---
phase: 08-ai-tutor-enhancement
plan: 02
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - native-app-wpf/Services/Phi4TutorService.cs
  - native-app-wpf/Services/ITutorService.cs
  - native-app-wpf/Controls/TutorChat.xaml.cs
  - native-app-wpf/Models/TutorContext.cs
autonomous: true

must_haves:
  truths:
    - Tutor uses Socratic method (guiding questions, not direct answers)
    - Tutor receives full lesson content (theory, examples, key points) as context
    - Tutor knows current challenge context (starter code, expected output)
    - System prompt rewritten to enforce Socratic teaching style
  artifacts:
    - path: native-app-wpf/Services/Phi4TutorService.cs
      provides: Socratic system prompt and full lesson context injection
      contains: "Socratic method", "guiding questions", "lessonContent"
    - path: native-app-wpf/Services/ITutorService.cs
      provides: Extended TutorContext with lesson content fields
      contains: "LessonTheory", "LessonExamples", "LessonKeyPoints"
    - path: native-app-wpf/Models/TutorContext.cs
      provides: Structured context model for lesson content
      exports: ["LessonTheory", "LessonExamples", "LessonKeyPoints", "ChallengeStarterCode", "ChallengeExpectedOutput"]
  key_links:
    - from: TutorChat.UpdateContext
      to: Phi4TutorService.BuildPrompt
      via: TutorContext with lesson content
      pattern: "lessonContent.*theory.*examples"
---

<objective>
Rewrite the tutor's system prompt to use Socratic method and inject full lesson content (theory, examples, key points) into the context.

Purpose: Current tutor gives direct answers. The Socratic method guides students to discover answers through questions, which improves learning retention. Full lesson context ensures the tutor knows what concepts the student is working with.
Output: New Socratic system prompt, extended TutorContext with lesson content fields, updated context passing from UI to service.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@native-app-wpf/Services/ITutorService.cs
@native-app-wpf/Services/Phi4TutorService.cs
@native-app-wpf/Controls/TutorChat.xaml.cs

## Current System Prompt (in Phi4TutorService.BuildPrompt)

```csharp
sb.AppendLine("<|system|>");
sb.AppendLine("You are a friendly and knowledgeable programming tutor helping students learn to code.");
sb.AppendLine("Guidelines:");
sb.AppendLine("- Give clear, concise explanations suitable for beginners");
sb.AppendLine("- Use examples when helpful, but keep them short");
sb.AppendLine("- If the student has an error, explain what went wrong and guide them to fix it");
sb.AppendLine("- Encourage good coding practices");
sb.AppendLine("- Be supportive and patient");
sb.AppendLine("- Keep responses focused and under 200 words unless more detail is needed");
```

## Current TutorContext (in ITutorService.cs)

```csharp
public class TutorContext
{
    public string? CurrentLanguage { get; set; }
    public string? LessonTitle { get; set; }
    public string? LessonContent { get; set; }  // Currently unused/generic
    public string? UserCode { get; set; }
    public string? ExecutionError { get; set; }
    public string? ExpectedOutput { get; set; }
}
```

## Current Context Usage (in Phi4TutorService.BuildPrompt)

Only uses:
- CurrentLanguage (language name)
- LessonTitle (title only)
- UserCode (if provided)
- ExecutionError (if provided)

Does NOT use LessonContent field - it's ignored.

## Lesson Content Structure

Lessons contain multiple content sections with types:
- THEORY: Concept explanations
- EXAMPLE: Code demonstrations  
- KEY_POINT: Important takeaways
- ANALOGY: Relatable comparisons
- WARNING: Common pitfalls
- LEGACY_COMPARISON: Old vs new patterns

Each lesson.json has a "content" array with section objects containing "type" and "content" fields.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create structured TutorContext model with lesson content fields</name>
  <files>native-app-wpf/Models/TutorContext.cs</files>
  <action>
Create a new file native-app-wpf/Models/TutorContext.cs with a structured context model that captures full lesson content:

```csharp
using System.Collections.Generic;

namespace CodeTutor.Wpf.Models;

/// <summary>
/// Structured context for the AI tutor including full lesson content
/// </summary>
public class TutorContext
{
    // Basic context
    public string? CurrentLanguage { get; set; }
    public string? LessonTitle { get; set; }
    public string? ModuleTitle { get; set; }
    public string? CourseName { get; set; }
    
    // Full lesson content sections
    public List<ContentSection> LessonSections { get; set; } = new();
    
    // Aggregated content for easy access
    public string? LessonTheory { get; set; }
    public string? LessonExamples { get; set; }
    public string? LessonKeyPoints { get; set; }
    public string? LessonAnalogies { get; set; }
    public string? LessonWarnings { get; set; }
    
    // Challenge context
    public string? ChallengeTitle { get; set; }
    public string? ChallengeDescription { get; set; }
    public string? ChallengeStarterCode { get; set; }
    public string? ChallengeExpectedOutput { get; set; }
    
    // Student state
    public string? UserCode { get; set; }
    public string? ExecutionError { get; set; }
    public string? ActualOutput { get; set; }
    public int? HintLevel { get; set; } // 0=none, 1=nudge, 2=guidance, 3=solution
    
    /// <summary>
    /// Gets all THEORY sections combined
    /// </summary>
    public string GetCombinedTheory()
    {
        return LessonTheory ?? string.Join("\n\n", 
            LessonSections.Where(s => s.Type == "THEORY")
                         .Select(s => s.Content));
    }
    
    /// <summary>
    /// Gets all EXAMPLE sections combined
    /// </summary>
    public string GetCombinedExamples()
    {
        return LessonExamples ?? string.Join("\n\n", 
            LessonSections.Where(s => s.Type == "EXAMPLE")
                         .Select(s => $"```{CurrentLanguage?.ToLower() ?? "text"}\n{s.Content}\n```"));
    }
    
    /// <summary>
    /// Gets all KEY_POINT sections as bullet points
    /// </summary>
    public string GetCombinedKeyPoints()
    {
        return LessonKeyPoints ?? string.Join("\n", 
            LessonSections.Where(s => s.Type == "KEY_POINT")
                         .Select(s => $"• {s.Content}"));
    }
}

/// <summary>
/// Represents a single content section from a lesson
/// </summary>
public class ContentSection
{
    public string Type { get; set; } = string.Empty; // THEORY, EXAMPLE, KEY_POINT, etc.
    public string Content { get; set; } = string.Empty;
    public string? Title { get; set; }
}
```

This replaces the inline TutorContext class in ITutorService.cs.
  </action>
  <verify>Test-Path native-app-wpf/Models/TutorContext.cs</verify>
  <done>TutorContext.cs exists with all required properties and helper methods</done>
</task>

<task type="auto">
  <name>Task 2: Update ITutorService to use new TutorContext model</name>
  <files>native-app-wpf/Services/ITutorService.cs</files>
  <action>
Update ITutorService.cs to:
1. Remove the inline TutorContext class definition
2. Add using statement: `using CodeTutor.Wpf.Models;`
3. Keep the ITutorService interface unchanged (it already uses TutorContext)

The file should look like:

```csharp
using CodeTutor.Wpf.Models;

namespace CodeTutor.Wpf.Services;

public interface ITutorService
{
    bool IsModelLoaded { get; }
    int LoadingProgress { get; }
    event EventHandler<int>? LoadingProgressChanged;
    Task LoadModelAsync(CancellationToken cancellationToken = default);
    IAsyncEnumerable<string> SendMessageAsync(
        string userMessage,
        TutorContext context,
        IReadOnlyList<TutorMessage> history,
        CancellationToken cancellationToken = default);
    void UnloadModel();
}
```

Do NOT modify method signatures - just remove the TutorContext class and add the using.
  </action>
  <verify>! (Select-String -Path native-app-wpf/Services/ITutorService.cs -Pattern "class TutorContext") -and (Select-String -Path native-app-wpf/Services/ITutorService.cs -Pattern "using CodeTutor.Wpf.Models")</verify>
  <done>ITutorService imports TutorContext from Models namespace, no duplicate class definition</done>
</task>

<task type="auto">
  <name>Task 3: Rewrite Phi4TutorService with Socratic system prompt and full context injection</name>
  <files>native-app-wpf/Services/Phi4TutorService.cs</files>
  <action>
Rewrite the BuildPrompt method in Phi4TutorService.cs to:

1. Add using statement: `using CodeTutor.Wpf.Models;`
2. Replace the entire system prompt section with Socratic method prompt
3. Add full lesson content context injection

**NEW Socratic System Prompt:**
```csharp
sb.AppendLine("<|system|>");
sb.AppendLine("You are a Socratic programming tutor. Your goal is to guide students to discover answers themselves, not to give them direct solutions.");
sb.AppendLine("");
sb.AppendLine("Core Principles:");
sb.AppendLine("- Ask guiding questions that lead students toward understanding");
sb.AppendLine("- Never give complete code solutions - help them build solutions step by step");
sb.AppendLine("- When explaining concepts, use the lesson content provided below");
sb.AppendLine("- For errors: ask what they think went wrong before explaining");
sb.AppendLine("- For challenges: provide hints at increasing levels (nudge → guidance → partial solution)");
sb.AppendLine("- Encourage debugging by asking them to trace through their code mentally");
sb.AppendLine("- Celebrate partial progress and correct thinking");
sb.AppendLine("- Keep responses conversational and encouraging");
sb.AppendLine("- Maximum 150 words per response unless complex explanation needed");
sb.AppendLine("");
sb.AppendLine("Response Patterns:");
sb.AppendLine("- 'I'm stuck' → Ask what specific part is confusing, reference lesson theory");
sb.AppendLine("- 'Is this right?' → Ask them to test it and observe the output");
sb.AppendLine("- 'Getting error X' → Ask what they think causes X, then guide to fix");
sb.AppendLine("- 'How do I do Y?' → Break Y into steps, ask which step they need help with");
```

**NEW Context Injection (after system prompt, before history):**
```csharp
// Add full lesson context
sb.AppendLine("");
sb.AppendLine("=== LESSON CONTEXT ===");

if (!string.IsNullOrEmpty(context.CourseName))
    sb.AppendLine($"Course: {context.CourseName}");
if (!string.IsNullOrEmpty(context.ModuleTitle))
    sb.AppendLine($"Module: {context.ModuleTitle}");
if (!string.IsNullOrEmpty(context.LessonTitle))
    sb.AppendLine($"Lesson: {context.LessonTitle}");
if (!string.IsNullOrEmpty(context.CurrentLanguage))
    sb.AppendLine($"Language: {context.CurrentLanguage}");

// Inject lesson theory
var theory = context.GetCombinedTheory();
if (!string.IsNullOrEmpty(theory))
{
    sb.AppendLine("");
    sb.AppendLine("Lesson Theory:");
    sb.AppendLine(theory);
}

// Inject examples
var examples = context.GetCombinedExamples();
if (!string.IsNullOrEmpty(examples))
{
    sb.AppendLine("");
    sb.AppendLine("Code Examples from Lesson:");
    sb.AppendLine(examples);
}

// Inject key points
var keyPoints = context.GetCombinedKeyPoints();
if (!string.IsNullOrEmpty(keyPoints))
{
    sb.AppendLine("");
    sb.AppendLine("Key Points:");
    sb.AppendLine(keyPoints);
}

// Inject challenge context if available
if (!string.IsNullOrEmpty(context.ChallengeTitle))
{
    sb.AppendLine("");
    sb.AppendLine("=== CHALLENGE CONTEXT ===");
    sb.AppendLine($"Challenge: {context.ChallengeTitle}");
    if (!string.IsNullOrEmpty(context.ChallengeDescription))
        sb.AppendLine($"Description: {context.ChallengeDescription}");
    if (!string.IsNullOrEmpty(context.ChallengeExpectedOutput))
        sb.AppendLine($"Expected Output: {context.ChallengeExpectedOutput}");
    if (context.HintLevel.HasValue)
        sb.AppendLine($"Hint Level Requested: {context.HintLevel} (1=nudge, 2=guidance, 3=partial solution)");
}

// Inject student state
if (!string.IsNullOrEmpty(context.UserCode))
{
    sb.AppendLine("");
    sb.AppendLine("=== STUDENT'S CURRENT CODE ===");
    sb.AppendLine($"```{context.CurrentLanguage?.ToLower() ?? "text"}");
    sb.AppendLine(context.UserCode);
    sb.AppendLine("```");
}

if (!string.IsNullOrEmpty(context.ExecutionError))
{
    sb.AppendLine("");
    sb.AppendLine("=== EXECUTION ERROR ===");
    sb.AppendLine(context.ExecutionError);
}

if (!string.IsNullOrEmpty(context.ActualOutput))
{
    sb.AppendLine("");
    sb.AppendLine("=== ACTUAL OUTPUT ===");
    sb.AppendLine(context.ActualOutput);
}

sb.AppendLine("<|end|>");
```

Keep all other methods unchanged (LoadModelAsync, SendMessageAsync, GetLastGeneratedToken, etc.).
  </action>
  <verify>(Select-String -Path native-app-wpf/Services/Phi4TutorService.cs -Pattern "Socratic").Count -gt 0 -and (Select-String -Path native-app-wpf/Services/Phi4TutorService.cs -Pattern "LESSON CONTEXT").Count -gt 0</verify>
  <done>Phi4TutorService contains Socratic system prompt and full lesson context injection</done>
</task>

<task type="auto">
  <name>Task 4: Update TutorChat to populate full lesson context</name>
  <files>native-app-wpf/Controls/TutorChat.xaml.cs</files>
  <action>
Update the UpdateContext method and related code in TutorChat.xaml.cs to populate the new TutorContext fields:

1. Add using statement: `using CodeTutor.Wpf.Models;`
2. Replace the UpdateContext method to accept and populate full lesson context

**NEW UpdateContext approach:**

The UpdateContext method should accept a more comprehensive context object. However, since the method signature is called from outside, we'll work with what we have and enhance the context population:

```csharp
public void UpdateContext(TutorContext context)
{
    _currentContext = context ?? new TutorContext();
    
    // Ensure HintLevel defaults to 0 if not set
    if (!_currentContext.HintLevel.HasValue)
        _currentContext.HintLevel = 0;
}

/// <summary>
/// Updates context with lesson content loaded from lesson.json
/// </summary>
public void LoadLessonContext(
    string courseName,
    string moduleTitle,
    string lessonTitle,
    string language,
    List<ContentSection> lessonSections)
{
    _currentContext.CourseName = courseName;
    _currentContext.ModuleTitle = moduleTitle;
    _currentContext.LessonTitle = lessonTitle;
    _currentContext.CurrentLanguage = language;
    _currentContext.LessonSections = lessonSections ?? new List<ContentSection>();
    _currentContext.HintLevel = 0; // Reset hint level for new lesson
}

/// <summary>
/// Updates context with challenge-specific information
/// </summary>
public void LoadChallengeContext(
    string challengeTitle,
    string challengeDescription,
    string starterCode,
    string expectedOutput)
{
    _currentContext.ChallengeTitle = challengeTitle;
    _currentContext.ChallengeDescription = challengeDescription;
    _currentContext.ChallengeStarterCode = starterCode;
    _currentContext.ChallengeExpectedOutput = expectedOutput;
    _currentContext.HintLevel = 0; // Reset hint level for new challenge
}

/// <summary>
/// Updates student code and execution state
/// </summary>
public void UpdateStudentState(string userCode, string? executionError = null, string? actualOutput = null)
{
    _currentContext.UserCode = userCode;
    _currentContext.ExecutionError = executionError;
    _currentContext.ActualOutput = actualOutput;
}

/// <summary>
/// Sets the hint level for progressive hint requests
/// </summary>
public void SetHintLevel(int level)
{
    _currentContext.HintLevel = Math.Clamp(level, 0, 3);
}
```

Also update the QuickAction_Click method to set hint levels:
```csharp
private void QuickAction_Click(object sender, RoutedEventArgs e)
{
    if (sender is Button button && button.Tag is string action)
    {
        var prompt = action switch
        {
            "explain" => "Can you explain what this code does step by step?",
            "error" => "I'm getting an error. Can you help me understand what's wrong?",
            "hint" => SetHintLevelAndPrompt(1), // Start with nudge
            _ => string.Empty
        };

        if (!string.IsNullOrEmpty(prompt))
        {
            InputTextBox.Text = prompt;
            _ = SendMessageAsync();
        }
    }
}

private string SetHintLevelAndPrompt(int level)
{
    SetHintLevel(level);
    return "I'm stuck on this challenge. Can you give me a hint?";
}
```

Keep all other methods unchanged.
  </action>
  <verify>(Select-String -Path native-app-wpf/Controls/TutorChat.xaml.cs -Pattern "LoadLessonContext|LoadChallengeContext|SetHintLevel").Count -ge 3</verify>
  <done>TutorChat has methods to load lesson context, challenge context, and set hint levels</done>
</task>

<task type="auto">
  <name>Task 5: Build project to verify compilation</name>
  <files>native-app-wpf/</files>
  <action>
Build the WPF project to verify all changes compile correctly:

1. Build: `dotnet build native-app-wpf/CodeTutor.Wpf.csproj --configuration Release`

If build fails, check for:
- Missing using statements
- Type name conflicts
- Missing namespace imports
- Incorrect method signatures
  </action>
  <verify>dotnet build native-app-wpf/CodeTutor.Wpf.csproj --configuration Release -v quiet | Select-String "Build succeeded"</verify>
  <done>Build succeeds with 0 errors</done>
</task>

</tasks>

<verification>
Overall phase checks:
- [ ] TutorContext model has LessonTheory, LessonExamples, LessonKeyPoints properties
- [ ] Phi4TutorService uses Socratic system prompt
- [ ] Phi4TutorService injects full lesson context into prompts
- [ ] ITutorService references TutorContext from Models namespace
- [ ] TutorChat has LoadLessonContext, LoadChallengeContext, SetHintLevel methods
- [ ] Build succeeds with no errors
</verification>

<success_criteria>
- Socratic system prompt replaces direct-answer prompt
- TutorContext has structured fields for all lesson content types
- Phi4TutorService.BuildPrompt injects THEORY, EXAMPLE, KEY_POINT content
- TutorChat provides methods to populate lesson and challenge context
- ITutorService correctly references external TutorContext model
- All code compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/08-ai-tutor-enhancement/08-02-SUMMARY.md`
</output>
