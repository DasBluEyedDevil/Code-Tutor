<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# Using this curriculum as a foundation, create the necessary modules, their associated lessons, and all lesson content for Phase 1.  Utilize web searches to ensure the most updated and accurate learning content is provided.

The following comprehensive guide details **Phase 1: Modern Java Fundamentals with Java 23+**, designed to transition developers immediately into the latest language standards.

This curriculum treats "Preview" features in Java 23 (like Stream Gatherers and Structured Concurrency) as primary tools, as they represent the finalized direction of the platform for 2026 enterprise architecture.

***

# Phase 1: Modern Java Fundamentals with Java 23+ (Weeks 1-10)

## Module 1.1: Development Environment \& Java 23 Setup (Weeks 1-2)

**Goal:** Establish a "modern-first" workflow where new Java 23 syntax is the default, not an alternative.

### Lesson 1.1.1: The Modern Java Toolchain

* **Topic:** Installing JDK 23 and configuring the "Preview" ecosystem.
* **Key Concepts:**
    * **JDK 23 Installation:** Using SDKMAN or native installers.
    * **Enable Preview:** Understanding why `--enable-preview` is necessary for JEP 476/477/467 features.
    * **Tooling:** Configuring IntelliJ IDEA 2024+ language level to "23 (Preview)".
* **Content Detail:**
    * Legacy Java required verbose `public static void main` and explicit class wrappers. Java 23 enables **Implicitly Declared Classes** (JEP 477), allowing scripts to run like Python or Node.js files.
    * **Configuration:**

```bash
# Compile with preview
javac --release 23 --enable-preview Main.java
# Run with preview
java --enable-preview Main
```


### Lesson 1.1.2: Implicitly Declared Classes \& Instance Main

* **Topic:** Writing concise, single-file programs without boilerplate.
* **Code Example:**

```java
// Old Way (Java 20 and below)
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello");
    }
}

// Modern Way (Java 23+)
void main() {
    println("Hello, World!"); // Static import from java.io.IO via implicit java.base import
}
```

* **Deep Dive:** The "Implicit Class" is automatically generated by the compiler. It resides in the unnamed package. All methods are instance methods, not static, allowing easier extension later.


### Lesson 1.1.3: Module Import Declarations (JEP 476)

* **Topic:** Importing entire modules to avoid header clutter.
* **Concept:** Instead of 50 lines of `import java.util.*;` and `import java.io.*;`, you import the defining module.
* **Code Example:**

```java
import module java.base; // Imports java.util, java.io, java.nio, etc.
import module java.sql;  // Imports java.sql, javax.sql

void main() {
    // List, Map, and Stream are instantly available
    List<String> names = List.of("Java", "23");
    println(names);
}
```


### Lesson 1.1.4: Markdown Documentation (JEP 467)

* **Topic:** Writing Javadoc in Markdown instead of HTML.
* **Syntax:** Use `///` instead of `/** ... */`.
* **Code Example:**

```java
/// # User Validation Service
/// Validates user input against *corporate policies*.
///
/// ## Usage
/// ```java
/// var validator = new Validator();
/// validator.check("user@example.com");
/// ```
///
/// - Returns: `true` if valid
/// - Throws: [IllegalArgumentException] on failure
public boolean check(String email) { ... }
```


**Assessment:** Create a CLI tool "SysInfo" in a single file that uses `import module java.base`, Markdown docs, and prints system properties using `void main()`.

***

## Module 1.2: Advanced Type System \& Pattern Matching (Weeks 3-4)

**Goal:** Eliminate "type pollution" and unnecessary casting using Data-Oriented Programming (DOP).

### Lesson 1.2.1: Data Modeling with Records \& Sealed Types

* **Topic:** Creating immutable, precise domain models.
* **Key Concepts:**
    * **Records:** Transparent data carriers.
    * **Sealed Classes:** Restricting inheritance to a known set of subclasses (algebraic data types).
* **Code Example:**

```java
public sealed interface PaymentMethod permits CreditCard, PayPal, Crypto {}
public record CreditCard(String number, String expiry) implements PaymentMethod {}
public record PayPal(String email) implements PaymentMethod {}
public record Crypto(String walletAddress) implements PaymentMethod {}
```


### Lesson 1.2.2: Pattern Matching for Switch \& Primitives (JEP 455)

* **Topic:** Handling logic based on *shape* and *data*, not just values. Now supports primitives in `switch`.
* **Code Example:**

```java
// JEP 455: Primitive patterns in switch
void process(Object input) {
    switch (input) {
        case Integer i when i > 100 -> println("Large Integer: " + i);
        case int i -> println("Small int: " + i); // Matches unboxed primitive
        case byte b -> println("Byte: " + b);
        case CreditCard(var no, var exp) -> println("Card ending in " + no.substring(12));
        case null -> println("Null input");
        default -> println("Unknown");
    }
}
```


### Lesson 1.2.3: Flexible Constructor Bodies (JEP 492)

* **Topic:** Validating arguments *before* calling `super()`.
* **Concept:** Previously, `super()` had to be the very first line. Now, you can run logic first (as long as it doesn't touch `this`).
* **Code Example:**

```java
public class PositiveBigInt extends BigInteger {
    public PositiveBigInt(long value) {
        if (value < 0) throw new IllegalArgumentException("Must be positive");
        // Logic *before* super is now legal
        super(String.valueOf(value));
    }
}
```


**Assessment:** Build a "Financial Transaction Processor" that uses sealed interfaces for transaction types and a `switch` expression with pattern matching (including primitive guards) to calculate fees.

***

## Module 1.3: Modern Concurrency with Virtual Threads 2.0 (Weeks 5-6)

**Goal:** Move from "Reactive/Async" complexity to "Synchronous-style" simplicity with high throughput.

### Lesson 1.3.1: Virtual Threads vs. Platform Threads

* **Topic:** The "One Thread Per Request" model reborn.
* **Concept:** Virtual threads are cheap (approx. 200 bytes). You can create millions. They unmount from the CPU when blocked (I/O), making non-blocking code look blocking.
* **Code Example:**

```java
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    IntStream.range(0, 10_000).forEach(i -> {
        executor.submit(() -> {
            Thread.sleep(Duration.ofSeconds(1)); // Unmounts, doesn't block OS thread
            return i;
        });
    });
}
```


### Lesson 1.3.2: Structured Concurrency (JEP 480)

* **Topic:** Treating multiple concurrent tasks as a single unit of work.
* **Concept:** If one subtask fails, the scope can automatically cancel others (short-circuiting).
* **Code Example:**

```java
try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
    var userTask = scope.fork(() -> fetchUser(id));
    var ordersTask = scope.fork(() -> fetchOrders(id));

    scope.join(); // Wait for all
    scope.throwIfFailed(); // Propagate error if any failed

    return new Dashboard(userTask.get(), ordersTask.get());
}
```


### Lesson 1.3.3: Scoped Values (JEP 487)

* **Topic:** A high-performance, immutable alternative to `ThreadLocal`.
* **Concept:** Pass implicit context (like Transaction IDs or User Principals) down the stack safely.
* **Code Example:**

```java
public final static ScopedValue<User> CURRENT_USER = ScopedValue.newInstance();

void serve() {
    User user = authenticate();
    ScopedValue.where(CURRENT_USER, user).run(() -> {
        processRequest(); // Can access CURRENT_USER.get() without passing args
    });
}
```


**Assessment:** Create a "Travel Booking Engine" that fetches Flights, Hotels, and Cars in parallel using `StructuredTaskScope`. If the Flight search fails, the Hotel search should be automatically cancelled.

***

## Module 1.4: Stream API \& Data Processing (Weeks 7-8)

**Goal:** Perform complex data transformation and parallel math purely in Java.

### Lesson 1.4.1: Stream Gatherers (JEP 485)

* **Topic:** Custom intermediate operations (the missing link in Streams).
* **Concept:** Standard streams support `map` (1-to-1) and `filter` (1-to-0/1). Gatherers support many-to-many, sliding windows, and stateful transformations.
* **Built-in Gatherers:** `windowFixed`, `windowSliding`, `fold`.
* **Code Example:**

```java
// Group elements into windows of 3
var windows = Stream.of(1, 2, 3, 4, 5)
    .gather(Gatherers.windowFixed(3))
    .toList(); 
// Result: [[1, 2, 3], [4, 5]]
```


### Lesson 1.4.2: Vector API (JEP 469)

* **Topic:** SIMD (Single Instruction, Multiple Data) programming in Java.
* **Use Case:** Heavy math, image processing, AI inference.
* **Code Example:**

```java
var species = IntVector.SPECIES_PREFERRED;
var v1 = IntVector.fromArray(species, array1, 0);
var v2 = IntVector.fromArray(species, array2, 0);
var result = v1.add(v2); // Adds 4, 8, or 16 integers at once depending on CPU
result.intoArray(output, 0);
```


**Assessment:** Implement a "Stock Moving Average" calculator using Stream Gatherers (`windowSliding`) and a high-performance "Matrix Multiplier" using the Vector API.

***

## Module 1.5: Memory Management \& Performance (Weeks 9-10)

**Goal:** Understand the low-level machinery of modern Java (GC and Native Access).

### Lesson 1.5.1: Generational ZGC (JEP 474)

* **Topic:** The new default for low-latency.
* **Concept:** ZGC is now generational, meaning it separates "young" (short-lived) objects from "old" ones. This boosts throughput while maintaining <1ms pause times.
* **Configuration:** `-XX:+UseZGC` (Generational is now default in Java 23+).


### Lesson 1.5.2: Class-File API (JEP 466)

* **Topic:** Parsing and generating bytecode without ASM.
* **Code Example:**

```java
ClassFile.of().parse(path).methods().forEach(m -> 
    println("Method: " + m.methodName())
);
```


### Lesson 1.5.3: Foreign Function \& Memory (FFM) API

* **Topic:** Calling C/C++ libraries safely without JNI.
* **Concept:** `Arena` manages memory lifecycle (off-heap). `Linker` calls native code.
* **Code Example:**

```java
try (var arena = Arena.ofConfined()) {
    // Allocate off-heap memory
    MemorySegment cString = arena.allocateFrom("Hello Native World");
    // Pass 'cString' to a C function (conceptually)
}
```


**Assessment:** Build a "System Monitor" that uses FFM to call a native OS function (e.g., `getpid` or `strlen` from standard C library) and parses a `.class` file to list its methods using the Class-File API.
<span style="display:none">[^1][^10][^11][^12][^13][^14][^15][^16][^17][^18][^19][^2][^20][^21][^22][^23][^24][^25][^26][^27][^28][^29][^3][^30][^31][^32][^33][^34][^35][^36][^37][^38][^39][^4][^40][^41][^42][^43][^44][^45][^46][^47][^48][^49][^5][^50][^51][^52][^53][^54][^55][^56][^57][^58][^59][^6][^60][^7][^8][^9]</span>

<div align="center">‚ÅÇ</div>

[^1]: Java-Curriculum.md

[^2]: https://openjdk.org/jeps/476

[^3]: https://foojay.io/today/exploring-new-features-in-jdk-23-simplifying-java-with-module-import-declarations-with-jep-476/

[^4]: https://www.infoq.com/news/2024/05/jep467-markdown-in-javadoc/

[^5]: https://openjdk.org/jeps/455

[^6]: https://www.youtube.com/watch?v=XF1z1DRrZOs

[^7]: https://www.infoq.com/news/2024/05/simplifying-java-module-import/

[^8]: https://payara.fish/blog/nugget-friday-simplify-module-imports-in-java-23/

[^9]: https://openjdk.org/jeps/467

[^10]: https://foojay.io/today/exploring-new-features-in-jdk-23-builder-pattern-simplicity-with-jep-455-primitive-types-in-patterns-instanceof-and-switch-preview/

[^11]: https://www.happycoders.eu/java/java-24-features/

[^12]: https://www.youtube.com/watch?v=mSYA3cZ5o6c

[^13]: https://www.reddit.com/r/java/comments/1ctgyy3/module_imports_in_java_23/

[^14]: https://www.youtube.com/watch?v=hEWU2OMtNnw

[^15]: https://docs.oracle.com/en/java/javase/23/language/pattern-matching-switch.html

[^16]: https://builds.shipilev.net/backports-monitor/release-notes-23.html

[^17]: https://hanno.codes/2024/09/17/java-23-has-arrived/

[^18]: https://docs.oracle.com/en/java/javase/23/language/module-import-declarations.html

[^19]: https://docs.oracle.com/en/java/javase/25/javadoc/using-markdown-documentation-comments.html

[^20]: https://www.youtube.com/watch?v=tqBV4MZ-qSM

[^21]: https://openjdk.org/jeps/492

[^22]: https://metadesignsolutions.com/java-22-released-virtual-threads-2-0-ffi-and-new-gc-optimizations/

[^23]: https://www.happycoders.eu/java/java-23-features/

[^24]: https://openjdk.org/jeps/487

[^25]: https://openjdk.org/jeps/485

[^26]: https://www.youtube.com/watch?v=_C3adaExyi0

[^27]: https://www.jvm-weekly.com/p/everything-you-might-have-missed-30c

[^28]: https://www.danvega.dev/blog/2024/09/12/jdk-23-first-look

[^29]: https://horstmann.com/unblog/2024-10-01/index.html

[^30]: https://blogs.oracle.com/java/the-arrival-of-java-23

[^31]: https://javascript.plainenglish.io/java-26-is-coming-and-its-about-to-redefine-what-fast-really-means-023fe1686ff0

[^32]: https://www.youtube.com/watch?v=K-LyK5LU3mM

[^33]: https://dev.to/hyperskill_academy/modern-java-features-part-2-from-java-22-to-25-20gk

[^34]: https://www.reddit.com/r/java/comments/1f7f85k/jep_485_stream_gatherers_new_candidate_jep/

[^35]: https://inside.java/2024/10/23/java-and-ai/

[^36]: https://dev.to/code_performance/mastering-java-24-a-deep-dive-into-the-revolutionary-apis-that-will-transform-your-development-3bg0

[^37]: https://openjdk.org/jeps/480

[^38]: https://www.youtube.com/watch?v=7tfUJLUbZiM

[^39]: https://docs.oracle.com/en/java/javase/25/core/stream-gatherers.html

[^40]: https://blog.jetbrains.com/idea/2024/09/jep-explained-a-series-of-interviews-on-java-23-features/

[^41]: https://michalpiotrowski.dev/2024/08/08/current-state-of-gc-in-java/

[^42]: https://www.youtube.com/watch?v=H4WPgHVp6gQ

[^43]: https://www.happycoders.eu/java/foreign-function-memory-api/

[^44]: https://docs.oracle.com/en/graalvm/jdk/23/docs/reference-manual/native-image/debugging-and-diagnostics/JFR/

[^45]: https://www.infoq.com/news/2024/05/java-zgc-update/

[^46]: https://foojay.io/today/java-23-has-arrived-and-it-brings-a-truckload-of-changes/

[^47]: https://www.baeldung.com/java-foreign-memory-access

[^48]: https://www.youtube.com/watch?v=IluRn8ecuCo

[^49]: https://www.youtube.com/watch?v=nTRHBfHPBa8

[^50]: https://inside.java/2024/09/17/jdk-23-available/

[^51]: https://blog.leadingedje.com/post/goingnative/foreignfunctionandmemory.html

[^52]: https://www.morling.dev/blog/tracking-java-native-memory-with-jdk-flight-recorder/

[^53]: https://www.jrebel.com/blog/whats-new-java-23

[^54]: https://pretius.com/blog/java-23-features

[^55]: https://docs.oracle.com/en/java/javase/22/core/foreign-function-and-memory-api.html

[^56]: https://dev.java/learn/security/monitor/

[^57]: https://www.reddit.com/r/java/comments/1fs731a/3_permanent_features_in_java_23/

[^58]: https://www.innoq.com/en/articles/2025/04/java-class-file-api/

[^59]: https://www.youtube.com/watch?v=iwmVbeiA42E

[^60]: https://foojay.io/today/custom-jfr-events-a-short-introduction/

