#!/usr/bin/env python3
"""
Add Module 21 (React Full-Stack Capstone) with lessons 4-6 to JavaScript course
"""
import json

def create_module_21():
    module_21 = {
        "id": "module-21",
        "title": "Module 21: React Full-Stack Capstone",
        "description": "Build a complete full-stack React application with authentication, state management, and protected routes. This capstone combines frontend components, authentication flows, and routing into a production-ready application.",
        "difficulty": "advanced",
        "estimatedHours": 2,
        "lessons": [
            {
                "id": "21.4",
                "title": "React Components & State",
                "moduleId": "module-21",
                "order": 4,
                "estimatedMinutes": 45,
                "difficulty": "advanced",
                "contentSections": [
                    {
                        "type": "CONCEPT",
                        "title": "Functional Components with TypeScript",
                        "content": "Modern React uses functional components with hooks instead of class components. Functional components are:\n\n- **Simpler**: Less boilerplate than class components\n- **Composable**: Easier to share stateful logic via custom hooks\n- **Testable**: Easier to test pure functions than classes\n\nWith TypeScript, we add strong typing to our components, props, and state, catching errors at compile time rather than runtime.\n\n**Component Signature**\nA typed React component is a function that takes props and returns JSX:\n```typescript\ninterface MyComponentProps {\n  title: string;\n  onAction: () => void;\n}\n\nconst MyComponent: React.FC<MyComponentProps> = ({ title, onAction }) => {\n  return <div onClick={onAction}>{title}</div>;\n};\n```\n\n**Common Hook Patterns**\n- `useState`: Manage local component state\n- `useEffect`: Handle side effects (data fetching, subscriptions)\n- `useContext`: Access values from context without prop drilling"
                    },
                    {
                        "type": "CONCEPT",
                        "title": "useState and useEffect Hooks",
                        "content": "**useState Hook**\nThe `useState` hook lets functional components have state. Unlike class components, you can call it multiple times:\n\n```typescript\nconst [count, setCount] = useState<number>(0);\nconst [name, setName] = useState<string>('');\n```\n\nTypeScript infers the type from the initial value, or you can explicitly type it.\n\n**useEffect Hook**\nThe `useEffect` hook runs side effects. It takes two arguments:\n1. A function to run\n2. A dependency array that controls when it runs:\n\n```typescript\n// Runs once on mount\nuseEffect(() => {\n  console.log('Component mounted');\n}, []);\n\n// Runs when 'userId' changes\nuseEffect(() => {\n  fetchUser(userId);\n}, [userId]);\n\n// Runs after every render (no dependency array)\nuseEffect(() => {\n  console.log('Component rendered');\n});\n```\n\n**Cleanup Function**\nReturn a cleanup function to prevent memory leaks:\n\n```typescript\nuseEffect(() => {\n  const subscription = api.subscribe(onMessage);\n  return () => subscription.unsubscribe(); // Cleanup\n}, []);\n```"
                    },
                    {
                        "type": "CONCEPT",
                        "title": "Props Typing with TypeScript",
                        "content": "TypeScript props ensure components are used correctly. Define an interface for each component's props:\n\n**Basic Props**\n```typescript\ninterface ButtonProps {\n  label: string;\n  onClick: () => void;\n  disabled?: boolean;  // Optional with ?\n}\n```\n\n**Common Patterns**\n- **Optional props**: Use `?` to make a prop optional\n- **Union types**: `status: 'loading' | 'success' | 'error'`\n- **Event handlers**: `onChange: (value: string) => void`\n- **Children**: `children: React.ReactNode`\n- **Ref prop**: `ref: React.Ref<HTMLInputElement>`\n\n**Example with multiple prop types**\n```typescript\ninterface TaskCardProps {\n  id: string;\n  title: string;\n  completed: boolean;\n  onToggle: (id: string) => void;\n  onDelete: (id: string) => void;\n  priority?: 'low' | 'medium' | 'high';\n}\n\nconst TaskCard: React.FC<TaskCardProps> = ({\n  id,\n  title,\n  completed,\n  onToggle,\n  onDelete,\n  priority = 'medium'\n}) => {\n  return (\n    <div className={`task ${completed ? 'done' : ''}`}>\n      <h3>{title}</h3>\n      {priority && <span className=\"priority\">{priority}</span>}\n      <button onClick={() => onToggle(id)}>Toggle</button>\n      <button onClick={() => onDelete(id)}>Delete</button>\n    </div>\n  );\n};\n```"
                    },
                    {
                        "type": "CODE",
                        "title": "TaskList Component",
                        "content": "Create the main TaskList component that manages a list of tasks with TypeScript typing:",
                        "language": "typescript",
                        "code": "import React, { useState, useEffect } from 'react';\n\ninterface Task {\n  id: string;\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt: string;\n}\n\ninterface TaskListProps {\n  userId: string;\n  onTaskUpdate?: (task: Task) => void;\n}\n\nconst TaskList: React.FC<TaskListProps> = ({ userId, onTaskUpdate }) => {\n  const [tasks, setTasks] = useState<Task[]>([]);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Fetch tasks on component mount and when userId changes\n  useEffect(() => {\n    const fetchTasks = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        const response = await fetch(`/api/tasks?userId=${userId}`, {\n          headers: {\n            'Authorization': `Bearer ${localStorage.getItem('token')}`\n          }\n        });\n        \n        if (!response.ok) {\n          throw new Error(`Failed to fetch tasks: ${response.statusText}`);\n        }\n        \n        const data = await response.json();\n        setTasks(data.tasks);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Unknown error');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchTasks();\n  }, [userId]);\n\n  const handleToggleTask = async (taskId: string) => {\n    const task = tasks.find(t => t.id === taskId);\n    if (!task) return;\n\n    try {\n      const response = await fetch(`/api/tasks/${taskId}`, {\n        method: 'PATCH',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${localStorage.getItem('token')}`\n        },\n        body: JSON.stringify({ completed: !task.completed })\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to update task');\n      }\n\n      const updatedTask: Task = await response.json();\n      setTasks(tasks.map(t => t.id === taskId ? updatedTask : t));\n      onTaskUpdate?.(updatedTask);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Unknown error');\n    }\n  };\n\n  const handleDeleteTask = async (taskId: string) => {\n    try {\n      const response = await fetch(`/api/tasks/${taskId}`, {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bearer ${localStorage.getItem('token')}`\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to delete task');\n      }\n\n      setTasks(tasks.filter(t => t.id !== taskId));\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Unknown error');\n    }\n  };\n\n  if (loading) {\n    return <div className=\"task-list-loading\">Loading tasks...</div>;\n  }\n\n  if (error) {\n    return <div className=\"task-list-error\">Error: {error}</div>;\n  }\n\n  return (\n    <div className=\"task-list\">\n      <h2>Your Tasks ({tasks.length})</h2>\n      {tasks.length === 0 ? (\n        <p className=\"no-tasks\">No tasks yet. Create one to get started!</p>\n      ) : (\n        <ul className=\"tasks\">\n          {tasks.map(task => (\n            <li key={task.id}>\n              <div className=\"task-item\">\n                <input\n                  type=\"checkbox\"\n                  checked={task.completed}\n                  onChange={() => handleToggleTask(task.id)}\n                  className=\"task-checkbox\"\n                />\n                <div className=\"task-content\">\n                  <h3 className={task.completed ? 'completed' : ''}>\n                    {task.title}\n                  </h3>\n                  <p>{task.description}</p>\n                  <small>{new Date(task.createdAt).toLocaleDateString()}</small>\n                </div>\n                <button\n                  onClick={() => handleDeleteTask(task.id)}\n                  className=\"delete-btn\"\n                >\n                  Delete\n                </button>\n              </div>\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n};\n\nexport default TaskList;"
                    },
                    {
                        "type": "CODE",
                        "title": "TaskCard Component",
                        "content": "Create a reusable TaskCard component for individual task display:",
                        "language": "typescript",
                        "code": "import React from 'react';\n\ninterface TaskCardProps {\n  id: string;\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt: string;\n  onToggle: (id: string) => void;\n  onDelete: (id: string) => void;\n}\n\nconst TaskCard: React.FC<TaskCardProps> = ({\n  id,\n  title,\n  description,\n  completed,\n  createdAt,\n  onToggle,\n  onDelete\n}) => {\n  const formattedDate = new Date(createdAt).toLocaleDateString('en-US', {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric'\n  });\n\n  return (\n    <div className={`task-card ${completed ? 'completed' : ''}`}>\n      <div className=\"task-card-header\">\n        <input\n          type=\"checkbox\"\n          checked={completed}\n          onChange={() => onToggle(id)}\n          className=\"task-card-checkbox\"\n          aria-label={`Toggle task: ${title}`}\n        />\n        <h3 className=\"task-card-title\">{title}</h3>\n      </div>\n      \n      <p className=\"task-card-description\">{description}</p>\n      \n      <div className=\"task-card-footer\">\n        <span className=\"task-card-date\">Created: {formattedDate}</span>\n        <button\n          onClick={() => onDelete(id)}\n          className=\"task-card-delete-btn\"\n          aria-label={`Delete task: ${title}`}\n        >\n          Delete\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default TaskCard;"
                    },
                    {
                        "type": "CONCEPT",
                        "title": "Challenge: Extend the TaskList",
                        "content": "## Challenge: Add Filtering and Search\n\nExtend the TaskList component with:\n1. **Search functionality**: Filter tasks by title or description (case-insensitive)\n2. **Status filter**: Show only 'All', 'Active', or 'Completed' tasks\n3. **Sort options**: Sort by creation date (newest/oldest) or completion status\n\n**Requirements:**\n- Use useState hooks to manage filter state\n- Create separate functions for filtering logic\n- Update the UI to show current filter selections\n- Maintain TypeScript typing throughout\n- Keep API calls unchanged (filter on the client side)\n\n**Bonus Challenge:**\n- Add a \"Clear completed\" button that deletes all completed tasks\n- Implement pagination to show 10 tasks per page\n- Add an animation when tasks are marked complete"
                    }
                ]
            },
            {
                "id": "21.5",
                "title": "Authentication UI Flow",
                "moduleId": "module-21",
                "order": 5,
                "estimatedMinutes": 40,
                "difficulty": "advanced",
                "contentSections": [
                    {
                        "type": "CONCEPT",
                        "title": "Authentication Context Setup",
                        "content": "Authentication state needs to be accessible throughout your app without prop drilling. React Context is perfect for this.\n\n**Why Context for Auth?**\n- Store user identity and tokens globally\n- Avoid passing auth state through every component\n- Centralize login/logout logic\n- Enable automatic login on page refresh via localStorage\n\n**Context Structure**\nYour auth context should expose:\n- `user`: Current authenticated user (or null)\n- `token`: JWT token for API requests\n- `isLoading`: Whether auth check is in progress\n- `login(email, password)`: Authenticate user\n- `register(email, password, name)`: Create new account\n- `logout()`: Clear auth state\n\n**Types for Auth**\n```typescript\ninterface User {\n  id: string;\n  email: string;\n  name: string;\n  createdAt: string;\n}\n\ninterface AuthContextType {\n  user: User | null;\n  token: string | null;\n  isLoading: boolean;\n  login: (email: string, password: string) => Promise<void>;\n  register: (email: string, password: string, name: string) => Promise<void>;\n  logout: () => void;\n}\n```"
                    },
                    {
                        "type": "CONCEPT",
                        "title": "Form Validation & Error Handling",
                        "content": "Login and registration forms need to validate input before sending to the server.\n\n**Client-side Validation**\n- Email format check\n- Password strength requirements\n- Required field checks\n- Display clear error messages\n\n**Common Validation Rules**\n```typescript\ninterface ValidationErrors {\n  email?: string;\n  password?: string;\n  name?: string;\n  [key: string]: string | undefined;\n}\n\nconst validateEmail = (email: string): boolean => {\n  return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n};\n\nconst validatePassword = (password: string): boolean => {\n  return password.length >= 8;\n};\n\nconst validateRegistration = (email: string, password: string, name: string): ValidationErrors => {\n  const errors: ValidationErrors = {};\n  if (!validateEmail(email)) errors.email = 'Invalid email format';\n  if (!validatePassword(password)) errors.password = 'Password must be at least 8 characters';\n  if (name.trim().length < 2) errors.name = 'Name must be at least 2 characters';\n  return errors;\n};\n```\n\n**Server Error Handling**\nWhen the API returns an error, display it to the user:\n- 400 Bad Request: Show field-specific errors\n- 401 Unauthorized: Show \"Invalid credentials\"\n- 409 Conflict: Show \"Email already exists\"\n- 500 Server Error: Show generic message + support contact"
                    },
                    {
                        "type": "CONCEPT",
                        "title": "Token Storage & Security",
                        "content": "Tokens must be stored securely and sent with API requests.\n\n**localStorage vs sessionStorage**\n- `localStorage`: Persists until explicitly cleared (survives page refresh)\n- `sessionStorage`: Cleared when tab closes\n- `Memory`: Lost on refresh (not persistent)\n\nFor authentication, use `localStorage` so users stay logged in, but understand the tradeoff:\n\n**Security Considerations**\n```typescript\n// Store token after login\nconst storeToken = (token: string) => {\n  localStorage.setItem('token', token);\n};\n\n// Retrieve token for API requests\nconst getToken = (): string | null => {\n  return localStorage.getItem('token');\n};\n\n// Clear token on logout\nconst clearToken = () => {\n  localStorage.removeItem('token');\n};\n\n// Add token to every API request\nconst fetchWithAuth = async (url: string, options: RequestInit = {}) => {\n  const token = getToken();\n  return fetch(url, {\n    ...options,\n    headers: {\n      ...options.headers,\n      'Authorization': `Bearer ${token}`,\n      'Content-Type': 'application/json'\n    }\n  });\n};\n```\n\n**Important**: Never store passwords. Only store JWT tokens. The token expires (typically in hours) so periodic re-authentication is required."
                    },
                    {
                        "type": "CODE",
                        "title": "AuthContext with localStorage",
                        "content": "Create an auth context that persists tokens and user info:",
                        "language": "typescript",
                        "code": "import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\n\ninterface User {\n  id: string;\n  email: string;\n  name: string;\n  createdAt: string;\n}\n\ninterface AuthContextType {\n  user: User | null;\n  token: string | null;\n  isLoading: boolean;\n  login: (email: string, password: string) => Promise<void>;\n  register: (email: string, password: string, name: string) => Promise<void>;\n  logout: () => void;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [token, setToken] = useState<string | null>(null);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n\n  // Restore auth state from localStorage on mount\n  useEffect(() => {\n    const restoreAuth = async () => {\n      try {\n        const storedToken = localStorage.getItem('token');\n        if (storedToken) {\n          // Verify token is still valid by fetching current user\n          const response = await fetch('/api/auth/me', {\n            headers: {\n              'Authorization': `Bearer ${storedToken}`\n            }\n          });\n          if (response.ok) {\n            const userData: User = await response.json();\n            setToken(storedToken);\n            setUser(userData);\n          } else {\n            // Token expired or invalid\n            localStorage.removeItem('token');\n          }\n        }\n      } catch (error) {\n        console.error('Failed to restore auth:', error);\n        localStorage.removeItem('token');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    restoreAuth();\n  }, []);\n\n  const login = async (email: string, password: string) => {\n    try {\n      const response = await fetch('/api/auth/login', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ email, password })\n      });\n\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.message || 'Login failed');\n      }\n\n      const data = await response.json();\n      const newToken = data.token;\n      const userData: User = data.user;\n\n      localStorage.setItem('token', newToken);\n      setToken(newToken);\n      setUser(userData);\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  const register = async (email: string, password: string, name: string) => {\n    try {\n      const response = await fetch('/api/auth/register', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ email, password, name })\n      });\n\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.message || 'Registration failed');\n      }\n\n      const data = await response.json();\n      const newToken = data.token;\n      const userData: User = data.user;\n\n      localStorage.setItem('token', newToken);\n      setToken(newToken);\n      setUser(userData);\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  const logout = () => {\n    localStorage.removeItem('token');\n    setToken(null);\n    setUser(null);\n  };\n\n  const value: AuthContextType = {\n    user,\n    token,\n    isLoading,\n    login,\n    register,\n    logout\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n};"
                    },
                    {
                        "type": "CODE",
                        "title": "Login Form Component",
                        "content": "Create a login form with validation and error handling:",
                        "language": "typescript",
                        "code": "import React, { useState } from 'react';\nimport { useAuth } from './AuthContext';\n\ninterface LoginFormProps {\n  onSuccess?: () => void;\n}\n\ninterface FormErrors {\n  email?: string;\n  password?: string;\n  submit?: string;\n}\n\nconst LoginForm: React.FC<LoginFormProps> = ({ onSuccess }) => {\n  const [email, setEmail] = useState<string>('');\n  const [password, setPassword] = useState<string>('');\n  const [errors, setErrors] = useState<FormErrors>({});\n  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);\n  const { login } = useAuth();\n\n  const validateForm = (): boolean => {\n    const newErrors: FormErrors = {};\n\n    if (!email) {\n      newErrors.email = 'Email is required';\n    } else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email)) {\n      newErrors.email = 'Invalid email format';\n    }\n\n    if (!password) {\n      newErrors.password = 'Password is required';\n    } else if (password.length < 8) {\n      newErrors.password = 'Password must be at least 8 characters';\n    }\n\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!validateForm()) return;\n\n    setIsSubmitting(true);\n    try {\n      await login(email, password);\n      // Reset form on success\n      setEmail('');\n      setPassword('');\n      setErrors({});\n      onSuccess?.();\n    } catch (error) {\n      setErrors({\n        submit: error instanceof Error ? error.message : 'Login failed'\n      });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  return (\n    <form className=\"login-form\" onSubmit={handleSubmit}>\n      <h2>Login</h2>\n\n      {errors.submit && (\n        <div className=\"form-error-message\">\n          {errors.submit}\n        </div>\n      )}\n\n      <div className=\"form-group\">\n        <label htmlFor=\"email\">Email</label>\n        <input\n          id=\"email\"\n          type=\"email\"\n          value={email}\n          onChange={(e) => {\n            setEmail(e.target.value);\n            if (errors.email) setErrors({ ...errors, email: undefined });\n          }}\n          className={errors.email ? 'input-error' : ''}\n          disabled={isSubmitting}\n          placeholder=\"you@example.com\"\n        />\n        {errors.email && (\n          <span className=\"field-error-message\">{errors.email}</span>\n        )}\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"password\">Password</label>\n        <input\n          id=\"password\"\n          type=\"password\"\n          value={password}\n          onChange={(e) => {\n            setPassword(e.target.value);\n            if (errors.password) setErrors({ ...errors, password: undefined });\n          }}\n          className={errors.password ? 'input-error' : ''}\n          disabled={isSubmitting}\n          placeholder=\"••••••••\"\n        />\n        {errors.password && (\n          <span className=\"field-error-message\">{errors.password}</span>\n        )}\n      </div>\n\n      <button\n        type=\"submit\"\n        disabled={isSubmitting}\n        className=\"submit-button\"\n      >\n        {isSubmitting ? 'Logging in...' : 'Login'}\n      </button>\n\n      <p className=\"form-footer\">\n        Don't have an account? <a href=\"/register\">Register here</a>\n      </p>\n    </form>\n  );\n};\n\nexport default LoginForm;"
                    },
                    {
                        "type": "CODE",
                        "title": "Register Form Component",
                        "content": "Create a registration form with password validation:",
                        "language": "typescript",
                        "code": "import React, { useState } from 'react';\nimport { useAuth } from './AuthContext';\n\ninterface RegisterFormProps {\n  onSuccess?: () => void;\n}\n\ninterface FormErrors {\n  email?: string;\n  password?: string;\n  name?: string;\n  submit?: string;\n}\n\nconst RegisterForm: React.FC<RegisterFormProps> = ({ onSuccess }) => {\n  const [name, setName] = useState<string>('');\n  const [email, setEmail] = useState<string>('');\n  const [password, setPassword] = useState<string>('');\n  const [confirmPassword, setConfirmPassword] = useState<string>('');\n  const [errors, setErrors] = useState<FormErrors>({});\n  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);\n  const { register } = useAuth();\n\n  const validateForm = (): boolean => {\n    const newErrors: FormErrors = {};\n\n    if (!name || name.trim().length < 2) {\n      newErrors.name = 'Name must be at least 2 characters';\n    }\n\n    if (!email) {\n      newErrors.email = 'Email is required';\n    } else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email)) {\n      newErrors.email = 'Invalid email format';\n    }\n\n    if (!password) {\n      newErrors.password = 'Password is required';\n    } else if (password.length < 8) {\n      newErrors.password = 'Password must be at least 8 characters';\n    } else if (password !== confirmPassword) {\n      newErrors.password = 'Passwords do not match';\n    }\n\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!validateForm()) return;\n\n    setIsSubmitting(true);\n    try {\n      await register(email, password, name);\n      // Reset form on success\n      setName('');\n      setEmail('');\n      setPassword('');\n      setConfirmPassword('');\n      setErrors({});\n      onSuccess?.();\n    } catch (error) {\n      setErrors({\n        submit: error instanceof Error ? error.message : 'Registration failed'\n      });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  return (\n    <form className=\"register-form\" onSubmit={handleSubmit}>\n      <h2>Create Account</h2>\n\n      {errors.submit && (\n        <div className=\"form-error-message\">\n          {errors.submit}\n        </div>\n      )}\n\n      <div className=\"form-group\">\n        <label htmlFor=\"name\">Full Name</label>\n        <input\n          id=\"name\"\n          type=\"text\"\n          value={name}\n          onChange={(e) => {\n            setName(e.target.value);\n            if (errors.name) setErrors({ ...errors, name: undefined });\n          }}\n          className={errors.name ? 'input-error' : ''}\n          disabled={isSubmitting}\n          placeholder=\"John Doe\"\n        />\n        {errors.name && (\n          <span className=\"field-error-message\">{errors.name}</span>\n        )}\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"email\">Email</label>\n        <input\n          id=\"email\"\n          type=\"email\"\n          value={email}\n          onChange={(e) => {\n            setEmail(e.target.value);\n            if (errors.email) setErrors({ ...errors, email: undefined });\n          }}\n          className={errors.email ? 'input-error' : ''}\n          disabled={isSubmitting}\n          placeholder=\"you@example.com\"\n        />\n        {errors.email && (\n          <span className=\"field-error-message\">{errors.email}</span>\n        )}\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"password\">Password</label>\n        <input\n          id=\"password\"\n          type=\"password\"\n          value={password}\n          onChange={(e) => {\n            setPassword(e.target.value);\n            if (errors.password) setErrors({ ...errors, password: undefined });\n          }}\n          className={errors.password ? 'input-error' : ''}\n          disabled={isSubmitting}\n          placeholder=\"••••••••\"\n        />\n        <small className=\"hint\">Must be at least 8 characters</small>\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"confirmPassword\">Confirm Password</label>\n        <input\n          id=\"confirmPassword\"\n          type=\"password\"\n          value={confirmPassword}\n          onChange={(e) => setConfirmPassword(e.target.value)}\n          className={errors.password ? 'input-error' : ''}\n          disabled={isSubmitting}\n          placeholder=\"••••••••\"\n        />\n      </div>\n\n      {errors.password && (\n        <div className=\"field-error-message\">{errors.password}</div>\n      )}\n\n      <button\n        type=\"submit\"\n        disabled={isSubmitting}\n        className=\"submit-button\"\n      >\n        {isSubmitting ? 'Creating account...' : 'Register'}\n      </button>\n\n      <p className=\"form-footer\">\n        Already have an account? <a href=\"/login\">Login here</a>\n      </p>\n    </form>\n  );\n};\n\nexport default RegisterForm;"
                    },
                    {
                        "type": "CONCEPT",
                        "title": "Challenge: Add Password Strength Indicator",
                        "content": "## Challenge: Visual Password Strength Feedback\n\nEnhance the RegisterForm component to:\n1. **Display a strength meter** showing password strength as user types\n2. **Color-code the meter**: Red (weak) → Yellow (fair) → Green (strong)\n3. **Show strength requirements**:\n   - At least 8 characters\n   - Contains both lowercase and uppercase letters\n   - Contains at least one number\n   - Contains at least one special character (!@#$%^&*)\n\n**Requirements:**\n- Create a separate PasswordStrengthMeter component\n- Use React state to track which requirements are met\n- Update the meter in real-time as user types\n- Disable submit button until password meets all requirements\n- Show a helpful message like \"Strong password!\"\n\n**Bonus Challenge:**\n- Add a \"Show password\" toggle button\n- Generate a password suggestion using a library\n- Store password preferences in context (optional requirements)"
                    }
                ]
            },
            {
                "id": "21.6",
                "title": "Protected Routes",
                "moduleId": "module-21",
                "order": 6,
                "estimatedMinutes": 35,
                "difficulty": "advanced",
                "contentSections": [
                    {
                        "type": "CONCEPT",
                        "title": "React Router Setup",
                        "content": "React Router is the standard library for client-side routing in React. It lets you:\n- Map URLs to components\n- Navigate without page reloads\n- Handle nested routes\n- Manage history\n\n**Core Concepts**\n```typescript\n// BrowserRouter: Wraps your app with routing context\n// Routes: Contains all route definitions\n// Route: Maps a path to a component\n// Navigate: Programmatically navigate to a new URL\n// useNavigate: Hook to get navigate function\n// useParams: Hook to get URL parameters\n// useLocation: Hook to get current location\n```\n\n**Basic Setup**\n```typescript\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport LoginPage from './pages/LoginPage';\nimport DashboardPage from './pages/DashboardPage';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/login\" element={<LoginPage />} />\n        <Route path=\"/dashboard\" element={<DashboardPage />} />\n        <Route path=\"/\" element={<Navigate to=\"/dashboard\" replace />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n```\n\n**Dynamic Routes**\nUse `:parameter` to create dynamic segments:\n```typescript\n// Route definition\n<Route path=\"/tasks/:id\" element={<TaskDetailPage />} />\n\n// Component accessing the parameter\nimport { useParams } from 'react-router-dom';\n\nfunction TaskDetailPage() {\n  const { id } = useParams<{ id: string }>();\n  return <div>Task {id}</div>;\n}\n```"
                    },
                    {
                        "type": "CONCEPT",
                        "title": "ProtectedRoute Component Pattern",
                        "content": "A ProtectedRoute (also called PrivateRoute) is a wrapper component that:\n1. Checks if user is authenticated\n2. Allows access to the protected page if authenticated\n3. Redirects to login if not authenticated\n4. Optionally shows a loading state while checking auth\n\n**Implementation Patterns**\n\n**Pattern 1: Route-level Protection**\n```typescript\n<Route\n  path=\"/dashboard\"\n  element={<ProtectedRoute><DashboardPage /></ProtectedRoute>}\n/>\n```\n\n**Pattern 2: Conditional Element**\n```typescript\n<Route\n  path=\"/dashboard\"\n  element={user ? <DashboardPage /> : <Navigate to=\"/login\" />}\n/>\n```\n\n**Pattern 3: Custom Component**\n```typescript\n<Route\n  path=\"/dashboard\"\n  element={<ProtectedRoute component={DashboardPage} />}\n/>\n```\n\n**State Checking**\nUse the AuthContext to determine if user is authenticated:\n```typescript\nconst { user, isLoading } = useAuth();\n\nif (isLoading) return <LoadingPage />;\nif (!user) return <Navigate to=\"/login\" replace />;\nreturn <YourPage />;\n```"
                    },
                    {
                        "type": "CONCEPT",
                        "title": "Redirect & Auth State Persistence",
                        "content": "When routing with authentication, you need to:\n1. **Redirect unauthenticated users** to login\n2. **Redirect authenticated users away from login** (e.g., if they visit /login while logged in)\n3. **Persist auth state** across page refreshes\n4. **Save the original URL** to redirect after login (\"return to where you were\")\n\n**Redirect After Login Pattern**\nSave the user's original location before redirecting to login:\n```typescript\nimport { useNavigate, useLocation } from 'react-router-dom';\n\nfunction LoginPage() {\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  const handleLoginSuccess = () => {\n    // Redirect to where they came from, or dashboard\n    const from = location.state?.from?.pathname || '/dashboard';\n    navigate(from, { replace: true });\n  };\n\n  return <LoginForm onSuccess={handleLoginSuccess} />;\n}\n\n// In ProtectedRoute, save the location when redirecting\nif (!user) {\n  return <Navigate to=\"/login\" state={{ from: location }} replace />;\n}\n```\n\n**Auth Persistence Strategy**\n1. On app startup, check localStorage for token\n2. If token exists, verify it's still valid (call /api/auth/me)\n3. If valid, restore user state from server response\n4. Show loading page during this check (prevent flashing login)\n5. Then render the app with correct initial state"
                    },
                    {
                        "type": "CODE",
                        "title": "ProtectedRoute Component",
                        "content": "Create a reusable ProtectedRoute component that wraps protected pages:",
                        "language": "typescript",
                        "code": "import React from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\nimport { useAuth } from '../contexts/AuthContext';\n\ninterface ProtectedRouteProps {\n  children: React.ReactNode;\n}\n\nconst ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {\n  const { user, isLoading } = useAuth();\n  const location = useLocation();\n\n  // Show loading state while checking authentication\n  if (isLoading) {\n    return (\n      <div className=\"protected-route-loading\">\n        <div className=\"loading-spinner\"></div>\n        <p>Loading...</p>\n      </div>\n    );\n  }\n\n  // User is authenticated, render the protected component\n  if (user) {\n    return <>{children}</>;\n  }\n\n  // User is not authenticated, redirect to login\n  // Save the location so we can redirect back after login\n  return (\n    <Navigate\n      to=\"/login\"\n      state={{ from: location }}\n      replace\n    />\n  );\n};\n\nexport default ProtectedRoute;"
                    },
                    {
                        "type": "CODE",
                        "title": "App Router Configuration",
                        "content": "Set up your complete routing structure with protected routes:",
                        "language": "typescript",
                        "code": "import React from 'react';\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport { AuthProvider } from './contexts/AuthContext';\nimport ProtectedRoute from './components/ProtectedRoute';\n\n// Pages\nimport LoginPage from './pages/LoginPage';\nimport RegisterPage from './pages/RegisterPage';\nimport DashboardPage from './pages/DashboardPage';\nimport TaskDetailPage from './pages/TaskDetailPage';\nimport NotFoundPage from './pages/NotFoundPage';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <AuthProvider>\n        <Routes>\n          {/* Public routes */}\n          <Route path=\"/login\" element={<LoginPage />} />\n          <Route path=\"/register\" element={<RegisterPage />} />\n\n          {/* Protected routes */}\n          <Route\n            path=\"/dashboard\"\n            element={\n              <ProtectedRoute>\n                <DashboardPage />\n              </ProtectedRoute>\n            }\n          />\n          <Route\n            path=\"/tasks/:id\"\n            element={\n              <ProtectedRoute>\n                <TaskDetailPage />\n              </ProtectedRoute>\n            }\n          />\n\n          {/* Redirect root to dashboard */}\n          <Route path=\"/\" element={<Navigate to=\"/dashboard\" replace />} />\n\n          {/* 404 - Not found */}\n          <Route path=\"*\" element={<NotFoundPage />} />\n        </Routes>\n      </AuthProvider>\n    </BrowserRouter>\n  );\n}\n\nexport default App;"
                    },
                    {
                        "type": "CODE",
                        "title": "Login Page with Redirect",
                        "content": "Create a login page that redirects to the original location after success:",
                        "language": "typescript",
                        "code": "import React from 'react';\nimport { useNavigate, useLocation, Navigate } from 'react-router-dom';\nimport { useAuth } from '../contexts/AuthContext';\nimport LoginForm from '../components/LoginForm';\n\nconst LoginPage: React.FC = () => {\n  const { user, isLoading } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  // If already logged in, redirect to dashboard\n  if (!isLoading && user) {\n    return <Navigate to=\"/dashboard\" replace />;\n  }\n\n  const handleLoginSuccess = () => {\n    // Get the location they were trying to access\n    const from = location.state?.from?.pathname || '/dashboard';\n    \n    // Redirect to original location with replace to clear history\n    navigate(from, { replace: true });\n  };\n\n  return (\n    <div className=\"login-page\">\n      <div className=\"login-container\">\n        <h1>Welcome Back</h1>\n        <p className=\"login-subtitle\">Sign in to your Task Manager account</p>\n        <LoginForm onSuccess={handleLoginSuccess} />\n      </div>\n    </div>\n  );\n};\n\nexport default LoginPage;"
                    },
                    {
                        "type": "CODE",
                        "title": "Dashboard Page with Navigation",
                        "content": "Create a protected dashboard page with user info and logout:",
                        "language": "typescript",
                        "code": "import React, { useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { useAuth } from '../contexts/AuthContext';\nimport TaskList from '../components/TaskList';\n\nconst DashboardPage: React.FC = () => {\n  const { user, logout } = useAuth();\n  const navigate = useNavigate();\n  const [showLogoutConfirm, setShowLogoutConfirm] = useState<boolean>(false);\n\n  const handleLogout = () => {\n    logout();\n    navigate('/login', { replace: true });\n  };\n\n  if (!user) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div className=\"dashboard-page\">\n      <header className=\"dashboard-header\">\n        <div className=\"dashboard-header-content\">\n          <h1>Dashboard</h1>\n          <p className=\"greeting\">Welcome back, {user.name}!</p>\n        </div>\n        <div className=\"dashboard-header-actions\">\n          <span className=\"user-email\">{user.email}</span>\n          <button\n            onClick={() => setShowLogoutConfirm(true)}\n            className=\"logout-button\"\n          >\n            Logout\n          </button>\n        </div>\n      </header>\n\n      {showLogoutConfirm && (\n        <div className=\"logout-confirm-modal\">\n          <div className=\"modal-overlay\" onClick={() => setShowLogoutConfirm(false)} />\n          <div className=\"modal-content\">\n            <h2>Confirm Logout</h2>\n            <p>Are you sure you want to log out?</p>\n            <div className=\"modal-actions\">\n              <button\n                onClick={() => setShowLogoutConfirm(false)}\n                className=\"cancel-button\"\n              >\n                Cancel\n              </button>\n              <button\n                onClick={handleLogout}\n                className=\"confirm-button\"\n              >\n                Logout\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n\n      <main className=\"dashboard-main\">\n        <section className=\"dashboard-section\">\n          <div className=\"section-header\">\n            <h2>Your Tasks</h2>\n            <button className=\"create-task-button\">+ Create New Task</button>\n          </div>\n          <TaskList userId={user.id} />\n        </section>\n      </main>\n    </div>\n  );\n};\n\nexport default DashboardPage;"
                    },
                    {
                        "type": "CONCEPT",
                        "title": "Challenge: Token Refresh Flow",
                        "content": "## Challenge: Implement Token Refresh\n\nExpanding on the authentication system, implement a token refresh mechanism:\n\n**Requirements:**\n1. **Track token expiration** using JWT decode library\n2. **Auto-refresh tokens** before they expire using a refresh endpoint\n3. **Handle refresh failures** by logging out the user\n4. **Queue API requests** during token refresh to prevent race conditions\n\n**Implementation Steps:**\n1. Decode JWT token to get expiration time\n2. Create a `useRefreshToken` hook that:\n   - Checks if token is expiring soon (within 5 minutes)\n   - Calls `/api/auth/refresh` to get new token\n   - Updates token in localStorage and context\n3. Update `fetchWithAuth` to automatically refresh tokens\n4. Handle the edge case where refresh also fails (force logout)\n\n**Bonus Challenge:**\n- Implement silent token refresh in the background using useEffect\n- Add a \"Your session is expiring\" warning modal (1 min before expiration)\n- Allow users to extend their session by clicking a button\n- Create an axios interceptor pattern for cleaner token management"
                    }
                ]
            }
        ]
    }
    return module_21

def main():
    # Read the current course
    with open('content/courses/javascript/course.json', 'r', encoding='utf-8') as f:
        data = json.load(f)

    # Create and add module 21
    module_21 = create_module_21()
    data['modules'].append(module_21)

    # Save the updated course
    with open('content/courses/javascript/course.json', 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

    print("[OK] Module 21 created successfully with 3 lessons")
    print("[OK] Lesson 21.4: React Components & State (45 min)")
    print("[OK] Lesson 21.5: Authentication UI Flow (40 min)")
    print("[OK] Lesson 21.6: Protected Routes (35 min)")
    print(f"\nTotal course modules: {len(data['modules'])}")

    # Verify module was added
    module_21_check = next((m for m in data['modules'] if m['id'] == 'module-21'), None)
    if module_21_check:
        print(f"Module 21 verified: {module_21_check['title']}")
        print(f"Number of lessons: {len(module_21_check['lessons'])}")

if __name__ == '__main__':
    main()
