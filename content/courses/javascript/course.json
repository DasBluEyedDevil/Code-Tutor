{
  "id": "javascript",
  "language": "javascript",
  "title": "JavaScript & TypeScript Full Course",
  "description": "Master JavaScript from basics to advanced with TypeScript, covering 42+ interactive lessons with real-world challenges.",
  "difficulty": "beginner",
  "estimatedHours": 35,
  "prerequisites": [],
  "modules": [
    {
      "id": "module-01",
      "title": "Module 1: The Absolute Basics (The 'What')",
      "description": "Understanding what programming is and writing your first lines of code",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "1.1",
          "title": "What Is Programming? (The Recipe Analogy)",
          "moduleId": "module-01",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're teaching a very literal robot to make a peanut butter and jelly sandwich. You can't just say 'make a sandwich' - the robot doesn't know what that means!\n\nYou have to break it down into tiny, specific steps: 'Pick up the knife. Dip the knife into the peanut butter jar. Spread the peanut butter on one slice of bread.' That's exactly what programming is.\n\nProgramming is writing a list of very specific instructions that a computer can follow. The computer is like that literal robot - it will do exactly what you tell it to do, but nothing more. It can't guess what you mean, and it can't read your mind. You have to be crystal clear.\n\nThe 'language' we use to give these instructions is called a programming language. Today, we're learning JavaScript, which is like giving instructions to a web browser."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// This is a comment - the computer ignores this line.\n// Comments are notes we leave for ourselves.\n\n// This is an instruction to the computer:\nconsole.log('Hello, World!');\n\n// The computer will display the text 'Hello, World!' on the screen."
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down that code line by line:\n\n1. Lines starting with // are comments. They're ignored by the computer. Think of them as sticky notes you leave for yourself (or other programmers) to explain what the code does.\n\n2. console.log('Hello, World!'); - This is an instruction (we'll call it a 'statement' later). Let's unpack it:\n   - console is like a special message board built into your web browser\n   - log means 'write a message'\n   - The text inside the parentheses and quotes ('Hello, World!') is the message we want to write\n   - The semicolon ; at the end is like a period at the end of a sentence - it tells the computer 'this instruction is complete'\n\nSo the whole thing means: 'Computer, write the message Hello, World! to the console.'"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes beginners make:\n\n1. Forgetting the quotes: console.log(Alice); won't work because the computer thinks Alice is a variable (a 'box' we'll learn about soon), not text.\n\n2. Forgetting the semicolon: While JavaScript is forgiving about this, it's good practice to always end statements with ;\n\n3. Misspelling console or log: Programming is case-sensitive! Console.log or console.Log won't work.\n\n4. Missing parentheses: console.log 'Alice'; won't work. The parentheses are how we 'pass' the message to the log function."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.1-challenge",
              "title": "Practice Challenge",
              "description": "Now it's your turn! Your challenge: Write code that displays your own name to the console. Replace 'Your Name Here' with your actual name (keep the quotes!).",
              "instructions": "Now it's your turn! Your challenge: Write code that displays your own name to the console. Replace 'Your Name Here' with your actual name (keep the quotes!).",
              "starterCode": "// Replace 'Your Name Here' with your name\nconsole.log('Your Name Here');",
              "solution": "console.log('Alice');  // Replace Alice with your actual name",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays a name to the console",
                  "expectedOutput": "Alice",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Uses console.log to output text",
                  "expectedOutput": "Your Name Here",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Make sure to keep the quotes around your name, and don't forget the semicolon at the end!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes beginners make:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes beginners make:"
                },
                {
                  "mistake": "Forgetting the quotes: console.log(Alice); won't work because the computer thinks Alice is a variable (a 'box' we'll learn about soon), not text.",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting the quotes: console.log(Alice); won't work because the computer thinks Alice is a variable (a 'box' we'll learn about soon), not text."
                },
                {
                  "mistake": "Forgetting the semicolon: While JavaScript is forgiving about this, it's good practice to always end statements with ;",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting the semicolon: While JavaScript is forgiving about this, it's good practice to always end statements with ;"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.2",
          "title": "Your First Workspace (Running JavaScript)",
          "moduleId": "module-01",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of the code editor as your workshop - it's where you'll build and test your code. Just like a carpenter has a workbench where they can quickly test if a joint fits or a piece is the right size, Code Tutor is where you can quickly try out JavaScript code and see the results immediately.\n\nCode Tutor runs JavaScript using Node.js - the same JavaScript engine that powers web browsers, but running on your computer. This means you can write and test JavaScript code without needing a web browser. The `console.log()` function works exactly the same way!\n\n**To run JavaScript, you'll need Node.js installed:**\n\n1. Download Node.js from https://nodejs.org\n2. Install it (the default options are fine)\n3. Restart Code Tutor\n\nOnce installed, write your code and click 'Run Code' to see the results!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// You can do math in the console!\nconsole.log(5 + 3);\n\n// You can write multiple messages\nconsole.log('First message');\nconsole.log('Second message');\nconsole.log('Third message');\n\n// You can even do math inside the message\nconsole.log('The answer is: ' + (10 * 2));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's look at what's happening:\n\n1. console.log(5 + 3); - The computer will actually do the math (5 + 3 = 8) and then display '8'. The computer evaluates (figures out) what's inside the parentheses first, then displays the result.\n\n2. Multiple console.log statements run in order, from top to bottom. The computer executes them one at a time, like following a recipe step by step.\n\n3. The + symbol does two things in JavaScript:\n   - When used with numbers, it adds them: 5 + 3 = 8\n   - When used with text (in quotes), it joins them together: 'Hello' + ' ' + 'World' becomes 'Hello World'\n\n4. Notice the parentheses around (10 * 2) in the last example? That tells the computer 'do this math first, then join it with the text.'"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Putting quotes around the numbers: console.log('100 - 45'); will display the text '100 - 45' instead of doing the math. Remove the quotes to make the computer calculate it.\n\n2. Forgetting the console.log part: Just writing 100 - 45; won't display anything. You need console.log() to actually show the result.\n\n3. Wrong symbols: Make sure you use * for multiplication (not x), and - for subtraction (not a dash that might look similar)."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.2-challenge",
              "title": "Practice Challenge",
              "description": "Create a mini calculator! Write code that:\n1. Displays the result of 15 + 27\n2. Displays the result of 100 - 45\n3. Displays the result of 6 * 7 (the * symbol means multiply)",
              "instructions": "Create a mini calculator! Write code that:\n1. Displays the result of 15 + 27\n2. Displays the result of 100 - 45\n3. Displays the result of 6 * 7 (the * symbol means multiply)",
              "starterCode": "// Calculate and display 15 + 27\nconsole.log(15 + 27);\n\n// Calculate and display 100 - 45\n// YOUR CODE HERE\n\n// Calculate and display 6 * 7\n// YOUR CODE HERE",
              "solution": "console.log(15 + 27);\nconsole.log(100 - 45);\nconsole.log(6 * 7);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays 42 (the result of 15 + 27)",
                  "expectedOutput": "42",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Follow the same pattern as the first line: console.log(), put the math inside the parentheses, and end with a semicolon."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Putting quotes around the numbers: console.log('100 - 45'); will display the text '100 - 45' instead of doing the math. Remove the quotes to make the computer calculate it.",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Putting quotes around the numbers: console.log('100 - 45'); will display the text '100 - 45' instead of doing the math. Remove the quotes to make the computer calculate it."
                },
                {
                  "mistake": "Forgetting the console.log part: Just writing 100 - 45; won't display anything. You need console.log() to actually show the result.",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting the console.log part: Just writing 100 - 45; won't display anything. You need console.log() to actually show the result."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.3",
          "title": "Leaving Notes for Yourself (Comments)",
          "moduleId": "module-01",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're cooking a complex recipe, and you write little notes in the margins: 'This takes 20 minutes' or 'Make sure the oven is preheated!' Those notes aren't part of the recipe itself - they're reminders to yourself.\n\nComments in code work the same way. They're notes you leave for yourself (or other programmers) that the computer completely ignores. The computer will skip right over them like they don't exist.\n\nWhy are comments important? Because code that makes perfect sense today might be confusing in a month. Comments explain WHY you wrote the code a certain way, not just WHAT the code does."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// This is a single-line comment\n// The computer ignores everything after the //\n\nconsole.log('This runs!');  // You can also put comments at the end of a line\n\n// console.log('This does NOT run because it is commented out');\n\n/*\n  This is a multi-line comment.\n  Everything between the /* and */ is ignored.\n  This is useful for longer explanations.\n*/\n\nconsole.log('This also runs!');\n\n/* You can also use multi-line comments\n   to temporarily 'turn off' code:\n   console.log('This is turned off');\n   console.log('So is this');\n*/"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Two types of comments:\n\n1. Single-line comments: //\n   - Everything after // on that line is ignored\n   - Great for short notes\n   - Example: // This calculates the total price\n\n2. Multi-line comments: /* */\n   - Everything between /* and */ is ignored, even across multiple lines\n   - Great for longer explanations or temporarily disabling multiple lines of code\n   - Example:\n     /*\n       This function is complex, so here's how it works:\n       First, it checks if the user is logged in...\n     */\n\nPro tip: Use comments to explain WHY, not WHAT. The code itself shows WHAT it does. Comments should explain WHY you made that choice.\n\nGood comment: // Using 30-day trial period instead of 7-day based on user feedback\nBad comment: // This sets the trial period to 30"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting the space after //: While //comment works, // comment is more readable.\n\n2. Trying to nest multi-line comments: /* /* nested */ */ doesn't work. Once the computer sees */, it thinks the comment is over.\n\n3. Not closing a multi-line comment: If you forget the */, everything after /* will be treated as a comment, and your code won't run!\n\n4. Over-commenting: Don't comment every single line. Comment the WHY and the complex parts, not the obvious stuff."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.3-challenge",
              "title": "Practice Challenge",
              "description": "Practice using comments! Add a single-line comment above the console.log explaining what the code does. Then, comment out the second console.log (so it doesn't run) using //.",
              "instructions": "Practice using comments! Add a single-line comment above the console.log explaining what the code does. Then, comment out the second console.log (so it doesn't run) using //.",
              "starterCode": "console.log('I am learning JavaScript!');\n\nconsole.log('Comment me out!');",
              "solution": "// This displays a message about learning JavaScript\nconsole.log('I am learning JavaScript!');\n\n// console.log('Comment me out!');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Only the first message is displayed",
                  "expectedOutput": "I am learning JavaScript!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Put // at the beginning of the line you want to comment out."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting the space after //: While //comment works, // comment is more readable.",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting the space after //: While //comment works, // comment is more readable."
                },
                {
                  "mistake": "Trying to nest multi-line comments: /* /* nested */ */ doesn't work. Once the computer sees */, it thinks the comment is over.",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Trying to nest multi-line comments: /* /* nested */ */ doesn't work. Once the computer sees */, it thinks the comment is over."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-02",
      "title": "Module 2: Storing & Using Information (The 'Boxes')",
      "description": "Learn how to store and label information for later use",
      "difficulty": "beginner",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "2.1",
          "title": "Variables: Your Labeled Storage Boxes (let and const)",
          "moduleId": "module-02",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have a storage room with many boxes. Each box can hold one thing, and you put a label on each box so you remember what's inside.\n\n'Age: 25' - A box labeled 'Age' that contains the number 25\n'Name: Alice' - A box labeled 'Name' that contains the text 'Alice'\n'Is Student: true' - A box labeled 'Is Student' that contains the answer 'yes' (true)\n\nIn programming, these labeled boxes are called VARIABLES. A variable is just a named container that holds a piece of information. You create a variable, give it a name (the label), and store something in it (the contents).\n\nWhy are variables useful? Because you can create a box once and then use what's inside it many times throughout your code. If you need to change what's in the box, you change it in ONE place, and everywhere that uses that box automatically gets the new value."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Creating a variable with 'let'\n// 'let' means 'create a new box'\nlet age = 25;\nlet name = 'Alice';\nlet isStudent = true;\n\n// Now we can use these boxes!\nconsole.log(name);  // Displays: Alice\nconsole.log(age);   // Displays: 25\n\n// We can change what's inside a 'let' box\nage = 26;  // It's Alice's birthday!\nconsole.log(age);  // Displays: 26\n\n// Creating a variable with 'const'\n// 'const' means 'constant' - a box whose contents CANNOT change\nconst birthYear = 1998;\nconsole.log(birthYear);  // Displays: 1998\n\n// This would cause an ERROR:\n// birthYear = 1999;  // Can't change a const!"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down the anatomy of creating a variable:\n\nlet age = 25;\n│   │   │ │\n│   │   │ └─ The value (what goes IN the box)\n│   │   └─── The equals sign (means 'store this value')\n│   └─────── The variable name (the label on the box)\n└─────────── The keyword 'let' (tells the computer to create a box)\n\nThink of it as: let [label] = [contents];\n\nTwo keywords for creating variables:\n\n1. let - Use this when the value might change later\n   - Example: let score = 0; (score will increase during a game)\n   \n2. const - Use this when the value will NEVER change\n   - Example: const PI = 3.14159; (pi is always pi)\n   - If you try to change a const, you'll get an error\n\nVariable naming rules:\n- Must start with a letter, $, or _\n- Can contain letters, numbers, $, or _ (but not spaces!)\n- Cannot be a reserved word (like 'let', 'const', 'if', etc.)\n- Case sensitive: 'age' and 'Age' are different variables\n\nNaming conventions (not required, but everyone does it):\n- Use camelCase: firstName, not firstname or first_name\n- Use descriptive names: userAge, not x or ua\n- Start with lowercase: age, not Age (unless it's a special case we'll learn later)"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting 'let' or 'const': Writing just age = 25; instead of let age = 25; In strict mode, this causes an error.\n\n2. Using 'let' or 'const' when USING a variable: You only use 'let' or 'const' when CREATING the variable. After that, just use the name:\n   Correct: let age = 25; age = 26;\n   Wrong: let age = 25; let age = 26; (Can't create the same box twice!)\n\n3. Trying to change a 'const': Remember, const means 'constant'. Once set, it cannot be changed.\n\n4. Misspelling variable names: If you create 'userName' but later try to use 'username', JavaScript will say 'username is not defined' because it's looking for a box with that exact label.\n\n5. Not using quotes for text: let name = Alice; won't work. Text must be in quotes: let name = 'Alice';"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.1-challenge",
              "title": "Practice Challenge",
              "description": "Create three variables:\n1. A 'const' variable called 'city' that stores your favorite city name (as text in quotes)\n2. A 'let' variable called 'temperature' that stores the number 72\n3. Use console.log to display both variables",
              "instructions": "Create three variables:\n1. A 'const' variable called 'city' that stores your favorite city name (as text in quotes)\n2. A 'let' variable called 'temperature' that stores the number 72\n3. Use console.log to display both variables",
              "starterCode": "// Create your variables here\n\n// Display them here",
              "solution": "const city = 'New York';\nlet temperature = 72;\n\nconsole.log(city);\nconsole.log(temperature);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays the city name",
                  "expectedOutput": "New York",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Displays the temperature value",
                  "expectedOutput": "72",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Uses const for city variable",
                  "expectedOutput": "New York",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Remember: const city = 'some city'; and let temperature = 72; Then use console.log for each."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting 'let' or 'const': Writing just age = 25; instead of let age = 25; In strict mode, this causes an error.",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting 'let' or 'const': Writing just age = 25; instead of let age = 25; In strict mode, this causes an error."
                },
                {
                  "mistake": "Using 'let' or 'const' when USING a variable: You only use 'let' or 'const' when CREATING the variable. After that, just use the name:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using 'let' or 'const' when USING a variable: You only use 'let' or 'const' when CREATING the variable. After that, just use the name:\n   Correct: let age = 25; age = 26;\n   Wrong: let age = 25; let age = 26; (Can't create the same box twice!)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.2",
          "title": "Types of Information: Strings, Numbers, and Booleans",
          "moduleId": "module-02",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Just like in real life, we store different TYPES of things in different ways:\n\n- Words and sentences: We write them down as text (String)\n- Counting and measuring: We use numbers (Number)\n- Yes/No questions: We use true or false (Boolean)\n\nJavaScript has different 'types' of data for the same reason. Each type works differently and has different things you can do with it.\n\nThink of it like different types of storage containers:\n- A filing cabinet is for documents (text/strings)\n- A scale is for numbers (you can add, subtract, compare)\n- A light switch is for true/false (on or off, yes or no)\n\nYou wouldn't try to do math with words, and you wouldn't try to write a letter with numbers. JavaScript keeps track of what TYPE each variable is so it knows how to work with it."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// STRINGS (text) - always in quotes\nlet firstName = 'Alice';\nlet lastName = \"Smith\";  // Single or double quotes both work\nlet greeting = 'Hello, World!';\n\n// You can join strings together with +\nlet fullName = firstName + ' ' + lastName;\nconsole.log(fullName);  // Displays: Alice Smith\n\n// NUMBERS - no quotes!\nlet age = 25;\nlet price = 19.99;  // Decimals are fine\nlet temperature = -5;  // Negative numbers too\n\n// You can do math with numbers\nlet total = price + 10;\nconsole.log(total);  // Displays: 29.99\n\n// BOOLEANS (true or false) - no quotes!\nlet isStudent = true;\nlet hasGraduated = false;\nlet isRaining = true;\n\nconsole.log(isStudent);  // Displays: true\n\n// A common mistake: don't put quotes around booleans!\nlet wrong = 'true';  // This is a STRING containing the word 'true'\nlet right = true;    // This is a BOOLEAN with the value true"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "The three basic data types:\n\n1. STRING - Text\n   - Always enclosed in quotes (single ' or double \")\n   - Can be empty: let empty = '';\n   - Can contain numbers as text: let code = '12345';\n   - Use + to join strings: 'Hello' + ' ' + 'World' = 'Hello World'\n\n2. NUMBER - Numeric values\n   - NO quotes\n   - Can be positive, negative, or decimal\n   - Can do math: +, -, *, / (division), % (remainder)\n   - Special values: Infinity, -Infinity, NaN (Not a Number)\n\n3. BOOLEAN - True or False\n   - Only two possible values: true or false\n   - NO quotes (quotes would make it a string)\n   - Used for yes/no, on/off, exists/doesn't exist\n   - We'll use these a lot when making decisions (if statements)\n\nHow to remember:\n- If it's text, it needs quotes → String\n- If it's a number for math, no quotes → Number\n- If it's true or false, no quotes → Boolean\n\nThe + operator:\n- With numbers: 5 + 3 = 8 (addition)\n- With strings: 'Hello' + 'World' = 'HelloWorld' (joining)\n- Mixed: 'Age: ' + 25 = 'Age: 25' (converts number to string and joins)"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Quotes around numbers: let age = '25'; makes age a STRING, not a NUMBER. You can't do math with it: '25' + 5 = '255' (string joining, not 30).\n\n2. Quotes around booleans: let isStudent = 'true'; makes it a STRING containing the word 'true', not the boolean value true.\n\n3. Forgetting quotes around text: let name = Alice; won't work. JavaScript thinks Alice is a variable, not text. Use let name = 'Alice';\n\n4. Mixing up + for numbers vs strings:\n   - 5 + 5 = 10 (math)\n   - '5' + '5' = '55' (joining strings)\n   - '5' + 5 = '55' (JavaScript converts the number to a string)\n\n5. Case matters: true and false must be lowercase. True or FALSE won't work."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.2-challenge",
              "title": "Practice Challenge",
              "description": "Create a mini profile:\n1. Create a const 'userName' with your name (string)\n2. Create a let 'userAge' with your age (number)\n3. Create a const 'isLearning' set to true (boolean)\n4. Display a message: 'Name: [name], Age: [age], Learning: [boolean]' by joining strings and variables",
              "instructions": "Create a mini profile:\n1. Create a const 'userName' with your name (string)\n2. Create a let 'userAge' with your age (number)\n3. Create a const 'isLearning' set to true (boolean)\n4. Display a message: 'Name: [name], Age: [age], Learning: [boolean]' by joining strings and variables",
              "starterCode": "// Create your variables\n\n// Create a message by joining strings with +\n// Example: 'Name: ' + userName + ', Age: ' + userAge ...\nlet message = // YOUR CODE HERE\n\nconsole.log(message);",
              "solution": "const userName = 'Alice';\nlet userAge = 25;\nconst isLearning = true;\n\nlet message = 'Name: ' + userName + ', Age: ' + userAge + ', Learning: ' + isLearning;\n\nconsole.log(message);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays a formatted profile message with name, age, and learning status",
                  "expectedOutput": "Name: Alice, Age: 25, Learning: true",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output contains the Name label",
                  "expectedOutput": "Name:",
                  "isVisible": false
                },
                {
                  "id": "test-3",
                  "description": "Output contains the Learning label with boolean",
                  "expectedOutput": "Learning: true",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use + to join strings and variables: 'Name: ' + userName + ', Age: ' + userAge + ', Learning: ' + isLearning"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Quotes around numbers: let age = '25'; makes age a STRING, not a NUMBER. You can't do math with it: '25' + 5 = '255' (string joining, not 30).",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Quotes around numbers: let age = '25'; makes age a STRING, not a NUMBER. You can't do math with it: '25' + 5 = '255' (string joining, not 30)."
                },
                {
                  "mistake": "Quotes around booleans: let isStudent = 'true'; makes it a STRING containing the word 'true', not the boolean value true.",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Quotes around booleans: let isStudent = 'true'; makes it a STRING containing the word 'true', not the boolean value true."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-03",
      "title": "Module 3: Making Decisions (The 'Forks in the Road')",
      "description": "Teach your program to make choices based on conditions",
      "difficulty": "beginner",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "3.1",
          "title": "Teaching Your Code to Choose (if Statements)",
          "moduleId": "module-03",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're a traffic cop at an intersection. When you see a red light, you tell cars to STOP. When you see a green light, you tell them to GO. You're making a decision based on a condition (the light color).\n\nThat's exactly what an 'if' statement does in code. It checks a condition (is something true or false?), and based on the answer, it decides what action to take.\n\nThink of it like a flowchart with a diamond-shaped decision box: 'Is it raining?' If YES, take umbrella. If NO, leave it home. In code, we call these YES/NO questions 'conditions', and they always evaluate to either true or false (remember booleans from Module 2?)."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "let temperature = 75;\n\n// The 'if' statement: \"IF this condition is true, THEN do this\"\nif (temperature > 70) {\n  console.log('It is warm outside!');\n}\n\nconsole.log('This line runs no matter what');\n\n// Another example\nlet isRaining = true;\n\nif (isRaining) {\n  console.log('Take an umbrella');\n}\n\n// You can check if something is false\nlet hasKeys = false;\n\nif (!hasKeys) {  // The ! means \"NOT\"\n  console.log('Go back and get your keys!');\n}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down an if statement:\n\nif (condition) {\n│  │          │ │\n│  │          │ └─ The code to run (the 'action')\n│  │          └─── Closing parenthesis\n│  └─────────────── The condition (must be true/false)\n└────────────────── The 'if' keyword\n\nKey points:\n\n1. if - This keyword says \"I'm about to check a condition\"\n\n2. (condition) - This must be something that evaluates to true or false\n   - temperature > 70 → either true or false\n   - isRaining → already a boolean (true or false)\n   - !hasKeys → the ! flips the boolean (false becomes true)\n\n3. { } - Curly braces contain the code that runs IF the condition is true\n   - If the condition is false, everything inside { } is skipped\n   - You can have multiple lines of code inside { }\n\n4. Code outside the if statement runs no matter what\n\nThe ! operator (NOT):\n- !true → false\n- !false → true\n- It flips/inverts the boolean value"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting parentheses around the condition: if age >= 18 won't work. Must be if (age >= 18)\n\n2. Using = instead of ==  or ===:\n   - if (age = 18) is WRONG - this assigns 18 to age!\n   - if (age === 18) is CORRECT - this checks if age equals 18\n\n3. Forgetting curly braces: While technically optional for single-line if statements, always use { } to avoid bugs later.\n\n4. Putting a semicolon after the condition: if (age >= 18); is wrong. The semicolon ends the if statement before it does anything!\n\n5. Trying to use 'AND' or 'OR' in English: if (age > 17 and age < 65) won't work. JavaScript uses && for 'and' and || for 'or' (we'll learn these soon)."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.1-challenge",
              "title": "Practice Challenge",
              "description": "Create a simple age checker:\n1. Create a variable 'age' and set it to any number\n2. Write an if statement that displays 'You can vote!' if age is 18 or greater\n3. Test it with different ages (try 17, then try 18)",
              "instructions": "Create a simple age checker:\n1. Create a variable 'age' and set it to any number\n2. Write an if statement that displays 'You can vote!' if age is 18 or greater\n3. Test it with different ages (try 17, then try 18)",
              "starterCode": "// Create your age variable\nlet age = 17;\n\n// Write your if statement here\n",
              "solution": "let age = 18;\n\nif (age >= 18) {\n  console.log('You can vote!');\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Works for age 18 or above",
                  "expectedOutput": "You can vote!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the >= operator (greater than or equal to). Format: if (age >= 18) { console.log('You can vote!'); }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting parentheses around the condition: if age >= 18 won't work. Must be if (age >= 18)",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting parentheses around the condition: if age >= 18 won't work. Must be if (age >= 18)"
                },
                {
                  "mistake": "Using = instead of ==  or ===:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using = instead of ==  or ===:\n   - if (age = 18) is WRONG - this assigns 18 to age!\n   - if (age === 18) is CORRECT - this checks if age equals 18"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.2",
          "title": "Multiple Paths (else if and else)",
          "moduleId": "module-03",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're getting dressed based on the weather. Here's your thought process:\n\n'IF it's snowing → wear a heavy coat'\n'ELSE IF it's raining → wear a raincoat'\n'ELSE IF it's cold → wear a jacket'\n'ELSE → wear a t-shirt' (default for all other cases)\n\nYou're checking multiple conditions in order, and taking the FIRST one that's true. Once you've made a decision, you don't check the rest - you're already dressed!\n\nThis is exactly how else if and else work in programming. You can have multiple 'forks in the road', and your code will take the first path where the condition is true."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "let temperature = 45;\n\n// Multiple conditions with if...else if...else\nif (temperature > 80) {\n  console.log('It is hot! Wear shorts.');\n} else if (temperature > 60) {\n  console.log('It is nice! Wear a t-shirt.');\n} else if (temperature > 40) {\n  console.log('It is cold! Wear a jacket.');\n} else {\n  console.log('It is freezing! Wear a heavy coat.');\n}\n\n// Another example: letter grades\nlet score = 85;\n\nif (score >= 90) {\n  console.log('Grade: A');\n} else if (score >= 80) {\n  console.log('Grade: B');\n} else if (score >= 70) {\n  console.log('Grade: C');\n} else if (score >= 60) {\n  console.log('Grade: D');\n} else {\n  console.log('Grade: F');\n}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "The structure:\n\nif (first condition) {\n  // Runs if first condition is true\n} else if (second condition) {\n  // Runs if first is false BUT second is true  \n} else if (third condition) {\n  // Runs if first and second are false BUT third is true\n} else {\n  // Runs if ALL above conditions are false (the 'default')\n}\n\nImportant rules:\n\n1. You MUST start with 'if' - you can't have 'else if' or 'else' without an 'if' first\n\n2. You can have as many 'else if' blocks as you want (0, 1, 5, 100...)\n\n3. The 'else' block is optional - it's the \"catch-all\" for when nothing else is true\n\n4. ONLY ONE block of code will run - the first one with a true condition\n   - If the first 'if' is true, the rest are skipped completely\n   - If the first 'if' is false, check the first 'else if'\n   - And so on...\n\n5. Order matters! In the grade example:\n   - We check >= 90 first\n   - Then >= 80 (which also includes 90-100, but we already handled those)\n   - If we checked >= 60 first, everyone would get a 'D' because 90 >= 60 is true!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Wrong order of conditions:\n   if (score >= 60) { ... } else if (score >= 90) { ... }\n   This is wrong! If score is 95, the first condition (>= 60) is true, so it stops there. Always check from most specific to least specific.\n\n2. Using separate if statements instead of else if:\n   if (temp > 80) { ... }\n   if (temp > 60) { ... }  // WRONG - both could run!\n   Instead use: else if (temp > 60) { ... }\n\n3. Forgetting the 'else' keyword: writing if (cond1) { } if (cond2) { } won't work as intended.\n\n4. Putting code between the blocks:\n   if (x > 5) { }\n   console.log('hello');  // This runs no matter what!\n   else { }  // ERROR - can't have code between if and else"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.2-challenge",
              "title": "Practice Challenge",
              "description": "Create a movie rating advisor:\n1. Create a variable 'age' with a number\n2. If age is under 13: display 'You can watch G and PG movies'\n3. Else if age is under 17: display 'You can watch G, PG, and PG-13 movies'\n4. Else: display 'You can watch all movies including R-rated'",
              "instructions": "Create a movie rating advisor:\n1. Create a variable 'age' with a number\n2. If age is under 13: display 'You can watch G and PG movies'\n3. Else if age is under 17: display 'You can watch G, PG, and PG-13 movies'\n4. Else: display 'You can watch all movies including R-rated'",
              "starterCode": "let age = 15;\n\n// Write your if...else if...else statement here\n",
              "solution": "let age = 15;\n\nif (age < 13) {\n  console.log('You can watch G and PG movies');\n} else if (age < 17) {\n  console.log('You can watch G, PG, and PG-13 movies');\n} else {\n  console.log('You can watch all movies including R-rated');\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Correctly handles age 15",
                  "expectedOutput": "You can watch G, PG, and PG-13 movies",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use if (age < 13), then else if (age < 17), then else for the rest."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Wrong order of conditions:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Wrong order of conditions:\n   if (score >= 60) { ... } else if (score >= 90) { ... }\n   This is wrong! If score is 95, the first condition (>= 60) is true, so it stops there. Always check from most specific to least specific."
                },
                {
                  "mistake": "Using separate if statements instead of else if:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using separate if statements instead of else if:\n   if (temp > 80) { ... }\n   if (temp > 60) { ... }  // WRONG - both could run!\n   Instead use: else if (temp > 60) { ... }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.3",
          "title": "Comparison Operators (How to Compare Things)",
          "moduleId": "module-03",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "When you're shopping, you constantly compare things:\n\n'Is this apple bigger than that one?' (>)\n'Is this shirt the same price as that one?' (===)\n'Is this milk carton NOT expired?' (not equal to today's date)\n\nIn programming, we have special symbols for making these comparisons. They're called 'comparison operators', and they always give you a true/false answer - perfect for use in if statements!\n\nThink of them as questions you can ask:\n- '>' means 'Is this bigger?'\n- '<' means 'Is this smaller?'\n- '===' means 'Are these exactly the same?'\n- '!==' means 'Are these different?'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Greater than (>)\nlet age = 25;\nif (age > 18) {\n  console.log('You are an adult');  // true, runs\n}\n\n// Less than (<)\nlet temperature = 32;\nif (temperature < 40) {\n  console.log('It is very cold');  // true, runs\n}\n\n// Greater than or equal to (>=)\nlet score = 60;\nif (score >= 60) {\n  console.log('You passed!');  // true, runs (60 equals 60)\n}\n\n// Less than or equal to (<=)\nlet speed = 55;\nif (speed <= 55) {\n  console.log('You are within the speed limit');  // true, runs\n}\n\n// Equal to (===)\nlet userAnswer = 'Paris';\nif (userAnswer === 'Paris') {\n  console.log('Correct!');  // true, runs\n}\n\n// Not equal to (!==)\nlet status = 'pending';\nif (status !== 'complete') {\n  console.log('Still waiting...');  // true, runs\n}\n\n// You can also store comparison results in variables!\nlet isAdult = age >= 18;  // isAdult now holds true or false\nconsole.log(isAdult);  // Displays: true"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "The six comparison operators:\n\n1. >   Greater than\n   - 5 > 3 → true\n   - 3 > 5 → false\n   - 5 > 5 → false (not greater, they're equal)\n\n2. <   Less than\n   - 3 < 5 → true\n   - 5 < 3 → false\n   - 5 < 5 → false\n\n3. >=  Greater than OR equal to\n   - 5 >= 5 → true (the equal part makes it true)\n   - 6 >= 5 → true\n   - 4 >= 5 → false\n\n4. <=  Less than OR equal to\n   - 5 <= 5 → true\n   - 4 <= 5 → true\n   - 6 <= 5 → false\n\n5. === Exactly equal to (strict equality)\n   - 5 === 5 → true\n   - 5 === '5' → false (number vs string)\n   - 'cat' === 'cat' → true\n   - 'Cat' === 'cat' → false (case matters!)\n\n6. !== Not equal to (strict inequality)\n   - 5 !== 3 → true (they are different)\n   - 5 !== 5 → false (they are the same)\n\nAll comparison operators return a boolean (true or false). You can use them:\n- Directly in if statements: if (age > 18)\n- Store in variables: let canVote = age >= 18;\n- Display them: console.log(5 > 3);  // Shows: true"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Using = instead of ===:\n   if (age = 18)  // WRONG - this assigns 18 to age!\n   if (age === 18)  // CORRECT - this compares\n\n2. Using == instead of ===:\n   JavaScript has == (loose equality) and === (strict equality)\n   - 5 == '5' → true (converts types, then compares)\n   - 5 === '5' → false (different types)\n   ALWAYS use === and !== to avoid surprises\n\n3. Comparing strings with > or <:\n   'apple' < 'banana' → true (alphabetical order works!)\n   But '10' < '2' → true (compares as strings, not numbers)\n   To compare string numbers, convert first: Number('10') < Number('2') → false\n\n4. Case sensitivity:\n   'Hello' === 'hello' → false\n   To ignore case: 'Hello'.toLowerCase() === 'hello'.toLowerCase()\n\n5. Confusing >= and =>:\n   >= is greater-than-or-equal (comparison)\n   => is for arrow functions (we'll learn later)"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.3-challenge",
              "title": "Practice Challenge",
              "description": "Create a simple login validator:\n1. Create two variables: 'password' (a string) and 'confirmPassword' (another string)\n2. If they are equal (===), display 'Passwords match!'\n3. If they are not equal (!==), display 'Passwords do not match'",
              "instructions": "Create a simple login validator:\n1. Create two variables: 'password' (a string) and 'confirmPassword' (another string)\n2. If they are equal (===), display 'Passwords match!'\n3. If they are not equal (!==), display 'Passwords do not match'",
              "starterCode": "let password = 'secret123';\nlet confirmPassword = 'secret123';\n\n// Write your if...else statement here\n",
              "solution": "let password = 'secret123';\nlet confirmPassword = 'secret123';\n\nif (password === confirmPassword) {\n  console.log('Passwords match!');\n} else {\n  console.log('Passwords do not match');\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Detects matching passwords",
                  "expectedOutput": "Passwords match!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use === to check if they're equal: if (password === confirmPassword)"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Using = instead of ===:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using = instead of ===:\n   if (age = 18)  // WRONG - this assigns 18 to age!\n   if (age === 18)  // CORRECT - this compares"
                },
                {
                  "mistake": "Using == instead of ===:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using == instead of ===:\n   JavaScript has == (loose equality) and === (strict equality)\n   - 5 == '5' → true (converts types, then compares)\n   - 5 === '5' → false (different types)\n   ALWAYS use === and !== to avoid surprises"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.4",
          "title": "The Loose vs Strict Check (== vs ===)",
          "moduleId": "module-03",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're checking if two people are 'the same':\n\n**Loose check (==)**: 'Are they the same height?' You might say yes even if one person is wearing heels - you're flexible about what 'same' means.\n\n**Strict check (===)**: 'Are they the EXACT same height, measured precisely, wearing the exact same shoes?' You're being very specific.\n\nIn JavaScript:\n- == (loose equality) tries to be helpful by converting types: '5' == 5 → true\n- === (strict equality) requires exact match: '5' === 5 → false\n\nAlmost all professional JavaScript developers use === exclusively because it's more predictable and prevents bugs."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// The difference between == and ===\n\n// == (loose equality) - converts types\nconsole.log(5 == '5');     // true (converts '5' to number)\nconsole.log(true == 1);    // true (converts true to 1)\nconsole.log(false == 0);   // true (converts false to 0)\nconsole.log(null == undefined);  // true (special case)\n\n// === (strict equality) - no conversion\nconsole.log(5 === '5');    // false (number vs string)\nconsole.log(true === 1);   // false (boolean vs number)\nconsole.log(false === 0);  // false (boolean vs number)\nconsole.log(null === undefined);  // false (different types)\n\n// Real-world example where == causes bugs\nlet userInput = '0';  // User typed '0' in a form\n\nif (userInput == false) {\n  console.log('This runs! But did the user mean false?');\n}\n\nif (userInput === false) {\n  console.log('This does NOT run - safer!');\n}\n\n// Best practice: ALWAYS use ===\nlet count = 0;\nif (count === 0) {\n  console.log('Count is zero');\n}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding the two equality operators:\n\n== (Loose Equality)\n- Also called 'abstract equality'\n- Converts types before comparing\n- Can lead to unexpected results\n- Example: '5' == 5 → JavaScript converts '5' to 5, then compares → true\n\n=== (Strict Equality)\n- Also called 'strict equality'\n- No type conversion\n- Both value AND type must match\n- Example: '5' === 5 → Different types (string vs number) → false\n\nThe same applies to inequality:\n\n!= (Loose Inequality)\n- Converts types before comparing\n- 5 != '5' → false (they're 'equal' after conversion)\n\n!== (Strict Inequality)  \n- No type conversion\n- 5 !== '5' → true (different types, so not equal)\n\nType coercion with ==:\n- true == 1 → true\n- false == 0 → true\n- '' == 0 → true (empty string)\n- ' ' == 0 → true (space string)\n- [] == 0 → true (empty array)\n- null == undefined → true\n\nThese are all FALSE with ===!\n\n**Best Practice**: Use === and !== exclusively. The only time to use == is if you specifically want type coercion, which is rare."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Using == when you mean ===:\n   This is SO common. Most bugs from == are subtle and hard to spot.\n   Rule of thumb: ALWAYS use ===\n\n2. Not understanding type coercion:\n   if (userInput == true)  // Almost never what you want\n   Better: if (userInput === true) or just if (userInput)\n\n3. Assuming null == 0:\n   Actually, null == 0 → false\n   But null == undefined → true\n   Weird, right? That's why we use ===\n\n4. Forgetting that form inputs are strings:\n   <input type='number'> still gives you a string!\n   Always convert: Number(input.value)\n\n5. Triple equals in other languages:\n   PHP has ===, but most languages (Java, Python, C#) only have ==\n   JavaScript is unique in needing this distinction"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.4-challenge",
              "title": "Practice Challenge",
              "description": "Debug this code! A user typed their age in a form (stored as a string). We want to check if they're 18, but the code isn't working:\n\nlet userAge = '18';  // String from form input\nif (userAge === 18) {\n  console.log('You are 18!');\n} else {\n  console.log('You are not 18');\n}\n\nFix it TWO ways:\n1. Convert userAge to a number before comparing (use Number(userAge))\n2. Compare as strings (userAge === '18')",
              "instructions": "Debug this code! A user typed their age in a form (stored as a string). We want to check if they're 18, but the code isn't working:\n\nlet userAge = '18';  // String from form input\nif (userAge === 18) {\n  console.log('You are 18!');\n} else {\n  console.log('You are not 18');\n}\n\nFix it TWO ways:\n1. Convert userAge to a number before comparing (use Number(userAge))\n2. Compare as strings (userAge === '18')",
              "starterCode": "// Method 1: Convert to number\nlet userAge = '18';\n// YOUR CODE HERE\n\n// Method 2: Compare as strings  \nlet userAge2 = '18';\n// YOUR CODE HERE",
              "solution": "// Method 1: Convert to number\nlet userAge = '18';\nif (Number(userAge) === 18) {\n  console.log('You are 18!');\n}\n\n// Method 2: Compare as strings\nlet userAge2 = '18';\nif (userAge2 === '18') {\n  console.log('You are 18!');\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Compares correctly",
                  "expectedOutput": "You are 18!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Method 1: if (Number(userAge) === 18)\nMethod 2: if (userAge === '18')"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Using == when you mean ===:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using == when you mean ===:\n   This is SO common. Most bugs from == are subtle and hard to spot.\n   Rule of thumb: ALWAYS use ==="
                },
                {
                  "mistake": "Not understanding type coercion:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Not understanding type coercion:\n   if (userInput == true)  // Almost never what you want\n   Better: if (userInput === true) or just if (userInput)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.5",
          "title": "Combining Conditions (Logical Operators: &&, ||, !)",
          "moduleId": "module-03",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Sometimes you need to check multiple conditions at once:\n\n'Can I go to the movies?' \n- I need money AND I need time AND the movie needs to be showing\n- If ANY of these are false, I can't go\n\nThis is what the && operator does - it means 'AND'. All conditions must be true.\n\nOr consider:\n'Should I bring an umbrella?'\n- IF it's raining OR IF it's cloudy OR IF the forecast says rain\n- If ANY of these are true, bring it\n\nThis is what the || operator does - it means 'OR'. At least one condition must be true.\n\nWe also have ! which means 'NOT' - it flips true to false and vice versa."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// AND operator (&&) - ALL must be true\nlet hasTicket = true;\nlet hasTime = true;\nlet isShowing = true;\n\nif (hasTicket && hasTime && isShowing) {\n  console.log('You can watch the movie!');  // All true, this runs\n}\n\nlet age = 25;\nlet hasLicense = true;\n\nif (age >= 16 && hasLicense) {\n  console.log('You can drive');  // Both true, this runs\n}\n\n// OR operator (||) - AT LEAST ONE must be true\nlet isWeekend = true;\nlet isHoliday = false;\n\nif (isWeekend || isHoliday) {\n  console.log('You can sleep in!');  // One is true, this runs\n}\n\nlet temperature = 95;\nif (temperature > 90 || temperature < 32) {\n  console.log('Extreme weather!');  // First condition true, runs\n}\n\n// NOT operator (!) - flips true/false\nlet isRaining = false;\n\nif (!isRaining) {\n  console.log('No umbrella needed');  // !false = true, runs\n}\n\n// Combining operators\nlet hour = 14;\nlet isWeekday = true;\n\nif ((hour >= 9 && hour <= 17) && isWeekday) {\n  console.log('Office is open');\n}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "The three logical operators:\n\n1. && (AND)\n   - true && true → true\n   - true && false → false\n   - false && true → false\n   - false && false → false\n   - ALL conditions must be true for the result to be true\n\n2. || (OR)\n   - true || true → true\n   - true || false → true\n   - false || true → true\n   - false || false → false\n   - AT LEAST ONE condition must be true for the result to be true\n\n3. ! (NOT)\n   - !true → false\n   - !false → true\n   - Flips/inverts the boolean value\n\nOrder of operations:\n1. ! (NOT) happens first\n2. && (AND) happens second\n3. || (OR) happens last\n\nExample:\n!false && true || false\n= true && true || false  // ! first\n= true || false          // && second\n= true                   // || last\n\nUse parentheses for clarity:\n(age >= 18) && (hasLicense)\n\nShort-circuit evaluation:\n- With &&: If first is false, second is never checked\n  - false && (anything) → immediately false\n- With ||: If first is true, second is never checked\n  - true || (anything) → immediately true\n\nThis is useful but can cause subtle bugs if you're not careful!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Using 'and' or 'or' instead of symbols:\n   if (age > 18 and hasLicense)  // WRONG\n   if (age > 18 && hasLicense)   // CORRECT\n\n2. Confusing && and ||:\n   if (isWeekend || hasWork)  // Do I work on weekends or any day?\n   vs\n   if (isWeekend && !hasWork) // Free weekend?\n   Read them out loud to check!\n\n3. Forgetting parentheses with mixed operators:\n   if (a || b && c)  // Unclear!\n   if (a || (b && c))  // Better\n   if ((a || b) && c)  // Different meaning!\n\n4. Double negatives:\n   if (!!isLoggedIn)  // Just use: if (isLoggedIn)\n   Don't overthink it!\n\n5. Not understanding short-circuit:\n   if (user && user.name)  // Safe - checks user exists first\n   if (user.name && user)  // DANGEROUS - might error if user is null\n\n6. Trying to check multiple values at once:\n   if (x === 1 || 2 || 3)  // WRONG - doesn't work!\n   if (x === 1 || x === 2 || x === 3)  // CORRECT\n   Or better: if ([1,2,3].includes(x))  // We'll learn this later!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.5-challenge",
              "title": "Practice Challenge",
              "description": "Create a simple access control system for a secure building:\n1. Create variables: isEmployee (boolean), hasKeycard (boolean), securityLevel (number 1-3)\n2. Access is granted if:\n   - Person is an employee AND has a keycard\n   - OR security level is 3 (admin access)\n3. Display 'Access Granted' or 'Access Denied'",
              "instructions": "Create a simple access control system for a secure building:\n1. Create variables: isEmployee (boolean), hasKeycard (boolean), securityLevel (number 1-3)\n2. Access is granted if:\n   - Person is an employee AND has a keycard\n   - OR security level is 3 (admin access)\n3. Display 'Access Granted' or 'Access Denied'",
              "starterCode": "let isEmployee = true;\nlet hasKeycard = true;\nlet securityLevel = 2;\n\n// Write your if statement here\n// Access granted if: (isEmployee AND hasKeycard) OR securityLevel is 3\n",
              "solution": "let isEmployee = true;\nlet hasKeycard = true;\nlet securityLevel = 2;\n\nif ((isEmployee && hasKeycard) || securityLevel === 3) {\n  console.log('Access Granted');\n} else {\n  console.log('Access Denied');\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Grants access for employee with keycard",
                  "expectedOutput": "Access Granted",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use parentheses to group: if ((isEmployee && hasKeycard) || securityLevel === 3)"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Using 'and' or 'or' instead of symbols:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using 'and' or 'or' instead of symbols:\n   if (age > 18 and hasLicense)  // WRONG\n   if (age > 18 && hasLicense)   // CORRECT"
                },
                {
                  "mistake": "Confusing && and ||:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Confusing && and ||:\n   if (isWeekend || hasWork)  // Do I work on weekends or any day?\n   vs\n   if (isWeekend && !hasWork) // Free weekend?\n   Read them out loud to check!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-04",
      "title": "Module 4: Repeating Actions (The 'Loops')",
      "description": "Automate repetitive tasks using loops",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "4.1",
          "title": "Doing Something a Specific Number of Times (for Loops)",
          "moduleId": "module-04",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're a teacher taking attendance. You have a list of 25 students, and you need to call out each name, one by one:\n\n'Student 1: Are you here?'\n'Student 2: Are you here?'\n'Student 3: Are you here?'\n...and so on until student 25.\n\nYou're doing the SAME action 25 times, just changing the number. This is tedious to write out, but perfect for a loop!\n\nA 'for loop' is like saying: 'Start at 1, keep going until 25, and for each number, do this action.' The loop handles the counting automatically - you just tell it what to do each time."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Basic for loop - count from 0 to 4\nfor (let i = 0; i < 5; i++) {\n  console.log('Count: ' + i);\n}\n// Displays: Count: 0, Count: 1, Count: 2, Count: 3, Count: 4\n\n// Count from 1 to 10\nfor (let i = 1; i <= 10; i++) {\n  console.log(i);\n}\n\n// Count by twos (even numbers)\nfor (let i = 0; i <= 10; i += 2) {\n  console.log(i);  // 0, 2, 4, 6, 8, 10\n}\n\n// Count backwards\nfor (let i = 10; i >= 1; i--) {\n  console.log(i);\n}\nconsole.log('Blast off!');\n\n// Practical example: calculate total\nlet total = 0;\nfor (let i = 1; i <= 5; i++) {\n  total += i;  // Same as: total = total + i\n}\nconsole.log('Sum of 1 to 5: ' + total);  // 15"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Anatomy of a for loop:\n\nfor (initialization; condition; update) {\n     │              │          │\n     │              │          └─ What happens after each loop\n     │              └──────────── When to keep looping\n     └─────────────────────────── Where to start\n  // Code to repeat\n}\n\nLet's break down: for (let i = 0; i < 5; i++)\n\n1. **Initialization** (let i = 0)\n   - Runs ONCE at the very beginning\n   - Creates a counter variable (usually named i)\n   - Sets its starting value\n\n2. **Condition** (i < 5)\n   - Checked BEFORE each loop iteration\n   - If true, run the loop body\n   - If false, exit the loop\n\n3. **Update** (i++)\n   - Runs AFTER each loop iteration\n   - Usually increments the counter\n   - i++ means 'add 1 to i' (same as i = i + 1)\n\nHow it flows:\n1. let i = 0           (start)\n2. Is i < 5? Yes (0 < 5)  → run loop body\n3. i++ → i is now 1\n4. Is i < 5? Yes (1 < 5)  → run loop body\n5. i++ → i is now 2\n6. Is i < 5? Yes (2 < 5)  → run loop body\n7. i++ → i is now 3\n8. Is i < 5? Yes (3 < 5)  → run loop body\n9. i++ → i is now 4\n10. Is i < 5? Yes (4 < 5) → run loop body\n11. i++ → i is now 5\n12. Is i < 5? No (5 is NOT < 5) → EXIT LOOP\n\nCommon patterns:\n- Count up: i++\n- Count down: i--\n- Skip by 2: i += 2\n- Count by 10s: i += 10"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Off-by-one errors (VERY common!):\n   for (let i = 0; i < 5; i++)  // Runs 5 times (0,1,2,3,4)\n   for (let i = 1; i < 5; i++)  // Runs 4 times (1,2,3,4)\n   for (let i = 1; i <= 5; i++) // Runs 5 times (1,2,3,4,5)\n   Always test: does this loop run the right number of times?\n\n2. Infinite loops:\n   for (let i = 0; i < 5; i--) // i gets SMALLER, never reaches 5!\n   This will crash your program!\n\n3. Forgetting to increment:\n   for (let i = 0; i < 5; ) // Missing i++\n   Another infinite loop!\n\n4. Using = instead of ==:\n   for (let i = 0; i = 5; i++)  // WRONG - assigns 5 to i!\n   for (let i = 0; i < 5; i++)  // CORRECT\n\n5. Modifying the loop variable inside:\n   for (let i = 0; i < 5; i++) {\n     i = 0;  // BAD - creates infinite loop!\n   }\n   Don't change i inside the loop body!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.1-challenge",
              "title": "Practice Challenge",
              "description": "Create a multiplication table for 7:\nUse a for loop to display:\n7 x 1 = 7\n7 x 2 = 14\n7 x 3 = 21\n...up to...\n7 x 10 = 70\n\nHint: Loop from 1 to 10, and each time display: console.log('7 x ' + i + ' = ' + (7 * i));",
              "instructions": "Create a multiplication table for 7:\nUse a for loop to display:\n7 x 1 = 7\n7 x 2 = 14\n7 x 3 = 21\n...up to...\n7 x 10 = 70\n\nHint: Loop from 1 to 10, and each time display: console.log('7 x ' + i + ' = ' + (7 * i));",
              "starterCode": "// Create a for loop that goes from 1 to 10\n// Each time, display the multiplication\n",
              "solution": "for (let i = 1; i <= 10; i++) {\n  console.log('7 x ' + i + ' = ' + (7 * i));\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays 7 x 1 = 7",
                  "expectedOutput": "7 x 1 = 7",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "for (let i = 1; i <= 10; i++) { console.log('7 x ' + i + ' = ' + (7 * i)); }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Off-by-one errors (VERY common!):",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Off-by-one errors (VERY common!):\n   for (let i = 0; i < 5; i++)  // Runs 5 times (0,1,2,3,4)\n   for (let i = 1; i < 5; i++)  // Runs 4 times (1,2,3,4)\n   for (let i = 1; i <= 5; i++) // Runs 5 times (1,2,3,4,5)\n   Always test: does this loop run the right number of times?"
                },
                {
                  "mistake": "Infinite loops:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Infinite loops:\n   for (let i = 0; i < 5; i--) // i gets SMALLER, never reaches 5!\n   This will crash your program!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "4.2",
          "title": "Looping Until a Condition Changes (while Loops)",
          "moduleId": "module-04",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're filling a bathtub. You don't know EXACTLY how many seconds it will take - you just know you need to keep the water running WHILE the tub is not full.\n\nEvery few seconds you check: 'Is it full yet?' No → keep filling. 'Is it full yet?' No → keep filling. 'Is it full yet?' YES → turn off the water!\n\nThis is what a 'while loop' does. Unlike a for loop (where you know how many times to repeat), a while loop keeps going UNTIL a condition becomes false. You don't know how many times it will run - you just know the condition that needs to be met to stop."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Basic while loop - count to 5\nlet count = 0;\n\nwhile (count < 5) {\n  console.log('Count: ' + count);\n  count++;  // IMPORTANT: Don't forget to update!\n}\n\n// Practical example: password attempts\nlet password = 'secret';\nlet userInput = 'wrong';\nlet attempts = 0;\nlet maxAttempts = 3;\n\nwhile (userInput !== password && attempts < maxAttempts) {\n  console.log('Attempt ' + (attempts + 1) + ': Incorrect password');\n  // In a real app, you'd ask for input here\n  // For this example, we'll just increment\n  attempts++;\n  if (attempts === 2) {\n    userInput = 'secret';  // Correct on 3rd try\n  }\n}\n\nif (userInput === password) {\n  console.log('Access granted!');\n} else {\n  console.log('Too many failed attempts');\n}\n\n// Countdown example\nlet countdown = 5;\nwhile (countdown > 0) {\n  console.log(countdown);\n  countdown--;\n}\nconsole.log('Liftoff!');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Structure of a while loop:\n\nwhile (condition) {\n       │\n       └─ Keep looping while this is true\n  // Code to repeat\n  // MUST update something that affects the condition!\n}\n\nHow it works:\n1. Check the condition\n2. If true: run the loop body, then go back to step 1\n3. If false: exit the loop\n\nCritical difference from for loop:\n- for loop: Use when you KNOW how many times to loop\n  for (let i = 0; i < 10; i++) { }  // Exactly 10 times\n\n- while loop: Use when you DON'T know how many times\n  while (notFullYet) { }  // Until it's full (who knows how long?)\n\n**WARNING**: You MUST change something in the loop that affects the condition, or you'll create an infinite loop!\n\nGood (will eventually stop):\nlet x = 0;\nwhile (x < 5) {\n  console.log(x);\n  x++;  // x changes, will eventually reach 5\n}\n\nBAD (infinite loop!):\nlet x = 0;\nwhile (x < 5) {\n  console.log(x);  // x never changes!\n  // Loop runs forever!\n}\n\nCommon while loop patterns:\n- Keep trying until success\n- Process until data runs out\n- Wait for a condition to change"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting to update the condition variable:\n   let x = 0;\n   while (x < 10) {\n     console.log(x);  // x never changes - INFINITE LOOP!\n   }\n\n2. Updating in the wrong direction:\n   let x = 0;\n   while (x < 10) {\n     console.log(x);\n     x--;  // x gets MORE negative - INFINITE LOOP!\n   }\n\n3. Wrong comparison operator:\n   let x = 0;\n   while (x < 10) {\n     console.log(x);\n     x--;  // Should be x++\n   }\n\n4. Condition that's never true:\n   let x = 5;\n   while (x < 0) {  // 5 is not < 0\n     // This never runs at all!\n   }\n\n5. Not initializing before the loop:\n   while (count < 10) {  // count is not defined!\n     count++;\n   }\n   Must declare: let count = 0; BEFORE the while loop"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.2-challenge",
              "title": "Practice Challenge",
              "description": "Create a simple number guessing game:\n1. Set a target number (e.g., 7)\n2. Set a guess variable to 1\n3. Use a while loop that runs while guess is not equal to target\n4. Each time through the loop:\n   - Display: 'Guess: [number] - Wrong!'\n   - Increment guess by 1\n5. After the loop, display: 'Guess: [number] - Correct!'",
              "instructions": "Create a simple number guessing game:\n1. Set a target number (e.g., 7)\n2. Set a guess variable to 1\n3. Use a while loop that runs while guess is not equal to target\n4. Each time through the loop:\n   - Display: 'Guess: [number] - Wrong!'\n   - Increment guess by 1\n5. After the loop, display: 'Guess: [number] - Correct!'",
              "starterCode": "let target = 7;\nlet guess = 1;\n\n// Write your while loop here\n\n// After the loop, display the correct message\n",
              "solution": "let target = 7;\nlet guess = 1;\n\nwhile (guess !== target) {\n  console.log('Guess: ' + guess + ' - Wrong!');\n  guess++;\n}\n\nconsole.log('Guess: ' + guess + ' - Correct!');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Keeps guessing until correct",
                  "expectedOutput": "Guess: 1 - Wrong!\nGuess: 2 - Wrong!\nGuess: 3 - Correct!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "while (guess !== target) { console.log('Guess: ' + guess + ' - Wrong!'); guess++; }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting to update the condition variable:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting to update the condition variable:\n   let x = 0;\n   while (x < 10) {\n     console.log(x);  // x never changes - INFINITE LOOP!\n   }"
                },
                {
                  "mistake": "Updating in the wrong direction:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Updating in the wrong direction:\n   let x = 0;\n   while (x < 10) {\n     console.log(x);\n     x--;  // x gets MORE negative - INFINITE LOOP!\n   }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "4.3",
          "title": "Breaking Out Early (break and continue)",
          "moduleId": "module-04",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're looking through a stack of 100 papers for a specific document:\n\n**break**: You find the document on paper #37. You don't need to look through the remaining 63 papers - you STOP immediately and leave. That's what 'break' does - it exits the loop early.\n\n**continue**: You're reading through papers, but whenever you see a blank page, you skip it and go to the next one without processing it. That's what 'continue' does - it skips to the next iteration of the loop.\n\nBoth are useful for making loops more efficient and handling special cases."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// BREAK - exit the loop early\nconsole.log('--- Using break ---');\nfor (let i = 1; i <= 10; i++) {\n  if (i === 5) {\n    console.log('Found 5! Stopping.');\n    break;  // Exit the entire loop\n  }\n  console.log(i);\n}\nconsole.log('Loop finished');\n// Output: 1, 2, 3, 4, Found 5! Stopping., Loop finished\n\n// CONTINUE - skip to next iteration\nconsole.log('--- Using continue ---');\nfor (let i = 1; i <= 10; i++) {\n  if (i % 2 === 0) {  // If even number\n    continue;  // Skip the rest, go to next iteration\n  }\n  console.log(i);  // Only odd numbers print\n}\n// Output: 1, 3, 5, 7, 9\n\n// Practical: searching for a value\nlet numbers = [5, 8, 12, 15, 20, 25];\nlet target = 15;\nlet found = false;\n\nfor (let i = 0; i < numbers.length; i++) {\n  if (numbers[i] === target) {\n    console.log('Found ' + target + ' at position ' + i);\n    found = true;\n    break;  // No need to keep searching!\n  }\n}\n\nif (!found) {\n  console.log(target + ' not found');\n}\n\n// Skip invalid data\nfor (let i = 1; i <= 5; i++) {\n  if (i === 3) {\n    console.log('Skipping 3');\n    continue;\n  }\n  console.log('Processing: ' + i);\n}\n// Processes 1, 2, skips 3, processes 4, 5"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Two flow control keywords:\n\n**break**\n- Immediately exits the loop\n- Execution continues after the loop\n- Use when you've found what you're looking for\n- Use when a condition makes continuing pointless\n\nExample:\nfor (let i = 0; i < 100; i++) {\n  if (found) {\n    break;  // Don't check remaining 90 items\n  }\n}\nconsole.log('Continue here');  // This runs after break\n\n**continue**\n- Skips the rest of the current iteration\n- Goes directly to the next iteration\n- Use to skip invalid/unwanted values\n- Use to avoid deep nesting\n\nExample:\nfor (let i = 0; i < 10; i++) {\n  if (i === 5) {\n    continue;  // Skip when i is 5\n  }\n  console.log(i);  // This doesn't run when i is 5\n  // But runs for all other values\n}\n\nComparing break vs continue:\n\nbreak:\nfor (let i = 0; i < 5; i++) {\n  if (i === 3) break;\n  console.log(i);\n}\n// Prints: 0, 1, 2 (then EXITS loop)\n\ncontinue:\nfor (let i = 0; i < 5; i++) {\n  if (i === 3) continue;\n  console.log(i);\n}\n// Prints: 0, 1, 2, 4 (SKIPS 3, continues loop)\n\nImportant: break and continue only affect the INNERMOST loop they're in. If you have nested loops, they don't break out of all loops."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Using break outside a loop:\n   if (x > 5) {\n     break;  // ERROR - not in a loop!\n   }\n   break only works inside loops or switch statements\n\n2. Confusing break and return:\n   - break exits a loop\n   - return exits a function (we'll learn soon)\n   Don't mix them up!\n\n3. Expecting break to exit nested loops:\n   for (let i = 0; i < 3; i++) {\n     for (let j = 0; j < 3; j++) {\n       if (j === 1) break;  // Only exits inner loop!\n     }\n   }\n   To exit all loops, use a flag or a function with return\n\n4. Forgetting to update counter before continue:\n   let i = 0;\n   while (i < 10) {\n     if (i === 5) continue;  // INFINITE LOOP!\n     console.log(i);\n     i++;  // Never reached when i is 5\n   }\n   Fix: Put i++ before the continue check\n\n5. Overusing break/continue:\n   Sometimes an if statement is clearer:\n   for (let i = 0; i < 10; i++) {\n     if (i !== 5) {  // Clearer than using continue\n       console.log(i);\n     }\n   }"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.3-challenge",
              "title": "Practice Challenge",
              "description": "Create a loop that finds the first number divisible by 7 between 1 and 50:\n1. Use a for loop from 1 to 50\n2. Check if the number is divisible by 7 (use i % 7 === 0)\n3. When you find it, display 'First number divisible by 7: [number]'\n4. Use 'break' to exit the loop (no need to check the rest)",
              "instructions": "Create a loop that finds the first number divisible by 7 between 1 and 50:\n1. Use a for loop from 1 to 50\n2. Check if the number is divisible by 7 (use i % 7 === 0)\n3. When you find it, display 'First number divisible by 7: [number]'\n4. Use 'break' to exit the loop (no need to check the rest)",
              "starterCode": "// Loop from 1 to 50\n// Check if divisible by 7\n// Display and break when found\n",
              "solution": "for (let i = 1; i <= 50; i++) {\n  if (i % 7 === 0) {\n    console.log('First number divisible by 7: ' + i);\n    break;\n  }\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Finds first number divisible by 7",
                  "expectedOutput": "First number divisible by 7: 7",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "for (let i = 1; i <= 50; i++) { if (i % 7 === 0) { console.log('First number divisible by 7: ' + i); break; } }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Using break outside a loop:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using break outside a loop:\n   if (x > 5) {\n     break;  // ERROR - not in a loop!\n   }\n   break only works inside loops or switch statements"
                },
                {
                  "mistake": "Confusing break and return:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Confusing break and return:\n   - break exits a loop\n   - return exits a function (we'll learn soon)\n   Don't mix them up!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "4.4",
          "title": "Looping Through Lists (for...of)",
          "moduleId": "module-04",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have a playlist of songs, and you want to play each one in order. You don't care about the position (song #1, song #2, etc.) - you just want to go through each song:\n\n'Play song: Song A'\n'Play song: Song B'\n'Play song: Song C'\n\nYou're iterating through the LIST, not counting numbers. This is perfect for the 'for...of' loop - it's designed specifically for going through each item in a list (array) without worrying about indices or counters."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Old way: using a regular for loop with an index\nlet fruits = ['apple', 'banana', 'cherry'];\n\nfor (let i = 0; i < fruits.length; i++) {\n  console.log(fruits[i]);  // Need to use fruits[i] to get the item\n}\n\n// New way: for...of loop (much cleaner!)\nfor (let fruit of fruits) {\n  console.log(fruit);  // Direct access to each item\n}\n\n// Another example: summing numbers\nlet numbers = [10, 20, 30, 40, 50];\nlet total = 0;\n\nfor (let num of numbers) {\n  total += num;\n}\nconsole.log('Total: ' + total);  // 150\n\n// Works with strings too! (string is a list of characters)\nlet word = 'hello';\n\nfor (let letter of word) {\n  console.log(letter);  // h, e, l, l, o\n}\n\n// Practical: find if item exists\nlet shoppingCart = ['milk', 'eggs', 'bread', 'butter'];\nlet lookingFor = 'eggs';\nlet hasItem = false;\n\nfor (let item of shoppingCart) {\n  if (item === lookingFor) {\n    hasItem = true;\n    break;\n  }\n}\n\nconsole.log(hasItem ? 'Found it!' : 'Not in cart');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding for...of:\n\nfor (let item of array) {\n     │   │    │    │\n     │   │    │    └─ The array to loop through\n     │   │    └────── The 'of' keyword\n     │   └─────────── Variable to hold each item (you choose the name)\n     └─────────────── let (or const)\n  // Use 'item' here\n}\n\nComparing loop types:\n\n// Regular for loop - use when you need the INDEX\nfor (let i = 0; i < arr.length; i++) {\n  console.log('Position ' + i + ': ' + arr[i]);\n}\n\n// for...of loop - use when you just need the ITEMS\nfor (let item of arr) {\n  console.log(item);  // Don't care about position\n}\n\n// while loop - use when you don't know how many times\nwhile (notDone) {\n  // Keep going until condition changes\n}\n\nWhen to use for...of:\n✓ Going through all items in an array\n✓ Don't need the index/position\n✓ Cleaner, more readable code\n\nWhen NOT to use for...of:\n✗ Need the index number\n✗ Need to modify the array while looping\n✗ Looping a specific number of times (use regular for)\n\nNote: You can use 'const' instead of 'let' in for...of:\nfor (const fruit of fruits) {\n  // fruit is reassigned each iteration, so const works!\n}\n\nArray.length:\n- Every array has a .length property\n- fruits.length → 3 (number of items)\n- Use in regular for loops: i < arr.length"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Using 'in' instead of 'of':\n   for (let fruit in fruits)  // WRONG - gives index, not item!\n   for (let fruit of fruits)  // CORRECT - gives the item\n   \n   Confusing, right? Remember: 'of' for values, 'in' for keys (we'll learn later)\n\n2. Trying to get the index:\n   for (let fruit of fruits) {\n     console.log(i);  // ERROR - i doesn't exist!\n   }\n   If you need the index, use a regular for loop or .forEach() (later)\n\n3. Modifying the array while looping:\n   for (let fruit of fruits) {\n     fruits.push('new');  // DANGEROUS - might cause infinite loop!\n   }\n   Don't modify the array you're looping through\n\n4. Expecting it to work on objects:\n   let person = {name: 'Alice', age: 25};\n   for (let prop of person)  // ERROR - for...of doesn't work on plain objects!\n   Use for...in for objects (later lesson)\n\n5. Using wrong variable name:\n   for (let fruit of fruits) {\n     console.log(fruits);  // Prints whole array each time!\n   }\n   Should be: console.log(fruit);  // Just one item"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.4-challenge",
              "title": "Practice Challenge",
              "description": "You have a list of temperatures in Celsius. Convert each to Fahrenheit and display it:\n1. Given array: [0, 10, 20, 30, 40]\n2. Use a for...of loop\n3. For each temperature, convert to Fahrenheit: (celsius * 9/5) + 32\n4. Display: '[celsius]°C is [fahrenheit]°F'",
              "instructions": "You have a list of temperatures in Celsius. Convert each to Fahrenheit and display it:\n1. Given array: [0, 10, 20, 30, 40]\n2. Use a for...of loop\n3. For each temperature, convert to Fahrenheit: (celsius * 9/5) + 32\n4. Display: '[celsius]°C is [fahrenheit]°F'",
              "starterCode": "let celsiusTemps = [0, 10, 20, 30, 40];\n\n// Use for...of to loop through each temperature\n// Convert and display each one\n",
              "solution": "let celsiusTemps = [0, 10, 20, 30, 40];\n\nfor (let celsius of celsiusTemps) {\n  let fahrenheit = (celsius * 9/5) + 32;\n  console.log(celsius + '°C is ' + fahrenheit + '°F');\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Converts 0°C correctly",
                  "expectedOutput": "0°C is 32°F",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "for (let celsius of celsiusTemps) { let fahrenheit = (celsius * 9/5) + 32; console.log(...); }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Using 'in' instead of 'of':",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using 'in' instead of 'of':\n   for (let fruit in fruits)  // WRONG - gives index, not item!\n   for (let fruit of fruits)  // CORRECT - gives the item\n   \n   Confusing, right? Remember: 'of' for values, 'in' for keys (we'll learn later)"
                },
                {
                  "mistake": "Trying to get the index:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Trying to get the index:\n   for (let fruit of fruits) {\n     console.log(i);  // ERROR - i doesn't exist!\n   }\n   If you need the index, use a regular for loop or .forEach() (later)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-05",
      "title": "Module 5: Grouping Information (The 'Containers')",
      "description": "Store and organize multiple pieces of related information using arrays and objects",
      "difficulty": "beginner",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "5.1",
          "title": "Ordered Lists of Things (Arrays)",
          "moduleId": "module-05",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have a shopping list written on paper:\n\n1. Milk\n2. Eggs\n3. Bread\n4. Butter\n\nThis is an ordered list - each item has a position (1st, 2nd, 3rd, etc.). In programming, we call this an ARRAY. It's a single variable that can hold multiple values in a specific order.\n\nThink of an array like a train with numbered cars: Car 0 has apples, Car 1 has bananas, Car 2 has cherries. The numbers (0, 1, 2) are called 'indices' (plural of index), and they tell you where each item is located.\n\nImportant quirk: Programming counts from 0, not 1! So the first item is at position 0, the second at position 1, and so on."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Creating an array\nlet fruits = ['apple', 'banana', 'cherry'];\n\n// Accessing items by index (position)\nconsole.log(fruits[0]);  // apple (first item)\nconsole.log(fruits[1]);  // banana (second item)\nconsole.log(fruits[2]);  // cherry (third item)\n\n// Arrays can hold different types\nlet mixed = ['text', 42, true, null];\nconsole.log(mixed[1]);  // 42\n\n// Empty array\nlet empty = [];\n\n// Array length (how many items)\nconsole.log(fruits.length);  // 3\n\n// Last item (using length)\nlet lastFruit = fruits[fruits.length - 1];\nconsole.log(lastFruit);  // cherry\n\n// Changing an item\nfruits[1] = 'blueberry';\nconsole.log(fruits);  // ['apple', 'blueberry', 'cherry']\n\n// Loop through array\nfor (let i = 0; i < fruits.length; i++) {\n  console.log('Item ' + i + ': ' + fruits[i]);\n}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Array syntax:\n\n// Creating arrays\nlet arrayName = [item1, item2, item3];\nlet empty = [];\n\n// Accessing items (zero-indexed!)\narray[0]  // First item\narray[1]  // Second item\narray[2]  // Third item\n\n// Index visualization:\nlet numbers = [10, 20, 30, 40, 50];\n//  Index:     0   1   2   3   4\n//  Value:    10  20  30  40  50\n\nnumbers[0] → 10\nnumbers[4] → 50\nnumbers[5] → undefined (doesn't exist)\n\nKey properties:\n\n1. .length - number of items\n   - ['a', 'b', 'c'].length → 3\n   - [].length → 0\n\n2. Zero-indexed\n   - First item: array[0]\n   - Last item: array[array.length - 1]\n\n3. Mutable (can be changed)\n   - array[0] = 'new value'\n\n4. Can hold any type\n   - [1, 'text', true, {}, []]  // all valid\n\nCommon patterns:\n\n// Last item\nlet last = array[array.length - 1];\n\n// Check if empty\nif (array.length === 0) {\n  console.log('Empty');\n}\n\n// Loop through all items\nfor (let i = 0; i < array.length; i++) {\n  // use array[i]\n}"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Starting at index 1 instead of 0:\n   array[1]  // This is the SECOND item, not first!\n   array[0]  // This is the first item\n\n2. Accessing index === length:\n   let arr = ['a', 'b', 'c'];  // length is 3\n   arr[3]  // undefined - no such index!\n   // Valid indices: 0, 1, 2\n\n3. Forgetting .length is a property, not a method:\n   array.length()  // WRONG\n   array.length    // CORRECT (no parentheses)\n\n4. Confusing length with last index:\n   let arr = ['a', 'b', 'c'];\n   arr.length       // 3 (count of items)\n   arr[arr.length]  // undefined!\n   arr[arr.length - 1]  // 'c' (last item)\n\n5. Treating arrays like single values:\n   let arr = [1, 2, 3];\n   console.log(arr);  // Prints whole array [1, 2, 3]\n   console.log(arr[0]);  // Prints just first item: 1"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.1-challenge",
              "title": "Practice Challenge",
              "description": "Create a simple gradebook:\n1. Create an array of test scores: [85, 92, 78, 95, 88]\n2. Display the first score (index 0)\n3. Display the last score (use .length - 1)\n4. Calculate and display the average score (sum all, divide by length)",
              "instructions": "Create a simple gradebook:\n1. Create an array of test scores: [85, 92, 78, 95, 88]\n2. Display the first score (index 0)\n3. Display the last score (use .length - 1)\n4. Calculate and display the average score (sum all, divide by length)",
              "starterCode": "let scores = [85, 92, 78, 95, 88];\n\n// Display first score\n\n// Display last score\n\n// Calculate average\nlet total = 0;\n// Use a loop to sum all scores\n// Then divide by scores.length\n",
              "solution": "let scores = [85, 92, 78, 95, 88];\n\nconsole.log('First score: ' + scores[0]);\nconsole.log('Last score: ' + scores[scores.length - 1]);\n\nlet total = 0;\nfor (let i = 0; i < scores.length; i++) {\n  total += scores[i];\n}\n\nlet average = total / scores.length;\nconsole.log('Average: ' + average);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays first score",
                  "expectedOutput": "85",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "First: scores[0], Last: scores[scores.length - 1], Average: sum all in loop, divide by scores.length"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Starting at index 1 instead of 0:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Starting at index 1 instead of 0:\n   array[1]  // This is the SECOND item, not first!\n   array[0]  // This is the first item"
                },
                {
                  "mistake": "Accessing index === length:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Accessing index === length:\n   let arr = ['a', 'b', 'c'];  // length is 3\n   arr[3]  // undefined - no such index!\n   // Valid indices: 0, 1, 2"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.2",
          "title": "Adding and Removing Items (Array Methods: push, pop, shift, unshift)",
          "moduleId": "module-05",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine your array is a line of people:\n\n**push()**: Someone new joins the END of the line\n**pop()**: The person at the END of the line leaves\n**unshift()**: Someone cuts in at the FRONT of the line\n**shift()**: The person at the FRONT of the line leaves\n\nThese four methods let you add or remove items from either end of an array. They're like doors - two at the back (push/pop) and two at the front (shift/unshift)."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "let fruits = ['apple', 'banana'];\nconsole.log(fruits);  // ['apple', 'banana']\n\n// push() - add to the END\nfruits.push('cherry');\nconsole.log(fruits);  // ['apple', 'banana', 'cherry']\n\n// Can push multiple at once\nfruits.push('date', 'elderberry');\nconsole.log(fruits);  // ['apple', 'banana', 'cherry', 'date', 'elderberry']\n\n// pop() - remove from the END, returns the removed item\nlet removed = fruits.pop();\nconsole.log(removed);  // 'elderberry'\nconsole.log(fruits);  // ['apple', 'banana', 'cherry', 'date']\n\n// unshift() - add to the FRONT\nfruits.unshift('apricot');\nconsole.log(fruits);  // ['apricot', 'apple', 'banana', 'cherry', 'date']\n\n// shift() - remove from the FRONT, returns the removed item\nlet firstItem = fruits.shift();\nconsole.log(firstItem);  // 'apricot'\nconsole.log(fruits);  // ['apple', 'banana', 'cherry', 'date']\n\n// Practical: stack (Last In, First Out)\nlet stack = [];\nstack.push('task 1');\nstack.push('task 2');\nstack.push('task 3');\nlet current = stack.pop();  // 'task 3' - most recent\n\n// Practical: queue (First In, First Out)\nlet queue = [];\nqueue.push('person 1');\nqueue.push('person 2');\nqueue.push('person 3');\nlet next = queue.shift();  // 'person 1' - first in line"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "The four basic array methods:\n\n1. push(item) - add to END\n   - Adds one or more items to the end\n   - Returns new length\n   - Example: arr.push('x') → adds 'x' to end\n\n2. pop() - remove from END\n   - Removes last item\n   - Returns the removed item\n   - Example: let last = arr.pop()\n\n3. unshift(item) - add to FRONT\n   - Adds one or more items to the beginning\n   - Shifts all existing items to higher indices\n   - Returns new length\n   - Example: arr.unshift('x') → adds 'x' to front\n\n4. shift() - remove from FRONT\n   - Removes first item\n   - Shifts all remaining items to lower indices\n   - Returns the removed item\n   - Example: let first = arr.shift()\n\nMemory trick:\n- push/pop: work with the END (both have 'p')\n- shift/unshift: work with the FRONT\n- push/unshift: ADD items\n- pop/shift: REMOVE items\n\nPerformance notes:\n- push() and pop(): Fast (O(1))\n- shift() and unshift(): Slower (O(n)) because indices must be recalculated\n- For large arrays, avoid shift/unshift if performance matters\n\nThese methods MODIFY the original array:\nlet arr = [1, 2];\narr.push(3);  // arr is now [1, 2, 3]\n// The original array changed!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting these methods modify the array:\n   let arr = [1, 2, 3];\n   arr.push(4);  // arr is NOW [1, 2, 3, 4]\n   // It's not arr2 = arr.push(4)\n\n2. Expecting push/pop to work on both ends:\n   arr.pop()  // Removes from END, not front\n   // Use shift() to remove from front\n\n3. Not using the return value:\n   arr.pop();  // Item is removed AND returned\n   let item = arr.pop();  // Save the removed item!\n\n4. Confusing shift/unshift names:\n   shift = remove first (shifts everything left)\n   unshift = add to first (unshifts everything right)\n   Confusing, but that's the name!\n\n5. Using on non-arrays:\n   let str = 'hello';\n   str.push('x');  // ERROR - strings don't have push\n   // Convert to array first: str.split('')"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.2-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a simple to-do list:\n1. Start with an empty array: let todos = []\n2. Add 'Buy groceries' to the end\n3. Add 'Clean room' to the end\n4. Add 'URGENT: Pay bills' to the FRONT (it's urgent!)\n5. Display the array\n6. Complete the first task (remove it with shift())\n7. Display the updated array",
              "instructions": "Simulate a simple to-do list:\n1. Start with an empty array: let todos = []\n2. Add 'Buy groceries' to the end\n3. Add 'Clean room' to the end\n4. Add 'URGENT: Pay bills' to the FRONT (it's urgent!)\n5. Display the array\n6. Complete the first task (remove it with shift())\n7. Display the updated array",
              "starterCode": "let todos = [];\n\n// Add tasks\n\n// Display\n\n// Complete first task\n\n// Display again\n",
              "solution": "let todos = [];\n\ntodos.push('Buy groceries');\ntodos.push('Clean room');\ntodos.unshift('URGENT: Pay bills');\n\nconsole.log('Todos:', todos);\n// ['URGENT: Pay bills', 'Buy groceries', 'Clean room']\n\nlet completed = todos.shift();\nconsole.log('Completed:', completed);\nconsole.log('Remaining todos:', todos);\n// ['Buy groceries', 'Clean room']",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Builds todo list correctly",
                  "expectedOutput": "3",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "push() for end, unshift() for front, shift() to remove first"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting these methods modify the array:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting these methods modify the array:\n   let arr = [1, 2, 3];\n   arr.push(4);  // arr is NOW [1, 2, 3, 4]\n   // It's not arr2 = arr.push(4)"
                },
                {
                  "mistake": "Expecting push/pop to work on both ends:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Expecting push/pop to work on both ends:\n   arr.pop()  // Removes from END, not front\n   // Use shift() to remove from front"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.3",
          "title": "Searching and Transforming Lists (find, filter, map, reduce)",
          "moduleId": "module-05",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're managing a music playlist with 1000 songs:\n\n**find()**: 'Find me the first song by Taylor Swift' - you scan through until you find ONE match, then stop.\n\n**filter()**: 'Give me all songs from 2020' - you go through the entire list and create a NEW list with only the songs that match.\n\n**map()**: 'Convert all song titles to uppercase' - you go through each song and create a NEW list where each item has been transformed.\n\n**reduce()**: 'Calculate the total duration of all songs' - you go through each song, adding up all the durations into a SINGLE result. Reduce is like a snowball rolling down a hill, accumulating more snow (data) as it goes.\n\nThese are four of the most powerful array methods in JavaScript. They don't change the original array - they create new values or arrays."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "let numbers = [1, 4, 7, 10, 15, 20];\n\n// find() - returns FIRST item that matches\nlet firstBigNumber = numbers.find(function(num) {\n  return num > 10;\n});\nconsole.log(firstBigNumber);  // 15 (first one > 10)\n\n// filter() - returns ALL items that match\nlet bigNumbers = numbers.filter(function(num) {\n  return num > 10;\n});\nconsole.log(bigNumbers);  // [15, 20]\n\n// map() - transforms each item, returns new array\nlet doubled = numbers.map(function(num) {\n  return num * 2;\n});\nconsole.log(doubled);  // [2, 8, 14, 20, 30, 40]\nconsole.log(numbers);  // [1, 4, 7, 10, 15, 20] - original unchanged!\n\n// Real-world examples\nlet products = [\n  { name: 'Laptop', price: 1000 },\n  { name: 'Mouse', price: 25 },\n  { name: 'Keyboard', price: 75 },\n  { name: 'Monitor', price: 300 }\n];\n\n// Find first expensive item\nlet expensive = products.find(p => p.price > 500);\nconsole.log(expensive);  // {name: 'Laptop', price: 1000}\n\n// Filter affordable items\nlet affordable = products.filter(p => p.price < 100);\nconsole.log(affordable);  // Mouse and Keyboard\n\n// Get array of just names\nlet names = products.map(p => p.name);\nconsole.log(names);  // ['Laptop', 'Mouse', 'Keyboard', 'Monitor']\n\n// reduce() - accumulate values into a single result\nlet prices = [100, 200, 50, 75];\n\n// Calculate total (the snowball rolling down the hill!)\nlet total = prices.reduce(function(accumulator, currentPrice) {\n  return accumulator + currentPrice;\n}, 0);  // 0 is the starting value\n\nconsole.log(total);  // 425\n\n// Real-world: Calculate total price of cart\nlet totalCartPrice = products.reduce(function(sum, product) {\n  return sum + product.price;\n}, 0);\n\nconsole.log('Cart total: $' + totalCartPrice);  // $1400\n\n// Count items (using reduce creatively)\nlet words = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple'];\nlet wordCount = words.reduce(function(counts, word) {\n  counts[word] = (counts[word] || 0) + 1;\n  return counts;\n}, {});\n\nconsole.log(wordCount);  // {apple: 3, banana: 2, cherry: 1}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding the three methods:\n\n1. **find(callbackFunction)**\n   - Goes through array until callback returns true\n   - Returns the FIRST matching item\n   - Returns undefined if no match found\n   - Syntax: array.find(item => condition)\n\nExample:\nlet ages = [12, 18, 25, 30];\nlet adult = ages.find(age => age >= 18);  // 18\n\n2. **filter(callbackFunction)**\n   - Goes through ENTIRE array\n   - Returns NEW array with ALL matching items\n   - Returns empty array [] if no matches\n   - Original array unchanged\n   - Syntax: array.filter(item => condition)\n\nExample:\nlet adults = ages.filter(age => age >= 18);  // [18, 25, 30]\n\n3. **map(callbackFunction)**\n   - Goes through ENTIRE array\n   - Transforms each item\n   - Returns NEW array (same length as original)\n   - Original array unchanged\n   - Syntax: array.map(item => transformation)\n\nExample:\nlet doubled = ages.map(age => age * 2);  // [24, 36, 50, 60]\n\nCallback function:\n- A function you pass to another function\n- Gets called for each item\n- Receives: (item, index, array)\n- Usually you only need: item\n\nArrow function shorthand:\n// Long form\narray.find(function(item) {\n  return item > 10;\n})\n\n// Short form\narray.find(item => item > 10)\n\n4. **reduce(callbackFunction, initialValue)**\n   - Goes through ENTIRE array\n   - Accumulates/combines all values into a SINGLE result\n   - Like a snowball rolling downhill, gathering more\n   - Can return ANY type (number, string, object, array)\n   - Syntax: array.reduce((accumulator, item) => newAccumulator, startValue)\n\nExample - Sum numbers:\nlet prices = [10, 20, 30];\nlet total = prices.reduce((sum, price) => sum + price, 0);\n// Step 1: sum=0, price=10 → returns 10\n// Step 2: sum=10, price=20 → returns 30\n// Step 3: sum=30, price=30 → returns 60\n// Result: 60\n\nExample - Build object:\nlet fruits = ['apple', 'banana', 'apple'];\nlet counts = fruits.reduce((obj, fruit) => {\n  obj[fruit] = (obj[fruit] || 0) + 1;\n  return obj;\n}, {});\n// Result: {apple: 2, banana: 1}\n\nCallback function parameters:\n- **accumulator**: The accumulated value (result so far)\n- **currentValue**: Current item being processed\n- **index**: Current index (optional)\n- **array**: Original array (optional)\n\nInitial value:\n- Second argument to reduce()\n- Starting point for accumulator\n- Common values: 0 (for sums), '' (for strings), {} (for objects), [] (for arrays)\n- If omitted, first array element is used\n\nReturn value patterns:\n- find: single item or undefined\n- filter: new array (could be empty)\n- map: new array (same length as original)\n- reduce: single value of ANY type (number, string, object, array, etc.)"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Expecting find() to return all matches:\n   arr.find(x => x > 5)  // Returns FIRST match only\n   arr.filter(x => x > 5)  // Returns ALL matches\n\n2. Forgetting that map() always returns same-length array:\n   [1, 2, 3].map(x => x * 2)  // [2, 4, 6] - still 3 items\n   // Can't make array shorter with map, use filter for that\n\n3. Confusing filter and map:\n   filter: selects items (can make array shorter)\n   map: transforms items (same length)\n\n4. Not returning in the callback:\n   arr.map(x => { x * 2 })  // Returns [undefined, undefined, ...]\n   arr.map(x => x * 2)  // Correct - implicit return\n   arr.map(x => { return x * 2 })  // Also correct - explicit return\n\n5. Forgetting these don't modify original:\n   let arr = [1, 2, 3];\n   arr.map(x => x * 2);  // arr is still [1, 2, 3]!\n   let doubled = arr.map(x => x * 2);  // Save the result!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.3-challenge",
              "title": "Practice Challenge",
              "description": "You have a list of student objects. Use array methods to:\n1. Find the first student with a grade >= 90\n2. Filter to get all students who passed (grade >= 60)\n3. Map to get an array of just the student names\n\nlet students = [\n  {name: 'Alice', grade: 85},\n  {name: 'Bob', grade: 92},\n  {name: 'Charlie', grade: 58},\n  {name: 'Diana', grade: 95}\n];",
              "instructions": "You have a list of student objects. Use array methods to:\n1. Find the first student with a grade >= 90\n2. Filter to get all students who passed (grade >= 60)\n3. Map to get an array of just the student names\n\nlet students = [\n  {name: 'Alice', grade: 85},\n  {name: 'Bob', grade: 92},\n  {name: 'Charlie', grade: 58},\n  {name: 'Diana', grade: 95}\n];",
              "starterCode": "let students = [\n  {name: 'Alice', grade: 85},\n  {name: 'Bob', grade: 92},\n  {name: 'Charlie', grade: 58},\n  {name: 'Diana', grade: 95}\n];\n\n// Find first with grade >= 90\n\n// Filter students who passed (>= 60)\n\n// Map to get just names\n",
              "solution": "let students = [\n  {name: 'Alice', grade: 85},\n  {name: 'Bob', grade: 92},\n  {name: 'Charlie', grade: 58},\n  {name: 'Diana', grade: 95}\n];\n\nlet topStudent = students.find(s => s.grade >= 90);\nconsole.log('Top student:', topStudent);  // Bob\n\nlet passed = students.filter(s => s.grade >= 60);\nconsole.log('Passed:', passed);  // Alice, Bob, Diana\n\nlet names = students.map(s => s.name);\nconsole.log('All names:', names);  // ['Alice', 'Bob', 'Charlie', 'Diana']",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Finds first top student",
                  "expectedOutput": "Bob",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "find(s => s.grade >= 90), filter(s => s.grade >= 60), map(s => s.name)"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Expecting find() to return all matches:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Expecting find() to return all matches:\n   arr.find(x => x > 5)  // Returns FIRST match only\n   arr.filter(x => x > 5)  // Returns ALL matches"
                },
                {
                  "mistake": "Forgetting that map() always returns same-length array:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting that map() always returns same-length array:\n   [1, 2, 3].map(x => x * 2)  // [2, 4, 6] - still 3 items\n   // Can't make array shorter with map, use filter for that"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.4",
          "title": "Dictionaries: Storing Information with Labels (Objects)",
          "moduleId": "module-05",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're filling out a form about yourself:\n\nName: Alice\nAge: 25\nCity: New York\nIs Student: true\n\nEach piece of info has a LABEL (Name, Age, etc.) and a VALUE ('Alice', 25, etc.). This is different from an array, where items are accessed by position numbers. Here, you access items by NAME.\n\nIn JavaScript, this is called an OBJECT. Think of it like a real dictionary: you look up a WORD (the key) to find its DEFINITION (the value). Or like a person's contact card: each field (label) has a value.\n\nObjects are perfect for representing things with named properties: a user, a product, a car, etc."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Creating an object\nlet person = {\n  name: 'Alice',\n  age: 25,\n  city: 'New York',\n  isStudent: false\n};\n\n// Accessing properties (two ways)\nconsole.log(person.name);      // Alice (dot notation)\nconsole.log(person['age']);    // 25 (bracket notation)\n\n// Changing a property\nperson.age = 26;\nconsole.log(person.age);  // 26\n\n// Adding a new property\nperson.email = 'alice@example.com';\nconsole.log(person.email);  // alice@example.com\n\n// Deleting a property\ndelete person.isStudent;\nconsole.log(person.isStudent);  // undefined\n\n// Object with different types\nlet product = {\n  name: 'Laptop',\n  price: 999.99,\n  inStock: true,\n  specs: ['16GB RAM', '512GB SSD'],  // Array inside object!\n  manufacturer: {\n    name: 'Dell',\n    country: 'USA'\n  }  // Object inside object!\n};\n\nconsole.log(product.specs[0]);  // 16GB RAM\nconsole.log(product.manufacturer.name);  // Dell\n\n// Empty object\nlet empty = {};"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Object syntax:\n\n// Creating an object\nlet objectName = {\n  key1: value1,\n  key2: value2,\n  key3: value3\n};\n\nKey points:\n\n1. Surrounded by curly braces { }\n2. Key-value pairs separated by commas\n3. Key and value separated by colon :\n4. Keys are usually unquoted (unless they have spaces)\n5. Values can be any type\n\nAccessing properties:\n\n// Dot notation (most common)\nobject.propertyName\n\n// Bracket notation (for special cases)\nobject['property name']  // Property has space\nobject[variableName]     // Property name is in a variable\n\nWhen to use brackets:\n- Property name has spaces/special chars: obj['first name']\n- Property name is in a variable: let prop = 'age'; obj[prop]\n- Property name is computed: obj['item' + i]\n\nModifying objects:\n\n// Change existing property\nobj.name = 'new value';\n\n// Add new property\nobj.newProperty = 'value';\n\n// Delete property\ndelete obj.property;\n\n// Check if property exists\nif (obj.property !== undefined) { }\n// OR\nif ('property' in obj) { }\n\nNested structures:\nlet user = {\n  name: 'Alice',\n  address: {\n    street: '123 Main St',\n    city: 'NYC'\n  },\n  hobbies: ['reading', 'coding']\n};\n\nuser.address.city  // NYC\nuser.hobbies[0]    // reading"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting commas between properties:\n   {name: 'Alice' age: 25}  // WRONG - missing comma\n   {name: 'Alice', age: 25}  // CORRECT\n\n2. Using = instead of ::\n   {name = 'Alice'}  // WRONG\n   {name: 'Alice'}   // CORRECT\n\n3. Trailing comma on last property:\n   {name: 'Alice', age: 25,}  // Works in modern JS, but some old browsers error\n\n4. Confusing arrays and objects:\n   let arr = [1, 2, 3];    // Square brackets\n   let obj = {a: 1, b: 2}; // Curly braces\n\n5. Trying to use dot notation with spaces:\n   obj.first name  // WRONG\n   obj['first name']  // CORRECT\n   obj.firstName   // BETTER - use camelCase\n\n6. Expecting specific order:\n   Objects don't guarantee property order (though modern JS usually preserves it)\n   If order matters, use an array!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.4-challenge",
              "title": "Practice Challenge",
              "description": "Create an object representing a book:\n1. Create object with: title (string), author (string), pages (number), isRead (boolean)\n2. Display the title\n3. Change isRead to true\n4. Add a new property 'rating' with a number 1-5\n5. Display the entire object",
              "instructions": "Create an object representing a book:\n1. Create object with: title (string), author (string), pages (number), isRead (boolean)\n2. Display the title\n3. Change isRead to true\n4. Add a new property 'rating' with a number 1-5\n5. Display the entire object",
              "starterCode": "// Create your book object\n\n// Display title\n\n// Mark as read\n\n// Add rating\n\n// Display object\n",
              "solution": "let book = {\n  title: '1984',\n  author: 'George Orwell',\n  pages: 328,\n  isRead: false\n};\n\nconsole.log('Title:', book.title);\n\nbook.isRead = true;\n\nbook.rating = 5;\n\nconsole.log('Book:', book);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Creates book object correctly",
                  "expectedOutput": "Harry Potter",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "let book = {title: '...', author: '...', pages: 300, isRead: false};"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting commas between properties:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting commas between properties:\n   {name: 'Alice' age: 25}  // WRONG - missing comma\n   {name: 'Alice', age: 25}  // CORRECT"
                },
                {
                  "mistake": "Using = instead of ::",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using = instead of ::\n   {name = 'Alice'}  // WRONG\n   {name: 'Alice'}   // CORRECT"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.5",
          "title": "Working with Object Properties (Iterating and Manipulating)",
          "moduleId": "module-05",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're a store clerk inventorying products. You need to go through each product and check its details:\n\n'Product 1: Name = Laptop, Price = $1000'\n'Product 2: Name = Mouse, Price = $25'\n\nJust like we looped through arrays, we need to loop through objects. But objects don't have index numbers - they have property NAMES. JavaScript gives us special tools to work with object properties: get all keys, all values, or all key-value pairs."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "let student = {\n  name: 'Alice',\n  age: 20,\n  grade: 'A',\n  major: 'Computer Science'\n};\n\n// Get all property names (keys)\nlet keys = Object.keys(student);\nconsole.log(keys);  // ['name', 'age', 'grade', 'major']\n\n// Get all property values\nlet values = Object.values(student);\nconsole.log(values);  // ['Alice', 20, 'A', 'Computer Science']\n\n// Get all key-value pairs\nlet entries = Object.entries(student);\nconsole.log(entries);  // [['name', 'Alice'], ['age', 20], ...]\n\n// Loop through keys\nfor (let key of Object.keys(student)) {\n  console.log(key + ': ' + student[key]);\n}\n\n// Loop through key-value pairs (more elegant)\nfor (let [key, value] of Object.entries(student)) {\n  console.log(key + ': ' + value);\n}\n\n// for...in loop (older way)\nfor (let key in student) {\n  console.log(key + ': ' + student[key]);\n}\n\n// Practical: calculate total prices\nlet cart = {\n  laptop: 1000,\n  mouse: 25,\n  keyboard: 75\n};\n\nlet total = 0;\nfor (let price of Object.values(cart)) {\n  total += price;\n}\nconsole.log('Total: $' + total);  // $1100"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Three key Object methods:\n\n1. **Object.keys(obj)**\n   - Returns array of property names\n   - {a: 1, b: 2} → ['a', 'b']\n   - Use when you need property names\n\n2. **Object.values(obj)**\n   - Returns array of property values\n   - {a: 1, b: 2} → [1, 2]\n   - Use when you only need values\n\n3. **Object.entries(obj)**\n   - Returns array of [key, value] pairs\n   - {a: 1, b: 2} → [['a', 1], ['b', 2]]\n   - Use when you need both keys and values\n\nLoop patterns:\n\n// Pattern 1: Loop through keys\nfor (let key of Object.keys(obj)) {\n  console.log(key);          // Property name\n  console.log(obj[key]);     // Property value\n}\n\n// Pattern 2: Loop through values\nfor (let value of Object.values(obj)) {\n  console.log(value);  // Just the values\n}\n\n// Pattern 3: Loop through entries (destructuring)\nfor (let [key, value] of Object.entries(obj)) {\n  console.log(key, value);  // Both at once\n}\n\n// Pattern 4: for...in loop (older)\nfor (let key in obj) {\n  console.log(key, obj[key]);\n}\n\nDestructuring in loops:\n// This:\nfor (let entry of Object.entries(obj)) {\n  let key = entry[0];\n  let value = entry[1];\n}\n\n// Can be written as:\nfor (let [key, value] of Object.entries(obj)) {\n  // key and value are extracted automatically!\n}\n\nCounting properties:\nObject.keys(obj).length  // Number of properties"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Calling Object.keys() on non-object:\n   Object.keys([1,2,3])  // Works but returns ['0', '1', '2'] (indices as strings)\n   Object.keys('hello')  // Works but returns ['0', '1', '2', '3', '4']\n   \n2. Forgetting Object.keys() returns an array:\n   Object.keys(obj)  // Returns ARRAY of keys\n   // Must loop through: for (let key of Object.keys(obj))\n\n3. Confusing for...of and for...in:\n   for (let key of obj)  // ERROR - objects aren't iterable with for...of\n   for (let key in obj)  // CORRECT - for...in works on objects\n   for (let key of Object.keys(obj))  // ALSO CORRECT\n\n4. Not using destructuring with entries:\n   for (let entry of Object.entries(obj)) {\n     console.log(entry[0], entry[1]);  // Works but clunky\n   }\n   for (let [key, value] of Object.entries(obj)) {\n     console.log(key, value);  // Much cleaner!\n   }\n\n5. Expecting specific order:\n   Object properties don't have a guaranteed order\n   (Though modern JS usually maintains insertion order)"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.5-challenge",
              "title": "Practice Challenge",
              "description": "You have a product inventory object. Calculate:\n1. Total number of products (count of properties)\n2. Total value of all inventory (sum of all prices)\n3. Display each product with its price\n\nlet inventory = {\n  laptop: 1200,\n  mouse: 30,\n  keyboard: 80,\n  monitor: 350\n};",
              "instructions": "You have a product inventory object. Calculate:\n1. Total number of products (count of properties)\n2. Total value of all inventory (sum of all prices)\n3. Display each product with its price\n\nlet inventory = {\n  laptop: 1200,\n  mouse: 30,\n  keyboard: 80,\n  monitor: 350\n};",
              "starterCode": "let inventory = {\n  laptop: 1200,\n  mouse: 30,\n  keyboard: 80,\n  monitor: 350\n};\n\n// Count products\n\n// Calculate total value\n\n// Display each product\n",
              "solution": "let inventory = {\n  laptop: 1200,\n  mouse: 30,\n  keyboard: 80,\n  monitor: 350\n};\n\nlet productCount = Object.keys(inventory).length;\nconsole.log('Total products: ' + productCount);\n\nlet totalValue = 0;\nfor (let price of Object.values(inventory)) {\n  totalValue += price;\n}\nconsole.log('Total inventory value: $' + totalValue);\n\nconsole.log('Product list:');\nfor (let [product, price] of Object.entries(inventory)) {\n  console.log(product + ': $' + price);\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Counts products correctly",
                  "expectedOutput": "2",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Object.keys(inventory).length for count, loop through Object.values() to sum"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Calling Object.keys() on non-object:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Calling Object.keys() on non-object:\n   Object.keys([1,2,3])  // Works but returns ['0', '1', '2'] (indices as strings)\n   Object.keys('hello')  // Works but returns ['0', '1', '2', '3', '4']"
                },
                {
                  "mistake": "Forgetting Object.keys() returns an array:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting Object.keys() returns an array:\n   Object.keys(obj)  // Returns ARRAY of keys\n   // Must loop through: for (let key of Object.keys(obj))"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.6",
          "title": "Safe Property Access (Optional Chaining and Nullish Coalescing)",
          "moduleId": "module-05",
          "order": 6,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're looking for a friend's phone number in an address book. The book has sections for each person, and each person might have contact info. But what if:\n\n- The person doesn't exist in the book?\n- The person exists but has no contact section?\n- The contact section exists but has no phone number?\n\nIn the old days, you'd have to check each step: 'Does the person exist? If yes, do they have contacts? If yes, is there a phone number?' This is tedious and error-prone.\n\n**Optional Chaining (?.)** is like saying 'give me the phone number if it exists at any level, otherwise just give me undefined - don't crash!'\n\n**Nullish Coalescing (??)** is like saying 'use this value, BUT if it's null or undefined, use this backup instead.' It's smarter than || because it respects valid falsy values like 0 or empty string."
            },
            {
              "type": "EXAMPLE",
              "title": "Optional Chaining (?.) Examples",
              "content": "Optional chaining (?.) lets you safely access nested properties without checking each level for null or undefined. If any part of the chain is null or undefined, it returns undefined instead of throwing an error.",
              "code": "// The problem: accessing nested properties that might not exist\nlet user = {\n  name: 'Alice',\n  address: {\n    city: 'New York'\n  }\n};\n\n// Old way - tedious and error-prone\nlet city;\nif (user && user.address && user.address.city) {\n  city = user.address.city;\n}\nconsole.log(city);  // 'New York'\n\n// With Optional Chaining - clean and safe!\nlet city2 = user?.address?.city;\nconsole.log(city2);  // 'New York'\n\n// When property doesn't exist\nlet user2 = { name: 'Bob' };  // No address!\nlet city3 = user2?.address?.city;\nconsole.log(city3);  // undefined (no error!)\n\n// Without ?. this would crash:\n// let city4 = user2.address.city;  // ERROR: Cannot read 'city' of undefined\n\n// Works with methods too!\nlet calculator = {\n  add: (a, b) => a + b\n};\nconsole.log(calculator.add?.(2, 3));       // 5\nconsole.log(calculator.subtract?.(5, 2));  // undefined (method doesn't exist)\n\n// Works with arrays!\nlet users = [{ name: 'Alice' }, { name: 'Bob' }];\nconsole.log(users?.[0]?.name);  // 'Alice'\nconsole.log(users?.[5]?.name);  // undefined (index 5 doesn't exist)\n\nlet noUsers = null;\nconsole.log(noUsers?.[0]?.name);  // undefined (noUsers is null)",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "Nullish Coalescing (??) Examples",
              "content": "Nullish coalescing (??) provides a default value only when the left side is null or undefined. Unlike the || operator, it preserves valid falsy values like 0, empty string, or false.",
              "code": "// The problem with || for default values\nlet count = 0;\nlet displayCount = count || 'No count';  // 'No count' - WRONG!\n// We wanted 0, but || treats 0 as falsy\n\nlet username = '';\nlet displayName = username || 'Anonymous';  // 'Anonymous' - maybe WRONG!\n// What if empty string was intentional?\n\n// Nullish Coalescing only checks for null/undefined\nlet count2 = 0;\nlet displayCount2 = count2 ?? 'No count';  // 0 - CORRECT!\nconsole.log(displayCount2);  // 0\n\nlet username2 = '';\nlet displayName2 = username2 ?? 'Anonymous';  // '' - keeps empty string\nconsole.log(displayName2);  // ''\n\n// Only null and undefined trigger the default\nconsole.log(null ?? 'default');       // 'default'\nconsole.log(undefined ?? 'default');  // 'default'\nconsole.log(0 ?? 'default');          // 0\nconsole.log('' ?? 'default');         // ''\nconsole.log(false ?? 'default');      // false\n\n// Practical example: API response handling\nlet apiResponse = {\n  user: {\n    settings: {\n      theme: 'dark',\n      fontSize: 0,  // Valid setting!\n      notifications: null  // Not set\n    }\n  }\n};\n\nlet theme = apiResponse?.user?.settings?.theme ?? 'light';\nconsole.log(theme);  // 'dark'\n\nlet fontSize = apiResponse?.user?.settings?.fontSize ?? 16;\nconsole.log(fontSize);  // 0 (not 16! because 0 is a valid value)\n\nlet notifications = apiResponse?.user?.settings?.notifications ?? true;\nconsole.log(notifications);  // true (null triggers default)",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "**Optional Chaining (?.)**\n\nThree forms of optional chaining:\n\n1. **Property access**: obj?.property\n   - Returns undefined if obj is null/undefined\n   - Otherwise returns obj.property\n\n2. **Method calls**: obj.method?.(args)\n   - Returns undefined if method doesn't exist\n   - Otherwise calls the method\n\n3. **Array access**: arr?.[index]\n   - Returns undefined if arr is null/undefined\n   - Otherwise returns arr[index]\n\n**How it works:**\n```\nuser?.address?.city\n```\nis equivalent to:\n```\nuser != null ? (user.address != null ? user.address.city : undefined) : undefined\n```\n\n**Nullish Coalescing (??)**\n\nSyntax: `leftValue ?? rightValue`\n\n- Returns rightValue only if leftValue is null or undefined\n- Otherwise returns leftValue (even if it's 0, '', or false)\n\n**Comparison with ||:**\n\n| Expression | || result | ?? result |\n|------------|-----------|----------|\n| 0 \\|\\| 'default' | 'default' | - |\n| 0 ?? 'default' | - | 0 |\n| '' \\|\\| 'default' | 'default' | - |\n| '' ?? 'default' | - | '' |\n| null \\|\\| 'default' | 'default' | - |\n| null ?? 'default' | - | 'default' |\n| undefined \\|\\| 'default' | 'default' | - |\n| undefined ?? 'default' | - | 'default' |\n\n**Combining both:**\n```javascript\nconst value = obj?.deeply?.nested?.value ?? 'default';\n```\nThis safely navigates the object and provides a default if the value is null/undefined."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. **Using ?. when not needed:**\n   ```javascript\n   let name = user?.name;  // If you KNOW user exists, just use user.name\n   ```\n   Only use ?. when the value might be null/undefined.\n\n2. **Confusing ?? with ||:**\n   ```javascript\n   let port = config.port || 3000;  // WRONG if port could be 0\n   let port = config.port ?? 3000;  // CORRECT\n   ```\n\n3. **Optional chaining doesn't help with undefined properties:**\n   ```javascript\n   let user = { name: undefined };\n   console.log(user?.name);  // undefined (as expected)\n   // ?. checks if user exists, not if user.name has a value\n   ```\n\n4. **Cannot use ?. for assignment:**\n   ```javascript\n   user?.address = 'NYC';  // SYNTAX ERROR!\n   // Optional chaining is for reading, not writing\n   ```\n\n5. **Mixing ?? with || or && without parentheses:**\n   ```javascript\n   let a = null || undefined ?? 'default';  // SYNTAX ERROR!\n   let a = (null || undefined) ?? 'default';  // OK: 'default'\n   ```\n   JavaScript requires parentheses when mixing ?? with || or &&.\n\n6. **Overusing optional chaining (code smell):**\n   ```javascript\n   data?.users?.[0]?.profile?.settings?.theme?.color?.hex\n   // If you need this many ?., your data structure might need rethinking\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.6-challenge-1",
              "title": "Practice Challenge: Safe Data Access",
              "description": "You're building a user profile display. The API sometimes returns incomplete data. Use optional chaining and nullish coalescing to safely access properties and provide defaults.\n\n1. Get the user's city (default: 'Unknown')\n2. Get the user's email (default: 'No email provided')\n3. Get the user's age (default: 'Age not specified') - careful with 0!\n4. Get the first hobby (default: 'No hobbies listed')",
              "instructions": "Use optional chaining (?.) and nullish coalescing (??) to safely extract data with defaults.",
              "starterCode": "// This API data might have missing fields\nlet userData = {\n  name: 'Alice',\n  age: 0,  // Just born!\n  address: {\n    street: '123 Main St'\n    // Note: no city!\n  },\n  // Note: no email!\n  hobbies: ['reading', 'coding']\n};\n\n// Extract data safely with defaults\nlet city = // YOUR CODE HERE\nlet email = // YOUR CODE HERE  \nlet age = // YOUR CODE HERE\nlet firstHobby = // YOUR CODE HERE\n\nconsole.log('City:', city);\nconsole.log('Email:', email);\nconsole.log('Age:', age);\nconsole.log('First hobby:', firstHobby);",
              "solution": "let userData = {\n  name: 'Alice',\n  age: 0,\n  address: {\n    street: '123 Main St'\n  },\n  hobbies: ['reading', 'coding']\n};\n\nlet city = userData?.address?.city ?? 'Unknown';\nlet email = userData?.email ?? 'No email provided';\nlet age = userData?.age ?? 'Age not specified';\nlet firstHobby = userData?.hobbies?.[0] ?? 'No hobbies listed';\n\nconsole.log('City:', city);  // 'Unknown'\nconsole.log('Email:', email);  // 'No email provided'\nconsole.log('Age:', age);  // 0 (not 'Age not specified'!)\nconsole.log('First hobby:', firstHobby);  // 'reading'",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "City defaults to 'Unknown'",
                  "expectedOutput": "Unknown",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Age preserves 0 (doesn't use default)",
                  "expectedOutput": "0",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For city: userData?.address?.city ?? 'Unknown'"
                },
                {
                  "level": 2,
                  "text": "Remember: ?? only triggers on null/undefined, so age of 0 won't trigger the default!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using || instead of ?? for age",
                  "consequence": "Age of 0 would be replaced with the default string",
                  "correction": "Use ?? to preserve falsy values like 0: userData?.age ?? 'default'"
                },
                {
                  "mistake": "Not using ?. before array access",
                  "consequence": "Would crash if hobbies array is null/undefined",
                  "correction": "Use userData?.hobbies?.[0] to safely access array elements"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "5.6-challenge-2",
              "title": "Practice Challenge: Safe Method Calls",
              "description": "You have an object that may or may not have certain methods. Use optional chaining to safely call methods that might not exist.",
              "instructions": "Safely call methods using optional chaining for method calls.",
              "starterCode": "let calculator = {\n  add: (a, b) => a + b,\n  multiply: (a, b) => a * b\n  // Note: no subtract or divide methods!\n};\n\n// Safely call methods (return undefined if method doesn't exist)\nlet sum = // call add(5, 3)\nlet product = // call multiply(4, 2)\nlet difference = // call subtract(10, 4) - doesn't exist!\nlet quotient = // call divide(20, 5) - doesn't exist!\n\nconsole.log('Sum:', sum);\nconsole.log('Product:', product);\nconsole.log('Difference:', difference ?? 'Method not available');\nconsole.log('Quotient:', quotient ?? 'Method not available');",
              "solution": "let calculator = {\n  add: (a, b) => a + b,\n  multiply: (a, b) => a * b\n};\n\nlet sum = calculator.add?.(5, 3);\nlet product = calculator.multiply?.(4, 2);\nlet difference = calculator.subtract?.(10, 4);\nlet quotient = calculator.divide?.(20, 5);\n\nconsole.log('Sum:', sum);  // 8\nconsole.log('Product:', product);  // 8\nconsole.log('Difference:', difference ?? 'Method not available');  // 'Method not available'\nconsole.log('Quotient:', quotient ?? 'Method not available');  // 'Method not available'",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Existing methods work correctly",
                  "expectedOutput": "8",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Missing methods return undefined",
                  "expectedOutput": "Method not available",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use method?.() syntax to safely call methods"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Putting ?. before the parentheses wrong",
                  "consequence": "Syntax error",
                  "correction": "Use calculator.method?.(args) not calculator.method.?(args)"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.7",
          "title": "Modern Array Methods (ES2023-2025)",
          "moduleId": "module-05",
          "order": 7,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Remember how we learned about array methods like sort(), reverse(), and splice()? They all had one annoying problem: they MODIFY the original array. It's like editing a photo and accidentally saving over the original - you can't get it back!\n\nES2023-2025 introduced new 'non-mutating' versions of these methods. They're like making a copy before editing:\n\n- **toSorted()** - like sort(), but returns a NEW sorted array\n- **toReversed()** - like reverse(), but returns a NEW reversed array\n- **toSpliced()** - like splice(), but returns a NEW modified array\n- **with()** - like arr[i] = x, but returns a NEW array\n- **at()** - access elements with negative indices (like Python!)\n- **Object.groupBy()** - group array items by a key (super useful!)\n- **Map.groupBy()** - like Object.groupBy but with any key type\n\nThese methods are safer because they never change your original data. This is especially important in modern frameworks like React where you should never mutate state directly."
            },
            {
              "type": "EXAMPLE",
              "title": "The at() Method - Negative Indexing",
              "content": "The at() method lets you access array elements using negative indices. Negative indices count backward from the end, so at(-1) returns the last element - no more awkward array[array.length - 1] syntax!",
              "code": "// The old way to get the last element\nlet fruits = ['apple', 'banana', 'cherry', 'date'];\nlet last = fruits[fruits.length - 1];\nconsole.log(last);  // 'date'\n\n// With at() - so much cleaner!\nlet lastFruit = fruits.at(-1);\nconsole.log(lastFruit);  // 'date'\n\n// Negative indices count from the end\nconsole.log(fruits.at(0));   // 'apple' (first)\nconsole.log(fruits.at(1));   // 'banana' (second)\nconsole.log(fruits.at(-1));  // 'date' (last)\nconsole.log(fruits.at(-2));  // 'cherry' (second to last)\nconsole.log(fruits.at(-3));  // 'banana' (third to last)\n\n// Works with strings too!\nlet word = 'JavaScript';\nconsole.log(word.at(0));   // 'J'\nconsole.log(word.at(-1));  // 't'\nconsole.log(word.at(-2));  // 'p'\n\n// Practical: get the last item of a function result\nfunction getScores() {\n  return [85, 92, 78, 95, 88];\n}\nlet topScore = getScores().at(-1);\nconsole.log(topScore);  // 88\n\n// Compare: old way required intermediate variable or ugly syntax\nlet scores = getScores();\nlet oldWay = scores[scores.length - 1];  // More verbose",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "Non-Mutating Sort and Reverse",
              "content": "The toSorted() and toReversed() methods work like sort() and reverse(), but return NEW arrays instead of modifying the original. This is safer and essential for frameworks like React that require immutable state updates.",
              "code": "// THE PROBLEM: sort() and reverse() mutate the original array!\nlet numbers = [3, 1, 4, 1, 5, 9, 2, 6];\nlet sorted = numbers.sort((a, b) => a - b);\nconsole.log(sorted);   // [1, 1, 2, 3, 4, 5, 6, 9]\nconsole.log(numbers);  // [1, 1, 2, 3, 4, 5, 6, 9] - ORIGINAL CHANGED!\n\n// THE SOLUTION: toSorted() returns a NEW array\nlet numbers2 = [3, 1, 4, 1, 5, 9, 2, 6];\nlet sorted2 = numbers2.toSorted((a, b) => a - b);\nconsole.log(sorted2);   // [1, 1, 2, 3, 4, 5, 6, 9]\nconsole.log(numbers2);  // [3, 1, 4, 1, 5, 9, 2, 6] - ORIGINAL PRESERVED!\n\n// Same with reverse!\nlet letters = ['a', 'b', 'c', 'd'];\n\n// OLD: reverse() mutates\nlet reversed1 = letters.reverse();\nconsole.log(letters);  // ['d', 'c', 'b', 'a'] - original changed!\n\n// Reset and try toReversed()\nletters = ['a', 'b', 'c', 'd'];\nlet reversed2 = letters.toReversed();\nconsole.log(reversed2);  // ['d', 'c', 'b', 'a']\nconsole.log(letters);    // ['a', 'b', 'c', 'd'] - original preserved!\n\n// Practical: showing sorted data without affecting original\nlet products = [\n  { name: 'Laptop', price: 1000 },\n  { name: 'Mouse', price: 25 },\n  { name: 'Keyboard', price: 75 }\n];\n\n// Sort by price for display\nlet byPrice = products.toSorted((a, b) => a.price - b.price);\nconsole.log('Sorted by price:', byPrice.map(p => p.name));  // Mouse, Keyboard, Laptop\nconsole.log('Original order:', products.map(p => p.name));  // Laptop, Mouse, Keyboard",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "Non-Mutating Splice with toSpliced()",
              "content": "The toSpliced() method works like splice() for removing and adding elements, but returns a NEW array instead of modifying the original. Perfect for immutable updates when managing lists.",
              "code": "// splice() reminder: removes/adds elements AND mutates the array\nlet colors = ['red', 'green', 'blue', 'yellow'];\nlet removed = colors.splice(1, 2, 'purple');  // Remove 2 items at index 1, add 'purple'\nconsole.log(removed);  // ['green', 'blue'] (what was removed)\nconsole.log(colors);   // ['red', 'purple', 'yellow'] - MUTATED!\n\n// toSpliced() does the same but returns a NEW array\nlet colors2 = ['red', 'green', 'blue', 'yellow'];\nlet newColors = colors2.toSpliced(1, 2, 'purple');\nconsole.log(newColors);  // ['red', 'purple', 'yellow']\nconsole.log(colors2);    // ['red', 'green', 'blue', 'yellow'] - PRESERVED!\n\n// More examples:\nlet nums = [1, 2, 3, 4, 5];\n\n// Remove 2 items starting at index 1\nconsole.log(nums.toSpliced(1, 2));  // [1, 4, 5]\n\n// Remove 1 item at index 2, insert 'a', 'b'\nconsole.log(nums.toSpliced(2, 1, 'a', 'b'));  // [1, 2, 'a', 'b', 4, 5]\n\n// Insert without removing (delete count = 0)\nconsole.log(nums.toSpliced(2, 0, 'inserted'));  // [1, 2, 'inserted', 3, 4, 5]\n\n// Original is always unchanged\nconsole.log(nums);  // [1, 2, 3, 4, 5]\n\n// Practical: removing an item by index (common in React!)\nlet todoList = ['Buy milk', 'Clean room', 'Do homework', 'Exercise'];\nlet indexToRemove = 1;  // Remove 'Clean room'\n\n// Create new list without that item\nlet updatedList = todoList.toSpliced(indexToRemove, 1);\nconsole.log(updatedList);  // ['Buy milk', 'Do homework', 'Exercise']\nconsole.log(todoList);     // Original unchanged!",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "Object.groupBy() - Grouping Array Items",
              "content": "Object.groupBy() is a powerful new method that groups array items by a key you define. It returns an object where each key is a group name and each value is an array of items belonging to that group.",
              "code": "// Object.groupBy() groups array items by a key you define\n// This is SUPER useful for organizing data!\n\nlet products = [\n  { name: 'Apple', category: 'Fruit', price: 1.50 },\n  { name: 'Banana', category: 'Fruit', price: 0.75 },\n  { name: 'Carrot', category: 'Vegetable', price: 0.50 },\n  { name: 'Broccoli', category: 'Vegetable', price: 1.25 },\n  { name: 'Milk', category: 'Dairy', price: 3.00 }\n];\n\n// Group by category\nlet byCategory = Object.groupBy(products, product => product.category);\n\nconsole.log(byCategory);\n// {\n//   Fruit: [{name: 'Apple', ...}, {name: 'Banana', ...}],\n//   Vegetable: [{name: 'Carrot', ...}, {name: 'Broccoli', ...}],\n//   Dairy: [{name: 'Milk', ...}]\n// }\n\n// Access a specific group\nconsole.log(byCategory.Fruit);  // All fruit products\nconsole.log(byCategory.Vegetable.length);  // 2 vegetables\n\n// Group numbers by even/odd\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nlet byEvenOdd = Object.groupBy(numbers, n => n % 2 === 0 ? 'even' : 'odd');\nconsole.log(byEvenOdd);\n// { odd: [1, 3, 5, 7, 9], even: [2, 4, 6, 8, 10] }\n\n// Group students by grade\nlet students = [\n  { name: 'Alice', score: 95 },\n  { name: 'Bob', score: 82 },\n  { name: 'Charlie', score: 78 },\n  { name: 'Diana', score: 91 },\n  { name: 'Eve', score: 65 }\n];\n\nlet byGrade = Object.groupBy(students, student => {\n  if (student.score >= 90) return 'A';\n  if (student.score >= 80) return 'B';\n  if (student.score >= 70) return 'C';\n  return 'D';\n});\n\nconsole.log(byGrade);\n// {\n//   A: [Alice, Diana],\n//   B: [Bob],\n//   C: [Charlie],\n//   D: [Eve]\n// }\nconsole.log('A students:', byGrade.A.map(s => s.name));  // ['Alice', 'Diana']",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "Array.with() - Immutable Element Replacement",
              "content": "Array.with() replaces an element at a specific index and returns a NEW array, leaving the original unchanged. It's the immutable alternative to arr[index] = value assignment.",
              "code": "// Array.with() replaces an element at an index and returns a NEW array\n// Like bracket assignment, but without mutating the original!\n\nlet colors = ['red', 'green', 'blue', 'yellow'];\n\n// OLD WAY: Mutates the original array!\ncolors[1] = 'purple';\nconsole.log(colors);  // ['red', 'purple', 'blue', 'yellow'] - Changed!\n\n// Reset\ncolors = ['red', 'green', 'blue', 'yellow'];\n\n// NEW WAY with .with() - Original preserved!\nlet newColors = colors.with(1, 'purple');\nconsole.log(newColors);  // ['red', 'purple', 'blue', 'yellow']\nconsole.log(colors);     // ['red', 'green', 'blue', 'yellow'] - Unchanged!\n\n// Works with negative indices too (like at())\nlet fruits = ['apple', 'banana', 'cherry'];\nlet updated = fruits.with(-1, 'cranberry');  // Replace last element\nconsole.log(updated);  // ['apple', 'banana', 'cranberry']\nconsole.log(fruits);   // ['apple', 'banana', 'cherry'] - Original safe!\n\n// Chain with other immutable methods\nlet numbers = [5, 2, 8, 1, 9];\nlet result = numbers\n  .with(0, 100)           // Replace first with 100\n  .toSorted((a, b) => a - b)  // Sort ascending\n  .toReversed();          // Reverse\nconsole.log(result);   // [100, 9, 8, 2, 1]\nconsole.log(numbers);  // [5, 2, 8, 1, 9] - Original untouched!\n\n// Practical: Update item in React state\n// React requires immutable updates - .with() is perfect!\nlet todos = [\n  { id: 1, text: 'Buy milk', done: false },\n  { id: 2, text: 'Clean room', done: false },\n  { id: 3, text: 'Exercise', done: false }\n];\n\n// Mark second todo as complete (immutably)\nlet indexToUpdate = 1;\nlet updatedTodos = todos.with(indexToUpdate, {\n  ...todos[indexToUpdate],\n  done: true\n});\nconsole.log(updatedTodos[1].done);  // true\nconsole.log(todos[1].done);         // false - Original unchanged!",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "Map.groupBy() - Grouping with Complex Keys",
              "content": "Map.groupBy() works like Object.groupBy() but returns a Map instead of an object. Use it when you need non-string keys (booleans, objects, numbers) since Map preserves key types while objects convert everything to strings.",
              "code": "// Map.groupBy() is like Object.groupBy() but returns a Map\n// Why use Map? Keys can be ANY type (not just strings)!\n\nlet products = [\n  { name: 'Apple', category: 'Fruit', inStock: true },\n  { name: 'Banana', category: 'Fruit', inStock: false },\n  { name: 'Carrot', category: 'Vegetable', inStock: true },\n  { name: 'Milk', category: 'Dairy', inStock: true }\n];\n\n// Object.groupBy - Keys become strings\nlet objGrouped = Object.groupBy(products, p => p.inStock);\nconsole.log(objGrouped['true']);   // Works (string key)\nconsole.log(objGrouped[true]);     // undefined! Boolean converted to string\n\n// Map.groupBy - Keys keep their original type\nlet mapGrouped = Map.groupBy(products, p => p.inStock);\nconsole.log(mapGrouped.get(true));   // Products that are in stock\nconsole.log(mapGrouped.get(false));  // Products that are out of stock\n\n// Group by object reference (impossible with Object.groupBy!)\nlet categoryA = { name: 'Fruits' };\nlet categoryB = { name: 'Vegetables' };\n\nlet items = [\n  { product: 'Apple', cat: categoryA },\n  { product: 'Banana', cat: categoryA },\n  { product: 'Carrot', cat: categoryB }\n];\n\nlet byCategory = Map.groupBy(items, item => item.cat);\nconsole.log(byCategory.get(categoryA));  // Apple and Banana\nconsole.log(byCategory.get(categoryB));  // Carrot\n\n// Practical: Group DOM elements by their tag\n// (In browser) const elements = document.querySelectorAll('*');\n// const byTag = Map.groupBy([...elements], el => el.tagName);\n// console.log(byTag.get('DIV'));  // All div elements\n\n// Iterate over Map groups\nfor (let [key, items] of mapGrouped) {\n  console.log(`In stock: ${key}`, items.map(p => p.name));\n}\n// In stock: true ['Apple', 'Carrot', 'Milk']\n// In stock: false ['Banana']\n\n// Convert Map to Object if needed\nlet asObject = Object.fromEntries(mapGrouped);\nconsole.log(asObject);  // { true: [...], false: [...] }",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "**at(index)**\n- Access elements with positive or negative indices\n- Negative indices count from the end (-1 = last, -2 = second to last)\n- Returns undefined if index is out of bounds\n```javascript\narray.at(0)   // First element\narray.at(-1)  // Last element\narray.at(-2)  // Second to last\n```\n\n**toSorted(compareFn)**\n- Returns a NEW sorted array\n- Original array is unchanged\n- Same comparison function as sort()\n```javascript\nconst sorted = array.toSorted((a, b) => a - b);  // Ascending numbers\nconst sorted = array.toSorted((a, b) => b - a);  // Descending numbers\nconst sorted = array.toSorted();  // Default string sort\n```\n\n**toReversed()**\n- Returns a NEW reversed array\n- Original array is unchanged\n- No arguments needed\n```javascript\nconst reversed = array.toReversed();\n```\n\n**toSpliced(start, deleteCount, ...items)**\n- Returns a NEW array with elements removed/added\n- Original array is unchanged\n- Same parameters as splice()\n```javascript\narray.toSpliced(1, 2)        // Remove 2 elements at index 1\narray.toSpliced(1, 0, 'a')   // Insert 'a' at index 1\narray.toSpliced(1, 1, 'a')   // Replace element at index 1 with 'a'\n```\n\n**with(index, value)**\n- Returns a NEW array with element at index replaced\n- Supports negative indices (like at())\n- Original array is unchanged\n```javascript\narray.with(0, 'new')   // Replace first element\narray.with(-1, 'new')  // Replace last element\narray.with(2, 'new')   // Replace element at index 2\n```\n\n**Object.groupBy(array, keyFn)**\n- Groups array items into an object\n- keyFn returns the group key for each item\n- Returns an object where keys are group names, values are arrays\n```javascript\nObject.groupBy(items, item => item.category);\nObject.groupBy(numbers, n => n % 2 === 0 ? 'even' : 'odd');\n```\n\n**Map.groupBy(array, keyFn)**\n- Like Object.groupBy but returns a Map\n- Keys can be ANY type (not just strings)\n- Better for non-string keys like booleans, objects, or numbers\n```javascript\nMap.groupBy(items, item => item.inStock);  // Boolean keys work!\nMap.groupBy(items, item => item.category); // Object keys work!\n```\n\n**Why use non-mutating methods?**\n1. Safer - original data is preserved\n2. Predictable - easier to debug\n3. Functional programming style\n4. Required for React/Vue state management\n5. Enables method chaining without side effects"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. **Confusing at() with negative indexing on brackets:**\n   ```javascript\n   array[-1]    // undefined - doesn't work!\n   array.at(-1) // Last element - works!\n   ```\n\n2. **Forgetting toSorted/toReversed/with return new arrays:**\n   ```javascript\n   let nums = [3, 1, 2];\n   nums.toSorted();  // Returns [1, 2, 3] but you didn't save it!\n   nums.with(0, 99); // Returns [99, 1, 2] but you didn't save it!\n   console.log(nums);  // Still [3, 1, 2]\n   \n   // Correct:\n   let sorted = nums.toSorted();\n   let updated = nums.with(0, 99);\n   ```\n\n3. **Using toSorted() without comparison for numbers:**\n   ```javascript\n   [10, 2, 1].toSorted()  // [1, 10, 2] - sorted as strings!\n   [10, 2, 1].toSorted((a, b) => a - b)  // [1, 2, 10] - correct!\n   ```\n\n4. **Object.groupBy returns null prototype object:**\n   ```javascript\n   let grouped = Object.groupBy(items, fn);\n   // grouped doesn't have standard Object methods like hasOwnProperty\n   // Use Object.keys(grouped) or 'key' in grouped instead\n   ```\n\n5. **Using Object.groupBy when you need non-string keys:**\n   ```javascript\n   // Object.groupBy converts keys to strings\n   Object.groupBy(items, x => x.active);  // Keys: 'true', 'false' (strings)\n   \n   // Map.groupBy preserves key types\n   Map.groupBy(items, x => x.active);     // Keys: true, false (booleans)\n   ```\n\n6. **Browser compatibility:**\n   - at(): Supported in all modern browsers (2022+)\n   - toSorted/toReversed/toSpliced/with: ES2023 (mid-2023+)\n   - Object.groupBy/Map.groupBy: ES2024 (late 2023+)\n   - Check compatibility if supporting older browsers!\n\n7. **Mixing up splice and toSpliced return values:**\n   ```javascript\n   // splice returns REMOVED elements\n   // toSpliced returns the NEW array\n   let arr = [1, 2, 3];\n   arr.splice(1, 1);      // Returns [2] (removed)\n   arr.toSpliced(1, 1);   // Returns [1, 3] (new array)\n   ```\n\n8. **with() throws RangeError for invalid index:**\n   ```javascript\n   let arr = [1, 2, 3];\n   arr.with(10, 'x');  // RangeError! Index out of bounds\n   arr.with(-10, 'x'); // RangeError! Index out of bounds\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.7-challenge-1",
              "title": "Practice Challenge: Safe Array Operations",
              "description": "You're building a leaderboard. Use modern array methods to sort and display scores WITHOUT modifying the original data.\n\n1. Display the top 3 scores (highest first) using toSorted()\n2. Get the last place score using at()\n3. Remove the player at index 2 using toSpliced() and show the new list",
              "instructions": "Use toSorted(), at(), and toSpliced() to work with the data safely.",
              "starterCode": "let players = [\n  { name: 'Alice', score: 850 },\n  { name: 'Bob', score: 920 },\n  { name: 'Charlie', score: 780 },\n  { name: 'Diana', score: 1050 },\n  { name: 'Eve', score: 890 }\n];\n\n// 1. Get top 3 players (sorted by score, highest first)\nlet top3 = // YOUR CODE HERE\nconsole.log('Top 3:', top3.map(p => p.name));\n\n// 2. Get the last place player using at()\nlet lastPlace = // YOUR CODE HERE\nconsole.log('Last place:', lastPlace.name);\n\n// 3. Remove player at index 2 (Charlie) using toSpliced()\nlet withoutCharlie = // YOUR CODE HERE\nconsole.log('Without Charlie:', withoutCharlie.map(p => p.name));\n\n// Verify original is unchanged\nconsole.log('Original:', players.map(p => p.name));",
              "solution": "let players = [\n  { name: 'Alice', score: 850 },\n  { name: 'Bob', score: 920 },\n  { name: 'Charlie', score: 780 },\n  { name: 'Diana', score: 1050 },\n  { name: 'Eve', score: 890 }\n];\n\n// 1. Get top 3 players (sorted by score, highest first)\nlet top3 = players.toSorted((a, b) => b.score - a.score).slice(0, 3);\nconsole.log('Top 3:', top3.map(p => p.name));  // Diana, Bob, Eve\n\n// 2. Get the last place player using at()\nlet sorted = players.toSorted((a, b) => b.score - a.score);\nlet lastPlace = sorted.at(-1);\nconsole.log('Last place:', lastPlace.name);  // Charlie\n\n// 3. Remove player at index 2 (Charlie) using toSpliced()\nlet withoutCharlie = players.toSpliced(2, 1);\nconsole.log('Without Charlie:', withoutCharlie.map(p => p.name));\n\n// Verify original is unchanged\nconsole.log('Original:', players.map(p => p.name));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Top 3 are correctly sorted",
                  "expectedOutput": "Diana",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Original array is unchanged",
                  "expectedOutput": "Alice",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For descending sort: toSorted((a, b) => b.score - a.score)"
                },
                {
                  "level": 2,
                  "text": "Chain .slice(0, 3) after toSorted() to get top 3"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using sort() instead of toSorted()",
                  "consequence": "Original array gets mutated",
                  "correction": "Always use toSorted() when you need to preserve the original"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "5.7-challenge-2",
              "title": "Practice Challenge: Grouping Data",
              "description": "You have a list of orders. Use Object.groupBy() to organize them by status, then calculate the total value for each status group.",
              "instructions": "Group orders by status and calculate totals for each group.",
              "starterCode": "let orders = [\n  { id: 1, product: 'Laptop', price: 1000, status: 'completed' },\n  { id: 2, product: 'Mouse', price: 25, status: 'pending' },\n  { id: 3, product: 'Keyboard', price: 75, status: 'completed' },\n  { id: 4, product: 'Monitor', price: 300, status: 'cancelled' },\n  { id: 5, product: 'Headphones', price: 150, status: 'pending' },\n  { id: 6, product: 'Webcam', price: 80, status: 'completed' }\n];\n\n// 1. Group orders by status\nlet byStatus = // YOUR CODE HERE\n\nconsole.log('Completed orders:', byStatus.completed?.length ?? 0);\nconsole.log('Pending orders:', byStatus.pending?.length ?? 0);\nconsole.log('Cancelled orders:', byStatus.cancelled?.length ?? 0);\n\n// 2. Calculate total value of completed orders\nlet completedTotal = // YOUR CODE HERE\nconsole.log('Completed orders total: $' + completedTotal);",
              "solution": "let orders = [\n  { id: 1, product: 'Laptop', price: 1000, status: 'completed' },\n  { id: 2, product: 'Mouse', price: 25, status: 'pending' },\n  { id: 3, product: 'Keyboard', price: 75, status: 'completed' },\n  { id: 4, product: 'Monitor', price: 300, status: 'cancelled' },\n  { id: 5, product: 'Headphones', price: 150, status: 'pending' },\n  { id: 6, product: 'Webcam', price: 80, status: 'completed' }\n];\n\n// 1. Group orders by status\nlet byStatus = Object.groupBy(orders, order => order.status);\n\nconsole.log('Completed orders:', byStatus.completed?.length ?? 0);  // 3\nconsole.log('Pending orders:', byStatus.pending?.length ?? 0);  // 2\nconsole.log('Cancelled orders:', byStatus.cancelled?.length ?? 0);  // 1\n\n// 2. Calculate total value of completed orders\nlet completedTotal = byStatus.completed?.reduce((sum, order) => sum + order.price, 0) ?? 0;\nconsole.log('Completed orders total: $' + completedTotal);  // $1155",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Groups orders correctly",
                  "expectedOutput": "3",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Calculates total correctly",
                  "expectedOutput": "1155",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Object.groupBy(orders, order => order.status)"
                },
                {
                  "level": 2,
                  "text": "Use reduce() on byStatus.completed to sum prices"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not handling potentially undefined groups",
                  "consequence": "Error if a status doesn't exist",
                  "correction": "Use optional chaining: byStatus.completed?.length ?? 0"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.8",
          "title": "Modern Set Methods (ES2025)",
          "moduleId": "module-05",
          "order": 8,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Remember Sets from math class? A Set is a collection where every item is unique - no duplicates allowed!\n\nThink of it like a VIP guest list where each person can only be listed once. If you try to add 'Alice' twice, she's still only on the list once.\n\nES2025 introduces powerful new Set methods that let you combine, compare, and manipulate Sets - just like Venn diagrams!\n\n**New Set Methods:**\n- **union()** - Combine two sets (everyone in EITHER set)\n- **intersection()** - Find common items (everyone in BOTH sets)\n- **difference()** - Find what's unique to one set (in A but NOT in B)\n- **symmetricDifference()** - Find what's unique to either (in A OR B, but not both)\n- **isSubsetOf()** - Check if one set contains all items of another\n- **isSupersetOf()** - Check if set contains all items of another set\n- **isDisjointFrom()** - Check if sets have no common items"
            },
            {
              "type": "EXAMPLE",
              "title": "Creating and Using Sets",
              "content": "A Set is a collection of unique values - duplicates are automatically removed. Create Sets from arrays, add/remove items, and convert back to arrays when needed.",
              "code": "// Creating Sets\nlet fruits = new Set(['apple', 'banana', 'cherry']);\nlet moreFruits = new Set(['cherry', 'date', 'elderberry']);\n\n// Sets automatically remove duplicates\nlet numbers = new Set([1, 2, 2, 3, 3, 3]);\nconsole.log(numbers);  // Set { 1, 2, 3 } - duplicates removed!\n\n// Basic Set operations\nfruits.add('date');        // Add item\nfruits.delete('banana');   // Remove item\nfruits.has('apple');       // true - check if exists\nfruits.size;               // 3 - number of items\n\n// Convert to array\nlet fruitArray = [...fruits];  // ['apple', 'cherry', 'date']\n\n// Loop through a Set\nfor (let fruit of fruits) {\n  console.log(fruit);\n}\n\n// Remove duplicates from array (common pattern)\nlet dupes = [1, 2, 2, 3, 3, 3, 4];\nlet unique = [...new Set(dupes)];\nconsole.log(unique);  // [1, 2, 3, 4]",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "union() - Combining Sets",
              "content": "The union() method combines two Sets into one, returning all unique items from both. It's like creating a guest list for people invited to either party.",
              "code": "// union() returns all unique items from BOTH sets\n// Like 'everyone invited to EITHER party'\n\nlet frontend = new Set(['Alice', 'Bob', 'Charlie']);\nlet backend = new Set(['Charlie', 'Diana', 'Eve']);\n\nlet allDevs = frontend.union(backend);\nconsole.log(allDevs);\n// Set { 'Alice', 'Bob', 'Charlie', 'Diana', 'Eve' }\n// Notice: Charlie appears only once (no duplicates)\n\n// Practical: Combine permission sets\nlet adminPerms = new Set(['read', 'write', 'delete', 'admin']);\nlet userPerms = new Set(['read', 'write']);\n\nlet combinedPerms = adminPerms.union(userPerms);\nconsole.log(combinedPerms);\n// Set { 'read', 'write', 'delete', 'admin' }\n\n// Works with any iterable\nlet setA = new Set([1, 2, 3]);\nlet setB = new Set([3, 4, 5]);\nconsole.log(setA.union(setB));  // Set { 1, 2, 3, 4, 5 }\n\n// OLD WAY (before ES2025):\nlet oldUnion = new Set([...setA, ...setB]);\nconsole.log(oldUnion);  // Same result, but more verbose",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "intersection() - Finding Common Items",
              "content": "The intersection() method returns only the items that exist in BOTH Sets. It's like finding people who were invited to both parties - the overlap in a Venn diagram.",
              "code": "// intersection() returns items that exist in BOTH sets\n// Like 'people invited to BOTH parties'\n\nlet frontend = new Set(['Alice', 'Bob', 'Charlie']);\nlet backend = new Set(['Charlie', 'Diana', 'Eve']);\n\nlet fullStack = frontend.intersection(backend);\nconsole.log(fullStack);  // Set { 'Charlie' }\n// Only Charlie is in both teams!\n\n// Practical: Find common interests\nlet aliceHobbies = new Set(['reading', 'gaming', 'hiking', 'cooking']);\nlet bobHobbies = new Set(['gaming', 'music', 'hiking', 'sports']);\n\nlet commonHobbies = aliceHobbies.intersection(bobHobbies);\nconsole.log(commonHobbies);  // Set { 'gaming', 'hiking' }\n\n// Find users with both permissions\nlet canRead = new Set(['user1', 'user2', 'user3', 'admin']);\nlet canWrite = new Set(['user2', 'admin', 'editor']);\n\nlet canReadAndWrite = canRead.intersection(canWrite);\nconsole.log(canReadAndWrite);  // Set { 'user2', 'admin' }\n\n// OLD WAY (before ES2025):\nlet oldIntersection = new Set(\n  [...aliceHobbies].filter(x => bobHobbies.has(x))\n);\n// New way is much cleaner!",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "difference() - Finding Unique Items",
              "content": "The difference() method returns items that are in the first Set but NOT in the second. The order matters - A.difference(B) gives different results than B.difference(A).",
              "code": "// difference() returns items in the first set but NOT in the second\n// Like 'people only invited to MY party, not yours'\n\nlet myFriends = new Set(['Alice', 'Bob', 'Charlie', 'Diana']);\nlet yourFriends = new Set(['Charlie', 'Diana', 'Eve', 'Frank']);\n\nlet onlyMyFriends = myFriends.difference(yourFriends);\nconsole.log(onlyMyFriends);  // Set { 'Alice', 'Bob' }\n\nlet onlyYourFriends = yourFriends.difference(myFriends);\nconsole.log(onlyYourFriends);  // Set { 'Eve', 'Frank' }\n// Order matters! A.difference(B) !== B.difference(A)\n\n// Practical: Find missing items\nlet required = new Set(['name', 'email', 'password', 'age']);\nlet provided = new Set(['name', 'email']);\n\nlet missing = required.difference(provided);\nconsole.log(missing);  // Set { 'password', 'age' }\nconsole.log('Missing fields:', [...missing].join(', '));\n// 'Missing fields: password, age'\n\n// Find items to remove from cart\nlet cartBefore = new Set(['apple', 'banana', 'cherry', 'date']);\nlet cartAfter = new Set(['apple', 'cherry']);\n\nlet removed = cartBefore.difference(cartAfter);\nconsole.log('Removed:', removed);  // Set { 'banana', 'date' }",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "symmetricDifference() - Items Unique to Either Set",
              "content": "The symmetricDifference() method returns items that are in EITHER Set, but not in BOTH. It's the opposite of intersection - everything except the overlap.",
              "code": "// symmetricDifference() returns items in EITHER set, but not BOTH\n// Like 'people invited to only one party, not both'\n\nlet teamA = new Set(['Alice', 'Bob', 'Charlie']);\nlet teamB = new Set(['Charlie', 'Diana', 'Eve']);\n\nlet exclusiveMembers = teamA.symmetricDifference(teamB);\nconsole.log(exclusiveMembers);\n// Set { 'Alice', 'Bob', 'Diana', 'Eve' }\n// Charlie is in BOTH, so excluded!\n\n// This is the same as union minus intersection\n// (A union B) - (A intersection B) = symmetricDifference\n\n// Practical: Find changes between two versions\nlet version1Features = new Set(['login', 'dashboard', 'profile']);\nlet version2Features = new Set(['login', 'dashboard', 'settings', 'notifications']);\n\nlet changes = version1Features.symmetricDifference(version2Features);\nconsole.log('Changed features:', changes);\n// Set { 'profile', 'settings', 'notifications' }\n// 'profile' was removed, 'settings' and 'notifications' were added\n\n// Find students who didn't attend both days\nlet day1Attendance = new Set(['Alice', 'Bob', 'Charlie']);\nlet day2Attendance = new Set(['Bob', 'Charlie', 'Diana']);\n\nlet inconsistent = day1Attendance.symmetricDifference(day2Attendance);\nconsole.log('Missed a day:', inconsistent);  // Alice and Diana",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "Subset, Superset, and Disjoint Checks",
              "content": "These methods let you compare Sets: isSubsetOf() checks if all items exist in another Set, isSupersetOf() checks if a Set contains all items of another, and isDisjointFrom() checks if Sets have no common items.",
              "code": "// isSubsetOf() - Check if ALL items exist in another set\nlet basic = new Set(['read']);\nlet standard = new Set(['read', 'write']);\nlet premium = new Set(['read', 'write', 'delete', 'admin']);\n\nconsole.log(basic.isSubsetOf(standard));    // true - 'read' is in standard\nconsole.log(standard.isSubsetOf(premium));  // true - 'read', 'write' in premium\nconsole.log(premium.isSubsetOf(basic));     // false - premium has more items\n\n// isSupersetOf() - Check if set CONTAINS all items of another\nconsole.log(premium.isSupersetOf(standard));  // true\nconsole.log(premium.isSupersetOf(basic));     // true\nconsole.log(basic.isSupersetOf(premium));     // false\n\n// isDisjointFrom() - Check if sets have NO common items\nlet cats = new Set(['whiskers', 'mittens', 'shadow']);\nlet dogs = new Set(['buddy', 'max', 'bella']);\nlet mixed = new Set(['whiskers', 'buddy']);\n\nconsole.log(cats.isDisjointFrom(dogs));   // true - no overlap\nconsole.log(cats.isDisjointFrom(mixed));  // false - 'whiskers' in both\n\n// Practical: Permission validation\nlet requiredPerms = new Set(['read', 'write']);\nlet userPerms = new Set(['read', 'write', 'comment']);\n\nif (requiredPerms.isSubsetOf(userPerms)) {\n  console.log('Access granted!');\n} else {\n  let missing = requiredPerms.difference(userPerms);\n  console.log('Missing permissions:', [...missing]);\n}",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "**Set Basics:**\n```javascript\nnew Set()              // Empty set\nnew Set([1, 2, 3])     // Set from array\nset.add(value)         // Add item (returns set)\nset.delete(value)      // Remove item (returns boolean)\nset.has(value)         // Check existence (returns boolean)\nset.size               // Number of items\nset.clear()            // Remove all items\n[...set]               // Convert to array\n```\n\n**New ES2025 Methods:**\n\n**set.union(otherSet)**\n- Returns new Set with all items from both\n- No duplicates\n- Original sets unchanged\n\n**set.intersection(otherSet)**\n- Returns new Set with items in BOTH sets\n- Only common elements\n\n**set.difference(otherSet)**\n- Returns items in set but NOT in otherSet\n- Order matters! A.difference(B) !== B.difference(A)\n\n**set.symmetricDifference(otherSet)**\n- Returns items in EITHER set but not BOTH\n- Same as (A union B) - (A intersection B)\n\n**set.isSubsetOf(otherSet)**\n- Returns true if ALL items are in otherSet\n- Empty set is subset of everything\n\n**set.isSupersetOf(otherSet)**\n- Returns true if set CONTAINS all items of otherSet\n- Opposite of isSubsetOf\n\n**set.isDisjointFrom(otherSet)**\n- Returns true if sets have NO common items\n- intersection would be empty"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. **Forgetting Sets use reference equality for objects:**\n   ```javascript\n   let set = new Set();\n   set.add({ name: 'Alice' });\n   set.add({ name: 'Alice' });  // Added! Different object reference\n   console.log(set.size);  // 2 - both objects added!\n   ```\n\n2. **difference() order matters:**\n   ```javascript\n   let a = new Set([1, 2, 3]);\n   let b = new Set([2, 3, 4]);\n   a.difference(b);  // Set { 1 } - what's in A but not B\n   b.difference(a);  // Set { 4 } - what's in B but not A\n   // These are different!\n   ```\n\n3. **Runtime requirements (ES2025):**\n   - **Node.js 22+** required for Set methods\n   - **Chrome 122+**, **Firefox 127+**, **Safari 17+** for browser support\n   - Older environments will throw: `TypeError: set.union is not a function`\n   - Consider polyfills (core-js) or transpilation for older environments\n   - Code Tutor uses your local Node.js - update Node if methods don't work\n\n4. **Sets don't have array methods:**\n   ```javascript\n   let set = new Set([1, 2, 3]);\n   set.map(x => x * 2);  // ERROR! Sets don't have map()\n   [...set].map(x => x * 2);  // [2, 4, 6] - convert first!\n   ```\n\n5. **Modifying set while iterating:**\n   ```javascript\n   let set = new Set([1, 2, 3]);\n   for (let item of set) {\n     set.delete(item);  // Works but can be confusing\n   }\n   // Better: collect items to delete, then delete after loop\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.8-challenge",
              "title": "Practice Challenge: Set Operations",
              "description": "You're building a team management system. Use Set methods to:\n\n1. Find developers who work on BOTH frontend AND backend (intersection)\n2. Find developers who ONLY work on frontend (difference)\n3. Combine all developers into one team (union)\n4. Check if the senior team is a subset of all developers",
              "instructions": "Use the new Set methods: union(), intersection(), difference(), and isSubsetOf()",
              "starterCode": "let frontendTeam = new Set(['Alice', 'Bob', 'Charlie', 'Diana']);\nlet backendTeam = new Set(['Charlie', 'Diana', 'Eve', 'Frank']);\nlet seniorDevs = new Set(['Alice', 'Eve']);\n\n// 1. Find full-stack developers (in BOTH teams)\nlet fullStack = // YOUR CODE HERE\nconsole.log('Full-stack:', [...fullStack]);\n\n// 2. Find frontend-only developers (in frontend but NOT backend)\nlet frontendOnly = // YOUR CODE HERE\nconsole.log('Frontend only:', [...frontendOnly]);\n\n// 3. Combine all developers\nlet allDevs = // YOUR CODE HERE\nconsole.log('All developers:', [...allDevs]);\n\n// 4. Check if all seniors are in the combined team\nlet allSeniorsIncluded = // YOUR CODE HERE\nconsole.log('All seniors included:', allSeniorsIncluded);",
              "solution": "let frontendTeam = new Set(['Alice', 'Bob', 'Charlie', 'Diana']);\nlet backendTeam = new Set(['Charlie', 'Diana', 'Eve', 'Frank']);\nlet seniorDevs = new Set(['Alice', 'Eve']);\n\n// 1. Find full-stack developers (in BOTH teams)\nlet fullStack = frontendTeam.intersection(backendTeam);\nconsole.log('Full-stack:', [...fullStack]);  // ['Charlie', 'Diana']\n\n// 2. Find frontend-only developers (in frontend but NOT backend)\nlet frontendOnly = frontendTeam.difference(backendTeam);\nconsole.log('Frontend only:', [...frontendOnly]);  // ['Alice', 'Bob']\n\n// 3. Combine all developers\nlet allDevs = frontendTeam.union(backendTeam);\nconsole.log('All developers:', [...allDevs]);\n// ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve', 'Frank']\n\n// 4. Check if all seniors are in the combined team\nlet allSeniorsIncluded = seniorDevs.isSubsetOf(allDevs);\nconsole.log('All seniors included:', allSeniorsIncluded);  // true",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Full-stack developers found correctly",
                  "expectedOutput": "Charlie",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Seniors are subset of all devs",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "intersection() finds items in BOTH sets"
                },
                {
                  "level": 2,
                  "text": "difference(other) finds items in the set but NOT in other"
                },
                {
                  "level": 3,
                  "text": "isSubsetOf() returns true if all items exist in the other set"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using filter instead of Set methods",
                  "consequence": "More verbose code",
                  "correction": "Use intersection(), difference(), union() for cleaner code"
                },
                {
                  "mistake": "Confusing difference order",
                  "consequence": "Wrong results",
                  "correction": "A.difference(B) gives items in A but not B"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-06",
      "title": "Module 6: Creating Reusable Tools (The 'Recipes')",
      "description": "Write code once and reuse it many times with functions",
      "difficulty": "intermediate",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "6.1",
          "title": "What Is a Function? (The Recipe Analogy)",
          "moduleId": "module-06",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "A recipe is a list of instructions for making a specific dish. Once you write the recipe down, you can use it over and over without rewriting the steps each time.\n\nA function in programming is exactly like a recipe:\n- It has a NAME (e.g., 'Make Pancakes')\n- It has INGREDIENTS (inputs, called 'parameters')\n- It has INSTRUCTIONS (the code inside)\n- It produces a RESULT (output, called a 'return value')\n\nJust like you can call out 'Make Pancakes!' and the recipe executes, in code you can 'call' a function and it executes its instructions. Functions let you avoid repeating the same code - write once, use many times!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Defining a function\nfunction sayHello() {\n  console.log('Hello, World!');\n}\n\n// Calling (using) the function\nsayHello();  // Hello, World!\nsayHello();  // Hello, World!\n// Can call as many times as you want!\n\n// Function with a parameter (ingredient)\nfunction greet(name) {\n  console.log('Hello, ' + name + '!');\n}\n\ngreet('Alice');   // Hello, Alice!\ngreet('Bob');     // Hello, Bob!\ngreet('Charlie'); // Hello, Charlie!\n\n// Function that returns a value\nfunction add(a, b) {\n  return a + b;\n}\n\nlet sum = add(5, 3);\nconsole.log(sum);  // 8\n\nlet result = add(10, 20);\nconsole.log(result);  // 30"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Function anatomy:\n\nfunction functionName(parameter1, parameter2) {\n│        │            │                      │\n│        │            └──────────────────────┴─ Parameters (inputs)\n│        └──────────────────────────────────── Name (you choose)\n└───────────────────────────────────────────── 'function' keyword\n  // Code to run\n  return result;  // Optional: send back a value\n}\n\nKey parts:\n\n1. **function keyword** - Tells JavaScript you're creating a function\n\n2. **Name** - What you call the function (use camelCase)\n   - Should describe what it does: calculateTotal, getUserName, etc.\n\n3. **Parameters** - Inputs the function needs (inside parentheses)\n   - Can have 0, 1, 2, or many parameters\n   - Separated by commas\n   - Like variables that exist only inside the function\n\n4. **Function body** - The code inside { }\n   - The instructions to execute\n\n5. **return statement** - Sends a value back (optional)\n   - Function stops executing when it hits return\n   - If no return, function returns undefined\n\nCalling a function:\nfunctionName(argument1, argument2);\n\n- Use the function name\n- Add parentheses ()\n- Pass arguments (values) for parameters\n\nWithout () it's just a reference:\ngreet     // The function itself (reference)\ngreet()   // Calling the function (execution)"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting parentheses when calling:\n   greet  // Doesn't execute - just references the function\n   greet()  // Executes the function\n\n2. Confusing parameters and arguments:\n   function greet(name) { }  // 'name' is a parameter (placeholder)\n   greet('Alice');  // 'Alice' is an argument (actual value)\n\n3. Not returning a value when you need one:\n   function add(a, b) {\n     a + b;  // WRONG - doesn't return anything!\n   }\n   function add(a, b) {\n     return a + b;  // CORRECT\n   }\n\n4. Code after return never runs:\n   function test() {\n     return 5;\n     console.log('This never runs!');  // Unreachable\n   }\n\n5. Wrong number of arguments:\n   function add(a, b) { return a + b; }\n   add(5);  // b is undefined, returns NaN\n   add(5, 3, 7);  // Extra argument ignored, returns 8"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.1-challenge",
              "title": "Practice Challenge",
              "description": "Create a function that converts Celsius to Fahrenheit:\n1. Name it celsiusToFahrenheit\n2. It should take one parameter: celsius\n3. Formula: (celsius * 9/5) + 32\n4. Return the result\n5. Test by calling it with 0, 100, and 37",
              "instructions": "Create a function that converts Celsius to Fahrenheit:\n1. Name it celsiusToFahrenheit\n2. It should take one parameter: celsius\n3. Formula: (celsius * 9/5) + 32\n4. Return the result\n5. Test by calling it with 0, 100, and 37",
              "starterCode": "// Define your function here\n\n// Test it\nconsole.log(celsiusToFahrenheit(0));    // Should be 32\nconsole.log(celsiusToFahrenheit(100));  // Should be 212\nconsole.log(celsiusToFahrenheit(37));   // Should be 98.6",
              "solution": "function celsiusToFahrenheit(celsius) {\n  return (celsius * 9/5) + 32;\n}\n\nconsole.log(celsiusToFahrenheit(0));    // 32\nconsole.log(celsiusToFahrenheit(100));  // 212\nconsole.log(celsiusToFahrenheit(37));   // 98.6",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Converts 0°C correctly",
                  "expectedOutput": "32",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "function celsiusToFahrenheit(celsius) { return (celsius * 9/5) + 32; }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting parentheses when calling:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting parentheses when calling:\n   greet  // Doesn't execute - just references the function\n   greet()  // Executes the function"
                },
                {
                  "mistake": "Confusing parameters and arguments:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Confusing parameters and arguments:\n   function greet(name) { }  // 'name' is a parameter (placeholder)\n   greet('Alice');  // 'Alice' is an argument (actual value)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.2",
          "title": "The Modern Shorthand (Arrow Functions =>)",
          "moduleId": "module-06",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have two ways to give someone your address:\n\n**Long form**: 'My address is 123 Main Street, New York, NY 10001'\n\n**Short form**: '123 Main St, NYC'\n\nBoth give the same information, but the short form is quicker for simple cases. Arrow functions (=>) are the 'short form' for writing functions in modern JavaScript. They do the same thing as regular functions, but with less typing for simple cases."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Traditional function\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow function (same thing, shorter)\nconst add = (a, b) => {\n  return a + b;\n};\n\n// Even shorter (implicit return for one-liners)\nconst add = (a, b) => a + b;\n\n// Examples of different arrow function forms\n\n// No parameters\nconst sayHello = () => console.log('Hello!');\nsayHello();  // Hello!\n\n// One parameter (parentheses optional)\nconst double = num => num * 2;\nconsole.log(double(5));  // 10\n\n// Multiple parameters (need parentheses)\nconst multiply = (a, b) => a * b;\nconsole.log(multiply(3, 4));  // 12\n\n// Multiple lines (need curly braces and explicit return)\nconst greetPerson = (name) => {\n  let greeting = 'Hello, ' + name;\n  return greeting + '!';\n};\nconsole.log(greetPerson('Alice'));  // Hello, Alice!\n\n// Using with array methods\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = numbers.map(n => n * 2);\nconsole.log(doubled);  // [2, 4, 6, 8, 10]"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Arrow function syntax:\n\nconst functionName = (parameters) => { body };\n│     │              │            │  │      │\n│     │              │            │  │      └─ Function body\n│     │              │            │  └──────── Arrow\n│     │              └────────────┴─────────── Parameters\n│     └──────────────────────────────────────── Name\n└────────────────────────────────────────────── const (or let)\n\nShorthand rules:\n\n1. **No parameters**: Use empty ()\n   const greet = () => 'Hello';\n\n2. **One parameter**: Parentheses optional\n   const double = x => x * 2;\n   const double = (x) => x * 2;  // Also valid\n\n3. **Multiple parameters**: Need parentheses\n   const add = (a, b) => a + b;\n\n4. **One-line body**: Can omit { } and return\n   const add = (a, b) => a + b;  // Implicit return\n\n5. **Multi-line body**: Need { } and explicit return\n   const greet = (name) => {\n     let msg = 'Hello, ' + name;\n     return msg;\n   };\n\nComparing to traditional functions:\n\n// Traditional\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow (full form)\nconst add = (a, b) => {\n  return a + b;\n};\n\n// Arrow (short form)\nconst add = (a, b) => a + b;\n\nWhen to use arrow functions:\n✓ Short, simple functions\n✓ Callback functions (map, filter, etc.)\n✓ Modern JavaScript style\n\nWhen to use traditional functions:\n✓ Methods in objects/classes\n✓ Need 'this' keyword (advanced)\n✓ Personal preference for readability"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting parentheses with multiple parameters:\n   const add = a, b => a + b;  // WRONG\n   const add = (a, b) => a + b;  // CORRECT\n\n2. Forgetting curly braces for multi-line:\n   const greet = name =>\n     let msg = 'Hello';\n     return msg;  // WRONG - syntax error\n   \n   const greet = name => {\n     let msg = 'Hello';\n     return msg;  // CORRECT\n   };\n\n3. Trying to return an object without parentheses:\n   const getUser = () => {name: 'Alice'};  // WRONG - thinks { } is function body\n   const getUser = () => ({name: 'Alice'});  // CORRECT - wrapped in ()\n\n4. Using arrow function as method:\n   const person = {\n     name: 'Alice',\n     greet: () => console.log(this.name)  // WRONG - 'this' doesn't work as expected\n   };\n   Use traditional function for object methods\n\n5. Mixing up = and =>:\n   const add = (a, b) = a + b;  // WRONG - single =\n   const add = (a, b) => a + b;  // CORRECT - arrow =>"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.2-challenge",
              "title": "Practice Challenge",
              "description": "Convert these traditional functions to arrow functions:\n\n1. function square(x) { return x * x; }\n2. function isEven(num) { return num % 2 === 0; }\n3. function getFullName(first, last) { return first + ' ' + last; }\n\nUse the shortest form possible!",
              "instructions": "Convert these traditional functions to arrow functions:\n\n1. function square(x) { return x * x; }\n2. function isEven(num) { return num % 2 === 0; }\n3. function getFullName(first, last) { return first + ' ' + last; }\n\nUse the shortest form possible!",
              "starterCode": "// Convert to arrow functions\nconst square = // YOUR CODE HERE\n\nconst isEven = // YOUR CODE HERE\n\nconst getFullName = // YOUR CODE HERE\n\n// Test them\nconsole.log(square(5));  // 25\nconsole.log(isEven(4));  // true\nconsole.log(getFullName('John', 'Doe'));  // John Doe",
              "solution": "const square = x => x * x;\n\nconst isEven = num => num % 2 === 0;\n\nconst getFullName = (first, last) => first + ' ' + last;\n\n// Test them\nconsole.log(square(5));  // 25\nconsole.log(isEven(4));  // true\nconsole.log(getFullName('John', 'Doe'));  // John Doe",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Square function works",
                  "expectedOutput": "25",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use: const name = params => expression"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting parentheses with multiple parameters:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting parentheses with multiple parameters:\n   const add = a, b => a + b;  // WRONG\n   const add = (a, b) => a + b;  // CORRECT"
                },
                {
                  "mistake": "Forgetting curly braces for multi-line:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting curly braces for multi-line:\n   const greet = name =>\n     let msg = 'Hello';\n     return msg;  // WRONG - syntax error\n   \n   const greet = name => {\n     let msg = 'Hello';\n     return msg;  // CORRECT\n   };"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.3",
          "title": "Ingredients and Results (Parameters and Return Values)",
          "moduleId": "module-06",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "A coffee machine is a perfect analogy for functions with parameters and return values:\n\n**Inputs (Parameters)**: You put in coffee beans, water, and select a size\n**Process**: The machine does its work inside (you don't see this)\n**Output (Return Value)**: You get a cup of coffee\n\nSimilarly, a function:\n- Takes INPUTS (parameters)\n- Does some PROCESSING (the function body)\n- Gives back an OUTPUT (return value)\n\nJust like you can put different beans in the coffee machine and get different coffee, you can pass different parameters to a function and get different results."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Function with one parameter\nfunction greet(name) {\n  return 'Hello, ' + name + '!';\n}\n\nlet message = greet('Alice');\nconsole.log(message);  // Hello, Alice!\n\n// Function with multiple parameters\nfunction calculateArea(width, height) {\n  return width * height;\n}\n\nlet area = calculateArea(5, 10);\nconsole.log(area);  // 50\n\n// Parameters with default values (ES2015+)\nfunction greet(name = 'Guest') {\n  return 'Hello, ' + name + '!';\n}\n\nconsole.log(greet());        // Hello, Guest!\nconsole.log(greet('Bob'));   // Hello, Bob!\n\n// Function that doesn't return (returns undefined)\nfunction logMessage(msg) {\n  console.log(msg);\n  // No return statement\n}\n\nlet result = logMessage('Test');\nconsole.log(result);  // undefined\n\n// Returning early\nfunction divide(a, b) {\n  if (b === 0) {\n    return 'Cannot divide by zero';\n  }\n  return a / b;\n}\n\nconsole.log(divide(10, 2));  // 5\nconsole.log(divide(10, 0));  // Cannot divide by zero\n\n// Returning objects\nfunction createUser(name, age) {\n  return {\n    name: name,\n    age: age,\n    isAdult: age >= 18\n  };\n}\n\nlet user = createUser('Alice', 25);\nconsole.log(user);  // {name: 'Alice', age: 25, isAdult: true}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding parameters and returns:\n\n**Parameters** (Function Definition):\nfunction doSomething(param1, param2, param3) {\n                     │      │      │\n                     └──────┴──────┴─ Placeholders for values\n}\n\n**Arguments** (Function Call):\ndoSomething(value1, value2, value3);\n            │       │       │\n            └───────┴───────┴─ Actual values passed in\n\nParameter patterns:\n\n1. **No parameters**:\n   function sayHello() {\n     return 'Hello!';\n   }\n\n2. **One parameter**:\n   function double(x) {\n     return x * 2;\n   }\n\n3. **Multiple parameters**:\n   function add(a, b) {\n     return a + b;\n   }\n\n4. **Default parameters** (ES2015):\n   function greet(name = 'Guest', greeting = 'Hello') {\n     return greeting + ', ' + name;\n   }\n   greet();  // Hello, Guest\n   greet('Alice');  // Hello, Alice\n   greet('Bob', 'Hi');  // Hi, Bob\n\n5. **Rest parameters** (collect all remaining args):\n   function sum(...numbers) {\n     return numbers.reduce((total, n) => total + n, 0);\n   }\n   sum(1, 2, 3, 4);  // 10\n\nReturn value patterns:\n\n1. **Return a value**:\n   return 42;\n   return 'text';\n   return true;\n\n2. **Return early** (exit function immediately):\n   if (error) {\n     return 'Error';\n   }\n   // Rest of function\n\n3. **No return** (implicitly returns undefined):\n   function doSomething() {\n     console.log('Done');\n   }\n\n4. **Return object** (use parentheses with arrow functions):\n   const getUser = () => ({name: 'Alice', age: 25});\n\n5. **Return another function**:\n   function outer() {\n     return function inner() {\n       return 'Hello';\n     };\n   }"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Wrong number of arguments:\n   function add(a, b) { return a + b; }\n   add(5);  // b is undefined, returns NaN\n   add(5, 3, 7);  // 7 is ignored\n\n2. Not returning the value:\n   function add(a, b) {\n     a + b;  // Calculated but not returned!\n   }\n   let result = add(5, 3);  // undefined\n\n3. Trying to use parameters outside function:\n   function greet(name) {\n     return 'Hello, ' + name;\n   }\n   console.log(name);  // ERROR - name only exists inside function\n\n4. Forgetting to call the function:\n   let result = add;  // result is the function itself\n   let result = add(5, 3);  // result is 8\n\n5. Returning in wrong place:\n   function test() {\n     if (true) {\n       let x = 5;\n       return x;  // WRONG - x might not be accessible\n     }\n   }\n   Better: calculate first, then return"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.3-challenge",
              "title": "Practice Challenge",
              "description": "Create a function called calculateGrade that:\n1. Takes one parameter: score (a number 0-100)\n2. Returns a letter grade based on:\n   - 90+ = 'A'\n   - 80-89 = 'B'\n   - 70-79 = 'C'\n   - 60-69 = 'D'\n   - Below 60 = 'F'\n3. Test with scores: 95, 87, 72, 65, 45",
              "instructions": "Create a function called calculateGrade that:\n1. Takes one parameter: score (a number 0-100)\n2. Returns a letter grade based on:\n   - 90+ = 'A'\n   - 80-89 = 'B'\n   - 70-79 = 'C'\n   - 60-69 = 'D'\n   - Below 60 = 'F'\n3. Test with scores: 95, 87, 72, 65, 45",
              "starterCode": "function calculateGrade(score) {\n  // YOUR CODE HERE\n}\n\n// Test\nconsole.log(calculateGrade(95));  // Should be 'A'\nconsole.log(calculateGrade(87));  // Should be 'B'\nconsole.log(calculateGrade(72));  // Should be 'C'",
              "solution": "function calculateGrade(score) {\n  if (score >= 90) {\n    return 'A';\n  } else if (score >= 80) {\n    return 'B';\n  } else if (score >= 70) {\n    return 'C';\n  } else if (score >= 60) {\n    return 'D';\n  } else {\n    return 'F';\n  }\n}\n\nconsole.log(calculateGrade(95));  // A\nconsole.log(calculateGrade(87));  // B\nconsole.log(calculateGrade(72));  // C\nconsole.log(calculateGrade(65));  // D\nconsole.log(calculateGrade(45));  // F",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Returns 'A' for 95",
                  "expectedOutput": "A",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use if/else if/else with return statements"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Wrong number of arguments:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Wrong number of arguments:\n   function add(a, b) { return a + b; }\n   add(5);  // b is undefined, returns NaN\n   add(5, 3, 7);  // 7 is ignored"
                },
                {
                  "mistake": "Not returning the value:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Not returning the value:\n   function add(a, b) {\n     a + b;  // Calculated but not returned!\n   }\n   let result = add(5, 3);  // undefined"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.4",
          "title": "What's 'In the Kitchen'? (Scope and Variable Visibility)",
          "moduleId": "module-06",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a restaurant with different areas:\n\n**The Kitchen** (Function Scope): Chefs can use all the kitchen tools and ingredients. But customers in the dining room can't reach into the kitchen and grab a spatula.\n\n**The Dining Room** (Global Scope): Everyone can see and use things here - tables, chairs, menus.\n\n**A Chef's Personal Station** (Block Scope): Each chef has their own station. Their tools are theirs - other chefs can't use them.\n\nThis is SCOPE in programming - which parts of your code can 'see' and use which variables. Variables declared inside a function are like kitchen tools - only accessible inside that function. Variables declared outside are like the dining room - everyone can access them."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Global scope - accessible everywhere\nlet globalVar = 'I am global';\n\nfunction testScope() {\n  // Function scope - only accessible inside this function\n  let localVar = 'I am local';\n  \n  console.log(globalVar);  // Works - can access global\n  console.log(localVar);   // Works - we're inside the function\n}\n\ntestScope();\nconsole.log(globalVar);  // Works - global is accessible\n// console.log(localVar);   // ERROR - localVar doesn't exist here!\n\n// Block scope (let and const)\nif (true) {\n  let blockVar = 'I am in a block';\n  const alsoBlock = 'Me too';\n  var notBlock = 'I escape!';\n  \n  console.log(blockVar);  // Works\n}\n\n// console.log(blockVar);  // ERROR - blockVar is block-scoped\nconsole.log(notBlock);   // Works - var ignores block scope (bad!)\n\n// Nested scopes\nlet outer = 'outer';\n\nfunction outerFunc() {\n  let middle = 'middle';\n  \n  function innerFunc() {\n    let inner = 'inner';\n    \n    console.log(outer);   // Works - can see outer\n    console.log(middle);  // Works - can see parent\n    console.log(inner);   // Works - own scope\n  }\n  \n  innerFunc();\n  // console.log(inner);  // ERROR - can't see child scope\n}\n\nouterFunc();\n\n// Shadowing (be careful!)\nlet name = 'Global Alice';\n\nfunction greet() {\n  let name = 'Local Bob';  // Different variable!\n  console.log(name);  // Local Bob\n}\n\ngreet();\nconsole.log(name);  // Global Alice"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding scope:\n\n**1. Global Scope**\n- Variables declared outside any function\n- Accessible everywhere in your code\n- Use sparingly - can cause naming conflicts\n\nlet globalVar = 'accessible everywhere';\n\nfunction anywhere() {\n  console.log(globalVar);  // Can access\n}\n\n**2. Function Scope**\n- Variables declared inside a function\n- Only accessible inside that function\n- Includes parameters\n\nfunction myFunc(param) {  // param has function scope\n  let localVar = 'only here';  // localVar has function scope\n}\n\n**3. Block Scope** (let and const only)\n- Variables declared inside { }\n- Only accessible inside that block\n- if, for, while, etc. create blocks\n\nif (true) {\n  let x = 5;  // Block scoped\n  const y = 10;  // Block scoped\n  var z = 15;  // Function scoped (escapes block!)\n}\n\n**Scope Chain** (looking up variables):\n\nlet a = 'global';\n\nfunction outer() {\n  let b = 'outer';\n  \n  function inner() {\n    let c = 'inner';\n    \n    // JavaScript looks for variables in this order:\n    // 1. Current scope (inner) - c\n    // 2. Parent scope (outer) - b\n    // 3. Grandparent scope (global) - a\n  }\n}\n\n**Best Practices**:\n\n1. Use let and const (not var)\n   - They respect block scope\n   - Prevent accidental global variables\n\n2. Keep variables in smallest scope needed\n   - Declare inside functions/blocks when possible\n   - Reduces naming conflicts\n\n3. Avoid global variables\n   - Hard to track who modifies them\n   - Can cause bugs\n\n4. Don't shadow variables (same name in nested scopes)\n   - Confusing to read\n   - Use different names"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Using variables outside their scope:\n   function test() {\n     let x = 5;\n   }\n   console.log(x);  // ERROR - x only exists inside test()\n\n2. Forgetting var escapes block scope:\n   if (true) {\n     var x = 5;  // Function scoped, not block scoped!\n   }\n   console.log(x);  // 5 - var leaks out\n   \n   Always use let/const, never var!\n\n3. Shadowing by accident:\n   let name = 'Alice';\n   function greet() {\n     let name = 'Bob';  // Different variable!\n   }\n   Confusing - use different names\n\n4. Trying to access parameters outside function:\n   function add(a, b) {\n     return a + b;\n   }\n   console.log(a);  // ERROR - parameters are function-scoped\n\n5. Not understanding hoisting:\n   console.log(x);  // undefined (not error with var)\n   var x = 5;\n   \n   vs\n   \n   console.log(x);  // ERROR - cannot access before initialization\n   let x = 5;\n   \n   Another reason to use let/const!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.4-challenge",
              "title": "Practice Challenge",
              "description": "Debug this code - it has scope issues:\n\nfunction calculateTotal() {\n  let price = 100;\n  let tax = 0.08;\n  \n  if (price > 50) {\n    let discount = 10;\n  }\n  \n  let total = price - discount + (price * tax);\n  return total;\n}\n\nFix it so discount is accessible. Then calculate the total correctly.",
              "instructions": "Debug this code - it has scope issues:\n\nfunction calculateTotal() {\n  let price = 100;\n  let tax = 0.08;\n  \n  if (price > 50) {\n    let discount = 10;\n  }\n  \n  let total = price - discount + (price * tax);\n  return total;\n}\n\nFix it so discount is accessible. Then calculate the total correctly.",
              "starterCode": "function calculateTotal() {\n  let price = 100;\n  let tax = 0.08;\n  \n  if (price > 50) {\n    let discount = 10;\n  }\n  \n  let total = price - discount + (price * tax);\n  return total;\n}\n\nconsole.log(calculateTotal());",
              "solution": "function calculateTotal() {\n  let price = 100;\n  let tax = 0.08;\n  let discount = 0;  // Declare in function scope\n  \n  if (price > 50) {\n    discount = 10;  // Assign (no let)\n  }\n  \n  let total = price - discount + (price * tax);\n  return total;\n}\n\nconsole.log(calculateTotal());  // 98",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Calculates total correctly",
                  "expectedOutput": "98",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Declare discount outside the if block, or move the calculation inside"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Using variables outside their scope:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using variables outside their scope:\n   function test() {\n     let x = 5;\n   }\n   console.log(x);  // ERROR - x only exists inside test()"
                },
                {
                  "mistake": "Forgetting var escapes block scope:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting var escapes block scope:\n   if (true) {\n     var x = 5;  // Function scoped, not block scoped!\n   }\n   console.log(x);  // 5 - var leaks out\n   \n   Always use let/const, never var!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-07",
      "title": "Module 7: Working with the Web Page (The 'Browser')",
      "description": "Make your code interact with HTML and create dynamic web pages",
      "difficulty": "intermediate",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "7.1",
          "title": "The Three Layers of a Webpage (HTML, CSS, and JavaScript)",
          "moduleId": "module-07",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Building a house has three distinct phases:\n\n**HTML (The Structure)**: This is like the wooden frame of a house - the walls, roof, floors. It defines WHAT exists (rooms, doors, windows) but not how they look or behave.\n\n**CSS (The Styling)**: This is like painting, decorating, choosing furniture. It makes the structure LOOK good - colors, fonts, layouts, spacing.\n\n**JavaScript (The Behavior)**: This is like the electrical wiring, plumbing, security system. It makes things WORK - lights turn on/off, doors lock/unlock, alarms sound.\n\nYou need all three! A house with just a frame is boring. A house with no wiring doesn't work. Together, they create a complete, functional, beautiful home."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "<!-- HTML: The structure (skeleton) -->\n<!DOCTYPE html>\n<html>\n<head>\n  <title>My Page</title>\n  <!-- CSS: The styling (clothes) -->\n  <style>\n    h1 {\n      color: blue;        /* Make heading blue */\n      font-size: 32px;    /* Make it big */\n    }\n    .highlight {\n      background-color: yellow;\n    }\n  </style>\n</head>\n<body>\n  <h1 id=\"title\">Hello, World!</h1>\n  <button id=\"myButton\">Click Me!</button>\n  <p id=\"message\"></p>\n\n  <!-- JavaScript: The behavior (brain) -->\n  <script>\n    // This code runs when the page loads\n    \n    // Find the button element\n    let button = document.getElementById('myButton');\n    \n    // Make something happen when button is clicked\n    button.addEventListener('click', function() {\n      // Find the message paragraph\n      let message = document.getElementById('message');\n      \n      // Change its text content\n      message.textContent = 'Button was clicked!';\n      \n      // Add styling class\n      message.className = 'highlight';\n    });\n  </script>\n</body>\n</html>"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding the three layers:\n\n**1. HTML (HyperText Markup Language)**\n- Defines the STRUCTURE and CONTENT\n- Uses tags: <tagname>content</tagname>\n- Common tags:\n  - <h1> to <h6>: Headings\n  - <p>: Paragraphs\n  - <div>: Generic container\n  - <button>: Clickable button\n  - <input>: Form input\n- Attributes give extra info:\n  - id=\"unique-name\" (unique identifier)\n  - class=\"style-class\" (styling group)\n\n**2. CSS (Cascading Style Sheets)**\n- Defines how HTML elements LOOK\n- Syntax: selector { property: value; }\n- Can be:\n  - Inline: <p style=\"color: red\">Text</p>\n  - Internal: <style> tags in <head>\n  - External: <link rel=\"stylesheet\" href=\"style.css\">\n- Selectors:\n  - h1 { } - All <h1> tags\n  - #myId { } - Element with id=\"myId\"\n  - .myClass { } - Elements with class=\"myClass\"\n\n**3. JavaScript (The Programming Language)**\n- Makes pages INTERACTIVE and DYNAMIC\n- Can:\n  - Find HTML elements\n  - Change their content\n  - Change their styling\n  - Respond to user actions (clicks, typing, etc.)\n  - Fetch data from servers\n  - Validate forms\n  - Animate elements\n\nHow they work together:\n1. HTML creates structure\n2. CSS makes it pretty\n3. JavaScript makes it interactive\n\nExample flow:\n1. User sees button (HTML)\n2. Button is styled blue (CSS)\n3. User clicks button (JavaScript detects)\n4. Message appears (JavaScript changes HTML)\n5. Message is highlighted (JavaScript adds CSS class)"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting quotes around IDs:\n   document.getElementById(heading)  // WRONG - thinks heading is a variable\n   document.getElementById('heading')  // CORRECT - string literal\n\n2. Running JavaScript before HTML loads:\n   <script>document.getElementById('myButton')</script>\n   <button id=\"myButton\">Click</button>\n   The script runs before button exists! Put scripts at end of <body>\n\n3. Typos in IDs (case-sensitive!):\n   HTML: <div id=\"myDiv\"></div>\n   JS: document.getElementById('mydiv')  // WRONG - lowercase d\n   JS: document.getElementById('myDiv')  // CORRECT\n\n4. Confusing textContent, innerHTML, and value:\n   - textContent: Text only (safe, no HTML)\n   - innerHTML: HTML content (can be dangerous!)\n   - value: For form inputs (<input>, <textarea>)\n\n5. Forgetting to attach event listener:\n   button.addEventListener('click', myFunction)  // Correct\n   button.addEventListener('click', myFunction())  // WRONG - calls immediately!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.1-challenge",
              "title": "Practice Challenge",
              "description": "You'll work with this HTML structure:\n\n<h1 id=\"heading\">Welcome</h1>\n<button id=\"changeButton\">Change Text</button>\n\nWrite JavaScript that:\n1. Finds the heading element (use document.getElementById)\n2. Finds the button element\n3. When button is clicked, change heading text to 'Hello, JavaScript!'",
              "instructions": "You'll work with this HTML structure:\n\n<h1 id=\"heading\">Welcome</h1>\n<button id=\"changeButton\">Change Text</button>\n\nWrite JavaScript that:\n1. Finds the heading element (use document.getElementById)\n2. Finds the button element\n3. When button is clicked, change heading text to 'Hello, JavaScript!'",
              "starterCode": "// Find the heading element\nlet heading = document.getElementById('heading');\n\n// Find the button element\nlet button = document.getElementById('changeButton');\n\n// Add click event listener\nbutton.addEventListener('click', function() {\n  // YOUR CODE HERE: Change heading.textContent\n});",
              "solution": "let heading = document.getElementById('heading');\nlet button = document.getElementById('changeButton');\n\nbutton.addEventListener('click', function() {\n  heading.textContent = 'Hello, JavaScript!';\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Changes heading text on click",
                  "expectedOutput": "Hello, JavaScript!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Inside the click function, use: heading.textContent = 'Hello, JavaScript!';"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting quotes around IDs:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting quotes around IDs:\n   document.getElementById(heading)  // WRONG - thinks heading is a variable\n   document.getElementById('heading')  // CORRECT - string literal"
                },
                {
                  "mistake": "Running JavaScript before HTML loads:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Running JavaScript before HTML loads:\n   <script>document.getElementById('myButton')</script>\n   <button id=\"myButton\">Click</button>\n   The script runs before button exists! Put scripts at end of <body>"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "7.2",
          "title": "The Browser's Live Blueprint (What Is the DOM?)",
          "moduleId": "module-07",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're building with LEGO blocks. You have the instruction manual (HTML code), but you also have the actual LEGO structure you've built (the DOM).\n\nThe **DOM (Document Object Model)** is the browser's LIVE representation of your webpage. It's not the HTML code itself - it's the browser's interpretation of that code, turned into a tree of objects that JavaScript can manipulate.\n\nThink of it like this:\n- **HTML**: Blueprint on paper (static text)\n- **DOM**: Actual LEGO construction (living, changeable structure)\n\nWhen you use JavaScript to change the DOM, you're rebuilding parts of the LEGO structure on the fly. The browser immediately shows your changes on screen."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// The DOM is a tree structure\n// HTML:\n// <html>\n//   <body>\n//     <h1>Title</h1>\n//     <p>Paragraph</p>\n//   </body>\n// </html>\n//\n// Becomes this tree:\n// document\n//   └─ html\n//      └─ body\n//         ├─ h1 (\"Title\")\n//         └─ p (\"Paragraph\")\n\n// Accessing the DOM\nconsole.log(document);  // The entire page\nconsole.log(document.body);  // The <body> element\nconsole.log(document.title);  // Page title\n\n// Finding elements (we'll learn more about this next)\nlet element = document.getElementById('myId');\nlet elements = document.getElementsByClassName('myClass');\nlet firstDiv = document.querySelector('div');\nlet allDivs = document.querySelectorAll('div');\n\n// The DOM is LIVE - changes appear immediately\nlet heading = document.getElementById('title');\nheading.textContent = 'New Title';  // Page updates instantly!\n\n// DOM nodes have properties\nconsole.log(heading.tagName);  // 'H1'\nconsole.log(heading.id);  // 'title'\nconsole.log(heading.className);  // CSS classes\n\n// DOM nodes have relationships (tree structure)\nlet parent = heading.parentElement;  // Element above\nlet children = parent.children;  // Elements below\nlet nextSibling = heading.nextElementSibling;  // Next element at same level"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding the DOM:\n\n**What is the DOM?**\n- Browser's representation of the HTML page\n- Tree structure of objects\n- Each HTML element becomes a JavaScript object\n- You can read and modify these objects\n- Changes appear instantly on the page\n\n**DOM Tree Structure:**\n\nHTML:\n<body>\n  <div id=\"container\">\n    <h1>Title</h1>\n    <p>Text</p>\n  </div>\n</body>\n\nDOM Tree:\ndocument\n  └─ body\n     └─ div (id=\"container\")\n        ├─ h1 (\"Title\")\n        └─ p (\"Text\")\n\n**Key DOM Methods:**\n\n1. Finding single elements:\n   - document.getElementById('id')\n   - document.querySelector('selector')\n\n2. Finding multiple elements:\n   - document.getElementsByClassName('class')\n   - document.getElementsByTagName('tag')\n   - document.querySelectorAll('selector')\n\n3. Element properties:\n   - element.textContent (text only)\n   - element.innerHTML (HTML content)\n   - element.value (for inputs)\n   - element.id (element's ID)\n   - element.className (CSS classes)\n   - element.style (inline CSS)\n\n4. Tree navigation:\n   - element.parentElement (parent)\n   - element.children (child elements)\n   - element.nextElementSibling (next)\n   - element.previousElementSibling (previous)\n\n**Important Concepts:**\n\n1. The DOM is LIVE\n   - Changes happen immediately\n   - No need to \"refresh\" or \"save\"\n\n2. Elements are objects\n   - They have properties you can read/write\n   - They have methods you can call\n\n3. Everything is a node\n   - Elements, text, comments, etc.\n   - Forms a tree structure\n\n4. querySelector is modern and flexible\n   - Uses CSS selectors\n   - More powerful than getElementBy...\n   - We'll use this primarily"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Confusing the DOM with HTML:\n   - HTML: Static code you write\n   - DOM: Live structure in browser\n   - Changing HTML file doesn't change running page\n   - Changing DOM changes page immediately\n\n2. Null reference errors:\n   let element = document.getElementById('wrong-id');\n   element.textContent = 'Hi';  // ERROR - element is null!\n   \n   Always check:\n   if (element !== null) {\n     element.textContent = 'Hi';\n   }\n\n3. Mixing up textContent and innerHTML:\n   element.textContent = '<b>Bold</b>';  // Shows literal <b> tags\n   element.innerHTML = '<b>Bold</b>';  // Renders as bold\n   \n   Use textContent for safety (prevents XSS attacks)\n\n4. Timing issues:\n   If JavaScript runs before HTML loads, elements don't exist yet\n   Solution: Put <script> at end of <body> or use DOMContentLoaded event\n\n5. getElementsByClassName returns collection, not array:\n   let items = document.getElementsByClassName('item');\n   items.forEach(...)  // ERROR - not an array!\n   Array.from(items).forEach(...)  // Correct"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.2-challenge",
              "title": "Practice Challenge",
              "description": "Given this HTML:\n<div id=\"container\">\n  <h1 id=\"title\">Original Title</h1>\n  <p id=\"description\">Original description</p>\n</div>\n\nWrite JavaScript that:\n1. Finds the container div\n2. Finds the title h1\n3. Finds the description p\n4. Change title to 'Updated Title'\n5. Change description to 'Updated description'\n6. Log the container's number of children",
              "instructions": "Given this HTML:\n<div id=\"container\">\n  <h1 id=\"title\">Original Title</h1>\n  <p id=\"description\">Original description</p>\n</div>\n\nWrite JavaScript that:\n1. Finds the container div\n2. Finds the title h1\n3. Finds the description p\n4. Change title to 'Updated Title'\n5. Change description to 'Updated description'\n6. Log the container's number of children",
              "starterCode": "// Find the elements\nlet container = // YOUR CODE\nlet title = // YOUR CODE\nlet description = // YOUR CODE\n\n// Update content\n// YOUR CODE\n\n// Log number of children\nconsole.log(container.children.length);",
              "solution": "let container = document.getElementById('container');\nlet title = document.getElementById('title');\nlet description = document.getElementById('description');\n\ntitle.textContent = 'Updated Title';\ndescription.textContent = 'Updated description';\n\nconsole.log(container.children.length);  // 2",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Updates both elements correctly",
                  "expectedOutput": "2",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use document.getElementById('id') for each element"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Confusing the DOM with HTML:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Confusing the DOM with HTML:\n   - HTML: Static code you write\n   - DOM: Live structure in browser\n   - Changing HTML file doesn't change running page\n   - Changing DOM changes page immediately"
                },
                {
                  "mistake": "Null reference errors:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Null reference errors:\n   let element = document.getElementById('wrong-id');\n   element.textContent = 'Hi';  // ERROR - element is null!\n   \n   Always check:\n   if (element !== null) {\n     element.textContent = 'Hi';\n   }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "7.3",
          "title": "Finding Elements on the Page (querySelector)",
          "moduleId": "module-07",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're in a huge library looking for books:\n\n**Old way** (getElementById, getElementsByClassName): You can only search by:\n- Call number (ID): \"Find book #12345\"\n- Category (class): \"Find all books in Science section\"\n\n**New way** (querySelector): You can search by ANYTHING:\n- \"Find the first red book on the third shelf\"\n- \"Find all books by Author X with 'JavaScript' in the title\"\n- \"Find the book inside the Special Collections room\"\n\nquerySelector uses CSS selectors, which means you can find elements in incredibly flexible ways. It's like having a super-powered library search system!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// querySelector finds the FIRST match\n// querySelectorAll finds ALL matches\n\n// By ID (same as getElementById, but with # prefix)\nlet title = document.querySelector('#title');\n\n// By class (same as getElementsByClassName, but with . prefix)\nlet firstItem = document.querySelector('.item');\nlet allItems = document.querySelectorAll('.item');\n\n// By tag name\nlet firstParagraph = document.querySelector('p');\nlet allParagraphs = document.querySelectorAll('p');\n\n// By attribute\nlet input = document.querySelector('[type=\"email\"]');\nlet required = document.querySelectorAll('[required]');\n\n// Combining selectors\nlet redButton = document.querySelector('button.red');\nlet containerDiv = document.querySelector('div#container');\n\n// Descendant selectors (inside)\nlet linkInNav = document.querySelector('nav a');\nlet itemsInList = document.querySelectorAll('ul.menu li');\n\n// Direct children (>)\nlet directChild = document.querySelector('div > p');\n\n// Pseudo-selectors\nlet firstChild = document.querySelector('li:first-child');\nlet lastChild = document.querySelector('li:last-child');\nlet evenItems = document.querySelectorAll('li:nth-child(even)');\n\n// Complex example\nlet specificButton = document.querySelector('div.container button.primary:not(.disabled)');\n// Finds: button with class 'primary', inside div with class 'container', not having class 'disabled'\n\n// querySelectorAll returns NodeList (array-like)\nlet buttons = document.querySelectorAll('button');\nconsole.log(buttons.length);  // Number of buttons\nbuttons.forEach(btn => {\n  console.log(btn.textContent);\n});"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "querySelector syntax (uses CSS selectors):\n\n**Basic Selectors:**\n\n1. By ID: #idName\n   document.querySelector('#myId')\n   // Same as: document.getElementById('myId')\n\n2. By class: .className\n   document.querySelector('.myClass')\n   document.querySelectorAll('.myClass')  // All matches\n\n3. By tag: tagname\n   document.querySelector('p')\n   document.querySelectorAll('div')\n\n4. By attribute: [attribute]\n   document.querySelector('[href]')  // Has href attribute\n   document.querySelector('[type=\"submit\"]')  // type=\"submit\"\n\n**Combinators:**\n\n1. Descendant: space (anywhere inside)\n   document.querySelector('div p')  // p inside any div\n\n2. Direct child: >\n   document.querySelector('div > p')  // p directly inside div\n\n3. Multiple selectors: comma\n   document.querySelectorAll('h1, h2, h3')  // All headings\n\n4. Combined: no space\n   document.querySelector('button.primary')  // button with class 'primary'\n\n**Pseudo-selectors:**\n\n1. :first-child, :last-child\n2. :nth-child(n) - The nth child\n3. :nth-child(even), :nth-child(odd)\n4. :not(selector) - Exclude matches\n5. :hover, :focus, :checked (for CSS, less useful in JS)\n\n**Differences from getElementBy...:**\n\nquerySelector:\n✓ More flexible (any CSS selector)\n✓ Consistent syntax\n✓ Returns null if not found\n✓ Modern and recommended\n✗ Slightly slower (negligible)\n\ngetElementBy...:\n✓ Slightly faster\n✓ Returns live collections (auto-updates)\n✗ Limited to ID, class, or tag\n✗ Different syntax for each\n\n**Best Practice:**\nUse querySelector/querySelectorAll for everything. They're more powerful and the syntax is consistent.\n\n**NodeList vs Array:**\nquerySelectorAll returns a NodeList (not an Array)\n- Has .length\n- Has .forEach() (modern browsers)\n- Doesn't have .map(), .filter(), etc.\n\nConvert to array if needed:\nlet itemsArray = Array.from(document.querySelectorAll('.item'));"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting the . or # prefix:\n   document.querySelector('myClass')  // WRONG - looks for <myClass> tag\n   document.querySelector('.myClass')  // CORRECT - looks for class\n\n2. Expecting querySelectorAll to be an array:\n   let items = document.querySelectorAll('.item');\n   items.map(...)  // ERROR - NodeList doesn't have map\n   \n   Convert first:\n   Array.from(items).map(...)\n   // Or use forEach (works on NodeList):\n   items.forEach(...)\n\n3. Confusing querySelector with querySelectorAll:\n   querySelector returns: first match or null\n   querySelectorAll returns: NodeList of all matches (can be empty)\n\n4. Complex selectors with typos:\n   'div.container button.primary'  // Correct\n   'div .container button .primary'  // WRONG - extra spaces change meaning\n\n5. Not checking for null:\n   let element = document.querySelector('.doesnt-exist');\n   element.textContent = 'Hi';  // ERROR - element is null!\n   \n   Always check:\n   if (element) {\n     element.textContent = 'Hi';\n   }"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.3-challenge",
              "title": "Practice Challenge",
              "description": "Given this HTML:\n<nav>\n  <ul class=\"menu\">\n    <li class=\"item\">Home</li>\n    <li class=\"item active\">About</li>\n    <li class=\"item\">Contact</li>\n  </ul>\n</nav>\n<div class=\"content\">\n  <button class=\"primary\">Save</button>\n  <button class=\"secondary\">Cancel</button>\n</div>\n\nWrite JavaScript using querySelector to:\n1. Find the active menu item\n2. Find all menu items\n3. Find the primary button\n4. Find all buttons\n5. Log the text of the active item",
              "instructions": "Given this HTML:\n<nav>\n  <ul class=\"menu\">\n    <li class=\"item\">Home</li>\n    <li class=\"item active\">About</li>\n    <li class=\"item\">Contact</li>\n  </ul>\n</nav>\n<div class=\"content\">\n  <button class=\"primary\">Save</button>\n  <button class=\"secondary\">Cancel</button>\n</div>\n\nWrite JavaScript using querySelector to:\n1. Find the active menu item\n2. Find all menu items\n3. Find the primary button\n4. Find all buttons\n5. Log the text of the active item",
              "starterCode": "// Find the active menu item\nlet activeItem = document.querySelector(/* YOUR SELECTOR */);\n\n// Find all menu items\nlet allItems = document.querySelectorAll(/* YOUR SELECTOR */);\n\n// Find the primary button\nlet primaryButton = document.querySelector(/* YOUR SELECTOR */);\n\n// Find all buttons\nlet allButtons = document.querySelectorAll(/* YOUR SELECTOR */);\n\n// Log the active item text\nconsole.log(activeItem.textContent);",
              "solution": "let activeItem = document.querySelector('.item.active');\nlet allItems = document.querySelectorAll('.item');\nlet primaryButton = document.querySelector('.primary');\nlet allButtons = document.querySelectorAll('button');\n\nconsole.log(activeItem.textContent);  // About",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Finds active item correctly",
                  "expectedOutput": "About",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use '.item.active' for active item, '.item' for all items, '.primary' for primary button, 'button' for all buttons"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting the . or # prefix:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting the . or # prefix:\n   document.querySelector('myClass')  // WRONG - looks for <myClass> tag\n   document.querySelector('.myClass')  // CORRECT - looks for class"
                },
                {
                  "mistake": "Expecting querySelectorAll to be an array:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Expecting querySelectorAll to be an array:\n   let items = document.querySelectorAll('.item');\n   items.map(...)  // ERROR - NodeList doesn't have map\n   \n   Convert first:\n   Array.from(items).map(...)\n   // Or use forEach (works on NodeList):\n   items.forEach(...)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "7.4",
          "title": "Changing What Users See (Modifying .textContent and .style)",
          "moduleId": "module-07",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have a puppet theater:\n\n**textContent**: This is like changing what the puppet SAYS. You're swapping out the dialogue.\n\n**style**: This is like changing what the puppet WEARS or how it LOOKS. You're changing the costume, makeup, lighting.\n\nJavaScript lets you be the puppeteer - you can change what elements say (their text) and how they look (their styling) on the fly, creating a dynamic, interactive show for your users."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Changing text content\nlet heading = document.querySelector('h1');\nheading.textContent = 'New Heading';\n\nlet paragraph = document.querySelector('p');\nparagraph.textContent = 'New paragraph text';\n\n// Changing inline styles (CSS properties)\nlet box = document.querySelector('.box');\nbox.style.color = 'red';  // Text color\nbox.style.backgroundColor = 'yellow';  // Background (note camelCase!)\nbox.style.fontSize = '24px';  // Font size\nbox.style.width = '200px';  // Width\nbox.style.padding = '20px';  // Padding\nbox.style.border = '2px solid black';  // Border\n\n// CSS properties with hyphens become camelCase in JavaScript\n// CSS: background-color → JavaScript: backgroundColor\n// CSS: font-size → JavaScript: fontSize\n// CSS: margin-top → JavaScript: marginTop\n\n// Working with classes (better than inline styles!)\nlet element = document.querySelector('.item');\n\n// Add a class\nelement.classList.add('active');\n\n// Remove a class\nelement.classList.remove('inactive');\n\n// Toggle a class (add if missing, remove if present)\nelement.classList.toggle('highlighted');\n\n// Check if class exists\nif (element.classList.contains('active')) {\n  console.log('Element is active');\n}\n\n// Practical example: Dark mode toggle\nlet button = document.querySelector('#darkModeBtn');\nbutton.addEventListener('click', function() {\n  document.body.classList.toggle('dark-mode');\n});\n\n// Changing multiple styles at once\nlet card = document.querySelector('.card');\nObject.assign(card.style, {\n  width: '300px',\n  height: '200px',\n  backgroundColor: '#f0f0f0',\n  borderRadius: '10px',\n  padding: '20px'\n});\n\n// Getting current styles\nlet computedStyle = window.getComputedStyle(element);\nconsole.log(computedStyle.color);  // Current color"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Modifying DOM elements:\n\n**1. Changing Text Content:**\n\n// textContent (recommended - safe, text only)\nelement.textContent = 'New text';\n\n// innerHTML (can include HTML, but risky!)\nelement.innerHTML = '<b>Bold text</b>';\n\n// innerText (similar to textContent, but respects CSS visibility)\nelement.innerText = 'New text';\n\n**Best practice**: Use textContent unless you specifically need HTML\n\n**2. Changing Inline Styles:**\n\nelement.style.propertyName = 'value';\n\nKey points:\n- CSS properties with hyphens become camelCase\n- Values are strings (include units: '20px', '50%')\n- This adds inline styles (highest priority)\n\nExamples:\nCSS Property        → JavaScript Property\ncolor               → color\nbackground-color    → backgroundColor\nfont-size           → fontSize\nmargin-top          → marginTop\nborder-radius       → borderRadius\nz-index             → zIndex\n\n**3. Working with Classes (Preferred Method):**\n\n// classList provides methods to manipulate classes\nelement.classList.add('class1', 'class2');\nelement.classList.remove('class1');\nelement.classList.toggle('class1');  // Add if missing, remove if present\nelement.classList.contains('class1');  // Returns true/false\nelement.classList.replace('old', 'new');\n\n// Old way (not recommended):\nelement.className = 'class1 class2';  // Replaces all classes\n\n**Why use classes instead of inline styles?**\n\n✓ Separation of concerns (CSS in CSS, JS in JS)\n✓ Easier to maintain\n✓ Can change multiple properties at once\n✓ Better performance\n✓ CSS can be cached\n✓ Easier to override\n\nExample:\n// Instead of:\nelement.style.color = 'red';\nelement.style.fontWeight = 'bold';\nelement.style.fontSize = '20px';\n\n// Do this:\nelement.classList.add('error');\n\n// And in CSS:\n.error {\n  color: red;\n  font-weight: bold;\n  font-size: 20px;\n}\n\n**4. Reading Styles:**\n\n// Inline styles only\nelement.style.color  // Only returns inline styles\n\n// All computed styles (including CSS)\nlet styles = window.getComputedStyle(element);\nstyles.color\nstyles.fontSize"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting camelCase for CSS properties:\n   element.style.background-color = 'red';  // SYNTAX ERROR\n   element.style.backgroundColor = 'red';  // CORRECT\n\n2. Forgetting units:\n   element.style.width = 200;  // WRONG - no effect\n   element.style.width = '200px';  // CORRECT\n\n3. Overusing inline styles instead of classes:\n   Bad:\n   element.style.color = 'red';\n   element.style.fontWeight = 'bold';\n   \n   Better:\n   element.classList.add('error');\n   // Define .error in CSS\n\n4. Confusing textContent, innerHTML, and innerText:\n   textContent: Safest, pure text\n   innerHTML: Can include HTML (security risk if user input!)\n   innerText: Respects CSS (slower)\n\n5. Not checking if element exists:\n   let el = document.querySelector('.missing');\n   el.textContent = 'Hi';  // ERROR if el is null!\n   \n   Always check:\n   if (el) {\n     el.textContent = 'Hi';\n   }"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.4-challenge",
              "title": "Practice Challenge",
              "description": "Create an interactive element:\n\n<div id=\"box\" class=\"normal\">Click Me!</div>\n\nWrite JavaScript that:\n1. Finds the box\n2. When clicked, toggles a 'highlighted' class\n3. Also changes the textContent to show if it's highlighted or normal\n\nCSS (already defined):\n.normal { background: gray; }\n.highlighted { background: yellow; }",
              "instructions": "Create an interactive element:\n\n<div id=\"box\" class=\"normal\">Click Me!</div>\n\nWrite JavaScript that:\n1. Finds the box\n2. When clicked, toggles a 'highlighted' class\n3. Also changes the textContent to show if it's highlighted or normal\n\nCSS (already defined):\n.normal { background: gray; }\n.highlighted { background: yellow; }",
              "starterCode": "let box = document.querySelector('#box');\n\nbox.addEventListener('click', function() {\n  // Toggle the highlighted class\n  \n  // Check if highlighted and update text\n  if (box.classList.contains('highlighted')) {\n    box.textContent = 'Highlighted!';\n  } else {\n    box.textContent = 'Click Me!';\n  }\n});",
              "solution": "let box = document.querySelector('#box');\n\nbox.addEventListener('click', function() {\n  box.classList.toggle('highlighted');\n  \n  if (box.classList.contains('highlighted')) {\n    box.textContent = 'Highlighted!';\n  } else {\n    box.textContent = 'Click Me!';\n  }\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Toggles class and updates text",
                  "expectedOutput": "Click Me!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use box.classList.toggle('highlighted') and box.classList.contains('highlighted')"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting camelCase for CSS properties:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting camelCase for CSS properties:\n   element.style.background-color = 'red';  // SYNTAX ERROR\n   element.style.backgroundColor = 'red';  // CORRECT"
                },
                {
                  "mistake": "Forgetting units:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting units:\n   element.style.width = 200;  // WRONG - no effect\n   element.style.width = '200px';  // CORRECT"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "7.5",
          "title": "Responding to User Actions (Event Listeners)",
          "moduleId": "module-07",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're a security guard at a building:\n\nYou're not actively doing anything most of the time - you're LISTENING and WAITING for specific events to happen:\n\n- **Event**: Someone presses the doorbell → **Response**: You open the door\n- **Event**: Fire alarm goes off → **Response**: You evacuate everyone\n- **Event**: Someone tries wrong password 3 times → **Response**: You lock them out\n\nEvent listeners work the same way. Your JavaScript code sits idle, LISTENING for specific events (clicks, key presses, mouse movements, etc.). When an event happens, your code RESPONDS by running a function."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Basic event listener\nlet button = document.querySelector('#myButton');\n\nbutton.addEventListener('click', function() {\n  console.log('Button was clicked!');\n});\n\n// Common events\nlet input = document.querySelector('#nameInput');\n\n// 'input' fires when user types\ninput.addEventListener('input', function(event) {\n  console.log('User typed:', event.target.value);\n});\n\n// 'change' fires when input loses focus after being changed\ninput.addEventListener('change', function(event) {\n  console.log('Input changed to:', event.target.value);\n});\n\n// 'focus' fires when element receives focus\ninput.addEventListener('focus', function() {\n  console.log('Input focused');\n});\n\n// 'blur' fires when element loses focus\ninput.addEventListener('blur', function() {\n  console.log('Input lost focus');\n});\n\n// Mouse events\nlet box = document.querySelector('.box');\n\nbox.addEventListener('mouseenter', function() {\n  console.log('Mouse entered box');\n});\n\nbox.addEventListener('mouseleave', function() {\n  console.log('Mouse left box');\n});\n\nbox.addEventListener('mousemove', function(event) {\n  console.log('Mouse position:', event.clientX, event.clientY);\n});\n\n// Keyboard events\ndocument.addEventListener('keydown', function(event) {\n  console.log('Key pressed:', event.key);\n  \n  if (event.key === 'Enter') {\n    console.log('Enter key pressed!');\n  }\n});\n\n// Form events\nlet form = document.querySelector('#myForm');\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();  // Prevent default form submission\n  console.log('Form submitted');\n  \n  // Get form data\n  let formData = new FormData(form);\n  console.log(formData.get('username'));\n});\n\n// Event object\nbutton.addEventListener('click', function(event) {\n  console.log('Event type:', event.type);  // 'click'\n  console.log('Target element:', event.target);  // The button\n  console.log('Mouse position:', event.clientX, event.clientY);\n});\n\n// Removing event listeners\nfunction handleClick() {\n  console.log('Clicked!');\n}\n\nbutton.addEventListener('click', handleClick);\nbutton.removeEventListener('click', handleClick);  // Must be same function\n\n// Multiple listeners on same event\nbutton.addEventListener('click', function() {\n  console.log('First listener');\n});\n\nbutton.addEventListener('click', function() {\n  console.log('Second listener');\n});\n// Both run when button is clicked!"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Event listeners syntax:\n\nelement.addEventListener(eventType, callbackFunction);\n│                        │          │\n│                        │          └─ Function to run when event fires\n│                        └──────────── Type of event to listen for\n└───────────────────────────────────── Element to listen on\n\n**Common Event Types:**\n\nMouse Events:\n- 'click' - Element is clicked\n- 'dblclick' - Element is double-clicked\n- 'mouseenter' - Mouse enters element\n- 'mouseleave' - Mouse leaves element\n- 'mousemove' - Mouse moves over element\n- 'mousedown' - Mouse button pressed\n- 'mouseup' - Mouse button released\n\nKeyboard Events:\n- 'keydown' - Key is pressed down\n- 'keyup' - Key is released\n- 'keypress' - Key is pressed (deprecated, use keydown)\n\nForm Events:\n- 'submit' - Form is submitted\n- 'input' - Input value changes (real-time)\n- 'change' - Input value changes (on blur)\n- 'focus' - Element receives focus\n- 'blur' - Element loses focus\n\nWindow/Document Events:\n- 'load' - Page fully loaded\n- 'DOMContentLoaded' - HTML loaded (before images)\n- 'resize' - Window resized\n- 'scroll' - Page scrolled\n\n**Event Object:**\n\nThe callback receives an event object:\n\nelement.addEventListener('click', function(event) {\n  // event contains information about the event\n});\n\nUseful properties:\n- event.type - Type of event ('click', 'keydown', etc.)\n- event.target - Element that triggered the event\n- event.currentTarget - Element the listener is attached to\n- event.key - Key that was pressed (keyboard events)\n- event.clientX, event.clientY - Mouse position\n- event.preventDefault() - Prevent default behavior\n- event.stopPropagation() - Stop event bubbling\n\n**Preventing Defaults:**\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();  // Stop form from actually submitting\n  // Handle with JavaScript instead\n});\n\nlink.addEventListener('click', function(event) {\n  event.preventDefault();  // Stop link from navigating\n  // Do something else\n});\n\n**Arrow Functions:**\n\n// Traditional function\nelement.addEventListener('click', function() {\n  console.log('Clicked');\n});\n\n// Arrow function (more modern)\nelement.addEventListener('click', () => {\n  console.log('Clicked');\n});\n\n// With event parameter\nelement.addEventListener('click', (event) => {\n  console.log(event.target);\n});"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Calling the function immediately:\n   button.addEventListener('click', myFunction());  // WRONG - runs now!\n   button.addEventListener('click', myFunction);  // CORRECT - runs on click\n\n2. Forgetting event.preventDefault() for forms:\n   form.addEventListener('submit', function(event) {\n     // Form submits and page reloads before your code runs!\n   });\n   \n   Must prevent default:\n   form.addEventListener('submit', function(event) {\n     event.preventDefault();  // Now your code can run\n   });\n\n3. Confusing input vs change:\n   'input' - Fires on every keystroke (real-time)\n   'change' - Fires when field loses focus (final value)\n\n4. Not getting input values correctly:\n   let value = input;  // WRONG - this is the element!\n   let value = input.value;  // CORRECT - this is the text\n\n5. Trying to remove anonymous function:\n   element.addEventListener('click', function() { });\n   element.removeEventListener('click', function() { });  // Doesn't work!\n   \n   Must use named function:\n   function handleClick() { }\n   element.addEventListener('click', handleClick);\n   element.removeEventListener('click', handleClick);  // Works!\n\n6. Forgetting 'this' context in arrow functions:\n   // Traditional function: 'this' is the element\n   button.addEventListener('click', function() {\n     console.log(this);  // The button\n   });\n   \n   // Arrow function: 'this' is lexical scope\n   button.addEventListener('click', () => {\n     console.log(this);  // NOT the button!\n   });"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.5-challenge",
              "title": "Practice Challenge",
              "description": "Create an interactive form validator:\n\n<form id=\"signupForm\">\n  <input type=\"text\" id=\"username\" placeholder=\"Username\">\n  <input type=\"email\" id=\"email\" placeholder=\"Email\">\n  <button type=\"submit\">Sign Up</button>\n  <p id=\"message\"></p>\n</form>\n\nWrite JavaScript that:\n1. When the form is submitted, prevent default behavior\n2. Get the username and email values\n3. If username is empty, show error message\n4. If email doesn't contain '@', show error message\n5. If both valid, show success message",
              "instructions": "Create an interactive form validator:\n\n<form id=\"signupForm\">\n  <input type=\"text\" id=\"username\" placeholder=\"Username\">\n  <input type=\"email\" id=\"email\" placeholder=\"Email\">\n  <button type=\"submit\">Sign Up</button>\n  <p id=\"message\"></p>\n</form>\n\nWrite JavaScript that:\n1. When the form is submitted, prevent default behavior\n2. Get the username and email values\n3. If username is empty, show error message\n4. If email doesn't contain '@', show error message\n5. If both valid, show success message",
              "starterCode": "let form = document.querySelector('#signupForm');\nlet message = document.querySelector('#message');\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();\n  \n  let username = document.querySelector('#username').value;\n  let email = document.querySelector('#email').value;\n  \n  // YOUR CODE HERE\n  // Check if username is empty\n  // Check if email contains '@'\n  // Show appropriate message\n});",
              "solution": "let form = document.querySelector('#signupForm');\nlet message = document.querySelector('#message');\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();\n  \n  let username = document.querySelector('#username').value;\n  let email = document.querySelector('#email').value;\n  \n  if (username === '') {\n    message.textContent = 'Username is required';\n    message.style.color = 'red';\n  } else if (!email.includes('@')) {\n    message.textContent = 'Please enter a valid email';\n    message.style.color = 'red';\n  } else {\n    message.textContent = 'Sign up successful!';\n    message.style.color = 'green';\n  }\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Validates empty username",
                  "expectedOutput": "Username required",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use if/else to check: username === '' and !email.includes('@')"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Calling the function immediately:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Calling the function immediately:\n   button.addEventListener('click', myFunction());  // WRONG - runs now!\n   button.addEventListener('click', myFunction);  // CORRECT - runs on click"
                },
                {
                  "mistake": "Forgetting event.preventDefault() for forms:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting event.preventDefault() for forms:\n   form.addEventListener('submit', function(event) {\n     // Form submits and page reloads before your code runs!\n   });\n   \n   Must prevent default:\n   form.addEventListener('submit', function(event) {\n     event.preventDefault();  // Now your code can run\n   });"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-08",
      "title": "Module 8: Asynchronous JavaScript (The 'Waiting Game')",
      "description": "Handle tasks that take time without freezing your application",
      "difficulty": "intermediate",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "8.1",
          "title": "The Restaurant Buzzer (Synchronous vs. Asynchronous)",
          "moduleId": "module-08",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine two different ways of ordering food:\n\n**Synchronous (Blocking)**: You stand at the counter. The cook makes your burger while you wait, staring at them. You can't do ANYTHING else until your burger is ready. If it takes 20 minutes, you stand there for 20 minutes. This is how most code works - one line after another, waiting for each to finish.\n\n**Asynchronous (Non-blocking)**: You order, get a buzzer, and sit down. While the kitchen makes your food, you can chat with friends, check your phone, or relax. When food is ready, the buzzer vibrates, and you go pick it up. You're not stuck waiting!\n\nJavaScript is single-threaded (one line at a time), but asynchronous code lets it START a slow task, move on to other things, then come back when the slow task is done. Perfect for network requests, file reading, or anything that takes time."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// SYNCHRONOUS (Blocking) - Everything waits\nconsole.log('Start');\nfor (let i = 0; i < 3; i++) {\n  console.log('Step ' + i);\n}\nconsole.log('End');\n// Output: Start, Step 0, Step 1, Step 2, End (in order)\n\n// ASYNCHRONOUS (Non-blocking) - Using setTimeout\nconsole.log('Start');\n\nsetTimeout(function() {\n  console.log('This runs after 2 seconds');\n}, 2000);\n\nconsole.log('End');\n// Output: Start, End, (wait 2 seconds), This runs after 2 seconds\n// Notice 'End' comes BEFORE the timeout!\n\n// Practical example: Loading data\nconsole.log('Fetching user data...');\n\n// Simulating a slow network request (async)\nsetTimeout(function() {\n  console.log('User data loaded: Alice, age 25');\n}, 1000);\n\nconsole.log('Continuing with other tasks...');\n// Output:\n// Fetching user data...\n// Continuing with other tasks...\n// (1 second later) User data loaded: Alice, age 25\n\n// Multiple async operations\nconsole.log('Cooking eggs');\n\nsetTimeout(() => console.log('Eggs done!'), 2000);\nsetTimeout(() => console.log('Toast done!'), 1000);\nsetTimeout(() => console.log('Coffee done!'), 1500);\n\nconsole.log('Started all cooking tasks');\n// Output:\n// Cooking eggs\n// Started all cooking tasks\n// (1s) Toast done!\n// (1.5s) Coffee done!\n// (2s) Eggs done!"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding sync vs async:\n\n**Synchronous Code (Default):**\n- Runs line by line\n- Each line waits for the previous to complete\n- Blocking (stops everything until done)\n\nlet a = 1;\nlet b = 2;\nlet c = a + b;  // Waits for a and b\nconsole.log(c);  // Waits for c\n\n**Asynchronous Code:**\n- Starts a task\n- Doesn't wait for it to finish\n- Continues to next line immediately\n- Comes back when task completes\n\nCommon async operations:\n- setTimeout / setInterval (timers)\n- fetch() (network requests)\n- Reading files (Node.js)\n- Database queries\n- User interactions (clicks are async events)\n\n**setTimeout Syntax:**\n\nsetTimeout(callbackFunction, delayInMilliseconds);\n\nExamples:\nsetTimeout(() => console.log('Hi'), 1000);  // After 1 second\nsetTimeout(myFunction, 500);  // After 0.5 seconds\nsetTimeout(() => {\n  console.log('Multiple');\n  console.log('Lines');\n}, 2000);  // After 2 seconds\n\n**setInterval (Repeating Timer):**\n\nsetInterval(callbackFunction, intervalInMilliseconds);\n\nlet count = 0;\nlet intervalId = setInterval(() => {\n  count++;\n  console.log('Count:', count);\n  \n  if (count === 5) {\n    clearInterval(intervalId);  // Stop the interval\n  }\n}, 1000);  // Every 1 second\n\n**Why Async Matters:**\n\n// Synchronous (BAD for web):\nlet data = fetchDataFromServer();  // Takes 3 seconds, UI freezes!\nconsole.log(data);\n\n// Asynchronous (GOOD for web):\nfetchDataFromServer((data) => {\n  console.log(data);\n});  // UI stays responsive!\n\n**The Event Loop:**\n\nJavaScript has:\n1. Call stack (current code running)\n2. Web APIs (setTimeout, fetch, etc.)\n3. Callback queue (waiting callbacks)\n4. Event loop (moves callbacks to stack when empty)\n\nThis is how async works without multiple threads!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Expecting async code to run in order:\n   setTimeout(() => console.log('A'), 1000);\n   console.log('B');\n   // Output: B, (wait), A  (not A, B!)\n\n2. Not storing interval ID to clear it:\n   setInterval(() => console.log('Hi'), 1000);\n   // Can't stop it now!\n   \n   Correct:\n   let id = setInterval(() => console.log('Hi'), 1000);\n   clearInterval(id);  // Can stop it\n\n3. Confusing milliseconds with seconds:\n   setTimeout(() => console.log('Hi'), 5);  // 5 milliseconds!\n   setTimeout(() => console.log('Hi'), 5000);  // 5 seconds\n\n4. Creating infinite intervals:\n   setInterval(() => {\n     // Runs forever!\n   }, 1000);\n   // Remember to clearInterval when done\n\n5. Trying to 'wait' for async with sync code:\n   setTimeout(() => data = fetchData(), 1000);\n   console.log(data);  // undefined! Timeout hasn't run yet\n   \n   Must use callbacks or promises (next lessons)"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "8.1-challenge",
              "title": "Practice Challenge",
              "description": "Create a countdown timer that:\n1. Starts at 3\n2. Logs the number every second\n3. Logs 'Liftoff!' after 0\n\nExpected output (over 4 seconds):\n3\n2\n1\n0\nLiftoff!",
              "instructions": "Create a countdown timer that:\n1. Starts at 3\n2. Logs the number every second\n3. Logs 'Liftoff!' after 0\n\nExpected output (over 4 seconds):\n3\n2\n1\n0\nLiftoff!",
              "starterCode": "let count = 3;\n\n// Create an interval that runs every 1000ms\nlet intervalId = setInterval(() => {\n  // YOUR CODE HERE\n  // Log count\n  // Decrease count\n  // If count < 0, log 'Liftoff!' and stop interval\n}, 1000);",
              "solution": "let count = 3;\n\nlet intervalId = setInterval(() => {\n  console.log(count);\n  count--;\n  \n  if (count < 0) {\n    console.log('Liftoff!');\n    clearInterval(intervalId);\n  }\n}, 1000);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Countdown works correctly",
                  "expectedOutput": "3\n2\n1\n0\nLiftoff!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Log count, then count--, then if (count < 0) clearInterval and log Liftoff"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Expecting async code to run in order:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Expecting async code to run in order:\n   setTimeout(() => console.log('A'), 1000);\n   console.log('B');\n   // Output: B, (wait), A  (not A, B!)"
                },
                {
                  "mistake": "Not storing interval ID to clear it:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Not storing interval ID to clear it:\n   setInterval(() => console.log('Hi'), 1000);\n   // Can't stop it now!\n   \n   Correct:\n   let id = setInterval(() => console.log('Hi'), 1000);\n   clearInterval(id);  // Can stop it"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "8.2",
          "title": "The Promise of a Future Result (Promises)",
          "moduleId": "module-08",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "You order a pizza for delivery:\n\n1. **You place the order** (create a Promise) - The restaurant promises to either deliver your pizza OR call you with a problem.\n\n2. **You wait** (Promise is 'pending') - The pizza is being made. You don't have it yet, but you have a promise.\n\n3. **Two possible outcomes**:\n   - **Fulfilled (Resolved)**: Pizza arrives! You eat it (the 'then' callback runs)\n   - **Rejected**: Restaurant calls - they're out of ingredients (the 'catch' callback runs)\n\nA Promise is JavaScript's way of saying: 'I'll get you a result eventually. Here's a guarantee (promise) that I'll let you know when it's done, whether it succeeds or fails.'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Creating a Promise\nlet myPromise = new Promise((resolve, reject) => {\n  // Simulating async operation\n  let success = true;\n  \n  setTimeout(() => {\n    if (success) {\n      resolve('Operation successful!');  // Fulfilled\n    } else {\n      reject('Operation failed!');  // Rejected\n    }\n  }, 1000);\n});\n\n// Using a Promise\nmyPromise\n  .then((result) => {\n    console.log('Success:', result);\n  })\n  .catch((error) => {\n    console.log('Error:', error);\n  });\n\n// Practical example: Fetching data\nfunction fetchUserData(userId) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId > 0) {\n        resolve({ id: userId, name: 'Alice' });\n      } else {\n        reject('Invalid user ID');\n      }\n    }, 1000);\n  });\n}\n\nfetchUserData(1)\n  .then((user) => {\n    console.log('User:', user.name);\n  })\n  .catch((error) => {\n    console.log('Error:', error);\n  });\n\n// Chaining Promises\nfetchUserData(1)\n  .then((user) => {\n    console.log('Got user:', user.name);\n    return fetchUserPosts(user.id);  // Returns another promise\n  })\n  .then((posts) => {\n    console.log('Got posts:', posts);\n  })\n  .catch((error) => {\n    console.log('Error:', error);\n  });\n\n// Promise.all - Wait for multiple promises\nlet promise1 = fetchUserData(1);\nlet promise2 = fetchUserData(2);\nlet promise3 = fetchUserData(3);\n\nPromise.all([promise1, promise2, promise3])\n  .then((results) => {\n    console.log('All users:', results);\n  })\n  .catch((error) => {\n    console.log('At least one failed:', error);\n  });\n\n// Promise.race - First one to finish\nPromise.race([promise1, promise2, promise3])\n  .then((result) => {\n    console.log('First result:', result);\n  });\n\n// Promise.withResolvers() - ES2024 new feature!\nlet { promise, resolve, reject } = Promise.withResolvers();\n\n// Can resolve/reject from anywhere\nsetTimeout(() => resolve('Done!'), 1000);\n\npromise.then(result => console.log(result));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Promise syntax:\n\n**Creating a Promise:**\n\nlet promise = new Promise((resolve, reject) => {\n                           │        │\n                           │        └─ Call when operation fails\n                           └────────── Call when operation succeeds\n  // Do async work\n  if (success) {\n    resolve(successValue);\n  } else {\n    reject(errorValue);\n  }\n});\n\n**Using a Promise:**\n\npromise\n  .then((result) => {\n    // Runs if promise resolves (success)\n    console.log(result);\n  })\n  .catch((error) => {\n    // Runs if promise rejects (failure)\n    console.log(error);\n  })\n  .finally(() => {\n    // Always runs (success or failure)\n    console.log('Done');\n  });\n\n**Promise States:**\n\n1. Pending - Initial state, not yet resolved or rejected\n2. Fulfilled - Operation completed successfully (resolve called)\n3. Rejected - Operation failed (reject called)\n\nOnce settled (fulfilled or rejected), state can't change!\n\n**Promise Chaining:**\n\nfetch('/api/user')\n  .then(response => response.json())  // Parse JSON\n  .then(user => {\n    console.log('User:', user);\n    return fetch('/api/posts/' + user.id);  // Next request\n  })\n  .then(response => response.json())\n  .then(posts => {\n    console.log('Posts:', posts);\n  })\n  .catch(error => {\n    console.log('Error anywhere in chain:', error);\n  });\n\n**Promise Utilities:**\n\n1. Promise.all([p1, p2, p3])\n   - Waits for ALL to resolve\n   - Rejects if ANY rejects\n   - Returns array of results\n\n2. Promise.race([p1, p2, p3])\n   - Returns when FIRST settles (resolve or reject)\n\n3. Promise.allSettled([p1, p2, p3])\n   - Waits for ALL to settle\n   - Never rejects\n   - Returns array of {status, value/reason}\n\n4. Promise.any([p1, p2, p3])\n   - Returns when FIRST resolves\n   - Rejects only if ALL reject\n\n5. Promise.withResolvers() - ES2024!\n   - Returns {promise, resolve, reject}\n   - Useful when you need to resolve/reject from outside\n\n**Error Handling:**\n\n// Catch errors\npromise.catch(error => console.log(error));\n\n// Or use second argument to then\npromise.then(\n  result => console.log(result),\n  error => console.log(error)\n);"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting to return a promise from a function:\n   function getData() {\n     new Promise((resolve) => { ... });  // WRONG - not returned!\n   }\n   \n   function getData() {\n     return new Promise((resolve) => { ... });  // CORRECT\n   }\n\n2. Not returning in .then() for chaining:\n   promise\n     .then(data => {\n       processData(data);  // Returns undefined!\n     })\n     .then(result => {\n       console.log(result);  // undefined\n     });\n   \n   Must return:\n   .then(data => {\n     return processData(data);\n   })\n\n3. Calling resolve/reject multiple times:\n   new Promise((resolve) => {\n     resolve('first');\n     resolve('second');  // Ignored!\n   });\n   // Only first resolve/reject counts\n\n4. Mixing callbacks and promises:\n   // Don't do this:\n   getData(function(result) {\n     // Old callback style mixed with promises\n   });\n   \n   // Use promises consistently\n\n5. Not catching errors:\n   fetch('/api/data')\n     .then(response => response.json());\n   // If error occurs, it's unhandled!\n   \n   Always add .catch():\n   fetch('/api/data')\n     .then(response => response.json())\n     .catch(error => console.log(error));"
            },
            {
              "type": "EXAMPLE",
              "title": "Promise.try() - Safe Error Handling",
              "content": "Promise.try() wraps any function and catches both sync AND async errors. This solves the problem where synchronous throws inside promise chains cause unhandled exceptions.",
              "language": "javascript",
              "code": "// BEFORE: Manual wrapping for sync errors\nfunction loadConfigOld(path) {\n  return Promise.resolve().then(() => {\n    if (!path) throw new Error('Path required');\n    return Bun.file(path).json();\n  });\n}\n\n// AFTER: Promise.try() handles sync errors elegantly\nfunction loadConfig(path) {\n  return Promise.try(() => {\n    if (!path) throw new Error('Path required');\n    return Bun.file(path).json();\n  });\n}\n\n// Usage - both sync and async errors are caught\nloadConfig(null)\n  .catch(err => console.log('Caught:', err.message));\n// Output: Caught: Path required"
            },
            {
              "type": "KEY_POINT",
              "title": "When to Use Promise.try()",
              "content": "Use `Promise.try()` when:\n\n1. **Your callback might throw synchronously** - Validation, parsing, etc.\n2. **You want consistent error handling** - All errors go to `.catch()`\n3. **Mixing sync and async code** - The callback can return a value OR a Promise\n\n```javascript\n// Works with sync returns\nPromise.try(() => 42).then(console.log); // 42\n\n// Works with async returns\nPromise.try(() => fetch('/api')).then(console.log); // Response\n\n// Works with sync throws\nPromise.try(() => { throw new Error('Oops'); }).catch(console.log); // Error: Oops\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Promise.withResolvers() - The Modern Way",
              "content": "ES2024 introduces `Promise.withResolvers()` which gives you the promise, resolve, and reject functions separately. This is cleaner than the traditional executor pattern.",
              "language": "javascript",
              "code": "// TRADITIONAL: Executor callback (still valid but verbose)\nfunction rollDiceOld() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(Math.floor(Math.random() * 6) + 1);\n    }, 1000);\n  });\n}\n\n// MODERN: Promise.withResolvers() (ES2024)\nfunction rollDice() {\n  const { promise, resolve } = Promise.withResolvers();\n  setTimeout(() => {\n    resolve(Math.floor(Math.random() * 6) + 1);\n  }, 1000);\n  return promise;\n}\n\n// Usage is identical\nrollDice().then(result => console.log('You rolled:', result));"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Traditional Promise Constructor",
              "legacy": "es2020",
              "content": "Before ES2024, you had to use the executor callback pattern. This is still valid and works everywhere, but Promise.withResolvers() is cleaner for complex cases where you need to pass resolve/reject to other functions.",
              "language": "javascript",
              "code": "// The executor pattern (pre-ES2024)\nconst promise = new Promise((resolve, reject) => {\n  // resolve and reject are only available here\n  doAsyncWork((err, result) => {\n    if (err) reject(err);\n    else resolve(result);\n  });\n});"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "8.2-challenge",
              "title": "Practice Challenge",
              "description": "Create a function that simulates a dice roll:\n\nfunction rollDice() {\n  // Returns a promise that resolves after 1 second\n  // Resolves with a random number 1-6\n}\n\nUse it like:\nrollDice()\n  .then(result => console.log('Rolled:', result));\n\nHint: Use Math.floor(Math.random() * 6) + 1 for random 1-6",
              "instructions": "Create a function that simulates a dice roll:\n\nfunction rollDice() {\n  // Returns a promise that resolves after 1 second\n  // Resolves with a random number 1-6\n}\n\nUse it like:\nrollDice()\n  .then(result => console.log('Rolled:', result));\n\nHint: Use Math.floor(Math.random() * 6) + 1 for random 1-6",
              "starterCode": "function rollDice() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      // YOUR CODE: Generate random number 1-6 and resolve with it\n    }, 1000);\n  });\n}\n\n// Test it\nrollDice()\n  .then(result => {\n    console.log('You rolled:', result);\n  });",
              "solution": "function rollDice() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      let roll = Math.floor(Math.random() * 6) + 1;\n      resolve(roll);\n    }, 1000);\n  });\n}\n\nrollDice()\n  .then(result => {\n    console.log('You rolled:', result);\n  });",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Returns a number",
                  "expectedOutput": "4",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "let roll = Math.floor(Math.random() * 6) + 1; resolve(roll);"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting to return a promise from a function:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting to return a promise from a function:\n   function getData() {\n     new Promise((resolve) => { ... });  // WRONG - not returned!\n   }\n   \n   function getData() {\n     return new Promise((resolve) => { ... });  // CORRECT\n   }"
                },
                {
                  "mistake": "Not returning in .then() for chaining:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Not returning in .then() for chaining:\n   promise\n     .then(data => {\n       processData(data);  // Returns undefined!\n     })\n     .then(result => {\n       console.log(result);  // undefined\n     });\n   \n   Must return:\n   .then(data => {\n     return processData(data);\n   })"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "8.3",
          "title": "The Modern, Clean Way (async and await)",
          "moduleId": "module-08",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Promises are like getting a tracking number for your package:\n\n**Promises (.then)**: You keep checking the tracking number and saying 'THEN when it arrives, THEN I'll open it, THEN I'll use it, THEN I'll write a review...'\n\n**async/await**: You just wait at the door for the package to arrive, open it when it comes, use it, write review - one step at a time, in order. More natural!\n\nasync/await is syntactic sugar over Promises. It makes asynchronous code LOOK and READ like synchronous code, while still being non-blocking. It's the modern, preferred way to handle async operations."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// OLD WAY: Promises with .then()\nfunction getUser() {\n  fetchUser(1)\n    .then(user => {\n      console.log('User:', user);\n      return fetchPosts(user.id);\n    })\n    .then(posts => {\n      console.log('Posts:', posts);\n    })\n    .catch(error => {\n      console.log('Error:', error);\n    });\n}\n\n// NEW WAY: async/await (same thing, cleaner!)\nasync function getUser() {\n  try {\n    let user = await fetchUser(1);\n    console.log('User:', user);\n    \n    let posts = await fetchPosts(user.id);\n    console.log('Posts:', posts);\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}\n\n// async function returns a Promise\nasync function getData() {\n  return 'Hello';  // Automatically wrapped in Promise.resolve()\n}\n\ngetData().then(result => console.log(result));  // Hello\n\n// await pauses until Promise resolves\nasync function example() {\n  console.log('Start');\n  \n  let result = await someAsyncOperation();  // Waits here\n  console.log('Result:', result);  // Runs after promise resolves\n  \n  console.log('End');\n}\n\n// Multiple awaits in sequence\nasync function sequential() {\n  let user = await fetchUser(1);  // Wait for this\n  let posts = await fetchPosts(user.id);  // Then wait for this\n  let comments = await fetchComments(posts[0].id);  // Then wait for this\n  return { user, posts, comments };\n}\n\n// Multiple awaits in parallel (faster!)\nasync function parallel() {\n  // Start all at once\n  let userPromise = fetchUser(1);\n  let postsPromise = fetchPosts(1);\n  let commentsPromise = fetchComments(1);\n  \n  // Wait for all to finish\n  let user = await userPromise;\n  let posts = await postsPromise;\n  let comments = await commentsPromise;\n  \n  return { user, posts, comments };\n}\n\n// Or use Promise.all\nasync function parallelAll() {\n  let [user, posts, comments] = await Promise.all([\n    fetchUser(1),\n    fetchPosts(1),\n    fetchComments(1)\n  ]);\n  return { user, posts, comments };\n}\n\n// Error handling\nasync function withErrorHandling() {\n  try {\n    let data = await riskyOperation();\n    return data;\n  } catch (error) {\n    console.log('Caught error:', error);\n    return null;\n  }\n}\n\n// Can only use await inside async function\n// This is WRONG:\nfunction normal() {\n  let result = await fetchData();  // ERROR!\n}\n\n// This is CORRECT:\nasync function async() {\n  let result = await fetchData();  // Works!\n}\n\n// Top-level await (ES2022 - in modules only)\nawait fetchData();  // Now works at module top level!"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "async/await syntax:\n\n**async function:**\n\nasync function functionName() {\n│     │\n│     └─ Makes function asynchronous\n└─────── async keyword required\n  // Can use 'await' inside\n}\n\n// async function automatically returns a Promise\nasync function getName() {\n  return 'Alice';  // Becomes Promise.resolve('Alice')\n}\n\n// These are equivalent:\nasync function a() { return 'Hi'; }\nfunction b() { return Promise.resolve('Hi'); }\n\n**await keyword:**\n\nlet result = await promise;\n│            │     │\n│            │     └─ A Promise\n│            └─────── await keyword (pauses until resolved)\n└──────────────────── Result of the promise\n\nRules for await:\n1. Can ONLY be used inside async functions (or module top-level)\n2. Pauses function execution until Promise resolves\n3. Returns the resolved value\n4. Throws if Promise rejects (use try/catch)\n\n**Error Handling:**\n\n// Promises:\npromise\n  .then(result => { })\n  .catch(error => { });\n\n// async/await:\ntry {\n  let result = await promise;\n} catch (error) {\n  // Handle error\n}\n\n**Sequential vs Parallel:**\n\n// Sequential (one after another - SLOW)\nasync function sequential() {\n  let a = await fetchA();  // Wait 1 second\n  let b = await fetchB();  // Wait 1 second\n  // Total: 2 seconds\n}\n\n// Parallel (at same time - FAST)\nasync function parallel() {\n  let [a, b] = await Promise.all([\n    fetchA(),  // Both start at same time\n    fetchB()\n  ]);\n  // Total: 1 second (whichever is slower)\n}\n\n**Common Patterns:**\n\n1. Simple fetch:\n   async function getData() {\n     let response = await fetch('/api/data');\n     let data = await response.json();\n     return data;\n   }\n\n2. With error handling:\n   async function getData() {\n     try {\n       let response = await fetch('/api/data');\n       if (!response.ok) throw new Error('Failed');\n       return await response.json();\n     } catch (error) {\n       console.log('Error:', error);\n       return null;\n     }\n   }\n\n3. Multiple parallel requests:\n   async function getAll() {\n     let [users, posts, comments] = await Promise.all([\n       fetch('/api/users').then(r => r.json()),\n       fetch('/api/posts').then(r => r.json()),\n       fetch('/api/comments').then(r => r.json())\n     ]);\n     return { users, posts, comments };\n   }"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting 'async' keyword:\n   function getData() {\n     let result = await fetch();  // ERROR!\n   }\n   \n   Must be:\n   async function getData() {\n     let result = await fetch();\n   }\n\n2. Not awaiting Promises:\n   async function getData() {\n     let data = fetchData();  // data is a Promise!\n     console.log(data.name);  // undefined!\n   }\n   \n   Must await:\n   async function getData() {\n     let data = await fetchData();\n     console.log(data.name);  // Works!\n   }\n\n3. Sequential when could be parallel:\n   // SLOW (3 seconds total):\n   async function slow() {\n     let a = await fetchA();  // 1s\n     let b = await fetchB();  // 1s\n     let c = await fetchC();  // 1s\n   }\n   \n   // FAST (1 second total):\n   async function fast() {\n     let [a, b, c] = await Promise.all([\n       fetchA(),\n       fetchB(),\n       fetchC()\n     ]);  // All at once!\n   }\n\n4. Not handling errors:\n   async function getData() {\n     let data = await fetch('/api/data');  // What if it fails?\n   }\n   \n   Always try/catch:\n   async function getData() {\n     try {\n       let data = await fetch('/api/data');\n     } catch (error) {\n       console.log('Error:', error);\n     }\n   }\n\n5. Mixing async/await with .then():\n   // Pick one style, don't mix:\n   async function mixed() {\n     let data = await fetchData();\n     data.then(result => { });  // Confusing!\n   }\n   \n   // Use async/await consistently:\n   async function clean() {\n     let data = await fetchData();\n     let result = await processData(data);\n   }"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "8.3-challenge",
              "title": "Practice Challenge",
              "description": "Convert this Promise code to async/await:\n\nfunction loadUserData() {\n  return fetchUser(1)\n    .then(user => {\n      console.log('User:', user.name);\n      return fetchPosts(user.id);\n    })\n    .then(posts => {\n      console.log('Posts:', posts.length);\n      return posts;\n    })\n    .catch(error => {\n      console.log('Error:', error);\n    });\n}\n\nRewrite as async/await with try/catch.",
              "instructions": "Convert this Promise code to async/await:\n\nfunction loadUserData() {\n  return fetchUser(1)\n    .then(user => {\n      console.log('User:', user.name);\n      return fetchPosts(user.id);\n    })\n    .then(posts => {\n      console.log('Posts:', posts.length);\n      return posts;\n    })\n    .catch(error => {\n      console.log('Error:', error);\n    });\n}\n\nRewrite as async/await with try/catch.",
              "starterCode": "async function loadUserData() {\n  // YOUR CODE HERE using async/await\n}",
              "solution": "async function loadUserData() {\n  try {\n    let user = await fetchUser(1);\n    console.log('User:', user.name);\n    \n    let posts = await fetchPosts(user.id);\n    console.log('Posts:', posts.length);\n    \n    return posts;\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays the user name from fetchUser",
                  "expectedOutput": "User:",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Displays the posts count from fetchPosts",
                  "expectedOutput": "Posts:",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Uses try/catch for error handling",
                  "expectedOutput": "Error:",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "async function with try/catch, await fetchUser, await fetchPosts"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting 'async' keyword:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting 'async' keyword:\n   function getData() {\n     let result = await fetch();  // ERROR!\n   }\n   \n   Must be:\n   async function getData() {\n     let result = await fetch();\n   }"
                },
                {
                  "mistake": "Not awaiting Promises:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Not awaiting Promises:\n   async function getData() {\n     let data = fetchData();  // data is a Promise!\n     console.log(data.name);  // undefined!\n   }\n   \n   Must await:\n   async function getData() {\n     let data = await fetchData();\n     console.log(data.name);  // Works!\n   }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "8.4",
          "title": "Ordering from the Menu (Using fetch() to Get API Data)",
          "moduleId": "module-08",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Using an API is like ordering from a restaurant:\n\n1. **You look at the menu** (API documentation) - What dishes (endpoints) are available?\n2. **You place an order** (fetch request) - 'I'll have the user data for ID 123, please'\n3. **Kitchen prepares it** (server processes) - Takes time, you wait\n4. **Server brings your food** (response) - Here's your data!\n5. **You eat it** (use the data) - Display on your webpage\n\nAPIs (Application Programming Interfaces) are how websites talk to servers. fetch() is JavaScript's built-in way to request data from APIs. It returns a Promise, so we use async/await!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Basic fetch - GET request\nasync function getUsers() {\n  try {\n    let response = await fetch('https://jsonplaceholder.typicode.com/users');\n    \n    // Check if request was successful\n    if (!response.ok) {\n      throw new Error('Request failed: ' + response.status);\n    }\n    \n    // Parse JSON response\n    let users = await response.json();\n    console.log(users);\n    \n    return users;\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}\n\n// Fetch with options - POST request\nasync function createUser(userData) {\n  try {\n    let response = await fetch('https://api.example.com/users', {\n      method: 'POST',  // HTTP method\n      headers: {\n        'Content-Type': 'application/json'  // Sending JSON\n      },\n      body: JSON.stringify(userData)  // Convert object to JSON string\n    });\n    \n    let newUser = await response.json();\n    console.log('Created:', newUser);\n    return newUser;\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}\n\n// Example: Create user\ncreateUser({\n  name: 'Alice',\n  email: 'alice@example.com',\n  age: 25\n});\n\n// UPDATE - PUT/PATCH request\nasync function updateUser(userId, updates) {\n  let response = await fetch(`https://api.example.com/users/${userId}`, {\n    method: 'PATCH',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(updates)\n  });\n  \n  return await response.json();\n}\n\n// DELETE request\nasync function deleteUser(userId) {\n  let response = await fetch(`https://api.example.com/users/${userId}`, {\n    method: 'DELETE'\n  });\n  \n  if (response.ok) {\n    console.log('User deleted');\n  }\n}\n\n// Practical example: Display users on page\nasync function displayUsers() {\n  try {\n    let response = await fetch('https://jsonplaceholder.typicode.com/users');\n    let users = await response.json();\n    \n    let userList = document.querySelector('#userList');\n    \n    users.forEach(user => {\n      let li = document.createElement('li');\n      li.textContent = user.name;\n      userList.appendChild(li);\n    });\n  } catch (error) {\n    console.log('Failed to load users:', error);\n  }\n}\n\n// With loading state\nasync function fetchWithLoading() {\n  let loadingEl = document.querySelector('#loading');\n  let contentEl = document.querySelector('#content');\n  \n  try {\n    loadingEl.style.display = 'block';  // Show loading\n    \n    let response = await fetch('/api/data');\n    let data = await response.json();\n    \n    contentEl.textContent = JSON.stringify(data);\n  } catch (error) {\n    contentEl.textContent = 'Error loading data';\n  } finally {\n    loadingEl.style.display = 'none';  // Hide loading\n  }\n}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "fetch() syntax:\n\n**Basic GET request:**\n\nlet response = await fetch(url);\nlet data = await response.json();\n\n**With options:**\n\nlet response = await fetch(url, {\n  method: 'POST',  // GET, POST, PUT, PATCH, DELETE\n  headers: {       // Request headers\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer token123'\n  },\n  body: JSON.stringify(data)  // Request body (POST/PUT/PATCH)\n});\n\n**Response object properties:**\n\nresponse.ok          // true if status 200-299\nresponse.status      // HTTP status code (200, 404, 500, etc.)\nresponse.statusText  // Status message ('OK', 'Not Found', etc.)\nresponse.headers     // Response headers\nresponse.json()      // Parse as JSON (returns Promise)\nresponse.text()      // Get as text (returns Promise)\nresponse.blob()      // Get as binary (for images, files)\n\n**HTTP Methods (CRUD):**\n\nGET    - Read data (default)\nPOST   - Create new resource\nPUT    - Replace entire resource\nPATCH  - Update part of resource\nDELETE - Delete resource\n\n**Complete pattern:**\n\nasync function apiCall() {\n  try {\n    // 1. Make request\n    let response = await fetch(url, options);\n    \n    // 2. Check if successful\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    // 3. Parse response\n    let data = await response.json();\n    \n    // 4. Use data\n    return data;\n    \n  } catch (error) {\n    // 5. Handle errors\n    console.error('Fetch error:', error);\n    throw error;  // Re-throw or handle\n  }\n}\n\n**Common Headers:**\n\n'Content-Type': 'application/json'  // Sending JSON\n'Authorization': 'Bearer token'      // Authentication\n'Accept': 'application/json'         // Expecting JSON\n\n**Sending Data:**\n\n// Object to JSON string\nlet user = { name: 'Alice', age: 25 };\nlet jsonString = JSON.stringify(user);\n\n// Send in fetch\nbody: JSON.stringify(user)\n\n// Parsing response\nlet data = await response.json();  // JSON string to object\n\n**Error Handling:**\n\n// Network errors (no connection)\ntry {\n  let response = await fetch(url);\n} catch (error) {\n  console.log('Network error:', error);\n}\n\n// HTTP errors (404, 500, etc.)\nif (!response.ok) {\n  throw new Error('HTTP ' + response.status);\n}\n\n// JSON parsing errors\ntry {\n  let data = await response.json();\n} catch (error) {\n  console.log('Invalid JSON:', error);\n}"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Not awaiting response.json():\n   let response = await fetch(url);\n   let data = response.json();  // WRONG - data is a Promise!\n   \n   Must await:\n   let data = await response.json();\n\n2. Forgetting to check response.ok:\n   let response = await fetch(url);\n   let data = await response.json();  // Might fail!\n   \n   Always check:\n   if (!response.ok) {\n     throw new Error('HTTP error');\n   }\n\n3. Not stringifying request body:\n   fetch(url, {\n     body: {name: 'Alice'}  // WRONG - object!\n   });\n   \n   Must stringify:\n   fetch(url, {\n     body: JSON.stringify({name: 'Alice'})\n   });\n\n4. CORS errors (Cross-Origin Request Blocked):\n   // Can't fetch from different domain without server permission\n   fetch('https://other-site.com/api')  // Might be blocked\n   // Server must send CORS headers to allow\n\n5. Forgetting Content-Type header:\n   fetch(url, {\n     method: 'POST',\n     body: JSON.stringify(data)  // Server might not parse it!\n   });\n   \n   Need header:\n   fetch(url, {\n     method: 'POST',\n     headers: {\n       'Content-Type': 'application/json'\n     },\n     body: JSON.stringify(data)\n   });\n\n6. Not handling network errors:\n   // If internet is down, fetch throws\n   try {\n     await fetch(url);\n   } catch (error) {\n     // Handle network error\n   }"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "8.4-challenge",
              "title": "Practice Challenge",
              "description": "Create a function that:\n1. Fetches a random user from: https://randomuser.me/api/\n2. Extracts the name (results[0].name.first)\n3. Returns the name\n4. Handles errors appropriately\n\nHint: The API returns { results: [{name: {first: 'John', last: 'Doe'}}] }",
              "instructions": "Create a function that:\n1. Fetches a random user from: https://randomuser.me/api/\n2. Extracts the name (results[0].name.first)\n3. Returns the name\n4. Handles errors appropriately\n\nHint: The API returns { results: [{name: {first: 'John', last: 'Doe'}}] }",
              "starterCode": "async function getRandomUser() {\n  try {\n    // YOUR CODE HERE\n    // 1. fetch from URL\n    // 2. Check response.ok\n    // 3. Parse JSON\n    // 4. Extract and return name\n  } catch (error) {\n    console.log('Error:', error);\n    return null;\n  }\n}\n\n// Test it\ngetRandomUser().then(name => console.log('Random user:', name));",
              "solution": "async function getRandomUser() {\n  try {\n    let response = await fetch('https://randomuser.me/api/');\n    \n    if (!response.ok) {\n      throw new Error('Request failed');\n    }\n    \n    let data = await response.json();\n    let firstName = data.results[0].name.first;\n    \n    return firstName;\n  } catch (error) {\n    console.log('Error:', error);\n    return null;\n  }\n}\n\ngetRandomUser().then(name => console.log('Random user:', name));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Fetches and parses data",
                  "expectedOutput": "John",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "let response = await fetch(url); let data = await response.json(); return data.results[0].name.first;"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Not awaiting response.json():",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Not awaiting response.json():\n   let response = await fetch(url);\n   let data = response.json();  // WRONG - data is a Promise!\n   \n   Must await:\n   let data = await response.json();"
                },
                {
                  "mistake": "Forgetting to check response.ok:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting to check response.ok:\n   let response = await fetch(url);\n   let data = await response.json();  // Might fail!\n   \n   Always check:\n   if (!response.ok) {\n     throw new Error('HTTP error');\n   }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-09",
      "title": "Module 9: Introducing TypeScript",
      "description": "Learn why TypeScript exists and how it makes your code safer and more predictable through type checking",
      "difficulty": "intermediate",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "9.1",
          "title": "Why TypeScript? (The LEGO Instructions Analogy)",
          "moduleId": "module-09",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine building a complex LEGO set without instructions versus with a detailed manual.\n\nWithout instructions (plain JavaScript):\n- You might try to put the wrong pieces together\n- You won't know if you're missing pieces until the end\n- You can build it any way you want (freedom but risky)\n- Mistakes are discovered when the model doesn't work\n\nWith instructions (TypeScript):\n- The manual tells you exactly which pieces go where\n- You know immediately if you're using the wrong piece\n- You still have freedom within the design\n- Mistakes are caught BEFORE you finish building\n\nTypeScript is like having LEGO instructions for your code. It doesn't stop you from building creative things—it just helps you catch mistakes earlier!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// JavaScript: No type checking (risky)\nfunction addNumbers(a, b) {\n  return a + b;\n}\n\nconsole.log(addNumbers(5, 3));        // 8 ✓\nconsole.log(addNumbers('5', '3'));    // '53' (string concatenation - oops!)\nconsole.log(addNumbers(5, 'hello')); // '5hello' (probably not what you wanted)\n\n// TypeScript: Type checking (safer)\nfunction addNumbersTyped(a: number, b: number): number {\n  return a + b;\n}\n\nconsole.log(addNumbersTyped(5, 3));        // 8 ✓\n// console.log(addNumbersTyped('5', '3'));    // ERROR: Type 'string' is not assignable to type 'number'\n// console.log(addNumbersTyped(5, 'hello')); // ERROR: Argument of type 'string' is not assignable to parameter of type 'number'\n\n// TypeScript catches mistakes BEFORE you run the code!"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down the TypeScript syntax:\n\n1. **Parameter Types**: `a: number`\n   - The colon `:` means \"this variable should be\"\n   - `number` is the type we're expecting\n   - Think of it as a label on a LEGO piece\n\n2. **Return Type**: `: number` after the parentheses\n   - Tells TypeScript what type of value the function returns\n   - Optional but recommended for clarity\n\n3. **Type Checking**: TypeScript analyzes your code\n   - Happens BEFORE you run the code (compile-time)\n   - Catches type mismatches and shows red squiggly lines in your editor\n   - Your code won't compile if types don't match\n\n4. **Benefits**:\n   - Catch bugs early (before runtime)\n   - Better autocomplete in your editor\n   - Self-documenting code (types show intent)\n   - Safer refactoring (TypeScript tells you what breaks)"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes when starting with TypeScript:\n\n1. **Forgetting the colon**: `width number` won't work - you need `width: number`\n2. **Using the wrong type**: `width: string` when you mean numbers\n3. **Thinking TypeScript runs in the browser**: TypeScript must be compiled to JavaScript first\n4. **Over-typing everything**: Start simple, add types gradually\n5. **Confusing TypeScript with JavaScript**: TypeScript is a superset - all valid JavaScript is valid TypeScript, but not all TypeScript features work in plain JavaScript\n\nRemember: TypeScript is JavaScript with type safety training wheels. The training wheels help you learn to avoid crashes!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "9.1-challenge",
              "title": "Practice Challenge",
              "description": "Create a TypeScript function called `calculateArea` that:\n1. Takes two parameters: `width` and `height` (both should be numbers)\n2. Returns the area (width * height)\n3. Add type annotations to ensure only numbers can be passed\n\nTest your function with: calculateArea(10, 5)",
              "instructions": "Create a TypeScript function called `calculateArea` that:\n1. Takes two parameters: `width` and `height` (both should be numbers)\n2. Returns the area (width * height)\n3. Add type annotations to ensure only numbers can be passed\n\nTest your function with: calculateArea(10, 5)",
              "starterCode": "// Write your calculateArea function here\nfunction calculateArea(width, height) {\n  return width * height;\n}\n\nconsole.log(calculateArea(10, 5));",
              "solution": "function calculateArea(width: number, height: number): number {\n  return width * height;\n}\n\nconsole.log(calculateArea(10, 5));  // 50\nconsole.log(calculateArea(7.5, 4)); // 30",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should calculate area correctly",
                  "expectedOutput": "50",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should work with decimal numbers",
                  "expectedOutput": "30",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Add `: number` after each parameter name, and `: number` after the closing parenthesis to specify the return type."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes when starting with TypeScript:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes when starting with TypeScript:"
                },
                {
                  "mistake": "**Forgetting the colon**: `width number` won't work - you need `width: number`",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting the colon**: `width number` won't work - you need `width: number`"
                },
                {
                  "mistake": "**Using the wrong type**: `width: string` when you mean numbers",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Using the wrong type**: `width: string` when you mean numbers"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "9.2",
          "title": "Your First Types (The Label Maker Analogy)",
          "moduleId": "module-09",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine organizing a kitchen with a label maker:\n\nWithout labels (JavaScript):\n- You can put anything in any container\n- Sugar in the salt jar? Sure!\n- Flour in the coffee can? Why not!\n- You discover mistakes when you taste your food\n\nWith labels (TypeScript):\n- Each container has a clear label\n- You know immediately if you're putting the wrong thing in\n- The label maker prevents you from mislabeling\n- Mistakes are caught BEFORE cooking\n\nTypeScript's basic types are like labels for your variables. They tell you (and the computer) what kind of data should go in each container."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// TypeScript 5.7 Basic Types (2024-2025)\n\n// 1. STRING - Text data\nlet playerName: string = 'Alice';\nlet greeting: string = \"Hello, world!\";\nlet message: string = `Welcome, ${playerName}!`; // Template literal\n\nconsole.log(message); // 'Welcome, Alice!'\n\n// 2. NUMBER - Numeric data (integers and decimals)\nlet score: number = 100;\nlet health: number = 95.5;\nlet temperature: number = -5;\n\nconsole.log('Score:', score); // 100\n\n// 3. BOOLEAN - True or false\nlet isGameOver: boolean = false;\nlet hasWon: boolean = true;\nlet isLoggedIn: boolean = score > 50;\n\nconsole.log('Game over?', isGameOver); // false\n\n// 4. ARRAYS - Lists of the same type\nlet scores: number[] = [100, 95, 87, 92];\nlet names: string[] = ['Alice', 'Bob', 'Charlie'];\nlet flags: boolean[] = [true, false, true];\n\nconsole.log('First score:', scores[0]);   // 100\nconsole.log('All names:', names);         // ['Alice', 'Bob', 'Charlie']\n\n// Alternative array syntax (both work the same)\nlet moreScores: Array<number> = [88, 92, 76];\n\n// 5. TYPE INFERENCE - TypeScript guesses the type\nlet autoString = 'TypeScript is smart!'; // TypeScript knows this is a string\nlet autoNumber = 42;                      // TypeScript knows this is a number\nlet autoBool = true;                      // TypeScript knows this is a boolean\n\n// autoString = 123; // ERROR: Can't assign number to string variable\n\n// 6. ANY - Escape hatch (use sparingly!)\nlet anything: any = 'I can be anything';\nanything = 42;        // OK\nanything = true;      // OK\nanything = [1, 2, 3]; // OK\n// Using 'any' turns off type checking - avoid it when possible!\n\nconsole.log('Anything:', anything);"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down TypeScript's basic types:\n\n1. **String Type**: `let name: string = 'Alice'`\n   - For text data\n   - Use single quotes, double quotes, or backticks\n   - Can't assign numbers or booleans to string variables\n\n2. **Number Type**: `let age: number = 25`\n   - For all numeric data (integers and decimals)\n   - JavaScript/TypeScript doesn't distinguish between int and float\n   - Can't assign strings or booleans to number variables\n\n3. **Boolean Type**: `let isActive: boolean = true`\n   - Only two values: `true` or `false`\n   - Used for yes/no, on/off logic\n   - Can't assign strings or numbers (even 0 and 1)\n\n4. **Array Types**: `let numbers: number[] = [1, 2, 3]`\n   - Square brackets `[]` after the type\n   - All elements must be the same type\n   - Alternative syntax: `Array<number>`\n\n5. **Type Inference**: TypeScript is smart!\n   - If you assign a value immediately, TypeScript guesses the type\n   - `let x = 5` → TypeScript knows x is a number\n   - Still type-safe, just less typing!\n\n6. **The 'any' Type**: Last resort!\n   - Turns off type checking for that variable\n   - Defeats the purpose of TypeScript\n   - Use only when absolutely necessary (like external APIs)"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common beginner mistakes:\n\n1. **Mixing up type names**: `String` vs `string`\n   - Use lowercase: `string`, `number`, `boolean`\n   - Uppercase versions (String, Number, Boolean) are JavaScript wrapper objects - avoid them!\n\n2. **Forgetting array brackets**: `let nums: number` vs `let nums: number[]`\n   - `number` is a single number\n   - `number[]` is an array of numbers\n\n3. **Type mismatch errors**: `let age: number = '25'`\n   - '25' is a string, not a number\n   - Remove quotes: `let age: number = 25`\n\n4. **Overusing 'any'**: Using `any` everywhere defeats TypeScript's purpose\n   - Only use 'any' as a last resort\n   - Better to learn the correct type\n\n5. **Type inference confusion**: \"Do I always need type annotations?\"\n   - No! If you assign immediately, TypeScript infers the type\n   - `let x = 5` is the same as `let x: number = 5`\n   - Explicit types are good for function parameters and return values"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "9.2-challenge",
              "title": "Practice Challenge",
              "description": "Create variables with proper TypeScript types:\n1. A string variable `username` with your name\n2. A number variable `age` with your age\n3. A boolean variable `isStudent` set to true\n4. An array of numbers called `grades` with at least 3 grade values\n5. Calculate and log the average grade\n\nLog all variables to see their values.",
              "instructions": "Create variables with proper TypeScript types:\n1. A string variable `username` with your name\n2. A number variable `age` with your age\n3. A boolean variable `isStudent` set to true\n4. An array of numbers called `grades` with at least 3 grade values\n5. Calculate and log the average grade\n\nLog all variables to see their values.",
              "starterCode": "// Add type annotations to these variables\nlet username = 'YourName';\nlet age = 0;\nlet isStudent = true;\nlet grades = [85, 92, 78];\n\n// Calculate average\nlet sum = 0;\nfor (let grade of grades) {\n  sum = sum + grade;\n}\nlet average = sum / grades.length;\n\nconsole.log('Username:', username);\nconsole.log('Age:', age);\nconsole.log('Student?', isStudent);\nconsole.log('Grades:', grades);\nconsole.log('Average:', average);",
              "solution": "// Properly typed variables\nlet username: string = 'Alice';\nlet age: number = 20;\nlet isStudent: boolean = true;\nlet grades: number[] = [85, 92, 78];\n\n// Calculate average\nlet sum: number = 0;\nfor (let grade of grades) {\n  sum = sum + grade;\n}\nlet average: number = sum / grades.length;\n\nconsole.log('Username:', username);  // Alice\nconsole.log('Age:', age);            // 20\nconsole.log('Student?', isStudent);  // true\nconsole.log('Grades:', grades);      // [85, 92, 78]\nconsole.log('Average:', average);    // 85",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should create typed variables",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should calculate average correctly",
                  "expectedOutput": "85",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Add `: string`, `: number`, `: boolean`, and `: number[]` after each variable name."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common beginner mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common beginner mistakes:"
                },
                {
                  "mistake": "**Mixing up type names**: `String` vs `string`",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Mixing up type names**: `String` vs `string`\n   - Use lowercase: `string`, `number`, `boolean`\n   - Uppercase versions (String, Number, Boolean) are JavaScript wrapper objects - avoid them!"
                },
                {
                  "mistake": "**Forgetting array brackets**: `let nums: number` vs `let nums: number[]`",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting array brackets**: `let nums: number` vs `let nums: number[]`\n   - `number` is a single number\n   - `number[]` is an array of numbers"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "9.3",
          "title": "Creating Custom Blueprints (Interfaces and Types)",
          "moduleId": "module-09",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're running a car dealership:\n\nWithout blueprints (plain JavaScript):\n- Every car is just an object with random properties\n- One car has 'color', another has 'colour'\n- No one knows what properties a car should have\n- Lots of inconsistency and confusion\n\nWith blueprints (TypeScript Interfaces):\n- You create a 'Car Blueprint' that says every car must have:\n  * make (string)\n  * model (string)\n  * year (number)\n  * color (string)\n- Now every car follows the same structure\n- If someone forgets a property, the blueprint catches it\n- Everyone knows exactly what a car object should look like\n\nInterfaces are blueprints for objects. They define the exact shape your data should have."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// TypeScript 5.7 Interfaces and Type Aliases (2024-2025)\n\n// INTERFACE - Blueprint for an object\ninterface User {\n  id: number;\n  username: string;\n  email: string;\n  isActive: boolean;\n}\n\n// Using the interface\nlet alice: User = {\n  id: 1,\n  username: 'alice',\n  email: 'alice@example.com',\n  isActive: true\n};\n\nconsole.log('User:', alice.username); // 'alice'\n\n// This will cause an error (missing properties):\n// let bob: User = {\n//   id: 2,\n//   username: 'bob'\n//   // ERROR: Missing email and isActive!\n// };\n\n// OPTIONAL PROPERTIES - Sometimes a property might not exist\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  description?: string;  // ? means optional\n  inStock?: boolean;\n}\n\nlet laptop: Product = {\n  id: 101,\n  name: 'Gaming Laptop',\n  price: 1299.99\n  // description and inStock are optional - no error!\n};\n\nlet phone: Product = {\n  id: 102,\n  name: 'Smartphone',\n  price: 799.99,\n  description: 'Latest model with amazing camera',\n  inStock: true\n};\n\nconsole.log('Laptop:', laptop.name);      // 'Gaming Laptop'\nconsole.log('Phone stock:', phone.inStock); // true\n\n// TYPE ALIASES - Alternative way to create custom types\ntype Point = {\n  x: number;\n  y: number;\n};\n\nlet origin: Point = { x: 0, y: 0 };\nlet cursor: Point = { x: 150, y: 200 };\n\nconsole.log('Cursor position:', cursor.x, cursor.y); // 150 200\n\n// UNION TYPES - A value can be one of several types\ntype Status = 'pending' | 'approved' | 'rejected';\n\nlet orderStatus: Status = 'pending';\nconsole.log('Order status:', orderStatus); // 'pending'\n\norderStatus = 'approved';  // OK\n// orderStatus = 'cancelled'; // ERROR: Not one of the allowed values!\n\n// INTERFACES WITH METHODS - Objects can have functions\ninterface Calculator {\n  add(a: number, b: number): number;\n  subtract(a: number, b: number): number;\n}\n\nlet calc: Calculator = {\n  add(a, b) {\n    return a + b;\n  },\n  subtract(a, b) {\n    return a - b;\n  }\n};\n\nconsole.log('5 + 3 =', calc.add(5, 3));      // 8\nconsole.log('10 - 4 =', calc.subtract(10, 4)); // 6"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down custom types in TypeScript:\n\n1. **Interface Definition**: `interface User { ... }`\n   - Starts with the `interface` keyword\n   - Name should be PascalCase (capitalized)\n   - Properties inside curly braces\n   - Each property has a type\n\n2. **Using an Interface**: `let user: User = { ... }`\n   - Use the interface name as a type annotation\n   - Object must have ALL required properties\n   - Properties must match the specified types\n\n3. **Optional Properties**: `description?: string`\n   - Question mark `?` after property name\n   - Means this property might not exist\n   - Still type-safe when it does exist\n\n4. **Type Aliases**: `type Point = { x: number; y: number }`\n   - Alternative to interfaces\n   - Use the `type` keyword\n   - Can create complex types\n\n5. **Union Types**: `type Status = 'pending' | 'approved' | 'rejected'`\n   - Pipe `|` means \"OR\"\n   - Value must be one of the listed options\n   - Great for status codes, modes, etc.\n\n6. **Method Signatures**: `add(a: number, b: number): number`\n   - Functions inside interfaces\n   - Parameters have types\n   - Return type after the closing parenthesis\n\nWhen to use Interface vs Type:\n- Use `interface` for object shapes (most common)\n- Use `type` for unions, primitives, or complex combinations\n- Both work for objects, choose based on preference"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes with interfaces:\n\n1. **Forgetting required properties**:\n   ```typescript\n   let user: User = { id: 1 }; // ERROR: Missing username, email, isActive\n   ```\n   Solution: Include ALL required properties\n\n2. **Wrong property names**:\n   ```typescript\n   let user: User = { \n     id: 1, \n     userName: 'alice' // ERROR: Should be 'username' not 'userName'\n   };\n   ```\n   Solution: Match property names exactly (case-sensitive!)\n\n3. **Extra properties**:\n   ```typescript\n   let user: User = {\n     id: 1,\n     username: 'alice',\n     email: 'alice@example.com',\n     isActive: true,\n     age: 25 // ERROR: 'age' doesn't exist in User interface\n   };\n   ```\n   Solution: Only include properties defined in the interface\n\n4. **Confusing `?` placement**: `string?` is wrong, `property?: string` is correct\n\n5. **Interface vs Type confusion**:\n   - Both can define object shapes\n   - Interfaces can be extended and merged\n   - Types can do unions and complex types\n   - For simple object shapes, use either one - they're interchangeable!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "9.3-challenge",
              "title": "Practice Challenge",
              "description": "Create a TypeScript interface called `Book` with the following properties:\n1. `title` (string, required)\n2. `author` (string, required)\n3. `pages` (number, required)\n4. `isbn` (string, optional)\n5. `isRead` (boolean, required)\n\nThen create two book objects using this interface:\n- A book you've read (with all properties including isbn)\n- A book you haven't read yet (without isbn)\n\nLog both books to verify they work.",
              "instructions": "Create a TypeScript interface called `Book` with the following properties:\n1. `title` (string, required)\n2. `author` (string, required)\n3. `pages` (number, required)\n4. `isbn` (string, optional)\n5. `isRead` (boolean, required)\n\nThen create two book objects using this interface:\n- A book you've read (with all properties including isbn)\n- A book you haven't read yet (without isbn)\n\nLog both books to verify they work.",
              "starterCode": "// Define your Book interface here\ninterface Book {\n  // Add properties here\n}\n\n// Create two book objects\nlet book1: Book = {\n  title: 'The Great Gatsby',\n  author: 'F. Scott Fitzgerald',\n  pages: 180,\n  isbn: '978-0743273565',\n  isRead: true\n};\n\nlet book2: Book = {\n  title: '1984',\n  author: 'George Orwell',\n  pages: 328,\n  isRead: false\n};\n\nconsole.log('Book 1:', book1.title);\nconsole.log('Book 2:', book2.title);",
              "solution": "// Book interface with optional isbn\ninterface Book {\n  title: string;\n  author: string;\n  pages: number;\n  isbn?: string;  // Optional property\n  isRead: boolean;\n}\n\n// Book with all properties\nlet book1: Book = {\n  title: 'The Great Gatsby',\n  author: 'F. Scott Fitzgerald',\n  pages: 180,\n  isbn: '978-0743273565',\n  isRead: true\n};\n\n// Book without optional isbn\nlet book2: Book = {\n  title: '1984',\n  author: 'George Orwell',\n  pages: 328,\n  isRead: false\n};\n\nconsole.log('Book 1:', book1.title);  // 'The Great Gatsby'\nconsole.log('Book 2:', book2.title);  // '1984'\nconsole.log('Book 1 ISBN:', book1.isbn); // '978-0743273565'\nconsole.log('Book 2 ISBN:', book2.isbn); // undefined",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should create book objects with interface",
                  "expectedOutput": "Test",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should handle optional isbn",
                  "expectedOutput": "200",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use `?` to make isbn optional. The syntax is: `propertyName?: type`"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes with interfaces:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes with interfaces:"
                },
                {
                  "mistake": "**Forgetting required properties**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting required properties**:\n   ```typescript\n   let user: User = { id: 1 }; // ERROR: Missing username, email, isActive\n   ```\n   Solution: Include ALL required properties"
                },
                {
                  "mistake": "**Wrong property names**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong property names**:\n   ```typescript\n   let user: User = { \n     id: 1, \n     userName: 'alice' // ERROR: Should be 'username' not 'userName'\n   };\n   ```\n   Solution: Match property names exactly (case-sensitive!)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "9.4",
          "title": "TypeScript Project Setup (The Toolbox Assembly)",
          "moduleId": "module-09",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're setting up a woodworking shop:\n\nWoodworking setup:\n- You need tools (saw, hammer, drill)\n- You need a workspace (workshop with proper layout)\n- You need safety equipment (goggles, gloves)\n- You need instructions on how to use everything\n\nTypeScript project setup:\n- You need TypeScript installed (the compiler)\n- You need a configuration file (tsconfig.json)\n- You need a folder structure (organized workspace)\n- You need to know how to compile TS → JS\n\nJust like you can't start woodworking without setting up your shop, you can't start a TypeScript project without proper configuration!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// TypeScript 5.7 Project Setup (2024-2025)\n\n// STEP 1: Initialize a Node.js project (run in terminal)\n// npm init -y\n\n// STEP 2: Install TypeScript (run in terminal)\n// npm install -D typescript\n\n// STEP 3: Create tsconfig.json configuration file\n// Content of tsconfig.json:\n/*\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2024\",           // Use ES2024 features\n    \"module\": \"ESNext\",           // Modern module system\n    \"outDir\": \"./dist\",           // Compiled JS goes here\n    \"rootDir\": \"./src\",           // TypeScript source files here\n    \"strict\": true,               // Enable all strict type checks\n    \"esModuleInterop\": true,      // Better import compatibility\n    \"skipLibCheck\": true,         // Skip type checking of declaration files\n    \"forceConsistentCasingInFileNames\": true  // Case-sensitive imports\n  },\n  \"include\": [\"src/**/*\"],       // Include all files in src folder\n  \"exclude\": [\"node_modules\"]    // Exclude dependencies\n}\n*/\n\n// STEP 4: Create folder structure\n// project/\n//   ├── src/           (TypeScript source files)\n//   │   └── index.ts\n//   ├── dist/          (Compiled JavaScript - auto-generated)\n//   ├── node_modules/  (Dependencies)\n//   ├── package.json\n//   └── tsconfig.json\n\n// STEP 5: Write TypeScript code in src/index.ts\ninterface Greeting {\n  message: string;\n  name: string;\n}\n\nfunction greet(greeting: Greeting): string {\n  return `${greeting.message}, ${greeting.name}!`;\n}\n\nconst welcome: Greeting = {\n  message: 'Hello',\n  name: 'TypeScript Developer'\n};\n\nconsole.log(greet(welcome));\n\n// STEP 6: Compile TypeScript to JavaScript (run in terminal)\n// npx tsc\n// This creates dist/index.js\n\n// STEP 7: Run the compiled JavaScript (run in terminal)\n// node dist/index.js\n\n// STEP 8: (Optional) Watch mode - auto-compile on file changes\n// npx tsc --watch\n\n// MODERN WORKFLOW: Use ts-node for development\n// npm install -D ts-node\n// npx ts-node src/index.ts  (runs TypeScript directly!)\n\nconsole.log('TypeScript project setup complete!');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down TypeScript project configuration:\n\n1. **tsconfig.json**: The command center\n   - Tells TypeScript how to compile your code\n   - Lives in the project root directory\n   - JSON format (strict syntax)\n\n2. **Key Configuration Options**:\n   - `target`: Which JavaScript version to output (ES2024 is latest)\n   - `module`: How to handle imports/exports (ESNext for modern)\n   - `outDir`: Where compiled JavaScript goes (usually 'dist' or 'build')\n   - `rootDir`: Where TypeScript source files are (usually 'src')\n   - `strict`: Turn on all strict type checking (HIGHLY recommended)\n\n3. **Compilation Process**:\n   - Write `.ts` files (TypeScript)\n   - Run `npx tsc` command\n   - TypeScript compiler reads tsconfig.json\n   - Generates `.js` files in outDir\n   - Run the `.js` files with Node.js\n\n4. **Development Tools**:\n   - `tsc`: TypeScript compiler\n   - `ts-node`: Run TypeScript directly without manual compilation\n   - `--watch`: Auto-recompile when files change\n   - `npm install -D`: Install as development dependency\n\n5. **Folder Structure Best Practices**:\n   - `/src`: All TypeScript source code\n   - `/dist`: Compiled JavaScript (gitignored)\n   - `/node_modules`: Dependencies (gitignored)\n   - Root: Config files (tsconfig.json, package.json)\n\n6. **Why We Need Compilation**:\n   - Browsers and Node.js don't understand TypeScript\n   - TypeScript must be converted (transpiled) to JavaScript\n   - The type checking happens during compilation\n   - Runtime uses the generated JavaScript"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common setup mistakes:\n\n1. **Wrong tsconfig.json location**:\n   - Must be in project root (not inside src/)\n   - Must be named exactly 'tsconfig.json' (case-sensitive)\n\n2. **JSON syntax errors**:\n   ```json\n   {\n     \"target\": \"ES2024\",  // ERROR: No trailing comma on last item!\n   }\n   ```\n   Solution: Remove trailing commas in JSON files\n\n3. **Running .ts files directly**: `node src/index.ts`\n   - Node.js can't run TypeScript!\n   - Either compile first: `npx tsc` then `node dist/index.js`\n   - Or use ts-node: `npx ts-node src/index.ts`\n\n4. **Forgetting to install TypeScript**:\n   - Must run `npm install -D typescript` first\n   - Check with `npx tsc --version`\n\n5. **Wrong folder structure**:\n   - TypeScript files should be in src/\n   - If you put them elsewhere, update `rootDir` in tsconfig.json\n\n6. **Confusion about compilation**:\n   - TypeScript → JavaScript (compilation/transpilation)\n   - Types are removed during compilation\n   - The .js output has no type information\n   - Type checking happens at compile-time only\n\n7. **Not using strict mode**:\n   - `\"strict\": false` allows many unsafe patterns\n   - Always use `\"strict\": true` for maximum safety\n   - You're learning TypeScript to catch bugs - use all its power!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "9.4-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a TypeScript project setup by creating the necessary configuration:\n\n1. Create a simple TypeScript configuration object with these properties:\n   - `target`: 'ES2024'\n   - `strict`: true\n   - `outDir`: './dist'\n\n2. Create an interface `ProjectConfig` that matches this structure\n\n3. Create a function `validateConfig` that takes a ProjectConfig and returns true if strict is enabled\n\n4. Test your function with a config object\n\nLog the validation result.",
              "instructions": "Simulate a TypeScript project setup by creating the necessary configuration:\n\n1. Create a simple TypeScript configuration object with these properties:\n   - `target`: 'ES2024'\n   - `strict`: true\n   - `outDir`: './dist'\n\n2. Create an interface `ProjectConfig` that matches this structure\n\n3. Create a function `validateConfig` that takes a ProjectConfig and returns true if strict is enabled\n\n4. Test your function with a config object\n\nLog the validation result.",
              "starterCode": "// Define ProjectConfig interface\ninterface ProjectConfig {\n  // Add properties here\n}\n\n// Create validation function\nfunction validateConfig(config) {\n  return config.strict === true;\n}\n\n// Create a config object\nlet myConfig = {\n  target: 'ES2024',\n  strict: true,\n  outDir: './dist'\n};\n\nconsole.log('Strict mode enabled?', validateConfig(myConfig));",
              "solution": "// ProjectConfig interface\ninterface ProjectConfig {\n  target: string;\n  strict: boolean;\n  outDir: string;\n}\n\n// Typed validation function\nfunction validateConfig(config: ProjectConfig): boolean {\n  return config.strict === true;\n}\n\n// Create typed config object\nlet myConfig: ProjectConfig = {\n  target: 'ES2024',\n  strict: true,\n  outDir: './dist'\n};\n\nconsole.log('Strict mode enabled?', validateConfig(myConfig)); // true\n\n// Test with strict mode disabled\nlet loosConfig: ProjectConfig = {\n  target: 'ES2024',\n  strict: false,\n  outDir: './dist'\n};\n\nconsole.log('Loose mode:', validateConfig(loosConfig)); // false",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should validate strict mode is enabled",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should detect when strict mode is disabled",
                  "expectedOutput": "false",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Add type annotations to the interface properties and function parameter."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common setup mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common setup mistakes:"
                },
                {
                  "mistake": "**Wrong tsconfig.json location**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong tsconfig.json location**:\n   - Must be in project root (not inside src/)\n   - Must be named exactly 'tsconfig.json' (case-sensitive)"
                },
                {
                  "mistake": "**JSON syntax errors**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**JSON syntax errors**:\n   ```json\n   {\n     \"target\": \"ES2024\",  // ERROR: No trailing comma on last item!\n   }\n   ```\n   Solution: Remove trailing commas in JSON files"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "9.5",
          "title": "Converting JavaScript to TypeScript (The Upgrade Path)",
          "moduleId": "module-09",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have a bicycle and you want to upgrade it to an electric bike:\n\nBicycle (JavaScript):\n- Works perfectly fine as-is\n- You can ride it anywhere\n- No extra features\n\nE-bike (TypeScript):\n- Same bicycle underneath\n- Added motor, battery, controls\n- More features and safety\n- Still works as a regular bike if battery dies\n\nConverting JavaScript to TypeScript is the same:\n- Start with working JavaScript code\n- Add type annotations (the electric components)\n- Get extra safety and features\n- The underlying logic stays the same!\n\nYou don't have to convert everything at once - you can gradually upgrade piece by piece."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// BEFORE: Plain JavaScript (works but no type safety)\nfunction calculateDiscount(price, discountPercent) {\n  if (discountPercent < 0 || discountPercent > 100) {\n    return 'Invalid discount';\n  }\n  let discount = price * (discountPercent / 100);\n  return price - discount;\n}\n\nlet product = {\n  name: 'Laptop',\n  price: 1000,\n  category: 'Electronics'\n};\n\nlet discountedPrice = calculateDiscount(product.price, 20);\nconsole.log('Original JavaScript:', discountedPrice); // 800\n\n// Problems with the JavaScript version:\n// calculateDiscount('abc', 'xyz')  // No error until runtime!\n// calculateDiscount(1000, 150)     // Accepts invalid discount percent\n\n// AFTER: TypeScript (type-safe)\ninterface Product {\n  name: string;\n  price: number;\n  category: string;\n}\n\nfunction calculateDiscountTyped(\n  price: number, \n  discountPercent: number\n): number | string {\n  if (discountPercent < 0 || discountPercent > 100) {\n    return 'Invalid discount';\n  }\n  let discount: number = price * (discountPercent / 100);\n  return price - discount;\n}\n\nlet typedProduct: Product = {\n  name: 'Laptop',\n  price: 1000,\n  category: 'Electronics'\n};\n\nlet typedDiscountedPrice = calculateDiscountTyped(typedProduct.price, 20);\nconsole.log('TypeScript version:', typedDiscountedPrice); // 800\n\n// These will now cause COMPILE-TIME errors:\n// calculateDiscountTyped('abc', 'xyz')  // ERROR: string is not assignable to number\n// calculateDiscountTyped(1000, 150)     // Still runs, but you can add validation\n\n// MIGRATION STRATEGY: Step-by-step conversion\n\n// Step 1: Rename .js files to .ts (start simple)\n// app.js → app.ts\n\n// Step 2: Add return types to functions\nfunction greet(name: string): string {\n  return `Hello, ${name}!`;\n}\n\n// Step 3: Add parameter types\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// Step 4: Create interfaces for complex objects\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// Step 5: Update variable declarations\nlet users: User[] = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' }\n];\n\n// Step 6: Enable strict mode in tsconfig.json (gradually)\n// Start with \"strict\": false, then enable incrementally\n\nconsole.log('Migration complete!');\nconsole.log('User count:', users.length); // 2"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Converting JavaScript to TypeScript step-by-step:\n\n1. **File Renaming** (easiest step):\n   - `.js` → `.ts` (JavaScript → TypeScript)\n   - `.jsx` → `.tsx` (React files)\n   - All valid JavaScript is valid TypeScript!\n\n2. **Add Function Return Types**:\n   ```typescript\n   // Before\n   function getName() {\n     return 'Alice';\n   }\n   \n   // After\n   function getName(): string {\n     return 'Alice';\n   }\n   ```\n\n3. **Add Parameter Types**:\n   ```typescript\n   // Before\n   function greet(name) {\n     return `Hello, ${name}`;\n   }\n   \n   // After  \n   function greet(name: string): string {\n     return `Hello, ${name}`;\n   }\n   ```\n\n4. **Create Interfaces for Objects**:\n   ```typescript\n   // Before\n   let user = {\n     id: 1,\n     name: 'Alice'\n   };\n   \n   // After\n   interface User {\n     id: number;\n     name: string;\n   }\n   \n   let user: User = {\n     id: 1,\n     name: 'Alice'\n   };\n   ```\n\n5. **Type Arrays**:\n   ```typescript\n   // Before\n   let numbers = [1, 2, 3];\n   \n   // After\n   let numbers: number[] = [1, 2, 3];\n   ```\n\n6. **Union Types for Multiple Return Types**:\n   ```typescript\n   function getValue(): number | string {\n     // Can return either number or string\n   }\n   ```\n\n7. **Migration Strategy**:\n   - Start with strict: false in tsconfig.json\n   - Convert one file at a time\n   - Focus on functions and interfaces first\n   - Gradually enable strict checks\n   - Don't try to convert everything at once!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common migration mistakes:\n\n1. **Trying to convert everything at once**:\n   - This is overwhelming and error-prone\n   - Convert one file or module at a time\n   - Start with core utilities, then work outward\n\n2. **Using 'any' everywhere**:\n   ```typescript\n   function process(data: any): any {  // Bad!\n     // ...\n   }\n   ```\n   - This defeats the purpose of TypeScript\n   - Take time to figure out the correct types\n   - Use 'any' only as a temporary placeholder\n\n3. **Ignoring type errors**:\n   - TypeScript errors are there to help!\n   - Don't use `@ts-ignore` to suppress them\n   - Fix the underlying issue instead\n\n4. **Not updating tests**:\n   - If you have .test.js files, convert them to .test.ts\n   - Add types to test data and assertions\n\n5. **Forgetting about third-party types**:\n   - Many libraries need type definitions\n   - Install them: `npm install -D @types/lodash`\n   - Check DefinitelyTyped for available types\n\n6. **Over-typing simple code**:\n   ```typescript\n   // Over-typed (unnecessary)\n   let name: string = 'Alice';\n   \n   // Better (type inference)\n   let name = 'Alice';  // TypeScript knows it's a string\n   ```\n   - Let TypeScript infer obvious types\n   - Add explicit types for function parameters and returns\n\n7. **Not communicating with team**:\n   - Migration affects everyone\n   - Set coding standards together\n   - Pair program on tricky conversions\n   - Document your migration strategy\n\nRemember: Migration is a gradual process. It's okay to have both .js and .ts files in your project during the transition!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "9.5-challenge",
              "title": "Practice Challenge",
              "description": "Convert this JavaScript code to TypeScript:\n\nYou have a function `getFullName` that takes a user object with firstName and lastName properties and returns the full name.\n\nTasks:\n1. Create a `User` interface with firstName and lastName (both strings)\n2. Add type annotations to the function parameter and return type\n3. Create a typed user object\n4. Test the function\n\nOriginal JavaScript:\n```javascript\nfunction getFullName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nlet user = {\n  firstName: 'Jane',\n  lastName: 'Doe'\n};\n```",
              "instructions": "Convert this JavaScript code to TypeScript:\n\nYou have a function `getFullName` that takes a user object with firstName and lastName properties and returns the full name.\n\nTasks:\n1. Create a `User` interface with firstName and lastName (both strings)\n2. Add type annotations to the function parameter and return type\n3. Create a typed user object\n4. Test the function\n\nOriginal JavaScript:\n```javascript\nfunction getFullName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nlet user = {\n  firstName: 'Jane',\n  lastName: 'Doe'\n};\n```",
              "starterCode": "// Step 1: Create User interface\ninterface User {\n  // Add properties\n}\n\n// Step 2: Add types to function\nfunction getFullName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\n// Step 3: Create typed user\nlet user = {\n  firstName: 'Jane',\n  lastName: 'Doe'\n};\n\nconsole.log(getFullName(user));",
              "solution": "// Step 1: Create User interface\ninterface User {\n  firstName: string;\n  lastName: string;\n}\n\n// Step 2: Add types to function\nfunction getFullName(user: User): string {\n  return user.firstName + ' ' + user.lastName;\n}\n\n// Step 3: Create typed user\nlet user: User = {\n  firstName: 'Jane',\n  lastName: 'Doe'\n};\n\nconsole.log(getFullName(user)); // 'Jane Doe'\n\n// Bonus: Array of users\nlet users: User[] = [\n  { firstName: 'Jane', lastName: 'Doe' },\n  { firstName: 'John', lastName: 'Smith' }\n];\n\nfor (let u of users) {\n  console.log(getFullName(u));\n}\n// Output:\n// 'Jane Doe'\n// 'John Smith'",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should return full name",
                  "expectedOutput": "Jane Doe",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should work with different names",
                  "expectedOutput": "John Smith",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Add `: string` to both interface properties, `: User` to the function parameter, and `: string` for the return type."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common migration mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common migration mistakes:"
                },
                {
                  "mistake": "**Trying to convert everything at once**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Trying to convert everything at once**:\n   - This is overwhelming and error-prone\n   - Convert one file or module at a time\n   - Start with core utilities, then work outward"
                },
                {
                  "mistake": "**Using 'any' everywhere**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Using 'any' everywhere**:\n   ```typescript\n   function process(data: any): any {  // Bad!\n     // ...\n   }\n   ```\n   - This defeats the purpose of TypeScript\n   - Take time to figure out the correct types\n   - Use 'any' only as a temporary placeholder"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "9.6",
          "title": "Generics (The Swiss Army Knife Analogy)",
          "moduleId": "module-09",
          "order": 6,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a Swiss Army knife:\n\nWithout versatility (specific tools):\n- You need a separate knife for cutting bread\n- A different knife for cutting rope\n- Another knife for cutting paper\n- Each tool only works with one material\n\nWith versatility (Swiss Army knife):\n- One tool that adapts to many uses\n- Same cutting motion, different materials\n- The knife works with whatever you give it\n- Still sharp and effective for each use\n\nGenerics in TypeScript work the same way. Instead of writing separate functions for numbers, strings, and objects, you write ONE function that works with ANY type you give it. The function adapts to the type, just like a Swiss Army knife adapts to the material."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// TypeScript Generics - Flexible, Reusable Types\n\n// PROBLEM: Writing the same function for different types\nfunction getFirstNumber(arr: number[]): number | undefined {\n  return arr[0];\n}\n\nfunction getFirstString(arr: string[]): string | undefined {\n  return arr[0];\n}\n\n// We need a new function for every type! That's a lot of repetition.\n\n// SOLUTION: Generics - One function that works with ANY type\nfunction getFirst<T>(arr: T[]): T | undefined {\n  return arr[0];\n}\n\n// Now it works with any type!\nconsole.log(getFirst<number>([1, 2, 3]));           // 1\nconsole.log(getFirst<string>(['a', 'b', 'c']));    // 'a'\nconsole.log(getFirst<boolean>([true, false]));     // true\n\n// TypeScript can also INFER the type automatically!\nconsole.log(getFirst([10, 20, 30]));               // 10 (infers number)\nconsole.log(getFirst(['hello', 'world']));         // 'hello' (infers string)\n\n// GENERIC INTERFACES - Create flexible data structures\ninterface Box<T> {\n  contents: T;\n  label: string;\n}\n\nlet numberBox: Box<number> = { contents: 42, label: 'Answer' };\nlet stringBox: Box<string> = { contents: 'Hello', label: 'Greeting' };\n\nconsole.log('Number box:', numberBox.contents);    // 42\nconsole.log('String box:', stringBox.contents);    // 'Hello'\n\n// MULTIPLE TYPE PARAMETERS - Use more than one generic type\nfunction makePair<K, V>(key: K, value: V): { key: K; value: V } {\n  return { key, value };\n}\n\nlet pair1 = makePair<string, number>('age', 25);\nlet pair2 = makePair<number, boolean>(1, true);\nlet pair3 = makePair('name', 'Alice');  // Types inferred automatically\n\nconsole.log('Pair 1:', pair1);  // { key: 'age', value: 25 }\nconsole.log('Pair 2:', pair2);  // { key: 1, value: true }\nconsole.log('Pair 3:', pair3);  // { key: 'name', value: 'Alice' }\n\n// GENERIC CONSTRAINTS - Limit what types are allowed\ninterface Lengthable {\n  length: number;\n}\n\nfunction logLength<T extends Lengthable>(item: T): void {\n  console.log('Length:', item.length);\n}\n\nlogLength('Hello');           // 5 (strings have length)\nlogLength([1, 2, 3, 4]);      // 4 (arrays have length)\nlogLength({ length: 10 });    // 10 (object with length property)\n// logLength(42);             // ERROR: number doesn't have length!\n\n// GENERIC CLASSES - Reusable data structures\nclass Stack<T> {\n  private items: T[] = [];\n  \n  push(item: T): void {\n    this.items.push(item);\n  }\n  \n  pop(): T | undefined {\n    return this.items.pop();\n  }\n  \n  peek(): T | undefined {\n    return this.items[this.items.length - 1];\n  }\n}\n\nlet numberStack = new Stack<number>();\nnumberStack.push(1);\nnumberStack.push(2);\nnumberStack.push(3);\nconsole.log('Top of stack:', numberStack.peek());  // 3\nconsole.log('Popped:', numberStack.pop());         // 3\n\nlet stringStack = new Stack<string>();\nstringStack.push('first');\nstringStack.push('second');\nconsole.log('String stack top:', stringStack.peek());  // 'second'\n\n// REAL-WORLD EXAMPLE: API Response wrapper\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message: string;\n}\n\ninterface User {\n  id: number;\n  name: string;\n}\n\ninterface Product {\n  sku: string;\n  price: number;\n}\n\nlet userResponse: ApiResponse<User> = {\n  data: { id: 1, name: 'Alice' },\n  status: 200,\n  message: 'Success'\n};\n\nlet productResponse: ApiResponse<Product> = {\n  data: { sku: 'ABC123', price: 29.99 },\n  status: 200,\n  message: 'Success'\n};\n\nconsole.log('User:', userResponse.data.name);       // 'Alice'\nconsole.log('Product:', productResponse.data.sku);  // 'ABC123'"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down generics in TypeScript:\n\n1. **Basic Generic Syntax**: `function name<T>(param: T): T`\n   - `<T>` declares a type parameter (T is just a convention)\n   - `T` is a placeholder for any type\n   - Common names: T (Type), K (Key), V (Value), E (Element)\n\n2. **Using Generic Functions**:\n   ```typescript\n   // Explicit type argument\n   getFirst<string>(['a', 'b']);\n   \n   // Type inference (TypeScript figures it out)\n   getFirst(['a', 'b']);  // Infers string\n   ```\n\n3. **Generic Interfaces**: `interface Box<T> { contents: T }`\n   - Create reusable shapes that work with any type\n   - Specify the type when using: `Box<number>`\n\n4. **Multiple Type Parameters**: `<K, V>`\n   - Use multiple placeholders for complex types\n   - Each can be different types\n\n5. **Generic Constraints**: `<T extends SomeType>`\n   - Limit which types can be used\n   - `extends` means \"must have these properties\"\n   - Ensures the generic type has required features\n\n6. **Generic Classes**: `class Container<T> { ... }`\n   - Create reusable data structures\n   - Type is specified when creating instances\n   - Methods work with the specified type\n\n7. **When to Use Generics**:\n   - Functions that work with multiple types\n   - Data structures (lists, stacks, maps)\n   - API wrappers and response types\n   - Utility functions (getFirst, filter, map)\n\n8. **Benefits of Generics**:\n   - Write once, use with many types\n   - Full type safety maintained\n   - Better code reuse\n   - Self-documenting code"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes with generics:\n\n1. **Using `any` instead of generics**:\n   ```typescript\n   // Bad - loses type safety\n   function getFirst(arr: any[]): any {\n     return arr[0];\n   }\n   \n   // Good - preserves type safety\n   function getFirst<T>(arr: T[]): T | undefined {\n     return arr[0];\n   }\n   ```\n\n2. **Forgetting type constraints**:\n   ```typescript\n   // Error - T might not have 'length'\n   function logLength<T>(item: T): void {\n     console.log(item.length);  // ERROR!\n   }\n   \n   // Fixed - constrain T to have length\n   function logLength<T extends { length: number }>(item: T): void {\n     console.log(item.length);  // OK\n   }\n   ```\n\n3. **Over-complicating with generics**:\n   - Don't use generics when a simple union type works\n   - `string | number` might be clearer than `T`\n   - Use generics when you need type relationships\n\n4. **Confusing generic syntax**:\n   - `<T>` goes after function name: `function name<T>(...)`\n   - `<T>` goes after interface name: `interface Name<T> {...}`\n   - Arrow functions: `const fn = <T>(x: T): T => x;`\n\n5. **Not specifying return types**:\n   ```typescript\n   // TypeScript infers, but explicit is clearer\n   function getFirst<T>(arr: T[]): T | undefined {\n     return arr[0];\n   }\n   ```\n\n6. **Naming conventions**:\n   - T, U, V for general types\n   - K for keys, V for values\n   - E for elements in collections\n   - More descriptive names also work: `TItem`, `TResponse`"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "9.6-challenge",
              "title": "Practice Challenge",
              "description": "Create a generic function and interface:\n\n1. Create a generic function `wrapInArray<T>` that:\n   - Takes a single value of type T\n   - Returns an array containing just that value: [value]\n\n2. Create a generic interface `Result<T>` with:\n   - `success`: boolean\n   - `data`: T (the generic type)\n   - `error`: string | null\n\n3. Create a function `createSuccess<T>` that:\n   - Takes a data parameter of type T\n   - Returns a Result<T> with success: true, the data, and error: null\n\n4. Test with different types (string, number, object)",
              "instructions": "Create a generic function and interface:\n\n1. Create a generic function `wrapInArray<T>` that:\n   - Takes a single value of type T\n   - Returns an array containing just that value: [value]\n\n2. Create a generic interface `Result<T>` with:\n   - `success`: boolean\n   - `data`: T (the generic type)\n   - `error`: string | null\n\n3. Create a function `createSuccess<T>` that:\n   - Takes a data parameter of type T\n   - Returns a Result<T> with success: true, the data, and error: null\n\n4. Test with different types (string, number, object)",
              "starterCode": "// 1. Create the wrapInArray function\nfunction wrapInArray(value) {\n  return [value];\n}\n\n// 2. Create the Result interface\ninterface Result {\n  success: boolean;\n  data: any;\n  error: string | null;\n}\n\n// 3. Create the createSuccess function\nfunction createSuccess(data) {\n  return {\n    success: true,\n    data: data,\n    error: null\n  };\n}\n\n// 4. Test your code\nconsole.log(wrapInArray(42));\nconsole.log(wrapInArray('hello'));\nconsole.log(createSuccess({ id: 1, name: 'Alice' }));",
              "solution": "// 1. Generic wrapInArray function\nfunction wrapInArray<T>(value: T): T[] {\n  return [value];\n}\n\n// 2. Generic Result interface\ninterface Result<T> {\n  success: boolean;\n  data: T;\n  error: string | null;\n}\n\n// 3. Generic createSuccess function\nfunction createSuccess<T>(data: T): Result<T> {\n  return {\n    success: true,\n    data: data,\n    error: null\n  };\n}\n\n// 4. Test with different types\nconsole.log(wrapInArray<number>(42));        // [42]\nconsole.log(wrapInArray<string>('hello'));   // ['hello']\nconsole.log(wrapInArray([1, 2, 3]));         // [[1, 2, 3]]\n\nlet userResult = createSuccess<{ id: number; name: string }>({ id: 1, name: 'Alice' });\nconsole.log('User result:', userResult);\n// { success: true, data: { id: 1, name: 'Alice' }, error: null }\n\nlet numberResult = createSuccess<number>(42);\nconsole.log('Number result:', numberResult);\n// { success: true, data: 42, error: null }",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "wrapInArray should wrap value in array",
                  "expectedOutput": "[42]",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "createSuccess should create proper Result",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For wrapInArray, add <T> after the function name, then use T for the parameter type and T[] for the return type."
                },
                {
                  "level": 2,
                  "text": "For the Result interface, add <T> after the interface name: interface Result<T>. Then use T for the data property type."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to add <T> to the function or interface",
                  "consequence": "TypeScript won't recognize it as a generic type.",
                  "correction": "Add <T> immediately after the function/interface name: function name<T>(...) or interface Name<T> {...}"
                },
                {
                  "mistake": "Using 'any' instead of the generic type parameter",
                  "consequence": "Loses type safety - the whole point of generics.",
                  "correction": "Replace 'any' with 'T' (or your type parameter name) to maintain type relationships."
                },
                {
                  "mistake": "Forgetting the return type annotation",
                  "consequence": "While TypeScript can infer, explicit types make code clearer.",
                  "correction": "Add return type: function wrapInArray<T>(value: T): T[] { ... }"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "9.7",
          "title": "Utility Types (The Transformer Toolkit Analogy)",
          "moduleId": "module-09",
          "order": 7,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have a photo editing app:\n\nWithout filters/presets:\n- You manually adjust every setting for each photo\n- Want black and white? Manually remove all colors\n- Want to resize? Calculate and enter dimensions\n- Repetitive and error-prone\n\nWith filters/presets (Utility Types):\n- One-click transformations\n- 'Black and White' filter instantly transforms any photo\n- 'Resize 50%' works on any image\n- Same transformation, different inputs\n\nTypeScript's utility types are like photo filters for your types. They take an existing type and transform it into something new. `Partial<User>` makes all fields optional, `Pick<User, 'name'>` extracts just one field - same transformation, different types!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// TypeScript Utility Types - Transform Types Easily\n\n// Our base interface to transform\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n  isAdmin: boolean;\n}\n\n// 1. PARTIAL<T> - Makes all properties optional\ntype PartialUser = Partial<User>;\n// Same as: { id?: number; name?: string; email?: string; ... }\n\nfunction updateUser(id: number, updates: Partial<User>): void {\n  console.log(`Updating user ${id} with:`, updates);\n}\n\nupdateUser(1, { name: 'Alice' });           // Only update name\nupdateUser(2, { email: 'new@email.com' });  // Only update email\nupdateUser(3, { age: 30, isAdmin: true });  // Update multiple fields\n\n// 2. REQUIRED<T> - Makes all properties required (opposite of Partial)\ninterface OptionalConfig {\n  theme?: string;\n  language?: string;\n  fontSize?: number;\n}\n\ntype RequiredConfig = Required<OptionalConfig>;\n// Now all properties are required!\n\nlet config: RequiredConfig = {\n  theme: 'dark',\n  language: 'en',\n  fontSize: 14\n};\nconsole.log('Config:', config);\n\n// 3. PICK<T, Keys> - Select only specific properties\ntype UserPreview = Pick<User, 'id' | 'name'>;\n// Same as: { id: number; name: string }\n\nlet preview: UserPreview = {\n  id: 1,\n  name: 'Alice'\n};\nconsole.log('User preview:', preview);\n\n// 4. OMIT<T, Keys> - Remove specific properties\ntype UserWithoutEmail = Omit<User, 'email'>;\n// Same as: { id: number; name: string; age: number; isAdmin: boolean }\n\nlet publicUser: UserWithoutEmail = {\n  id: 1,\n  name: 'Alice',\n  age: 25,\n  isAdmin: false\n};\nconsole.log('Public user (no email):', publicUser);\n\n// 5. READONLY<T> - Makes all properties read-only\ntype ReadonlyUser = Readonly<User>;\n\nlet frozenUser: ReadonlyUser = {\n  id: 1,\n  name: 'Alice',\n  email: 'alice@example.com',\n  age: 25,\n  isAdmin: false\n};\n// frozenUser.name = 'Bob';  // ERROR: Cannot assign to 'name' because it is read-only\nconsole.log('Frozen user:', frozenUser.name);\n\n// 6. RECORD<Keys, Type> - Create object type with specific keys\ntype UserRoles = 'admin' | 'editor' | 'viewer';\ntype RolePermissions = Record<UserRoles, string[]>;\n\nlet permissions: RolePermissions = {\n  admin: ['read', 'write', 'delete', 'manage'],\n  editor: ['read', 'write'],\n  viewer: ['read']\n};\nconsole.log('Editor can:', permissions.editor);  // ['read', 'write']\n\n// 7. EXCLUDE<T, U> - Remove types from a union\ntype AllStatus = 'pending' | 'approved' | 'rejected' | 'cancelled';\ntype ActiveStatus = Exclude<AllStatus, 'cancelled'>;\n// Same as: 'pending' | 'approved' | 'rejected'\n\nlet status: ActiveStatus = 'pending';  // OK\n// let status2: ActiveStatus = 'cancelled';  // ERROR!\nconsole.log('Active status:', status);\n\n// 8. EXTRACT<T, U> - Keep only matching types from a union\ntype StringOrNumber = string | number | boolean | null;\ntype OnlyStringOrNumber = Extract<StringOrNumber, string | number>;\n// Same as: string | number\n\nlet value: OnlyStringOrNumber = 'hello';  // OK\nvalue = 42;  // OK\n// value = true;  // ERROR: boolean not allowed\nconsole.log('Value:', value);\n\n// 9. NONNULLABLE<T> - Remove null and undefined\ntype MaybeString = string | null | undefined;\ntype DefinitelyString = NonNullable<MaybeString>;\n// Same as: string\n\nlet definite: DefinitelyString = 'I exist!';\n// let bad: DefinitelyString = null;  // ERROR!\nconsole.log('Definite value:', definite);\n\n// 10. RETURNTYPE<T> - Get the return type of a function\nfunction createUser(name: string, age: number) {\n  return { id: Date.now(), name, age, createdAt: new Date() };\n}\n\ntype CreatedUser = ReturnType<typeof createUser>;\n// Same as: { id: number; name: string; age: number; createdAt: Date }\n\nlet newUser: CreatedUser = createUser('Bob', 30);\nconsole.log('Created user type:', newUser);\n\n// COMBINING UTILITY TYPES - Chain them together!\ntype EditableUserFields = Partial<Pick<User, 'name' | 'email' | 'age'>>;\n// Only name, email, age - and all optional!\n\nfunction editProfile(updates: EditableUserFields): void {\n  console.log('Editing profile:', updates);\n}\n\neditProfile({ name: 'New Name' });  // Just name\neditProfile({ email: 'new@email.com', age: 26 });  // email and age\neditProfile({});  // Nothing - all optional!\n\nconsole.log('Utility types are powerful!');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down TypeScript utility types:\n\n1. **Partial<T>** - Make all properties optional\n   - Use for update functions where you only change some fields\n   - `Partial<User>` = `{ id?: number; name?: string; ... }`\n\n2. **Required<T>** - Make all properties required\n   - Opposite of Partial\n   - Useful when you have optional defaults but need complete objects\n\n3. **Pick<T, Keys>** - Select specific properties\n   - `Pick<User, 'id' | 'name'>` = only id and name\n   - Great for creating smaller types from larger ones\n\n4. **Omit<T, Keys>** - Remove specific properties\n   - `Omit<User, 'password'>` = User without password\n   - Good for public-facing types\n\n5. **Readonly<T>** - Make all properties read-only\n   - Prevents accidental mutations\n   - Good for config objects, constants\n\n6. **Record<Keys, Type>** - Create object with specific keys\n   - `Record<'a' | 'b', number>` = `{ a: number; b: number }`\n   - Great for lookup tables, maps\n\n7. **Exclude<T, U>** - Remove types from union\n   - `Exclude<'a' | 'b' | 'c', 'a'>` = `'b' | 'c'`\n\n8. **Extract<T, U>** - Keep only matching types\n   - `Extract<string | number | boolean, string | number>` = `string | number`\n\n9. **NonNullable<T>** - Remove null and undefined\n   - `NonNullable<string | null>` = `string`\n\n10. **ReturnType<T>** - Get function's return type\n    - `ReturnType<typeof myFunction>` = whatever the function returns\n\n11. **Combining Utility Types**:\n    - Chain them: `Partial<Pick<User, 'name' | 'email'>>`\n    - Read right-to-left: Pick first, then Partial"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes with utility types:\n\n1. **Wrong key names in Pick/Omit**:\n   ```typescript\n   // ERROR: 'username' doesn't exist in User\n   type Bad = Pick<User, 'username'>;\n   \n   // Correct: Use actual property names\n   type Good = Pick<User, 'name'>;\n   ```\n\n2. **Forgetting union syntax for multiple keys**:\n   ```typescript\n   // Wrong\n   type Bad = Pick<User, 'id', 'name'>;\n   \n   // Correct - use union type\n   type Good = Pick<User, 'id' | 'name'>;\n   ```\n\n3. **Confusing Exclude and Omit**:\n   - `Omit` removes properties from object types\n   - `Exclude` removes types from union types\n   ```typescript\n   // Omit for objects\n   type NoEmail = Omit<User, 'email'>;\n   \n   // Exclude for unions\n   type NoA = Exclude<'a' | 'b' | 'c', 'a'>;\n   ```\n\n4. **Not using typeof with ReturnType**:\n   ```typescript\n   // Wrong - myFunc is a value, not a type\n   type Bad = ReturnType<myFunc>;\n   \n   // Correct - use typeof to get the type\n   type Good = ReturnType<typeof myFunc>;\n   ```\n\n5. **Over-nesting utility types**:\n   ```typescript\n   // Hard to read\n   type Complex = Partial<Required<Readonly<Pick<Omit<User, 'id'>, 'name'>>>>;\n   \n   // Better - use intermediate types\n   type UserName = Pick<User, 'name'>;\n   type EditableName = Partial<UserName>;\n   ```\n\n6. **Thinking Readonly prevents all mutations**:\n   - Only prevents reassignment of properties\n   - Nested objects can still be mutated\n   - Use deep readonly libraries for nested protection"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "9.7-challenge",
              "title": "Practice Challenge",
              "description": "Practice using utility types with a Product interface:\n\n1. Create an interface `Product` with:\n   - id: number\n   - name: string\n   - price: number\n   - description: string\n   - inStock: boolean\n\n2. Create these type aliases using utility types:\n   - `ProductPreview`: Only id, name, and price (use Pick)\n   - `ProductUpdate`: All fields optional (use Partial)\n   - `ProductWithoutId`: Everything except id (use Omit)\n\n3. Create a function `displayPreview` that takes a ProductPreview and logs it\n\n4. Create a function `updateProduct` that takes an id and ProductUpdate\n\n5. Test both functions",
              "instructions": "Practice using utility types with a Product interface:\n\n1. Create an interface `Product` with:\n   - id: number\n   - name: string\n   - price: number\n   - description: string\n   - inStock: boolean\n\n2. Create these type aliases using utility types:\n   - `ProductPreview`: Only id, name, and price (use Pick)\n   - `ProductUpdate`: All fields optional (use Partial)\n   - `ProductWithoutId`: Everything except id (use Omit)\n\n3. Create a function `displayPreview` that takes a ProductPreview and logs it\n\n4. Create a function `updateProduct` that takes an id and ProductUpdate\n\n5. Test both functions",
              "starterCode": "// 1. Create the Product interface\ninterface Product {\n  // Add properties here\n}\n\n// 2. Create type aliases using utility types\ntype ProductPreview = Product;  // Fix this\ntype ProductUpdate = Product;   // Fix this\ntype ProductWithoutId = Product; // Fix this\n\n// 3. Create displayPreview function\nfunction displayPreview(product) {\n  console.log(`${product.name}: $${product.price}`);\n}\n\n// 4. Create updateProduct function\nfunction updateProduct(id, updates) {\n  console.log(`Updating product ${id}:`, updates);\n}\n\n// 5. Test the functions\nlet preview = { id: 1, name: 'Laptop', price: 999 };\ndisplayPreview(preview);\n\nupdateProduct(1, { price: 899 });",
              "solution": "// 1. Product interface\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  description: string;\n  inStock: boolean;\n}\n\n// 2. Type aliases using utility types\ntype ProductPreview = Pick<Product, 'id' | 'name' | 'price'>;\ntype ProductUpdate = Partial<Product>;\ntype ProductWithoutId = Omit<Product, 'id'>;\n\n// 3. displayPreview function with proper types\nfunction displayPreview(product: ProductPreview): void {\n  console.log(`${product.name}: $${product.price}`);\n}\n\n// 4. updateProduct function with proper types\nfunction updateProduct(id: number, updates: ProductUpdate): void {\n  console.log(`Updating product ${id}:`, updates);\n}\n\n// 5. Test the functions\nlet preview: ProductPreview = { id: 1, name: 'Laptop', price: 999 };\ndisplayPreview(preview);  // 'Laptop: $999'\n\nupdateProduct(1, { price: 899 });  // Just price\nupdateProduct(2, { name: 'New Name', inStock: true });  // Multiple fields\nupdateProduct(3, {});  // Empty update is valid with Partial\n\n// ProductWithoutId example - for creating new products\nlet newProduct: ProductWithoutId = {\n  name: 'Keyboard',\n  price: 79,\n  description: 'Mechanical keyboard',\n  inStock: true\n};\nconsole.log('New product (no id yet):', newProduct);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "displayPreview should show product info",
                  "expectedOutput": "Laptop: $999",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "updateProduct should accept partial updates",
                  "expectedOutput": "Updating product 1:",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For ProductPreview, use Pick<Product, 'id' | 'name' | 'price'> to select only those three properties."
                },
                {
                  "level": 2,
                  "text": "For ProductUpdate, use Partial<Product> to make all properties optional. For ProductWithoutId, use Omit<Product, 'id'>."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using comma instead of union for Pick keys",
                  "consequence": "Syntax error - Pick expects a single union type for keys.",
                  "correction": "Use: Pick<Product, 'id' | 'name' | 'price'> with pipe (|) between property names."
                },
                {
                  "mistake": "Forgetting quotes around property names",
                  "consequence": "TypeScript looks for variables named id, name, etc.",
                  "correction": "Property names must be string literals: 'id' | 'name', not id | name."
                },
                {
                  "mistake": "Confusing Omit and Exclude",
                  "consequence": "Exclude is for union types, Omit is for object properties.",
                  "correction": "Use Omit<Product, 'id'> to remove the id property from the Product object type."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "9.8",
          "title": "Type Guards and Discriminated Unions (The Security Checkpoint Analogy)",
          "moduleId": "module-09",
          "order": 8,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine airport security checkpoints:\n\nWithout proper checks:\n- Anyone could go anywhere\n- Passengers and crew mixed together\n- No way to know who has what access\n- Chaos and security risks\n\nWith security checkpoints (Type Guards):\n- Check ID: 'Are you a passenger or crew member?'\n- Once verified as crew, you can access crew areas\n- Once verified as passenger, you go through different process\n- Each check NARROWS DOWN who you are\n\nType guards work the same way in TypeScript. When you have a value that could be multiple types (like `string | number`), a type guard checks which type it actually is. Once checked, TypeScript KNOWS the specific type and gives you the right autocomplete and safety!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Type Guards and Type Narrowing in TypeScript\n\n// BASIC TYPE GUARDS - Using typeof\nfunction formatValue(value: string | number): string {\n  // TypeScript doesn't know if value is string or number here\n  \n  if (typeof value === 'string') {\n    // Inside this block, TypeScript KNOWS value is a string!\n    return value.toUpperCase();  // String methods available\n  } else {\n    // Here, TypeScript KNOWS value is a number!\n    return value.toFixed(2);  // Number methods available\n  }\n}\n\nconsole.log(formatValue('hello'));  // 'HELLO'\nconsole.log(formatValue(42.567));   // '42.57'\n\n// TYPE GUARDS WITH ARRAYS - Using Array.isArray\nfunction processData(data: string | string[]): void {\n  if (Array.isArray(data)) {\n    // TypeScript knows: data is string[]\n    console.log('Array with', data.length, 'items');\n    data.forEach(item => console.log('  -', item));\n  } else {\n    // TypeScript knows: data is string\n    console.log('Single string:', data);\n  }\n}\n\nprocessData('hello');                    // Single string: hello\nprocessData(['apple', 'banana', 'cherry']); // Array with 3 items\n\n// DISCRIMINATED UNIONS - The 'kind' pattern\ninterface Circle {\n  kind: 'circle';  // Literal type - always exactly 'circle'\n  radius: number;\n}\n\ninterface Rectangle {\n  kind: 'rectangle';  // Literal type - always exactly 'rectangle'\n  width: number;\n  height: number;\n}\n\ninterface Triangle {\n  kind: 'triangle';  // Literal type\n  base: number;\n  height: number;\n}\n\n// Union of all shapes - the 'kind' property discriminates between them\ntype Shape = Circle | Rectangle | Triangle;\n\nfunction calculateArea(shape: Shape): number {\n  // Switch on the discriminant property 'kind'\n  switch (shape.kind) {\n    case 'circle':\n      // TypeScript knows: shape is Circle\n      return Math.PI * shape.radius ** 2;\n      \n    case 'rectangle':\n      // TypeScript knows: shape is Rectangle\n      return shape.width * shape.height;\n      \n    case 'triangle':\n      // TypeScript knows: shape is Triangle\n      return 0.5 * shape.base * shape.height;\n  }\n}\n\nlet circle: Circle = { kind: 'circle', radius: 5 };\nlet rect: Rectangle = { kind: 'rectangle', width: 10, height: 4 };\nlet tri: Triangle = { kind: 'triangle', base: 6, height: 8 };\n\nconsole.log('Circle area:', calculateArea(circle).toFixed(2));   // 78.54\nconsole.log('Rectangle area:', calculateArea(rect));              // 40\nconsole.log('Triangle area:', calculateArea(tri));                // 24\n\n// CUSTOM TYPE GUARDS - Using 'is' keyword\ninterface Dog {\n  breed: string;\n  bark(): void;\n}\n\ninterface Cat {\n  breed: string;\n  meow(): void;\n}\n\ntype Pet = Dog | Cat;\n\n// Custom type guard function - returns 'pet is Dog'\nfunction isDog(pet: Pet): pet is Dog {\n  return 'bark' in pet;  // Dogs have a bark method\n}\n\nfunction isCat(pet: Pet): pet is Cat {\n  return 'meow' in pet;  // Cats have a meow method\n}\n\nfunction makeNoise(pet: Pet): void {\n  if (isDog(pet)) {\n    // TypeScript knows: pet is Dog\n    pet.bark();\n  } else {\n    // TypeScript knows: pet is Cat\n    pet.meow();\n  }\n}\n\nlet myDog: Dog = {\n  breed: 'Golden Retriever',\n  bark() { console.log('Woof!'); }\n};\n\nlet myCat: Cat = {\n  breed: 'Siamese',\n  meow() { console.log('Meow!'); }\n};\n\nmakeNoise(myDog);  // Woof!\nmakeNoise(myCat);  // Meow!\n\n// 'IN' OPERATOR TYPE GUARD\ninterface Admin {\n  name: string;\n  privileges: string[];\n}\n\ninterface Employee {\n  name: string;\n  startDate: Date;\n}\n\ntype Staff = Admin | Employee;\n\nfunction printStaffInfo(staff: Staff): void {\n  console.log('Name:', staff.name);  // Both types have 'name'\n  \n  if ('privileges' in staff) {\n    // TypeScript knows: staff is Admin\n    console.log('Privileges:', staff.privileges.join(', '));\n  }\n  \n  if ('startDate' in staff) {\n    // TypeScript knows: staff is Employee\n    console.log('Start date:', staff.startDate.toDateString());\n  }\n}\n\nlet admin: Admin = { name: 'Alice', privileges: ['create', 'delete'] };\nlet employee: Employee = { name: 'Bob', startDate: new Date('2024-01-15') };\n\nprintStaffInfo(admin);     // Name: Alice, Privileges: create, delete\nprintStaffInfo(employee);  // Name: Bob, Start date: Mon Jan 15 2024\n\n// NULLISH TYPE GUARDS - Handling null and undefined\nfunction greet(name: string | null | undefined): string {\n  if (name === null || name === undefined) {\n    return 'Hello, stranger!';\n  }\n  // TypeScript knows: name is string\n  return `Hello, ${name.toUpperCase()}!`;\n}\n\nconsole.log(greet('alice'));     // Hello, ALICE!\nconsole.log(greet(null));        // Hello, stranger!\nconsole.log(greet(undefined));   // Hello, stranger!\n\n// EXHAUSTIVENESS CHECKING - Catch missing cases\ntype Color = 'red' | 'green' | 'blue';\n\nfunction getColorHex(color: Color): string {\n  switch (color) {\n    case 'red':\n      return '#FF0000';\n    case 'green':\n      return '#00FF00';\n    case 'blue':\n      return '#0000FF';\n    default:\n      // This should never happen if all cases are handled\n      const _exhaustiveCheck: never = color;\n      return _exhaustiveCheck;\n  }\n}\n\nconsole.log('Red hex:', getColorHex('red'));    // #FF0000\nconsole.log('Blue hex:', getColorHex('blue'));  // #0000FF"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down type guards and discriminated unions:\n\n1. **typeof Type Guards**:\n   ```typescript\n   if (typeof value === 'string') {\n     // value is string here\n   }\n   ```\n   - Works for: string, number, boolean, function, object, undefined\n   - Most common type guard\n\n2. **Array.isArray Type Guard**:\n   ```typescript\n   if (Array.isArray(data)) {\n     // data is an array here\n   }\n   ```\n   - Specifically checks for arrays\n   - typeof returns 'object' for arrays!\n\n3. **Discriminated Unions**:\n   - Add a common property with literal types\n   - Usually called 'kind', 'type', or 'tag'\n   - Switch on this property to narrow types\n   ```typescript\n   interface A { kind: 'a'; propA: string }\n   interface B { kind: 'b'; propB: number }\n   type AB = A | B;\n   ```\n\n4. **Custom Type Guards** (type predicates):\n   ```typescript\n   function isDog(pet: Pet): pet is Dog {\n     return 'bark' in pet;\n   }\n   ```\n   - Return type: `paramName is Type`\n   - Returns boolean, but narrows type when true\n\n5. **'in' Operator**:\n   ```typescript\n   if ('propertyName' in object) {\n     // object has propertyName here\n   }\n   ```\n   - Checks if property exists\n   - Narrows type to those with that property\n\n6. **Nullish Checks**:\n   ```typescript\n   if (value !== null && value !== undefined) {\n     // value is non-nullable here\n   }\n   ```\n   - Removes null/undefined from type\n   - Also works: `if (value) { ... }` (for truthy check)\n\n7. **Exhaustiveness Checking**:\n   - Use `never` type in default case\n   - TypeScript errors if you forget a case\n   - Great for switch statements on unions"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes with type guards:\n\n1. **typeof null === 'object'**:\n   ```typescript\n   let value: object | null = null;\n   \n   // Wrong - null passes this check!\n   if (typeof value === 'object') {\n     // value could still be null here\n   }\n   \n   // Correct - check for null first\n   if (value !== null && typeof value === 'object') {\n     // value is definitely an object\n   }\n   ```\n\n2. **Forgetting to handle all union members**:\n   ```typescript\n   type Status = 'pending' | 'approved' | 'rejected';\n   \n   function handleStatus(status: Status): void {\n     if (status === 'pending') { ... }\n     if (status === 'approved') { ... }\n     // Forgot 'rejected'!\n   }\n   ```\n   Use exhaustiveness checking with `never`.\n\n3. **Wrong discriminant property type**:\n   ```typescript\n   // Wrong - 'type' is just string, not specific\n   interface Circle { type: string; radius: number }\n   \n   // Correct - literal type\n   interface Circle { type: 'circle'; radius: number }\n   ```\n\n4. **Type guard returns wrong thing**:\n   ```typescript\n   // Wrong - returns boolean, but no narrowing\n   function isDog(pet: Pet): boolean {\n     return 'bark' in pet;\n   }\n   \n   // Correct - 'pet is Dog' enables narrowing\n   function isDog(pet: Pet): pet is Dog {\n     return 'bark' in pet;\n   }\n   ```\n\n5. **Not understanding narrowing scope**:\n   - Type narrowing only works within the if block\n   - After the block, type reverts to original union\n   - Use early returns for cleaner code\n\n6. **Overcomplicating simple checks**:\n   ```typescript\n   // Overcomplicated\n   function isDefined<T>(value: T | undefined): value is T {\n     return value !== undefined;\n   }\n   \n   // Often simpler inline\n   if (value !== undefined) { ... }\n   ```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "Key points about type guards and discriminated unions:\n\n1. **Type guards narrow types** - They tell TypeScript which specific type a value is within a code block.\n\n2. **Use the right guard for the job**:\n   - `typeof` for primitives\n   - `Array.isArray()` for arrays\n   - `in` operator for property existence\n   - Custom guards for complex logic\n   - Discriminated unions for related types\n\n3. **Discriminated unions are powerful** - Add a `kind` property with literal types for type-safe switches.\n\n4. **Custom type guards use `is`** - Return type `param is Type` enables TypeScript narrowing.\n\n5. **Exhaustiveness checking** - Use `never` in default case to catch missing union members at compile time.\n\n6. **Narrowing is block-scoped** - Type is narrowed only within the if/else/switch block.\n\n7. **Combine with utility types** - Works great with `Exclude`, `Extract`, and other utility types."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "9.8-challenge",
              "title": "Practice Challenge",
              "description": "Create a payment processing system using discriminated unions:\n\n1. Create three interfaces for payment methods:\n   - `CreditCard` with: kind: 'credit', cardNumber: string, cvv: string\n   - `PayPal` with: kind: 'paypal', email: string\n   - `BankTransfer` with: kind: 'bank', accountNumber: string, routingNumber: string\n\n2. Create a union type `PaymentMethod` that includes all three\n\n3. Create a function `processPayment` that:\n   - Takes a PaymentMethod and amount: number\n   - Uses a switch statement on the 'kind' property\n   - Logs a different message for each payment type\n   - For credit: 'Processing credit card ending in XXXX'\n   - For PayPal: 'Processing PayPal payment for EMAIL'\n   - For bank: 'Processing bank transfer from account XXXX'\n\n4. Test with all three payment types",
              "instructions": "Create a payment processing system using discriminated unions:\n\n1. Create three interfaces for payment methods:\n   - `CreditCard` with: kind: 'credit', cardNumber: string, cvv: string\n   - `PayPal` with: kind: 'paypal', email: string\n   - `BankTransfer` with: kind: 'bank', accountNumber: string, routingNumber: string\n\n2. Create a union type `PaymentMethod` that includes all three\n\n3. Create a function `processPayment` that:\n   - Takes a PaymentMethod and amount: number\n   - Uses a switch statement on the 'kind' property\n   - Logs a different message for each payment type\n   - For credit: 'Processing credit card ending in XXXX'\n   - For PayPal: 'Processing PayPal payment for EMAIL'\n   - For bank: 'Processing bank transfer from account XXXX'\n\n4. Test with all three payment types",
              "starterCode": "// 1. Create the payment method interfaces\ninterface CreditCard {\n  // Add properties\n}\n\ninterface PayPal {\n  // Add properties\n}\n\ninterface BankTransfer {\n  // Add properties\n}\n\n// 2. Create the union type\ntype PaymentMethod = any;  // Fix this\n\n// 3. Create the processPayment function\nfunction processPayment(payment, amount) {\n  // Use switch statement on payment.kind\n  console.log('Processing payment of $' + amount);\n}\n\n// 4. Test with all payment types\nlet creditPayment = { kind: 'credit', cardNumber: '4111111111111234', cvv: '123' };\nlet paypalPayment = { kind: 'paypal', email: 'user@example.com' };\nlet bankPayment = { kind: 'bank', accountNumber: '12345678', routingNumber: '987654321' };\n\nprocessPayment(creditPayment, 100);\nprocessPayment(paypalPayment, 50);\nprocessPayment(bankPayment, 200);",
              "solution": "// 1. Payment method interfaces with discriminant 'kind'\ninterface CreditCard {\n  kind: 'credit';\n  cardNumber: string;\n  cvv: string;\n}\n\ninterface PayPal {\n  kind: 'paypal';\n  email: string;\n}\n\ninterface BankTransfer {\n  kind: 'bank';\n  accountNumber: string;\n  routingNumber: string;\n}\n\n// 2. Union type of all payment methods\ntype PaymentMethod = CreditCard | PayPal | BankTransfer;\n\n// 3. Process payment with type-safe switch\nfunction processPayment(payment: PaymentMethod, amount: number): void {\n  console.log(`Processing payment of $${amount}`);\n  \n  switch (payment.kind) {\n    case 'credit':\n      // TypeScript knows: payment is CreditCard\n      let lastFour = payment.cardNumber.slice(-4);\n      console.log(`Processing credit card ending in ${lastFour}`);\n      break;\n      \n    case 'paypal':\n      // TypeScript knows: payment is PayPal\n      console.log(`Processing PayPal payment for ${payment.email}`);\n      break;\n      \n    case 'bank':\n      // TypeScript knows: payment is BankTransfer\n      let maskedAccount = payment.accountNumber.slice(-4);\n      console.log(`Processing bank transfer from account ${maskedAccount}`);\n      break;\n  }\n}\n\n// 4. Test with all payment types\nlet creditPayment: CreditCard = {\n  kind: 'credit',\n  cardNumber: '4111111111111234',\n  cvv: '123'\n};\n\nlet paypalPayment: PayPal = {\n  kind: 'paypal',\n  email: 'user@example.com'\n};\n\nlet bankPayment: BankTransfer = {\n  kind: 'bank',\n  accountNumber: '12345678',\n  routingNumber: '987654321'\n};\n\nprocessPayment(creditPayment, 100);\n// Processing payment of $100\n// Processing credit card ending in 1234\n\nprocessPayment(paypalPayment, 50);\n// Processing payment of $50\n// Processing PayPal payment for user@example.com\n\nprocessPayment(bankPayment, 200);\n// Processing payment of $200\n// Processing bank transfer from account 5678",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should process credit card payment",
                  "expectedOutput": "credit card ending in",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should process PayPal payment",
                  "expectedOutput": "PayPal payment for",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Should process bank transfer",
                  "expectedOutput": "bank transfer from account",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Each interface needs a 'kind' property with a literal type (in quotes): kind: 'credit', kind: 'paypal', kind: 'bank'"
                },
                {
                  "level": 2,
                  "text": "In the switch statement, after 'case \"credit\":', TypeScript knows payment is CreditCard, so you can access payment.cardNumber safely."
                },
                {
                  "level": 3,
                  "text": "Use payment.cardNumber.slice(-4) to get the last 4 digits of the card number for display."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using string type instead of literal types for 'kind'",
                  "consequence": "TypeScript can't narrow the type in switch cases - 'kind: string' could be anything.",
                  "correction": "Use literal types: kind: 'credit' (with quotes), not kind: string."
                },
                {
                  "mistake": "Forgetting to handle all cases in the switch",
                  "consequence": "Some payment types won't be processed correctly.",
                  "correction": "Add a case for each payment kind: 'credit', 'paypal', and 'bank'."
                },
                {
                  "mistake": "Trying to access payment.cardNumber before narrowing",
                  "consequence": "TypeScript error - not all PaymentMethods have cardNumber.",
                  "correction": "Access type-specific properties only inside the appropriate case block."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-10",
      "title": "Module 10: Building for the Server with Bun & Hono",
      "description": "Learn to build server-side applications with Bun and Hono, the modern high-performance stack for 2025",
      "difficulty": "intermediate",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "10.1",
          "title": "What Is Bun? (The Supercharged Kitchen Analogy)",
          "moduleId": "module-10",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine the difference between a food truck and a supercharged restaurant kitchen:\n\nFood Truck (Browser JavaScript):\n- Serves food directly to customers on the street\n- Limited space and equipment\n- Can't do heavy-duty cooking\n- Works in one location at a time\n\nSupercharged Kitchen (Bun):\n- Behind the scenes, ULTRA-FAST equipment\n- Can handle many orders simultaneously at blazing speed\n- Access to storage, databases, file systems\n- Built-in tools: no need to buy separate appliances!\n- TypeScript menu cards work without translation\n- Sends finished dishes out to customers\n\nBun is like Node.js, but reimagined for 2025. It's a JavaScript runtime that runs your code OUTSIDE the browser, but it's significantly faster and comes with batteries included: built-in TypeScript support, a package manager, bundler, and test runner. No extra tools needed!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Bun - The All-in-One JavaScript Runtime (2025)\n\n// KEY ADVANTAGES OF BUN\n// 1. SPEED - Up to 4x faster than Node.js\n// 2. TypeScript works out of the box (no compilation!)\n// 3. Built-in package manager (bun install)\n// 4. Built-in bundler (bun build)\n// 5. Built-in test runner (bun test)\n\n// BUILT-IN APIs - Bun comes with powerful tools\n// (Note: These won't work in browser JavaScript!)\n\n// 1. FILE SYSTEM - Read and write files (simulated for demo)\nlet simulatedFileContent = 'Hello from Bun!';\nconsole.log('File content:', simulatedFileContent);\n\n// In real Bun, file operations are super simple:\n// const file = Bun.file('data.txt');\n// const content = await file.text();\n// console.log(content);\n\n// 2. PATH - Handle file paths\nfunction joinPath(...parts) {\n  return parts.join('/');\n}\n\nlet filePath = joinPath('users', 'documents', 'notes.txt');\nconsole.log('File path:', filePath);\n\n// 3. HTTP SERVER - Built-in with Bun.serve()\n// In real Bun:\n// Bun.serve({\n//   port: 3000,\n//   fetch(request) {\n//     return new Response('Hello from Bun!');\n//   }\n// });\n\nconsole.log('Bun can create web servers with Bun.serve()!');\n\n// 4. RUNTIME INFO\nlet bunVersion = '1.2.0'; // Bun version\nlet platform = 'linux'; // Could be 'win32', 'darwin' (macOS), etc.\n\nconsole.log('Bun version:', bunVersion);\nconsole.log('Platform:', platform);\n\n// 5. NATIVE TYPESCRIPT SUPPORT\n// In Bun, you can run .ts files directly!\n// bun run app.ts   <- No compilation needed!\n// interface User { name: string; age: number; }\n// const user: User = { name: 'Alice', age: 30 };\n\nconsole.log('Bun runs TypeScript natively!');\n\n// 6. ASYNC OPERATIONS - Same as Node.js\nfunction simulateFileRead(filename) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`Contents of ${filename}`);\n    }, 100);\n  });\n}\n\nsimulateFileRead('data.txt').then(data => {\n  console.log('File data:', data);\n});\n\n// 7. NPM COMPATIBILITY - Use any npm package!\n// Bun is compatible with npm packages\n// bun install express  <- Works!\n// bun install hono     <- Even better!\n\nconsole.log('Bun works with npm packages!');\n\n// 8. ES MODULES - Modern imports by default\n// import { Hono } from 'hono';\n// import express from 'express';\n\n// 9. BUN-SPECIFIC FEATURES\nlet bunFeatures = [\n  'Native TypeScript/JSX support',\n  'Fastest JavaScript runtime',\n  'Built-in SQLite database',\n  'Built-in password hashing',\n  'Built-in HTML rewriter',\n  'Web-standard APIs (fetch, Response, Request)'\n];\n\nconsole.log('\\nBun-specific features:');\nbunFeatures.forEach(f => console.log('  -', f));\n\n// 10. RUNNING BUN CODE\n// Save file as app.ts or app.js\n// Run with: bun run app.ts\n// Or simply: bun app.ts\n\nconsole.log('\\nRun Bun code with: bun run app.ts');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding Bun fundamentals:\n\n1. **What Makes Bun Special**:\n   - Written in Zig for maximum performance\n   - Up to 4x faster than Node.js\n   - Built-in TypeScript support (no tsconfig needed!)\n   - Same code runs on Bun, Node, Deno, and Edge\n   - Drop-in replacement for Node.js in most cases\n\n2. **Built-in Tools**:\n   - `bun install`: Package manager (faster than npm)\n   - `bun run`: Script runner (runs .ts files directly!)\n   - `bun test`: Test runner (Jest-compatible)\n   - `bun build`: Bundler for production\n\n3. **Bun APIs**:\n   - `Bun.file()`: Read/write files\n   - `Bun.serve()`: Create HTTP servers\n   - `Bun.password`: Hash passwords\n   - `Bun.sql()`: SQLite database\n   - Standard Web APIs: `fetch`, `Response`, `Request`\n\n4. **TypeScript Just Works**:\n   ```typescript\n   // app.ts - Run directly with: bun app.ts\n   interface User {\n     name: string;\n     email: string;\n   }\n   \n   const user: User = {\n     name: 'Alice',\n     email: 'alice@example.com'\n   };\n   \n   console.log(user.name); // No compilation step!\n   ```\n\n5. **File Operations**:\n   ```javascript\n   // Reading files in Bun\n   const file = Bun.file('config.json');\n   const content = await file.text();  // or .json()\n   \n   // Writing files\n   await Bun.write('output.txt', 'Hello World!');\n   ```\n\n6. **Creating Servers**:\n   ```javascript\n   Bun.serve({\n     port: 3000,\n     fetch(request) {\n       return new Response('Hello from Bun!');\n     }\n   });\n   ```\n\n7. **Running Bun Code**:\n   - Save file as `app.ts` or `app.js`\n   - Run with: `bun run app.ts`\n   - Or simply: `bun app.ts`\n   - No browser needed, no compilation needed!"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Node.js Equivalent",
              "legacy": "nodejs",
              "content": "If you've used Node.js before, here's how Bun compares:\n\n**Node.js** requires separate tools:\n- `npm` or `yarn` for packages\n- `tsc` for TypeScript compilation\n- `jest` or `vitest` for testing\n- `webpack` or `esbuild` for bundling\n\n**Bun** has everything built-in!\n\nThe code patterns are similar, but Bun is faster and simpler.",
              "code": "// Node.js way (requires setup):\n// 1. npm init\n// 2. npm install typescript ts-node\n// 3. Create tsconfig.json\n// 4. npx ts-node app.ts\n\n// Node.js file reading:\nconst fs = require('fs');\nfs.readFile('data.txt', 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n\n// Node.js HTTP server:\nconst http = require('http');\nconst server = http.createServer((req, res) => {\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('Hello from Node.js!');\n});\nserver.listen(3000);",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Bun beginner mistakes:\n\n1. **Trying to use browser APIs**:\n   ```javascript\n   // ERROR in Bun - no DOM!\n   document.getElementById('app'); // ReferenceError: document is not defined\n   window.location.href;           // ReferenceError: window is not defined\n   ```\n   Solution: Bun is for servers, not browsers\n\n2. **Forgetting Bun uses Web APIs**:\n   ```javascript\n   // Bun uses standard Web APIs\n   // Use fetch() instead of axios for HTTP requests\n   const response = await fetch('https://api.example.com/data');\n   const data = await response.json();\n   ```\n\n3. **Using Node.js-specific patterns unnecessarily**:\n   ```javascript\n   // Old Node.js way (still works but not needed)\n   import { fileURLToPath } from 'url';\n   import { dirname } from 'path';\n   const __filename = fileURLToPath(import.meta.url);\n   const __dirname = dirname(__filename);\n   \n   // Bun way - import.meta has more built-in!\n   console.log(import.meta.dir);  // Current directory\n   console.log(import.meta.file); // Current filename\n   ```\n\n4. **Not leveraging Bun.file()**:\n   ```javascript\n   // Instead of fs.readFile callbacks:\n   const file = Bun.file('data.txt');\n   const text = await file.text();  // Simple!\n   ```\n\n5. **Installing TypeScript separately**:\n   - Bun runs .ts files directly!\n   - No need for `npm install typescript`\n   - No need for tsconfig.json (unless you want custom settings)\n\n6. **Using npm when bun is faster**:\n   - Use `bun install` instead of `npm install`\n   - Use `bun add package` instead of `npm install package`\n   - Up to 25x faster package installation!\n\n7. **Assuming all Node.js APIs work**:\n   - Most do, but some edge cases differ\n   - Check Bun docs for compatibility\n   - When in doubt, use Web Standard APIs"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.1-challenge",
              "title": "Practice Challenge",
              "description": "Create a simple Bun utility module:\n\n1. Create a function `getSystemInfo()` that returns an object with:\n   - `runtime`: 'bun'\n   - `bunVersion`: '1.2.0'\n   - `uptime`: any number (simulate uptime)\n\n2. Create a function `readConfig(filename)` that:\n   - Takes a filename as a parameter\n   - Returns a Promise that resolves with simulated file content\n   - Use setTimeout to simulate async file reading\n\n3. Test both functions and log the results",
              "instructions": "Create a simple Bun utility module:\n\n1. Create a function `getSystemInfo()` that returns an object with:\n   - `runtime`: 'bun'\n   - `bunVersion`: '1.2.0'\n   - `uptime`: any number (simulate uptime)\n\n2. Create a function `readConfig(filename)` that:\n   - Takes a filename as a parameter\n   - Returns a Promise that resolves with simulated file content\n   - Use setTimeout to simulate async file reading\n\n3. Test both functions and log the results",
              "starterCode": "// System info function (simulating Bun environment)\nfunction getSystemInfo() {\n  return {\n    runtime: 'bun',\n    bunVersion: '1.2.0',\n    uptime: 12345\n  };\n}\n\n// Async file reading simulation\n// In real Bun: const file = Bun.file(filename); return file.text();\nfunction readConfig(filename) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(`Config from ${filename}`);\n    }, 100);\n  });\n}\n\n// Test the functions\nlet info = getSystemInfo();\nconsole.log('System:', info);\n\nreadConfig('app.config').then(data => {\n  console.log('Config:', data);\n});",
              "solution": "// Complete Bun utility module\n\n// System info function (simulating Bun environment)\nfunction getSystemInfo() {\n  return {\n    runtime: 'bun',\n    bunVersion: '1.2.0',\n    uptime: 12345,\n    features: ['typescript', 'bundler', 'test-runner']\n  };\n}\n\n// Async file reading simulation\n// In real Bun: const file = Bun.file(filename); return file.text();\nfunction readConfig(filename) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (!filename) {\n        reject(new Error('Filename is required'));\n      } else {\n        resolve(`Config from ${filename}`);\n      }\n    }, 100);\n  });\n}\n\n// Test the functions\nlet info = getSystemInfo();\nconsole.log('System info:', info);\nconsole.log('Runtime:', info.runtime);       // bun\nconsole.log('Bun version:', info.bunVersion); // 1.2.0\n\n// Test async config reading\nreadConfig('app.config').then(data => {\n  console.log('Config loaded:', data); // Config from app.config\n}).catch(error => {\n  console.log('Error:', error.message);\n});\n\n// Using async/await (modern pattern)\nasync function loadSystemConfig() {\n  try {\n    let config = await readConfig('database.config');\n    console.log('Database config:', config);\n  } catch (error) {\n    console.log('Failed to load config:', error.message);\n  }\n}\n\nloadSystemConfig();",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should return system info with bun runtime",
                  "expectedOutput": "bun",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should read config asynchronously",
                  "expectedOutput": "Config from test.config",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use new Promise((resolve, reject) => {...}) and setTimeout to simulate async operations."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using Node.js-specific APIs when Bun has simpler alternatives",
                  "consequence": "Code works but misses Bun's simpler patterns.",
                  "correction": "Use Bun.file() for file reading instead of fs.readFile(). Use import.meta.dir instead of __dirname workarounds."
                },
                {
                  "mistake": "Trying to use browser APIs in Bun",
                  "consequence": "ReferenceError: document/window is not defined",
                  "correction": "Bun runs on the server. Use server-side APIs like Bun.file(), Bun.serve(), and fetch()."
                },
                {
                  "mistake": "Installing TypeScript separately",
                  "consequence": "Unnecessary dependency and complexity.",
                  "correction": "Bun runs .ts files directly! Just use: bun run app.ts"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "10.2",
          "title": "Your First Hono Server (The Super-Efficient Manager Analogy)",
          "moduleId": "module-10",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine running a restaurant:\n\nWithout a manager (plain Bun.serve()):\n- You handle every customer request manually\n- You write the same instructions over and over\n- You manage reservations, orders, payments all yourself\n- Lots of repetitive work\n\nWith a super-efficient manager (Hono framework):\n- The manager handles common tasks LIGHTNING FAST\n- Organized system for taking orders (routes)\n- Standardized way to serve dishes (responses)\n- Easy to add new menu items (endpoints)\n- Works anywhere: kitchen, food truck, catering (multi-platform!)\n- Less work, more organized, and portable!\n\nHono is like an ultra-efficient, portable restaurant manager. It works with Bun, Node.js, Deno, and even in the cloud (Cloudflare Workers). It's the modern choice for building APIs in 2025!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Hono - The Ultra-Fast Web Framework (2025)\n// Note: This is simulated Hono code for learning\n\n// BASIC HONO SERVER STRUCTURE\n\n// In real Bun:\n// import { Hono } from 'hono';\n// const app = new Hono();\n\n// For this demo, we'll simulate Hono behavior:\nclass HonoApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n    console.log(`Route registered: GET ${path}`);\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n    console.log(`Route registered: POST ${path}`);\n  }\n  \n  simulateRequest(method, path, body = null) {\n    let route = this.routes.find(r => r.method === method && r.path === path);\n    if (route) {\n      // Hono uses a Context object (c) instead of req/res\n      let c = {\n        req: {\n          method,\n          path,\n          query: (key) => null,\n          param: (key) => null,\n          json: async () => body || {}\n        },\n        text: function(data, status = 200) {\n          console.log(`Response [${status}]:`, data);\n          return { status, body: data };\n        },\n        json: function(data, status = 200) {\n          console.log(`Response [${status}]:`, JSON.stringify(data));\n          return { status, body: data };\n        }\n      };\n      route.handler(c);\n    } else {\n      console.log(`404 Not Found: ${method} ${path}`);\n    }\n  }\n}\n\nlet app = new HonoApp();\n\n// ROUTE DEFINITIONS - Notice the simpler 'c' context pattern!\n\n// 1. Simple GET route - Homepage\napp.get('/', (c) => {\n  return c.text('Welcome to Hono!');\n});\n\n// 2. GET route returning JSON\napp.get('/api/status', (c) => {\n  return c.json({\n    status: 'online',\n    version: '1.0.0',\n    framework: 'Hono',\n    timestamp: Date.now()\n  });\n});\n\n// 3. GET route - List of users\napp.get('/api/users', (c) => {\n  let users = [\n    { id: 1, name: 'Alice', email: 'alice@example.com' },\n    { id: 2, name: 'Bob', email: 'bob@example.com' }\n  ];\n  return c.json(users);\n});\n\n// 4. POST route - Create new user\napp.post('/api/users', async (c) => {\n  // In real Hono: const body = await c.req.json();\n  let newUser = { id: 3, name: 'Charlie', email: 'charlie@example.com' };\n  \n  return c.json({\n    message: 'User created successfully',\n    user: newUser\n  }, 201);  // Status code as second argument!\n});\n\n// 5. Error response\napp.get('/api/error', (c) => {\n  return c.json({\n    error: 'Something went wrong!',\n    message: 'Internal server error'\n  }, 500);\n});\n\n// In real Bun, export the app:\n// export default app;\n// Then run: bun run app.ts\n\nconsole.log('\\nHono server routes registered!');\nconsole.log('In real Bun, export default app and run with: bun run app.ts');\n\n// SIMULATE REQUESTS\nconsole.log('\\n--- Simulating HTTP Requests ---\\n');\n\napp.simulateRequest('GET', '/');\napp.simulateRequest('GET', '/api/status');\napp.simulateRequest('GET', '/api/users');\napp.simulateRequest('POST', '/api/users');\napp.simulateRequest('GET', '/api/error');\napp.simulateRequest('GET', '/api/notfound');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding Hono fundamentals:\n\n1. **Creating a Hono App**:\n   ```javascript\n   import { Hono } from 'hono';\n   const app = new Hono();\n   ```\n   - `new Hono()` creates a new application\n   - `app` is your main server object\n\n2. **Route Methods** (HTTP verbs):\n   - `app.get()` - Read data\n   - `app.post()` - Create data\n   - `app.put()` - Update data (replace)\n   - `app.patch()` - Update data (partial)\n   - `app.delete()` - Delete data\n\n3. **The Context Object (c)**:\n   Unlike Express with separate req/res, Hono uses ONE context object:\n   ```javascript\n   app.get('/hello', (c) => {\n     // c has everything!\n     return c.text('Hello!');\n   });\n   ```\n\n4. **Accessing Request Data**:\n   - `c.req.param('id')` - URL parameters (`/users/:id`)\n   - `c.req.query('search')` - Query strings (`?search=hello`)\n   - `await c.req.json()` - POST/PUT body (async!)\n   - `c.req.header('Authorization')` - HTTP headers\n\n5. **Response Helpers**:\n   - `c.text('Hello')` - Send text\n   - `c.json({ data })` - Send JSON\n   - `c.json(data, 201)` - JSON with status code\n   - `c.html('<h1>Hi</h1>')` - Send HTML\n   - `c.redirect('/other')` - Redirect\n\n6. **Status Codes**:\n   - Pass as second argument: `c.json(data, 201)`\n   - 200: OK (success)\n   - 201: Created (new resource)\n   - 400: Bad Request (client error)\n   - 404: Not Found\n   - 500: Internal Server Error\n\n7. **Running the Server (Bun)**:\n   ```javascript\n   // app.ts\n   import { Hono } from 'hono';\n   const app = new Hono();\n   \n   app.get('/', (c) => c.text('Hello!'));\n   \n   export default app;  // Bun auto-serves!\n   ```\n   Run with: `bun run app.ts`"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Node.js/Express Equivalent",
              "legacy": "express",
              "content": "Hono and Express are similar, but Hono is simpler and more modern. The main difference is Hono's unified context object (c) vs Express's separate req/res.",
              "code": "// Express way (Node.js)\nimport express from 'express';\nconst app = express();\n\napp.use(express.json()); // Need middleware for JSON!\n\n// Two separate objects: req and res\napp.get('/api/users', (req, res) => {\n  res.json([{ id: 1, name: 'Alice' }]);\n});\n\napp.post('/api/users', (req, res) => {\n  const body = req.body;  // Already parsed\n  res.status(201).json({ message: 'Created', user: body });\n});\n\napp.listen(3000, () => {\n  console.log('Server on port 3000');\n});\n\n// vs Hono way (cleaner!)\n// import { Hono } from 'hono';\n// const app = new Hono();\n// \n// app.get('/api/users', (c) => c.json([...]));\n// app.post('/api/users', async (c) => {\n//   const body = await c.req.json();\n//   return c.json({ message: 'Created' }, 201);\n// });\n// \n// export default app;  // That's it!",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Hono mistakes:\n\n1. **Forgetting to return the response**:\n   ```javascript\n   app.get('/api/users', (c) => {\n     c.json({ data: 'hello' });  // Missing return!\n   });\n   \n   // Correct:\n   app.get('/api/users', (c) => {\n     return c.json({ data: 'hello' });  // Always return!\n   });\n   ```\n\n2. **Forgetting async for body parsing**:\n   ```javascript\n   // Wrong - req.json() is async!\n   app.post('/api/users', (c) => {\n     const body = c.req.json();  // This is a Promise!\n   });\n   \n   // Correct:\n   app.post('/api/users', async (c) => {\n     const body = await c.req.json();  // Await it!\n   });\n   ```\n\n3. **Using Express patterns by mistake**:\n   ```javascript\n   // Express style (won't work in Hono!):\n   app.get('/users', (req, res) => {\n     res.json({ data });\n   });\n   \n   // Hono style:\n   app.get('/users', (c) => {\n     return c.json({ data });\n   });\n   ```\n\n4. **Route order still matters**:\n   ```javascript\n   app.get('/api/users/active', ...);  // Specific first\n   app.get('/api/users/:id', ...);     // Generic after\n   ```\n\n5. **Not exporting for Bun**:\n   ```javascript\n   // For Bun to serve your app:\n   export default app;  // Don't forget this!\n   \n   // Or with custom port:\n   export default {\n     port: 3000,\n     fetch: app.fetch\n   };\n   ```\n\n6. **Status code position**:\n   ```javascript\n   // Hono: status is SECOND argument\n   return c.json({ error: 'Not found' }, 404);\n   \n   // NOT like Express: res.status(404).json(...)\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.2-challenge",
              "title": "Practice Challenge",
              "description": "Create a simple API for a todo list using Hono patterns:\n\n1. Create a GET route `/api/todos` that returns an array of todo objects\n   - Each todo should have: id, task, completed\n   - Use c.json() to return the data\n\n2. Create a POST route `/api/todos` that:\n   - Simulates creating a new todo\n   - Returns status 201 and the new todo using c.json(data, 201)\n\n3. Create a GET route `/api/todos/completed` that:\n   - Returns only completed todos\n\nUse the HonoApp class from the example. Simulate requests to test your routes.",
              "instructions": "Create a simple API for a todo list using Hono patterns:\n\n1. Create a GET route `/api/todos` that returns an array of todo objects\n   - Each todo should have: id, task, completed\n   - Use c.json() to return the data\n\n2. Create a POST route `/api/todos` that:\n   - Simulates creating a new todo\n   - Returns status 201 and the new todo using c.json(data, 201)\n\n3. Create a GET route `/api/todos/completed` that:\n   - Returns only completed todos\n\nUse the HonoApp class from the example. Simulate requests to test your routes.",
              "starterCode": "// Hono app simulation\nclass HonoApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n  }\n  \n  simulateRequest(method, path) {\n    let route = this.routes.find(r => r.method === method && r.path === path);\n    if (route) {\n      let c = {\n        req: { method, path },\n        json: function(data, status = 200) {\n          console.log(`[${status}]`, JSON.stringify(data));\n          return { status, body: data };\n        }\n      };\n      route.handler(c);\n    }\n  }\n}\n\nlet app = new HonoApp();\n\n// Sample todo data\nlet todos = [\n  { id: 1, task: 'Learn Hono', completed: false },\n  { id: 2, task: 'Build an API', completed: true }\n];\n\n// TODO: Add your routes here using the Hono pattern\n// Remember: (c) => { return c.json(data); }\n\n// Test your routes\napp.simulateRequest('GET', '/api/todos');\napp.simulateRequest('POST', '/api/todos');\napp.simulateRequest('GET', '/api/todos/completed');",
              "solution": "// Hono app simulation\nclass HonoApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n  }\n  \n  simulateRequest(method, path) {\n    let route = this.routes.find(r => r.method === method && r.path === path);\n    if (route) {\n      let c = {\n        req: { method, path },\n        json: function(data, status = 200) {\n          console.log(`[${status}]`, JSON.stringify(data));\n          return { status, body: data };\n        }\n      };\n      route.handler(c);\n    }\n  }\n}\n\nlet app = new HonoApp();\n\n// Sample todo data\nlet todos = [\n  { id: 1, task: 'Learn Hono', completed: false },\n  { id: 2, task: 'Build an API', completed: true },\n  { id: 3, task: 'Deploy app', completed: true }\n];\n\n// Route 1: Get all todos (Hono pattern)\napp.get('/api/todos', (c) => {\n  return c.json(todos);\n});\n\n// Route 2: Create new todo (with 201 status)\napp.post('/api/todos', (c) => {\n  let newTodo = {\n    id: todos.length + 1,\n    task: 'New task',\n    completed: false\n  };\n  todos.push(newTodo);\n  \n  return c.json({\n    message: 'Todo created',\n    todo: newTodo\n  }, 201);  // Status as second argument!\n});\n\n// Route 3: Get completed todos only\napp.get('/api/todos/completed', (c) => {\n  let completedTodos = todos.filter(t => t.completed);\n  return c.json(completedTodos);\n});\n\n// Test the routes\nconsole.log('All todos:');\napp.simulateRequest('GET', '/api/todos');\n\nconsole.log('\\nCreate todo:');\napp.simulateRequest('POST', '/api/todos');\n\nconsole.log('\\nCompleted todos:');\napp.simulateRequest('GET', '/api/todos/completed');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should return all todos using c.json()",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should filter completed todos",
                  "expectedOutput": "1",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "In Hono, use (c) => { return c.json(data); } pattern. For status codes, pass as second argument: c.json(data, 201)"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to return the response in Hono",
                  "consequence": "The route handler returns undefined and no response is sent.",
                  "correction": "Always return c.json(), c.text(), etc. Example: return c.json({ data });"
                },
                {
                  "mistake": "Using Express (req, res) pattern instead of Hono (c) pattern",
                  "consequence": "Code will not work correctly with Hono's context object.",
                  "correction": "Use (c) => { return c.json(data); } instead of (req, res) => { res.json(data); }"
                },
                {
                  "mistake": "Putting status code in wrong place",
                  "consequence": "Status code may not be set correctly.",
                  "correction": "In Hono, status is the second argument: c.json(data, 201)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "10.3",
          "title": "Routing and Parameters in Hono (The Address System Analogy)",
          "moduleId": "module-10",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine delivering packages in a city:\n\nSimple addresses (static routes):\n- 123 Main Street (exact address)\n- City Hall (exact location)\n- Central Park (exact destination)\n\nDynamic addresses (parameterized routes):\n- \"Apartment {number} on Floor {floor}\" -> Many apartments, one pattern\n- \"House number {X} on {Street Name}\" -> Any house, flexible pattern\n- \"Locker {number} at Gym\" -> Dynamic, but follows a pattern\n\nHono routing works the same way:\n- Static routes: `/about`, `/contact` (exact paths)\n- Dynamic routes: `/users/:id`, `/products/:category/:item` (pattern-based)\n\nParameters let you create one route that handles many similar requests!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Hono - Advanced Routing (2025)\n\n// Simulated Hono with routing features\nclass HonoApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  simulateRequest(method, url) {\n    console.log(`\\n${method} ${url}`);\n    \n    for (let route of this.routes) {\n      if (route.method !== method) continue;\n      \n      let params = this.matchRoute(route.path, url);\n      if (params !== null) {\n        let [path, queryString] = url.split('?');\n        let queryObj = this.parseQuery(queryString);\n        \n        // Hono uses context object (c) with methods\n        let c = {\n          req: {\n            param: (key) => params[key],\n            query: (key) => queryObj[key],\n            url: url\n          },\n          json: function(data, status = 200) {\n            console.log(`Response [${status}]:`, JSON.stringify(data));\n            return { status, body: data };\n          }\n        };\n        \n        route.handler(c);\n        return;\n      }\n    }\n    \n    console.log('404 Not Found');\n  }\n  \n  matchRoute(pattern, url) {\n    let [urlPath] = url.split('?');\n    let patternParts = pattern.split('/');\n    let urlParts = urlPath.split('/');\n    \n    if (patternParts.length !== urlParts.length) return null;\n    \n    let params = {};\n    for (let i = 0; i < patternParts.length; i++) {\n      if (patternParts[i].startsWith(':')) {\n        let paramName = patternParts[i].slice(1);\n        params[paramName] = urlParts[i];\n      } else if (patternParts[i] !== urlParts[i]) {\n        return null;\n      }\n    }\n    return params;\n  }\n  \n  parseQuery(queryString) {\n    if (!queryString) return {};\n    let query = {};\n    queryString.split('&').forEach(pair => {\n      let [key, value] = pair.split('=');\n      query[key] = value;\n    });\n    return query;\n  }\n}\n\nlet app = new HonoApp();\n\n// ROUTE PARAMETERS (Dynamic segments in URL)\n\n// 1. Single parameter - Get user by ID\n// In Hono: use c.req.param('id') to get the parameter\napp.get('/api/users/:id', (c) => {\n  let userId = c.req.param('id');\n  \n  // Simulate database lookup\n  let user = {\n    id: userId,\n    name: 'Alice',\n    email: 'alice@example.com'\n  };\n  \n  return c.json(user);\n});\n\n// 2. Multiple parameters - Get specific product\napp.get('/api/products/:category/:productId', (c) => {\n  let category = c.req.param('category');\n  let productId = c.req.param('productId');\n  \n  return c.json({\n    category: category,\n    productId: productId,\n    name: 'Sample Product',\n    price: 29.99\n  });\n});\n\n// 3. Query parameters - Search and filter\n// In Hono: use c.req.query('key') to get query params\napp.get('/api/search', (c) => {\n  let q = c.req.query('q');\n  let category = c.req.query('category');\n  let minPrice = c.req.query('minPrice');\n  let maxPrice = c.req.query('maxPrice');\n  \n  return c.json({\n    searchTerm: q || 'none',\n    category: category || 'all',\n    priceRange: {\n      min: minPrice || 0,\n      max: maxPrice || 'unlimited'\n    },\n    results: [\n      { id: 1, name: 'Product A' },\n      { id: 2, name: 'Product B' }\n    ]\n  });\n});\n\n// 4. Combining params and query\napp.get('/api/categories/:category/products', (c) => {\n  let category = c.req.param('category');\n  let sort = c.req.query('sort');\n  let limit = c.req.query('limit');\n  \n  return c.json({\n    category: category,\n    sortBy: sort || 'name',\n    limit: limit || 10,\n    products: ['Product 1', 'Product 2']\n  });\n});\n\n// TEST THE ROUTES\n\n// Parameter examples\napp.simulateRequest('GET', '/api/users/42');\napp.simulateRequest('GET', '/api/users/999');\n\napp.simulateRequest('GET', '/api/products/electronics/laptop-123');\napp.simulateRequest('GET', '/api/products/books/novel-456');\n\n// Query parameter examples  \napp.simulateRequest('GET', '/api/search?q=laptop&category=electronics&minPrice=500&maxPrice=2000');\napp.simulateRequest('GET', '/api/search?q=headphones');\n\n// Combined params and query\napp.simulateRequest('GET', '/api/categories/electronics/products?sort=price&limit=20');\napp.simulateRequest('GET', '/api/categories/books/products');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding Hono routing:\n\n1. **Route Parameters** (`:paramName`):\n   ```javascript\n   app.get('/users/:id', (c) => {\n     const id = c.req.param('id');  // Extract from URL\n     return c.json({ id });\n   });\n   ```\n   - Colon `:` marks a parameter\n   - Use `c.req.param('name')` to get the value\n   - `/users/42` -> `c.req.param('id')` returns `'42'`\n\n2. **Multiple Parameters**:\n   ```javascript\n   app.get('/posts/:year/:month/:day', (c) => {\n     const year = c.req.param('year');\n     const month = c.req.param('month');\n     const day = c.req.param('day');\n     return c.json({ year, month, day });\n   });\n   ```\n\n3. **Query Parameters** (after `?`):\n   ```javascript\n   // URL: /search?q=hono&page=2\n   app.get('/search', (c) => {\n     const searchTerm = c.req.query('q');     // 'hono'\n     const page = c.req.query('page');        // '2'\n     return c.json({ searchTerm, page });\n   });\n   ```\n   - Not part of the route pattern\n   - Optional by default\n   - Use `c.req.query('key')` to access\n\n4. **Parameter vs Query - When to Use**:\n   - **Route parameters** (`:id`):\n     * Required parts of the URL\n     * Identifying resources\n     * `/users/:userId/posts/:postId`\n   \n   - **Query parameters** (`?key=value`):\n     * Optional filters\n     * Search terms\n     * Pagination, sorting\n     * `/products?category=books&sort=price&page=2`\n\n5. **Accessing Data in Hono**:\n   - `c.req.param('key')` -> Single URL parameter\n   - `c.req.query('key')` -> Single query parameter\n   - `await c.req.json()` -> POST/PUT body (async!)\n   - `c.req.header('key')` -> Request headers\n\n6. **Type Conversion**:\n   ```javascript\n   app.get('/api/users/:id', (c) => {\n     // c.req.param() always returns STRING\n     const userId = parseInt(c.req.param('id'));\n     const page = parseInt(c.req.query('page')) || 1;\n     return c.json({ userId, page });\n   });\n   ```\n   All parameters come as strings - convert as needed!"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Node.js/Express Equivalent",
              "legacy": "express",
              "content": "Hono uses method calls instead of object properties for accessing parameters. This is slightly different from Express but provides a cleaner API.",
              "code": "// Express way - object properties\napp.get('/users/:id', (req, res) => {\n  const id = req.params.id;         // Object property\n  const search = req.query.search;  // Object property\n  res.json({ id, search });\n});\n\n// Hono way - method calls\napp.get('/users/:id', (c) => {\n  const id = c.req.param('id');     // Method call\n  const search = c.req.query('search'); // Method call\n  return c.json({ id, search });\n});\n\n// Key differences:\n// Express: req.params.id, req.query.search, req.body\n// Hono: c.req.param('id'), c.req.query('search'), await c.req.json()",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Hono routing mistakes:\n\n1. **Using Express object syntax**:\n   ```javascript\n   // Wrong - Express style!\n   app.get('/users/:id', (c) => {\n     const id = c.req.params.id;  // undefined!\n   });\n   \n   // Correct - Hono method style!\n   app.get('/users/:id', (c) => {\n     const id = c.req.param('id');  // Works!\n   });\n   ```\n\n2. **Parameter type confusion**:\n   ```javascript\n   app.get('/users/:id', (c) => {\n     const id = c.req.param('id');\n     if (id > 100) {  // String comparison! '9' > '100' is true!\n       // Wrong!\n     }\n     \n     // Correct:\n     if (parseInt(id) > 100) {\n       // Right!\n     }\n   });\n   ```\n\n3. **Route order conflicts**:\n   ```javascript\n   // Wrong order!\n   app.get('/users/:id', ...);        // Matches EVERYTHING\n   app.get('/users/active', ...);     // Never reached!\n   \n   // Correct order:\n   app.get('/users/active', ...);     // Specific first\n   app.get('/users/:id', ...);        // Generic last\n   ```\n\n4. **Forgetting to return response**:\n   ```javascript\n   app.get('/search', (c) => {\n     const q = c.req.query('q');\n     c.json({ query: q });  // Missing return!\n   });\n   \n   // Correct:\n   app.get('/search', (c) => {\n     const q = c.req.query('q');\n     return c.json({ query: q });  // Always return!\n   });\n   ```\n\n5. **Missing query parameters**:\n   ```javascript\n   app.get('/search', (c) => {\n     const limit = c.req.query('limit');  // undefined if not provided!\n     \n     // Better:\n     const limit = c.req.query('limit') || '10';\n     const limitNum = parseInt(c.req.query('limit')) || 10;\n   });\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.3-challenge",
              "title": "Practice Challenge",
              "description": "Create a blog API with Hono routing patterns:\n\n1. GET `/api/posts/:postId` - Get a specific post by ID\n   - Use c.req.param('postId') to get the ID\n   - Return object with: postId, title, content\n\n2. GET `/api/authors/:authorId/posts` - Get all posts by an author\n   - Use c.req.param('authorId')\n   - Return array of posts with authorId in each\n\n3. GET `/api/posts` with query parameters - Search posts\n   - Use c.req.query() for: search, category, limit\n   - Return search parameters and mock results\n\nUse the HonoApp class. Remember to use return c.json()!",
              "instructions": "Create a blog API with Hono routing patterns:\n\n1. GET `/api/posts/:postId` - Get a specific post by ID\n   - Use c.req.param('postId') to get the ID\n   - Return object with: postId, title, content\n\n2. GET `/api/authors/:authorId/posts` - Get all posts by an author\n   - Use c.req.param('authorId')\n   - Return array of posts with authorId in each\n\n3. GET `/api/posts` with query parameters - Search posts\n   - Use c.req.query() for: search, category, limit\n   - Return search parameters and mock results\n\nUse the HonoApp class. Remember to use return c.json()!",
              "starterCode": "class HonoApp {\n  constructor() { this.routes = []; }\n  get(path, handler) { this.routes.push({ method: 'GET', path, handler }); }\n  simulateRequest(method, url) {\n    console.log(`\\n${method} ${url}`);\n    for (let route of this.routes) {\n      if (route.method !== method) continue;\n      let params = this.matchRoute(route.path, url);\n      if (params !== null) {\n        let [path, queryString] = url.split('?');\n        let queryObj = this.parseQuery(queryString);\n        let c = {\n          req: {\n            param: (key) => params[key],\n            query: (key) => queryObj[key]\n          },\n          json: function(d, status = 200) {\n            console.log(`[${status}]`, JSON.stringify(d));\n            return { status, body: d };\n          }\n        };\n        route.handler(c);\n        return;\n      }\n    }\n  }\n  matchRoute(pattern, url) {\n    let [urlPath] = url.split('?');\n    let patternParts = pattern.split('/');\n    let urlParts = urlPath.split('/');\n    if (patternParts.length !== urlParts.length) return null;\n    let params = {};\n    for (let i = 0; i < patternParts.length; i++) {\n      if (patternParts[i].startsWith(':')) {\n        params[patternParts[i].slice(1)] = urlParts[i];\n      } else if (patternParts[i] !== urlParts[i]) return null;\n    }\n    return params;\n  }\n  parseQuery(qs) {\n    if (!qs) return {};\n    let q = {};\n    qs.split('&').forEach(p => { let [k,v] = p.split('='); q[k] = v; });\n    return q;\n  }\n}\n\nlet app = new HonoApp();\n\n// TODO: Add your routes here using Hono patterns\n// Remember: c.req.param('key') and c.req.query('key')\n\n// Test routes\napp.simulateRequest('GET', '/api/posts/123');\napp.simulateRequest('GET', '/api/authors/42/posts');\napp.simulateRequest('GET', '/api/posts?search=hono&category=tech&limit=5');",
              "solution": "class HonoApp {\n  constructor() { this.routes = []; }\n  get(path, handler) { this.routes.push({ method: 'GET', path, handler }); }\n  simulateRequest(method, url) {\n    console.log(`\\n${method} ${url}`);\n    for (let route of this.routes) {\n      if (route.method !== method) continue;\n      let params = this.matchRoute(route.path, url);\n      if (params !== null) {\n        let [path, queryString] = url.split('?');\n        let queryObj = this.parseQuery(queryString);\n        let c = {\n          req: {\n            param: (key) => params[key],\n            query: (key) => queryObj[key]\n          },\n          json: function(d, status = 200) {\n            console.log(`[${status}]`, JSON.stringify(d, null, 2));\n            return { status, body: d };\n          }\n        };\n        route.handler(c);\n        return;\n      }\n    }\n    console.log('404 Not Found');\n  }\n  matchRoute(pattern, url) {\n    let [urlPath] = url.split('?');\n    let patternParts = pattern.split('/');\n    let urlParts = urlPath.split('/');\n    if (patternParts.length !== urlParts.length) return null;\n    let params = {};\n    for (let i = 0; i < patternParts.length; i++) {\n      if (patternParts[i].startsWith(':')) {\n        params[patternParts[i].slice(1)] = urlParts[i];\n      } else if (patternParts[i] !== urlParts[i]) return null;\n    }\n    return params;\n  }\n  parseQuery(qs) {\n    if (!qs) return {};\n    let q = {};\n    qs.split('&').forEach(p => { let [k,v] = p.split('='); q[k] = v; });\n    return q;\n  }\n}\n\nlet app = new HonoApp();\n\n// Route 1: Get specific post using c.req.param()\napp.get('/api/posts/:postId', (c) => {\n  const postId = c.req.param('postId');\n  \n  return c.json({\n    postId: postId,\n    title: `Post ${postId} Title`,\n    content: 'This is the post content...',\n    author: 'Alice'\n  });\n});\n\n// Route 2: Get posts by author\napp.get('/api/authors/:authorId/posts', (c) => {\n  const authorId = c.req.param('authorId');\n  \n  return c.json({\n    authorId: authorId,\n    posts: [\n      { id: 1, title: 'First Post', content: 'Content 1' },\n      { id: 2, title: 'Second Post', content: 'Content 2' }\n    ]\n  });\n});\n\n// Route 3: Search posts with c.req.query()\napp.get('/api/posts', (c) => {\n  const search = c.req.query('search');\n  const category = c.req.query('category');\n  const limit = c.req.query('limit');\n  \n  return c.json({\n    search: search || 'all',\n    category: category || 'all',\n    limit: limit || '10',\n    results: [\n      { id: 1, title: 'Hono Tutorial', category: 'tech' },\n      { id: 2, title: 'Bun Guide', category: 'tech' }\n    ]\n  });\n});\n\n// Test all routes\napp.simulateRequest('GET', '/api/posts/123');\napp.simulateRequest('GET', '/api/authors/42/posts');\napp.simulateRequest('GET', '/api/posts?search=hono&category=tech&limit=5');\napp.simulateRequest('GET', '/api/posts');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should extract post ID using c.req.param()",
                  "expectedOutput": "123",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should parse query parameters using c.req.query()",
                  "expectedOutput": "10",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "In Hono, use c.req.param('postId') for URL parameters and c.req.query('search') for query strings. Always return c.json()!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using Express req.params.id instead of Hono c.req.param('id')",
                  "consequence": "Returns undefined because Hono uses method calls, not object properties.",
                  "correction": "Use c.req.param('id') for URL parameters and c.req.query('key') for query strings."
                },
                {
                  "mistake": "Forgetting to return the response in route handlers",
                  "consequence": "No response is sent to the client.",
                  "correction": "Always use return c.json(...) or return c.text(...)"
                },
                {
                  "mistake": "Route order conflicts with dynamic segments",
                  "consequence": "Specific routes like /users/active get matched by /users/:id first.",
                  "correction": "Place specific routes before parameterized routes: /users/active before /users/:id"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "10.4",
          "title": "Hono Middleware (The Assembly Line Analogy)",
          "moduleId": "module-10",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a factory assembly line:\n\nWithout assembly line (no middleware):\n- One worker does EVERYTHING for each product\n- Unwrap materials, assemble, test, package, label\n- Repetitive, inefficient, error-prone\n\nWith assembly line (middleware):\n- Station 1: Unwrap and inspect materials (authentication)\n- Station 2: Assemble parts (body parsing)\n- Station 3: Quality check (validation)\n- Station 4: Package product (route handler)\n- Station 5: Add label (response formatting)\n\nEach station does one job, passes to the next!\n\nHono middleware works the same way:\n- Request comes in\n- Passes through middleware functions in order\n- Each middleware does one specific task\n- Calls await next() to continue\n- Finally reaches your route handler\n- Response goes back to client\n\nMiddleware = functions that process requests before they reach your routes!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Hono - Middleware (2025)\n\n// Simulated Hono with middleware support\nclass HonoApp {\n  constructor() {\n    this.routes = [];\n    this.middleware = [];\n  }\n  \n  use(pattern, handler) {\n    // Hono middleware signature: app.use('*', handler)\n    // or app.use('/api/*', handler) for path-specific\n    if (typeof pattern === 'function') {\n      handler = pattern;\n      pattern = '*';\n    }\n    this.middleware.push({ pattern, handler });\n    console.log(`Middleware registered for: ${pattern}`);\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n  }\n  \n  async simulateRequest(method, path, body = null) {\n    console.log(`\\n--- ${method} ${path} ---`);\n    \n    // Create Hono-style context\n    let c = {\n      req: {\n        method,\n        path,\n        header: (key) => key === 'Authorization' ? 'Bearer valid-token' : null,\n        json: async () => body || {}\n      },\n      // Context can store data via c.set() and c.get()\n      _store: {},\n      set: function(key, value) { this._store[key] = value; },\n      get: function(key) { return this._store[key]; },\n      json: function(data, status = 200) {\n        console.log(`Response [${status}]:`, JSON.stringify(data));\n        return { status, body: data };\n      },\n      text: function(data, status = 200) {\n        console.log(`Response [${status}]:`, data);\n        return { status, body: data };\n      }\n    };\n    \n    // Run middleware chain with async/await\n    let middlewareIndex = 0;\n    \n    let next = async () => {\n      if (middlewareIndex < this.middleware.length) {\n        let currentMiddleware = this.middleware[middlewareIndex++];\n        await currentMiddleware.handler(c, next);\n      } else {\n        // Middleware done, find and run route handler\n        let route = this.routes.find(r => r.method === method && r.path === path);\n        if (route) {\n          return route.handler(c);\n        } else {\n          return c.json({ error: 'Not found' }, 404);\n        }\n      }\n    };\n    \n    await next();\n  }\n}\n\nlet app = new HonoApp();\n\n// HONO MIDDLEWARE EXAMPLES\n// Note: Hono middleware uses (c, next) pattern with async/await\n\n// 1. Logging Middleware - Runs on EVERY request\napp.use('*', async (c, next) => {\n  console.log(`[LOG] ${c.req.method} ${c.req.path}`);\n  const start = Date.now();\n  \n  await next();  // MUST await next() to continue!\n  \n  // Code AFTER next() runs after route handler\n  const duration = Date.now() - start;\n  console.log(`[TIMING] Request took ${duration}ms`);\n});\n\n// 2. Authentication Middleware\napp.use('*', async (c, next) => {\n  const token = c.req.header('Authorization');\n  \n  if (token === 'Bearer valid-token') {\n    // Store user in context using c.set()\n    c.set('user', { id: 1, name: 'Alice', role: 'admin' });\n    console.log('[AUTH] User authenticated:', c.get('user').name);\n    await next();\n  } else {\n    console.log('[AUTH] Invalid token!');\n    return c.json({ error: 'Unauthorized' }, 401);\n    // Note: No next() call - request stops here!\n  }\n});\n\n// 3. Request Validator Middleware (for POST)\napp.use('*', async (c, next) => {\n  if (c.req.method === 'POST') {\n    const body = await c.req.json();\n    c.set('body', body);  // Store parsed body for route\n    console.log('[PARSER] Parsed JSON body');\n  }\n  await next();\n});\n\n// ROUTES (run AFTER middleware)\n\napp.get('/api/public', (c) => {\n  const user = c.get('user');\n  return c.json({ \n    message: 'Public endpoint',\n    user: user ? user.name : 'anonymous'\n  });\n});\n\napp.get('/api/protected', (c) => {\n  // Get user from context (set by auth middleware)\n  const user = c.get('user');\n  return c.json({ \n    message: 'Protected data',\n    user: user.name,\n    role: user.role\n  });\n});\n\napp.post('/api/data', (c) => {\n  const body = c.get('body');  // Get parsed body from middleware\n  const user = c.get('user');\n  return c.json({ \n    message: 'Data received',\n    data: body,\n    processedBy: user.name\n  });\n});\n\n// TEST MIDDLEWARE CHAIN\n\napp.simulateRequest('GET', '/api/public');\napp.simulateRequest('GET', '/api/protected');\napp.simulateRequest('POST', '/api/data', { title: 'Test', value: 42 });"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding Hono middleware:\n\n1. **Middleware Signature**: `async (c, next) => { ... }`\n   - `c`: Context object (has req, response helpers, storage)\n   - `next`: Async function to call the next middleware\n   - MUST await `next()` to continue the chain!\n\n2. **Registering Middleware**: `app.use('*', middlewareFunction)`\n   - `'*'` means run on ALL routes\n   - `'/api/*'` runs only on /api routes\n   - Order matters - middleware runs in order you add it\n\n3. **Middleware Flow**:\n   ```\n   Request -> Middleware 1 -> Middleware 2 -> Route Handler\n                   |                |              |\n                   v                v              v\n             (before next)    (before next)   (handler)\n                   |                |              |\n                   v                v              v\n             (after next)     (after next)    Response\n   ```\n\n4. **Context Storage** (c.set/c.get):\n   ```javascript\n   // In middleware\n   app.use('*', async (c, next) => {\n     c.set('user', { id: 1, name: 'Alice' });\n     await next();\n   });\n   \n   // In route handler\n   app.get('/profile', (c) => {\n     const user = c.get('user');  // Access stored data!\n     return c.json(user);\n   });\n   ```\n\n5. **Before and After next()**:\n   ```javascript\n   app.use('*', async (c, next) => {\n     console.log('Before route handler');  // Runs first\n     const start = Date.now();\n     \n     await next();  // Route handler runs here\n     \n     const ms = Date.now() - start;  // Runs after\n     console.log(`Request took ${ms}ms`);\n   });\n   ```\n\n6. **Stopping the Chain**:\n   ```javascript\n   app.use('*', async (c, next) => {\n     if (!isAuthorized(c)) {\n       return c.json({ error: 'Unauthorized' }, 401);\n       // No next() - request stops here!\n     }\n     await next();\n   });\n   ```\n\n7. **Built-in Hono Middleware**:\n   ```javascript\n   import { cors } from 'hono/cors';\n   import { logger } from 'hono/logger';\n   import { prettyJSON } from 'hono/pretty-json';\n   \n   app.use('*', logger());\n   app.use('*', cors());\n   app.use('*', prettyJSON());\n   ```"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Node.js/Express Equivalent",
              "legacy": "express",
              "content": "Hono middleware is simpler than Express. The key differences are: unified context object, async/await by default, and c.set()/c.get() for data storage instead of mutating req.",
              "code": "// Express middleware (older pattern)\napp.use((req, res, next) => {\n  req.user = { id: 1, name: 'Alice' };  // Mutate req object\n  next();  // Not async by default\n});\n\napp.get('/profile', (req, res) => {\n  res.json(req.user);  // Access from req\n});\n\n// Hono middleware (modern pattern)\napp.use('*', async (c, next) => {\n  c.set('user', { id: 1, name: 'Alice' });  // Use context storage\n  await next();  // Async by default\n});\n\napp.get('/profile', (c) => {\n  const user = c.get('user');  // Access from context\n  return c.json(user);\n});\n\n// Key differences:\n// Express: (req, res, next) with next() callback\n// Hono: async (c, next) with await next()\n// Express: req.user = data (mutation)\n// Hono: c.set('user', data) (storage)",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Hono middleware mistakes:\n\n1. **Forgetting to await next()**:\n   ```javascript\n   app.use('*', async (c, next) => {\n     console.log('Request received');\n     next();  // Missing await! Middleware continues before route finishes\n   });\n   \n   // Correct:\n   app.use('*', async (c, next) => {\n     console.log('Request received');\n     await next();  // Properly waits for chain to complete\n   });\n   ```\n\n2. **Returning after next()**:\n   ```javascript\n   app.use('*', async (c, next) => {\n     await next();\n     return c.json({ data: 'oops' });  // This overwrites route response!\n   });\n   \n   // Correct - don't return after next() unless intentional:\n   app.use('*', async (c, next) => {\n     await next();\n     // Just add logging, don't return a response\n     console.log('Request completed');\n   });\n   ```\n\n3. **Using Express patterns**:\n   ```javascript\n   // Wrong - Express style!\n   app.use((req, res, next) => {\n     req.user = { name: 'Alice' };\n     next();\n   });\n   \n   // Correct - Hono style!\n   app.use('*', async (c, next) => {\n     c.set('user', { name: 'Alice' });\n     await next();\n   });\n   ```\n\n4. **Forgetting the path pattern**:\n   ```javascript\n   // Hono requires a pattern (usually '*')\n   app.use('*', async (c, next) => { ... });\n   \n   // For specific paths:\n   app.use('/api/*', async (c, next) => { ... });\n   ```\n\n5. **Not handling errors in async middleware**:\n   ```javascript\n   app.use('*', async (c, next) => {\n     try {\n       await someAsyncOperation();\n       await next();\n     } catch (error) {\n       return c.json({ error: error.message }, 500);\n     }\n   });\n   ```\n\n6. **Wrong middleware order**:\n   - Authentication should come before route handlers\n   - Logging should come first (to catch all requests)\n   - Error handlers should come last"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.4-challenge",
              "title": "Practice Challenge",
              "description": "Create a middleware system for a blog API using Hono patterns:\n\n1. Create a logging middleware that logs the method and path\n2. Create a validation middleware that:\n   - For POST requests, parses the body and checks for 'title'\n   - If missing, return 400 error using c.json(error, 400)\n   - If present, store body using c.set('body', body) and await next()\n3. Create a route POST `/api/posts` that:\n   - Gets the body using c.get('body')\n   - Returns the post data with a generated ID\n4. Test with valid and invalid requests\n\nUse the HonoApp class. Remember: async (c, next) and await next()!",
              "instructions": "Create a middleware system for a blog API using Hono patterns:\n\n1. Create a logging middleware that logs the method and path\n2. Create a validation middleware that:\n   - For POST requests, parses the body and checks for 'title'\n   - If missing, return 400 error using c.json(error, 400)\n   - If present, store body using c.set('body', body) and await next()\n3. Create a route POST `/api/posts` that:\n   - Gets the body using c.get('body')\n   - Returns the post data with a generated ID\n4. Test with valid and invalid requests\n\nUse the HonoApp class. Remember: async (c, next) and await next()!",
              "starterCode": "class HonoApp {\n  constructor() { this.routes = []; this.middleware = []; }\n  use(pattern, handler) {\n    if (typeof pattern === 'function') { handler = pattern; pattern = '*'; }\n    this.middleware.push({ pattern, handler });\n  }\n  post(path, handler) { this.routes.push({ method: 'POST', path, handler }); }\n  async simulateRequest(method, path, body) {\n    console.log(`\\n${method} ${path}`);\n    let c = {\n      req: { method, path, json: async () => body || {} },\n      _store: {},\n      set: function(k, v) { this._store[k] = v; },\n      get: function(k) { return this._store[k]; },\n      json: function(d, s = 200) {\n        console.log(`[${s}]`, JSON.stringify(d));\n        return { status: s, body: d };\n      }\n    };\n    let i = 0;\n    let next = async () => {\n      if (i < this.middleware.length) {\n        await this.middleware[i++].handler(c, next);\n      } else {\n        let route = this.routes.find(r => r.method === method && r.path === path);\n        if (route) return route.handler(c);\n      }\n    };\n    await next();\n  }\n}\n\nlet app = new HonoApp();\n\n// TODO: Add logging middleware\n// app.use('*', async (c, next) => { ... await next(); });\n\n// TODO: Add validation middleware\n\n// TODO: Add POST route\n\n// Test\napp.simulateRequest('POST', '/api/posts', { title: 'My Post', content: 'Hello' });\napp.simulateRequest('POST', '/api/posts', { content: 'No title!' });",
              "solution": "class HonoApp {\n  constructor() { this.routes = []; this.middleware = []; }\n  use(pattern, handler) {\n    if (typeof pattern === 'function') { handler = pattern; pattern = '*'; }\n    this.middleware.push({ pattern, handler });\n  }\n  post(path, handler) { this.routes.push({ method: 'POST', path, handler }); }\n  async simulateRequest(method, path, body) {\n    console.log(`\\n${method} ${path}`);\n    let c = {\n      req: { method, path, json: async () => body || {} },\n      _store: {},\n      set: function(k, v) { this._store[k] = v; },\n      get: function(k) { return this._store[k]; },\n      json: function(d, s = 200) {\n        console.log(`[${s}]`, JSON.stringify(d));\n        return { status: s, body: d };\n      }\n    };\n    let i = 0;\n    let next = async () => {\n      if (i < this.middleware.length) {\n        await this.middleware[i++].handler(c, next);\n      } else {\n        let route = this.routes.find(r => r.method === method && r.path === path);\n        if (route) return route.handler(c);\n      }\n    };\n    await next();\n  }\n}\n\nlet app = new HonoApp();\n\n// Middleware 1: Logging\napp.use('*', async (c, next) => {\n  console.log(`[LOG] ${c.req.method} ${c.req.path}`);\n  await next();\n});\n\n// Middleware 2: Validation for POST requests\napp.use('*', async (c, next) => {\n  if (c.req.method === 'POST') {\n    const body = await c.req.json();\n    \n    if (!body || !body.title) {\n      console.log('[VALIDATION] Missing title!');\n      return c.json({ \n        error: 'Validation failed',\n        message: 'Title is required'\n      }, 400);\n      // No next() - stop here!\n    }\n    \n    console.log('[VALIDATION] Title found:', body.title);\n    c.set('body', body);  // Store for route handler\n  }\n  await next();\n});\n\n// Route: Create post\napp.post('/api/posts', (c) => {\n  const body = c.get('body');  // Get from middleware\n  \n  const post = {\n    id: Math.floor(Math.random() * 1000),\n    title: body.title,\n    content: body.content || '',\n    createdAt: new Date().toISOString()\n  };\n  \n  return c.json({\n    message: 'Post created successfully',\n    post: post\n  }, 201);\n});\n\n// Test with valid request\napp.simulateRequest('POST', '/api/posts', { \n  title: 'My First Post', \n  content: 'Hello World!' \n});\n\n// Test with invalid request (missing title)\napp.simulateRequest('POST', '/api/posts', { \n  content: 'No title here!' \n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should validate title exists using Hono patterns",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should detect missing title and return 400",
                  "expectedOutput": "false",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "In Hono middleware, use async (c, next) => { await next(); }. Store data with c.set('key', value) and access with c.get('key')."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to await next() in Hono middleware",
                  "consequence": "Middleware continues before the route handler completes, causing timing issues.",
                  "correction": "Always use: await next(); The await is essential in Hono's async middleware pattern."
                },
                {
                  "mistake": "Using Express (req, res, next) pattern instead of Hono (c, next)",
                  "consequence": "Code will not work with Hono's unified context object.",
                  "correction": "Use async (c, next) => { ... await next(); } pattern. Access request via c.req and respond via c.json()."
                },
                {
                  "mistake": "Mutating context like Express mutates req",
                  "consequence": "Data may be lost or cause unexpected behavior.",
                  "correction": "Use c.set('key', value) to store data and c.get('key') to retrieve it in route handlers."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "10.5",
          "title": "Building a RESTful API with Hono (The Library Catalog Analogy)",
          "moduleId": "module-10",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine managing a library catalog system:\n\nLibrary Operations (RESTful API):\n- GET /books - View all books (like browsing shelves)\n- GET /books/:id - View one specific book (like requesting a book by card number)\n- POST /books - Add a new book (like cataloging a new arrival)\n- PUT /books/:id - Update book info completely (like replacing a catalog card)\n- PATCH /books/:id - Update part of book info (like correcting a typo)\n- DELETE /books/:id - Remove a book (like removing from catalog)\n\nEach operation uses a specific method (GET, POST, etc.) and follows a pattern!\n\nREST = Representational State Transfer\n- A standard way to design APIs\n- Uses HTTP methods correctly\n- Predictable URL patterns\n- Stateless (each request is independent)\n\nHono makes building RESTful APIs simple and fast. The same REST principles apply whether you use Express or Hono!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Hono - RESTful API Example (2025)\n\n// Simulated Hono app\nclass HonoApp {\n  constructor() { this.routes = []; }\n  get(path, handler) { this.routes.push({ method: 'GET', path, handler }); }\n  post(path, handler) { this.routes.push({ method: 'POST', path, handler }); }\n  put(path, handler) { this.routes.push({ method: 'PUT', path, handler }); }\n  delete(path, handler) { this.routes.push({ method: 'DELETE', path, handler }); }\n  \n  async simulateRequest(method, path, body = null) {\n    console.log(`\\n=== ${method} ${path} ===`);\n    if (body) console.log('Body:', JSON.stringify(body));\n    \n    let route = this.routes.find(r => {\n      if (r.method !== method) return false;\n      let routePattern = r.path.replace(':id', '([^/]+)');\n      return new RegExp('^' + routePattern + '$').test(path);\n    });\n    \n    if (route) {\n      let id = path.match(/\\d+$/)?.[0];\n      // Hono context object\n      let c = {\n        req: {\n          param: (key) => key === 'id' ? id : null,\n          json: async () => body || {}\n        },\n        json: function(data, status = 200) {\n          console.log(`Status: ${status}`);\n          console.log('Response:', JSON.stringify(data, null, 2));\n          return { status, body: data };\n        }\n      };\n      await route.handler(c);\n    } else {\n      console.log('Status: 404');\n      console.log('Response: Not Found');\n    }\n  }\n}\n\nlet app = new HonoApp();\n\n// IN-MEMORY DATABASE (simulated)\nlet books = [\n  { id: 1, title: '1984', author: 'George Orwell', year: 1949, available: true },\n  { id: 2, title: 'To Kill a Mockingbird', author: 'Harper Lee', year: 1960, available: true },\n  { id: 3, title: 'The Great Gatsby', author: 'F. Scott Fitzgerald', year: 1925, available: false }\n];\n\nlet nextId = 4;\n\n// RESTful API ROUTES with Hono\n\n// 1. GET /api/books - List all books\napp.get('/api/books', (c) => {\n  return c.json({\n    count: books.length,\n    books: books\n  });\n});\n\n// 2. GET /api/books/:id - Get one book\napp.get('/api/books/:id', (c) => {\n  const id = parseInt(c.req.param('id'));\n  const book = books.find(b => b.id === id);\n  \n  if (!book) {\n    return c.json({ \n      error: 'Book not found',\n      id: id \n    }, 404);\n  }\n  \n  return c.json(book);\n});\n\n// 3. POST /api/books - Create new book\napp.post('/api/books', async (c) => {\n  const body = await c.req.json();\n  \n  // Validation\n  if (!body.title || !body.author) {\n    return c.json({\n      error: 'Validation failed',\n      message: 'Title and author are required'\n    }, 400);\n  }\n  \n  const newBook = {\n    id: nextId++,\n    title: body.title,\n    author: body.author,\n    year: body.year,\n    available: true\n  };\n  \n  books.push(newBook);\n  \n  return c.json({\n    message: 'Book created successfully',\n    book: newBook\n  }, 201);\n});\n\n// 4. PUT /api/books/:id - Update entire book (replace)\napp.put('/api/books/:id', async (c) => {\n  const id = parseInt(c.req.param('id'));\n  const body = await c.req.json();\n  const index = books.findIndex(b => b.id === id);\n  \n  if (index === -1) {\n    return c.json({ error: 'Book not found' }, 404);\n  }\n  \n  // Replace entire book (keeping the ID)\n  books[index] = {\n    id: id,\n    title: body.title,\n    author: body.author,\n    year: body.year,\n    available: body.available\n  };\n  \n  return c.json({\n    message: 'Book updated successfully',\n    book: books[index]\n  });\n});\n\n// 5. DELETE /api/books/:id - Delete a book\napp.delete('/api/books/:id', (c) => {\n  const id = parseInt(c.req.param('id'));\n  const index = books.findIndex(b => b.id === id);\n  \n  if (index === -1) {\n    return c.json({ error: 'Book not found' }, 404);\n  }\n  \n  const deletedBook = books.splice(index, 1)[0];\n  \n  return c.json({\n    message: 'Book deleted successfully',\n    book: deletedBook\n  });\n});\n\n// TEST THE API\n\nconsole.log('\\nRESTful API Demo - Book Library System (Hono)\\n');\n\n// List all books\napp.simulateRequest('GET', '/api/books');\n\n// Get specific book\napp.simulateRequest('GET', '/api/books/1');\n\n// Get non-existent book\napp.simulateRequest('GET', '/api/books/999');\n\n// Create new book\napp.simulateRequest('POST', '/api/books', {\n  title: 'The Hobbit',\n  author: 'J.R.R. Tolkien',\n  year: 1937\n});\n\n// Update book\napp.simulateRequest('PUT', '/api/books/1', {\n  title: '1984',\n  author: 'George Orwell',\n  year: 1949,\n  available: false\n});\n\n// Delete book\napp.simulateRequest('DELETE', '/api/books/2');\n\n// List all books after changes\napp.simulateRequest('GET', '/api/books');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "RESTful API design principles (same for Hono and Express):\n\n1. **HTTP Methods Map to CRUD**:\n   - CREATE -> POST\n   - READ -> GET\n   - UPDATE -> PUT (complete) or PATCH (partial)\n   - DELETE -> DELETE\n\n2. **RESTful URL Patterns**:\n   ```\n   GET    /api/resources      -> List all\n   GET    /api/resources/:id  -> Get one\n   POST   /api/resources      -> Create new\n   PUT    /api/resources/:id  -> Update (replace)\n   PATCH  /api/resources/:id  -> Update (partial)\n   DELETE /api/resources/:id  -> Delete\n   ```\n\n3. **Hono Response Patterns**:\n   ```javascript\n   // Success with default 200\n   return c.json({ data: books });\n   \n   // Created - 201\n   return c.json({ message: 'Created' }, 201);\n   \n   // Error - 404\n   return c.json({ error: 'Not found' }, 404);\n   \n   // Validation error - 400\n   return c.json({ error: 'Invalid input' }, 400);\n   ```\n\n4. **Status Codes**:\n   - 200 OK - Successful GET, PUT, PATCH\n   - 201 Created - Successful POST\n   - 204 No Content - Successful DELETE (no body)\n   - 400 Bad Request - Validation error\n   - 404 Not Found - Resource doesn't exist\n   - 500 Internal Server Error - Server problem\n\n5. **Accessing Data in Hono**:\n   ```javascript\n   // URL parameter\n   const id = c.req.param('id');\n   \n   // Request body (async!)\n   const body = await c.req.json();\n   \n   // Query parameter\n   const search = c.req.query('search');\n   ```\n\n6. **Validation**:\n   ```javascript\n   app.post('/api/books', async (c) => {\n     const body = await c.req.json();\n     \n     if (!body.title) {\n       return c.json({ error: 'Title is required' }, 400);\n     }\n     // ... create book\n   });\n   ```\n\n7. **Real Hono + Bun Server**:\n   ```javascript\n   import { Hono } from 'hono';\n   const app = new Hono();\n   \n   app.get('/api/books', (c) => c.json(books));\n   \n   export default app;  // Bun serves this!\n   ```"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Node.js/Express Equivalent",
              "legacy": "express",
              "content": "The REST principles are identical between Express and Hono. The main differences are in syntax: Hono uses a unified context object and passes status as a second argument.",
              "code": "// Express way\nimport express from 'express';\nconst app = express();\napp.use(express.json());  // Need middleware!\n\napp.get('/api/books/:id', (req, res) => {\n  const id = req.params.id;              // Object property\n  const book = books.find(b => b.id === id);\n  if (!book) {\n    return res.status(404).json({ error: 'Not found' });\n  }\n  res.json(book);\n});\n\napp.post('/api/books', (req, res) => {\n  const body = req.body;                 // Already parsed\n  res.status(201).json({ book: body });\n});\n\napp.listen(3000);\n\n// Hono way (cleaner!)\nimport { Hono } from 'hono';\nconst app = new Hono();\n// No body parsing middleware needed!\n\napp.get('/api/books/:id', (c) => {\n  const id = c.req.param('id');          // Method call\n  const book = books.find(b => b.id === id);\n  if (!book) {\n    return c.json({ error: 'Not found' }, 404);\n  }\n  return c.json(book);\n});\n\napp.post('/api/books', async (c) => {\n  const body = await c.req.json();       // Async!\n  return c.json({ book: body }, 201);\n});\n\nexport default app;  // That's it!",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common RESTful API mistakes (applies to both Hono and Express):\n\n1. **Using verbs in URLs**:\n   ```javascript\n   // Wrong!\n   app.get('/api/getUsers', ...);\n   app.post('/api/createUser', ...);\n   \n   // Correct!\n   app.get('/api/users', ...);\n   app.post('/api/users', ...);\n   ```\n   The HTTP method IS the verb!\n\n2. **Forgetting async for body parsing in Hono**:\n   ```javascript\n   // Wrong!\n   app.post('/api/books', (c) => {\n     const body = c.req.json();  // This is a Promise!\n   });\n   \n   // Correct!\n   app.post('/api/books', async (c) => {\n     const body = await c.req.json();  // Await it!\n   });\n   ```\n\n3. **Wrong status codes**:\n   ```javascript\n   // Wrong in Hono\n   return c.json({ error: 'Not found' });  // Still 200!\n   \n   // Correct\n   return c.json({ error: 'Not found' }, 404);\n   ```\n\n4. **Forgetting to return in Hono**:\n   ```javascript\n   // Wrong - missing return!\n   app.get('/api/books', (c) => {\n     c.json(books);\n   });\n   \n   // Correct\n   app.get('/api/books', (c) => {\n     return c.json(books);\n   });\n   ```\n\n5. **Not validating input**:\n   ```javascript\n   // Always validate!\n   app.post('/api/books', async (c) => {\n     const body = await c.req.json();\n     \n     if (!body.title || !body.author) {\n       return c.json({ error: 'Invalid input' }, 400);\n     }\n     // ... safe to create book\n   });\n   ```\n\n6. **Forgetting to handle not found**:\n   ```javascript\n   app.get('/api/books/:id', (c) => {\n     const book = books.find(...);\n     if (!book) {\n       return c.json({ error: 'Book not found' }, 404);\n     }\n     return c.json(book);\n   });\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.5-challenge",
              "title": "Practice Challenge",
              "description": "Build a RESTful API for managing tasks using Hono patterns:\n\n1. Create an array to store tasks (each has: id, title, completed)\n2. Implement these endpoints using Hono's (c) context:\n   - GET /api/tasks - Return all tasks using c.json()\n   - GET /api/tasks/:id - Return one task (404 if not found)\n   - POST /api/tasks - Create new task (validate title exists)\n   - PUT /api/tasks/:id - Update task completely\n   - DELETE /api/tasks/:id - Delete task\n\n3. Use proper status codes with c.json(data, status):\n   - 200 for successful GET/PUT\n   - 201 for successful POST\n   - 404 for not found\n   - 400 for validation errors\n\n4. Remember: return c.json() and use async for POST/PUT body parsing!",
              "instructions": "Build a RESTful API for managing tasks using Hono patterns:\n\n1. Create an array to store tasks (each has: id, title, completed)\n2. Implement these endpoints using Hono's (c) context:\n   - GET /api/tasks - Return all tasks using c.json()\n   - GET /api/tasks/:id - Return one task (404 if not found)\n   - POST /api/tasks - Create new task (validate title exists)\n   - PUT /api/tasks/:id - Update task completely\n   - DELETE /api/tasks/:id - Delete task\n\n3. Use proper status codes with c.json(data, status):\n   - 200 for successful GET/PUT\n   - 201 for successful POST\n   - 404 for not found\n   - 400 for validation errors\n\n4. Remember: return c.json() and use async for POST/PUT body parsing!",
              "starterCode": "class HonoApp {\n  constructor() { this.routes = []; }\n  get(p, h) { this.routes.push({ method: 'GET', path: p, handler: h }); }\n  post(p, h) { this.routes.push({ method: 'POST', path: p, handler: h }); }\n  put(p, h) { this.routes.push({ method: 'PUT', path: p, handler: h }); }\n  delete(p, h) { this.routes.push({ method: 'DELETE', path: p, handler: h }); }\n  async simulateRequest(method, path, body = null) {\n    console.log(`\\n${method} ${path}`);\n    let id = path.match(/\\d+$/)?.[0];\n    let route = this.routes.find(r => {\n      if (r.method !== method) return false;\n      let pattern = r.path.replace(':id', '([^/]+)');\n      return new RegExp('^' + pattern + '$').test(path);\n    });\n    if (route) {\n      let c = {\n        req: {\n          param: (key) => key === 'id' ? id : null,\n          json: async () => body || {}\n        },\n        json: function(d, s = 200) {\n          console.log(`[${s}]`, JSON.stringify(d));\n          return { status: s, body: d };\n        }\n      };\n      await route.handler(c);\n    }\n  }\n}\n\nlet app = new HonoApp();\n\n// Task storage\nlet tasks = [\n  { id: 1, title: 'Learn Hono', completed: false }\n];\nlet nextId = 2;\n\n// TODO: Implement your routes here using Hono patterns\n// Remember: (c) => { return c.json(data); }\n// For POST/PUT: async (c) => { const body = await c.req.json(); }\n\n// Test\napp.simulateRequest('GET', '/api/tasks');\napp.simulateRequest('POST', '/api/tasks', { title: 'Build API' });\napp.simulateRequest('GET', '/api/tasks/1');\napp.simulateRequest('DELETE', '/api/tasks/1');",
              "solution": "class HonoApp {\n  constructor() { this.routes = []; }\n  get(p, h) { this.routes.push({ method: 'GET', path: p, handler: h }); }\n  post(p, h) { this.routes.push({ method: 'POST', path: p, handler: h }); }\n  put(p, h) { this.routes.push({ method: 'PUT', path: p, handler: h }); }\n  delete(p, h) { this.routes.push({ method: 'DELETE', path: p, handler: h }); }\n  async simulateRequest(method, path, body = null) {\n    console.log(`\\n${method} ${path}`);\n    let id = path.match(/\\d+$/)?.[0];\n    let route = this.routes.find(r => {\n      if (r.method !== method) return false;\n      let pattern = r.path.replace(':id', '([^/]+)');\n      return new RegExp('^' + pattern + '$').test(path);\n    });\n    if (route) {\n      let c = {\n        req: {\n          param: (key) => key === 'id' ? id : null,\n          json: async () => body || {}\n        },\n        json: function(d, s = 200) {\n          console.log(`[${s}]`, JSON.stringify(d, null, 2));\n          return { status: s, body: d };\n        }\n      };\n      await route.handler(c);\n    }\n  }\n}\n\nlet app = new HonoApp();\n\n// Task storage\nlet tasks = [\n  { id: 1, title: 'Learn Hono', completed: false },\n  { id: 2, title: 'Build API', completed: true }\n];\nlet nextId = 3;\n\n// GET /api/tasks - List all\napp.get('/api/tasks', (c) => {\n  return c.json({ count: tasks.length, tasks });\n});\n\n// GET /api/tasks/:id - Get one\napp.get('/api/tasks/:id', (c) => {\n  const task = tasks.find(t => t.id === parseInt(c.req.param('id')));\n  if (!task) {\n    return c.json({ error: 'Task not found' }, 404);\n  }\n  return c.json(task);\n});\n\n// POST /api/tasks - Create\napp.post('/api/tasks', async (c) => {\n  const body = await c.req.json();\n  \n  if (!body.title) {\n    return c.json({ error: 'Title is required' }, 400);\n  }\n  \n  const newTask = {\n    id: nextId++,\n    title: body.title,\n    completed: false\n  };\n  tasks.push(newTask);\n  \n  return c.json({ message: 'Task created', task: newTask }, 201);\n});\n\n// PUT /api/tasks/:id - Update\napp.put('/api/tasks/:id', async (c) => {\n  const id = parseInt(c.req.param('id'));\n  const body = await c.req.json();\n  const index = tasks.findIndex(t => t.id === id);\n  \n  if (index === -1) {\n    return c.json({ error: 'Task not found' }, 404);\n  }\n  \n  tasks[index] = {\n    id: id,\n    title: body.title,\n    completed: body.completed\n  };\n  \n  return c.json({ message: 'Task updated', task: tasks[index] });\n});\n\n// DELETE /api/tasks/:id - Delete\napp.delete('/api/tasks/:id', (c) => {\n  const id = parseInt(c.req.param('id'));\n  const index = tasks.findIndex(t => t.id === id);\n  \n  if (index === -1) {\n    return c.json({ error: 'Task not found' }, 404);\n  }\n  \n  const deleted = tasks.splice(index, 1)[0];\n  return c.json({ message: 'Task deleted', task: deleted });\n});\n\n// Tests\nconsole.log('=== Task API Demo (Hono) ===');\napp.simulateRequest('GET', '/api/tasks');\napp.simulateRequest('GET', '/api/tasks/1');\napp.simulateRequest('POST', '/api/tasks', { title: 'Deploy app' });\napp.simulateRequest('PUT', '/api/tasks/1', { title: 'Learn Hono', completed: true });\napp.simulateRequest('DELETE', '/api/tasks/2');\napp.simulateRequest('GET', '/api/tasks');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should find task by id using Hono patterns",
                  "expectedOutput": "Test",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should validate task has title",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use c.req.param('id') to get the ID. For POST/PUT, use async and await c.req.json() to parse body. Always return c.json()!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to return c.json() in Hono route handlers",
                  "consequence": "No response is sent to the client.",
                  "correction": "Always use return c.json(data) or return c.json(data, statusCode)."
                },
                {
                  "mistake": "Not using async/await for c.req.json() in POST/PUT handlers",
                  "consequence": "You get a Promise object instead of the parsed body.",
                  "correction": "Use async (c) => { const body = await c.req.json(); ... }"
                },
                {
                  "mistake": "Using Express syntax res.status(404).json() instead of Hono's c.json(data, 404)",
                  "consequence": "Code will not work with Hono's API.",
                  "correction": "In Hono, pass status as second argument: return c.json({ error: 'Not found' }, 404)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-11",
      "title": "Module 11: Storing Data - Databases & Prisma ORM",
      "description": "Learn how to persist data using databases, SQL basics, and Prisma ORM for type-safe database access",
      "difficulty": "advanced",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "11.1",
          "title": "What Are Databases? (The Filing Cabinet Analogy)",
          "moduleId": "module-11",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine storing customer information for a business:\n\nWithout a database (variables in memory):\n- Write customer data on sticky notes\n- Keep them on your desk\n- When you close the office (restart server), all notes are thrown away\n- No way to search through thousands of notes efficiently\n- Notes get lost, damaged, or mixed up\n\nWith a database (persistent storage):\n- Organized filing cabinet with labeled drawers\n- Customer files stay there even when office closes\n- Can quickly find any customer using the index\n- Multiple people can access files simultaneously\n- Backup copies exist for safety\n\nDatabases are like permanent, organized filing systems for your application's data. They persist information even when your server restarts!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Understanding Databases - Concept Demo\n\n// PROBLEM: In-memory storage (data is temporary)\nlet users = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' }\n];\n\nconsole.log('Users in memory:', users.length); // 2\n\n// When server restarts... POOF! Data is gone!\n// users = [];  // Lost forever!\n\n// DATABASE CONCEPTS\n\n// 1. PERSISTENCE - Data survives server restarts\nconsole.log('Database benefit: Data persists across restarts');\n\n// 2. STRUCTURED DATA - Tables with columns\n/*\n  Users Table:\n  ┌────┬────────┬──────────────────────┐\n  │ id │ name   │ email                │\n  ├────┼────────┼──────────────────────┤\n  │ 1  │ Alice  │ alice@example.com    │\n  │ 2  │ Bob    │ bob@example.com      │\n  └────┴────────┴──────────────────────┘\n*/\n\n// 3. RELATIONSHIPS - Tables can connect to each other\n/*\n  Posts Table:\n  ┌────┬────────────────┬───────────┐\n  │ id │ title          │ userId    │\n  ├────┼────────────────┼───────────┤\n  │ 1  │ First Post     │ 1 (Alice) │\n  │ 2  │ Hello World    │ 2 (Bob)   │\n  └────┴────────────────┴───────────┘\n*/\n\nconsole.log('Database benefit: Relationships between data');\n\n// 4. QUERIES - Ask questions about your data\nlet sqlExamples = [\n  'SELECT * FROM users WHERE name = \"Alice\"',\n  'SELECT * FROM posts WHERE userId = 1',\n  'SELECT users.name, posts.title FROM users JOIN posts ON users.id = posts.userId'\n];\n\nconsole.log('SQL queries let you ask complex questions:');\nsqlExamples.forEach(sql => console.log('  -', sql));\n\n// 5. TRANSACTIONS - All-or-nothing operations\nconsole.log('Database benefit: Transactions ensure data integrity');\n/*\n  Example: Transferring money\n  - Subtract $100 from Account A\n  - Add $100 to Account B\n  \n  Either BOTH happen, or NEITHER happens!\n  No lost money!\n*/\n\n// TYPES OF DATABASES\n\nlet databaseTypes = {\n  'Relational (SQL)': {\n    examples: ['PostgreSQL', 'MySQL', 'SQLite'],\n    structure: 'Tables with rows and columns',\n    uses: 'Most applications, e-commerce, banking'\n  },\n  'NoSQL (Document)': {\n    examples: ['MongoDB', 'Firestore'],\n    structure: 'JSON-like documents',\n    uses: 'Flexible schemas, real-time apps'\n  },\n  'Key-Value': {\n    examples: ['Redis', 'DynamoDB'],\n    structure: 'Simple key-value pairs',\n    uses: 'Caching, sessions, real-time'\n  }\n};\n\nconsole.log('\\nTypes of databases:');\nfor (let [type, info] of Object.entries(databaseTypes)) {\n  console.log(`${type}: ${info.examples.join(', ')}`);\n}\n\n// WHY USE A DATABASE?\nlet benefits = [\n  'Persistence: Data survives restarts',\n  'Scalability: Handle millions of records',\n  'Concurrency: Multiple users at once',\n  'Query power: Complex data searches',\n  'Data integrity: Constraints and validation',\n  'Security: Access control and encryption',\n  'Backup: Restore data if something breaks'\n];\n\nconsole.log('\\nDatabase benefits:');\nbenefits.forEach(b => console.log(`  ✓ ${b}`));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Database fundamentals:\n\n1. **Database Types**:\n   - **SQL (Relational)**: Structured tables, relationships, strict schema\n     * PostgreSQL (powerful, feature-rich)\n     * MySQL (popular, web apps)\n     * SQLite (simple, file-based)\n   \n   - **NoSQL**: Flexible structure, JSON-like\n     * MongoDB (document-based)\n     * Redis (key-value, caching)\n\n2. **Key Database Concepts**:\n   - **Table**: Collection of similar data (like a spreadsheet)\n   - **Row**: Individual record (one user, one post)\n   - **Column**: Property/field (name, email, age)\n   - **Primary Key**: Unique identifier (usually `id`)\n   - **Foreign Key**: Reference to another table (userId references users table)\n\n3. **SQL Basics** (Structured Query Language):\n   ```sql\n   -- Create table\n   CREATE TABLE users (\n     id INTEGER PRIMARY KEY,\n     name TEXT NOT NULL,\n     email TEXT UNIQUE\n   );\n   \n   -- Insert data\n   INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');\n   \n   -- Read data\n   SELECT * FROM users WHERE name = 'Alice';\n   \n   -- Update data\n   UPDATE users SET email = 'newemail@example.com' WHERE id = 1;\n   \n   -- Delete data\n   DELETE FROM users WHERE id = 1;\n   ```\n\n4. **CRUD Operations**:\n   - **C**reate: INSERT\n   - **R**ead: SELECT\n   - **U**pdate: UPDATE\n   - **D**elete: DELETE\n\n5. **Relationships**:\n   - **One-to-Many**: One user has many posts\n   - **Many-to-Many**: Users can follow many users, users have many followers\n   - **One-to-One**: User has one profile\n\n6. **Choosing a Database**:\n   - **PostgreSQL**: Production apps, complex queries, reliability\n   - **SQLite**: Development, simple apps, mobile apps\n   - **MongoDB**: Flexible schemas, rapid prototyping\n   - **Redis**: Caching, sessions, real-time features"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common database misconceptions:\n\n1. **\"Databases are too complex for beginners\"**:\n   - Start simple with SQLite or Prisma\n   - You don't need to be a DBA to use databases\n   - ORMs (like Prisma) make it much easier\n\n2. **\"I can just use variables/files instead\"**:\n   ```javascript\n   // This seems easier but...\n   let users = [];  // Lost on restart!\n   \n   // Or\n   fs.writeFileSync('users.json', JSON.stringify(users));\n   // File corruption? Race conditions? Concurrent access?\n   ```\n   Databases solve these problems professionally\n\n3. **\"All databases are the same\"**:\n   - SQL databases: Structured, relations, ACID guarantees\n   - NoSQL databases: Flexible, scalable, eventual consistency\n   - Choose based on your needs!\n\n4. **\"I need to learn raw SQL first\"**:\n   - Modern ORMs (Prisma, TypeORM) abstract SQL\n   - You can learn SQL gradually\n   - Start with ORM, understand SQL over time\n\n5. **\"Databases are slow\"**:\n   - Modern databases are EXTREMELY fast\n   - Proper indexes make queries lightning quick\n   - Can handle millions of queries per second\n\n6. **\"I don't need relationships\"**:\n   - Even simple apps benefit from relationships\n   - User → Posts → Comments (natural hierarchy)\n   - Avoids data duplication\n\n7. **\"Development database vs Production database\"**:\n   - Use SQLite for development (simple, file-based)\n   - Use PostgreSQL for production (robust, scalable)\n   - Prisma makes switching databases easy!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.1-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a simple database system:\n\n1. Create an array called `database` to store user objects\n2. Create a function `insertUser(name, email)` that:\n   - Generates a unique ID\n   - Adds user to database\n   - Returns the new user\n3. Create a function `findUserByEmail(email)` that:\n   - Searches the database\n   - Returns the user or null\n4. Create a function `updateUserEmail(id, newEmail)` that:\n   - Finds user by ID\n   - Updates their email\n   - Returns true/false for success\n\nTest all functions.",
              "instructions": "Simulate a simple database system:\n\n1. Create an array called `database` to store user objects\n2. Create a function `insertUser(name, email)` that:\n   - Generates a unique ID\n   - Adds user to database\n   - Returns the new user\n3. Create a function `findUserByEmail(email)` that:\n   - Searches the database\n   - Returns the user or null\n4. Create a function `updateUserEmail(id, newEmail)` that:\n   - Finds user by ID\n   - Updates their email\n   - Returns true/false for success\n\nTest all functions.",
              "starterCode": "// Simulated database (array of objects)\nlet database = [];\nlet nextId = 1;\n\n// Function to insert a user\nfunction insertUser(name, email) {\n  let user = {\n    id: nextId++,\n    name: name,\n    email: email\n  };\n  database.push(user);\n  return user;\n}\n\n// Function to find user by email\nfunction findUserByEmail(email) {\n  return database.find(user => user.email === email) || null;\n}\n\n// Function to update user email\nfunction updateUserEmail(id, newEmail) {\n  let user = database.find(u => u.id === id);\n  if (user) {\n    user.email = newEmail;\n    return true;\n  }\n  return false;\n}\n\n// Test the functions\nlet user1 = insertUser('Alice', 'alice@example.com');\nconsole.log('Inserted:', user1);\n\nlet found = findUserByEmail('alice@example.com');\nconsole.log('Found:', found);\n\nlet updated = updateUserEmail(1, 'alice.new@example.com');\nconsole.log('Updated:', updated);\nconsole.log('Database:', database);",
              "solution": "// Complete database simulation\nlet database = [];\nlet nextId = 1;\n\n// Insert user\nfunction insertUser(name, email) {\n  let user = {\n    id: nextId++,\n    name: name,\n    email: email,\n    createdAt: new Date().toISOString()\n  };\n  database.push(user);\n  console.log(`✓ Inserted user ID ${user.id}`);\n  return user;\n}\n\n// Find user by email\nfunction findUserByEmail(email) {\n  let user = database.find(u => u.email === email);\n  return user || null;\n}\n\n// Update user email\nfunction updateUserEmail(id, newEmail) {\n  let user = database.find(u => u.id === id);\n  if (user) {\n    let oldEmail = user.email;\n    user.email = newEmail;\n    console.log(`✓ Updated user ${id}: ${oldEmail} → ${newEmail}`);\n    return true;\n  }\n  console.log(`✗ User ${id} not found`);\n  return false;\n}\n\n// Delete user\nfunction deleteUser(id) {\n  let index = database.findIndex(u => u.id === id);\n  if (index !== -1) {\n    let deleted = database.splice(index, 1)[0];\n    console.log(`✓ Deleted user ${id}`);\n    return deleted;\n  }\n  return null;\n}\n\n// List all users\nfunction getAllUsers() {\n  return database;\n}\n\n// Test the database\nconsole.log('=== Database Simulation ===\\n');\n\nlet alice = insertUser('Alice', 'alice@example.com');\nlet bob = insertUser('Bob', 'bob@example.com');\nlet charlie = insertUser('Charlie', 'charlie@example.com');\n\nconsole.log('\\nAll users:', getAllUsers().length);\n\nlet found = findUserByEmail('bob@example.com');\nconsole.log('\\nFound Bob:', found ? found.name : 'Not found');\n\nupdateUserEmail(1, 'alice.new@example.com');\n\ndeleteUser(2);\n\nconsole.log('\\nFinal database:', database);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should insert user with ID",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should find user by email",
                  "expectedOutput": "Alice",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use array methods: push() to add, find() to search, and direct property assignment to update."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common database misconceptions:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common database misconceptions:"
                },
                {
                  "mistake": "**\"Databases are too complex for beginners\"**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**\"Databases are too complex for beginners\"**:\n   - Start simple with SQLite or Prisma\n   - You don't need to be a DBA to use databases\n   - ORMs (like Prisma) make it much easier"
                },
                {
                  "mistake": "**\"I can just use variables/files instead\"**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**\"I can just use variables/files instead\"**:\n   ```javascript\n   // This seems easier but...\n   let users = [];  // Lost on restart!\n   \n   // Or\n   fs.writeFileSync('users.json', JSON.stringify(users));\n   // File corruption? Race conditions? Concurrent access?\n   ```\n   Databases solve these problems professionally"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "11.2",
          "title": "Introduction to Prisma ORM (The Translator Analogy)",
          "moduleId": "module-11",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're traveling in a foreign country:\n\nWithout a translator (raw SQL):\n- You need to learn the local language fluently\n- Every conversation requires you to form sentences carefully\n- Easy to make grammar mistakes\n- Different regions have different dialects (MySQL vs PostgreSQL)\n- Stressful and error-prone\n\nWith a translator (Prisma ORM):\n- You speak in your native language (TypeScript/JavaScript)\n- Translator converts to local language (SQL)\n- Translator knows all the dialects\n- Type-safe: Translator stops you from saying nonsense\n- Confident communication!\n\nPrisma ORM (Object-Relational Mapping) is a translator between your JavaScript code and your database. You write TypeScript, Prisma generates the SQL!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Prisma ORM Demonstration (Conceptual)\n// In real projects, Prisma generates TypeScript types automatically!\n\n// TRADITIONAL WAY: Raw SQL (error-prone)\nlet rawSQL = `\n  SELECT users.name, posts.title \n  FROM users \n  JOIN posts ON users.id = posts.userId \n  WHERE users.email = 'alice@example.com'\n`;\n\nconsole.log('Raw SQL (requires SQL knowledge):', rawSQL);\nconsole.log('Problems: SQL injection, typos, no type safety\\n');\n\n// PRISMA WAY: Type-safe JavaScript/TypeScript\n// (Simulated - real Prisma connects to actual database)\n\nclass PrismaClient {\n  constructor() {\n    this.user = {\n      create: async (data) => {\n        console.log('[Prisma] Creating user:', data.data);\n        return { id: 1, ...data.data, createdAt: new Date() };\n      },\n      findUnique: async (query) => {\n        console.log('[Prisma] Finding user where:', query.where);\n        return {\n          id: 1,\n          name: 'Alice',\n          email: 'alice@example.com',\n          posts: [\n            { id: 1, title: 'First Post', content: 'Hello!' }\n          ]\n        };\n      },\n      findMany: async (query) => {\n        console.log('[Prisma] Finding many users');\n        return [\n          { id: 1, name: 'Alice', email: 'alice@example.com' },\n          { id: 2, name: 'Bob', email: 'bob@example.com' }\n        ];\n      },\n      update: async (query) => {\n        console.log('[Prisma] Updating user:', query.where, 'with:', query.data);\n        return { id: 1, ...query.data };\n      },\n      delete: async (query) => {\n        console.log('[Prisma] Deleting user:', query.where);\n        return { id: 1, name: 'Alice' };\n      }\n    };\n    \n    this.post = {\n      create: async (data) => {\n        console.log('[Prisma] Creating post:', data.data);\n        return { id: 1, ...data.data };\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// PRISMA EXAMPLES (async/await pattern)\n\n// 1. CREATE a user\nasync function createUser() {\n  let user = await prisma.user.create({\n    data: {\n      name: 'Alice',\n      email: 'alice@example.com'\n    }\n  });\n  console.log('Created user:', user);\n  return user;\n}\n\n// 2. FIND a user by email\nasync function findUser() {\n  let user = await prisma.user.findUnique({\n    where: {\n      email: 'alice@example.com'\n    },\n    include: {\n      posts: true  // Include related posts!\n    }\n  });\n  console.log('Found user with posts:', user);\n  return user;\n}\n\n// 3. UPDATE a user\nasync function updateUser() {\n  let user = await prisma.user.update({\n    where: { id: 1 },\n    data: {\n      name: 'Alice Smith'\n    }\n  });\n  console.log('Updated user:', user);\n  return user;\n}\n\n// 4. DELETE a user\nasync function deleteUser() {\n  let user = await prisma.user.delete({\n    where: { id: 1 }\n  });\n  console.log('Deleted user:', user);\n  return user;\n}\n\n// 5. LIST all users\nasync function listUsers() {\n  let users = await prisma.user.findMany();\n  console.log('All users:', users);\n  return users;\n}\n\n// Run examples\nconsole.log('=== Prisma ORM Examples ===\\n');\n\ncreateUser();\nsetTimeout(() => findUser(), 100);\nsetTimeout(() => updateUser(), 200);\nsetTimeout(() => listUsers(), 300);\n\n// PRISMA BENEFITS\nconsole.log('\\n=== Prisma Benefits ===');\nlet benefits = [\n  '✓ Type-safe database queries (TypeScript)',\n  '✓ Auto-generated types from schema',\n  '✓ Database agnostic (PostgreSQL, MySQL, SQLite, etc.)',\n  '✓ Intuitive API (JavaScript objects, not SQL strings)',\n  '✓ Migrations built-in',\n  '✓ Prisma Studio (database GUI)',\n  '✓ Query builder prevents SQL injection',\n  '✓ Excellent autocomplete in IDE'\n];\n\nbenefits.forEach(b => console.log(b));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding Prisma ORM:\n\n1. **What is Prisma?**\n   - Modern ORM (Object-Relational Mapping)\n   - Translates TypeScript ↔ SQL\n   - Type-safe database client\n   - Works with PostgreSQL, MySQL, SQLite, MongoDB, etc.\n\n2. **Prisma Setup** (typical workflow):\n   ```bash\n   # Install Prisma\n   npm install prisma --save-dev\n   npm install @prisma/client\n   \n   # Initialize Prisma\n   npx prisma init\n   \n   # This creates:\n   # - prisma/schema.prisma (database schema)\n   # - .env (database connection string)\n   ```\n\n3. **Prisma Schema** (schema.prisma):\n   ```prisma\n   model User {\n     id        Int      @id @default(autoincrement())\n     email     String   @unique\n     name      String\n     posts     Post[]\n     createdAt DateTime @default(now())\n   }\n   \n   model Post {\n     id        Int      @id @default(autoincrement())\n     title     String\n     content   String?\n     published Boolean  @default(false)\n     userId    Int\n     user      User     @relation(fields: [userId], references: [id])\n   }\n   ```\n\n4. **Prisma Client Usage**:\n   ```typescript\n   import { PrismaClient } from '@prisma/client';\n   const prisma = new PrismaClient();\n   \n   // All your database operations...\n   ```\n\n5. **CRUD Operations**:\n   - **Create**: `prisma.user.create({ data: {...} })`\n   - **Read**: `prisma.user.findUnique({ where: {...} })`\n   - **Update**: `prisma.user.update({ where: {...}, data: {...} })`\n   - **Delete**: `prisma.user.delete({ where: {...} })`\n\n6. **Relationships**:\n   ```typescript\n   // Get user with all their posts\n   const userWithPosts = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: { posts: true }\n   });\n   ```\n\n7. **Migrations** (database schema changes):\n   ```bash\n   # Create migration\n   npx prisma migrate dev --name add_users_table\n   \n   # Apply migrations to production\n   npx prisma migrate deploy\n   ```\n\n8. **Prisma Studio** (database GUI):\n   ```bash\n   npx prisma studio\n   # Opens visual database editor in browser\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Prisma mistakes:\n\n1. **Forgetting async/await**:\n   ```typescript\n   // Wrong!\n   let user = prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.name); // ERROR: user is a Promise!\n   \n   // Correct!\n   let user = await prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.name); // Works!\n   ```\n\n2. **Not running migrations**:\n   - After changing schema.prisma, run: `npx prisma migrate dev`\n   - Then: `npx prisma generate` to update TypeScript types\n   - Without this, your code won't match the database!\n\n3. **Prisma Client not initialized**:\n   ```typescript\n   // Create once, reuse everywhere\n   // prisma/client.ts\n   import { PrismaClient } from '@prisma/client';\n   export const prisma = new PrismaClient();\n   \n   // other files\n   import { prisma } from './prisma/client';\n   ```\n\n4. **Not handling null results**:\n   ```typescript\n   let user = await prisma.user.findUnique({ where: { id: 999 } });\n   console.log(user.name); // ERROR if user is null!\n   \n   // Better:\n   if (!user) {\n     throw new Error('User not found');\n   }\n   console.log(user.name);\n   ```\n\n5. **Forgetting to connect/disconnect**:\n   ```typescript\n   // Usually not needed in serverless\n   // But for long-running servers:\n   await prisma.$connect();\n   // ... use prisma ...\n   await prisma.$disconnect();\n   ```\n\n6. **Schema syntax errors**:\n   ```prisma\n   // Wrong!\n   model User {\n     id Int @id\n     name String\n     // Missing newline before }\n   }\n   \n   // Correct!\n   model User {\n     id   Int    @id @default(autoincrement())\n     name String\n   }\n   ```\n\n7. **Not using Prisma Studio**:\n   - Run `npx prisma studio` to see your data visually\n   - Great for debugging and understanding your database\n   - Much easier than writing SELECT queries!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.2-challenge",
              "title": "Practice Challenge",
              "description": "Simulate Prisma-style database operations:\n\n1. Create a mock Prisma client class with a `book` property\n2. Implement these methods on the `book` object:\n   - `create(data)` - Returns new book with generated ID\n   - `findMany()` - Returns all books array\n   - `findUnique(where)` - Finds book by ID\n   - `update(where, data)` - Updates book and returns it\n\n3. Create a books array to store data\n4. Test all CRUD operations\n\nMake it feel like Prisma's API!",
              "instructions": "Simulate Prisma-style database operations:\n\n1. Create a mock Prisma client class with a `book` property\n2. Implement these methods on the `book` object:\n   - `create(data)` - Returns new book with generated ID\n   - `findMany()` - Returns all books array\n   - `findUnique(where)` - Finds book by ID\n   - `update(where, data)` - Updates book and returns it\n\n3. Create a books array to store data\n4. Test all CRUD operations\n\nMake it feel like Prisma's API!",
              "starterCode": "// Mock Prisma client\nclass PrismaClient {\n  constructor() {\n    this.booksData = [];\n    this.nextId = 1;\n    \n    this.book = {\n      create: async (options) => {\n        let book = {\n          id: this.nextId++,\n          ...options.data\n        };\n        this.booksData.push(book);\n        return book;\n      },\n      \n      findMany: async () => {\n        return this.booksData;\n      },\n      \n      findUnique: async (options) => {\n        return this.booksData.find(b => b.id === options.where.id) || null;\n      },\n      \n      update: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        if (book) {\n          Object.assign(book, options.data);\n          return book;\n        }\n        return null;\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// Test CRUD operations\nasync function testPrisma() {\n  // Create\n  let book1 = await prisma.book.create({\n    data: { title: '1984', author: 'George Orwell', pages: 328 }\n  });\n  console.log('Created:', book1);\n  \n  // Find all\n  let books = await prisma.book.findMany();\n  console.log('All books:', books);\n  \n  // Find one\n  let found = await prisma.book.findUnique({ where: { id: 1 } });\n  console.log('Found:', found);\n  \n  // Update\n  let updated = await prisma.book.update({\n    where: { id: 1 },\n    data: { pages: 330 }\n  });\n  console.log('Updated:', updated);\n}\n\ntestPrisma();",
              "solution": "// Complete Prisma-style mock client\nclass PrismaClient {\n  constructor() {\n    this.booksData = [];\n    this.nextId = 1;\n    \n    this.book = {\n      create: async (options) => {\n        let book = {\n          id: this.nextId++,\n          ...options.data,\n          createdAt: new Date()\n        };\n        this.booksData.push(book);\n        console.log(`✓ Created book ID ${book.id}`);\n        return book;\n      },\n      \n      findMany: async (options = {}) => {\n        let books = this.booksData;\n        \n        // Filter if where clause provided\n        if (options.where) {\n          books = books.filter(book => {\n            return Object.entries(options.where).every(([key, value]) => {\n              return book[key] === value;\n            });\n          });\n        }\n        \n        return books;\n      },\n      \n      findUnique: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        return book || null;\n      },\n      \n      update: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        if (book) {\n          Object.assign(book, options.data);\n          book.updatedAt = new Date();\n          console.log(`✓ Updated book ID ${book.id}`);\n          return book;\n        }\n        throw new Error(`Book with ID ${options.where.id} not found`);\n      },\n      \n      delete: async (options) => {\n        let index = this.booksData.findIndex(b => b.id === options.where.id);\n        if (index !== -1) {\n          let deleted = this.booksData.splice(index, 1)[0];\n          console.log(`✓ Deleted book ID ${deleted.id}`);\n          return deleted;\n        }\n        throw new Error(`Book with ID ${options.where.id} not found`);\n      },\n      \n      count: async () => {\n        return this.booksData.length;\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// Comprehensive test\nasync function testPrisma() {\n  console.log('=== Prisma-Style ORM Demo ===\\n');\n  \n  // Create books\n  await prisma.book.create({\n    data: { title: '1984', author: 'George Orwell', pages: 328 }\n  });\n  \n  await prisma.book.create({\n    data: { title: 'The Great Gatsby', author: 'F. Scott Fitzgerald', pages: 180 }\n  });\n  \n  // Find all\n  let allBooks = await prisma.book.findMany();\n  console.log('\\nAll books:', allBooks.length);\n  \n  // Find specific\n  let book = await prisma.book.findUnique({ where: { id: 1 } });\n  console.log('\\nFound book:', book.title);\n  \n  // Update\n  await prisma.book.update({\n    where: { id: 1 },\n    data: { pages: 330 }\n  });\n  \n  // Count\n  let count = await prisma.book.count();\n  console.log('\\nTotal books:', count);\n  \n  // Delete\n  await prisma.book.delete({ where: { id: 2 } });\n  \n  // Final state\n  let remaining = await prisma.book.findMany();\n  console.log('\\nRemaining books:', remaining);\n}\n\ntestPrisma();",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should create book with generated ID",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should find book by id",
                  "expectedOutput": "Test",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use async functions and make methods return promises. Store books in an array."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common Prisma mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common Prisma mistakes:"
                },
                {
                  "mistake": "**Forgetting async/await**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting async/await**:\n   ```typescript\n   // Wrong!\n   let user = prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.name); // ERROR: user is a Promise!\n   \n   // Correct!\n   let user = await prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.name); // Works!\n   ```"
                },
                {
                  "mistake": "**Not running migrations**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Not running migrations**:\n   - After changing schema.prisma, run: `npx prisma migrate dev`\n   - Then: `npx prisma generate` to update TypeScript types\n   - Without this, your code won't match the database!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "11.3",
          "title": "Writing the Prisma Schema (The Blueprint Analogy)",
          "moduleId": "module-11",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're an architect designing a house:\n\nWithout a blueprint:\n- Builders have no clear plan\n- Everyone interprets requirements differently\n- Walls might not line up\n- No standard for room sizes\n- Chaos!\n\nWith a blueprint (Prisma schema):\n- Clear specification for every room\n- Exact measurements and connections\n- Everyone follows the same plan\n- Changes update the whole design\n- Professional and organized!\n\nThe Prisma schema file (schema.prisma) is your database blueprint. It defines your data models, their fields, types, and relationships. Prisma reads this file and:\n1. Creates the database tables for you\n2. Generates TypeScript types automatically\n3. Ensures your code and database always match!\n\nNo more writing SQL CREATE TABLE statements by hand!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Understanding Prisma Schema (schema.prisma file)\n// This is NOT JavaScript - it's Prisma's special language!\n\n// CONCEPTUAL DEMO - showing schema structure in JavaScript comments\n\n/*\nPrisma Schema Structure:\n\n// 1. DATABASE CONNECTION\ndatasource db {\n  provider = \"postgresql\"  // or \"mysql\", \"sqlite\", \"mongodb\"\n  url      = env(\"DATABASE_URL\")  // Connection string from .env\n}\n\n// 2. PRISMA CLIENT GENERATOR\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\n// 3. DATA MODELS (Tables)\n\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  name      String\n  password  String\n  role      String   @default(\"user\")\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  \n  posts     Post[]   // Relationship: User has many Posts\n  profile   Profile? // Relationship: User has one optional Profile\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  viewCount Int      @default(0)\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  \n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n  \n  categories Category[]\n}\n\nmodel Profile {\n  id       Int    @id @default(autoincrement())\n  bio      String?\n  avatar   String?\n  \n  userId   Int    @unique\n  user     User   @relation(fields: [userId], references: [id])\n}\n\nmodel Category {\n  id    Int    @id @default(autoincrement())\n  name  String @unique\n  \n  posts Post[]\n}\n*/\n\n// SCHEMA CONCEPTS EXPLAINED\n\nlet schemaExplanation = {\n  'Field Types': {\n    'String': 'Text data (\"hello\", \"user@example.com\")',\n    'Int': 'Whole numbers (1, 42, 1000)',\n    'Float': 'Decimal numbers (3.14, 99.99)',\n    'Boolean': 'true or false',\n    'DateTime': 'Dates and times',\n    'Json': 'JSON objects (flexible data)'\n  },\n  \n  'Attributes': {\n    '@id': 'Primary key (unique identifier)',\n    '@unique': 'Value must be unique across all records',\n    '@default(value)': 'Default value if not provided',\n    '@updatedAt': 'Auto-updates to current time on changes',\n    '@relation': 'Defines relationships between models'\n  },\n  \n  'Type Modifiers': {\n    'field String': 'Required field (cannot be null)',\n    'field String?': 'Optional field (can be null)',\n    'field String[]': 'Array of strings'\n  },\n  \n  'Default Functions': {\n    'autoincrement()': 'Auto-increment integers (1, 2, 3...)',\n    'now()': 'Current timestamp',\n    'uuid()': 'Generate random UUID',\n    'cuid()': 'Generate random CUID (shorter than UUID)'\n  }\n};\n\nconsole.log('=== Prisma Schema Concepts ===\\n');\n\nfor (let [category, details] of Object.entries(schemaExplanation)) {\n  console.log(category + ':');\n  for (let [key, desc] of Object.entries(details)) {\n    console.log(`  ${key}: ${desc}`);\n  }\n  console.log('');\n}\n\n// EXAMPLE: What this schema creates\n\nlet exampleData = {\n  users: [\n    {\n      id: 1,\n      email: 'alice@example.com',\n      name: 'Alice',\n      password: 'hashed_password',\n      role: 'user',\n      createdAt: new Date('2025-01-01'),\n      updatedAt: new Date('2025-01-15')\n    }\n  ],\n  posts: [\n    {\n      id: 1,\n      title: 'My First Post',\n      content: 'Hello world!',\n      published: true,\n      viewCount: 42,\n      authorId: 1,  // References user with id 1\n      createdAt: new Date('2025-01-10')\n    }\n  ],\n  profiles: [\n    {\n      id: 1,\n      bio: 'Software developer',\n      avatar: 'https://example.com/avatar.jpg',\n      userId: 1  // References user with id 1\n    }\n  ]\n};\n\nconsole.log('Example database structure:');\nconsole.log(JSON.stringify(exampleData, null, 2));\n\n// WORKFLOW\nconsole.log('\\n=== Prisma Schema Workflow ===');\n\nlet workflow = [\n  '1. Write schema.prisma file (define your models)',\n  '2. Run: npx prisma migrate dev --name init',\n  '   → Creates database tables',\n  '   → Creates migration files',\n  '3. Run: npx prisma generate',\n  '   → Generates TypeScript types',\n  '   → Updates Prisma Client',\n  '4. Use in your code with full type safety!'\n];\n\nworkflow.forEach(step => console.log(step));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Prisma Schema Syntax Guide:\n\n1. **File Structure** (schema.prisma):\n   ```prisma\n   // Database connection\n   datasource db {\n     provider = \"postgresql\"\n     url      = env(\"DATABASE_URL\")\n   }\n   \n   // TypeScript client generator\n   generator client {\n     provider = \"prisma-client-js\"\n   }\n   \n   // Your data models\n   model ModelName {\n     // fields here\n   }\n   ```\n\n2. **Field Syntax**:\n   ```prisma\n   model User {\n     fieldName  FieldType  @attribute\n   }\n   ```\n\n3. **Common Field Types**:\n   - `String` - Text (VARCHAR)\n   - `Int` - Integer\n   - `Float` - Decimal number\n   - `Boolean` - true/false\n   - `DateTime` - Timestamp\n   - `Json` - JSON object\n   - `Bytes` - Binary data\n\n4. **Field Attributes**:\n   ```prisma\n   id        Int      @id @default(autoincrement())\n   email     String   @unique\n   name      String   @default(\"Anonymous\")\n   createdAt DateTime @default(now())\n   updatedAt DateTime @updatedAt\n   bio       String?  // ? makes it optional\n   tags      String[] // [] makes it an array\n   ```\n\n5. **Primary Key Options**:\n   ```prisma\n   // Auto-incrementing integer\n   id Int @id @default(autoincrement())\n   \n   // UUID (random unique string)\n   id String @id @default(uuid())\n   \n   // CUID (shorter unique string)\n   id String @id @default(cuid())\n   ```\n\n6. **Unique Constraints**:\n   ```prisma\n   email String @unique  // Single unique field\n   \n   // Compound unique (combination must be unique)\n   @@unique([email, username])\n   ```\n\n7. **Indexes for Performance**:\n   ```prisma\n   email String @unique  // Automatically indexed\n   \n   // Manual index\n   @@index([email])\n   \n   // Compound index\n   @@index([lastName, firstName])\n   ```\n\n8. **Database Providers**:\n   ```prisma\n   provider = \"postgresql\"  // Recommended for production\n   provider = \"mysql\"\n   provider = \"sqlite\"      // Good for development\n   provider = \"sqlserver\"\n   provider = \"mongodb\"\n   provider = \"cockroachdb\"\n   ```\n\n9. **Environment Variables**:\n   ```prisma\n   url = env(\"DATABASE_URL\")\n   ```\n   \n   In your .env file:\n   ```\n   DATABASE_URL=\"postgresql://user:password@localhost:5432/mydb\"\n   ```\n\n10. **Complete Example**:\n    ```prisma\n    datasource db {\n      provider = \"postgresql\"\n      url      = env(\"DATABASE_URL\")\n    }\n    \n    generator client {\n      provider = \"prisma-client-js\"\n    }\n    \n    model User {\n      id        Int      @id @default(autoincrement())\n      email     String   @unique\n      name      String\n      age       Int?\n      isActive  Boolean  @default(true)\n      createdAt DateTime @default(now())\n      updatedAt DateTime @updatedAt\n    }\n    ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Prisma schema mistakes:\n\n1. **Forgetting semicolons or using wrong syntax**:\n   ```prisma\n   // Wrong! Prisma doesn't use semicolons\n   model User {\n     id Int @id;\n   }\n   \n   // Correct!\n   model User {\n     id Int @id\n   }\n   ```\n\n2. **Wrong field type capitalization**:\n   ```prisma\n   // Wrong!\n   name string  // lowercase\n   \n   // Correct!\n   name String  // Pascal case\n   ```\n\n3. **Forgetting @id attribute**:\n   ```prisma\n   // Wrong! Every model needs an @id\n   model User {\n     email String @unique\n     name  String\n   }\n   \n   // Correct!\n   model User {\n     id    Int    @id @default(autoincrement())\n     email String @unique\n     name  String\n   }\n   ```\n\n4. **Using JavaScript syntax in schema**:\n   ```prisma\n   // Wrong! This is not JavaScript\n   model User {\n     isActive: Boolean = true\n   }\n   \n   // Correct! This is Prisma schema language\n   model User {\n     isActive Boolean @default(true)\n   }\n   ```\n\n5. **Wrong default value syntax**:\n   ```prisma\n   // Wrong!\n   createdAt DateTime default(now())\n   \n   // Correct!\n   createdAt DateTime @default(now())\n   ```\n\n6. **Not running migrate after schema changes**:\n   - Changed schema.prisma?\n   - Run: `npx prisma migrate dev`\n   - Otherwise database won't match your schema!\n\n7. **Incorrect optional syntax**:\n   ```prisma\n   // Wrong!\n   bio String | null\n   \n   // Correct!\n   bio String?  // Question mark makes it optional\n   ```\n\n8. **Forgetting environment variables**:\n   - Schema uses: `url = env(\"DATABASE_URL\")`\n   - Must create .env file:\n   ```\n   DATABASE_URL=\"postgresql://user:pass@localhost:5432/db\"\n   ```\n\n9. **Using relations without foreign keys**:\n   ```prisma\n   // Incomplete! Missing authorId field\n   model Post {\n     id     Int  @id @default(autoincrement())\n     author User @relation(fields: [authorId], references: [id])\n   }\n   \n   // Correct!\n   model Post {\n     id       Int  @id @default(autoincrement())\n     authorId Int  // Foreign key field\n     author   User @relation(fields: [authorId], references: [id])\n   }\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.3-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a Prisma schema structure in JavaScript:\n\n1. Create an object called `schema` with a `models` property\n2. Add a 'Product' model with these fields:\n   - id (integer, auto-increment)\n   - name (string, required)\n   - price (number, required)\n   - inStock (boolean, default true)\n   - description (string, optional)\n   - createdAt (date, default now)\n\n3. Create a function `generateModelSQL(model)` that simulates generating SQL\n4. Display the schema structure\n\nYou're simulating what Prisma does internally!",
              "instructions": "Simulate a Prisma schema structure in JavaScript:\n\n1. Create an object called `schema` with a `models` property\n2. Add a 'Product' model with these fields:\n   - id (integer, auto-increment)\n   - name (string, required)\n   - price (number, required)\n   - inStock (boolean, default true)\n   - description (string, optional)\n   - createdAt (date, default now)\n\n3. Create a function `generateModelSQL(model)` that simulates generating SQL\n4. Display the schema structure\n\nYou're simulating what Prisma does internally!",
              "starterCode": "// Simulated Prisma schema structure\nlet schema = {\n  models: {\n    Product: {\n      fields: {\n        id: { type: 'Int', primaryKey: true, autoIncrement: true },\n        name: { type: 'String', required: true },\n        price: { type: 'Float', required: true },\n        inStock: { type: 'Boolean', default: true },\n        description: { type: 'String', required: false },\n        createdAt: { type: 'DateTime', default: 'now()' }\n      }\n    }\n  }\n};\n\n// Function to generate SQL from model\nfunction generateModelSQL(modelName, model) {\n  let sql = `CREATE TABLE ${modelName} (\\n`;\n  \n  let fields = [];\n  for (let [fieldName, field] of Object.entries(model.fields)) {\n    let line = `  ${fieldName} `;\n    \n    // Type mapping\n    if (field.type === 'Int') line += 'INTEGER';\n    else if (field.type === 'String') line += 'TEXT';\n    else if (field.type === 'Float') line += 'REAL';\n    else if (field.type === 'Boolean') line += 'BOOLEAN';\n    else if (field.type === 'DateTime') line += 'TIMESTAMP';\n    \n    // Constraints\n    if (field.primaryKey) line += ' PRIMARY KEY';\n    if (field.autoIncrement) line += ' AUTOINCREMENT';\n    if (field.required) line += ' NOT NULL';\n    if (field.default !== undefined) {\n      if (field.default === 'now()') line += ' DEFAULT CURRENT_TIMESTAMP';\n      else if (typeof field.default === 'boolean') line += ` DEFAULT ${field.default ? 1 : 0}`;\n      else line += ` DEFAULT ${field.default}`;\n    }\n    \n    fields.push(line);\n  }\n  \n  sql += fields.join(',\\n');\n  sql += '\\n);';\n  \n  return sql;\n}\n\n// Generate SQL\nlet sql = generateModelSQL('Product', schema.models.Product);\nconsole.log('Generated SQL:\\n');\nconsole.log(sql);\n\n// Display schema\nconsole.log('\\nPrisma Schema Structure:');\nconsole.log(JSON.stringify(schema, null, 2));",
              "solution": "// Complete Prisma schema simulator\nlet schema = {\n  datasource: {\n    provider: 'postgresql',\n    url: 'env(\"DATABASE_URL\")'\n  },\n  generator: {\n    provider: 'prisma-client-js'\n  },\n  models: {\n    Product: {\n      fields: {\n        id: {\n          type: 'Int',\n          primaryKey: true,\n          autoIncrement: true\n        },\n        name: {\n          type: 'String',\n          required: true\n        },\n        price: {\n          type: 'Float',\n          required: true\n        },\n        inStock: {\n          type: 'Boolean',\n          default: true\n        },\n        description: {\n          type: 'String',\n          required: false\n        },\n        category: {\n          type: 'String',\n          default: 'General'\n        },\n        createdAt: {\n          type: 'DateTime',\n          default: 'now()'\n        },\n        updatedAt: {\n          type: 'DateTime',\n          updatedAt: true\n        }\n      }\n    },\n    Order: {\n      fields: {\n        id: {\n          type: 'Int',\n          primaryKey: true,\n          autoIncrement: true\n        },\n        productId: {\n          type: 'Int',\n          required: true\n        },\n        quantity: {\n          type: 'Int',\n          required: true,\n          default: 1\n        },\n        total: {\n          type: 'Float',\n          required: true\n        },\n        createdAt: {\n          type: 'DateTime',\n          default: 'now()'\n        }\n      }\n    }\n  }\n};\n\nfunction generateModelSQL(modelName, model) {\n  let sql = `CREATE TABLE ${modelName} (\\n`;\n  let fields = [];\n  \n  for (let [fieldName, field] of Object.entries(model.fields)) {\n    let line = `  ${fieldName} `;\n    \n    // Map Prisma types to SQL types\n    let typeMap = {\n      'Int': 'INTEGER',\n      'String': 'TEXT',\n      'Float': 'REAL',\n      'Boolean': 'BOOLEAN',\n      'DateTime': 'TIMESTAMP'\n    };\n    \n    line += typeMap[field.type] || 'TEXT';\n    \n    if (field.primaryKey) line += ' PRIMARY KEY';\n    if (field.autoIncrement) line += ' AUTOINCREMENT';\n    if (field.required) line += ' NOT NULL';\n    \n    if (field.default !== undefined) {\n      if (field.default === 'now()') {\n        line += ' DEFAULT CURRENT_TIMESTAMP';\n      } else if (typeof field.default === 'boolean') {\n        line += ` DEFAULT ${field.default ? 1 : 0}`;\n      } else if (typeof field.default === 'string') {\n        line += ` DEFAULT '${field.default}'`;\n      } else {\n        line += ` DEFAULT ${field.default}`;\n      }\n    }\n    \n    fields.push(line);\n  }\n  \n  sql += fields.join(',\\n');\n  sql += '\\n);';\n  return sql;\n}\n\nconsole.log('=== Prisma Schema Simulator ===\\n');\n\n// Generate SQL for all models\nfor (let [modelName, model] of Object.entries(schema.models)) {\n  console.log(`${modelName} Model SQL:\\n`);\n  console.log(generateModelSQL(modelName, model));\n  console.log('');\n}\n\n// Display schema structure\nconsole.log('Complete Prisma Schema:');\nconsole.log(`datasource: ${schema.datasource.provider}`);\nconsole.log(`generator: ${schema.generator.provider}`);\nconsole.log(`models: ${Object.keys(schema.models).join(', ')}`);\nconsole.log('\\nDetailed Schema:');\nconsole.log(JSON.stringify(schema, null, 2));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Schema has Product model",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Product has required name field",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Create nested objects: schema → models → Product → fields → {id, name, price...}"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common Prisma schema mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common Prisma schema mistakes:"
                },
                {
                  "mistake": "**Forgetting semicolons or using wrong syntax**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting semicolons or using wrong syntax**:\n   ```prisma\n   // Wrong! Prisma doesn't use semicolons\n   model User {\n     id Int @id;\n   }\n   \n   // Correct!\n   model User {\n     id Int @id\n   }\n   ```"
                },
                {
                  "mistake": "**Wrong field type capitalization**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong field type capitalization**:\n   ```prisma\n   // Wrong!\n   name string  // lowercase\n   \n   // Correct!\n   name String  // Pascal case\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "11.4",
          "title": "Running Migrations (The Construction Log Analogy)",
          "moduleId": "module-11",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're building a house over several months:\n\nWithout a construction log:\n- Workers forget what was done yesterday\n- No record of foundation changes\n- Can't rebuild if something breaks\n- No way to share changes with other teams\n- Every site does things differently\n\nWith a construction log (Prisma migrations):\n- Detailed record of every change\n- Day 1: Poured foundation\n- Day 5: Built first floor walls\n- Day 10: Added plumbing\n- Any worker can see the full history\n- Can replay changes to build identical houses\n\nPrisma migrations are a construction log for your database. Each migration file records ONE specific change (like adding a table or field). These files:\n1. Track database evolution over time\n2. Can be replayed on other computers\n3. Make it easy to update production databases\n4. Keep your team synchronized\n\nInstead of manually writing SQL to update your database, Prisma generates migration files automatically from your schema changes!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Understanding Prisma Migrations\n// Migrations are SQL files that modify your database structure\n\n// SCENARIO: Building a blog app\n\n// Step 1: Initial schema (schema.prisma)\n/*\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String\n}\n*/\n\n// Run migration command:\n// npx prisma migrate dev --name init\n\n// Prisma generates:\n// migrations/20250114_init/migration.sql\n/*\nCREATE TABLE \"User\" (\n  \"id\" INTEGER PRIMARY KEY AUTOINCREMENT,\n  \"email\" TEXT UNIQUE NOT NULL,\n  \"name\" TEXT NOT NULL\n);\n*/\n\nconsole.log('Migration 1: Created User table');\n\n// Step 2: Add posts table\n// Update schema.prisma:\n/*\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String\n  posts Post[]  // NEW: Added relationship\n}\n\nmodel Post {  // NEW: Added entire model\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n}\n*/\n\n// Run migration:\n// npx prisma migrate dev --name add_posts\n\n// Prisma generates:\n// migrations/20250114_add_posts/migration.sql\n/*\nCREATE TABLE \"Post\" (\n  \"id\" INTEGER PRIMARY KEY AUTOINCREMENT,\n  \"title\" TEXT NOT NULL,\n  \"content\" TEXT,\n  \"published\" BOOLEAN NOT NULL DEFAULT 0,\n  \"authorId\" INTEGER NOT NULL,\n  FOREIGN KEY (\"authorId\") REFERENCES \"User\"(\"id\")\n);\n*/\n\nconsole.log('Migration 2: Created Post table with relationship to User');\n\n// Step 3: Add createdAt timestamps\n// Update schema.prisma:\n/*\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  name      String\n  createdAt DateTime @default(now())  // NEW\n  posts     Post[]\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  createdAt DateTime @default(now())  // NEW\n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n}\n*/\n\n// Run migration:\n// npx prisma migrate dev --name add_timestamps\n\n// Prisma generates:\n// migrations/20250114_add_timestamps/migration.sql\n/*\nALTER TABLE \"User\" ADD COLUMN \"createdAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;\nALTER TABLE \"Post\" ADD COLUMN \"createdAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;\n*/\n\nconsole.log('Migration 3: Added createdAt to User and Post tables');\n\n// MIGRATION COMMANDS EXPLAINED\n\nlet migrationCommands = {\n  'Development': {\n    'npx prisma migrate dev': 'Create and apply migrations in development',\n    'npx prisma migrate dev --name <name>': 'Create migration with descriptive name',\n    'npx prisma migrate reset': 'Reset database and replay all migrations',\n    'npx prisma db push': 'Quick prototype without creating migration file'\n  },\n  \n  'Production': {\n    'npx prisma migrate deploy': 'Apply pending migrations to production',\n    'npx prisma migrate resolve': 'Mark migration as applied/rolled back',\n    'npx prisma migrate status': 'Check which migrations are pending'\n  },\n  \n  'Inspection': {\n    'npx prisma migrate diff': 'Compare database to schema',\n    'npx prisma db pull': 'Introspect existing database to generate schema',\n    'npx prisma studio': 'Visual database browser'\n  }\n};\n\nconsole.log('\\n=== Prisma Migration Commands ===\\n');\n\nfor (let [category, commands] of Object.entries(migrationCommands)) {\n  console.log(category + ' Commands:');\n  for (let [cmd, desc] of Object.entries(commands)) {\n    console.log(`  ${cmd}`);\n    console.log(`    → ${desc}`);\n  }\n  console.log('');\n}\n\n// MIGRATION WORKFLOW SIMULATION\n\nlet migrationHistory = [\n  {\n    name: '20250114_init',\n    description: 'Initial database setup',\n    changes: ['Created User table']\n  },\n  {\n    name: '20250114_add_posts',\n    description: 'Add blog posts',\n    changes: ['Created Post table', 'Added User.posts relation']\n  },\n  {\n    name: '20250114_add_timestamps',\n    description: 'Add audit timestamps',\n    changes: ['Added User.createdAt', 'Added Post.createdAt']\n  }\n];\n\nconsole.log('Migration History:');\nmigrationHistory.forEach((migration, index) => {\n  console.log(`\\n${index + 1}. ${migration.name}`);\n  console.log(`   Description: ${migration.description}`);\n  console.log('   Changes:');\n  migration.changes.forEach(change => {\n    console.log(`     - ${change}`);\n  });\n});\n\n// BENEFITS OF MIGRATIONS\n\nlet benefits = [\n  'Version control: Track database changes like code',\n  'Reproducible: Same migrations = identical databases',\n  'Team sync: Everyone applies same changes',\n  'Rollback: Can undo changes if needed',\n  'Production safety: Test migrations before deploying',\n  'Documentation: Clear history of schema evolution',\n  'CI/CD: Automated database updates in pipelines'\n];\n\nconsole.log('\\nBenefits of Migrations:');\nbenefits.forEach(benefit => console.log(`  ✓ ${benefit}`));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Prisma Migration Commands Guide:\n\n1. **Creating Migrations** (Development):\n   ```bash\n   # Standard workflow\n   npx prisma migrate dev --name add_user_table\n   \n   # What this does:\n   # 1. Compares schema.prisma to current database\n   # 2. Generates SQL migration file\n   # 3. Applies migration to database\n   # 4. Runs prisma generate (updates Prisma Client)\n   ```\n\n2. **Migration File Structure**:\n   ```\n   prisma/\n   ├── schema.prisma\n   └── migrations/\n       ├── 20250114120000_init/\n       │   └── migration.sql\n       ├── 20250114130000_add_posts/\n       │   └── migration.sql\n       └── migration_lock.toml\n   ```\n\n3. **Example Migration File**:\n   ```sql\n   -- CreateTable\n   CREATE TABLE \"User\" (\n       \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n       \"email\" TEXT NOT NULL,\n       \"name\" TEXT NOT NULL\n   );\n   \n   -- CreateIndex\n   CREATE UNIQUE INDEX \"User_email_key\" ON \"User\"(\"email\");\n   ```\n\n4. **Common Migration Workflows**:\n\n   **First Migration**:\n   ```bash\n   # 1. Write schema.prisma\n   # 2. Create initial migration\n   npx prisma migrate dev --name init\n   ```\n\n   **Add New Table**:\n   ```bash\n   # 1. Add model to schema.prisma\n   # 2. Create migration\n   npx prisma migrate dev --name add_posts\n   ```\n\n   **Modify Existing Table**:\n   ```bash\n   # 1. Update model in schema.prisma\n   # 2. Create migration\n   npx prisma migrate dev --name add_user_bio\n   ```\n\n5. **Development vs Production**:\n\n   **Development** (migrate dev):\n   - Creates migration files\n   - Applies to local database\n   - Updates Prisma Client\n   - Can reset database easily\n   \n   ```bash\n   npx prisma migrate dev\n   ```\n\n   **Production** (migrate deploy):\n   - Only applies existing migrations\n   - Never creates new migrations\n   - Safe for production\n   - No schema changes\n   \n   ```bash\n   npx prisma migrate deploy\n   ```\n\n6. **Reset Database** (Development Only!):\n   ```bash\n   npx prisma migrate reset\n   \n   # This:\n   # 1. Drops entire database\n   # 2. Creates new database\n   # 3. Applies all migrations\n   # 4. Runs seed script (if exists)\n   ```\n\n7. **Prototyping Without Migrations**:\n   ```bash\n   npx prisma db push\n   \n   # Use when:\n   # - Early prototyping\n   # - Don't want migration files yet\n   # - Quick schema tests\n   \n   # DON'T use in production!\n   ```\n\n8. **Check Migration Status**:\n   ```bash\n   npx prisma migrate status\n   \n   # Shows:\n   # - Applied migrations\n   # - Pending migrations\n   # - Database drift (manual changes)\n   ```\n\n9. **Naming Conventions**:\n   ```bash\n   # Good names (descriptive):\n   npx prisma migrate dev --name init\n   npx prisma migrate dev --name add_user_profile\n   npx prisma migrate dev --name make_email_unique\n   npx prisma migrate dev --name add_post_comments\n   \n   # Bad names (not descriptive):\n   npx prisma migrate dev --name update\n   npx prisma migrate dev --name fix\n   npx prisma migrate dev --name changes\n   ```\n\n10. **Full Deployment Workflow**:\n    ```bash\n    # Development:\n    git checkout -b feature/add-comments\n    # Update schema.prisma\n    npx prisma migrate dev --name add_comments\n    git add prisma/\n    git commit -m \"Add comments table\"\n    git push\n    \n    # Production (CI/CD or manual):\n    git pull\n    npx prisma migrate deploy  # Apply pending migrations\n    npm run build\n    npm run start\n    ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common migration mistakes:\n\n1. **Forgetting to run migrations**:\n   ```bash\n   # Changed schema.prisma but database not updated!\n   \n   # Must run:\n   npx prisma migrate dev\n   ```\n\n2. **Using db push in production**:\n   ```bash\n   # NEVER do this in production:\n   npx prisma db push  # No migration history!\n   \n   # Use migrate deploy instead:\n   npx prisma migrate deploy\n   ```\n\n3. **Editing migration files manually**:\n   - Don't edit generated migrations unless absolutely necessary\n   - Prisma tracks checksums - manual edits can cause errors\n   - Better: create new migration to fix issues\n\n4. **Not committing migration files**:\n   ```bash\n   # WRONG: Ignoring migrations in .gitignore\n   prisma/migrations/  # Don't do this!\n   \n   # CORRECT: Commit migrations to git\n   git add prisma/migrations/\n   git commit -m \"Add user table migration\"\n   ```\n\n5. **Running migrate dev in production**:\n   ```bash\n   # Development:\n   npx prisma migrate dev  # Creates migrations\n   \n   # Production:\n   npx prisma migrate deploy  # Only applies existing migrations\n   ```\n\n6. **Schema drift (manual database changes)**:\n   ```bash\n   # Problem: Someone manually altered database\n   # Solution: Check drift\n   npx prisma migrate diff\n   \n   # Then either:\n   # - Revert manual changes\n   # - Create migration to match changes\n   ```\n\n7. **Migration conflicts in teams**:\n   ```bash\n   # Two developers create migrations at same time\n   # Git merge conflict in migrations folder\n   \n   # Resolution:\n   # 1. Pull latest changes\n   # 2. Reset local database\n   npx prisma migrate reset\n   # 3. Migrations will replay in correct order\n   ```\n\n8. **Forgetting to generate Prisma Client**:\n   ```bash\n   # After migration, types might be outdated\n   npx prisma generate\n   \n   # Or use migrate dev which does it automatically\n   npx prisma migrate dev\n   ```\n\n9. **Not testing migrations**:\n   ```bash\n   # Best practice:\n   # 1. Create migration in development\n   npx prisma migrate dev --name add_feature\n   \n   # 2. Test thoroughly\n   npm run test\n   \n   # 3. Deploy to staging\n   npx prisma migrate deploy\n   \n   # 4. Test staging\n   \n   # 5. Deploy to production\n   npx prisma migrate deploy\n   ```\n\n10. **Breaking changes without data migration**:\n    ```prisma\n    // Dangerous: Deleting field loses data!\n    model User {\n      id    Int    @id\n      email String\n      // name String  ← Deleted! Data lost!\n    }\n    \n    // Better: Make optional first, then remove later\n    model User {\n      id    Int     @id\n      email String\n      name  String? ← Made optional, can migrate data\n    }\n    ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.4-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a migration system:\n\n1. Create a `migrations` array to store migration records\n2. Create a function `createMigration(name, sql)` that:\n   - Generates a timestamp\n   - Creates migration object\n   - Adds to migrations array\n   - Returns the migration\n3. Create a function `applyMigrations()` that:\n   - Loops through all migrations\n   - Simulates executing SQL\n   - Tracks which are applied\n4. Simulate creating 3 migrations:\n   - 'init' (create users table)\n   - 'add_posts' (create posts table)\n   - 'add_timestamps' (add createdAt fields)\n5. Display migration history\n\nYou're simulating what Prisma does!",
              "instructions": "Simulate a migration system:\n\n1. Create a `migrations` array to store migration records\n2. Create a function `createMigration(name, sql)` that:\n   - Generates a timestamp\n   - Creates migration object\n   - Adds to migrations array\n   - Returns the migration\n3. Create a function `applyMigrations()` that:\n   - Loops through all migrations\n   - Simulates executing SQL\n   - Tracks which are applied\n4. Simulate creating 3 migrations:\n   - 'init' (create users table)\n   - 'add_posts' (create posts table)\n   - 'add_timestamps' (add createdAt fields)\n5. Display migration history\n\nYou're simulating what Prisma does!",
              "starterCode": "// Migration system simulator\nlet migrations = [];\nlet appliedMigrations = new Set();\n\n// Create migration\nfunction createMigration(name, sql) {\n  let timestamp = Date.now();\n  let migration = {\n    id: `${timestamp}_${name}`,\n    name: name,\n    sql: sql,\n    createdAt: new Date().toISOString()\n  };\n  \n  migrations.push(migration);\n  console.log(`✓ Created migration: ${migration.id}`);\n  return migration;\n}\n\n// Apply migrations\nfunction applyMigrations() {\n  console.log('\\nApplying migrations...');\n  \n  for (let migration of migrations) {\n    if (!appliedMigrations.has(migration.id)) {\n      console.log(`  Running: ${migration.name}`);\n      console.log(`  SQL: ${migration.sql}`);\n      appliedMigrations.add(migration.id);\n      console.log(`  ✓ Applied: ${migration.id}\\n`);\n    } else {\n      console.log(`  ⊘ Skipped (already applied): ${migration.name}`);\n    }\n  }\n}\n\n// Get migration status\nfunction getMigrationStatus() {\n  console.log('=== Migration Status ===');\n  console.log(`Total migrations: ${migrations.length}`);\n  console.log(`Applied: ${appliedMigrations.size}`);\n  console.log(`Pending: ${migrations.length - appliedMigrations.size}`);\n}\n\n// Create migrations\nconsole.log('=== Creating Migrations ===\\n');\n\ncreateMigration('init', 'CREATE TABLE users (id INT, email TEXT, name TEXT);');\n\nsetTimeout(() => {\n  createMigration('add_posts', 'CREATE TABLE posts (id INT, title TEXT, author_id INT);');\n}, 100);\n\nsetTimeout(() => {\n  createMigration('add_timestamps', 'ALTER TABLE users ADD COLUMN created_at TIMESTAMP;');\n}, 200);\n\nsetTimeout(() => {\n  applyMigrations();\n  getMigrationStatus();\n  \n  console.log('\\n=== Migration History ===');\n  migrations.forEach((m, i) => {\n    let status = appliedMigrations.has(m.id) ? '✓ Applied' : '⏳ Pending';\n    console.log(`${i + 1}. ${m.name} - ${status}`);\n  });\n}, 400);",
              "solution": "// Complete migration system simulator\nlet migrations = [];\nlet appliedMigrations = new Set();\nlet database = {\n  tables: {},\n  indexes: []\n};\n\nfunction createMigration(name, description, sql) {\n  let timestamp = Date.now();\n  let migration = {\n    id: `${timestamp}_${name}`,\n    name: name,\n    description: description,\n    sql: sql,\n    createdAt: new Date().toISOString(),\n    applied: false\n  };\n  \n  migrations.push(migration);\n  console.log(`✓ Created migration: ${migration.id}`);\n  console.log(`  Description: ${description}`);\n  return migration;\n}\n\nfunction applyMigrations() {\n  console.log('\\n=== Applying Migrations ===\\n');\n  \n  let applied = 0;\n  for (let migration of migrations) {\n    if (!appliedMigrations.has(migration.id)) {\n      console.log(`Running: ${migration.name}`);\n      console.log(`SQL: ${migration.sql}`);\n      \n      // Simulate executing SQL\n      executeSQLSimulation(migration.sql);\n      \n      appliedMigrations.add(migration.id);\n      migration.applied = true;\n      applied++;\n      \n      console.log(`✓ Applied: ${migration.id}\\n`);\n    } else {\n      console.log(`⊘ Skipped (already applied): ${migration.name}\\n`);\n    }\n  }\n  \n  console.log(`Completed: ${applied} migration(s) applied`);\n}\n\nfunction executeSQLSimulation(sql) {\n  // Simulate SQL execution\n  if (sql.includes('CREATE TABLE')) {\n    let match = sql.match(/CREATE TABLE (\\w+)/);\n    if (match) {\n      let tableName = match[1];\n      database.tables[tableName] = { created: true };\n      console.log(`  → Created table: ${tableName}`);\n    }\n  } else if (sql.includes('ALTER TABLE')) {\n    console.log('  → Altered table structure');\n  }\n}\n\nfunction getMigrationStatus() {\n  console.log('\\n=== Migration Status ===');\n  console.log(`Total migrations: ${migrations.length}`);\n  console.log(`Applied: ${appliedMigrations.size}`);\n  console.log(`Pending: ${migrations.length - appliedMigrations.size}`);\n  console.log(`Database tables: ${Object.keys(database.tables).join(', ') || 'none'}`);\n}\n\nfunction rollbackLastMigration() {\n  let lastApplied = migrations.filter(m => m.applied).pop();\n  if (lastApplied) {\n    appliedMigrations.delete(lastApplied.id);\n    lastApplied.applied = false;\n    console.log(`\\n✓ Rolled back: ${lastApplied.name}`);\n  } else {\n    console.log('\\nNo migrations to roll back');\n  }\n}\n\nfunction listMigrations() {\n  console.log('\\n=== Migration History ===');\n  migrations.forEach((m, i) => {\n    let status = m.applied ? '✓ Applied' : '⏳ Pending';\n    console.log(`${i + 1}. ${m.name}`);\n    console.log(`   ID: ${m.id}`);\n    console.log(`   Status: ${status}`);\n    console.log(`   Created: ${m.createdAt}`);\n    console.log(`   Description: ${m.description}`);\n    console.log('');\n  });\n}\n\n// Create migrations\nconsole.log('=== Migration System Simulator ===\\n');\n\ncreateMigration(\n  'init',\n  'Initial database setup',\n  'CREATE TABLE users (id INT PRIMARY KEY, email TEXT UNIQUE, name TEXT);'\n);\n\nsetTimeout(() => {\n  createMigration(\n    'add_posts',\n    'Add blog posts table',\n    'CREATE TABLE posts (id INT PRIMARY KEY, title TEXT, content TEXT, author_id INT);'\n  );\n}, 100);\n\nsetTimeout(() => {\n  createMigration(\n    'add_timestamps',\n    'Add audit timestamps',\n    'ALTER TABLE users ADD COLUMN created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;'\n  );\n}, 200);\n\nsetTimeout(() => {\n  applyMigrations();\n  getMigrationStatus();\n  listMigrations();\n}, 400);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Creates migration with timestamp",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Tracks applied migrations",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use timestamps for unique IDs, Set to track applied migrations, loops to apply each one"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common migration mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common migration mistakes:"
                },
                {
                  "mistake": "**Forgetting to run migrations**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting to run migrations**:\n   ```bash\n   # Changed schema.prisma but database not updated!\n   \n   # Must run:\n   npx prisma migrate dev\n   ```"
                },
                {
                  "mistake": "**Using db push in production**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Using db push in production**:\n   ```bash\n   # NEVER do this in production:\n   npx prisma db push  # No migration history!\n   \n   # Use migrate deploy instead:\n   npx prisma migrate deploy\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "11.5",
          "title": "Handling Relations (The Social Network Analogy)",
          "moduleId": "module-11",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine designing a social network:\n\nWithout relationships:\n- Each user's posts stored separately\n- No way to find who wrote which post\n- Comments disconnected from posts\n- Can't see friends list\n- Data duplication everywhere!\n\nWith relationships (Prisma relations):\n- Users ← many → Posts (one user has many posts)\n- Posts ← many → Comments (one post has many comments)\n- Users ← many ↔ many → Users (users can follow each other)\n- Data connected logically\n- No duplication!\n\nDatabase relations are like links between different entities. They mirror real-world connections:\n- A customer has many orders\n- A blog post has many comments\n- A student enrolls in many courses\n\nPrisma makes defining these relationships incredibly simple with its intuitive syntax!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Understanding Prisma Relations\n\n// THREE TYPES OF RELATIONSHIPS:\n\n// 1. ONE-TO-MANY (Most common)\n// Example: One user has many posts\n/*\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String\n  \n  posts Post[]  // Array: User has many posts\n}\n\nmodel Post {\n  id       Int    @id @default(autoincrement())\n  title    String\n  content  String?\n  \n  authorId Int    // Foreign key\n  author   User   @relation(fields: [authorId], references: [id])\n}\n*/\n\nconsole.log('=== ONE-TO-MANY Relationship ===');\nconsole.log('One User → Many Posts');\nconsole.log('Schema: User.posts (array), Post.author (single)');\nconsole.log('');\n\n// Example data structure:\nlet oneToManyExample = {\n  user: {\n    id: 1,\n    email: 'alice@example.com',\n    name: 'Alice',\n    posts: [  // Array of posts\n      { id: 1, title: 'First Post', authorId: 1 },\n      { id: 2, title: 'Second Post', authorId: 1 },\n      { id: 3, title: 'Third Post', authorId: 1 }\n    ]\n  }\n};\n\nconsole.log('Example data:');\nconsole.log(JSON.stringify(oneToManyExample, null, 2));\nconsole.log('');\n\n// 2. ONE-TO-ONE (Less common)\n// Example: One user has one profile\n/*\nmodel User {\n  id      Int      @id @default(autoincrement())\n  email   String   @unique\n  name    String\n  \n  profile Profile? // Optional: User might not have profile yet\n}\n\nmodel Profile {\n  id     Int    @id @default(autoincrement())\n  bio    String?\n  avatar String?\n  \n  userId Int     @unique  // UNIQUE makes it one-to-one!\n  user   User    @relation(fields: [userId], references: [id])\n}\n*/\n\nconsole.log('=== ONE-TO-ONE Relationship ===');\nconsole.log('One User → One Profile');\nconsole.log('Schema: Profile.userId must be @unique');\nconsole.log('');\n\nlet oneToOneExample = {\n  user: {\n    id: 1,\n    email: 'alice@example.com',\n    name: 'Alice',\n    profile: {  // Single profile object\n      id: 1,\n      bio: 'Software developer',\n      avatar: 'https://example.com/alice.jpg',\n      userId: 1\n    }\n  }\n};\n\nconsole.log('Example data:');\nconsole.log(JSON.stringify(oneToOneExample, null, 2));\nconsole.log('');\n\n// 3. MANY-TO-MANY (Complex but powerful)\n// Example: Users can like many posts, posts can be liked by many users\n/*\nmodel User {\n  id        Int    @id @default(autoincrement())\n  email     String @unique\n  name      String\n  \n  likedPosts Post[] @relation(\"PostLikes\")\n}\n\nmodel Post {\n  id       Int      @id @default(autoincrement())\n  title    String\n  content  String?\n  \n  likedBy  User[]   @relation(\"PostLikes\")\n}\n\n// Prisma creates a join table automatically:\n// _PostLikes (userId, postId)\n*/\n\nconsole.log('=== MANY-TO-MANY Relationship ===');\nconsole.log('Many Users ↔ Many Posts (likes)');\nconsole.log('Schema: Both sides have arrays, named relation');\nconsole.log('Prisma auto-creates join table: _PostLikes');\nconsole.log('');\n\nlet manyToManyExample = {\n  user: {\n    id: 1,\n    name: 'Alice',\n    likedPosts: [  // Array of posts Alice liked\n      { id: 5, title: 'Cool Post' },\n      { id: 7, title: 'Amazing Article' }\n    ]\n  },\n  post: {\n    id: 5,\n    title: 'Cool Post',\n    likedBy: [  // Array of users who liked this post\n      { id: 1, name: 'Alice' },\n      { id: 2, name: 'Bob' },\n      { id: 3, name: 'Charlie' }\n    ]\n  }\n};\n\nconsole.log('Example data:');\nconsole.log(JSON.stringify(manyToManyExample, null, 2));\nconsole.log('');\n\n// EXPLICIT MANY-TO-MANY (when you need extra fields)\n// Example: User enrollments in courses (with enrollment date)\n/*\nmodel User {\n  id          Int          @id @default(autoincrement())\n  name        String\n  enrollments Enrollment[]\n}\n\nmodel Course {\n  id          Int          @id @default(autoincrement())\n  title       String\n  enrollments Enrollment[]\n}\n\nmodel Enrollment {\n  id         Int      @id @default(autoincrement())\n  enrolledAt DateTime @default(now())\n  grade      String?\n  \n  userId     Int\n  user       User     @relation(fields: [userId], references: [id])\n  \n  courseId   Int\n  course     Course   @relation(fields: [courseId], references: [id])\n  \n  @@unique([userId, courseId])  // Can't enroll in same course twice\n}\n*/\n\nconsole.log('=== EXPLICIT MANY-TO-MANY ===');\nconsole.log('When you need extra fields on the relationship');\nconsole.log('Example: Enrollment date, grade, status');\nconsole.log('');\n\n// QUERYING RELATIONS WITH PRISMA CLIENT\n\nlet queryExamples = [\n  '// Get user with all their posts',\n  'let user = await prisma.user.findUnique({',\n  '  where: { id: 1 },',\n  '  include: { posts: true }  // Include related posts',\n  '});',\n  '',\n  '// Get post with author info',\n  'let post = await prisma.post.findUnique({',\n  '  where: { id: 1 },',\n  '  include: { author: true }  // Include related user',\n  '});',\n  '',\n  '// Create post with author connection',\n  'let post = await prisma.post.create({',\n  '  data: {',\n  '    title: \"New Post\",',\n  '    content: \"Hello!\",',\n  '    author: {',\n  '      connect: { id: 1 }  // Connect to existing user',\n  '    }',\n  '  }',\n  '});',\n  '',\n  '// Create user with posts in one go',\n  'let user = await prisma.user.create({',\n  '  data: {',\n  '    email: \"bob@example.com\",',\n  '    name: \"Bob\",',\n  '    posts: {',\n  '      create: [  // Create posts at same time',\n  '        { title: \"First\", content: \"Content 1\" },',\n  '        { title: \"Second\", content: \"Content 2\" }',\n  '      ]',\n  '    }',\n  '  }',\n  '});'\n];\n\nconsole.log('Querying Relations:');\nqueryExamples.forEach(line => console.log(line));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Prisma Relations Syntax Guide:\n\n1. **ONE-TO-MANY Relationship**:\n   ```prisma\n   model User {\n     id    Int    @id @default(autoincrement())\n     posts Post[] // Relation field (no column in database)\n   }\n   \n   model Post {\n     id       Int  @id @default(autoincrement())\n     authorId Int  // Foreign key (actual column)\n     author   User @relation(fields: [authorId], references: [id])\n   }\n   ```\n   \n   Key points:\n   - \"Many\" side: array type (Post[])\n   - \"One\" side: singular type + @relation\n   - Foreign key: actual database column\n   - Relation field: virtual, not in database\n\n2. **ONE-TO-ONE Relationship**:\n   ```prisma\n   model User {\n     id      Int      @id\n     profile Profile? // Optional (user might not have profile)\n   }\n   \n   model Profile {\n     id     Int  @id\n     userId Int  @unique // UNIQUE makes it one-to-one!\n     user   User @relation(fields: [userId], references: [id])\n   }\n   ```\n   \n   Key points:\n   - Foreign key must be @unique\n   - One side usually optional (?)\n\n3. **MANY-TO-MANY (Implicit)**:\n   ```prisma\n   model User {\n     id    Int    @id\n     posts Post[] @relation(\"UserLikes\")\n   }\n   \n   model Post {\n     id     Int    @id\n     likedBy User[] @relation(\"UserLikes\")\n   }\n   ```\n   \n   Key points:\n   - Both sides are arrays\n   - Named relation (\"UserLikes\")\n   - Prisma auto-creates join table (_UserLikes)\n   - No foreign keys needed!\n\n4. **MANY-TO-MANY (Explicit)**:\n   ```prisma\n   model User {\n     id          Int          @id\n     enrollments Enrollment[]\n   }\n   \n   model Course {\n     id          Int          @id\n     enrollments Enrollment[]\n   }\n   \n   model Enrollment {\n     id       Int      @id\n     userId   Int\n     user     User     @relation(fields: [userId], references: [id])\n     courseId Int\n     course   Course   @relation(fields: [courseId], references: [id])\n     \n     enrolledAt DateTime @default(now())\n     grade      String?\n     \n     @@unique([userId, courseId])\n   }\n   ```\n   \n   Use when you need:\n   - Extra fields (enrolledAt, grade)\n   - Composite unique constraints\n   - More control over join table\n\n5. **Relation Attributes**:\n   ```prisma\n   @relation(fields: [authorId], references: [id])\n   ```\n   \n   - `fields`: Foreign key in this model\n   - `references`: Primary key in related model\n   - Both are arrays (can be composite keys)\n\n6. **Cascade Delete** (be careful!):\n   ```prisma\n   model User {\n     id    Int    @id\n     posts Post[]\n   }\n   \n   model Post {\n     id       Int  @id\n     authorId Int\n     author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)\n   }\n   ```\n   \n   Options:\n   - `Cascade`: Delete posts when user deleted\n   - `SetNull`: Set authorId to null\n   - `Restrict`: Prevent deletion if posts exist\n   - `NoAction`: Database default\n\n7. **Self-Relations** (like followers):\n   ```prisma\n   model User {\n     id         Int    @id\n     followers  User[] @relation(\"UserFollows\")\n     following  User[] @relation(\"UserFollows\")\n   }\n   ```\n\n8. **Querying Relations**:\n   ```typescript\n   // Include related data\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: {\n       posts: true,\n       profile: true\n     }\n   });\n   \n   // Select specific fields\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     select: {\n       name: true,\n       posts: {\n         select: {\n           title: true,\n           createdAt: true\n         }\n       }\n     }\n   });\n   \n   // Filter relations\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: {\n       posts: {\n         where: { published: true },\n         orderBy: { createdAt: 'desc' },\n         take: 5\n       }\n     }\n   });\n   ```\n\n9. **Creating with Relations**:\n   ```typescript\n   // Connect to existing\n   await prisma.post.create({\n     data: {\n       title: 'New Post',\n       author: { connect: { id: 1 } }\n     }\n   });\n   \n   // Create related\n   await prisma.user.create({\n     data: {\n       email: 'bob@example.com',\n       posts: {\n         create: [\n           { title: 'First Post' },\n           { title: 'Second Post' }\n         ]\n       }\n     }\n   });\n   \n   // Nested writes\n   await prisma.user.update({\n     where: { id: 1 },\n     data: {\n       posts: {\n         create: { title: 'Another Post' },\n         delete: { id: 5 },\n         update: {\n           where: { id: 3 },\n           data: { title: 'Updated Title' }\n         }\n       }\n     }\n   });\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common relation mistakes:\n\n1. **Forgetting foreign key field**:\n   ```prisma\n   // WRONG! Missing authorId\n   model Post {\n     id     Int  @id\n     author User @relation(fields: [authorId], references: [id])\n   }\n   \n   // CORRECT!\n   model Post {\n     id       Int  @id\n     authorId Int  // Foreign key field\n     author   User @relation(fields: [authorId], references: [id])\n   }\n   ```\n\n2. **Wrong array syntax**:\n   ```prisma\n   // WRONG!\n   model User {\n     posts Post  // Missing brackets!\n   }\n   \n   // CORRECT!\n   model User {\n     posts Post[]  // Array of posts\n   }\n   ```\n\n3. **Missing @relation name for many-to-many**:\n   ```prisma\n   // WRONG! Ambiguous relation\n   model User {\n     posts Post[]\n   }\n   model Post {\n     users User[]\n   }\n   \n   // CORRECT!\n   model User {\n     posts Post[] @relation(\"UserPosts\")\n   }\n   model Post {\n     users User[] @relation(\"UserPosts\")\n   }\n   ```\n\n4. **Not using @unique for one-to-one**:\n   ```prisma\n   // WRONG! This is one-to-many without @unique\n   model Profile {\n     userId Int\n     user   User @relation(fields: [userId], references: [id])\n   }\n   \n   // CORRECT! @unique makes it one-to-one\n   model Profile {\n     userId Int  @unique\n     user   User @relation(fields: [userId], references: [id])\n   }\n   ```\n\n5. **Forgetting include in queries**:\n   ```typescript\n   // WRONG! This doesn't include posts\n   const user = await prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.posts);  // undefined!\n   \n   // CORRECT!\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: { posts: true }\n   });\n   console.log(user.posts);  // Array of posts\n   ```\n\n6. **Cascade delete pitfalls**:\n   ```prisma\n   // DANGEROUS! Deleting user deletes all posts\n   model Post {\n     authorId Int\n     author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)\n   }\n   \n   // Better: Prevent deletion if posts exist\n   model Post {\n     authorId Int\n     author   User @relation(fields: [authorId], references: [id], onDelete: Restrict)\n   }\n   ```\n\n7. **Creating without connecting**:\n   ```typescript\n   // WRONG! Post needs an author\n   await prisma.post.create({\n     data: {\n       title: 'New Post'\n       // Missing author connection!\n     }\n   });\n   \n   // CORRECT!\n   await prisma.post.create({\n     data: {\n       title: 'New Post',\n       author: { connect: { id: 1 } }\n     }\n   });\n   ```\n\n8. **Self-relation confusion**:\n   ```prisma\n   // WRONG! Ambiguous self-relation\n   model User {\n     followers User[]\n     following User[]\n   }\n   \n   // CORRECT! Named relation\n   model User {\n     followers User[] @relation(\"UserFollows\")\n     following User[] @relation(\"UserFollows\")\n   }\n   ```\n\n9. **Not understanding implicit vs explicit many-to-many**:\n   ```prisma\n   // Implicit: Prisma manages join table\n   model User {\n     posts Post[] @relation(\"Likes\")\n   }\n   model Post {\n     likedBy User[] @relation(\"Likes\")\n   }\n   \n   // Explicit: You control join table (when you need extra fields)\n   model User {\n     likes Like[]\n   }\n   model Post {\n     likes Like[]\n   }\n   model Like {\n     userId Int\n     user   User @relation(fields: [userId], references: [id])\n     postId Int\n     post   Post @relation(fields: [postId], references: [id])\n     likedAt DateTime @default(now())  // Extra field!\n   }\n   ```\n\n10. **Relation filtering mistakes**:\n    ```typescript\n    // WRONG! Can't filter like this\n    const users = await prisma.user.findMany({\n      where: { posts.published: true }  // Error!\n    });\n    \n    // CORRECT! Use relation filters\n    const users = await prisma.user.findMany({\n      where: {\n        posts: {\n          some: { published: true }  // Users with at least one published post\n        }\n      }\n    });\n    ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.5-challenge",
              "title": "Practice Challenge",
              "description": "Simulate Prisma relations:\n\n1. Create a schema object with three models:\n   - Author (id, name, books array)\n   - Book (id, title, authorId, author)\n   - Category (id, name, books array)\n2. Set up a one-to-many relation: Author → Books\n3. Set up a many-to-many relation: Books ↔ Categories\n4. Create sample data showing:\n   - One author with multiple books\n   - Books connected to multiple categories\n5. Create a function `getAuthorWithBooks(authorId)` that returns author with their books\n6. Display the relational data\n\nYou're simulating Prisma's relation system!",
              "instructions": "Simulate Prisma relations:\n\n1. Create a schema object with three models:\n   - Author (id, name, books array)\n   - Book (id, title, authorId, author)\n   - Category (id, name, books array)\n2. Set up a one-to-many relation: Author → Books\n3. Set up a many-to-many relation: Books ↔ Categories\n4. Create sample data showing:\n   - One author with multiple books\n   - Books connected to multiple categories\n5. Create a function `getAuthorWithBooks(authorId)` that returns author with their books\n6. Display the relational data\n\nYou're simulating Prisma's relation system!",
              "starterCode": "// Simulated Prisma relations\nlet database = {\n  authors: [\n    {\n      id: 1,\n      name: 'J.K. Rowling',\n      books: []  // Will populate\n    }\n  ],\n  books: [\n    {\n      id: 1,\n      title: 'Harry Potter',\n      authorId: 1,\n      categories: []  // Will populate\n    },\n    {\n      id: 2,\n      title: 'Fantastic Beasts',\n      authorId: 1,\n      categories: []\n    }\n  ],\n  categories: [\n    { id: 1, name: 'Fantasy', books: [] },\n    { id: 2, name: 'Adventure', books: [] }\n  ]\n};\n\n// Function to get author with books\nfunction getAuthorWithBooks(authorId) {\n  let author = database.authors.find(a => a.id === authorId);\n  if (!author) return null;\n  \n  // Find books by this author (one-to-many)\n  let books = database.books.filter(b => b.authorId === authorId);\n  \n  return {\n    ...author,\n    books: books\n  };\n}\n\n// Function to get book with categories\nfunction getBookWithCategories(bookId) {\n  let book = database.books.find(b => b.id === bookId);\n  if (!book) return null;\n  \n  // Many-to-many: find categories for this book\n  let categories = database.categories.filter(c => \n    c.books.includes(bookId)\n  );\n  \n  return {\n    ...book,\n    categories: categories\n  };\n}\n\n// Set up many-to-many relations\ndatabase.categories[0].books = [1, 2];  // Fantasy has both books\ndatabase.categories[1].books = [1];     // Adventure has HP only\n\ndatabase.books[0].categories = [1, 2];  // HP is Fantasy + Adventure\ndatabase.books[1].categories = [1];     // FB is Fantasy only\n\n// Test relations\nconsole.log('=== One-to-Many: Author → Books ===');\nlet authorWithBooks = getAuthorWithBooks(1);\nconsole.log(JSON.stringify(authorWithBooks, null, 2));\n\nconsole.log('\\n=== Many-to-Many: Book ↔ Categories ===');\nlet bookWithCategories = getBookWithCategories(1);\nconsole.log(JSON.stringify(bookWithCategories, null, 2));",
              "solution": "// Complete Prisma relations simulator\nlet database = {\n  authors: [\n    { id: 1, name: 'J.K. Rowling', bio: 'British author' },\n    { id: 2, name: 'George R.R. Martin', bio: 'American novelist' }\n  ],\n  books: [\n    { id: 1, title: 'Harry Potter and the Philosopher\\'s Stone', authorId: 1, published: true },\n    { id: 2, title: 'Harry Potter and the Chamber of Secrets', authorId: 1, published: true },\n    { id: 3, title: 'Fantastic Beasts', authorId: 1, published: true },\n    { id: 4, title: 'A Game of Thrones', authorId: 2, published: true },\n    { id: 5, title: 'A Clash of Kings', authorId: 2, published: true }\n  ],\n  categories: [\n    { id: 1, name: 'Fantasy' },\n    { id: 2, name: 'Adventure' },\n    { id: 3, name: 'Young Adult' },\n    { id: 4, name: 'Epic Fantasy' }\n  ],\n  // Many-to-many join table\n  bookCategories: [\n    { bookId: 1, categoryId: 1 },  // HP1 → Fantasy\n    { bookId: 1, categoryId: 2 },  // HP1 → Adventure\n    { bookId: 1, categoryId: 3 },  // HP1 → YA\n    { bookId: 2, categoryId: 1 },  // HP2 → Fantasy\n    { bookId: 2, categoryId: 3 },  // HP2 → YA\n    { bookId: 3, categoryId: 1 },  // FB → Fantasy\n    { bookId: 4, categoryId: 1 },  // GoT → Fantasy\n    { bookId: 4, categoryId: 4 },  // GoT → Epic Fantasy\n    { bookId: 5, categoryId: 1 },  // Clash → Fantasy\n    { bookId: 5, categoryId: 4 }   // Clash → Epic Fantasy\n  ]\n};\n\n// Prisma-style queries\n\nfunction findAuthorWithBooks(authorId) {\n  let author = database.authors.find(a => a.id === authorId);\n  if (!author) return null;\n  \n  // One-to-many: get all books by this author\n  let books = database.books.filter(b => b.authorId === authorId);\n  \n  // Include categories for each book\n  books = books.map(book => {\n    let categoryIds = database.bookCategories\n      .filter(bc => bc.bookId === book.id)\n      .map(bc => bc.categoryId);\n    \n    let categories = database.categories.filter(c => \n      categoryIds.includes(c.id)\n    );\n    \n    return { ...book, categories };\n  });\n  \n  return { ...author, books };\n}\n\nfunction findBookWithRelations(bookId) {\n  let book = database.books.find(b => b.id === bookId);\n  if (!book) return null;\n  \n  // Get author (many-to-one)\n  let author = database.authors.find(a => a.id === book.authorId);\n  \n  // Get categories (many-to-many)\n  let categoryIds = database.bookCategories\n    .filter(bc => bc.bookId === bookId)\n    .map(bc => bc.categoryId);\n  \n  let categories = database.categories.filter(c => \n    categoryIds.includes(c.id)\n  );\n  \n  return { ...book, author, categories };\n}\n\nfunction findCategoryWithBooks(categoryId) {\n  let category = database.categories.find(c => c.id === categoryId);\n  if (!category) return null;\n  \n  // Many-to-many: get all books in this category\n  let bookIds = database.bookCategories\n    .filter(bc => bc.categoryId === categoryId)\n    .map(bc => bc.bookId);\n  \n  let books = database.books.filter(b => bookIds.includes(b.id));\n  \n  // Include authors\n  books = books.map(book => {\n    let author = database.authors.find(a => a.id === book.authorId);\n    return { ...book, author };\n  });\n  \n  return { ...category, books };\n}\n\nfunction getStats() {\n  return {\n    totalAuthors: database.authors.length,\n    totalBooks: database.books.length,\n    totalCategories: database.categories.length,\n    averageBooksPerAuthor: (database.books.length / database.authors.length).toFixed(1)\n  };\n}\n\n// Test the relations\nconsole.log('=== Prisma Relations Simulator ===\\n');\n\nconsole.log('1. ONE-TO-MANY: Author with Books');\nconsole.log('Query: prisma.author.findUnique({ where: { id: 1 }, include: { books: true } })\\n');\nlet jkRowling = findAuthorWithBooks(1);\nconsole.log(JSON.stringify(jkRowling, null, 2));\n\nconsole.log('\\n2. MANY-TO-MANY: Book with Categories');\nconsole.log('Query: prisma.book.findUnique({ where: { id: 1 }, include: { categories: true } })\\n');\nlet hp1 = findBookWithRelations(1);\nconsole.log(JSON.stringify(hp1, null, 2));\n\nconsole.log('\\n3. MANY-TO-MANY REVERSE: Category with Books');\nconsole.log('Query: prisma.category.findUnique({ where: { id: 1 }, include: { books: true } })\\n');\nlet fantasy = findCategoryWithBooks(1);\nconsole.log(JSON.stringify(fantasy, null, 2));\n\nconsole.log('\\n4. Database Statistics');\nconsole.log(getStats());",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Author has multiple books",
                  "expectedOutput": "2",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Many-to-many with arrays",
                  "expectedOutput": "2",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use filter() for one-to-many, arrays for many-to-many relationships"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common relation mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common relation mistakes:"
                },
                {
                  "mistake": "**Forgetting foreign key field**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting foreign key field**:\n   ```prisma\n   // WRONG! Missing authorId\n   model Post {\n     id     Int  @id\n     author User @relation(fields: [authorId], references: [id])\n   }\n   \n   // CORRECT!\n   model Post {\n     id       Int  @id\n     authorId Int  // Foreign key field\n     author   User @relation(fields: [authorId], references: [id])\n   }\n   ```"
                },
                {
                  "mistake": "**Wrong array syntax**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong array syntax**:\n   ```prisma\n   // WRONG!\n   model User {\n     posts Post  // Missing brackets!\n   }\n   \n   // CORRECT!\n   model User {\n     posts Post[]  // Array of posts\n   }\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-12",
      "title": "Module 12: Building Modern Front-End with React 19",
      "description": "Learn React 19's latest features including JSX, components, hooks (useState, useEffect), and the new React 19 hooks. Setup: Use Vite (npm create vite@latest) - Create React App (CRA) is deprecated as of 2023",
      "difficulty": "advanced",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "12.1",
          "title": "JSX - JavaScript Meets HTML (But It's NOT HTML!)",
          "moduleId": "module-12",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine writing a recipe:\n\nPlain text recipe:\n- Hard to read\n- No structure\n- Easy to mess up\n\nFormatted recipe with sections:\n- Ingredients (like HTML tags)\n- Instructions (like JavaScript logic)\n- Combined in one document\n\nJSX is like having ingredients AND instructions in one file:\n- Looks like HTML (familiar and readable)\n- But it's actually JavaScript (gets compiled)\n- Can use JavaScript expressions inside {}\n\nJSX = JavaScript XML. It's JavaScript that LOOKS like HTML!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// JSX - The Syntax That Powers React\n\n// IMPORTANT: JSX compiles to JavaScript!\n// This JSX:\n// <h1>Hello World</h1>\n//\n// Becomes this JavaScript:\n// React.createElement('h1', null, 'Hello World')\n\nconsole.log('=== JSX Fundamentals ===\\n');\n\n// 1. JSX LOOKS LIKE HTML (but isn't!)\nlet jsxElement = '<h1>Hello, React!</h1>'; // This is just a string\nconsole.log('String:', jsxElement);\n\n// Real JSX (conceptual - won't run in plain JavaScript):\n// let jsxElement = <h1>Hello, React!</h1>;\n// This compiles to: React.createElement('h1', null, 'Hello, React!');\n\n// 2. EMBEDDING JAVASCRIPT WITH {}\nlet name = 'Alice';\nlet age = 25;\n\n// JSX allows JavaScript expressions inside curly braces\nlet greeting = `<h1>Hello, ${name}!</h1>`;  // Template literal (similar concept)\nconsole.log('\\nGreeting:', greeting);\n\n// In real JSX:\n// <h1>Hello, {name}!</h1>\n// <p>You are {age} years old</p>\n// <p>Next year: {age + 1}</p>\n\n// 3. JSX VS HTML - KEY DIFFERENCES\nconsole.log('\\n=== JSX vs HTML Differences ===\\n');\n\nlet differences = {\n  'class': {\n    html: '<div class=\"card\">',\n    jsx: '<div className=\"card\">',\n    reason: 'class is a JavaScript keyword'\n  },\n  'for': {\n    html: '<label for=\"name\">',\n    jsx: '<label htmlFor=\"name\">',\n    reason: 'for is a JavaScript keyword'\n  },\n  'style': {\n    html: '<div style=\"color: red; font-size: 16px\">',\n    jsx: '<div style={{ color: \"red\", fontSize: \"16px\" }}>',\n    reason: 'JSX style is a JavaScript object'\n  },\n  'onclick': {\n    html: '<button onclick=\"handleClick()\">',\n    jsx: '<button onClick={handleClick}>',\n    reason: 'camelCase in JSX, function reference not string'\n  },\n  'self-closing': {\n    html: '<img src=\"pic.jpg\">',\n    jsx: '<img src=\"pic.jpg\" />',\n    reason: 'JSX requires closing slash for void elements'\n  }\n};\n\nfor (let [feature, diff] of Object.entries(differences)) {\n  console.log(`${feature.toUpperCase()}:`);\n  console.log(`  HTML: ${diff.html}`);\n  console.log(`  JSX:  ${diff.jsx}`);\n  console.log(`  Why:  ${diff.reason}\\n`);\n}\n\n// 4. JAVASCRIPT EXPRESSIONS IN JSX\nconsole.log('=== JavaScript in JSX ===\\n');\n\nlet user = {\n  firstName: 'Bob',\n  lastName: 'Smith',\n  age: 30\n};\n\n// You can use ANY JavaScript expression inside {}\nlet examples = [\n  `{user.firstName}           → ${user.firstName}`,\n  `{user.firstName + ' ' + user.lastName} → ${user.firstName + ' ' + user.lastName}`,\n  `{age > 18 ? 'Adult' : 'Minor'} → ${user.age > 18 ? 'Adult' : 'Minor'}`,\n  `{[1,2,3].map(n => n * 2)}  → ${[1,2,3].map(n => n * 2).join(', ')}`\n];\n\nexamples.forEach(ex => console.log(ex));\n\n// 5. MUST RETURN SINGLE ROOT ELEMENT\nconsole.log('\\n=== JSX Rules ===\\n');\n\n// WRONG (in JSX - multiple roots):\n// return (\n//   <h1>Title</h1>\n//   <p>Text</p>\n// );\n\n// CORRECT - Wrapped in div:\n// return (\n//   <div>\n//     <h1>Title</h1>\n//     <p>Text</p>\n//   </div>\n// );\n\n// BETTER - React Fragment (no extra DOM node):\n// return (\n//   <>\n//     <h1>Title</h1>\n//     <p>Text</p>\n//   </>\n// );\n\nconsole.log('✓ JSX must have ONE root element');\nconsole.log('✓ Use <> </> (Fragment) to avoid extra divs');\nconsole.log('✓ All tags must be closed (including <img />, <br />)');\nconsole.log('✓ Use className not class');\nconsole.log('✓ Use camelCase for attributes (onClick, onChange)');\n\n// 6. WHY JSX?\nlet benefits = [\n  'Familiar HTML-like syntax',\n  'JavaScript power with {} expressions',\n  'Type checking and autocomplete',\n  'Prevents injection attacks (auto-escapes)',\n  'Easier to visualize component structure',\n  'Not required but highly recommended'\n];\n\nconsole.log('\\nWhy use JSX:');\nbenefits.forEach(b => console.log(`  ✓ ${b}`));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "JSX syntax guide:\n\n1. **JSX is JavaScript, not HTML**:\n   ```jsx\n   // This JSX:\n   const element = <h1>Hello</h1>;\n   \n   // Compiles to:\n   const element = React.createElement('h1', null, 'Hello');\n   ```\n\n2. **Embedding Expressions** with {}:\n   ```jsx\n   const name = 'Alice';\n   const element = <h1>Hello, {name}!</h1>;\n   \n   // Any JavaScript expression works:\n   <p>{2 + 2}</p>                    // 4\n   <p>{user.name.toUpperCase()}</p>  // ALICE\n   <p>{isLoggedIn ? 'Hi' : 'Please login'}</p>\n   ```\n\n3. **Attributes in JSX**:\n   ```jsx\n   // className not class\n   <div className=\"container\"></div>\n   \n   // htmlFor not for\n   <label htmlFor=\"email\">Email:</label>\n   \n   // camelCase event handlers\n   <button onClick={handleClick}>Click</button>\n   \n   // Style as object\n   <div style={{ color: 'red', fontSize: 16 }}></div>\n   ```\n\n4. **Self-Closing Tags**:\n   ```jsx\n   // Must include /\n   <img src=\"logo.png\" />\n   <br />\n   <input type=\"text\" />\n   ```\n\n5. **Children**:\n   ```jsx\n   // String children\n   <h1>Title</h1>\n   \n   // Expression children\n   <p>{user.name}</p>\n   \n   // Component children\n   <div>\n     <Header />\n     <Main />\n     <Footer />\n   </div>\n   ```\n\n6. **Fragments** (avoid extra divs):\n   ```jsx\n   // Shorthand\n   return (\n     <>\n       <h1>Title</h1>\n       <p>Text</p>\n     </>\n   );\n   \n   // Full syntax (needed for keys)\n   return (\n     <React.Fragment>\n       <h1>Title</h1>\n       <p>Text</p>\n     </React.Fragment>\n   );\n   ```\n\n7. **Comments in JSX**:\n   ```jsx\n   return (\n     <div>\n       {/* This is a comment */}\n       <h1>Title</h1>\n     </div>\n   );\n   ```"
            },
            {
              "type": "KEY_POINT",
              "title": "Setting Up a React Project (2025)",
              "content": "**Modern React Project Setup:**\\n\\n```bash\\n# Create new React project with Vite (RECOMMENDED)\\nnpm create vite@latest my-app -- --template react\\ncd my-app\\nnpm install\\nnpm run dev\\n```\\n\\n**Why Vite over Create React App?**\\n- Create React App (CRA) is **deprecated** as of 2023\\n- Vite is 10-100x faster for development\\n- Native ES modules support\\n- Recommended by React documentation\\n\\n**Alternative: Next.js** (for full-stack React):\\n```bash\\nnpx create-next-app@latest my-app\\n```\\n\\nAlways use Vite or Next.js for new React projects in 2025!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common JSX mistakes:\n\n1. **Using `class` instead of `className`**:\n   ```jsx\n   // Wrong!\n   <div class=\"container\">  // Error in JSX\n   \n   // Correct!\n   <div className=\"container\">\n   ```\n\n2. **Forgetting to close tags**:\n   ```jsx\n   // Wrong!\n   <img src=\"logo.png\">     // Error!\n   <br>                     // Error!\n   \n   // Correct!\n   <img src=\"logo.png\" />\n   <br />\n   ```\n\n3. **Quotes around JavaScript expressions**:\n   ```jsx\n   // Wrong!\n   <p>{\"userName\"}</p>       // Renders the string \"userName\"\n   <p>{age + 1}</p>         // Wrong quotes\n   \n   // Correct!\n   <p>{userName}</p>        // Uses the variable\n   <p>{age + 1}</p>         // No quotes for expressions\n   ```\n\n4. **Multiple root elements**:\n   ```jsx\n   // Wrong!\n   return (\n     <h1>Title</h1>\n     <p>Text</p>            // Error: Adjacent JSX elements\n   );\n   \n   // Correct!\n   return (\n     <>\n       <h1>Title</h1>\n       <p>Text</p>\n     </>\n   );\n   ```\n\n5. **Inline style as string**:\n   ```jsx\n   // Wrong! (HTML syntax)\n   <div style=\"color: red; font-size: 16px\">\n   \n   // Correct! (JSX object syntax)\n   <div style={{ color: 'red', fontSize: 16 }}>\n   //          ^^^^ object  ^^^^^ camelCase\n   ```\n\n6. **Event handler called immediately**:\n   ```jsx\n   // Wrong!\n   <button onClick={handleClick()}>  // Calls immediately!\n   \n   // Correct!\n   <button onClick={handleClick}>    // Passes function reference\n   <button onClick={() => handleClick()}>  // Arrow function wrapper\n   ```\n\n7. **Conditional rendering syntax**:\n   ```jsx\n   // Wrong!\n   <div>\n     if (isLoggedIn) {      // Can't use if in JSX!\n       <p>Welcome</p>\n     }\n   </div>\n   \n   // Correct!\n   <div>\n     {isLoggedIn && <p>Welcome</p>}           // && operator\n     {isLoggedIn ? <p>Hi</p> : <p>Login</p>}  // Ternary\n   </div>\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.1-challenge",
              "title": "Practice Challenge",
              "description": "Practice JSX concepts:\n\n1. Create variables for:\n   - `firstName` = your first name\n   - `lastName` = your last name\n   - `age` = your age\n\n2. Create a `getFullName()` function that returns first + last name\n\n3. Create a simulated JSX structure (as a string) that includes:\n   - An h1 with full name\n   - A p showing age\n   - A p showing if adult (age >= 18)\n\n4. Log the result\n\nNote: Since we're in plain JavaScript, use template literals to simulate JSX.",
              "instructions": "Practice JSX concepts:\n\n1. Create variables for:\n   - `firstName` = your first name\n   - `lastName` = your last name\n   - `age` = your age\n\n2. Create a `getFullName()` function that returns first + last name\n\n3. Create a simulated JSX structure (as a string) that includes:\n   - An h1 with full name\n   - A p showing age\n   - A p showing if adult (age >= 18)\n\n4. Log the result\n\nNote: Since we're in plain JavaScript, use template literals to simulate JSX.",
              "starterCode": "// Simulate JSX with template literals\n\nlet firstName = 'Alice';\nlet lastName = 'Johnson';\nlet age = 25;\n\nfunction getFullName() {\n  return firstName + ' ' + lastName;\n}\n\n// Simulate JSX structure\nlet jsxOutput = `\n<div className=\"user-card\">\n  <h1>Name: ${getFullName()}</h1>\n  <p>Age: ${age}</p>\n  <p>Status: ${age >= 18 ? 'Adult' : 'Minor'}</p>\n</div>\n`;\n\nconsole.log('Simulated JSX:');\nconsole.log(jsxOutput);",
              "solution": "// Complete JSX simulation\n\nlet firstName = 'Alice';\nlet lastName = 'Johnson';\nlet age = 25;\nlet isStudent = true;\n\nfunction getFullName() {\n  return `${firstName} ${lastName}`;\n}\n\nfunction getStatus() {\n  if (age < 18) return 'Minor';\n  if (isStudent) return 'Adult Student';\n  return 'Adult';\n}\n\n// Simulated JSX with all features\nlet jsxOutput = `\n<div className=\"user-card\">\n  <h1>Welcome, ${getFullName()}!</h1>\n  <div className=\"user-info\">\n    <p>First Name: ${firstName}</p>\n    <p>Last Name: ${lastName}</p>\n    <p>Age: ${age}</p>\n    <p>Status: ${getStatus()}</p>\n    <p>Can Vote: ${age >= 18 ? 'Yes' : 'No'}</p>\n  </div>\n  ${isStudent ? '<p className=\"badge\">Student Discount Available!</p>' : ''}\n</div>\n`;\n\nconsole.log('=== Simulated JSX Output ===');\nconsole.log(jsxOutput);\n\n// Demonstrate JavaScript expressions\nconsole.log('\\n=== Expression Examples ===');\nconsole.log('Full name:', getFullName());\nconsole.log('Next year age:', age + 1);\nconsole.log('Name length:', getFullName().length);\nconsole.log('Uppercase:', getFullName().toUpperCase());\nconsole.log('Adult?', age >= 18);\n\n// Array mapping (common in JSX)\nlet hobbies = ['Reading', 'Coding', 'Gaming'];\nlet hobbiesList = hobbies.map(hobby => `<li>${hobby}</li>`).join('\\n');\nconsole.log('\\nHobbies list:');\nconsole.log('<ul>');\nconsole.log(hobbiesList);\nconsole.log('</ul>');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should concatenate names",
                  "expectedOutput": "John Doe",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should check adult status",
                  "expectedOutput": "Adult",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use template literals with ${} to embed JavaScript expressions."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common JSX mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common JSX mistakes:"
                },
                {
                  "mistake": "**Using `class` instead of `className`**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Using `class` instead of `className`**:\n   ```jsx\n   // Wrong!\n   <div class=\"container\">  // Error in JSX\n   \n   // Correct!\n   <div className=\"container\">\n   ```"
                },
                {
                  "mistake": "**Forgetting to close tags**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting to close tags**:\n   ```jsx\n   // Wrong!\n   <img src=\"logo.png\">     // Error!\n   <br>                     // Error!\n   \n   // Correct!\n   <img src=\"logo.png\" />\n   <br />\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12.2",
          "title": "Components and Props (The LEGO Blocks Analogy)",
          "moduleId": "module-12",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of React components like LEGO blocks:\n\nBasic LEGO block:\n- Standard shape and size\n- Can connect to other blocks\n- Reusable - use the same piece many times\n- Different colors (props) make each one unique\n\nCustom LEGO creation (component):\n- Build a car from blocks\n- Want 5 cars? Use the same design 5 times\n- Each car can be different color (props)\n- Change the design once → All cars update\n\nReact components are reusable building blocks:\n- Define once, use many times\n- Pass props to customize each instance\n- Compose small components into bigger ones!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// React Components and Props\n\nconsole.log('=== React Components ===\\n');\n\n// COMPONENT = Reusable UI function\n// Props = Data passed to component (like function parameters)\n\n// 1. FUNCTION COMPONENT (modern React)\nfunction Greeting(props) {\n  return `<h1>Hello, ${props.name}!</h1>`;\n}\n\n// Use it multiple times with different props\nlet greeting1 = Greeting({ name: 'Alice' });\nlet greeting2 = Greeting({ name: 'Bob' });\nlet greeting3 = Greeting({ name: 'Charlie' });\n\nconsole.log('Same component, different props:');\nconsole.log(greeting1);  // Hello, Alice!\nconsole.log(greeting2);  // Hello, Bob!\nconsole.log(greeting3);  // Hello, Charlie!\n\n// 2. PROPS ARE READ-ONLY\nfunction UserCard(props) {\n  // props.name = 'Different'; // ERROR! Can't modify props!\n  \n  return `\n    <div className=\"user-card\">\n      <h2>${props.name}</h2>\n      <p>Email: ${props.email}</p>\n      <p>Role: ${props.role || 'User'}</p>\n    </div>\n  `;\n}\n\nlet user1 = UserCard({\n  name: 'Alice Johnson',\n  email: 'alice@example.com',\n  role: 'Admin'\n});\n\nlet user2 = UserCard({\n  name: 'Bob Smith',\n  email: 'bob@example.com'\n  // No role = uses default 'User'\n});\n\nconsole.log('\\nUser Cards:');\nconsole.log(user1);\nconsole.log(user2);\n\n// 3. DESTRUCTURING PROPS (cleaner syntax)\nfunction Button({ label, color, onClick }) {\n  // Instead of props.label, props.color, etc.\n  return `<button style=\"background: ${color}\" onClick=\"${onClick}\">${label}</button>`;\n}\n\nlet submitBtn = Button({\n  label: 'Submit',\n  color: 'blue',\n  onClick: 'handleSubmit()'\n});\n\nconsole.log('\\nButton:', submitBtn);\n\n// 4. PROPS WITH CHILDREN\nfunction Card({ title, children }) {\n  return `\n    <div className=\"card\">\n      <h3>${title}</h3>\n      <div className=\"card-body\">\n        ${children}\n      </div>\n    </div>\n  `;\n}\n\nlet card = Card({\n  title: 'My Card',\n  children: '<p>This is the card content</p><p>Multiple children!</p>'\n});\n\nconsole.log('\\nCard with children:');\nconsole.log(card);\n\n// 5. COMPONENT COMPOSITION\nfunction Header({ logo, title }) {\n  return `<header><img src=\"${logo}\" /><h1>${title}</h1></header>`;\n}\n\nfunction Footer({ year, company }) {\n  return `<footer><p>© ${year} ${company}</p></footer>`;\n}\n\nfunction App() {\n  return `\n    <div className=\"app\">\n      ${Header({ logo: 'logo.png', title: 'My App' })}\n      <main>\n        ${Card({ title: 'Welcome', children: '<p>Welcome to my app!</p>' })}\n      </main>\n      ${Footer({ year: 2025, company: 'My Company' })}\n    </div>\n  `;\n}\n\nconsole.log('\\nComplete App (composed of smaller components):');\nconsole.log(App());\n\n// 6. PROPS BEST PRACTICES\nconsole.log('\\n=== Props Best Practices ===\\n');\n\nlet practices = [\n  '✓ Props are read-only (immutable)',\n  '✓ Destructure props for cleaner code',\n  '✓ Provide default values: role || \"User\"',\n  '✓ Use clear, descriptive prop names',\n  '✓ Pass only what component needs',\n  '✓ Children prop for nested content',\n  '✓ Keep components focused and reusable'\n];\n\npractices.forEach(p => console.log(p));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Components and Props explained:\n\n1. **Function Component** (modern standard):\n   ```jsx\n   function Welcome(props) {\n     return <h1>Hello, {props.name}!</h1>;\n   }\n   \n   // Use it:\n   <Welcome name=\"Alice\" />\n   ```\n\n2. **Props Object**:\n   ```jsx\n   function UserCard(props) {\n     // props = { name: 'Alice', age: 25, email: 'alice@...' }\n     return (\n       <div>\n         <h2>{props.name}</h2>\n         <p>Age: {props.age}</p>\n         <p>Email: {props.email}</p>\n       </div>\n     );\n   }\n   ```\n\n3. **Destructuring Props** (recommended):\n   ```jsx\n   // Instead of props.name, props.age...\n   function UserCard({ name, age, email }) {\n     return (\n       <div>\n         <h2>{name}</h2>\n         <p>Age: {age}</p>\n         <p>Email: {email}</p>\n       </div>\n     );\n   }\n   ```\n\n4. **Default Props**:\n   ```jsx\n   function Button({ label, color = 'blue', size = 'medium' }) {\n     return <button style={{ backgroundColor: color }}>{label}</button>;\n   }\n   \n   // Uses defaults:\n   <Button label=\"Click\" />  // blue, medium\n   \n   // Override defaults:\n   <Button label=\"Submit\" color=\"green\" size=\"large\" />\n   ```\n\n5. **Children Prop** (special):\n   ```jsx\n   function Card({ title, children }) {\n     return (\n       <div className=\"card\">\n         <h3>{title}</h3>\n         <div className=\"card-body\">\n           {children}\n         </div>\n       </div>\n     );\n   }\n   \n   // Use with children:\n   <Card title=\"My Card\">\n     <p>This is the content</p>\n     <button>Action</button>\n   </Card>\n   ```\n\n6. **Passing Functions as Props**:\n   ```jsx\n   function Button({ label, onClick }) {\n     return <button onClick={onClick}>{label}</button>;\n   }\n   \n   // Parent passes function:\n   function App() {\n     function handleClick() {\n       console.log('Clicked!');\n     }\n     \n     return <Button label=\"Click Me\" onClick={handleClick} />;\n   }\n   ```\n\n7. **Component Composition**:\n   ```jsx\n   function App() {\n     return (\n       <div>\n         <Header />\n         <Sidebar />\n         <MainContent>\n           <Article title=\"Hello\" />\n           <Article title=\"World\" />\n         </MainContent>\n         <Footer />\n       </div>\n     );\n   }\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common component/props mistakes:\n\n1. **Modifying props (forbidden!)**:\n   ```jsx\n   function UserCard(props) {\n     props.name = 'Different';  // ERROR! Props are read-only!\n     return <h1>{props.name}</h1>;\n   }\n   ```\n   Props flow down (parent → child) and cannot be changed by child.\n\n2. **Forgetting to pass props**:\n   ```jsx\n   function Greeting({ name }) {\n     return <h1>Hello, {name}!</h1>;\n   }\n   \n   // Wrong!\n   <Greeting />  // name is undefined!\n   \n   // Correct!\n   <Greeting name=\"Alice\" />\n   ```\n\n3. **Component name not capitalized**:\n   ```jsx\n   // Wrong!\n   function greeting() {  // lowercase!\n     return <h1>Hello</h1>;\n   }\n   \n   // Correct!\n   function Greeting() {  // PascalCase!\n     return <h1>Hello</h1>;\n   }\n   ```\n   React treats lowercase as HTML tags, uppercase as components.\n\n4. **Not destructuring (verbose)**:\n   ```jsx\n   // Works but verbose:\n   function UserCard(props) {\n     return <div>{props.name} - {props.email} - {props.age}</div>;\n   }\n   \n   // Better (destructured):\n   function UserCard({ name, email, age }) {\n     return <div>{name} - {email} - {age}</div>;\n   }\n   ```\n\n5. **Missing key in lists**:\n   ```jsx\n   // Wrong!\n   {users.map(user => <UserCard {...user} />)}\n   \n   // Correct!\n   {users.map(user => <UserCard key={user.id} {...user} />)}\n   ```\n   React needs keys to track which items changed.\n\n6. **Passing strings incorrectly**:\n   ```jsx\n   // Wrong!\n   <UserCard age=\"25\" />     // age is string \"25\", not number!\n   \n   // Correct!\n   <UserCard age={25} />     // age is number 25\n   \n   // Strings don't need braces:\n   <UserCard name=\"Alice\" /> // OK\n   <UserCard name={'Alice'} /> // Also OK but unnecessary\n   ```\n\n7. **Inline object props (causes re-renders)**:\n   ```jsx\n   // Avoid (creates new object every render):\n   <UserCard style={{ color: 'red' }} />\n   \n   // Better (define outside):\n   const cardStyle = { color: 'red' };\n   <UserCard style={cardStyle} />\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.2-challenge",
              "title": "Practice Challenge",
              "description": "Create reusable components with props:\n\n1. Create a `BlogPost` function that takes props:\n   - title\n   - author\n   - content\n   - Returns formatted HTML string\n\n2. Create an `AuthorBio` function that takes:\n   - name\n   - bio\n   - Returns formatted HTML string\n\n3. Create a `Blog` function that:\n   - Uses BlogPost twice with different data\n   - Uses AuthorBio once\n   - Returns complete blog page\n\nTest by calling Blog() and logging result.",
              "instructions": "Create reusable components with props:\n\n1. Create a `BlogPost` function that takes props:\n   - title\n   - author\n   - content\n   - Returns formatted HTML string\n\n2. Create an `AuthorBio` function that takes:\n   - name\n   - bio\n   - Returns formatted HTML string\n\n3. Create a `Blog` function that:\n   - Uses BlogPost twice with different data\n   - Uses AuthorBio once\n   - Returns complete blog page\n\nTest by calling Blog() and logging result.",
              "starterCode": "// Component functions\n\nfunction BlogPost({ title, author, content }) {\n  return `\n    <article className=\"blog-post\">\n      <h2>${title}</h2>\n      <p className=\"author\">By ${author}</p>\n      <p>${content}</p>\n    </article>\n  `;\n}\n\nfunction AuthorBio({ name, bio }) {\n  return `\n    <div className=\"author-bio\">\n      <h3>About ${name}</h3>\n      <p>${bio}</p>\n    </div>\n  `;\n}\n\nfunction Blog() {\n  return `\n    <div className=\"blog\">\n      <h1>My Blog</h1>\n      ${BlogPost({\n        title: 'Learning React',\n        author: 'Alice',\n        content: 'React is amazing for building UIs!'\n      })}\n      ${BlogPost({\n        title: 'Understanding Props',\n        author: 'Alice',\n        content: 'Props make components reusable.'\n      })}\n      ${AuthorBio({\n        name: 'Alice',\n        bio: 'Web developer and React enthusiast.'\n      })}\n    </div>\n  `;\n}\n\nconsole.log(Blog());",
              "solution": "// Complete component system with props\n\nfunction BlogPost({ title, author, content, date = 'Today' }) {\n  return `\n    <article className=\"blog-post\">\n      <h2>${title}</h2>\n      <div className=\"meta\">\n        <span className=\"author\">By ${author}</span>\n        <span className=\"date\">${date}</span>\n      </div>\n      <p className=\"content\">${content}</p>\n    </article>\n  `;\n}\n\nfunction AuthorBio({ name, bio, avatar = 'default-avatar.png' }) {\n  return `\n    <div className=\"author-bio\">\n      <img src=\"${avatar}\" alt=\"${name}\" className=\"avatar\" />\n      <h3>About ${name}</h3>\n      <p>${bio}</p>\n    </div>\n  `;\n}\n\nfunction CommentSection({ comments = [] }) {\n  if (comments.length === 0) {\n    return '<p>No comments yet.</p>';\n  }\n  \n  return `\n    <div className=\"comments\">\n      <h3>${comments.length} Comment${comments.length !== 1 ? 's' : ''}</h3>\n      ${comments.map(c => `\n        <div className=\"comment\">\n          <strong>${c.author}:</strong> ${c.text}\n        </div>\n      `).join('')}\n    </div>\n  `;\n}\n\nfunction Blog() {\n  let posts = [\n    {\n      title: 'Getting Started with React',\n      author: 'Alice Johnson',\n      content: 'React makes building user interfaces simple and enjoyable!',\n      date: 'Jan 15, 2025'\n    },\n    {\n      title: 'Understanding Props and Components',\n      author: 'Alice Johnson',\n      content: 'Props are the way we pass data between components.',\n      date: 'Jan 16, 2025'\n    }\n  ];\n  \n  let comments = [\n    { author: 'Bob', text: 'Great article!' },\n    { author: 'Charlie', text: 'Very helpful, thanks!' }\n  ];\n  \n  return `\n    <div className=\"blog\">\n      <header>\n        <h1>My React Blog</h1>\n      </header>\n      \n      <main>\n        ${posts.map(post => BlogPost(post)).join('\\n')}\n      </main>\n      \n      <aside>\n        ${AuthorBio({\n          name: 'Alice Johnson',\n          bio: 'Full-stack developer passionate about React and modern web development.',\n          avatar: 'alice-avatar.jpg'\n        })}\n      </aside>\n      \n      ${CommentSection({ comments })}\n    </div>\n  `;\n}\n\nconsole.log('=== Complete Blog Application ===\\n');\nconsole.log(Blog());\n\n// Demonstrate component reusability\nconsole.log('\\n=== Reusability Demo ===\\n');\nconsole.log('Creating 3 blog posts with same component:');\n\nfor (let i = 1; i <= 3; i++) {\n  console.log(BlogPost({\n    title: `Post ${i}`,\n    author: 'Demo Author',\n    content: `Content for post number ${i}`\n  }));\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should use props in template",
                  "expectedOutput": "<h2>Test</h2><p>By Bob</p>",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use destructuring in function parameters and template literals for HTML."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common component/props mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common component/props mistakes:"
                },
                {
                  "mistake": "**Modifying props (forbidden!)**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Modifying props (forbidden!)**:\n   ```jsx\n   function UserCard(props) {\n     props.name = 'Different';  // ERROR! Props are read-only!\n     return <h1>{props.name}</h1>;\n   }\n   ```\n   Props flow down (parent → child) and cannot be changed by child."
                },
                {
                  "mistake": "**Forgetting to pass props**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting to pass props**:\n   ```jsx\n   function Greeting({ name }) {\n     return <h1>Hello, {name}!</h1>;\n   }\n   \n   // Wrong!\n   <Greeting />  // name is undefined!\n   \n   // Correct!\n   <Greeting name=\"Alice\" />\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12.3",
          "title": "useState Hook - Giving Components Memory (The Light Switch Analogy)",
          "moduleId": "module-12",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of a light switch in your house:\n\nWithout state (broken switch):\n- You flip the switch up\n- Light turns on for a moment\n- Switch immediately resets to off\n- Light goes back off\n- Can't remember if it was on or off!\n\nWith state (working switch):\n- You flip switch up → light turns ON\n- Switch REMEMBERS it's on\n- Stays on until you flip it down\n- Switch REMEMBERS it's off\n- State = Current position of the switch\n\nReact useState is like giving your component a working switch:\n- Component can remember values between renders\n- When state changes → component re-renders\n- UI updates automatically to show new state\n- Perfect for: counters, form inputs, toggles, user data!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// useState Hook - Component Memory\n\nconsole.log('=== React useState Hook ===\\n');\n\n// WHY WE NEED STATE\nconsole.log('--- Without State (Doesn\\'t Work!) ---\\n');\n\nfunction simulateComponentWithoutState() {\n  let count = 0;  // Regular variable\n  \n  console.log('[Component] Initial render: count =', count);\n  \n  // User clicks button\n  console.log('[User] Clicks +1 button');\n  count = count + 1;\n  console.log('[Component] count =', count, '(but component doesn\\'t re-render!)');\n  \n  // Component renders again (for some reason)\n  count = 0;  // RESETS! Regular variables don't persist\n  console.log('[Component] Re-render: count =', count, '(LOST the value!)');\n}\n\nsimulateComponentWithoutState();\n\n// WITH STATE (Works!)\nconsole.log('\\n--- With useState (Works!) ---\\n');\n\nfunction simulateComponentWithState() {\n  // useState hook - PERSISTS between renders\n  let state = {\n    count: 0,\n    setCount: function(newValue) {\n      this.count = newValue;\n      console.log('[State Update] count changed to:', newValue);\n      console.log('[React] Re-rendering component...');\n    }\n  };\n  \n  console.log('[Component] Initial render: count =', state.count);\n  \n  // User clicks button\n  console.log('\\n[User] Clicks +1 button');\n  state.setCount(state.count + 1);\n  console.log('[Component] Re-render: count =', state.count, '(PERSISTED!)');\n  \n  // User clicks again\n  console.log('\\n[User] Clicks +1 button again');\n  state.setCount(state.count + 1);\n  console.log('[Component] Re-render: count =', state.count);\n}\n\nsimulateComponentWithState();\n\n// REAL useState SYNTAX\nconsole.log('\\n\\n=== useState Syntax ===\\n');\n\nconsole.log('// Import from React');\nconsole.log('import { useState } from \"react\";\\n');\n\nconsole.log('function Counter() {');\nconsole.log('  // useState returns [currentValue, setterFunction]');\nconsole.log('  const [count, setCount] = useState(0);');\nconsole.log('  //      ^^^^^  ^^^^^^^^          ^^^');\nconsole.log('  //      value  updater          initial value\\n');\n\nconsole.log('  function increment() {');\nconsole.log('    setCount(count + 1);  // Update state');\nconsole.log('  }\\n');\n\nconsole.log('  return (');\nconsole.log('    <div>');\nconsole.log('      <p>Count: {count}</p>');\nconsole.log('      <button onClick={increment}>+1</button>');\nconsole.log('    </div>');\nconsole.log('  );');\nconsole.log('}\\n');\n\n// MULTIPLE STATE VARIABLES\nconsole.log('=== Multiple State Variables ===\\n');\n\nconsole.log('function UserProfile() {');\nconsole.log('  const [name, setName] = useState(\"Alice\");');\nconsole.log('  const [age, setAge] = useState(25);');\nconsole.log('  const [isLoggedIn, setIsLoggedIn] = useState(false);\\n');\n\nconsole.log('  // Each state is independent!');\nconsole.log('  setName(\"Bob\");        // Only updates name');\nconsole.log('  setAge(30);           // Only updates age');\nconsole.log('  setIsLoggedIn(true);  // Only updates isLoggedIn');\nconsole.log('}\\n');\n\n// STATE WITH OBJECTS\nconsole.log('=== State with Objects ===\\n');\n\nlet userState = {\n  user: { name: 'Alice', age: 25, email: 'alice@example.com' },\n  setUser: function(newUser) {\n    // MUST create new object (don't mutate!)\n    this.user = { ...this.user, ...newUser };\n    console.log('[State] Updated user:', this.user);\n  }\n};\n\nconsole.log('Initial user:', userState.user);\n\nconsole.log('\\nUpdating age:');\nuserState.setUser({ age: 26 });  // Spread syntax preserves other fields\n\nconsole.log('\\n// WRONG way (mutation):');\nconsole.log('user.age = 26;        // ✗ Don\\'t mutate directly!');\nconsole.log('setUser(user);       // ✗ React won\\'t detect change!\\n');\n\nconsole.log('// CORRECT way (new object):');\nconsole.log('setUser({ ...user, age: 26 });  // ✓ Creates new object');\n\n// STATE WITH ARRAYS\nconsole.log('\\n\\n=== State with Arrays ===\\n');\n\nlet todosState = {\n  todos: ['Learn React', 'Build app'],\n  setTodos: function(newTodos) {\n    this.todos = newTodos;\n    console.log('[State] Updated todos:', this.todos);\n  }\n};\n\nconsole.log('Initial todos:', todosState.todos);\n\nconsole.log('\\nAdding todo:');\ntodosState.setTodos([...todosState.todos, 'Deploy app']);\n\nconsole.log('\\nRemoving first todo:');\ntodosState.setTodos(todosState.todos.slice(1));\n\nconsole.log('\\n--- Array State Patterns ---');\nconsole.log('Add item:    setTodos([...todos, newItem])');\nconsole.log('Remove item: setTodos(todos.filter(t => t.id !== id))');\nconsole.log('Update item: setTodos(todos.map(t => t.id === id ? updated : t))');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "useState Hook explained:\n\n1. **Basic useState**:\n   ```jsx\n   import { useState } from 'react';\n   \n   function Counter() {\n     const [count, setCount] = useState(0);\n     //      ^^^^^  ^^^^^^^^          ^^^\n     //      state  setter           initial value\n     \n     return (\n       <div>\n         <p>{count}</p>\n         <button onClick={() => setCount(count + 1)}>+1</button>\n       </div>\n     );\n   }\n   ```\n\n2. **Array Destructuring** (what [count, setCount] means):\n   ```jsx\n   // useState returns an array: [value, setter]\n   const stateArray = useState(0);  // [0, function]\n   const count = stateArray[0];     // Get value\n   const setCount = stateArray[1];  // Get setter\n   \n   // Shorthand (array destructuring):\n   const [count, setCount] = useState(0);  // Same thing!\n   ```\n\n3. **Initial Value**:\n   ```jsx\n   const [count, setCount] = useState(0);      // Number\n   const [name, setName] = useState('Alice');  // String\n   const [isOpen, setIsOpen] = useState(false); // Boolean\n   const [items, setItems] = useState([]);     // Array\n   const [user, setUser] = useState({ name: 'Alice' }); // Object\n   ```\n\n4. **Updating State**:\n   ```jsx\n   // Simple value\n   setCount(5);           // Set to 5\n   setCount(count + 1);   // Increment\n   \n   // Using previous value (safer)\n   setCount(prevCount => prevCount + 1);\n   ```\n\n5. **Multiple State Variables**:\n   ```jsx\n   function Form() {\n     const [name, setName] = useState('');\n     const [email, setEmail] = useState('');\n     const [age, setAge] = useState(0);\n     \n     // Each is independent\n   }\n   ```\n\n6. **State with Objects** (must spread!):\n   ```jsx\n   const [user, setUser] = useState({ name: 'Alice', age: 25 });\n   \n   // WRONG!\n   user.age = 26;         // Don't mutate!\n   setUser(user);         // React won't detect change\n   \n   // CORRECT!\n   setUser({ ...user, age: 26 });  // Create new object\n   ```\n\n7. **State with Arrays**:\n   ```jsx\n   const [items, setItems] = useState([1, 2, 3]);\n   \n   // Add item\n   setItems([...items, 4]);\n   setItems([newItem, ...items]);  // Add to beginning\n   \n   // Remove item\n   setItems(items.filter((item, index) => index !== 0));\n   \n   // Update item\n   setItems(items.map((item, i) => i === 1 ? newValue : item));\n   ```\n\n8. **Lazy Initial State** (expensive calculation):\n   ```jsx\n   // WRONG! (runs every render)\n   const [data, setData] = useState(expensiveCalculation());\n   \n   // CORRECT! (runs once)\n   const [data, setData] = useState(() => expensiveCalculation());\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common useState mistakes:\n\n1. **Mutating state directly**:\n   ```jsx\n   // WRONG!\n   const [user, setUser] = useState({ name: 'Alice' });\n   user.name = 'Bob';     // Don't mutate!\n   setUser(user);         // React won't re-render\n   \n   // CORRECT!\n   setUser({ ...user, name: 'Bob' });  // New object\n   ```\n\n2. **Forgetting to use setter**:\n   ```jsx\n   const [count, setCount] = useState(0);\n   \n   // WRONG!\n   count = count + 1;     // Won't work!\n   \n   // CORRECT!\n   setCount(count + 1);   // Use setter\n   ```\n\n3. **Using state immediately after setting**:\n   ```jsx\n   const [count, setCount] = useState(0);\n   \n   function increment() {\n     setCount(count + 1);\n     console.log(count);    // Still 0! (state updates are async)\n   }\n   \n   // Use useEffect or callback to see new value:\n   setCount(prevCount => {\n     console.log('Will be:', prevCount + 1);\n     return prevCount + 1;\n   });\n   ```\n\n4. **Multiple setStates based on current state**:\n   ```jsx\n   // WRONG! (race condition)\n   setCount(count + 1);\n   setCount(count + 1);\n   setCount(count + 1);\n   // Count only increases by 1!\n   \n   // CORRECT!\n   setCount(c => c + 1);\n   setCount(c => c + 1);\n   setCount(c => c + 1);\n   // Count increases by 3!\n   ```\n\n5. **Mutating arrays**:\n   ```jsx\n   const [items, setItems] = useState([1, 2, 3]);\n   \n   // WRONG!\n   items.push(4);         // Mutates!\n   setItems(items);       // Won't re-render\n   \n   // CORRECT!\n   setItems([...items, 4]);  // New array\n   \n   // Other array operations:\n   setItems(items.filter(i => i !== 2));    // Remove\n   setItems(items.map(i => i === 2 ? 5 : i)); // Update\n   ```\n\n6. **Forgetting initial value**:\n   ```jsx\n   // WRONG!\n   const [count, setCount] = useState();  // undefined!\n   \n   // CORRECT!\n   const [count, setCount] = useState(0);  // Start at 0\n   ```\n\n7. **Using if/loops in component body with useState**:\n   ```jsx\n   // WRONG! (hooks must be at top level)\n   function MyComponent({ condition }) {\n     if (condition) {\n       const [state, setState] = useState(0);  // Error!\n     }\n   }\n   \n   // CORRECT!\n   function MyComponent({ condition }) {\n     const [state, setState] = useState(0);  // Always call\n     \n     if (condition) {\n       // Use state here\n     }\n   }\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.3-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a counter component with state:\n\n1. Create a `Counter` object with:\n   - state: { count: 0 }\n   - setCount(newValue) method that updates count and logs it\n   - increment() method that calls setCount with count + 1\n   - decrement() method that calls setCount with count - 1\n   - reset() method that calls setCount with 0\n\n2. Test all methods and log the count after each operation",
              "instructions": "Simulate a counter component with state:\n\n1. Create a `Counter` object with:\n   - state: { count: 0 }\n   - setCount(newValue) method that updates count and logs it\n   - increment() method that calls setCount with count + 1\n   - decrement() method that calls setCount with count - 1\n   - reset() method that calls setCount with 0\n\n2. Test all methods and log the count after each operation",
              "starterCode": "// Counter with state\n\nlet Counter = {\n  state: { count: 0 },\n  \n  setCount(newValue) {\n    this.state.count = newValue;\n    console.log('[State] count =', this.state.count);\n  },\n  \n  increment() {\n    this.setCount(this.state.count + 1);\n  },\n  \n  decrement() {\n    this.setCount(this.state.count - 1);\n  },\n  \n  reset() {\n    this.setCount(0);\n  },\n  \n  getCount() {\n    return this.state.count;\n  }\n};\n\n// Test\nconsole.log('Initial count:', Counter.getCount());\n\nCounter.increment();\nCounter.increment();\nCounter.increment();\nCounter.decrement();\nCounter.reset();\n\nconsole.log('Final count:', Counter.getCount());",
              "solution": "// Complete state management simulation\n\nlet Counter = {\n  state: { count: 0 },\n  listeners: [],\n  \n  setCount(newValue) {\n    let oldValue = this.state.count;\n    this.state.count = newValue;\n    console.log(`[State Update] count: ${oldValue} → ${newValue}`);\n    console.log('[React] Re-rendering component...');\n    this.notifyListeners();\n  },\n  \n  increment() {\n    console.log('[Action] Increment');\n    this.setCount(this.state.count + 1);\n  },\n  \n  decrement() {\n    console.log('[Action] Decrement');\n    this.setCount(this.state.count - 1);\n  },\n  \n  incrementBy(amount) {\n    console.log(`[Action] Increment by ${amount}`);\n    this.setCount(this.state.count + amount);\n  },\n  \n  reset() {\n    console.log('[Action] Reset');\n    this.setCount(0);\n  },\n  \n  getCount() {\n    return this.state.count;\n  },\n  \n  // Subscribe to changes\n  onChange(callback) {\n    this.listeners.push(callback);\n  },\n  \n  notifyListeners() {\n    this.listeners.forEach(fn => fn(this.state.count));\n  },\n  \n  render() {\n    console.log('\\n[Render] Counter UI:');\n    console.log(`┌─────────────────┐`);\n    console.log(`│  Count: ${String(this.state.count).padEnd(6)} │`);\n    console.log(`├─────────────────┤`);\n    console.log(`│  [ - ] [ + ]    │`);\n    console.log(`│  [ Reset ]      │`);\n    console.log(`└─────────────────┘\\n`);\n  }\n};\n\n// Advanced: TodoList with state\nlet TodoList = {\n  state: {\n    todos: [],\n    nextId: 1\n  },\n  \n  setTodos(newTodos) {\n    this.state.todos = newTodos;\n    console.log('[State] todos updated:', newTodos.length, 'items');\n  },\n  \n  addTodo(text) {\n    console.log(`[Action] Add todo: \"${text}\"`);\n    let newTodo = {\n      id: this.state.nextId++,\n      text: text,\n      completed: false\n    };\n    // Must create NEW array (don't mutate!)\n    this.setTodos([...this.state.todos, newTodo]);\n  },\n  \n  toggleTodo(id) {\n    console.log(`[Action] Toggle todo ${id}`);\n    this.setTodos(\n      this.state.todos.map(todo =>\n        todo.id === id\n          ? { ...todo, completed: !todo.completed }  // New object\n          : todo\n      )\n    );\n  },\n  \n  deleteTodo(id) {\n    console.log(`[Action] Delete todo ${id}`);\n    this.setTodos(\n      this.state.todos.filter(todo => todo.id !== id)\n    );\n  },\n  \n  render() {\n    console.log('\\n[Render] Todo List:');\n    if (this.state.todos.length === 0) {\n      console.log('  No todos yet!');\n    } else {\n      this.state.todos.forEach(todo => {\n        let checkbox = todo.completed ? '[✓]' : '[ ]';\n        let text = todo.completed ? `(${todo.text})` : todo.text;\n        console.log(`  ${checkbox} ${text}`);\n      });\n    }\n    console.log('');\n  }\n};\n\n// Run simulations\nconsole.log('=== Counter Simulation ===\\n');\n\nCounter.render();\n\nconsole.log('User clicks +1 three times:');\nCounter.increment();\nCounter.increment();\nCounter.increment();\nCounter.render();\n\nconsole.log('User clicks -1:');\nCounter.decrement();\nCounter.render();\n\nconsole.log('User clicks reset:');\nCounter.reset();\nCounter.render();\n\nconsole.log('\\n=== TodoList Simulation ===\\n');\n\nTodoList.render();\n\nTodoList.addTodo('Learn useState');\nTodoList.addTodo('Build a counter app');\nTodoList.addTodo('Master React');\nTodoList.render();\n\nconsole.log('User completes first todo:');\nTodoList.toggleTodo(1);\nTodoList.render();\n\nconsole.log('User deletes second todo:');\nTodoList.deleteTodo(2);\nTodoList.render();\n\nconsole.log('=== Key Takeaways ===\\n');\nlet takeaways = [\n  '✓ useState gives components memory',\n  '✓ State updates trigger re-renders',\n  '✓ Never mutate state directly',\n  '✓ Always create new objects/arrays',\n  '✓ Use setCount(prev => prev + 1) for updates based on previous',\n  '✓ Can have multiple state variables',\n  '✓ Each state is independent'\n];\ntakeaways.forEach(t => console.log(t));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should increment count",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should decrement count",
                  "expectedOutput": "4",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use this.state.count to access current count, and this.setCount() to update it"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common useState mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common useState mistakes:"
                },
                {
                  "mistake": "**Mutating state directly**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Mutating state directly**:\n   ```jsx\n   // WRONG!\n   const [user, setUser] = useState({ name: 'Alice' });\n   user.name = 'Bob';     // Don't mutate!\n   setUser(user);         // React won't re-render\n   \n   // CORRECT!\n   setUser({ ...user, name: 'Bob' });  // New object\n   ```"
                },
                {
                  "mistake": "**Forgetting to use setter**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting to use setter**:\n   ```jsx\n   const [count, setCount] = useState(0);\n   \n   // WRONG!\n   count = count + 1;     // Won't work!\n   \n   // CORRECT!\n   setCount(count + 1);   // Use setter\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12.4",
          "title": "Event Handling - Responding to User Actions (The Doorbell Analogy)",
          "moduleId": "module-12",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine your house has a doorbell:\n\nPassive House (no doorbell):\n- Visitors knock\n- You don't hear them\n- Nothing happens\n- Frustrating for visitors!\n\nActive House (with doorbell):\n- Doorbell LISTENS for button press\n- Visitor presses button\n- Doorbell RESPONDS by ringing\n- You REACT by answering the door\n\nReact events work the same way:\n- Components LISTEN for events (onClick, onChange, etc.)\n- User performs action (click, type, submit)\n- Event handler RESPONDS\n- Component state updates → UI re-renders\n\nWithout event listeners → Your UI can't respond to users!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// React Event Handling\n\nconsole.log('=== Event Handling in React ===\\n');\n\n// CONCEPT: Event Listeners\nlet button = {\n  label: 'Click Me',\n  clickCount: 0,\n  \n  // Event handler function\n  handleClick: function() {\n    this.clickCount++;\n    console.log(`[Event] Button clicked! Total clicks: ${this.clickCount}`);\n  }\n};\n\n// Simulate user clicking button\nconsole.log('Button label:', button.label);\nconsole.log('\\nUser clicks button 3 times:\\n');\nbutton.handleClick();\nbutton.handleClick();\nbutton.handleClick();\n\n// COMMON EVENT TYPES\nconsole.log('\\n=== Common React Events ===\\n');\n\nlet events = {\n  'onClick': 'Button clicks, div clicks, any element click',\n  'onChange': 'Input field changes (text input, checkbox, select)',\n  'onSubmit': 'Form submission',\n  'onMouseEnter': 'Mouse cursor enters element',\n  'onMouseLeave': 'Mouse cursor leaves element',\n  'onKeyDown': 'Key pressed down',\n  'onKeyUp': 'Key released',\n  'onFocus': 'Element receives focus (clicked or tabbed to)',\n  'onBlur': 'Element loses focus'\n};\n\nfor (let [event, description] of Object.entries(events)) {\n  console.log(`${event.padEnd(15)} - ${description}`);\n}\n\n// REACT SYNTAX\nconsole.log('\\n\\n=== Event Handler Syntax ===\\n');\n\nconsole.log('// Method 1: Inline arrow function');\nconsole.log('<button onClick={() => console.log(\"Clicked!\")}>Click</button>\\n');\n\nconsole.log('// Method 2: Named function reference');\nconsole.log('function handleClick() {');\nconsole.log('  console.log(\"Clicked!\");');\nconsole.log('}');\nconsole.log('<button onClick={handleClick}>Click</button>\\n');\n\nconsole.log('// Method 3: With event object');\nconsole.log('function handleClick(event) {');\nconsole.log('  console.log(\"Button:\", event.target);');\nconsole.log('}');\nconsole.log('<button onClick={handleClick}>Click</button>\\n');\n\n// EVENT OBJECT\nconsole.log('=== The Event Object ===\\n');\n\nlet simulatedEvent = {\n  target: { tagName: 'BUTTON', textContent: 'Click Me', value: '' },\n  type: 'click',\n  preventDefault: function() {\n    console.log('[Event] Default action prevented');\n  },\n  stopPropagation: function() {\n    console.log('[Event] Event propagation stopped');\n  }\n};\n\nfunction handleEvent(event) {\n  console.log('Event type:', event.type);\n  console.log('Target element:', event.target.tagName);\n  console.log('Button text:', event.target.textContent);\n}\n\nconsole.log('Simulating click event:\\n');\nhandleEvent(simulatedEvent);\n\n// FORM HANDLING\nconsole.log('\\n\\n=== Form Event Handling ===\\n');\n\nlet form = {\n  state: { name: '', email: '' },\n  \n  handleNameChange: function(event) {\n    this.state.name = event.target.value;\n    console.log('[Input] Name:', this.state.name);\n  },\n  \n  handleEmailChange: function(event) {\n    this.state.email = event.target.value;\n    console.log('[Input] Email:', this.state.email);\n  },\n  \n  handleSubmit: function(event) {\n    event.preventDefault();\n    console.log('[Submit] Form data:', this.state);\n  }\n};\n\nconsole.log('User types in name field:');\nform.handleNameChange({ target: { value: 'Alice' } });\nform.handleNameChange({ target: { value: 'Alice J' } });\nform.handleNameChange({ target: { value: 'Alice Johnson' } });\n\nconsole.log('\\nUser types in email field:');\nform.handleEmailChange({ target: { value: 'alice@example.com' } });\n\nconsole.log('\\nUser submits form:');\nform.handleSubmit({ preventDefault: () => console.log('[Browser] Default submit prevented') });\n\n// REAL REACT EXAMPLE\nconsole.log('\\n\\n=== Complete React Example ===\\n');\n\nconsole.log('import { useState } from \"react\";\\n');\n\nconsole.log('function LoginForm() {');\nconsole.log('  const [email, setEmail] = useState(\"\");');\nconsole.log('  const [password, setPassword] = useState(\"\");\\n');\n\nconsole.log('  function handleSubmit(event) {');\nconsole.log('    event.preventDefault();  // Don\\'t reload page');\nconsole.log('    console.log(\"Login:\", email, password);');\nconsole.log('  }\\n');\n\nconsole.log('  return (');\nconsole.log('    <form onSubmit={handleSubmit}>');\nconsole.log('      <input');\nconsole.log('        type=\"email\"');\nconsole.log('        value={email}');\nconsole.log('        onChange={(e) => setEmail(e.target.value)}');\nconsole.log('      />');\nconsole.log('      <input');\nconsole.log('        type=\"password\"');\nconsole.log('        value={password}');\nconsole.log('        onChange={(e) => setPassword(e.target.value)}');\nconsole.log('      />');\nconsole.log('      <button type=\"submit\">Login</button>');\nconsole.log('    </form>');\nconsole.log('  );');\nconsole.log('}');\n\n// EVENT PATTERNS\nconsole.log('\\n\\n=== Common Event Patterns ===\\n');\n\nlet patterns = [\n  {    pattern: 'Button Click',\n    code: '<button onClick={handleClick}>Click</button>'\n  },\n  {\n    pattern: 'Input Change',\n    code: '<input onChange={(e) => setValue(e.target.value)} />'\n  },\n  {\n    pattern: 'Form Submit',\n    code: '<form onSubmit={handleSubmit}>...</form>'\n  },\n  {\n    pattern: 'Checkbox Toggle',\n    code: '<input type=\"checkbox\" onChange={(e) => setChecked(e.target.checked)} />'\n  },\n  {\n    pattern: 'Keyboard Event',\n    code: '<input onKeyDown={(e) => e.key === \"Enter\" && submit()} />'\n  },\n  {\n    pattern: 'Mouse Hover',\n    code: '<div onMouseEnter={handleEnter} onMouseLeave={handleLeave}>'\n  }\n];\n\npatterns.forEach(p => {\n  console.log(`${p.pattern}:`);\n  console.log(`  ${p.code}\\n`);\n});"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Event handling explained:\n\n1. **Basic onClick**:\n   ```jsx\n   function MyButton() {\n     function handleClick() {\n       console.log('Clicked!');\n     }\n     \n     return <button onClick={handleClick}>Click Me</button>;\n     //                      ^^^^^^^^^^^^\n     //                      Function REFERENCE (no parentheses!)\n   }\n   ```\n\n2. **Inline Arrow Function**:\n   ```jsx\n   <button onClick={() => console.log('Clicked!')}>Click</button>\n   \n   // With state update:\n   <button onClick={() => setCount(count + 1)}>+1</button>\n   ```\n\n3. **Event Object** (e or event):\n   ```jsx\n   function handleClick(event) {\n     console.log('Clicked element:', event.target);\n     console.log('Click position:', event.clientX, event.clientY);\n   }\n   \n   <button onClick={handleClick}>Click</button>\n   ```\n\n4. **Form Events** (onChange, onSubmit):\n   ```jsx\n   function Form() {\n     const [name, setName] = useState('');\n     \n     function handleSubmit(e) {\n       e.preventDefault();  // DON'T reload page!\n       console.log('Submitted:', name);\n     }\n     \n     return (\n       <form onSubmit={handleSubmit}>\n         <input\n           value={name}\n           onChange={(e) => setName(e.target.value)}\n           //                        ^^^^^^^^^^^^^\n           //                        Get input value\n         />\n         <button type=\"submit\">Submit</button>\n       </form>\n     );\n   }\n   ```\n\n5. **Passing Arguments** to event handlers:\n   ```jsx\n   // WRONG!\n   <button onClick={handleClick(id)}>  // Calls immediately!\n   \n   // CORRECT!\n   <button onClick={() => handleClick(id)}>  // Calls when clicked\n   <button onClick={handleClick.bind(null, id)}>  // Alternative\n   ```\n\n6. **Multiple Events**:\n   ```jsx\n   <div\n     onClick={handleClick}\n     onMouseEnter={handleEnter}\n     onMouseLeave={handleLeave}\n   >\n     Hover and click me!\n   </div>\n   ```\n\n7. **Controlled Inputs** (input value tied to state):\n   ```jsx\n   const [text, setText] = useState('');\n   \n   <input\n     value={text}              // Controlled by state\n     onChange={(e) => setText(e.target.value)}\n   />\n   ```\n\n8. **Checkbox Events**:\n   ```jsx\n   const [checked, setChecked] = useState(false);\n   \n   <input\n     type=\"checkbox\"\n     checked={checked}\n     onChange={(e) => setChecked(e.target.checked)}\n     //                            ^^^^^^^^^^^^^\n     //                            For checkboxes!\n   />\n   ```\n\n9. **Keyboard Events**:\n   ```jsx\n   function handleKeyDown(e) {\n     if (e.key === 'Enter') {\n       submit();\n     }\n     if (e.key === 'Escape') {\n       cancel();\n     }\n   }\n   \n   <input onKeyDown={handleKeyDown} />\n   ```\n\n10. **Prevent Default & Stop Propagation**:\n   ```jsx\n   function handleSubmit(e) {\n     e.preventDefault();     // Don't submit form\n     e.stopPropagation();    // Don't bubble up to parent\n     // Your code here\n   }\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common event handling mistakes:\n\n1. **Calling function immediately instead of passing reference**:\n   ```jsx\n   // WRONG! (calls immediately on render)\n   <button onClick={handleClick()}>Click</button>\n   \n   // CORRECT! (passes function reference)\n   <button onClick={handleClick}>Click</button>\n   \n   // Or use arrow function:\n   <button onClick={() => handleClick()}>Click</button>\n   ```\n\n2. **Forgetting e.preventDefault() on forms**:\n   ```jsx\n   function handleSubmit(e) {\n     // WRONG! (page reloads)\n     console.log('Submitted');\n     \n     // CORRECT!\n     e.preventDefault();  // Stop page reload\n     console.log('Submitted');\n   }\n   ```\n\n3. **Wrong event property for inputs**:\n   ```jsx\n   // Text input\n   <input onChange={(e) => setValue(e.target.value)} />\n   //                                   ^^^^^ value for text\n   \n   // Checkbox\n   <input type=\"checkbox\" onChange={(e) => setChecked(e.target.checked)} />\n   //                                                   ^^^^^^^ checked for checkbox\n   ```\n\n4. **Not binding 'this' in class components**:\n   ```jsx\n   // Old class component issue (not relevant for function components)\n   class MyComponent extends React.Component {\n     handleClick() {\n       this.setState(...);  // 'this' is undefined!\n     }\n     \n     // Fix 1: Bind in constructor\n     constructor() {\n       this.handleClick = this.handleClick.bind(this);\n     }\n     \n     // Fix 2: Arrow function\n     handleClick = () => {\n       this.setState(...);\n     }\n   }\n   ```\n\n5. **Trying to pass arguments incorrectly**:\n   ```jsx\n   // WRONG!\n   <button onClick={handleClick(id)}>  // Calls immediately!\n   \n   // CORRECT!\n   <button onClick={() => handleClick(id)}>Delete</button>\n   \n   // Or:\n   <button onClick={handleClick.bind(null, id)}>Delete</button>\n   ```\n\n6. **Uncontrolled vs controlled inputs confusion**:\n   ```jsx\n   // Uncontrolled (React doesn't control value)\n   <input defaultValue=\"Initial\" />\n   \n   // Controlled (React controls value via state)\n   const [text, setText] = useState('Initial');\n   <input\n     value={text}                          // Must have value\n     onChange={(e) => setText(e.target.value)}  // Must have onChange\n   />\n   ```\n\n7. **Multiple handlers without arrow functions**:\n   ```jsx\n   // WRONG! (both call immediately)\n   <div\n     onMouseEnter={handleEnter()}\n     onMouseLeave={handleLeave()}\n   >\n   \n   // CORRECT!\n   <div\n     onMouseEnter={handleEnter}\n     onMouseLeave={handleLeave}\n   >\n   \n   // Or with arguments:\n   <div\n     onMouseEnter={() => handleEnter(id)}\n     onMouseLeave={() => handleLeave(id)}\n   >\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.4-challenge",
              "title": "Practice Challenge",
              "description": "Create an interactive counter with event handling:\n\n1. Create a `CounterApp` object with:\n   - state: { count: 0, history: [] }\n   - handleIncrement() - increases count, adds to history\n   - handleDecrement() - decreases count, adds to history\n   - handleReset() - resets count to 0, clears history\n   - render() - displays current count and history\n\n2. Simulate user interactions and show the results",
              "instructions": "Create an interactive counter with event handling:\n\n1. Create a `CounterApp` object with:\n   - state: { count: 0, history: [] }\n   - handleIncrement() - increases count, adds to history\n   - handleDecrement() - decreases count, adds to history\n   - handleReset() - resets count to 0, clears history\n   - render() - displays current count and history\n\n2. Simulate user interactions and show the results",
              "starterCode": "// Interactive Counter App\n\nlet CounterApp = {\n  state: {\n    count: 0,\n    history: []\n  },\n  \n  handleIncrement() {\n    this.state.count++;\n    this.state.history.push('+1');\n    console.log('[Event] Increment → count:', this.state.count);\n  },\n  \n  handleDecrement() {\n    this.state.count--;\n    this.state.history.push('-1');\n    console.log('[Event] Decrement → count:', this.state.count);\n  },\n  \n  handleReset() {\n    this.state.count = 0;\n    this.state.history = [];\n    console.log('[Event] Reset → count:', this.state.count);\n  },\n  \n  render() {\n    console.log('\\n[Render]');\n    console.log('  Current Count:', this.state.count);\n    console.log('  History:', this.state.history.join(', ') || 'none');\n    console.log('');\n  }\n};\n\n// Simulate user interactions\nconsole.log('=== Counter App ===\\n');\n\nCounterApp.render();\n\nconsole.log('User clicks +1 button:');\nCounterApp.handleIncrement();\nCounterApp.render();\n\nconsole.log('User clicks +1 button again:');\nCounterApp.handleIncrement();\nCounterApp.render();\n\nconsole.log('User clicks -1 button:');\nCounterApp.handleDecrement();\nCounterApp.render();\n\nconsole.log('User clicks reset button:');\nCounterApp.handleReset();\nCounterApp.render();",
              "solution": "// Complete interactive app with event handling\n\nlet CounterApp = {\n  state: {\n    count: 0,\n    history: [],\n    lastAction: null\n  },\n  \n  handleIncrement() {\n    console.log('[Event] onClick={handleIncrement}');\n    this.state.count++;\n    this.state.history.push({ action: '+1', timestamp: Date.now() });\n    this.state.lastAction = 'increment';\n    this.render();\n  },\n  \n  handleDecrement() {\n    console.log('[Event] onClick={handleDecrement}');\n    this.state.count--;\n    this.state.history.push({ action: '-1', timestamp: Date.now() });\n    this.state.lastAction = 'decrement';\n    this.render();\n  },\n  \n  handleReset() {\n    console.log('[Event] onClick={handleReset}');\n    this.state.count = 0;\n    this.state.history = [];\n    this.state.lastAction = 'reset';\n    this.render();\n  },\n  \n  handleIncrementBy(amount) {\n    console.log(`[Event] onClick={() => handleIncrementBy(${amount})}`);\n    this.state.count += amount;\n    this.state.history.push({ action: `+${amount}`, timestamp: Date.now() });\n    this.render();\n  },\n  \n  render() {\n    console.log('\\n[React] Re-rendering component...');\n    console.log('┌────────────────────────────┐');\n    console.log(`│ Count: ${String(this.state.count).padEnd(19)} │`);\n    console.log('├────────────────────────────┤');\n    console.log('│ [ -1 ]  [ +1 ]  [ +5 ]     │');\n    console.log('│         [Reset]            │');\n    console.log('├────────────────────────────┤');\n    console.log(`│ Actions: ${String(this.state.history.length).padEnd(17)} │`);\n    if (this.state.history.length > 0) {\n      let recent = this.state.history.slice(-3).map(h => h.action).join(', ');\n      console.log(`│ Recent: ${recent.padEnd(18)} │`);\n    }\n    console.log('└────────────────────────────┘\\n');\n  }\n};\n\n// Form with event handling\nlet LoginForm = {\n  state: {\n    email: '',\n    password: '',\n    submitted: false,\n    errors: []\n  },\n  \n  handleEmailChange(event) {\n    console.log(`[Event] onChange={handleEmailChange}`);\n    this.state.email = event.target.value;\n    console.log(`  Email: \"${this.state.email}\"`);\n  },\n  \n  handlePasswordChange(event) {\n    console.log(`[Event] onChange={handlePasswordChange}`);\n    this.state.password = event.target.value;\n    console.log(`  Password: \"${'*'.repeat(this.state.password.length)}\"`);\n  },\n  \n  handleSubmit(event) {\n    console.log(`[Event] onSubmit={handleSubmit}`);\n    event.preventDefault();\n    \n    // Validation\n    this.state.errors = [];\n    if (!this.state.email.includes('@')) {\n      this.state.errors.push('Invalid email');\n    }\n    if (this.state.password.length < 6) {\n      this.state.errors.push('Password too short');\n    }\n    \n    if (this.state.errors.length === 0) {\n      this.state.submitted = true;\n      console.log('  ✓ Form valid! Logging in...');\n    } else {\n      console.log('  ✗ Form errors:', this.state.errors.join(', '));\n    }\n  },\n  \n  render() {\n    console.log('\\n[Render] Login Form');\n    console.log('  Email:', this.state.email || '(empty)');\n    console.log('  Password:', '*'.repeat(this.state.password.length) || '(empty)');\n    if (this.state.errors.length > 0) {\n      console.log('  Errors:', this.state.errors.join(', '));\n    }\n    if (this.state.submitted) {\n      console.log('  Status: ✓ Logged in!');\n    }\n    console.log('');\n  }\n};\n\n// Run simulations\nconsole.log('=== Counter App Simulation ===\\n');\n\nCounterApp.render();\n\nconsole.log('User clicks +1:');\nCounterApp.handleIncrement();\n\nconsole.log('User clicks +1 again:');\nCounterApp.handleIncrement();\n\nconsole.log('User clicks +5:');\nCounterApp.handleIncrementBy(5);\n\nconsole.log('User clicks -1:');\nCounterApp.handleDecrement();\n\nconsole.log('User clicks reset:');\nCounterApp.handleReset();\n\nconsole.log('\\n=== Login Form Simulation ===\\n');\n\nLoginForm.render();\n\nconsole.log('User types email:');\nLoginForm.handleEmailChange({ target: { value: 'a' } });\nLoginForm.handleEmailChange({ target: { value: 'al' } });\nLoginForm.handleEmailChange({ target: { value: 'alice@example.com' } });\nLoginForm.render();\n\nconsole.log('User types password:');\nLoginForm.handlePasswordChange({ target: { value: 'pass' } });\nLoginForm.render();\n\nconsole.log('User clicks submit (invalid):');\nLoginForm.handleSubmit({ preventDefault: () => {} });\nLoginForm.render();\n\nconsole.log('User fixes password:');\nLoginForm.handlePasswordChange({ target: { value: 'password123' } });\nLoginForm.render();\n\nconsole.log('User clicks submit (valid):');\nLoginForm.handleSubmit({ preventDefault: () => {} });\nLoginForm.render();\n\nconsole.log('=== Key Takeaways ===\\n');\nlet takeaways = [\n  '✓ Event handlers respond to user actions',\n  '✓ Use onClick, onChange, onSubmit, etc.',\n  '✓ Pass function reference, not call: onClick={handleClick}',\n  '✓ Access event with parameter: (e) => ...',\n  '✓ Use e.preventDefault() to prevent default behavior',\n  '✓ Controlled inputs: value={state} onChange={setState}',\n  '✓ Event updates state → state update triggers re-render'\n];\ntakeaways.forEach(t => console.log(t));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should handle increment",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should track history",
                  "expectedOutput": "1",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Update state in event handlers, then call render() to show changes"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common event handling mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common event handling mistakes:"
                },
                {
                  "mistake": "**Calling function immediately instead of passing reference**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Calling function immediately instead of passing reference**:\n   ```jsx\n   // WRONG! (calls immediately on render)\n   <button onClick={handleClick()}>Click</button>\n   \n   // CORRECT! (passes function reference)\n   <button onClick={handleClick}>Click</button>\n   \n   // Or use arrow function:\n   <button onClick={() => handleClick()}>Click</button>\n   ```"
                },
                {
                  "mistake": "**Forgetting e.preventDefault() on forms**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting e.preventDefault() on forms**:\n   ```jsx\n   function handleSubmit(e) {\n     // WRONG! (page reloads)\n     console.log('Submitted');\n     \n     // CORRECT!\n     e.preventDefault();  // Stop page reload\n     console.log('Submitted');\n   }\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12.5",
          "title": "Conditional Rendering - Showing Different UI Based on State (The Traffic Light Analogy)",
          "moduleId": "module-12",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of a traffic light at an intersection:\n\nStatic Display (no conditions):\n- Always shows green light\n- Never changes\n- Dangerous! Cars and pedestrians confused\n\nConditional Display (based on state):\n- If state = 'stop' → Show RED light\n- If state = 'caution' → Show YELLOW light\n- If state = 'go' → Show GREEN light\n- Changes based on current condition\n\nReact conditional rendering works the same:\n- Different UI based on state/props\n- Show login button if NOT logged in\n- Show profile if logged in\n- Show loading spinner while fetching\n- Show error message if failed\n\nOne component, many possible displays!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Conditional Rendering in React\n\nconsole.log('=== Conditional Rendering ===\\n');\n\n// METHOD 1: if/else (outside JSX)\nfunction renderGreeting(isLoggedIn) {\n  if (isLoggedIn) {\n    return '<h1>Welcome back!</h1>';\n  } else {\n    return '<h1>Please log in.</h1>';\n  }\n}\n\nconsole.log('User logged in:');\nconsole.log(renderGreeting(true));\nconsole.log('\\nUser NOT logged in:');\nconsole.log(renderGreeting(false));\n\n// METHOD 2: Ternary operator (? :)\nfunction renderStatus(isOnline) {\n  return `<p>Status: ${isOnline ? 'Online' : 'Offline'}</p>`;\n}\n\nconsole.log('\\nTernary operator:');\nconsole.log(renderStatus(true));\nconsole.log(renderStatus(false));\n\n// METHOD 3: Logical AND (&&)\nfunction renderNotifications(hasNotifications, count) {\n  return `\n    <div>\n      <h2>Dashboard</h2>\n      ${hasNotifications && `<p>You have ${count} new notifications!</p>` || ''}\n    </div>\n  `;\n}\n\nconsole.log('\\nLogical AND (&&):');\nconsole.log(renderNotifications(true, 5));\nconsole.log(renderNotifications(false, 0));\n\n// REAL-WORLD EXAMPLE: Login/Logout Button\nlet app = {\n  state: { isLoggedIn: false, username: null },\n  \n  render() {\n    console.log('\\n[Render] App UI:\\n');\n    \n    if (this.state.isLoggedIn) {\n      console.log(`Welcome, ${this.state.username}!`);\n      console.log('[Logout Button]');\n    } else {\n      console.log('Welcome, Guest!');\n      console.log('[Login Button]');\n    }\n  },\n  \n  login(username) {\n    this.state.isLoggedIn = true;\n    this.state.username = username;\n    this.render();\n  },\n  \n  logout() {\n    this.state.isLoggedIn = false;\n    this.state.username = null;\n    this.render();\n  }\n};\n\nconsole.log('\\n=== Login/Logout Example ===');\napp.render();\n\nconsole.log('\\nUser clicks login:');\napp.login('Alice');\n\nconsole.log('\\nUser clicks logout:');\napp.logout();\n\n// LOADING STATES\nlet dataFetcher = {\n  state: { loading: true, data: null, error: null },\n  \n  render() {\n    console.log('\\n[Render] Data View:\\n');\n    \n    if (this.state.loading) {\n      console.log('⏳ Loading...');\n    } else if (this.state.error) {\n      console.log(`❌ Error: ${this.state.error}`);\n    } else if (this.state.data) {\n      console.log('✓ Data:', this.state.data);\n    } else {\n      console.log('No data yet.');\n    }\n  },\n  \n  async simulateFetch(shouldFail = false) {\n    this.state.loading = true;\n    this.state.error = null;\n    this.state.data = null;\n    this.render();\n    \n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    if (shouldFail) {\n      this.state.loading = false;\n      this.state.error = 'Network error';\n    } else {\n      this.state.loading = false;\n      this.state.data = { users: ['Alice', 'Bob', 'Charlie'] };\n    }\n    this.render();\n  }\n};\n\nconsole.log('\\n=== Loading State Example ===');\nsetTimeout(async () => {\n  dataFetcher.render();\n  \n  console.log('\\nFetching data (success):');\n  await dataFetcher.simulateFetch(false);\n  \n  console.log('\\nFetching data (failure):');\n  await dataFetcher.simulateFetch(true);\n}, 100);\n\n// CONDITIONAL CSS CLASSES\nsetTimeout(() => {\n  console.log('\\n\\n=== Conditional Styling ===\\n');\n  \n  function renderButton(isActive) {\n    let className = isActive ? 'btn-active' : 'btn-inactive';\n    let text = isActive ? 'Active' : 'Inactive';\n    return `<button class=\"${className}\">${text}</button>`;\n  }\n  \n  console.log('Active button:');\n  console.log(renderButton(true));\n  console.log('\\nInactive button:');\n  console.log(renderButton(false));\n  \n  // Multiple conditions\n  function renderAlert(type, message) {\n    let className = type === 'success' ? 'alert-success' :\n                    type === 'error' ? 'alert-error' :\n                    type === 'warning' ? 'alert-warning' :\n                    'alert-info';\n    \n    let icon = type === 'success' ? '✓' :\n               type === 'error' ? '✗' :\n               type === 'warning' ? '⚠' :\n               'ℹ';\n    \n    return `<div class=\"${className}\">${icon} ${message}</div>`;\n  }\n  \n  console.log('\\nConditional alerts:');\n  console.log(renderAlert('success', 'Saved successfully!'));\n  console.log(renderAlert('error', 'Failed to save!'));\n  console.log(renderAlert('warning', 'Are you sure?'));\n  console.log(renderAlert('info', 'New update available'));\n}, 1200);\n\n// LIST RENDERING WITH CONDITIONS\nsetTimeout(() => {\n  console.log('\\n\\n=== Conditional List Rendering ===\\n');\n  \n  let todos = [\n    { id: 1, text: 'Learn React', completed: true },\n    { id: 2, text: 'Build app', completed: false },\n    { id: 3, text: 'Deploy', completed: false }\n  ];\n  \n  console.log('All todos:');\n  todos.forEach(todo => {\n    let checkbox = todo.completed ? '[✓]' : '[ ]';\n    let style = todo.completed ? '(completed)' : '';\n    console.log(`${checkbox} ${todo.text} ${style}`);\n  });\n  \n  console.log('\\nCompleted only:');\n  todos.filter(todo => todo.completed).forEach(todo => {\n    console.log(`[✓] ${todo.text}`);\n  });\n  \n  console.log('\\nIncomplete only:');\n  todos.filter(todo => !todo.completed).forEach(todo => {\n    console.log(`[ ] ${todo.text}`);\n  });\n}, 1300);\n\n// REACT SYNTAX PATTERNS\nsetTimeout(() => {\n  console.log('\\n\\n=== React Conditional Rendering Patterns ===\\n');\n  \n  console.log('// Pattern 1: Ternary operator');\n  console.log('{isLoggedIn ? <Dashboard /> : <Login />}\\n');\n  \n  console.log('// Pattern 2: Logical AND (show/hide)');\n  console.log('{hasError && <ErrorMessage />}');\n  console.log('{count > 0 && <p>You have {count} items</p>}\\n');\n  \n  console.log('// Pattern 3: If/else (before return)');\n  console.log('if (loading) return <Spinner />;');\n  console.log('if (error) return <Error message={error} />;');\n  console.log('return <Data data={data} />;\\n');\n  \n  console.log('// Pattern 4: Switch for multiple conditions');\n  console.log('switch(status) {');\n  console.log('  case \"loading\": return <Spinner />;');\n  console.log('  case \"error\": return <Error />;');\n  console.log('  case \"success\": return <Data />;');\n  console.log('  default: return null;');\n  console.log('}\\n');\n  \n  console.log('// Pattern 5: Null for hiding');\n  console.log('{!shouldShow && null}  // Renders nothing');\n  console.log('{shouldShow ? <Component /> : null}');\n}, 1400);"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Conditional rendering patterns:\n\n1. **Ternary Operator** (? :):\n   ```jsx\n   function Greeting({ isLoggedIn }) {\n     return (\n       <div>\n         {isLoggedIn ? (\n           <h1>Welcome back!</h1>\n         ) : (\n           <h1>Please log in</h1>\n         )}\n       </div>\n     );\n   }\n   ```\n\n2. **Logical AND** (&&):\n   ```jsx\n   function Notifications({ count }) {\n     return (\n       <div>\n         <h2>Dashboard</h2>\n         {count > 0 && <p>You have {count} notifications</p>}\n       </div>\n     );\n   }\n   // Shows paragraph ONLY if count > 0\n   ```\n\n3. **Early Return**:\n   ```jsx\n   function UserProfile({ user }) {\n     if (!user) {\n       return <p>Loading...</p>;\n     }\n     \n     if (user.error) {\n       return <p>Error: {user.error}</p>;\n     }\n     \n     return (\n       <div>\n         <h1>{user.name}</h1>\n         <p>{user.email}</p>\n       </div>\n     );\n   }\n   ```\n\n4. **Variable Assignment**:\n   ```jsx\n   function Dashboard({ isLoggedIn }) {\n     let content;\n     \n     if (isLoggedIn) {\n       content = <UserDashboard />;\n     } else {\n       content = <LoginPrompt />;\n     }\n     \n     return <div>{content}</div>;\n   }\n   ```\n\n5. **Null for Hiding**:\n   ```jsx\n   function Alert({ message, show }) {\n     if (!show) return null;  // Render nothing\n     \n     return <div className=\"alert\">{message}</div>;\n   }\n   ```\n\n6. **Conditional CSS Classes**:\n   ```jsx\n   function Button({ isActive }) {\n     return (\n       <button className={isActive ? 'btn-active' : 'btn-inactive'}>\n         {isActive ? 'Active' : 'Inactive'}\n       </button>\n     );\n   }\n   ```\n\n7. **Multiple Conditions (Switch)**:\n   ```jsx\n   function StatusDisplay({ status }) {\n     switch(status) {\n       case 'loading':\n         return <Spinner />;\n       case 'error':\n         return <ErrorMessage />;\n       case 'success':\n         return <SuccessMessage />;\n       default:\n         return null;\n     }\n   }\n   ```\n\n8. **Conditional Props**:\n   ```jsx\n   <button\n     className={isActive ? 'active' : 'inactive'}\n     disabled={isLoading}\n     style={{ color: hasError ? 'red' : 'black' }}\n   >\n     {isLoading ? 'Loading...' : 'Submit'}\n   </button>\n   ```\n\n9. **List Filtering**:\n   ```jsx\n   function TodoList({ todos, filter }) {\n     const filteredTodos = filter === 'completed'\n       ? todos.filter(t => t.completed)\n       : filter === 'active'\n       ? todos.filter(t => !t.completed)\n       : todos;\n     \n     return (\n       <ul>\n         {filteredTodos.map(todo => <li key={todo.id}>{todo.text}</li>)}\n       </ul>\n     );\n   }\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common conditional rendering mistakes:\n\n1. **Using if statement inside JSX**:\n   ```jsx\n   // WRONG! Can't use if in JSX\n   return (\n     <div>\n       {if (isLoggedIn) { <p>Welcome</p> }}  // Syntax error!\n     </div>\n   );\n   \n   // CORRECT! Use ternary\n   return (\n     <div>\n       {isLoggedIn ? <p>Welcome</p> : <p>Login</p>}\n     </div>\n   );\n   \n   // Or if/else before return:\n   if (isLoggedIn) {\n     return <div><p>Welcome</p></div>;\n   }\n   return <div><p>Login</p></div>;\n   ```\n\n2. **Wrong use of && operator**:\n   ```jsx\n   // WRONG! Renders \"0\" when count is 0\n   {count && <p>You have {count} items</p>}\n   \n   // CORRECT! Use explicit boolean\n   {count > 0 && <p>You have {count} items</p>}\n   ```\n\n3. **Forgetting the else in ternary**:\n   ```jsx\n   // WRONG!\n   {isLoggedIn ? <Dashboard /> }  // Syntax error!\n   \n   // CORRECT!\n   {isLoggedIn ? <Dashboard /> : null}\n   {isLoggedIn ? <Dashboard /> : <Login />}\n   \n   // Or use &&:\n   {isLoggedIn && <Dashboard />}\n   ```\n\n4. **Nested ternaries (hard to read)**:\n   ```jsx\n   // WRONG! (too complex)\n   {isLoading ? <Spinner /> : hasError ? <Error /> : hasData ? <Data /> : <Empty />}\n   \n   // BETTER! Use if/else before return\n   if (isLoading) return <Spinner />;\n   if (hasError) return <Error />;\n   if (hasData) return <Data />;\n   return <Empty />;\n   ```\n\n5. **Rendering undefined or false**:\n   ```jsx\n   // WRONG! Renders \"false\" or \"undefined\" as text\n   <div>{isLoggedIn}</div>  // Renders \"true\" or \"false\"\n   <div>{userData}</div>    // Might render \"undefined\"\n   \n   // CORRECT!\n   <div>{isLoggedIn ? 'Yes' : 'No'}</div>\n   <div>{userData?.name || 'N/A'}</div>\n   ```\n\n6. **String conditions** (always truthy!):\n   ```jsx\n   // WRONG! String \"false\" is truthy!\n   const showBanner = \"false\";  // String, not boolean\n   {showBanner && <Banner />}   // Always shows!\n   \n   // CORRECT!\n   const showBanner = false;    // Boolean\n   {showBanner && <Banner />}   // Works correctly\n   ```\n\n7. **Not handling all states** (loading, error, data):\n   ```jsx\n   // WRONG! Missing loading and error states\n   function UserProfile({ user }) {\n     return <div>{user.name}</div>;  // Crashes if user is null!\n   }\n   \n   // CORRECT!\n   function UserProfile({ user, loading, error }) {\n     if (loading) return <Spinner />;\n     if (error) return <Error message={error} />;\n     if (!user) return <p>No user found</p>;\n     return <div>{user.name}</div>;\n   }\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.5-challenge",
              "title": "Practice Challenge",
              "description": "Create a user authentication UI with conditional rendering:\n\n1. Create an `AuthApp` object with:\n   - state: { isLoggedIn: false, user: null, loading: false }\n   - login(username) method\n   - logout() method\n   - render() method that shows different UI based on state\n\n2. Show:\n   - Loading message when loading = true\n   - Login button when not logged in\n   - Welcome message + Logout button when logged in\n\n3. Test all states",
              "instructions": "Create a user authentication UI with conditional rendering:\n\n1. Create an `AuthApp` object with:\n   - state: { isLoggedIn: false, user: null, loading: false }\n   - login(username) method\n   - logout() method\n   - render() method that shows different UI based on state\n\n2. Show:\n   - Loading message when loading = true\n   - Login button when not logged in\n   - Welcome message + Logout button when logged in\n\n3. Test all states",
              "starterCode": "// Authentication App with Conditional Rendering\n\nlet AuthApp = {\n  state: {\n    isLoggedIn: false,\n    user: null,\n    loading: false\n  },\n  \n  render() {\n    console.log('\\n[Render] Auth UI:');\n    console.log('─'.repeat(40));\n    \n    if (this.state.loading) {\n      console.log('⏳ Loading...');\n    } else if (this.state.isLoggedIn) {\n      console.log(`Welcome, ${this.state.user}!`);\n      console.log('[Logout Button]');\n    } else {\n      console.log('Please log in to continue');\n      console.log('[Login Button]');\n    }\n    \n    console.log('─'.repeat(40) + '\\n');\n  },\n  \n  async login(username) {\n    console.log(`[Action] Login as ${username}`);\n    this.state.loading = true;\n    this.render();\n    \n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    this.state.loading = false;\n    this.state.isLoggedIn = true;\n    this.state.user = username;\n    this.render();\n  },\n  \n  logout() {\n    console.log('[Action] Logout');\n    this.state.isLoggedIn = false;\n    this.state.user = null;\n    this.render();\n  }\n};\n\n// Test all states\nasync function testAuthApp() {\n  console.log('=== Auth App Test ===');\n  \n  AuthApp.render();\n  \n  await AuthApp.login('Alice');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  AuthApp.logout();\n}\n\ntestAuthApp();",
              "solution": "// Complete solution with all conditional rendering patterns\n\nlet AuthApp = {\n  state: {\n    isLoggedIn: false,\n    user: null,\n    loading: false,\n    error: null\n  },\n  \n  render() {\n    console.log('\\n┌────────────────────────────────────────┐');\n    console.log('│          Authentication App            │');\n    console.log('├────────────────────────────────────────┤');\n    \n    // Loading state\n    if (this.state.loading) {\n      console.log('│  ⏳ Loading...                         │');\n      console.log('└────────────────────────────────────────┘\\n');\n      return;\n    }\n    \n    // Error state\n    if (this.state.error) {\n      console.log(`│  ❌ Error: ${this.state.error.padEnd(25)} │`);\n      console.log('│  [Try Again]                           │');\n      console.log('└────────────────────────────────────────┘\\n');\n      return;\n    }\n    \n    // Logged in state\n    if (this.state.isLoggedIn) {\n      console.log(`│  Welcome, ${this.state.user}! ${' '.repeat(26 - this.state.user.length)} │`);\n      console.log('│  ─────────────────────────────────────│');\n      console.log('│  Dashboard                             │');\n      console.log('│  Profile                               │');\n      console.log('│  Settings                              │');\n      console.log('│  ─────────────────────────────────────│');\n      console.log('│  [Logout]                              │');\n    } else {\n      // Logged out state\n      console.log('│  Please log in to continue            │');\n      console.log('│  ─────────────────────────────────────│');\n      console.log('│  [Login]                               │');\n      console.log('│  [Sign Up]                             │');\n    }\n    \n    console.log('└────────────────────────────────────────┘\\n');\n  },\n  \n  async login(username, password) {\n    console.log(`[Action] Login as \"${username}\"`);\n    this.state.loading = true;\n    this.state.error = null;\n    this.render();\n    \n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 800));\n    \n    // Simulate authentication\n    if (password === 'wrong') {\n      this.state.loading = false;\n      this.state.error = 'Invalid credentials';\n      this.render();\n      return;\n    }\n    \n    this.state.loading = false;\n    this.state.isLoggedIn = true;\n    this.state.user = username;\n    this.render();\n  },\n  \n  logout() {\n    console.log('[Action] Logout');\n    this.state.isLoggedIn = false;\n    this.state.user = null;\n    this.state.error = null;\n    this.render();\n  }\n};\n\n// Todo List with conditional rendering\nlet TodoApp = {\n  state: {\n    todos: [\n      { id: 1, text: 'Learn conditional rendering', completed: true },\n      { id: 2, text: 'Build a todo app', completed: false },\n      { id: 3, text: 'Master React', completed: false }\n    ],\n    filter: 'all'  // 'all', 'active', 'completed'\n  },\n  \n  render() {\n    console.log('\\n┌────────────────────────────────────────┐');\n    console.log('│             Todo List                  │');\n    console.log('├────────────────────────────────────────┤');\n    \n    // Filter todos based on current filter\n    let filteredTodos;\n    if (this.state.filter === 'completed') {\n      filteredTodos = this.state.todos.filter(t => t.completed);\n    } else if (this.state.filter === 'active') {\n      filteredTodos = this.state.todos.filter(t => !t.completed);\n    } else {\n      filteredTodos = this.state.todos;\n    }\n    \n    // Empty state\n    if (filteredTodos.length === 0) {\n      console.log('│  No todos to show                      │');\n    } else {\n      filteredTodos.forEach(todo => {\n        let checkbox = todo.completed ? '[✓]' : '[ ]';\n        let text = todo.completed ? `${todo.text} (done)` : todo.text;\n        let line = `│  ${checkbox} ${text}`.padEnd(41) + '│';\n        console.log(line);\n      });\n    }\n    \n    console.log('├────────────────────────────────────────┤');\n    \n    // Filter buttons with active state\n    let allActive = this.state.filter === 'all' ? '*' : ' ';\n    let activeActive = this.state.filter === 'active' ? '*' : ' ';\n    let completedActive = this.state.filter === 'completed' ? '*' : ' ';\n    \n    console.log(`│  [${allActive}]All [${activeActive}]Active [${completedActive}]Completed      │`);\n    console.log('└────────────────────────────────────────┘\\n');\n  },\n  \n  setFilter(filter) {\n    console.log(`[Action] Set filter: ${filter}`);\n    this.state.filter = filter;\n    this.render();\n  }\n};\n\n// Run demonstrations\nasync function runDemo() {\n  console.log('=== Authentication Demo ===\\n');\n  \n  AuthApp.render();\n  \n  console.log('User attempts login with wrong password:');\n  await AuthApp.login('Alice', 'wrong');\n  \n  await new Promise(resolve => setTimeout(resolve, 1000));\n  \n  console.log('User attempts login with correct password:');\n  await AuthApp.login('Alice', 'correct');\n  \n  await new Promise(resolve => setTimeout(resolve, 1000));\n  \n  console.log('User logs out:');\n  AuthApp.logout();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  console.log('\\n=== Todo List Demo ===\\n');\n  \n  TodoApp.render();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  console.log('Show only active todos:');\n  TodoApp.setFilter('active');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  console.log('Show only completed todos:');\n  TodoApp.setFilter('completed');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  console.log('Show all todos:');\n  TodoApp.setFilter('all');\n}\n\nrunDemo();",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should show different UI when logged in",
                  "expectedOutput": "Welcome",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should show login when logged out",
                  "expectedOutput": "Login",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use if/else in render() to show different UI based on state"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common conditional rendering mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common conditional rendering mistakes:"
                },
                {
                  "mistake": "**Using if statement inside JSX**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Using if statement inside JSX**:\n   ```jsx\n   // WRONG! Can't use if in JSX\n   return (\n     <div>\n       {if (isLoggedIn) { <p>Welcome</p> }}  // Syntax error!\n     </div>\n   );\n   \n   // CORRECT! Use ternary\n   return (\n     <div>\n       {isLoggedIn ? <p>Welcome</p> : <p>Login</p>}\n     </div>\n   );\n   \n   // Or if/else before return:\n   if (isLoggedIn) {\n     return <div><p>Welcome</p></div>;\n   }\n   return <div><p>Login</p></div>;\n   ```"
                },
                {
                  "mistake": "**Wrong use of && operator**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong use of && operator**:\n   ```jsx\n   // WRONG! Renders \"0\" when count is 0\n   {count && <p>You have {count} items</p>}\n   \n   // CORRECT! Use explicit boolean\n   {count > 0 && <p>You have {count} items</p>}\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12.6",
          "title": "useEffect Hook - Side Effects & Component Lifecycle (The Security Guard Analogy)",
          "moduleId": "module-12",
          "order": 6,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a security guard at a building entrance:\n\nWithout security guard:\n- People come and go\n- No one tracks entrances/exits\n- No one locks doors at night\n- No cleanup when building closes\n\nWith security guard (useEffect):\n- WHEN people arrive (component mounts) → Check them in\n- WHEN visitor badge expires (dependency changes) → Issue new badge\n- WHEN building closes (component unmounts) → Lock doors, cleanup\n- Guard watches specific things (dependencies)\n- Guard performs actions automatically\n\nReact useEffect is your component's security guard:\n- Runs code AFTER render (side effects)\n- Runs when component mounts\n- Runs when specific values change\n- Cleanup when component unmounts\n- Perfect for: API calls, timers, subscriptions, document title changes!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// useEffect Hook - Side Effects\n\nconsole.log('=== useEffect Hook ===\\n');\n\n// SIDE EFFECT = Code that affects something outside the component\n// Examples: API calls, timers, DOM manipulation, subscriptions\n\n// Simulating component lifecycle\nclass Component {\n  constructor(name) {\n    this.name = name;\n    this.effects = [];\n    this.mounted = false;\n  }\n  \n  useEffect(effect, dependencies) {\n    this.effects.push({ effect, dependencies });\n  }\n  \n  mount() {\n    console.log(`[${this.name}] Mounting...`);\n    this.mounted = true;\n    \n    // Run all effects\n    this.effects.forEach(({ effect, dependencies }) => {\n      console.log(`[${this.name}] Running effect (dependencies: ${dependencies || 'none'})`);\n      let cleanup = effect();\n      if (cleanup) {\n        console.log(`[${this.name}] Effect registered cleanup function`);\n      }\n    });\n  }\n  \n  unmount() {\n    console.log(`\\n[${this.name}] Unmounting...`);\n    console.log(`[${this.name}] Running cleanup functions`);\n    this.mounted = false;\n  }\n}\n\n// Example 1: Effect runs once on mount\nlet TitleComponent = new Component('TitleComponent');\n\nTitleComponent.useEffect(() => {\n  console.log('  Setting document title to: \"My React App\"');\n  // In real React: document.title = 'My React App';\n}, []); // Empty array = run once on mount\n\nTitleComponent.mount();\n\n// Example 2: Effect with cleanup\nconsole.log('\\n--- Timer Component ---');\nlet TimerComponent = new Component('TimerComponent');\n\nTimerComponent.useEffect(() => {\n  console.log('  Starting timer (setInterval)');\n  let intervalId = 123;\n  \n  // Cleanup function (returned)\n  return () => {\n    console.log('  Stopping timer (clearInterval)');\n  };\n}, []);\n\nTimerComponent.mount();\nsetTimeout(() => TimerComponent.unmount(), 1000);\n\n// Example 3: Effect runs when dependency changes\nsetTimeout(() => {\n  console.log('\\n--- User Profile Component ---');\n  \n  let ProfileComponent = new Component('ProfileComponent');\n  let userId = 1;\n  \n  ProfileComponent.useEffect(() => {\n    console.log(`  Fetching data for user ${userId}...`);\n    console.log(`  fetch('/api/users/${userId}')`);\n  }, [userId]); // Re-run when userId changes\n  \n  ProfileComponent.mount();\n  \n  // Simulate prop change\n  setTimeout(() => {\n    console.log('\\n[Props Changed] userId: 1 → 2');\n    userId = 2;\n    console.log('[ProfileComponent] Re-running effects with new userId');\n    console.log(`  Fetching data for user ${userId}...`);\n  }, 500);\n}, 1500);\n\n// DEPENDENCY ARRAY PATTERNS\nsetTimeout(() => {\n  console.log('\\n\\n=== useEffect Dependency Patterns ===\\n');\n  \n  let patterns = [\n    {\n      code: 'useEffect(() => { ... });',\n      deps: 'NO array',\n      runs: 'Every render (usually a mistake!)'\n    },\n    {\n      code: 'useEffect(() => { ... }, []);',\n      deps: 'Empty []',\n      runs: 'Once on mount only'\n    },\n    {\n      code: 'useEffect(() => { ... }, [count]);',\n      deps: '[count]',\n      runs: 'On mount + when count changes'\n    },\n    {\n      code: 'useEffect(() => { ... }, [a, b, c]);',\n      deps: '[a, b, c]',\n      runs: 'On mount + when a, b, OR c changes'\n    }\n  ];\n  \n  patterns.forEach(p => {\n    console.log(`${p.code}`);\n    console.log(`  Dependencies: ${p.deps}`);\n    console.log(`  Runs: ${p.runs}\\n`);\n  });\n}, 2500);\n\n// COMMON USE CASES\nsetTimeout(() => {\n  console.log('=== Common useEffect Use Cases ===\\n');\n  \n  console.log('1. FETCHING DATA:');\n  console.log('useEffect(() => {');\n  console.log('  fetch(\"/api/users\")');\n  console.log('    .then(res => res.json())');\n  console.log('    .then(data => setUsers(data));');\n  console.log('}, []); // Fetch once on mount\\n');\n  \n  console.log('2. SETTING DOCUMENT TITLE:');\n  console.log('useEffect(() => {');\n  console.log('  document.title = `Count: ${count}`;');\n  console.log('}, [count]); // Update when count changes\\n');\n  \n  console.log('3. SUBSCRIBING TO EVENTS:');\n  console.log('useEffect(() => {');\n  console.log('  function handleResize() {');\n  console.log('    setWidth(window.innerWidth);');\n  console.log('  }');\n  console.log('  ');\n  console.log('  window.addEventListener(\"resize\", handleResize);');\n  console.log('  ');\n  console.log('  return () => {  // Cleanup!');\n  console.log('    window.removeEventListener(\"resize\", handleResize);');\n  console.log('  };');\n  console.log('}, []); // Set up once\\n');\n  \n  console.log('4. TIMERS:');\n  console.log('useEffect(() => {');\n  console.log('  const timer = setInterval(() => {');\n  console.log('    setCount(c => c + 1);');\n  console.log('  }, 1000);');\n  console.log('  ');\n  console.log('  return () => clearInterval(timer); // Cleanup!');\n  console.log('}, []); // Start timer once\\n');\n  \n  console.log('5. LOCAL STORAGE:');\n  console.log('useEffect(() => {');\n  console.log('  localStorage.setItem(\"theme\", theme);');\n  console.log('}, [theme]); // Save when theme changes');\n}, 2600);"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "useEffect Hook explained:\n\n1. **Basic useEffect** (runs after every render):\n   ```jsx\n   import { useEffect } from 'react';\n   \n   function MyComponent() {\n     useEffect(() => {\n       console.log('Component rendered!');\n     });\n     // NO dependency array = runs after EVERY render\n   }\n   ```\n\n2. **Run once on mount** (empty dependency array):\n   ```jsx\n   useEffect(() => {\n     console.log('Component mounted!');\n   }, []);  // Empty array = run ONCE on mount\n   ```\n\n3. **Run when specific values change**:\n   ```jsx\n   useEffect(() => {\n     console.log('Count changed:', count);\n   }, [count]);  // Runs when count changes\n   ```\n\n4. **Cleanup function** (returned from effect):\n   ```jsx\n   useEffect(() => {\n     // Setup\n     const timer = setInterval(() => {\n       console.log('Tick');\n     }, 1000);\n     \n     // Cleanup (runs before next effect OR on unmount)\n     return () => {\n       clearInterval(timer);\n       console.log('Timer cleaned up');\n     };\n   }, []);\n   ```\n\n5. **Fetching data**:\n   ```jsx\n   useEffect(() => {\n     async function fetchData() {\n       const res = await fetch('/api/users');\n       const data = await res.json();\n       setUsers(data);\n     }\n     \n     fetchData();\n   }, []);  // Fetch once on mount\n   ```\n\n6. **Multiple dependencies**:\n   ```jsx\n   useEffect(() => {\n     // Runs when userId OR filter changes\n     fetchUserPosts(userId, filter);\n   }, [userId, filter]);\n   ```\n\n7. **Event listeners**:\n   ```jsx\n   useEffect(() => {\n     function handleScroll() {\n       setScrollY(window.scrollY);\n     }\n     \n     window.addEventListener('scroll', handleScroll);\n     \n     return () => {\n       window.removeEventListener('scroll', handleScroll);\n     };\n   }, []);\n   ```\n\n8. **Local Storage**:\n   ```jsx\n   useEffect(() => {\n     localStorage.setItem('user', JSON.stringify(user));\n   }, [user]);  // Save when user changes\n   ```\n\n9. **Document Title**:\n   ```jsx\n   useEffect(() => {\n     document.title = `Messages (${unreadCount})`;\n   }, [unreadCount]);\n   ```\n\n10. **Conditional Effect**:\n   ```jsx\n   useEffect(() => {\n     if (isLoggedIn) {\n       // Only run if logged in\n       connectToChat();\n       \n       return () => disconnectFromChat();\n     }\n   }, [isLoggedIn]);\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common useEffect mistakes:\n\n1. **Forgetting dependency array**:\n   ```jsx\n   // WRONG! Runs after EVERY render\n   useEffect(() => {\n     fetchData();  // Infinite loop if it updates state!\n   });\n   \n   // CORRECT!\n   useEffect(() => {\n     fetchData();\n   }, []);  // Run once on mount\n   ```\n\n2. **Using async directly in useEffect**:\n   ```jsx\n   // WRONG!\n   useEffect(async () => {  // Can't make effect async!\n     const data = await fetch('/api/users');\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     async function fetchData() {\n       const data = await fetch('/api/users');\n     }\n     fetchData();\n   }, []);\n   ```\n\n3. **Missing dependencies**:\n   ```jsx\n   // WRONG! (missing 'count' in dependencies)\n   useEffect(() => {\n     console.log('Count is:', count);\n   }, []);  // Should include [count]!\n   \n   // CORRECT!\n   useEffect(() => {\n     console.log('Count is:', count);\n   }, [count]);  // Re-run when count changes\n   ```\n\n4. **Not cleaning up**:\n   ```jsx\n   // WRONG! (memory leak)\n   useEffect(() => {\n     const timer = setInterval(() => setCount(c => c + 1), 1000);\n     // No cleanup!\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     const timer = setInterval(() => setCount(c => c + 1), 1000);\n     return () => clearInterval(timer);  // Cleanup!\n   }, []);\n   ```\n\n5. **Infinite loops**:\n   ```jsx\n   // WRONG! Infinite loop\n   useEffect(() => {\n     setCount(count + 1);  // Updates state → re-render → effect runs → updates state...\n   }, [count]);  // Depends on count!\n   \n   // CORRECT! (if you really need this pattern)\n   useEffect(() => {\n     if (count < 10) {  // Add condition\n       setCount(count + 1);\n     }\n   }, [count]);\n   ```\n\n6. **Stale closures**:\n   ```jsx\n   // WRONG! (captures old 'count')\n   useEffect(() => {\n     const timer = setInterval(() => {\n       setCount(count + 1);  // Always uses initial count!\n     }, 1000);\n     return () => clearInterval(timer);\n   }, []);  // Empty deps = count never updates\n   \n   // CORRECT!\n   useEffect(() => {\n     const timer = setInterval(() => {\n       setCount(c => c + 1);  // Use functional update\n     }, 1000);\n     return () => clearInterval(timer);\n   }, []);  // No dependency on count needed\n   ```\n\n7. **Multiple effects for unrelated logic** (good practice!):\n   ```jsx\n   // WRONG! (mixing concerns)\n   useEffect(() => {\n     fetchUsers();  // Unrelated\n     document.title = 'Users';  // to\n     window.addEventListener('resize', handleResize);  // each other\n   }, []);\n   \n   // CORRECT! (separate effects)\n   useEffect(() => {\n     fetchUsers();\n   }, []);\n   \n   useEffect(() => {\n     document.title = 'Users';\n   }, []);\n   \n   useEffect(() => {\n     window.addEventListener('resize', handleResize);\n     return () => window.removeEventListener('resize', handleResize);\n   }, []);\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.6-challenge",
              "title": "Practice Challenge",
              "description": "Create a clock component with useEffect:\n\n1. Create a `ClockComponent` object with:\n   - state: { time: current time string }\n   - mount() - simulates component mounting\n   - unmount() - simulates component unmounting\n   - Use effect to update time every second\n   - Cleanup timer on unmount\n\n2. Test by mounting, waiting 3 seconds, then unmounting",
              "instructions": "Create a clock component with useEffect:\n\n1. Create a `ClockComponent` object with:\n   - state: { time: current time string }\n   - mount() - simulates component mounting\n   - unmount() - simulates component unmounting\n   - Use effect to update time every second\n   - Cleanup timer on unmount\n\n2. Test by mounting, waiting 3 seconds, then unmounting",
              "starterCode": "// Clock Component with useEffect\n\nlet ClockComponent = {\n  state: { time: new Date().toLocaleTimeString() },\n  timerId: null,\n  \n  mount() {\n    console.log('[Clock] Mounting...');\n    console.log('[Clock] useEffect(() => { ... }, [])');\n    \n    // Effect: Start timer\n    this.timerId = setInterval(() => {\n      this.state.time = new Date().toLocaleTimeString();\n      console.log('[Clock] Tick:', this.state.time);\n    }, 1000);\n    \n    console.log('[Clock] Timer started (ID:', this.timerId, ')');\n    console.log('[Clock] Registered cleanup function\\n');\n  },\n  \n  unmount() {\n    console.log('\\n[Clock] Unmounting...');\n    console.log('[Clock] Running cleanup function');\n    \n    // Cleanup: Stop timer\n    if (this.timerId) {\n      clearInterval(this.timerId);\n      console.log('[Clock] Timer stopped');\n    }\n  }\n};\n\n// Test\nasync function testClock() {\n  console.log('=== Clock Component Test ===\\n');\n  \n  ClockComponent.mount();\n  \n  // Wait 3 seconds\n  await new Promise(resolve => setTimeout(resolve, 3000));\n  \n  ClockComponent.unmount();\n}\n\ntestClock();",
              "solution": "// Complete useEffect simulation\n\nlet ClockComponent = {\n  state: { time: new Date().toLocaleTimeString(), ticks: 0 },\n  timerId: null,\n  mounted: false,\n  \n  mount() {\n    console.log('┌────────────────────────────────┐');\n    console.log('│     Clock Component Mount      │');\n    console.log('└────────────────────────────────┘\\n');\n    \n    this.mounted = true;\n    \n    console.log('[useEffect] Starting side effects...');\n    console.log('[Effect 1] Setting document title');\n    // document.title = 'Clock App';\n    \n    console.log('[Effect 2] Starting interval timer\\n');\n    this.timerId = setInterval(() => {\n      if (this.mounted) {\n        this.state.time = new Date().toLocaleTimeString();\n        this.state.ticks++;\n        console.log(`⏰ ${this.state.time} (tick #${this.state.ticks})`);\n      }\n    }, 1000);\n    \n    console.log(`✓ Timer ID: ${this.timerId}`);\n    console.log('✓ Cleanup function registered\\n');\n  },\n  \n  unmount() {\n    console.log('\\n┌────────────────────────────────┐');\n    console.log('│    Clock Component Unmount     │');\n    console.log('└────────────────────────────────┘\\n');\n    \n    this.mounted = false;\n    \n    console.log('[Cleanup] Running effect cleanup...');\n    \n    if (this.timerId) {\n      clearInterval(this.timerId);\n      console.log(`✓ Timer ${this.timerId} cleared`);\n      this.timerId = null;\n    }\n    \n    console.log(`✓ Total ticks: ${this.state.ticks}`);\n    console.log('✓ Component unmounted cleanly\\n');\n  }\n};\n\n// Fetch component with cleanup\nlet DataFetcher = {\n  state: { data: null, loading: false },\n  controller: null,\n  \n  async mount(userId) {\n    console.log('┌────────────────────────────────┐');\n    console.log('│   DataFetcher Mount (user:${userId})   │'.replace('${userId}', userId));\n    console.log('└────────────────────────────────┘\\n');\n    \n    console.log('[useEffect] Running with [userId] dependency');\n    console.log(`  userId = ${userId}\\n`);\n    \n    // Simulate AbortController for fetch cancellation\n    this.controller = { aborted: false };\n    \n    this.state.loading = true;\n    console.log('[Fetch] Starting request...');\n    \n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    if (!this.controller.aborted) {\n      this.state.data = { id: userId, name: `User ${userId}` };\n      this.state.loading = false;\n      console.log('[Fetch] Success:', this.state.data);\n    } else {\n      console.log('[Fetch] Aborted');\n    }\n    \n    console.log('\\n✓ Cleanup function registered');\n  },\n  \n  unmount() {\n    console.log('\\n[Cleanup] Aborting fetch if in progress...');\n    if (this.controller) {\n      this.controller.aborted = true;\n      console.log('✓ Fetch aborted');\n    }\n  }\n};\n\n// Run demonstrations\nasync function runDemo() {\n  console.log('═══ useEffect Demo ═══\\n');\n  \n  // Demo 1: Clock\n  console.log('DEMO 1: Clock with Timer\\n');\n  ClockComponent.mount();\n  \n  await new Promise(resolve => setTimeout(resolve, 3500));\n  \n  ClockComponent.unmount();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // Demo 2: Data fetching\n  console.log('\\nDEMO 2: Data Fetching with Cleanup\\n');\n  console.log('Fetching user 1...');\n  let fetch1 = DataFetcher.mount(1);\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  console.log('\\n[Props Change] userId: 1 → 2');\n  console.log('Cleaning up old effect...');\n  DataFetcher.unmount();\n  \n  console.log('\\nFetching user 2...');\n  await DataFetcher.mount(2);\n  \n  console.log('\\n\\n=== useEffect Best Practices ===\\n');\n  let practices = [\n    '✓ Always include dependency array ([], [dep], etc.)',\n    '✓ Return cleanup function when needed',\n    '✓ Don\\'t call async functions directly in useEffect',\n    '✓ Clean up timers, subscriptions, event listeners',\n    '✓ Use separate useEffect for unrelated logic',\n    '✓ Put all dependencies in the array',\n    '✓ Cleanup prevents memory leaks'\n  ];\n  \n  practices.forEach(p => console.log(p));\n}\n\nrunDemo();",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should set up interval",
                  "expectedOutput": "number",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should clean up interval",
                  "expectedOutput": "cleaned",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use setInterval in mount(), clearInterval in unmount()"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common useEffect mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common useEffect mistakes:"
                },
                {
                  "mistake": "**Forgetting dependency array**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting dependency array**:\n   ```jsx\n   // WRONG! Runs after EVERY render\n   useEffect(() => {\n     fetchData();  // Infinite loop if it updates state!\n   });\n   \n   // CORRECT!\n   useEffect(() => {\n     fetchData();\n   }, []);  // Run once on mount\n   ```"
                },
                {
                  "mistake": "**Using async directly in useEffect**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Using async directly in useEffect**:\n   ```jsx\n   // WRONG!\n   useEffect(async () => {  // Can't make effect async!\n     const data = await fetch('/api/users');\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     async function fetchData() {\n       const data = await fetch('/api/users');\n     }\n     fetchData();\n   }, []);\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12.7",
          "title": "React Context API - Global State Without Prop Drilling (The Radio Station Analogy)",
          "moduleId": "module-12",
          "order": 7,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're running a radio station:\n\nWithout Radio (Prop Drilling):\n- Want to share a message with 100 people\n- Call person 1, they call person 2, they call person 3...\n- Message passes through everyone to reach the last person\n- Tedious! What if someone in the middle is busy?\n\nWith Radio Station (Context):\n- Broadcast once from the station\n- Everyone with a radio can tune in directly\n- No chain of messengers needed!\n- Anyone who needs the info just 'subscribes'\n\nReact Context works like a radio station:\n- **Provider** = The radio station (broadcasts data)\n- **Consumer/useContext** = The radio receiver (listens for data)\n- Any component can tune in without passing props through every level!\n\nPerfect for: Theme (dark/light), Auth (logged in user), Language (i18n)"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// React Context API - Global State\n\nconsole.log('=== React Context API ===\\n');\n\n// THE PROBLEM: Prop Drilling\nconsole.log('PROBLEM: Prop Drilling\\n');\nconsole.log('App → Layout → Header → UserMenu → UserName');\nconsole.log('Pass user prop through EVERY component? Tedious!\\n');\n\nlet propDrillingExample = `\n// Without Context (prop drilling nightmare)\nfunction App() {\n  const [user, setUser] = useState({ name: 'Alice' });\n  return <Layout user={user} />;  // Pass to Layout\n}\n\nfunction Layout({ user }) {\n  return <Header user={user} />;  // Pass to Header\n}\n\nfunction Header({ user }) {\n  return <UserMenu user={user} />;  // Pass to UserMenu\n}\n\nfunction UserMenu({ user }) {\n  return <span>{user.name}</span>;  // Finally use it!\n}\n`;\nconsole.log(propDrillingExample);\n\n// THE SOLUTION: Context\nconsole.log('\\nSOLUTION: Context API\\n');\n\n// Simulating React Context\nlet UserContext = {\n  _value: null,\n  Provider: function(props) {\n    this._value = props.value;\n    console.log('[Provider] Broadcasting:', props.value);\n    return props.children;\n  }\n};\n\nfunction useContext(context) {\n  console.log('[useContext] Receiving:', context._value);\n  return context._value;\n}\n\n// Create and use context\nconsole.log('// Step 1: Create Context');\nconsole.log('const UserContext = createContext(null);\\n');\n\nconsole.log('// Step 2: Provide value at top level');\nconsole.log('function App() {');\nconsole.log('  const [user, setUser] = useState({ name: \"Alice\" });');\nconsole.log('  return (');\nconsole.log('    <UserContext.Provider value={{ user, setUser }}>');\nconsole.log('      <Layout />  // No props needed!');\nconsole.log('    </UserContext.Provider>');\nconsole.log('  );');\nconsole.log('}\\n');\n\nconsole.log('// Step 3: Consume anywhere with useContext');\nconsole.log('function UserMenu() {');\nconsole.log('  const { user } = useContext(UserContext);  // Direct access!');\nconsole.log('  return <span>{user.name}</span>;');\nconsole.log('}\\n');\n\n// Simulate the flow\nconsole.log('=== Simulating Context Flow ===\\n');\n\nUserContext.Provider({ value: { name: 'Alice', role: 'admin' } });\nlet userData = useContext(UserContext);\nconsole.log('UserMenu displays:', userData.name);\n\n// Real-world example: Auth Context\nconsole.log('\\n\\n=== Real Example: Auth Context ===\\n');\n\nlet authContextCode = `\n// contexts/AuthContext.jsx\nimport { createContext, useContext, useState } from 'react';\n\n// 1. Create context\nconst AuthContext = createContext(null);\n\n// 2. Create provider component\nexport function AuthProvider({ children }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  const login = async (email, password) => {\n    const res = await fetch('/api/login', {\n      method: 'POST',\n      body: JSON.stringify({ email, password })\n    });\n    const data = await res.json();\n    setUser(data.user);\n  };\n\n  const logout = () => {\n    setUser(null);\n    // Clear cookies/tokens\n  };\n\n  return (\n    <AuthContext.Provider value={{ user, login, logout, loading }}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\n// 3. Create custom hook for easy access\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n}\n`;\nconsole.log(authContextCode);\n\nconsole.log('// Usage in App.jsx');\nconsole.log('import { AuthProvider } from \"./contexts/AuthContext\";\\n');\nconsole.log('function App() {');\nconsole.log('  return (');\nconsole.log('    <AuthProvider>');\nconsole.log('      <Router>');\nconsole.log('        <Routes>...</Routes>');\nconsole.log('      </Router>');\nconsole.log('    </AuthProvider>');\nconsole.log('  );');\nconsole.log('}\\n');\n\nconsole.log('// Usage in any component');\nconsole.log('function Navbar() {');\nconsole.log('  const { user, logout } = useAuth();');\nconsole.log('  return user ? (');\nconsole.log('    <button onClick={logout}>Logout {user.name}</button>');\nconsole.log('  ) : (');\nconsole.log('    <Link to=\"/login\">Login</Link>');\nconsole.log('  );');\nconsole.log('}');\n\n// Theme Context example\nconsole.log('\\n\\n=== Real Example: Theme Context ===\\n');\n\nlet ThemeContext = {\n  _value: { theme: 'light', toggleTheme: () => {} }\n};\n\nconsole.log('// contexts/ThemeContext.jsx');\nconsole.log('export function ThemeProvider({ children }) {');\nconsole.log('  const [theme, setTheme] = useState(\"light\");');\nconsole.log('');\nconsole.log('  const toggleTheme = () => {');\nconsole.log('    setTheme(prev => prev === \"light\" ? \"dark\" : \"light\");');\nconsole.log('  };');\nconsole.log('');\nconsole.log('  return (');\nconsole.log('    <ThemeContext.Provider value={{ theme, toggleTheme }}>');\nconsole.log('      {children}');\nconsole.log('    </ThemeContext.Provider>');\nconsole.log('  );');\nconsole.log('}\\n');\n\nconsole.log('// Any component can toggle theme!');\nconsole.log('function ThemeToggle() {');\nconsole.log('  const { theme, toggleTheme } = useTheme();');\nconsole.log('  return (');\nconsole.log('    <button onClick={toggleTheme}>');\nconsole.log('      {theme === \"light\" ? \"🌙\" : \"☀️\"}');\nconsole.log('    </button>');\nconsole.log('  );');\nconsole.log('}');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Context API step by step:\n\n1. **Create Context**:\n   ```jsx\n   import { createContext } from 'react';\n   \n   const MyContext = createContext(defaultValue);\n   // defaultValue used when no Provider found\n   ```\n\n2. **Create Provider Component**:\n   ```jsx\n   export function MyProvider({ children }) {\n     const [state, setState] = useState(initialValue);\n     \n     return (\n       <MyContext.Provider value={{ state, setState }}>\n         {children}\n       </MyContext.Provider>\n     );\n   }\n   ```\n\n3. **Create Custom Hook** (best practice!):\n   ```jsx\n   export function useMyContext() {\n     const context = useContext(MyContext);\n     if (!context) {\n       throw new Error('useMyContext must be within MyProvider');\n     }\n     return context;\n   }\n   ```\n\n4. **Wrap App with Provider**:\n   ```jsx\n   function App() {\n     return (\n       <MyProvider>\n         <RestOfApp />\n       </MyProvider>\n     );\n   }\n   ```\n\n5. **Use in Any Component**:\n   ```jsx\n   function DeepNestedComponent() {\n     const { state, setState } = useMyContext();\n     // Access state directly - no props needed!\n   }\n   ```\n\n**Common Context Use Cases**:\n- **AuthContext**: User login state, login/logout functions\n- **ThemeContext**: Dark/light mode, toggle function\n- **CartContext**: Shopping cart items, add/remove functions\n- **LanguageContext**: Current language, translation function\n\n**Multiple Contexts** (nest providers):\n```jsx\nfunction App() {\n  return (\n    <AuthProvider>\n      <ThemeProvider>\n        <CartProvider>\n          <Router>...</Router>\n        </CartProvider>\n      </ThemeProvider>\n    </AuthProvider>\n  );\n}\n```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Context mistakes:\n\n1. **Using Context for everything** (overuse):\n   ```jsx\n   // WRONG! Don't use context for local state\n   const ButtonContext = createContext();\n   // Button click count doesn't need global state!\n   \n   // CORRECT! Only use for truly global state:\n   // - Auth, Theme, Language, Shopping Cart\n   ```\n\n2. **Forgetting the Provider**:\n   ```jsx\n   // WRONG! useContext outside Provider returns undefined\n   function App() {\n     return <UserProfile />;  // No Provider!\n   }\n   \n   function UserProfile() {\n     const user = useContext(UserContext);  // undefined!\n   }\n   \n   // CORRECT!\n   function App() {\n     return (\n       <UserContext.Provider value={user}>\n         <UserProfile />\n       </UserContext.Provider>\n     );\n   }\n   ```\n\n3. **Not memoizing context value** (performance issue):\n   ```jsx\n   // WRONG! New object every render = all consumers re-render\n   <MyContext.Provider value={{ user, setUser }}>\n   \n   // CORRECT! Memoize the value\n   const value = useMemo(() => ({ user, setUser }), [user]);\n   <MyContext.Provider value={value}>\n   ```\n\n4. **Putting too much in one context**:\n   ```jsx\n   // WRONG! Everything in one context\n   const AppContext = createContext();\n   // value = { user, theme, cart, language, notifications... }\n   // Changing theme re-renders cart components!\n   \n   // CORRECT! Separate contexts\n   <AuthProvider>\n     <ThemeProvider>\n       <CartProvider>\n   ```\n\n5. **Not creating custom hook** (error-prone):\n   ```jsx\n   // WRONG! Raw useContext everywhere\n   const value = useContext(AuthContext);\n   // No error if used outside provider!\n   \n   // CORRECT! Custom hook with error checking\n   function useAuth() {\n     const context = useContext(AuthContext);\n     if (!context) {\n       throw new Error('useAuth must be within AuthProvider');\n     }\n     return context;\n   }\n   ```\n\n**When NOT to use Context**:\n- State only used by 1-2 nearby components (just pass props)\n- Frequently changing data (use state management like Zustand)\n- Server state (use React Query or SWR instead)"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.7-challenge",
              "title": "Practice Challenge: Theme Context",
              "description": "Create a simple Theme Context system:\n\n1. Create a ThemeContext simulation with:\n   - Current theme ('light' or 'dark')\n   - toggleTheme function\n\n2. Create a Provider that manages theme state\n\n3. Create components that use the theme:\n   - ThemeToggle button\n   - ThemedBox that shows current theme\n\n4. Demonstrate theme switching",
              "instructions": "Simulate React Context for theme management. Create provider, consumer, and demonstrate the toggle working.",
              "starterCode": "// Theme Context Simulation\n\n// Simulating React Context\nlet ThemeContext = {\n  _value: null,\n  Provider: function(value, children) {\n    this._value = value;\n    return children;\n  }\n};\n\nfunction useTheme() {\n  return ThemeContext._value;\n}\n\n// Theme Provider\nlet themeState = { theme: 'light' };\n\nfunction toggleTheme() {\n  themeState.theme = themeState.theme === 'light' ? 'dark' : 'light';\n  console.log('[Theme Changed]', themeState.theme);\n}\n\n// Set up provider\nThemeContext.Provider({ theme: themeState.theme, toggleTheme });\n\n// Components using context\nfunction ThemeToggle() {\n  let { theme, toggleTheme } = useTheme();\n  console.log(`[ThemeToggle] Current: ${theme}`);\n  console.log(`[ThemeToggle] Button: ${theme === 'light' ? '🌙 Dark Mode' : '☀️ Light Mode'}`);\n  return { toggle: toggleTheme };\n}\n\nfunction ThemedBox() {\n  let { theme } = useTheme();\n  let styles = theme === 'light' \n    ? { bg: 'white', text: 'black' }\n    : { bg: '#1a1a1a', text: 'white' };\n  console.log(`[ThemedBox] Background: ${styles.bg}, Text: ${styles.text}`);\n}\n\n// Test the context\nconsole.log('=== Theme Context Demo ===\\n');\nconsole.log('Initial state:');\nThemedBox();\n\nlet toggle = ThemeToggle();\nconsole.log('\\nClicking toggle button...');\ntoggle.toggle();\n\n// Update context with new state\nThemeContext.Provider({ theme: themeState.theme, toggleTheme });\n\nconsole.log('\\nAfter toggle:');\nThemedBox();",
              "solution": "// Complete Theme Context System\n\nconsole.log('═══════════════════════════════');\nconsole.log('   Theme Context Demo');\nconsole.log('═══════════════════════════════\\n');\n\n// Simulating React's createContext and useContext\nfunction createContext(defaultValue) {\n  return {\n    _value: defaultValue,\n    Provider: function(props) {\n      this._value = props.value;\n      console.log('[Context] Provider mounted with:', props.value.theme);\n      if (props.children) props.children();\n    }\n  };\n}\n\nfunction useContext(context) {\n  if (!context._value) {\n    throw new Error('useContext must be used within a Provider!');\n  }\n  return context._value;\n}\n\n// 1. Create Theme Context\nconst ThemeContext = createContext({ theme: 'light', toggleTheme: () => {} });\n\n// 2. Theme Provider (manages state)\nlet themeState = {\n  theme: 'light',\n  listeners: [],\n  \n  toggle() {\n    this.theme = this.theme === 'light' ? 'dark' : 'light';\n    console.log(`\\n[State] Theme changed to: ${this.theme}`);\n    this.notify();\n  },\n  \n  subscribe(fn) {\n    this.listeners.push(fn);\n  },\n  \n  notify() {\n    this.listeners.forEach(fn => fn(this.theme));\n  }\n};\n\nfunction ThemeProvider(children) {\n  const value = {\n    theme: themeState.theme,\n    toggleTheme: () => themeState.toggle()\n  };\n  \n  ThemeContext.Provider({ value, children });\n}\n\n// 3. Custom Hook (best practice!)\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n}\n\n// 4. Components using the context\nfunction Header() {\n  const { theme } = useTheme();\n  console.log(`\\n[Header] Rendering with ${theme} theme`);\n  console.log(`  Logo: ${theme === 'light' ? '🌞 MyApp' : '🌙 MyApp'}`);\n}\n\nfunction ThemeToggleButton() {\n  const { theme, toggleTheme } = useTheme();\n  console.log(`\\n[ThemeToggle] Button: ${theme === 'light' ? '🌙 Switch to Dark' : '☀️ Switch to Light'}`);\n  return { onClick: toggleTheme };\n}\n\nfunction Card() {\n  const { theme } = useTheme();\n  const styles = {\n    light: { bg: '#ffffff', text: '#000000', border: '#e0e0e0' },\n    dark: { bg: '#2d2d2d', text: '#ffffff', border: '#404040' }\n  };\n  const s = styles[theme];\n  console.log(`\\n[Card] Styled with ${theme} theme`);\n  console.log(`  Background: ${s.bg}`);\n  console.log(`  Text: ${s.text}`);\n  console.log(`  Border: ${s.border}`);\n}\n\nfunction Footer() {\n  const { theme } = useTheme();\n  console.log(`\\n[Footer] © 2024 MyApp (${theme} mode)`);\n}\n\n// 5. App with all components\nfunction App() {\n  Header();\n  Card();\n  let toggleBtn = ThemeToggleButton();\n  Footer();\n  return { toggleBtn };\n}\n\n// Run the demo\nconsole.log('─── Initial Render (Light Theme) ───');\nlet app;\nThemeProvider(() => {\n  app = App();\n});\n\nconsole.log('\\n─── User Clicks Theme Toggle ───');\nthemeState.toggle();\n\n// Re-render with new theme\nconsole.log('\\n─── Re-render (Dark Theme) ───');\nThemeProvider(() => {\n  app = App();\n});\n\nconsole.log('\\n─── Toggle Again ───');\nthemeState.toggle();\n\nThemeProvider(() => {\n  app = App();\n});\n\nconsole.log('\\n\\n═══════════════════════════════');\nconsole.log('   Context API Benefits');\nconsole.log('═══════════════════════════════');\nconsole.log('✓ No prop drilling through intermediate components');\nconsole.log('✓ Any component can access theme directly');\nconsole.log('✓ Single source of truth for theme state');\nconsole.log('✓ Easy to add new themed components');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Theme toggle works",
                  "expectedOutput": "dark",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Create a context object with _value property to store the current value"
                },
                {
                  "level": 2,
                  "text": "The Provider sets _value, useContext reads _value"
                },
                {
                  "level": 3,
                  "text": "toggleTheme should change 'light' to 'dark' and vice versa"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to wrap components in Provider",
                  "consequence": "useContext returns undefined or default value",
                  "correction": "Always wrap your component tree with <Provider value={...}>"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "12.8",
          "title": "React + TypeScript - Type-Safe Components (The Contract Analogy)",
          "moduleId": "module-12",
          "order": 8,
          "estimatedMinutes": 35,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine hiring a contractor to build a house:\n\nWithout a Contract (JavaScript):\n- 'Build me a house'\n- Contractor might forget the roof\n- Wrong number of rooms?\n- No way to verify until it's built\n\nWith a Contract (TypeScript):\n- 'Build a house with: 3 bedrooms, 2 bathrooms, a garage'\n- Contractor MUST follow the contract\n- Caught immediately if something's missing\n- Both parties know exactly what to expect\n\nTypeScript + React:\n- **Props interface** = Contract for component inputs\n- **State types** = Contract for component data\n- **Return types** = Contract for what component renders\n\nIDE catches errors BEFORE you run the app!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// React + TypeScript Fundamentals\n\nconsole.log('=== React + TypeScript ===\\n');\n\n// Setup: npm create vite@latest my-app -- --template react-ts\n\n// 1. TYPING PROPS\nconsole.log('1. Typing Component Props\\n');\n\nlet userCardExample = `\n// Define props interface\ninterface UserCardProps {\n  name: string;\n  email: string;\n  age: number;\n  isAdmin?: boolean;  // Optional prop\n  onEdit: (id: number) => void;  // Function prop\n}\n\n// Use interface with component\nfunction UserCard({ name, email, age, isAdmin = false, onEdit }: UserCardProps) {\n  return (\n    <div className=\"card\">\n      <h2>{name} {isAdmin && '👑'}</h2>\n      <p>{email}</p>\n      <p>Age: {age}</p>\n      <button onClick={() => onEdit(1)}>Edit</button>\n    </div>\n  );\n}\n\n// TypeScript catches errors:\n<UserCard name=\"Alice\" />  // ❌ Error: missing email, age, onEdit\n<UserCard name=\"Alice\" email=\"a@b.com\" age=\"25\" onEdit={() => {}} />  // ❌ age should be number\n<UserCard name=\"Alice\" email=\"a@b.com\" age={25} onEdit={() => {}} />  // ✅ Correct!\n`;\nconsole.log(userCardExample);\n\n// 2. TYPING STATE\nconsole.log('\\n2. Typing useState\\n');\n\nlet stateExample = `\n// Explicit type for complex state\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nfunction UserProfile() {\n  // Type inferred from initial value\n  const [count, setCount] = useState(0);  // number\n  const [name, setName] = useState('');   // string\n  \n  // Explicit type for complex objects\n  const [user, setUser] = useState<User | null>(null);\n  \n  // Array of objects\n  const [users, setUsers] = useState<User[]>([]);\n  \n  // Union types\n  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');\n  \n  return (\n    <div>\n      {user?.name}  // Safe access with optional chaining\n      {status === 'loading' && <Spinner />}\n    </div>\n  );\n}\n`;\nconsole.log(stateExample);\n\n// 3. TYPING EVENTS\nconsole.log('\\n3. Typing Event Handlers\\n');\n\nlet eventExample = `\nfunction SearchForm() {\n  const [query, setQuery] = useState('');\n  \n  // Input change event\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setQuery(e.target.value);\n  };\n  \n  // Form submit event\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    console.log('Searching:', query);\n  };\n  \n  // Button click event\n  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n    console.log('Button clicked');\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input value={query} onChange={handleChange} />\n      <button type=\"submit\" onClick={handleClick}>Search</button>\n    </form>\n  );\n}\n`;\nconsole.log(eventExample);\n\n// 4. TYPING CHILDREN\nconsole.log('\\n4. Typing Children Prop\\n');\n\nlet childrenExample = `\n// For components that wrap other components\ninterface CardProps {\n  title: string;\n  children: React.ReactNode;  // Any valid React child\n}\n\nfunction Card({ title, children }: CardProps) {\n  return (\n    <div className=\"card\">\n      <h2>{title}</h2>\n      {children}\n    </div>\n  );\n}\n\n// Usage\n<Card title=\"Profile\">\n  <p>User content here</p>\n  <UserAvatar />\n</Card>\n`;\nconsole.log(childrenExample);\n\n// 5. TYPING CONTEXT\nconsole.log('\\n5. Typing Context API\\n');\n\nlet contextExample = `\n// contexts/AuthContext.tsx\ninterface AuthContextType {\n  user: User | null;\n  login: (email: string, password: string) => Promise<void>;\n  logout: () => void;\n  loading: boolean;\n}\n\nconst AuthContext = createContext<AuthContextType | null>(null);\n\nexport function useAuth(): AuthContextType {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n}\n\n// Now TypeScript knows exactly what useAuth returns!\nfunction Navbar() {\n  const { user, logout } = useAuth();  // Fully typed!\n  //     ^^^^ TypeScript knows user is User | null\n}\n`;\nconsole.log(contextExample);\n\n// 6. COMMON PATTERNS\nconsole.log('\\n6. Common TypeScript + React Patterns\\n');\n\nlet patterns = `\n// Generic Components\ninterface ListProps<T> {\n  items: T[];\n  renderItem: (item: T) => React.ReactNode;\n}\n\nfunction List<T>({ items, renderItem }: ListProps<T>) {\n  return <ul>{items.map(renderItem)}</ul>;\n}\n\n// Usage with type inference\n<List \n  items={[{ id: 1, name: 'Alice' }]} \n  renderItem={(user) => <li key={user.id}>{user.name}</li>}\n/>\n\n// Discriminated Unions for State\ntype RequestState<T> = \n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: string };\n\nfunction UserList() {\n  const [state, setState] = useState<RequestState<User[]>>({ status: 'idle' });\n  \n  if (state.status === 'loading') return <Spinner />;\n  if (state.status === 'error') return <Error message={state.error} />;\n  if (state.status === 'success') return <List items={state.data} />;\n  return <button onClick={fetch}>Load Users</button>;\n}\n`;\nconsole.log(patterns);\n\nconsole.log('\\n=== Quick Reference ===\\n');\nconsole.log('Props:     interface XProps { prop: type }');\nconsole.log('State:     useState<Type>(initial)');\nconsole.log('Events:    (e: React.ChangeEvent<HTMLInputElement>) => void');\nconsole.log('Children:  React.ReactNode');\nconsole.log('Ref:       useRef<HTMLInputElement>(null)');\nconsole.log('Context:   createContext<Type | null>(null)');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "TypeScript + React essentials:\n\n1. **Props Interface**:\n   ```tsx\n   interface ButtonProps {\n     label: string;\n     onClick: () => void;\n     disabled?: boolean;  // Optional\n     variant: 'primary' | 'secondary';  // Union type\n   }\n   \n   function Button({ label, onClick, disabled = false }: ButtonProps) {\n     return <button disabled={disabled} onClick={onClick}>{label}</button>;\n   }\n   ```\n\n2. **Typed useState**:\n   ```tsx\n   // Simple types (inferred)\n   const [count, setCount] = useState(0);\n   \n   // Complex types (explicit)\n   const [user, setUser] = useState<User | null>(null);\n   const [items, setItems] = useState<Item[]>([]);\n   ```\n\n3. **Common Event Types**:\n   ```tsx\n   // Input\n   onChange: (e: React.ChangeEvent<HTMLInputElement>) => void\n   \n   // Form\n   onSubmit: (e: React.FormEvent<HTMLFormElement>) => void\n   \n   // Button\n   onClick: (e: React.MouseEvent<HTMLButtonElement>) => void\n   \n   // Keyboard\n   onKeyDown: (e: React.KeyboardEvent<HTMLInputElement>) => void\n   ```\n\n4. **Typed useRef**:\n   ```tsx\n   const inputRef = useRef<HTMLInputElement>(null);\n   const divRef = useRef<HTMLDivElement>(null);\n   \n   // Access with null check\n   inputRef.current?.focus();\n   ```\n\n5. **Typed Callbacks**:\n   ```tsx\n   const handleSave = useCallback((id: number, data: User) => {\n     // ...\n   }, []);\n   \n   const total = useMemo<number>(() => {\n     return items.reduce((sum, item) => sum + item.price, 0);\n   }, [items]);\n   ```\n\n6. **Function Component Type**:\n   ```tsx\n   // Explicit return type (optional but helpful)\n   const UserCard: React.FC<UserProps> = ({ name, email }) => {\n     return <div>{name}</div>;\n   };\n   \n   // Or simpler (preferred):\n   function UserCard({ name, email }: UserProps): JSX.Element {\n     return <div>{name}</div>;\n   }\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common TypeScript + React mistakes:\n\n1. **Forgetting null checks with state**:\n   ```tsx\n   // WRONG! user could be null\n   const [user, setUser] = useState<User | null>(null);\n   return <div>{user.name}</div>;  // ❌ Error!\n   \n   // CORRECT! Check for null\n   return <div>{user?.name}</div>;  // ✅ Optional chaining\n   // OR\n   if (!user) return <Loading />;\n   return <div>{user.name}</div>;  // ✅ TypeScript knows user exists\n   ```\n\n2. **Wrong event type**:\n   ```tsx\n   // WRONG! Using wrong element type\n   const handleChange = (e: React.ChangeEvent<HTMLButtonElement>) => {\n     console.log(e.target.value);  // Buttons don't have value!\n   };\n   \n   // CORRECT! Match element type\n   const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n     console.log(e.target.value);  // ✅\n   };\n   ```\n\n3. **Using `any` to avoid errors**:\n   ```tsx\n   // WRONG! Defeats the purpose of TypeScript\n   const [data, setData] = useState<any>(null);\n   \n   // CORRECT! Define proper types\n   interface ApiResponse {\n     users: User[];\n     total: number;\n   }\n   const [data, setData] = useState<ApiResponse | null>(null);\n   ```\n\n4. **Overusing React.FC**:\n   ```tsx\n   // Less preferred (implicit children, verbose)\n   const Card: React.FC<CardProps> = ({ title }) => { ... };\n   \n   // Preferred (simpler, explicit)\n   function Card({ title }: CardProps) { ... }\n   ```\n\n5. **Not typing async functions**:\n   ```tsx\n   // WRONG! Return type unclear\n   const fetchUsers = async () => {\n     const res = await fetch('/api/users');\n     return res.json();  // What type is this?\n   };\n   \n   // CORRECT! Explicit return type\n   const fetchUsers = async (): Promise<User[]> => {\n     const res = await fetch('/api/users');\n     return res.json();\n   };\n   ```\n\n**Setup TypeScript + React**:\n```bash\n# New project\nnpm create vite@latest my-app -- --template react-ts\n\n# Add to existing project\nnpm install typescript @types/react @types/react-dom\nnpx tsc --init\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.8-challenge",
              "title": "Practice Challenge: Type a React Component",
              "description": "Create a typed ProductCard component:\n\n1. Define a Product interface with:\n   - id: number\n   - name: string\n   - price: number\n   - inStock: boolean\n\n2. Define ProductCardProps interface with:\n   - product: Product\n   - onAddToCart: (id: number) => void\n\n3. Create a simulated ProductCard that uses these types\n\n4. Show how TypeScript catches errors",
              "instructions": "Define TypeScript interfaces and simulate a typed React component. Show error cases that TypeScript would catch.",
              "starterCode": "// TypeScript + React Simulation\n\n// Define interfaces\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  inStock: boolean;\n}\n\ninterface ProductCardProps {\n  product: Product;\n  onAddToCart: (id: number) => void;\n}\n\n// Simulate a typed component\nfunction ProductCard(props: ProductCardProps) {\n  let { product, onAddToCart } = props;\n  \n  console.log(`[ProductCard] Rendering: ${product.name}`);\n  console.log(`  Price: $${product.price.toFixed(2)}`);\n  console.log(`  In Stock: ${product.inStock ? 'Yes' : 'No'}`);\n  \n  if (product.inStock) {\n    console.log('  [Add to Cart] button enabled');\n  } else {\n    console.log('  [Out of Stock] button disabled');\n  }\n  \n  return {\n    addToCart: () => onAddToCart(product.id)\n  };\n}\n\n// Test with valid data\nconsole.log('=== Valid Usage ===\\n');\n\nlet laptop: Product = {\n  id: 1,\n  name: 'MacBook Pro',\n  price: 1999.99,\n  inStock: true\n};\n\nlet card = ProductCard({\n  product: laptop,\n  onAddToCart: (id) => console.log(`\\nAdded product ${id} to cart!`)\n});\n\ncard.addToCart();\n\n// TypeScript would catch these errors:\nconsole.log('\\n=== Errors TypeScript Would Catch ===\\n');\nconsole.log('❌ Missing required prop:');\nconsole.log('   ProductCard({ product: laptop })  // Error: missing onAddToCart');\n\nconsole.log('\\n❌ Wrong type:');\nconsole.log('   let bad = { id: \"1\", name: \"Item\", price: \"10\", inStock: \"yes\" }');\nconsole.log('   // Error: id should be number, price should be number, inStock should be boolean');\n\nconsole.log('\\n❌ Wrong function signature:');\nconsole.log('   onAddToCart: (name: string) => void');\nconsole.log('   // Error: expects (id: number) => void');",
              "solution": "// Complete TypeScript + React Type Safety Demo\n\nconsole.log('═══════════════════════════════');\nconsole.log('  TypeScript + React Demo');\nconsole.log('═══════════════════════════════\\n');\n\n// 1. Define interfaces\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  inStock: boolean;\n  category?: string;  // Optional property\n}\n\ninterface ProductCardProps {\n  product: Product;\n  onAddToCart: (id: number) => void;\n  showDetails?: boolean;  // Optional prop with default\n}\n\n// Type for cart state\ninterface CartItem {\n  product: Product;\n  quantity: number;\n}\n\n// 2. Simulate typed component\nfunction ProductCard({ product, onAddToCart, showDetails = true }: ProductCardProps) {\n  console.log(`\\n┌─ ProductCard ──────────────────┐`);\n  console.log(`│ ${product.name.padEnd(30)} │`);\n  console.log(`├────────────────────────────────┤`);\n  \n  if (showDetails) {\n    console.log(`│ Price: $${product.price.toFixed(2).padEnd(22)} │`);\n    console.log(`│ Stock: ${(product.inStock ? '✓ Available' : '✗ Out of Stock').padEnd(23)} │`);\n    if (product.category) {\n      console.log(`│ Category: ${product.category.padEnd(20)} │`);\n    }\n  }\n  \n  console.log(`│                                │`);\n  if (product.inStock) {\n    console.log(`│  [🛒 Add to Cart]              │`);\n  } else {\n    console.log(`│  [Notify When Available]       │`);\n  }\n  console.log(`└────────────────────────────────┘`);\n  \n  return {\n    handleClick: () => {\n      if (product.inStock) {\n        onAddToCart(product.id);\n      } else {\n        console.log(`[Notification] Will notify when ${product.name} is back!`);\n      }\n    }\n  };\n}\n\n// 3. Simulate cart with typed state\nlet cart: CartItem[] = [];\n\nfunction addToCart(productId: number, products: Product[]): void {\n  const product = products.find(p => p.id === productId);\n  if (!product) {\n    console.log(`[Error] Product ${productId} not found`);\n    return;\n  }\n  \n  const existing = cart.find(item => item.product.id === productId);\n  if (existing) {\n    existing.quantity++;\n    console.log(`[Cart] Updated ${product.name} quantity to ${existing.quantity}`);\n  } else {\n    cart.push({ product, quantity: 1 });\n    console.log(`[Cart] Added ${product.name} to cart`);\n  }\n}\n\n// 4. Test with typed data\nconst products: Product[] = [\n  { id: 1, name: 'MacBook Pro 16\"', price: 2499.99, inStock: true, category: 'Laptops' },\n  { id: 2, name: 'iPhone 15 Pro', price: 999.99, inStock: true, category: 'Phones' },\n  { id: 3, name: 'AirPods Max', price: 549.99, inStock: false, category: 'Audio' }\n];\n\nconsole.log('=== Rendering Product Cards ===');\n\nproducts.forEach(product => {\n  const card = ProductCard({\n    product,\n    onAddToCart: (id) => addToCart(id, products)\n  });\n  card.handleClick();\n});\n\nconsole.log('\\n\\n=== Cart Summary ===');\nconsole.log(`Total items: ${cart.length}`);\nconst total = cart.reduce((sum, item) => sum + (item.product.price * item.quantity), 0);\nconsole.log(`Total: $${total.toFixed(2)}`);\n\nconsole.log('\\n\\n=== TypeScript Error Prevention ===\\n');\n\nconst errorExamples = [\n  {\n    code: 'ProductCard({ product: laptop })',\n    error: 'Property onAddToCart is missing',\n    fixed: 'ProductCard({ product: laptop, onAddToCart: (id) => {} })'\n  },\n  {\n    code: '{ id: \"1\", name: \"Item\", price: \"10\" }',\n    error: 'Type string is not assignable to type number',\n    fixed: '{ id: 1, name: \"Item\", price: 10, inStock: true }'\n  },\n  {\n    code: 'onAddToCart: (name: string) => {}',\n    error: 'Parameter name incompatible with id: number',\n    fixed: 'onAddToCart: (id: number) => {}'\n  },\n  {\n    code: 'product.nonExistent',\n    error: 'Property nonExistent does not exist on type Product',\n    fixed: 'Use only defined properties: id, name, price, inStock'\n  }\n];\n\nerrorExamples.forEach((ex, i) => {\n  console.log(`${i + 1}. ❌ ${ex.code}`);\n  console.log(`   Error: ${ex.error}`);\n  console.log(`   ✅ Fix: ${ex.fixed}\\n`);\n});\n\nconsole.log('═══════════════════════════════');\nconsole.log('  Benefits of TypeScript + React');\nconsole.log('═══════════════════════════════');\nconsole.log('✓ Catch errors at compile time, not runtime');\nconsole.log('✓ IDE autocomplete for props and state');\nconsole.log('✓ Self-documenting code with interfaces');\nconsole.log('✓ Refactor with confidence');\nconsole.log('✓ Better team collaboration');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Correctly typed components work",
                  "expectedOutput": "Cart",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Define Product interface with all required properties"
                },
                {
                  "level": 2,
                  "text": "ProductCardProps needs product: Product and onAddToCart: (id: number) => void"
                },
                {
                  "level": 3,
                  "text": "Use optional properties (?) for non-required props"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using 'any' type to bypass errors",
                  "consequence": "Loses all type safety benefits",
                  "correction": "Define proper interfaces for all data structures"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "12.9",
          "title": "Tailwind CSS with React - Utility-First Styling (The Building Blocks Analogy)",
          "moduleId": "module-12",
          "order": 9,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine building with LEGO:\n\nTraditional CSS (Custom Bricks):\n- Design and manufacture each brick yourself\n- 'button-primary.css' with 20 properties\n- Change requires modifying the mold\n- Lots of unused bricks sitting around\n\nTailwind CSS (Standard LEGO Bricks):\n- Pre-made bricks in all sizes and colors\n- Combine small pieces: 'bg-blue-500 text-white px-4 py-2 rounded'\n- Want a change? Swap a brick!\n- Only bricks you use are in the final box\n\nTailwind = Utility classes that do ONE thing each:\n- bg-blue-500 → background: blue\n- text-white → color: white\n- px-4 → padding-left/right: 1rem\n- rounded → border-radius\n\nNo more writing custom CSS for every component!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Tailwind CSS with React\n\nconsole.log('=== Tailwind CSS Fundamentals ===\\n');\n\n// Setup: npm install -D tailwindcss postcss autoprefixer\n//        npx tailwindcss init -p\n\n// 1. BASIC CLASSES\nconsole.log('1. Basic Utility Classes\\n');\n\nlet basicClasses = {\n  spacing: {\n    'p-4': 'padding: 1rem (16px)',\n    'm-2': 'margin: 0.5rem (8px)',\n    'px-6': 'padding-left/right: 1.5rem',\n    'my-auto': 'margin-top/bottom: auto',\n    'space-x-4': 'horizontal spacing between children'\n  },\n  colors: {\n    'bg-blue-500': 'background-color: blue (medium)',\n    'text-white': 'color: white',\n    'border-gray-300': 'border-color: gray',\n    'bg-gradient-to-r': 'linear gradient to right'\n  },\n  typography: {\n    'text-xl': 'font-size: 1.25rem',\n    'font-bold': 'font-weight: 700',\n    'text-center': 'text-align: center',\n    'uppercase': 'text-transform: uppercase'\n  },\n  layout: {\n    'flex': 'display: flex',\n    'grid': 'display: grid',\n    'items-center': 'align-items: center',\n    'justify-between': 'justify-content: space-between'\n  }\n};\n\nfor (let [category, classes] of Object.entries(basicClasses)) {\n  console.log(`${category.toUpperCase()}:`);\n  for (let [className, meaning] of Object.entries(classes)) {\n    console.log(`  ${className.padEnd(20)} → ${meaning}`);\n  }\n  console.log('');\n}\n\n// 2. COMPONENT EXAMPLES\nconsole.log('\\n2. React Component Examples\\n');\n\nlet buttonExample = `\n// Button Component with Tailwind\nfunction Button({ children, variant = 'primary' }) {\n  const baseClasses = 'px-4 py-2 rounded font-medium transition-colors';\n  \n  const variants = {\n    primary: 'bg-blue-500 text-white hover:bg-blue-600',\n    secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300',\n    danger: 'bg-red-500 text-white hover:bg-red-600'\n  };\n  \n  return (\n    <button className={\\`\\${baseClasses} \\${variants[variant]}\\`}>\n      {children}\n    </button>\n  );\n}\n\n// Usage\n<Button>Save</Button>\n<Button variant=\"danger\">Delete</Button>\n`;\nconsole.log(buttonExample);\n\nlet cardExample = `\n// Card Component\nfunction Card({ title, children }) {\n  return (\n    <div className=\"bg-white rounded-lg shadow-md p-6 hover:shadow-lg transition-shadow\">\n      <h2 className=\"text-xl font-bold text-gray-800 mb-4\">{title}</h2>\n      <div className=\"text-gray-600\">{children}</div>\n    </div>\n  );\n}\n`;\nconsole.log(cardExample);\n\n// 3. RESPONSIVE DESIGN\nconsole.log('\\n3. Responsive Design (Mobile-First)\\n');\n\nlet responsiveExample = `\n// Responsive breakpoints:\n// sm:  640px and up\n// md:  768px and up\n// lg:  1024px and up\n// xl:  1280px and up\n// 2xl: 1536px and up\n\n// Mobile: 1 column, Tablet: 2 columns, Desktop: 4 columns\n<div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n  <Card>Item 1</Card>\n  <Card>Item 2</Card>\n  <Card>Item 3</Card>\n  <Card>Item 4</Card>\n</div>\n\n// Hide on mobile, show on desktop\n<nav className=\"hidden lg:flex\">\n  <Links />\n</nav>\n\n// Different padding at different sizes\n<div className=\"p-4 md:p-6 lg:p-8\">\n  Content\n</div>\n`;\nconsole.log(responsiveExample);\n\n// 4. DARK MODE\nconsole.log('\\n4. Dark Mode Support\\n');\n\nlet darkModeExample = `\n// tailwind.config.js\nmodule.exports = {\n  darkMode: 'class',  // or 'media' for system preference\n};\n\n// Component with dark mode\n<div className=\"bg-white dark:bg-gray-800 text-gray-900 dark:text-white\">\n  <h1 className=\"text-gray-800 dark:text-gray-100\">\n    Supports both themes!\n  </h1>\n</div>\n\n// Toggle dark mode\n<html className=\"dark\">  // Add/remove 'dark' class\n`;\nconsole.log(darkModeExample);\n\n// 5. COMMON PATTERNS\nconsole.log('\\n5. Common UI Patterns\\n');\n\nlet patterns = `\n// Centered Container\n<div className=\"max-w-4xl mx-auto px-4\">\n  Centered content\n</div>\n\n// Flex Row with Spacing\n<div className=\"flex items-center justify-between gap-4\">\n  <Logo />\n  <Nav />\n</div>\n\n// Form Input\n<input className=\"w-full px-4 py-2 border border-gray-300 rounded-lg \n                  focus:ring-2 focus:ring-blue-500 focus:border-transparent\n                  placeholder-gray-400\" />\n\n// Avatar\n<img className=\"w-10 h-10 rounded-full object-cover\" />\n\n// Badge\n<span className=\"px-2 py-1 text-xs font-medium bg-green-100 text-green-800 rounded-full\">\n  Active\n</span>\n\n// Loading Spinner\n<div className=\"animate-spin h-8 w-8 border-4 border-blue-500 \n                border-t-transparent rounded-full\" />\n`;\nconsole.log(patterns);\n\nconsole.log('\\n=== Tailwind Setup Commands ===\\n');\nconsole.log('npm install -D tailwindcss postcss autoprefixer');\nconsole.log('npx tailwindcss init -p');\nconsole.log('');\nconsole.log('// Add to tailwind.config.js');\nconsole.log('content: [\"./src/**/*.{js,jsx,ts,tsx}\"]');\nconsole.log('');\nconsole.log('// Add to src/index.css');\nconsole.log('@tailwind base;');\nconsole.log('@tailwind components;');\nconsole.log('@tailwind utilities;');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Tailwind class naming patterns:\n\n1. **Color Scale** (50-950):\n   ```jsx\n   // Lighter → Darker\n   bg-blue-50   // Very light blue\n   bg-blue-100\n   bg-blue-500  // Medium blue (default)\n   bg-blue-900  // Very dark blue\n   \n   text-gray-700  // Dark gray text\n   border-red-300  // Light red border\n   ```\n\n2. **Spacing Scale** (0-96):\n   ```jsx\n   // 1 unit = 0.25rem = 4px\n   p-0   // 0px\n   p-1   // 4px\n   p-2   // 8px\n   p-4   // 16px\n   p-8   // 32px\n   \n   // Directional\n   pt-4  // padding-top\n   pr-4  // padding-right\n   pb-4  // padding-bottom\n   pl-4  // padding-left\n   px-4  // padding left + right\n   py-4  // padding top + bottom\n   ```\n\n3. **State Modifiers**:\n   ```jsx\n   hover:bg-blue-600    // On hover\n   focus:ring-2         // On focus\n   active:scale-95      // On click\n   disabled:opacity-50  // When disabled\n   group-hover:visible  // When parent hovered\n   ```\n\n4. **Responsive Prefixes**:\n   ```jsx\n   // Mobile-first: no prefix = all sizes\n   w-full           // width: 100% on all\n   md:w-1/2         // width: 50% on medium+\n   lg:w-1/3         // width: 33% on large+\n   \n   hidden lg:block  // Hidden until large screens\n   ```\n\n5. **Flexbox Shortcuts**:\n   ```jsx\n   <div className=\"flex items-center justify-between gap-4\">\n   //              ^^^^  ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^  ^^^^^\n   //              display  align-items  justify-content  gap\n   ```\n\n6. **Grid Shortcuts**:\n   ```jsx\n   <div className=\"grid grid-cols-3 gap-4\">\n   //              ^^^^  ^^^^^^^^^^  ^^^^^\n   //              display  3 columns  gap\n   ```\n\n7. **Common Combinations**:\n   ```jsx\n   // Card\n   \"bg-white rounded-lg shadow-md p-6\"\n   \n   // Button\n   \"bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600\"\n   \n   // Input\n   \"border border-gray-300 rounded px-3 py-2 focus:ring-2\"\n   \n   // Centered container\n   \"max-w-4xl mx-auto px-4\"\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Tailwind mistakes:\n\n1. **Not purging unused styles in production**:\n   ```javascript\n   // tailwind.config.js - MUST configure content\n   module.exports = {\n     content: [\n       './src/**/*.{js,jsx,ts,tsx}',  // Scan these files\n       './public/index.html'\n     ],\n   };\n   // Without this: 3MB CSS file!\n   // With this: ~10KB CSS file\n   ```\n\n2. **Dynamic class names don't work**:\n   ```jsx\n   // WRONG! Tailwind can't detect dynamic classes\n   <div className={`bg-${color}-500`}>  // Won't work!\n   \n   // CORRECT! Use complete class names\n   const colorClasses = {\n     blue: 'bg-blue-500',\n     red: 'bg-red-500',\n     green: 'bg-green-500'\n   };\n   <div className={colorClasses[color]}>\n   ```\n\n3. **Class order doesn't matter (mostly)**:\n   ```jsx\n   // These are the same:\n   \"px-4 py-2 bg-blue-500\"\n   \"bg-blue-500 py-2 px-4\"\n   \n   // BUT: later classes don't override earlier ones!\n   \"text-red-500 text-blue-500\"  // Both applied, browser decides\n   ```\n\n4. **Forgetting mobile-first**:\n   ```jsx\n   // WRONG thinking: \"hide on large screens\"\n   <div className=\"lg:hidden\">  // Hidden on lg+, visible on mobile\n   \n   // CORRECT thinking: mobile-first\n   <div className=\"block lg:hidden\">  // Same, but clearer intent\n   <div className=\"hidden lg:block\">  // Hidden mobile, visible lg+\n   ```\n\n5. **Long class strings (use extraction)**:\n   ```jsx\n   // MESSY\n   <button className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 focus:ring-2 focus:ring-blue-300 disabled:opacity-50 transition-colors\">\n   \n   // BETTER: Extract to variable or component\n   const btnPrimary = 'px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600';\n   <button className={btnPrimary}>\n   \n   // BEST: Use @apply in CSS (sparingly)\n   .btn-primary {\n     @apply px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600;\n   }\n   ```\n\n6. **Not using the official plugins**:\n   ```bash\n   # Forms plugin - better form styling\n   npm install @tailwindcss/forms\n   \n   # Typography plugin - prose styling\n   npm install @tailwindcss/typography\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.9-challenge",
              "title": "Practice Challenge: Build a Profile Card",
              "description": "Create a profile card using Tailwind utility classes:\n\n1. Card container with:\n   - White background, rounded corners, shadow\n   - Padding and max-width\n\n2. Avatar section with:\n   - Circular image placeholder\n   - Centered\n\n3. User info with:\n   - Name (large, bold)\n   - Title (smaller, gray)\n   - Bio (normal text)\n\n4. Action buttons with:\n   - Follow (blue) and Message (gray) buttons\n   - Hover states",
              "instructions": "Build a profile card by logging the Tailwind classes you would use. Simulate the component structure.",
              "starterCode": "// Profile Card with Tailwind CSS\n\nconsole.log('=== Profile Card Component ===\\n');\n\n// Simulate the component structure with classes\nlet profileCard = {\n  container: 'bg-white rounded-xl shadow-lg p-6 max-w-sm mx-auto',\n  \n  avatar: {\n    wrapper: 'flex justify-center mb-4',\n    image: 'w-24 h-24 rounded-full bg-gray-200'\n  },\n  \n  info: {\n    name: 'text-xl font-bold text-gray-800 text-center',\n    title: 'text-gray-500 text-center mb-2',\n    bio: 'text-gray-600 text-center text-sm'\n  },\n  \n  buttons: {\n    wrapper: 'flex gap-3 mt-6',\n    follow: 'flex-1 bg-blue-500 text-white py-2 rounded-lg hover:bg-blue-600 transition-colors',\n    message: 'flex-1 bg-gray-200 text-gray-800 py-2 rounded-lg hover:bg-gray-300 transition-colors'\n  }\n};\n\n// Display the structure\nconsole.log('CARD CONTAINER:');\nconsole.log(`  className=\"${profileCard.container}\"`);\n\nconsole.log('\\nAVATAR:');\nconsole.log(`  wrapper: \"${profileCard.avatar.wrapper}\"`);\nconsole.log(`  image: \"${profileCard.avatar.image}\"`);\n\nconsole.log('\\nUSER INFO:');\nconsole.log(`  name: \"${profileCard.info.name}\"`);\nconsole.log(`  title: \"${profileCard.info.title}\"`);\nconsole.log(`  bio: \"${profileCard.info.bio}\"`);\n\nconsole.log('\\nBUTTONS:');\nconsole.log(`  wrapper: \"${profileCard.buttons.wrapper}\"`);\nconsole.log(`  follow: \"${profileCard.buttons.follow}\"`);\nconsole.log(`  message: \"${profileCard.buttons.message}\"`);\n\n// Render simulation\nconsole.log('\\n\\n=== Rendered Output (Simulated) ===\\n');\nconsole.log('┌────────────────────────────────┐');\nconsole.log('│                                │');\nconsole.log('│         ┌──────────┐           │');\nconsole.log('│         │  Avatar  │           │');\nconsole.log('│         └──────────┘           │');\nconsole.log('│                                │');\nconsole.log('│         Sarah Johnson          │');\nconsole.log('│      Product Designer          │');\nconsole.log('│                                │');\nconsole.log('│  Creating user-centered        │');\nconsole.log('│  experiences for startups.     │');\nconsole.log('│                                │');\nconsole.log('│  [Follow]       [Message]      │');\nconsole.log('│                                │');\nconsole.log('└────────────────────────────────┘');",
              "solution": "// Complete Profile Card with Tailwind CSS\n\nconsole.log('═══════════════════════════════');\nconsole.log('  Tailwind Profile Card Demo');\nconsole.log('═══════════════════════════════\\n');\n\n// Define the component with all Tailwind classes\nconst ProfileCard = {\n  // Main container\n  container: [\n    'bg-white',           // White background\n    'rounded-xl',         // Large rounded corners\n    'shadow-lg',          // Large shadow\n    'p-8',                // Padding all sides\n    'max-w-sm',           // Max width small\n    'mx-auto',            // Center horizontally\n    'hover:shadow-xl',    // Bigger shadow on hover\n    'transition-shadow',  // Smooth transition\n    'dark:bg-gray-800'    // Dark mode support\n  ].join(' '),\n  \n  // Avatar section\n  avatar: {\n    wrapper: 'flex justify-center mb-6',\n    image: [\n      'w-28', 'h-28',           // Size\n      'rounded-full',            // Circular\n      'object-cover',            // Image fit\n      'ring-4', 'ring-blue-100', // Border ring\n      'dark:ring-blue-900'       // Dark mode ring\n    ].join(' '),\n    placeholder: 'w-28 h-28 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center text-white text-3xl font-bold'\n  },\n  \n  // User information\n  info: {\n    name: 'text-2xl font-bold text-gray-800 text-center dark:text-white',\n    title: 'text-blue-500 text-center font-medium mt-1',\n    location: 'text-gray-400 text-sm text-center mt-1 flex items-center justify-center gap-1',\n    bio: 'text-gray-600 text-center mt-4 leading-relaxed dark:text-gray-300'\n  },\n  \n  // Stats section\n  stats: {\n    wrapper: 'flex justify-center gap-8 mt-6 pt-6 border-t border-gray-100 dark:border-gray-700',\n    item: 'text-center',\n    number: 'text-2xl font-bold text-gray-800 dark:text-white',\n    label: 'text-xs text-gray-500 uppercase tracking-wide'\n  },\n  \n  // Action buttons\n  buttons: {\n    wrapper: 'flex gap-3 mt-6',\n    primary: [\n      'flex-1',\n      'bg-blue-500', 'text-white',\n      'py-2.5', 'px-4',\n      'rounded-lg',\n      'font-medium',\n      'hover:bg-blue-600',\n      'active:scale-95',\n      'transition-all',\n      'flex', 'items-center', 'justify-center', 'gap-2'\n    ].join(' '),\n    secondary: [\n      'flex-1',\n      'bg-gray-100', 'text-gray-700',\n      'py-2.5', 'px-4',\n      'rounded-lg',\n      'font-medium',\n      'hover:bg-gray-200',\n      'active:scale-95',\n      'transition-all',\n      'dark:bg-gray-700', 'dark:text-gray-200'\n    ].join(' ')\n  }\n};\n\n// Log the classes for each section\nconsole.log('📦 CONTAINER');\nconsole.log(`   ${ProfileCard.container}\\n`);\n\nconsole.log('🖼️  AVATAR');\nconsole.log(`   Wrapper: ${ProfileCard.avatar.wrapper}`);\nconsole.log(`   Image: ${ProfileCard.avatar.image}\\n`);\n\nconsole.log('ℹ️  USER INFO');\nconsole.log(`   Name: ${ProfileCard.info.name}`);\nconsole.log(`   Title: ${ProfileCard.info.title}`);\nconsole.log(`   Bio: ${ProfileCard.info.bio}\\n`);\n\nconsole.log('📊 STATS');\nconsole.log(`   Wrapper: ${ProfileCard.stats.wrapper}`);\nconsole.log(`   Number: ${ProfileCard.stats.number}`);\nconsole.log(`   Label: ${ProfileCard.stats.label}\\n`);\n\nconsole.log('🔘 BUTTONS');\nconsole.log(`   Primary: ${ProfileCard.buttons.primary}`);\nconsole.log(`   Secondary: ${ProfileCard.buttons.secondary}\\n`);\n\n// Visual representation\nconsole.log('\\n═══════════════════════════════');\nconsole.log('     Visual Representation');\nconsole.log('═══════════════════════════════\\n');\n\nconsole.log('┌─────────────────────────────────────┐');\nconsole.log('│                                     │');\nconsole.log('│            ╭─────────╮              │');\nconsole.log('│            │   SJ    │              │');\nconsole.log('│            ╰─────────╯              │');\nconsole.log('│                                     │');\nconsole.log('│          Sarah Johnson              │');\nconsole.log('│         Product Designer            │');\nconsole.log('│          📍 San Francisco           │');\nconsole.log('│                                     │');\nconsole.log('│    Creating beautiful, functional   │');\nconsole.log('│    products that users love.        │');\nconsole.log('│                                     │');\nconsole.log('│  ─────────────────────────────────  │');\nconsole.log('│                                     │');\nconsole.log('│     234         89         12.4k    │');\nconsole.log('│    POSTS      PROJECTS    FOLLOWERS │');\nconsole.log('│                                     │');\nconsole.log('│  ┌──────────┐  ┌──────────────────┐ │');\nconsole.log('│  │  Follow  │  │     Message      │ │');\nconsole.log('│  └──────────┘  └──────────────────┘ │');\nconsole.log('│                                     │');\nconsole.log('└─────────────────────────────────────┘');\n\nconsole.log('\\n\\n═══════════════════════════════');\nconsole.log('       Key Tailwind Classes');\nconsole.log('═══════════════════════════════');\nconsole.log('• Layout: flex, justify-center, items-center, gap-*');\nconsole.log('• Spacing: p-*, m-*, mt-*, px-*');\nconsole.log('• Colors: bg-*, text-*, ring-*');\nconsole.log('• Typography: text-*, font-*');\nconsole.log('• Borders: rounded-*, border-*');\nconsole.log('• Effects: shadow-*, hover:*, transition-*');\nconsole.log('• Dark Mode: dark:bg-*, dark:text-*');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Card has proper Tailwind classes",
                  "expectedOutput": "rounded",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use bg-white, rounded-xl, shadow-lg for the card container"
                },
                {
                  "level": 2,
                  "text": "Use flex and justify-center to center the avatar"
                },
                {
                  "level": 3,
                  "text": "Add hover: prefixes for interactive states"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using dynamic class names like bg-${color}-500",
                  "consequence": "Tailwind purges classes it can't detect at build time",
                  "correction": "Use complete class names and map them to values"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-13",
      "title": "Module 13: Full-Stack Integration - Connecting Front-End & Back-End",
      "description": "Build complete full-stack applications by connecting React front-ends with Node.js/Hono backends and Prisma databases",
      "difficulty": "advanced",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "13.1",
          "title": "Full-Stack Architecture (The Restaurant Analogy)",
          "moduleId": "module-13",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "A restaurant has three main areas:\n\nDining Room (Front-End - React):\n- Where customers sit and interact\n- Beautiful presentation, easy to use\n- Menus, ordering interface, displays\n\nKitchen (Back-End - Node.js/Hono):\n- Where the real work happens\n- Receives orders, processes them\n- Business logic, data processing\n\nStorage Room (Database - Prisma/PostgreSQL):\n- Where ingredients are stored\n- Organized, persistent, reliable\n- Data that survives shutdowns\n\nWaiter (API):\n- Carries messages between dining room and kitchen\n- Takes orders from customers to chefs\n- Brings food from kitchen to customers\n\nFull-stack development means building ALL THREE parts and making them work together seamlessly!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Full-Stack Architecture Overview (Modern Stack)\n\n// FRONTEND (React) - What users see\nlet frontEnd = {\n  technology: 'React 19',\n  responsibilities: [\n    'User interface (buttons, forms, displays)',\n    'User interactions (clicks, typing)',\n    'API calls to backend',\n    'Display data from backend'\n  ],\n  example: 'Login form, dashboard, user profile page'\n};\n\nconsole.log('Frontend:', frontEnd);\n\n// BACKEND (Node.js + Hono) - Business logic\nlet backEnd = {\n  technology: 'Node.js 24 + Hono 4',\n  responsibilities: [\n    'API endpoints (routes)',\n    'Authentication & authorization',\n    'Business logic (validation, calculations)',\n    'Database operations',\n    'Security'\n  ],\n  example: 'POST /api/login, GET /api/users, PUT /api/profile'\n};\n\nconsole.log('\\nBackend:', backEnd);\n\n// DATABASE (PostgreSQL + Prisma) - Data storage\nlet database = {\n  technology: 'PostgreSQL + Prisma ORM',\n  responsibilities: [\n    'Store data persistently',\n    'Relationships between data',\n    'Query optimization',\n    'Data integrity'\n  ],\n  example: 'Users table, Posts table, Comments table'\n};\n\nconsole.log('\\nDatabase:', database);\n\n// HOW THEY COMMUNICATE (Example flow)\nconsole.log('\\n=== Full-Stack Data Flow ===\\n');\n\nfunction simulateFullStackFlow() {\n  console.log('1. USER ACTION: User clicks \"Login\" button in React');\n  console.log('   Frontend: <button onClick={handleLogin}>Login</button>');\n  \n  console.log('\\n2. FRONTEND: React sends HTTP request to backend');\n  console.log('   fetch(\"/api/login\", { method: \"POST\", body: { email, password } })');\n  \n  console.log('\\n3. BACKEND: Hono receives request at route');\n  console.log('   app.post(\"/api/login\", async (c) => { ... })');\n  \n  console.log('\\n4. BACKEND: Queries database via Prisma');\n  console.log('   const user = await prisma.user.findUnique({ where: { email } });');\n  \n  console.log('\\n5. DATABASE: Returns user data to backend');\n  console.log('   { id: 1, email: \"user@example.com\", name: \"Alice\" }');\n  \n  console.log('\\n6. BACKEND: Sends JSON response to frontend');\n  console.log('   return c.json({ success: true, user: { id: 1, name: \"Alice\" } });');\n  \n  console.log('\\n7. FRONTEND: React receives data and updates UI');\n  console.log('   setUser(data.user); // State update triggers re-render');\n  \n  console.log('\\n8. USER SEES: Dashboard with their name displayed');\n  console.log('   <h1>Welcome, {user.name}!</h1>');\n}\n\nsimulateFullStackFlow();\n\n// TECH STACK OPTIONS\nlet stacks = {\n  'Modern Stack': 'PostgreSQL + Hono + React + Node.js (recommended)',\n  PERN: 'PostgreSQL + Express + React + Node.js (legacy)',\n  MERN: 'MongoDB + Express + React + Node.js (legacy)',\n  'T3 Stack': 'TypeScript + tRPC + Tailwind + Prisma + Next.js'\n};\n\nconsole.log('\\nPopular Full-Stack Combinations:');\nfor (let [name, stack] of Object.entries(stacks)) {\n  console.log(`${name}: ${stack}`);\n}\n\nconsole.log('\\nWe\\'ll use: Hono + Prisma + React + TypeScript (modern, edge-ready)');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Full-Stack architecture explained:\n\n1. **Frontend (Client-Side)**:\n   - Runs in user's browser\n   - React components, HTML, CSS, JavaScript\n   - Makes HTTP requests to backend\n   - Port 3000 (development)\n\n2. **Backend (Server-Side)**:\n   - Runs on server (Node.js)\n   - Hono routes handle requests\n   - Connects to database\n   - Port 4000 or 5000 (development)\n\n3. **Database**:\n   - PostgreSQL server\n   - Stores all application data\n   - Accessed via Prisma ORM\n   - Port 5432 (default)\n\n4. **Communication (HTTP/REST)**:\n   ```javascript\n   // Frontend makes request\n   fetch('http://localhost:4000/api/users')\n     .then(res => res.json())\n     .then(users => setUsers(users));\n   \n   // Backend handles request (Hono)\n   app.get('/api/users', async (c) => {\n     const users = await prisma.user.findMany();\n     return c.json(users);\n   });\n   ```\n\n5. **CORS** (Cross-Origin Resource Sharing):\n   - Frontend and backend on different ports = different origins\n   - Need to enable CORS on backend:\n   ```javascript\n   import { Hono } from 'hono';\n   import { cors } from 'hono/cors';\n   const app = new Hono();\n   app.use('*', cors());\n   ```\n\n6. **Environment Variables**:\n   - Frontend: VITE_API_URL=http://localhost:4000\n   - Backend: DATABASE_URL=postgresql://...\n   - Never commit secrets to Git!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common full-stack mistakes:\n\n1. **CORS errors**:\n   ```\n   Error: Access to fetch at 'http://localhost:4000/api/users' from origin 'http://localhost:3000' \n   has been blocked by CORS policy\n   ```\n   Solution: Enable CORS on backend (Hono):\n   ```javascript\n   import { Hono } from 'hono';\n   import { cors } from 'hono/cors';\n   const app = new Hono();\n   app.use('*', cors());\n   ```\n\n2. **Wrong API URLs**:\n   ```javascript\n   // Wrong! (missing http://)\n   fetch('localhost:4000/api/users')\n   \n   // Correct!\n   fetch('http://localhost:4000/api/users')\n   \n   // Better! (use environment variable)\n   fetch(`${import.meta.env.VITE_API_URL}/api/users`)\n   ```\n\n3. **Frontend and backend not running**:\n   - Need TWO terminal windows:\n     * Terminal 1: `cd frontend && npm run dev` (port 3000)\n     * Terminal 2: `cd backend && npm run dev` (port 4000)\n\n4. **Not handling async properly**:\n   ```javascript\n   // Wrong!\n   let users = fetch('/api/users'); // Returns Promise!\n   console.log(users); // Promise, not data\n   \n   // Correct!\n   let response = await fetch('/api/users');\n   let users = await response.json();\n   console.log(users); // Actual data\n   ```\n\n5. **Hardcoded URLs**:\n   - Don't hardcode: `http://localhost:4000`\n   - Use env variables: `process.env.API_URL`\n   - Different in dev vs production!\n\n6. **Not validating data**:\n   - Validate on frontend (UX)\n   - ALSO validate on backend (security)\n   - Never trust client data!\n\n7. **Accessing request data in Hono**:\n   ```javascript\n   // Hono route\n   app.post('/api/users/:id', async (c) => {\n     c.req.param('id')           // From URL: /api/users/123\n     c.req.query('name')         // From query: ?name=alice\n     const body = await c.req.json()  // From POST body\n     body.email                  // { email: '...' }\n   });\n   ```\n\n8. **Storing JWT tokens in localStorage** (security risk!):\n   ```javascript\n   // RISKY! localStorage is vulnerable to XSS attacks\n   localStorage.setItem('token', jwtToken);\n   \n   // BETTER: Use httpOnly cookies (set by backend)\n   // Backend sets cookie (Hono):\n   import { setCookie } from 'hono/cookie';\n   setCookie(c, 'token', jwtToken, {\n     httpOnly: true,  // Can't be accessed by JavaScript!\n     secure: true,    // Only sent over HTTPS\n     sameSite: 'Strict'\n   });\n   \n   // Frontend automatically sends cookies with credentials:\n   fetch('/api/protected', { credentials: 'include' });\n   ```\n   - httpOnly cookies can't be stolen via XSS\n   - For SPAs, consider short-lived tokens + refresh tokens"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Express Equivalent",
              "legacy": "express",
              "content": "If you encounter older codebases using Express, here's how the patterns compare. Express was the dominant Node.js framework before Hono.",
              "code": "// Express Full-Stack Setup\nimport express from 'express';\nimport cors from 'cors';\n\nconst app = express();\n\n// CORS middleware (separate package)\napp.use(cors());\napp.use(express.json());\n\n// Route handling uses (req, res)\napp.get('/api/users', async (req, res) => {\n  const users = await prisma.user.findMany();\n  res.json(users);\n});\n\n// Request data access\napp.post('/api/users/:id', (req, res) => {\n  req.params.id    // URL params\n  req.query.name   // Query string\n  req.body.email   // POST body (needs express.json())\n});\n\n// Cookies\nres.cookie('token', jwtToken, {\n  httpOnly: true,\n  secure: true,\n  sameSite: 'strict'\n});",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13.1-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a full-stack data flow:\n\n1. Create a `frontend` object with a method `fetchUsers()` that:\n   - Logs \"Sending GET request to /api/users\"\n   - Calls backend.handleGetUsers()\n   - Logs the result\n\n2. Create a `backend` object with method `handleGetUsers()` that:\n   - Logs \"Backend received request\"\n   - Calls database.getUsers()\n   - Returns the result\n\n3. Create a `database` object with method `getUsers()` that:\n   - Returns array of mock users\n\nTest the complete flow.",
              "instructions": "Simulate a full-stack data flow:\n\n1. Create a `frontend` object with a method `fetchUsers()` that:\n   - Logs \"Sending GET request to /api/users\"\n   - Calls backend.handleGetUsers()\n   - Logs the result\n\n2. Create a `backend` object with method `handleGetUsers()` that:\n   - Logs \"Backend received request\"\n   - Calls database.getUsers()\n   - Returns the result\n\n3. Create a `database` object with method `getUsers()` that:\n   - Returns array of mock users\n\nTest the complete flow.",
              "starterCode": "// Database layer\nlet database = {\n  users: [\n    { id: 1, name: 'Alice', email: 'alice@example.com' },\n    { id: 2, name: 'Bob', email: 'bob@example.com' }\n  ],\n  \n  getUsers() {\n    console.log('[Database] Querying users table');\n    return this.users;\n  }\n};\n\n// Backend layer\nlet backend = {\n  handleGetUsers() {\n    console.log('[Backend] Received GET /api/users');\n    let users = database.getUsers();\n    console.log('[Backend] Sending response:', users.length, 'users');\n    return users;\n  }\n};\n\n// Frontend layer  \nlet frontend = {\n  fetchUsers() {\n    console.log('[Frontend] Fetching users from API');\n    let users = backend.handleGetUsers();\n    console.log('[Frontend] Received users:', users);\n    return users;\n  }\n};\n\n// Test the full stack\nconsole.log('=== Full-Stack Simulation ===\\n');\nfrontend.fetchUsers();",
              "solution": "// Complete full-stack simulation\n\n// Database layer\nlet database = {\n  users: [\n    { id: 1, name: 'Alice', email: 'alice@example.com' },\n    { id: 2, name: 'Bob', email: 'bob@example.com' },\n    { id: 3, name: 'Charlie', email: 'charlie@example.com' }\n  ],\n  \n  getUsers() {\n    console.log('[Database] Executing: SELECT * FROM users');\n    return this.users;\n  },\n  \n  getUserById(id) {\n    console.log(`[Database] Executing: SELECT * FROM users WHERE id = ${id}`);\n    return this.users.find(u => u.id === id);\n  },\n  \n  createUser(name, email) {\n    console.log(`[Database] Executing: INSERT INTO users (name, email) VALUES ('${name}', '${email}')`);\n    let newUser = { id: this.users.length + 1, name, email };\n    this.users.push(newUser);\n    return newUser;\n  }\n};\n\n// Backend layer\nlet backend = {\n  handleGetUsers() {\n    console.log('[Backend] GET /api/users');\n    let users = database.getUsers();\n    console.log(`[Backend] Response: 200 OK (${users.length} users)`);\n    return { status: 200, data: users };\n  },\n  \n  handleGetUser(id) {\n    console.log(`[Backend] GET /api/users/${id}`);\n    let user = database.getUserById(id);\n    if (user) {\n      console.log('[Backend] Response: 200 OK');\n      return { status: 200, data: user };\n    } else {\n      console.log('[Backend] Response: 404 Not Found');\n      return { status: 404, error: 'User not found' };\n    }\n  },\n  \n  handleCreateUser(name, email) {\n    console.log(`[Backend] POST /api/users`);\n    let newUser = database.createUser(name, email);\n    console.log('[Backend] Response: 201 Created');\n    return { status: 201, data: newUser };\n  }\n};\n\n// Frontend layer\nlet frontend = {\n  state: { users: [], currentUser: null },\n  \n  async fetchUsers() {\n    console.log('[Frontend] User clicked \"View Users\" button');\n    console.log('[Frontend] fetch(\"http://localhost:4000/api/users\")');\n    \n    let response = backend.handleGetUsers();\n    \n    if (response.status === 200) {\n      this.state.users = response.data;\n      console.log('[Frontend] State updated, re-rendering UI');\n      console.log('[Frontend] Displaying:', this.state.users.length, 'users');\n    }\n    \n    return this.state.users;\n  },\n  \n  async fetchUser(id) {\n    console.log(`[Frontend] User clicked on user ${id}`);\n    console.log(`[Frontend] fetch(\"http://localhost:4000/api/users/${id}\")`);\n    \n    let response = backend.handleGetUser(id);\n    \n    if (response.status === 200) {\n      this.state.currentUser = response.data;\n      console.log('[Frontend] Displaying user profile:', response.data.name);\n    } else {\n      console.log('[Frontend] Showing error: User not found');\n    }\n  },\n  \n  async createUser(name, email) {\n    console.log('[Frontend] User submitted \"Create User\" form');\n    console.log(`[Frontend] fetch(\"http://localhost:4000/api/users\", { method: \"POST\", body: { name, email } })`);\n    \n    let response = backend.handleCreateUser(name, email);\n    \n    if (response.status === 201) {\n      console.log('[Frontend] Success! Refreshing user list...');\n      this.fetchUsers();\n    }\n  }\n};\n\n// Simulate full-stack application\nconsole.log('=== Full-Stack Application Flow ===\\n');\n\nconsole.log('--- Scenario 1: List all users ---');\nfrontend.fetchUsers();\n\nconsole.log('\\n--- Scenario 2: View specific user ---');\nfrontend.fetchUser(1);\n\nconsole.log('\\n--- Scenario 3: Create new user ---');\nfrontend.createUser('Diana', 'diana@example.com');\n\nconsole.log('\\n--- Final database state ---');\nconsole.log('Total users:', database.users.length);\nconsole.log('Users:', database.users.map(u => u.name).join(', '));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should simulate complete flow",
                  "expectedOutput": "1",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Chain the method calls: frontend → backend → database → backend → frontend"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common full-stack mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common full-stack mistakes:"
                },
                {
                  "mistake": "**CORS errors**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**CORS errors**:\n   ```\n   Error: Access to fetch at 'http://localhost:4000/api/users' from origin 'http://localhost:3000' \n   has been blocked by CORS policy\n   ```\n   Solution: Enable CORS on backend:\n   ```javascript\n   import cors from 'cors';\n   app.use(cors());\n   ```"
                },
                {
                  "mistake": "**Wrong API URLs**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong API URLs**:\n   ```javascript\n   // Wrong! (missing http://)\n   fetch('localhost:4000/api/users')\n   \n   // Correct!\n   fetch('http://localhost:4000/api/users')\n   \n   // Better! (use environment variable)\n   fetch(`${import.meta.env.VITE_API_URL}/api/users`)\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "13.2",
          "title": "CORS - The #1 Error You'll Encounter (The Bouncer Analogy)",
          "moduleId": "module-13",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a nightclub with a strict bouncer:\n\nClub Rules:\n- Only people from the guest list can enter\n- The bouncer checks your ID and origin\n- If you're not on the list → DENIED!\n\nWeb Browser:\n- Your React app runs on http://localhost:3000 (origin A)\n- Your Hono API runs on http://localhost:4000 (origin B)\n- Browser: 'These are DIFFERENT addresses!'\n- Browser acts as bouncer: 'Can origin A talk to origin B?'\n\nCORS = Cross-Origin Resource Sharing:\n- Security feature built into ALL browsers\n- Prevents malicious websites from stealing data\n- By default: BLOCKS all cross-origin requests\n- You must EXPLICITLY allow your frontend to talk to your backend\n\nThe Fix:\n- Backend says: 'Yes, localhost:3000 is on the guest list'\n- Uses CORS headers to tell browser: 'This is allowed'\n- One line of code: app.use('*', cors())\n\nWithout CORS configuration → Every API call FAILS!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// CORS - The #1 Full-Stack Error (and how to fix it!)\n\nconsole.log('=== CORS Error Simulation ===\\n');\n\n// THE PROBLEM: Different origins\nlet origins = {\n  frontend: 'http://localhost:3000',\n  backend: 'http://localhost:4000'\n};\n\nconsole.log('Frontend origin:', origins.frontend);\nconsole.log('Backend origin:', origins.backend);\nconsole.log('\\nAre these the same origin?', origins.frontend === origins.backend);\nconsole.log('Result: DIFFERENT ORIGINS → Browser blocks by default!\\n');\n\n// What makes origins different?\nfunction analyzeOrigins() {\n  let examples = [\n    {\n      url1: 'http://localhost:3000',\n      url2: 'http://localhost:4000',\n      same: false,\n      reason: 'Different PORT'\n    },\n    {\n      url1: 'http://example.com',\n      url2: 'https://example.com',\n      same: false,\n      reason: 'Different PROTOCOL (http vs https)'\n    },\n    {\n      url1: 'http://example.com',\n      url2: 'http://api.example.com',\n      same: false,\n      reason: 'Different SUBDOMAIN'\n    },\n    {\n      url1: 'http://localhost:3000/page1',\n      url2: 'http://localhost:3000/page2',\n      same: true,\n      reason: 'Same protocol, domain, port (path doesn\\'t matter)'\n    }\n  ];\n  \n  console.log('=== What Makes Origins Different? ===\\n');\n  examples.forEach(ex => {\n    console.log(`${ex.url1}`);\n    console.log(`${ex.url2}`);\n    console.log(`Same origin? ${ex.same ? 'YES' : 'NO'}`);\n    console.log(`Reason: ${ex.reason}\\n`);\n  });\n}\n\nanalyzeOrigins();\n\n// THE ERROR students will see\nfunction simulateCORSError() {\n  console.log('=== The Error Message ===\\n');\n  console.log('Access to fetch at \\'http://localhost:4000/api/users\\' from origin');\n  console.log('   \\'http://localhost:3000\\' has been blocked by CORS policy:');\n  console.log('   No \\'Access-Control-Allow-Origin\\' header is present on the');\n  console.log('   requested resource.\\n');\n  console.log('Translation: Your backend didn\\'t give permission!\\n');\n}\n\nsimulateCORSError();\n\n// THE SOLUTION (Hono)\nconsole.log('=== The Fix (Hono Backend Code) ===\\n');\nconsole.log('// Hono has built-in CORS middleware - no extra package needed!\\n');\n\nconsole.log('// Import Hono and its CORS middleware');\nconsole.log('import { Hono } from \"hono\";');\nconsole.log('import { cors } from \"hono/cors\";  // Built-in!\\n');\n\nconsole.log('const app = new Hono();\\n');\n\nconsole.log('// THIS ONE LINE FIXES THE ERROR!');\nconsole.log('app.use(\"*\", cors());  // Allows ALL origins (dev only!)\\n');\n\nconsole.log('// Now your routes work');\nconsole.log('app.get(\"/api/users\", (c) => {');\nconsole.log('  return c.json([{ id: 1, name: \"Alice\" }]);');\nconsole.log('});\\n');\n\n// More secure CORS configuration\nconsole.log('=== Production CORS (More Secure) ===\\n');\nconsole.log('// Only allow specific origin');\nconsole.log('app.use(\"*\", cors({');\nconsole.log('  origin: \"https://myapp.com\",  // Only this domain allowed');\nconsole.log('  credentials: true,             // Allow cookies');\nconsole.log('  allowMethods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"]  // Allowed HTTP methods');\nconsole.log('}));\\n');\n\nconsole.log('// Multiple allowed origins');\nconsole.log('const allowedOrigins = [');\nconsole.log('  \"http://localhost:3000\",  // Dev');\nconsole.log('  \"https://myapp.com\",      // Production');\nconsole.log('  \"https://staging.myapp.com\"  // Staging');\nconsole.log('];\\n');\n\nconsole.log('app.use(\"*\", cors({');\nconsole.log('  origin: (origin) => {');\nconsole.log('    if (allowedOrigins.includes(origin)) {');\nconsole.log('      return origin;');\nconsole.log('    }');\nconsole.log('    return null;  // Deny other origins');\nconsole.log('  }');\nconsole.log('}));\\n');\n\n// What CORS actually does\nconsole.log('=== What CORS Does (Under the Hood) ===\\n');\nconsole.log('When you use app.use(\"*\", cors()), it adds these headers:\\n');\n\nlet corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization'\n};\n\nfor (let [header, value] of Object.entries(corsHeaders)) {\n  console.log(`${header}: ${value}`);\n}\n\nconsole.log('\\nThese headers tell the browser: \"It\\'s OK, I allow this!\"\\n');\n\n// Common CORS scenarios\nconsole.log('=== Common CORS Scenarios ===\\n');\n\nlet scenarios = [\n  {\n    scenario: 'React dev server calling Hono API',\n    frontend: 'http://localhost:3000',\n    backend: 'http://localhost:4000',\n    needsCORS: true,\n    solution: 'app.use(\"*\", cors())'\n  },\n  {\n    scenario: 'Production frontend calling production API',\n    frontend: 'https://myapp.com',\n    backend: 'https://api.myapp.com',\n    needsCORS: true,\n    solution: 'app.use(\"*\", cors({ origin: \"https://myapp.com\" }))'\n  },\n  {\n    scenario: 'React and API on same domain (proxy)',\n    frontend: 'https://myapp.com',\n    backend: 'https://myapp.com/api',\n    needsCORS: false,\n    solution: 'No CORS needed - same origin!'\n  }\n];\n\nscenarios.forEach((s, i) => {\n  console.log(`Scenario ${i + 1}: ${s.scenario}`);\n  console.log(`  Frontend: ${s.frontend}`);\n  console.log(`  Backend:  ${s.backend}`);\n  console.log(`  CORS needed? ${s.needsCORS ? 'YES' : 'NO'}`);\n  console.log(`  Solution: ${s.solution}\\n`);\n});\n\n// Debugging CORS\nconsole.log('=== Debugging CORS Errors ===\\n');\nlet debugSteps = [\n  '1. Check if both frontend and backend are running',\n  '2. Verify the URLs match (no typos)',\n  '3. Check backend has app.use(\"*\", cors()) BEFORE routes',\n  '4. Look in browser Network tab -> Response headers',\n  '5. Should see: Access-Control-Allow-Origin header',\n  '6. Try curl or Postman (they bypass CORS) to test API',\n  '7. Clear browser cache and restart dev servers'\n];\n\ndebugSteps.forEach(step => console.log(step));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "CORS configuration in Hono explained:\n\n1. **No extra package needed!** Hono has built-in CORS:\n   ```javascript\n   import { Hono } from 'hono';\n   import { cors } from 'hono/cors';  // Built-in!\n   ```\n\n2. **Basic CORS (allows all origins)**:\n   ```javascript\n   const app = new Hono();\n   app.use('*', cors());  // Must be BEFORE routes!\n   ```\n\n3. **Specific origin only** (recommended for production):\n   ```javascript\n   app.use('*', cors({\n     origin: 'https://myapp.com'\n   }));\n   ```\n\n4. **Multiple origins**:\n   ```javascript\n   const allowedOrigins = [\n     'http://localhost:3000',\n     'https://myapp.com'\n   ];\n   \n   app.use('*', cors({\n     origin: (origin) => {\n       if (allowedOrigins.includes(origin)) {\n         return origin;\n       }\n       return null;  // Deny\n     }\n   }));\n   ```\n\n5. **With credentials** (cookies, auth headers):\n   ```javascript\n   app.use('*', cors({\n     origin: 'http://localhost:3000',\n     credentials: true  // Allow cookies\n   }));\n   \n   // Frontend must also set:\n   fetch('http://localhost:4000/api/users', {\n     credentials: 'include'  // Send cookies\n   });\n   ```\n\n6. **Environment-based CORS**:\n   ```javascript\n   app.use('*', cors({\n     origin: process.env.NODE_ENV === 'production'\n       ? 'https://myapp.com'\n       : 'http://localhost:3000'\n   }));\n   ```\n\n7. **Preflight requests** (OPTIONS):\n   - Browser sends OPTIONS request first for PUT/DELETE/custom headers\n   - Hono CORS middleware handles this automatically\n   ```javascript\n   // This happens automatically with app.use('*', cors())\n   // No extra code needed!\n   ```\n\n8. **Manual CORS headers** (if not using middleware):\n   ```javascript\n   app.use('*', async (c, next) => {\n     c.header('Access-Control-Allow-Origin', '*');\n     c.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n     c.header('Access-Control-Allow-Headers', 'Content-Type');\n     await next();\n   });\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common CORS mistakes:\n\n1. **CORS middleware placed AFTER routes**:\n   ```javascript\n   // WRONG!\n   app.get('/api/users', (c) => { ... });\n   app.use('*', cors());  // Too late! Routes already defined\n   \n   // CORRECT!\n   app.use('*', cors());  // BEFORE routes!\n   app.get('/api/users', (c) => { ... });\n   ```\n\n2. **With Hono, CORS is built-in** - no package to install:\n   ```javascript\n   // Hono - built-in!\n   import { cors } from 'hono/cors';\n   ```\n\n3. **Using wrong origin in production**:\n   ```javascript\n   // WRONG in production!\n   app.use('*', cors({ origin: 'http://localhost:3000' }));\n   \n   // CORRECT - use environment variable\n   app.use('*', cors({ \n     origin: process.env.FRONTEND_URL  // https://myapp.com\n   }));\n   ```\n\n4. **Allowing all origins in production** (security risk!):\n   ```javascript\n   // WRONG in production!\n   app.use('*', cors());  // Any site can call your API!\n   \n   // CORRECT - be specific\n   app.use('*', cors({ origin: 'https://myapp.com' }));\n   ```\n\n5. **Credentials without specific origin**:\n   ```javascript\n   // WRONG!\n   app.use('*', cors({\n     origin: '*',\n     credentials: true  // Error! Can't use * with credentials\n   }));\n   \n   // CORRECT!\n   app.use('*', cors({\n     origin: 'http://localhost:3000',  // Specific origin required\n     credentials: true\n   }));\n   ```\n\n6. **Frontend not sending credentials**:\n   ```javascript\n   // Backend allows credentials\n   app.use('*', cors({ origin: '...', credentials: true }));\n   \n   // But frontend doesn't send them (cookies won't work!)\n   fetch('/api/users');  // WRONG!\n   \n   // CORRECT!\n   fetch('/api/users', { credentials: 'include' });\n   ```\n\n7. **Testing with curl/Postman and thinking CORS works**:\n   - curl and Postman BYPASS CORS (they're not browsers)\n   - Must test in actual browser!\n   ```bash\n   # This works even without CORS (not a browser!)\n   curl http://localhost:4000/api/users\n   \n   # But browser will still block it\n   ```\n\n8. **Different protocols (http vs https)**:\n   ```javascript\n   // Frontend: https://myapp.com\n   // Backend:  http://api.myapp.com\n   // DIFFERENT protocols -> CORS error!\n   \n   // Both must be https in production\n   ```"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Express CORS Equivalent",
              "legacy": "express",
              "content": "Express requires installing a separate cors package. If you encounter older codebases, here's how Express CORS differs from Hono.",
              "code": "// Express CORS (requires npm install cors)\nimport express from 'express';\nimport cors from 'cors';  // Separate package!\n\nconst app = express();\n\n// Basic CORS\napp.use(cors());\n\n// With options\napp.use(cors({\n  origin: 'https://myapp.com',\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE']  // Note: 'methods' not 'allowMethods'\n}));\n\n// Multiple origins (callback style)\napp.use(cors({\n  origin: function(origin, callback) {\n    if (allowedOrigins.includes(origin)) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  }\n}));",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13.2-challenge",
              "title": "Practice Challenge",
              "description": "Simulate CORS checking:\n\n1. Create a `browser` object with method `checkCORS(frontendOrigin, backendOrigin)` that:\n   - Compares the two origins\n   - Returns true if same origin (protocol + domain + port match)\n   - Returns false if different origins\n\n2. Create a `backend` object with:\n   - `corsEnabled` property (boolean)\n   - `allowedOrigins` array\n   - `handleRequest(origin)` method that:\n     - If corsEnabled is false → returns 'CORS Error: Blocked!'\n     - If origin is in allowedOrigins → returns 'Request allowed'\n     - Otherwise → returns 'CORS Error: Origin not allowed'\n\n3. Test various scenarios",
              "instructions": "Simulate CORS checking:\n\n1. Create a `browser` object with method `checkCORS(frontendOrigin, backendOrigin)` that:\n   - Compares the two origins\n   - Returns true if same origin (protocol + domain + port match)\n   - Returns false if different origins\n\n2. Create a `backend` object with:\n   - `corsEnabled` property (boolean)\n   - `allowedOrigins` array\n   - `handleRequest(origin)` method that:\n     - If corsEnabled is false → returns 'CORS Error: Blocked!'\n     - If origin is in allowedOrigins → returns 'Request allowed'\n     - Otherwise → returns 'CORS Error: Origin not allowed'\n\n3. Test various scenarios",
              "starterCode": "// CORS Simulation\n\nfunction parseOrigin(url) {\n  // Extract protocol, domain, port\n  let match = url.match(/(https?):\\/\\/([^:\\/]+)(?::(\\d+))?/);\n  return {\n    protocol: match[1],\n    domain: match[2],\n    port: match[3] || (match[1] === 'https' ? '443' : '80')\n  };\n}\n\nlet browser = {\n  checkCORS(frontendOrigin, backendOrigin) {\n    let f = parseOrigin(frontendOrigin);\n    let b = parseOrigin(backendOrigin);\n    \n    let sameOrigin = f.protocol === b.protocol &&\n                     f.domain === b.domain &&\n                     f.port === b.port;\n    \n    return sameOrigin;\n  }\n};\n\nlet backend = {\n  corsEnabled: true,\n  allowedOrigins: ['http://localhost:3000', 'https://myapp.com'],\n  \n  handleRequest(origin) {\n    if (!this.corsEnabled) {\n      return 'CORS Error: Blocked!';\n    }\n    \n    if (this.allowedOrigins.includes(origin)) {\n      return 'Request allowed';\n    }\n    \n    return 'CORS Error: Origin not allowed';\n  }\n};\n\n// Test scenarios\nconsole.log('=== CORS Tests ===\\n');\n\nlet tests = [\n  ['http://localhost:3000', 'http://localhost:4000'],\n  ['http://localhost:3000', 'http://localhost:3000'],\n  ['https://myapp.com', 'https://api.myapp.com']\n];\n\ntests.forEach(([frontend, api]) => {\n  console.log(`Frontend: ${frontend}`);\n  console.log(`Backend:  ${api}`);\n  console.log(`Same origin? ${browser.checkCORS(frontend, api)}`);\n  console.log(`Backend says: ${backend.handleRequest(frontend)}\\n`);\n});",
              "solution": "// Complete CORS simulation\n\nfunction parseOrigin(url) {\n  let match = url.match(/(https?):\\/\\/([^:\\/]+)(?::(\\d+))?/);\n  return {\n    protocol: match[1],\n    domain: match[2],\n    port: match[3] || (match[1] === 'https' ? '443' : '80'),\n    full: `${match[1]}://${match[2]}:${match[3] || (match[1] === 'https' ? '443' : '80')}`\n  };\n}\n\nlet browser = {\n  checkCORS(frontendOrigin, backendOrigin) {\n    let f = parseOrigin(frontendOrigin);\n    let b = parseOrigin(backendOrigin);\n    \n    let sameOrigin = f.protocol === b.protocol &&\n                     f.domain === b.domain &&\n                     f.port === b.port;\n    \n    console.log(`[Browser] Checking origins...`);\n    console.log(`  Frontend: ${f.protocol}://${f.domain}:${f.port}`);\n    console.log(`  Backend:  ${b.protocol}://${b.domain}:${b.port}`);\n    console.log(`  Same origin? ${sameOrigin}`);\n    \n    return sameOrigin;\n  },\n  \n  makeRequest(frontendOrigin, backendOrigin, backendObj) {\n    let sameOrigin = this.checkCORS(frontendOrigin, backendOrigin);\n    \n    if (sameOrigin) {\n      console.log('[Browser] Same origin - request allowed!\\n');\n      return { allowed: true, reason: 'Same origin' };\n    }\n    \n    console.log('[Browser] Different origin - checking CORS headers...');\n    let result = backendObj.handleRequest(frontendOrigin);\n    console.log(`[Browser] ${result}\\n`);\n    \n    return { allowed: result.includes('allowed'), reason: result };\n  }\n};\n\nlet backend = {\n  corsEnabled: true,\n  allowedOrigins: ['http://localhost:3000', 'https://myapp.com'],\n  allowCredentials: false,\n  \n  handleRequest(origin) {\n    console.log(`[Backend] Received request from: ${origin}`);\n    \n    if (!this.corsEnabled) {\n      console.log('[Backend] CORS is disabled - blocking all cross-origin requests');\n      return 'CORS Error: No Access-Control-Allow-Origin header';\n    }\n    \n    if (this.allowedOrigins.includes('*')) {\n      console.log('[Backend] CORS allows all origins (*)');  \n      return 'Request allowed (all origins)';\n    }\n    \n    if (this.allowedOrigins.includes(origin)) {\n      console.log(`[Backend] Origin ${origin} is in allowed list`);\n      console.log('[Backend] Adding header: Access-Control-Allow-Origin:', origin);\n      return 'Request allowed';\n    }\n    \n    console.log(`[Backend] Origin ${origin} is NOT in allowed list`);\n    console.log('[Backend] Blocking request');\n    return 'CORS Error: Origin not allowed';\n  },\n  \n  enableCORS(options = {}) {\n    this.corsEnabled = true;\n    if (options.origins) {\n      this.allowedOrigins = options.origins;\n    }\n    if (options.credentials) {\n      this.allowCredentials = options.credentials;\n    }\n    console.log('[Backend] CORS configured:', {\n      enabled: this.corsEnabled,\n      allowedOrigins: this.allowedOrigins,\n      credentials: this.allowCredentials\n    });\n  }\n};\n\n// Simulate different scenarios\nconsole.log('=== Scenario 1: React dev → Express API (CORS enabled) ===\\n');\nbackend.enableCORS({ origins: ['http://localhost:3000'] });\nbrowser.makeRequest('http://localhost:3000', 'http://localhost:4000', backend);\n\nconsole.log('=== Scenario 2: Same origin (no CORS needed) ===\\n');\nbrowser.makeRequest('http://localhost:3000', 'http://localhost:3000', backend);\n\nconsole.log('=== Scenario 3: Unauthorized origin (CORS blocks) ===\\n');\nbrowser.makeRequest('http://evil-site.com', 'http://localhost:4000', backend);\n\nconsole.log('=== Scenario 4: CORS disabled (everything blocked) ===\\n');\nbackend.corsEnabled = false;\nbrowser.makeRequest('http://localhost:3000', 'http://localhost:4000', backend);\n\nconsole.log('=== Scenario 5: Allow all origins (*) ===\\n');\nbackend.enableCORS({ origins: ['*'] });\nbrowser.makeRequest('http://any-site.com', 'http://localhost:4000', backend);\n\n// Summary\nconsole.log('\\n=== CORS Summary ===\\n');\nconsole.log('✓ Same origin = No CORS needed');\nconsole.log('✓ Different origin + CORS enabled + origin in list = Allowed');\nconsole.log('✗ Different origin + CORS disabled = Blocked');\nconsole.log('✗ Different origin + origin not in list = Blocked');\nconsole.log('\\n💡 Fix: Add app.use(cors()) to your Express backend!');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should detect same origin",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should detect different ports",
                  "expectedOutput": "false",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Origins are same if protocol, domain, AND port all match"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common CORS mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common CORS mistakes:"
                },
                {
                  "mistake": "**CORS middleware placed AFTER routes**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**CORS middleware placed AFTER routes**:\n   ```javascript\n   // WRONG!\n   app.get('/api/users', (req, res) => { ... });\n   app.use(cors());  // Too late! Routes already defined\n   \n   // CORRECT!\n   app.use(cors());  // BEFORE routes!\n   app.get('/api/users', (req, res) => { ... });\n   ```"
                },
                {
                  "mistake": "**Forgot to install cors package**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgot to install cors package**:\n   ```bash\n   # Error: Cannot find module 'cors'\n   npm install cors\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "13.3",
          "title": "Fetching Data with useEffect (The Automated Assistant Analogy)",
          "moduleId": "module-13",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine hiring an assistant for your office:\n\nManual Way (without useEffect):\n- Every morning YOU must remember to check the mailbox\n- YOU must remember to water the plants\n- YOU might forget → tasks don't get done\n\nAutomated Way (with useEffect):\n- Tell assistant: \"When you arrive (component mounts), check mail\"\n- Tell assistant: \"Every hour (dependency changes), water plants\"\n- Tell assistant: \"When you leave (component unmounts), lock doors\"\n- Assistant does these automatically → you don't have to remember!\n\nReact useEffect is your automated assistant:\n- Runs code automatically when component mounts\n- Runs code when specific values change\n- Cleanup when component unmounts\n- Perfect for fetching data from APIs!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// useEffect + fetch - Getting data from APIs\n\nconsole.log('=== useEffect for Data Fetching ===\\n');\n\n// Simulate React component lifecycle\nclass ComponentLifecycle {\n  constructor(name) {\n    this.name = name;\n    this.effects = [];\n    this.state = {};\n  }\n  \n  // Simulate useEffect\n  useEffect(callback, dependencies) {\n    console.log(`[${this.name}] Registering effect with dependencies:`, dependencies || 'none');\n    this.effects.push({ callback, dependencies });\n  }\n  \n  // Simulate component mount\n  mount() {\n    console.log(`\\n[${this.name}] Component mounting...`);\n    this.effects.forEach(effect => {\n      if (!effect.dependencies || effect.dependencies.length === 0) {\n        console.log(`[${this.name}] Running effect (runs on mount)`);\n        effect.callback();\n      }\n    });\n  }\n  \n  // Simulate state update\n  setState(newState) {\n    console.log(`\\n[${this.name}] State updating:`, newState);\n    let oldState = { ...this.state };\n    this.state = { ...this.state, ...newState };\n    \n    this.effects.forEach(effect => {\n      if (effect.dependencies) {\n        let changed = effect.dependencies.some(dep => {\n          return oldState[dep] !== this.state[dep];\n        });\n        if (changed) {\n          console.log(`[${this.name}] Dependency changed, re-running effect`);\n          effect.callback();\n        }\n      }\n    });\n  }\n}\n\n// Example 1: Fetch data on component mount\nconsole.log('=== Example 1: Fetch Users on Mount ===');\n\nlet UserList = new ComponentLifecycle('UserList');\n\nUserList.useEffect(() => {\n  console.log('[UserList] Fetching users from API...');\n  console.log('[UserList] fetch(\"http://localhost:4000/api/users\")');\n  \n  // Simulate API response\n  setTimeout(() => {\n    let users = [\n      { id: 1, name: 'Alice' },\n      { id: 2, name: 'Bob' }\n    ];\n    console.log('[UserList] Received:', users.length, 'users');\n    console.log('[UserList] setUsers(data) → triggers re-render');\n  }, 100);\n}, []); // Empty array = run once on mount\n\nUserList.mount();\n\n// Example 2: Fetch when dependency changes\nsetTimeout(() => {\n  console.log('\\n\\n=== Example 2: Fetch User Details When ID Changes ===');\n  \n  let UserProfile = new ComponentLifecycle('UserProfile');\n  UserProfile.state = { userId: null };\n  \n  UserProfile.useEffect(() => {\n    if (UserProfile.state.userId) {\n      console.log(`[UserProfile] Fetching user ${UserProfile.state.userId}...`);\n      console.log(`[UserProfile] fetch(\"http://localhost:4000/api/users/${UserProfile.state.userId}\")`);\n      \n      setTimeout(() => {\n        let user = { id: UserProfile.state.userId, name: 'Alice', email: 'alice@example.com' };\n        console.log('[UserProfile] Received:', user);\n      }, 100);\n    }\n  }, ['userId']); // Re-run when userId changes\n  \n  UserProfile.mount();\n  \n  // Simulate user clicking different profiles\n  setTimeout(() => {\n    console.log('\\n[User] Clicks on user 1');\n    UserProfile.setState({ userId: 1 });\n  }, 200);\n  \n  setTimeout(() => {\n    console.log('\\n[User] Clicks on user 2');\n    UserProfile.setState({ userId: 2 });\n  }, 400);\n}, 300);\n\n// Example 3: Real fetch pattern\nsetTimeout(() => {\n  console.log('\\n\\n=== Example 3: Complete Fetch Pattern ===\\n');\n  \n  console.log('// React component with useEffect\\n');\n  console.log('function UserList() {');\n  console.log('  const [users, setUsers] = useState([]);');\n  console.log('  const [loading, setLoading] = useState(true);');\n  console.log('  const [error, setError] = useState(null);\\n');\n  \n  console.log('  useEffect(() => {');\n  console.log('    async function fetchUsers() {');\n  console.log('      try {');\n  console.log('        setLoading(true);');\n  console.log('        const response = await fetch(\"http://localhost:4000/api/users\");');\n  console.log('        ');\n  console.log('        if (!response.ok) {');\n  console.log('          throw new Error(`HTTP error! status: ${response.status}`);');\n  console.log('        }');\n  console.log('        ');\n  console.log('        const data = await response.json();');\n  console.log('        setUsers(data);');\n  console.log('      } catch (err) {');\n  console.log('        setError(err.message);');\n  console.log('      } finally {');\n  console.log('        setLoading(false);');\n  console.log('      }');\n  console.log('    }\\n');\n  console.log('    fetchUsers();');\n  console.log('  }, []); // Run once on mount\\n');\n  \n  console.log('  if (loading) return <div>Loading...</div>;');\n  console.log('  if (error) return <div>Error: {error}</div>;');\n  \n  console.log('  return (');\n  console.log('    <ul>');\n  console.log('      {users.map(user => (');\n  console.log('        <li key={user.id}>{user.name}</li>');\n  console.log('      ))}');\n  console.log('    </ul>');\n  console.log('  );');\n  console.log('}');\n}, 800);\n\n// Dependency array explanation\nsetTimeout(() => {\n  console.log('\\n\\n=== useEffect Dependency Array ===\\n');\n  \n  let cases = [\n    {\n      code: 'useEffect(() => { ... });',\n      dependencies: 'NONE',\n      when: 'Every render (usually a mistake!)'\n    },\n    {\n      code: 'useEffect(() => { ... }, []);',\n      dependencies: '[] (empty)',\n      when: 'Once on mount only'\n    },\n    {\n      code: 'useEffect(() => { ... }, [userId]);',\n      dependencies: '[userId]',\n      when: 'On mount + whenever userId changes'\n    },\n    {\n      code: 'useEffect(() => { ... }, [userId, page]);',\n      dependencies: '[userId, page]',\n      when: 'On mount + when userId OR page changes'\n    }\n  ];\n  \n  cases.forEach(c => {\n    console.log(`${c.code}`);\n    console.log(`  Dependencies: ${c.dependencies}`);\n    console.log(`  Runs: ${c.when}\\n`);\n  });\n}, 1100);"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "useEffect with fetch explained:\n\n1. **Basic useEffect with fetch**:\n   ```jsx\n   import { useEffect, useState } from 'react';\n   \n   function UserList() {\n     const [users, setUsers] = useState([]);\n     \n     useEffect(() => {\n       fetch('http://localhost:4000/api/users')\n         .then(res => res.json())\n         .then(data => setUsers(data));\n     }, []); // Empty array = run once on mount\n     \n     return <div>{users.map(u => <div key={u.id}>{u.name}</div>)}</div>;\n   }\n   ```\n\n2. **With async/await** (recommended):\n   ```jsx\n   useEffect(() => {\n     async function fetchUsers() {\n       const response = await fetch('http://localhost:4000/api/users');\n       const data = await response.json();\n       setUsers(data);\n     }\n     \n     fetchUsers();\n   }, []);\n   ```\n\n3. **With loading and error states** (best practice):\n   ```jsx\n   const [users, setUsers] = useState([]);\n   const [loading, setLoading] = useState(true);\n   const [error, setError] = useState(null);\n   \n   useEffect(() => {\n     async function fetchUsers() {\n       try {\n         setLoading(true);\n         const res = await fetch('http://localhost:4000/api/users');\n         \n         if (!res.ok) {\n           throw new Error(`HTTP ${res.status}`);\n         }\n         \n         const data = await res.json();\n         setUsers(data);\n       } catch (err) {\n         setError(err.message);\n       } finally {\n         setLoading(false);\n       }\n     }\n     \n     fetchUsers();\n   }, []);\n   \n   if (loading) return <div>Loading...</div>;\n   if (error) return <div>Error: {error}</div>;\n   return <div>...</div>;\n   ```\n\n4. **Dependency array - fetch when value changes**:\n   ```jsx\n   const [userId, setUserId] = useState(1);\n   const [user, setUser] = useState(null);\n   \n   useEffect(() => {\n     fetch(`http://localhost:4000/api/users/${userId}`)\n       .then(res => res.json())\n       .then(data => setUser(data));\n   }, [userId]); // Re-fetch when userId changes\n   ```\n\n5. **Cleanup function** (abort requests):\n   ```jsx\n   useEffect(() => {\n     const controller = new AbortController();\n     \n     fetch('http://localhost:4000/api/users', {\n       signal: controller.signal\n     })\n       .then(res => res.json())\n       .then(data => setUsers(data))\n       .catch(err => {\n         if (err.name !== 'AbortError') {\n           setError(err.message);\n         }\n       });\n     \n     // Cleanup: abort fetch if component unmounts\n     return () => controller.abort();\n   }, []);\n   ```\n\n6. **POST request in useEffect**:\n   ```jsx\n   useEffect(() => {\n     async function createUser() {\n       const res = await fetch('http://localhost:4000/api/users', {\n         method: 'POST',\n         headers: { 'Content-Type': 'application/json' },\n         body: JSON.stringify({ name: 'Alice', email: 'alice@example.com' })\n       });\n       const newUser = await res.json();\n       console.log('Created:', newUser);\n     }\n     \n     createUser();\n   }, []);\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common useEffect + fetch mistakes:\n\n1. **Forgetting dependency array**:\n   ```jsx\n   // WRONG! Infinite loop!\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data)); // State update triggers re-render\n   }); // No dependency array → runs every render → infinite loop!\n   \n   // CORRECT!\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data));\n   }, []); // Empty array → run once\n   ```\n\n2. **Using async directly in useEffect**:\n   ```jsx\n   // WRONG!\n   useEffect(async () => {  // ← Can't do this!\n     const res = await fetch('/api/users');\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     async function fetchData() {  // Define async function inside\n       const res = await fetch('/api/users');\n     }\n     fetchData();  // Call it\n   }, []);\n   ```\n\n3. **Not handling loading/error states**:\n   ```jsx\n   // WRONG! (bad UX)\n   const [users, setUsers] = useState([]);\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data));\n   }, []);\n   return <div>{users.map(...)}</div>; // Empty while loading!\n   \n   // CORRECT!\n   const [users, setUsers] = useState([]);\n   const [loading, setLoading] = useState(true);\n   \n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => {\n         setUsers(data);\n         setLoading(false);\n       });\n   }, []);\n   \n   if (loading) return <div>Loading...</div>;\n   return <div>{users.map(...)}</div>;\n   ```\n\n4. **Not checking response.ok**:\n   ```jsx\n   // WRONG! (doesn't catch HTTP errors)\n   const res = await fetch('/api/users');\n   const data = await res.json(); // Fails if 404/500!\n   \n   // CORRECT!\n   const res = await fetch('/api/users');\n   if (!res.ok) {\n     throw new Error(`HTTP ${res.status}: ${res.statusText}`);\n   }\n   const data = await res.json();\n   ```\n\n5. **Missing cleanup (memory leaks)**:\n   ```jsx\n   // WRONG! (can cause \"Can't perform state update on unmounted component\")\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data)); // Component might unmount before this!\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     let cancelled = false;\n     \n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => {\n         if (!cancelled) {  // Only update if still mounted\n           setUsers(data);\n         }\n       });\n     \n     return () => {\n       cancelled = true;  // Cleanup\n     };\n   }, []);\n   ```\n\n6. **Wrong dependencies**:\n   ```jsx\n   function UserProfile({ userId }) {\n     const [user, setUser] = useState(null);\n     \n     // WRONG! (doesn't re-fetch when userId changes)\n     useEffect(() => {\n       fetch(`/api/users/${userId}`)\n         .then(res => res.json())\n         .then(data => setUser(data));\n     }, []); // Should include userId!\n     \n     // CORRECT!\n     useEffect(() => {\n       fetch(`/api/users/${userId}`)\n         .then(res => res.json())\n         .then(data => setUser(data));\n     }, [userId]); // Re-fetch when userId changes\n   }\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13.3-challenge",
              "title": "Practice Challenge",
              "description": "Build a complete data fetching flow:\n\n1. Create a `fetchUsers()` function that:\n   - Returns a Promise\n   - Simulates 1 second delay\n   - Resolves with array of mock users\n\n2. Create a `UserListComponent` object that:\n   - Has `state` with: users (array), loading (boolean), error (string|null)\n   - Has `mount()` method that simulates useEffect running\n   - In mount: sets loading true, calls fetchUsers, updates state\n\n3. Test by calling mount() and logging state changes",
              "instructions": "Build a complete data fetching flow:\n\n1. Create a `fetchUsers()` function that:\n   - Returns a Promise\n   - Simulates 1 second delay\n   - Resolves with array of mock users\n\n2. Create a `UserListComponent` object that:\n   - Has `state` with: users (array), loading (boolean), error (string|null)\n   - Has `mount()` method that simulates useEffect running\n   - In mount: sets loading true, calls fetchUsers, updates state\n\n3. Test by calling mount() and logging state changes",
              "starterCode": "// Simulate API\nfunction fetchUsers() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve([\n        { id: 1, name: 'Alice', email: 'alice@example.com' },\n        { id: 2, name: 'Bob', email: 'bob@example.com' },\n        { id: 3, name: 'Charlie', email: 'charlie@example.com' }\n      ]);\n    }, 1000);\n  });\n}\n\n// Simulate React component\nlet UserListComponent = {\n  state: {\n    users: [],\n    loading: false,\n    error: null\n  },\n  \n  setState(updates) {\n    this.state = { ...this.state, ...updates };\n    console.log('[State Updated]', this.state);\n  },\n  \n  async mount() {\n    console.log('[Component] Mounting...');\n    console.log('[useEffect] Running effect (fetch users)');\n    \n    this.setState({ loading: true });\n    \n    try {\n      console.log('[Fetch] Calling API...');\n      let users = await fetchUsers();\n      console.log('[Fetch] Received', users.length, 'users');\n      this.setState({ users, loading: false });\n    } catch (err) {\n      console.log('[Fetch] Error:', err.message);\n      this.setState({ error: err.message, loading: false });\n    }\n  }\n};\n\n// Test\nconsole.log('=== UserList Component ===\\n');\nUserListComponent.mount();",
              "solution": "// Complete data fetching simulation\n\n// Mock API with various endpoints\nlet mockAPI = {\n  users: [\n    { id: 1, name: 'Alice', email: 'alice@example.com', role: 'Admin' },\n    { id: 2, name: 'Bob', email: 'bob@example.com', role: 'User' },\n    { id: 3, name: 'Charlie', email: 'charlie@example.com', role: 'User' }\n  ],\n  \n  fetchUsers(delay = 1000) {\n    console.log(`[API] GET /api/users (simulating ${delay}ms network delay)`);\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        console.log('[API] Responding with', this.users.length, 'users');\n        resolve([...this.users]);\n      }, delay);\n    });\n  },\n  \n  fetchUserById(id, delay = 800) {\n    console.log(`[API] GET /api/users/${id}`);\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        let user = this.users.find(u => u.id === id);\n        if (user) {\n          console.log('[API] Found user:', user.name);\n          resolve({ ...user });\n        } else {\n          console.log('[API] 404 Not Found');\n          reject(new Error('User not found'));\n        }\n      }, delay);\n    });\n  },\n  \n  createUser(userData, delay = 1000) {\n    console.log('[API] POST /api/users', userData);\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        let newUser = {\n          id: this.users.length + 1,\n          ...userData\n        };\n        this.users.push(newUser);\n        console.log('[API] Created user:', newUser);\n        resolve(newUser);\n      }, delay);\n    });\n  }\n};\n\n// Component 1: UserList (fetch all users on mount)\nlet UserListComponent = {\n  state: { users: [], loading: false, error: null },\n  \n  setState(updates) {\n    this.state = { ...this.state, ...updates };\n    console.log('[UserList State]', this.state);\n  },\n  \n  async mount() {\n    console.log('[UserList] Component mounting...');\n    console.log('[UserList] useEffect(() => { fetchUsers() }, [])');\n    \n    try {\n      this.setState({ loading: true, error: null });\n      let users = await mockAPI.fetchUsers();\n      this.setState({ users, loading: false });\n      console.log('[UserList] Render with', users.length, 'users\\n');\n    } catch (err) {\n      this.setState({ error: err.message, loading: false });\n      console.log('[UserList] Render error state\\n');\n    }\n  }\n};\n\n// Component 2: UserProfile (fetch user when ID changes)\nlet UserProfileComponent = {\n  state: { userId: null, user: null, loading: false, error: null },\n  \n  setState(updates) {\n    let oldUserId = this.state.userId;\n    this.state = { ...this.state, ...updates };\n    console.log('[UserProfile State]', this.state);\n    \n    // Simulate useEffect with [userId] dependency\n    if ('userId' in updates && updates.userId !== oldUserId) {\n      console.log('[UserProfile] userId changed → running effect');\n      this.fetchUser();\n    }\n  },\n  \n  async fetchUser() {\n    if (!this.state.userId) {\n      console.log('[UserProfile] No userId, skipping fetch');\n      return;\n    }\n    \n    console.log(`[UserProfile] useEffect(() => { fetchUser(${this.state.userId}) }, [userId])`);\n    \n    try {\n      this.state.loading = true;\n      this.state.error = null;\n      let user = await mockAPI.fetchUserById(this.state.userId);\n      this.state.user = user;\n      this.state.loading = false;\n      console.log('[UserProfile] Render with user:', user.name, '\\n');\n    } catch (err) {\n      this.state.error = err.message;\n      this.state.loading = false;\n      console.log('[UserProfile] Render error\\n');\n    }\n  },\n  \n  mount() {\n    console.log('[UserProfile] Component mounting...');\n    console.log('[UserProfile] useEffect registered with [userId] dependency\\n');\n  }\n};\n\n// Run simulation\nasync function runSimulation() {\n  console.log('=== Full-Stack Data Fetching Simulation ===\\n');\n  \n  // Scenario 1: Fetch all users on mount\n  console.log('--- Scenario 1: UserList Component ---\\n');\n  await UserListComponent.mount();\n  \n  // Scenario 2: Fetch specific user when ID changes\n  console.log('--- Scenario 2: UserProfile Component ---\\n');\n  UserProfileComponent.mount();\n  \n  await new Promise(resolve => setTimeout(resolve, 100));\n  console.log('[User Action] Clicks on user 1');\n  UserProfileComponent.setState({ userId: 1 });\n  \n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log('[User Action] Clicks on user 2');\n  UserProfileComponent.setState({ userId: 2 });\n  \n  // Scenario 3: Create new user\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log('\\n--- Scenario 3: Create User ---\\n');\n  let newUser = await mockAPI.createUser({ \n    name: 'Diana', \n    email: 'diana@example.com',\n    role: 'User'\n  });\n  \n  console.log('\\n--- Final State ---');\n  console.log('Total users in database:', mockAPI.users.length);\n  console.log('Users:', mockAPI.users.map(u => u.name).join(', '));\n}\n\nrunSimulation();",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should fetch and return users",
                  "expectedOutput": "Array of 3 users",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use async/await and try/catch/finally for clean error handling"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common useEffect + fetch mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common useEffect + fetch mistakes:"
                },
                {
                  "mistake": "**Forgetting dependency array**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting dependency array**:\n   ```jsx\n   // WRONG! Infinite loop!\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data)); // State update triggers re-render\n   }); // No dependency array → runs every render → infinite loop!\n   \n   // CORRECT!\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data));\n   }, []); // Empty array → run once\n   ```"
                },
                {
                  "mistake": "**Using async directly in useEffect**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Using async directly in useEffect**:\n   ```jsx\n   // WRONG!\n   useEffect(async () => {  // ← Can't do this!\n     const res = await fetch('/api/users');\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     async function fetchData() {  // Define async function inside\n       const res = await fetch('/api/users');\n     }\n     fetchData();  // Call it\n   }, []);\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "13.4",
          "title": "Complete Full-Stack Example - Todo App with React + Hono + Prisma",
          "moduleId": "module-13",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Building a full-stack app is like building a house:\n\nFoundation (Database - Prisma/PostgreSQL):\n- Permanent storage for all data\n- Structured (schema)\n- Reliable\n\nPlumbing & Electrical (Backend - Hono):\n- Hidden from view\n- Does the real work\n- Connects everything together\n\nInterior & Facade (Frontend - React):\n- What users see and interact with\n- Beautiful and intuitive\n- Makes requests to backend for functionality\n\nInspector (CORS):\n- Ensures everything is safe and connected properly\n- Allows frontend and backend to communicate\n\nA complete full-stack app needs ALL these parts working together!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Complete Full-Stack Todo App Simulation\n\nconsole.log('=== Full-Stack Todo Application ===\\n');\n\n// DATABASE LAYER (Prisma + PostgreSQL)\nlet database = {\n  todos: [\n    { id: 1, title: 'Learn React', completed: false, userId: 1 },\n    { id: 2, title: 'Build API', completed: true, userId: 1 },\n    { id: 3, title: 'Deploy app', completed: false, userId: 1 }\n  ],\n  \n  // Simulate Prisma queries\n  async findMany(filter = {}) {\n    console.log('[Database] SELECT * FROM todos WHERE userId =', filter.userId || 'ALL');\n    let results = filter.userId \n      ? this.todos.filter(t => t.userId === filter.userId)\n      : this.todos;\n    return results;\n  },\n  \n  async create(data) {\n    console.log('[Database] INSERT INTO todos', data);\n    let newTodo = {\n      id: this.todos.length + 1,\n      completed: false,\n      ...data\n    };\n    this.todos.push(newTodo);\n    return newTodo;\n  },\n  \n  async update(id, data) {\n    console.log(`[Database] UPDATE todos SET ... WHERE id = ${id}`);\n    let todo = this.todos.find(t => t.id === id);\n    if (todo) {\n      Object.assign(todo, data);\n      return todo;\n    }\n    return null;\n  },\n  \n  async delete(id) {\n    console.log(`[Database] DELETE FROM todos WHERE id = ${id}`);\n    let index = this.todos.findIndex(t => t.id === id);\n    if (index !== -1) {\n      let deleted = this.todos.splice(index, 1)[0];\n      return deleted;\n    }\n    return null;\n  }\n};\n\n// BACKEND LAYER (Hono API)\nlet backend = {\n  corsEnabled: true,\n  \n  async handleGetTodos(userId) {\n    console.log('[Backend] GET /api/todos');\n    console.log('[Backend] Checking CORS... ' + (this.corsEnabled ? 'Allowed' : 'Blocked'));\n    \n    if (!this.corsEnabled) {\n      return { status: 403, error: 'CORS error' };\n    }\n    \n    let todos = await database.findMany({ userId });\n    console.log(`[Backend] Found ${todos.length} todos`);\n    return { status: 200, data: todos };\n  },\n  \n  async handleCreateTodo(title, userId) {\n    console.log('[Backend] POST /api/todos', { title, userId });\n    \n    // Validation\n    if (!title || title.trim().length === 0) {\n      console.log('[Backend] Validation failed: title required');\n      return { status: 400, error: 'Title is required' };\n    }\n    \n    let newTodo = await database.create({ title, userId });\n    console.log('[Backend] Created todo:', newTodo.id);\n    return { status: 201, data: newTodo };\n  },\n  \n  async handleUpdateTodo(id, updates) {\n    console.log(`[Backend] PATCH /api/todos/${id}`, updates);\n    let updated = await database.update(id, updates);\n    \n    if (!updated) {\n      console.log('[Backend] Todo not found');\n      return { status: 404, error: 'Todo not found' };\n    }\n    \n    console.log('[Backend] Updated todo:', updated);\n    return { status: 200, data: updated };\n  },\n  \n  async handleDeleteTodo(id) {\n    console.log(`[Backend] DELETE /api/todos/${id}`);\n    let deleted = await database.delete(id);\n    \n    if (!deleted) {\n      return { status: 404, error: 'Todo not found' };\n    }\n    \n    console.log('[Backend] Deleted todo');\n    return { status: 200, data: { message: 'Deleted successfully' } };\n  }\n};\n\n// FRONTEND LAYER (React Component)\nlet TodoApp = {\n  state: {\n    todos: [],\n    loading: false,\n    error: null,\n    newTodoTitle: '',\n    currentUserId: 1\n  },\n  \n  setState(updates) {\n    this.state = { ...this.state, ...updates };\n    console.log('[TodoApp State]', {\n      todos: this.state.todos.length + ' todos',\n      loading: this.state.loading,\n      error: this.state.error\n    });\n  },\n  \n  // useEffect - fetch todos on mount\n  async componentDidMount() {\n    console.log('\\n[TodoApp] Component mounted');\n    console.log('[TodoApp] useEffect(() => { fetchTodos() }, [])');\n    await this.fetchTodos();\n  },\n  \n  async fetchTodos() {\n    console.log('[TodoApp] Fetching todos from API...');\n    console.log('[TodoApp] fetch(\"http://localhost:4000/api/todos\")');\n    \n    this.setState({ loading: true, error: null });\n    \n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 300));\n    \n    let response = await backend.handleGetTodos(this.state.currentUserId);\n    \n    if (response.status === 200) {\n      this.setState({ todos: response.data, loading: false });\n      console.log('[TodoApp] Rendering', response.data.length, 'todos');\n    } else {\n      this.setState({ error: response.error, loading: false });\n    }\n  },\n  \n  async addTodo(title) {\n    console.log(`\\n[TodoApp] User types \"${title}\" and clicks Add`);\n    console.log('[TodoApp] handleAddTodo()');\n    console.log('[TodoApp] fetch(\"http://localhost:4000/api/todos\", { method: \"POST\", ... })');\n    \n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    let response = await backend.handleCreateTodo(title, this.state.currentUserId);\n    \n    if (response.status === 201) {\n      console.log('[TodoApp] Todo created! Refreshing list...');\n      await this.fetchTodos();\n    } else {\n      this.setState({ error: response.error });\n    }\n  },\n  \n  async toggleTodo(id) {\n    console.log(`\\n[TodoApp] User clicks checkbox for todo ${id}`);\n    let todo = this.state.todos.find(t => t.id === id);\n    console.log(`[TodoApp] Toggling completed: ${todo.completed} → ${!todo.completed}`);\n    console.log(`[TodoApp] fetch(\"http://localhost:4000/api/todos/${id}\", { method: \"PATCH\", ... })`);\n    \n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    let response = await backend.handleUpdateTodo(id, { completed: !todo.completed });\n    \n    if (response.status === 200) {\n      console.log('[TodoApp] Updated! Refreshing...');\n      await this.fetchTodos();\n    }\n  },\n  \n  async deleteTodo(id) {\n    console.log(`\\n[TodoApp] User clicks delete for todo ${id}`);\n    console.log(`[TodoApp] fetch(\"http://localhost:4000/api/todos/${id}\", { method: \"DELETE\" })`);\n    \n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    let response = await backend.handleDeleteTodo(id);\n    \n    if (response.status === 200) {\n      console.log('[TodoApp] Deleted! Refreshing...');\n      await this.fetchTodos();\n    }\n  }\n};\n\n// RUN SIMULATION\nasync function runFullStackSimulation() {\n  console.log('=== Simulating Full-Stack Todo App ===\\n');\n  \n  // 1. App loads\n  await TodoApp.componentDidMount();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // 2. User adds new todo\n  await TodoApp.addTodo('Master full-stack development');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // 3. User toggles todo\n  await TodoApp.toggleTodo(1);\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // 4. User deletes todo\n  await TodoApp.deleteTodo(2);\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // 5. Final state\n  console.log('\\n=== Final Application State ===');\n  console.log('\\nDatabase:');\n  database.todos.forEach(todo => {\n    console.log(`  [${todo.completed ? '✓' : ' '}] ${todo.id}. ${todo.title}`);\n  });\n  \n  console.log('\\nFrontend State:');\n  console.log('  Todos displayed:', TodoApp.state.todos.length);\n  console.log('  Loading:', TodoApp.state.loading);\n  console.log('  Error:', TodoApp.state.error || 'none');\n}\n\nrunFullStackSimulation();"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Complete full-stack implementation:\n\n**1. Database (Prisma Schema)**:\n```prisma\n// schema.prisma\nmodel Todo {\n  id        Int      @id @default(autoincrement())\n  title     String\n  completed Boolean  @default(false)\n  userId    Int\n  createdAt DateTime @default(now())\n}\n```\n\n**2. Backend (Hono + Prisma)**:\n```javascript\n// server.js\nimport { Hono } from 'hono';\nimport { cors } from 'hono/cors';\nimport { serve } from '@hono/node-server';\nimport { PrismaClient } from '@prisma/client';\n\nconst app = new Hono();\nconst prisma = new PrismaClient();\n\napp.use('*', cors());  // Enable CORS!\n\n// GET all todos\napp.get('/api/todos', async (c) => {\n  const todos = await prisma.todo.findMany({\n    where: { userId: c.get('userId') },\n    orderBy: { createdAt: 'desc' }\n  });\n  return c.json(todos);\n});\n\n// POST new todo\napp.post('/api/todos', async (c) => {\n  const { title } = await c.req.json();\n  \n  if (!title) {\n    return c.json({ error: 'Title required' }, 400);\n  }\n  \n  const todo = await prisma.todo.create({\n    data: { title, userId: c.get('userId') }\n  });\n  \n  return c.json(todo, 201);\n});\n\n// PATCH update todo\napp.patch('/api/todos/:id', async (c) => {\n  const id = parseInt(c.req.param('id'));\n  const { completed, title } = await c.req.json();\n  \n  const todo = await prisma.todo.update({\n    where: { id },\n    data: { completed, title }\n  });\n  \n  return c.json(todo);\n});\n\n// DELETE todo\napp.delete('/api/todos/:id', async (c) => {\n  const id = parseInt(c.req.param('id'));\n  \n  await prisma.todo.delete({\n    where: { id }\n  });\n  \n  return c.json({ message: 'Deleted' });\n});\n\nserve(app, (info) => {\n  console.log(`API running on http://localhost:${info.port}`);\n});\n```\n\n**3. Frontend (React)**:\n```jsx\n// TodoApp.jsx\nimport { useState, useEffect } from 'react';\n\nconst API_URL = 'http://localhost:3000';\n\nfunction TodoApp() {\n  const [todos, setTodos] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [newTitle, setNewTitle] = useState('');\n  \n  // Fetch todos on mount\n  useEffect(() => {\n    fetchTodos();\n  }, []);\n  \n  async function fetchTodos() {\n    const res = await fetch(`${API_URL}/api/todos`);\n    const data = await res.json();\n    setTodos(data);\n    setLoading(false);\n  }\n  \n  async function addTodo(e) {\n    e.preventDefault();\n    \n    await fetch(`${API_URL}/api/todos`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ title: newTitle })\n    });\n    \n    setNewTitle('');\n    fetchTodos();\n  }\n  \n  async function toggleTodo(id, completed) {\n    await fetch(`${API_URL}/api/todos/${id}`, {\n      method: 'PATCH',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ completed: !completed })\n    });\n    \n    fetchTodos();\n  }\n  \n  async function deleteTodo(id) {\n    await fetch(`${API_URL}/api/todos/${id}`, {\n      method: 'DELETE'\n    });\n    \n    fetchTodos();\n  }\n  \n  if (loading) return <div>Loading...</div>;\n  \n  return (\n    <div>\n      <h1>My Todos</h1>\n      \n      <form onSubmit={addTodo}>\n        <input\n          value={newTitle}\n          onChange={(e) => setNewTitle(e.target.value)}\n          placeholder=\"New todo...\"\n        />\n        <button type=\"submit\">Add</button>\n      </form>\n      \n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id}>\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => toggleTodo(todo.id, todo.completed)}\n            />\n            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n              {todo.title}\n            </span>\n            <button onClick={() => deleteTodo(todo.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common full-stack integration mistakes:\n\n1. **Forgetting to enable CORS**:\n   ```javascript\n   // Hono backend missing:\n   app.use('*', cors());  // Add this!\n   ```\n\n2. **Wrong API URL**:\n   ```jsx\n   // Wrong!\n   fetch('localhost:4000/api/todos')  // Missing http://\n   \n   // Correct!\n   fetch('http://localhost:4000/api/todos')\n   \n   // Best!\n   const API_URL = import.meta.env.VITE_API_URL;\n   fetch(`${API_URL}/api/todos`);\n   ```\n\n3. **Not refreshing data after mutations**:\n   ```jsx\n   // Wrong! (UI doesn't update)\n   async function addTodo() {\n     await fetch('/api/todos', { method: 'POST', ... });\n     // Forgot to refresh!\n   }\n   \n   // Correct!\n   async function addTodo() {\n     await fetch('/api/todos', { method: 'POST', ... });\n     fetchTodos();  // Refresh the list!\n   }\n   ```\n\n4. **Not validating on backend (Hono)**:\n   ```javascript\n   // NEVER trust frontend data!\n   app.post('/api/todos', async (c) => {\n     const { title } = await c.req.json();\n     \n     // Validate!\n     if (!title || title.trim().length === 0) {\n       return c.json({ error: 'Title required' }, 400);\n     }\n     \n     // Now safe to create\n     const todo = await prisma.todo.create({ data: { title } });\n     return c.json(todo);\n   });\n   ```\n\n5. **Hardcoded user IDs** (security issue!):\n   ```javascript\n   // Wrong! (any user can access any todo)\n   app.get('/api/todos', async (c) => {\n     const todos = await prisma.todo.findMany();\n     return c.json(todos);\n   });\n   \n   // Correct! (filter by authenticated user)\n   app.get('/api/todos', async (c) => {\n     const todos = await prisma.todo.findMany({\n       where: { userId: c.get('userId') }  // From auth middleware\n     });\n     return c.json(todos);\n   });\n   ```"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Express Backend Equivalent",
              "legacy": "express",
              "content": "If you encounter older codebases using Express, here's the same Todo API. The main differences are: Express uses (req, res) instead of (c), res.json() instead of return c.json(), and requires a separate cors package.",
              "code": "// Express + Prisma Todo API\nimport express from 'express';\nimport cors from 'cors';  // Separate package!\nimport { PrismaClient } from '@prisma/client';\n\nconst app = express();\nconst prisma = new PrismaClient();\n\napp.use(cors());\napp.use(express.json());  // Required for req.body!\n\n// GET all todos\napp.get('/api/todos', async (req, res) => {\n  const todos = await prisma.todo.findMany({\n    where: { userId: req.user.id },\n    orderBy: { createdAt: 'desc' }\n  });\n  res.json(todos);\n});\n\n// POST new todo\napp.post('/api/todos', async (req, res) => {\n  const { title } = req.body;\n  \n  if (!title) {\n    return res.status(400).json({ error: 'Title required' });\n  }\n  \n  const todo = await prisma.todo.create({\n    data: { title, userId: req.user.id }\n  });\n  \n  res.status(201).json(todo);\n});\n\n// PATCH update todo\napp.patch('/api/todos/:id', async (req, res) => {\n  const { id } = req.params;\n  const { completed, title } = req.body;\n  \n  const todo = await prisma.todo.update({\n    where: { id: parseInt(id) },\n    data: { completed, title }\n  });\n  \n  res.json(todo);\n});\n\n// DELETE todo\napp.delete('/api/todos/:id', async (req, res) => {\n  const { id } = req.params;\n  \n  await prisma.todo.delete({\n    where: { id: parseInt(id) }\n  });\n  \n  res.json({ message: 'Deleted' });\n});\n\napp.listen(4000, () => {\n  console.log('API running on http://localhost:4000');\n});",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13.4-challenge",
              "title": "Practice Challenge",
              "description": "Build a simplified full-stack blog:\n\n1. Create a `database` object with:\n   - posts array with sample posts (id, title, content)\n   - findAll() method\n   - create(data) method\n\n2. Create a `backend` object with:\n   - handleGetPosts() - returns all posts\n   - handleCreatePost(title, content) - creates post\n\n3. Create a `BlogApp` object with:\n   - state: posts, loading\n   - fetchPosts() - calls backend\n   - createPost(title, content) - calls backend and refreshes\n\n4. Test the flow",
              "instructions": "Build a simplified full-stack blog:\n\n1. Create a `database` object with:\n   - posts array with sample posts (id, title, content)\n   - findAll() method\n   - create(data) method\n\n2. Create a `backend` object with:\n   - handleGetPosts() - returns all posts\n   - handleCreatePost(title, content) - creates post\n\n3. Create a `BlogApp` object with:\n   - state: posts, loading\n   - fetchPosts() - calls backend\n   - createPost(title, content) - calls backend and refreshes\n\n4. Test the flow",
              "starterCode": "// Simplified blog system\n\nlet database = {\n  posts: [\n    { id: 1, title: 'First Post', content: 'Hello world!' },\n    { id: 2, title: 'Second Post', content: 'Learning full-stack!' }\n  ],\n  \n  findAll() {\n    console.log('[DB] SELECT * FROM posts');\n    return [...this.posts];\n  },\n  \n  create(data) {\n    console.log('[DB] INSERT INTO posts', data);\n    let post = { id: this.posts.length + 1, ...data };\n    this.posts.push(post);\n    return post;\n  }\n};\n\nlet backend = {\n  handleGetPosts() {\n    console.log('[API] GET /api/posts');\n    let posts = database.findAll();\n    return { status: 200, data: posts };\n  },\n  \n  handleCreatePost(title, content) {\n    console.log('[API] POST /api/posts');\n    let post = database.create({ title, content });\n    return { status: 201, data: post };\n  }\n};\n\nlet BlogApp = {\n  state: { posts: [], loading: false },\n  \n  setState(updates) {\n    this.state = { ...this.state, ...updates };\n    console.log('[App State]', this.state);\n  },\n  \n  async mount() {\n    console.log('[App] Mounting...');\n    await this.fetchPosts();\n  },\n  \n  async fetchPosts() {\n    console.log('[App] Fetching posts...');\n    this.setState({ loading: true });\n    \n    let response = backend.handleGetPosts();\n    this.setState({ posts: response.data, loading: false });\n  },\n  \n  async createPost(title, content) {\n    console.log(`[App] Creating post: ${title}`);\n    let response = backend.handleCreatePost(title, content);\n    console.log('[App] Post created, refreshing...');\n    await this.fetchPosts();\n  }\n};\n\n// Test\nconsole.log('=== Blog App Test ===\\n');\nBlogApp.mount().then(() => {\n  console.log('\\n[User] Clicks \"New Post\"');\n  BlogApp.createPost('Third Post', 'Full-stack is awesome!');\n});",
              "solution": "// See the codeExample above for complete solution with full CRUD operations",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should fetch posts",
                  "expectedOutput": "2",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Follow the pattern: Frontend → Backend → Database → Backend → Frontend"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common full-stack integration mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common full-stack integration mistakes:"
                },
                {
                  "mistake": "**Forgetting to enable CORS**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting to enable CORS**:\n   ```javascript\n   // Hono backend missing:\n   app.use('*', cors());  // Add this!\n   ```"
                },
                {
                  "mistake": "**Wrong API URL**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong API URL**:\n   ```jsx\n   // Wrong!\n   fetch('localhost:4000/api/todos')  // Missing http://\n   \n   // Correct!\n   fetch('http://localhost:4000/api/todos')\n   \n   // Best!\n   const API_URL = import.meta.env.VITE_API_URL;\n   fetch(`${API_URL}/api/todos`);\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-14",
      "title": "Module 14: Deployment & Professional Tools",
      "description": "Deploy your applications to production, use Git for version control, and adopt professional development practices",
      "difficulty": "advanced",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "14.1",
          "title": "Version Control with Git (The Time Machine Analogy)",
          "moduleId": "module-14",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine writing a book:\n\nWithout version control:\n- Save as: book_final.docx\n- Save as: book_final_v2.docx\n- Save as: book_final_v2_ACTUALLY_FINAL.docx\n- Save as: book_final_v2_ACTUALLY_FINAL_fixed.docx\n- Which one is the real final version?!\n- Want to go back to Tuesday's version? Good luck finding it!\n- Working with co-author? Email files back and forth (nightmare!)\n\nWith Git (version control):\n- One file: book.docx\n- Every save creates a snapshot (commit)\n- Can jump to ANY previous version instantly\n- See exactly what changed and when\n- Multiple authors work simultaneously\n- Automatic merging of changes\n- Complete history preserved forever\n\nGit is like a time machine for your code. It tracks every change, lets you experiment safely, and makes collaboration seamless!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Git Concepts (Simulated)\n// Git is a command-line tool, not JavaScript, but let's understand the concepts!\n\nconsole.log('=== Git Version Control ===\\n');\n\n// CONCEPT 1: REPOSITORY - Project history\nlet repository = {\n  name: 'my-awesome-app',\n  commits: [],\n  currentBranch: 'main',\n  branches: ['main']\n};\n\nconsole.log('Repository:', repository.name);\n\n// CONCEPT 2: COMMIT - Snapshot of your code\nfunction commit(message, files) {\n  let snapshot = {\n    id: Math.random().toString(36).substr(2, 7),\n    message: message,\n    files: files,\n    timestamp: new Date().toISOString(),\n    author: 'You'\n  };\n  \n  repository.commits.push(snapshot);\n  console.log(`✓ Committed: \"${message}\" (${snapshot.id})`);\n  return snapshot;\n}\n\n// CONCEPT 3: BRANCH - Parallel version of code\nfunction createBranch(name) {\n  repository.branches.push(name);\n  console.log(`✓ Created branch: ${name}`);\n}\n\nfunction switchBranch(name) {\n  if (repository.branches.includes(name)) {\n    repository.currentBranch = name;\n    console.log(`✓ Switched to branch: ${name}`);\n  }\n}\n\n// SIMULATE GIT WORKFLOW\nconsole.log('\\n--- Simulating Git Workflow ---\\n');\n\n// 1. Initial commit\ncommit('Initial commit', ['index.html', 'app.js', 'styles.css']);\n\n// 2. Add feature\ncommit('Add user authentication', ['auth.js', 'login.html']);\n\n// 3. Fix bug\ncommit('Fix login button styling', ['styles.css']);\n\n// 4. Create feature branch\ncreate Branch('feature/dark-mode');\nswitchBranch('feature/dark-mode');\n\n// 5. Work on feature\ncommit('Add dark mode toggle', ['darkMode.js', 'styles.css']);\n\n// 6. Switch back to main\nswitchBranch('main');\n\nconsole.log('\\n--- Repository State ---');\nconsole.log('Total commits:', repository.commits.length);\nconsole.log('Branches:', repository.branches.join(', '));\nconsole.log('Current branch:', repository.currentBranch);\n\nconsole.log('\\n--- Commit History ---');\nrepository.commits.forEach((c, i) => {\n  console.log(`${i + 1}. [${c.id}] ${c.message}`);\n});\n\n// GIT COMMANDS REFERENCE\nconsole.log('\\n=== Essential Git Commands ===\\n');\n\nlet gitCommands = {\n  'git init': 'Create new Git repository',\n  'git clone <url>': 'Download existing repository',\n  'git status': 'See which files changed',\n  'git add <file>': 'Stage file for commit',\n  'git add .': 'Stage all changed files',\n  'git commit -m \"message\"': 'Save snapshot with message',\n  'git log': 'View commit history',\n  'git branch <name>': 'Create new branch',\n  'git checkout <branch>': 'Switch to branch',\n  'git merge <branch>': 'Merge branch into current',\n  'git pull': 'Download latest changes from remote',\n  'git push': 'Upload your commits to remote',\n  'git diff': 'See what changed in files'\n};\n\nfor (let [command, description] of Object.entries(gitCommands)) {\n  console.log(`${command.padEnd(30)} - ${description}`);\n}\n\n// TYPICAL WORKFLOW\nconsole.log('\\n=== Typical Git Workflow ===\\n');\n\nlet workflow = [\n  '1. Make changes to your code',\n  '2. git status               (see what changed)',\n  '3. git add .                (stage all changes)',\n  '4. git commit -m \"Add feature X\"  (save snapshot)',\n  '5. git push                 (upload to GitHub)',\n  '',\n  'Repeat for every feature/fix!'\n];\n\nworkflow.forEach(step => console.log(step));\n\nconsole.log('\\n--- Why Use Git? ---');\nlet benefits = [\n  '✓ Never lose code (complete history)',\n  '✓ Experiment safely (branches)',\n  '✓ Collaborate easily (merge changes)',\n  '✓ See who changed what and when',\n  '✓ Revert mistakes instantly',\n  '✓ Required by all professional teams',\n  '✓ Works with GitHub (code hosting)'\n];\n\nbenefits.forEach(b => console.log(b));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Git fundamentals:\n\n1. **Setting Up Git**:\n   ```bash\n   # Configure Git (one time)\n   git config --global user.name \"Your Name\"\n   git config --global user.email \"you@example.com\"\n   \n   # Create new repository\n   git init\n   \n   # Or clone existing\n   git clone https://github.com/username/repo.git\n   ```\n\n2. **Basic Workflow**:\n   ```bash\n   # 1. Check status\n   git status\n   \n   # 2. Stage changes\n   git add filename.js      # Single file\n   git add .                # All files\n   \n   # 3. Commit\n   git commit -m \"Add user login feature\"\n   \n   # 4. Push to remote (GitHub)\n   git push\n   ```\n\n3. **Branches**:\n   ```bash\n   # Create and switch to new branch\n   git checkout -b feature/new-feature\n   \n   # Switch between branches\n   git checkout main\n   git checkout feature/new-feature\n   \n   # Merge branch into current\n   git checkout main\n   git merge feature/new-feature\n   \n   # Delete branch\n   git branch -d feature/new-feature\n   ```\n\n4. **Viewing History**:\n   ```bash\n   # See commits\n   git log\n   git log --oneline    # Compact view\n   \n   # See changes\n   git diff             # Unstaged changes\n   git diff --staged    # Staged changes\n   ```\n\n5. **.gitignore** - Files to never commit:\n   ```\n   node_modules/\n   .env\n   .DS_Store\n   dist/\n   build/\n   *.log\n   ```\n\n6. **GitHub Workflow**:\n   ```bash\n   # First time setup\n   git remote add origin https://github.com/username/repo.git\n   git push -u origin main\n   \n   # Regular updates\n   git pull    # Download changes\n   git push    # Upload changes\n   ```\n\n7. **Commit Messages** (best practices):\n   - Start with verb: \"Add\", \"Fix\", \"Update\", \"Remove\"\n   - Be specific: \"Fix login button alignment\"\n   - Not vague: \"Fixed stuff\" or \"Changes\"\n   - Present tense: \"Add feature\" not \"Added feature\""
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Git mistakes:\n\n1. **Forgetting to commit**:\n   ```bash\n   # Made lots of changes, forgot to commit\n   # Now have 50 files changed\n   # Hard to write one commit message!\n   \n   # Better: Commit after each feature\n   git add .\n   git commit -m \"Add user login\"\n   # Then continue coding\n   ```\n\n2. **Committing secrets**:\n   ```bash\n   # NEVER commit .env files!\n   # Add to .gitignore:\n   .env\n   .env.local\n   config/secrets.js\n   ```\n\n3. **Not using .gitignore**:\n   ```bash\n   # Don't commit node_modules!\n   # Create .gitignore file:\n   node_modules/\n   .DS_Store\n   dist/\n   *.log\n   ```\n\n4. **Merge conflicts** (scary but normal!):\n   ```\n   <<<<<<< HEAD\n   const API_URL = 'http://localhost:3000';\n   =======\n   const API_URL = 'https://api.production.com';\n   >>>>>>> feature-branch\n   ```\n   - Choose which version to keep\n   - Delete conflict markers (<<<<, ====, >>>>)\n   - Commit the resolved file\n\n5. **Wrong branch**:\n   ```bash\n   # Check current branch BEFORE committing!\n   git branch        # Shows all branches\n   git status        # Shows current branch\n   \n   # If on wrong branch:\n   git stash         # Save changes temporarily\n   git checkout correct-branch\n   git stash pop     # Apply changes here\n   ```\n\n6. **Push without pull**:\n   ```bash\n   # Error: Updates were rejected\n   # Someone else pushed while you were working\n   \n   # Fix:\n   git pull          # Get their changes\n   # Resolve conflicts if any\n   git push          # Now it works\n   ```\n\n7. **Vague commit messages**:\n   ```bash\n   # Bad:\n   git commit -m \"fixes\"\n   git commit -m \"stuff\"\n   git commit -m \"asdf\"\n   \n   # Good:\n   git commit -m \"Fix login button alignment on mobile\"\n   git commit -m \"Add password reset functionality\"\n   git commit -m \"Update dependencies to latest versions\"\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14.1-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a Git repository:\n\n1. Create a `repo` object with:\n   - commits array\n   - branches array (start with 'main')\n   - currentBranch property\n\n2. Create function `makeCommit(message)` that:\n   - Adds commit to commits array\n   - Returns commit object with: id, message, timestamp\n\n3. Create function `createBranch(name)` that:\n   - Adds branch to branches array\n\n4. Test by making 3 commits and creating 1 branch",
              "instructions": "Simulate a Git repository:\n\n1. Create a `repo` object with:\n   - commits array\n   - branches array (start with 'main')\n   - currentBranch property\n\n2. Create function `makeCommit(message)` that:\n   - Adds commit to commits array\n   - Returns commit object with: id, message, timestamp\n\n3. Create function `createBranch(name)` that:\n   - Adds branch to branches array\n\n4. Test by making 3 commits and creating 1 branch",
              "starterCode": "// Git repository simulation\nlet repo = {\n  commits: [],\n  branches: ['main'],\n  currentBranch: 'main'\n};\n\nfunction makeCommit(message) {\n  let commit = {\n    id: Math.random().toString(36).substr(2, 7),\n    message: message,\n    timestamp: new Date().toISOString()\n  };\n  repo.commits.push(commit);\n  console.log(`Committed: ${message} (${commit.id})`);\n  return commit;\n}\n\nfunction createBranch(name) {\n  repo.branches.push(name);\n  console.log(`Created branch: ${name}`);\n}\n\n// Test\nmakeCommit('Initial commit');\nmakeCommit('Add homepage');\nmakeCommit('Fix CSS');\ncreateBranch('feature/login');\n\nconsole.log('\\nRepository state:');\nconsole.log('Commits:', repo.commits.length);\nconsole.log('Branches:', repo.branches);",
              "solution": "// Complete Git simulation\nlet repo = {\n  commits: [],\n  branches: ['main'],\n  currentBranch: 'main',\n  files: {}\n};\n\nfunction makeCommit(message, files = []) {\n  let commit = {\n    id: Math.random().toString(36).substr(2, 7),\n    message: message,\n    branch: repo.currentBranch,\n    files: files,\n    timestamp: new Date().toISOString(),\n    author: 'Developer'\n  };\n  \n  repo.commits.push(commit);\n  console.log(`✓ [${commit.id}] ${message}`);\n  return commit;\n}\n\nfunction createBranch(name) {\n  if (repo.branches.includes(name)) {\n    console.log(`✗ Branch ${name} already exists`);\n    return false;\n  }\n  repo.branches.push(name);\n  console.log(`✓ Created branch: ${name}`);\n  return true;\n}\n\nfunction switchBranch(name) {\n  if (!repo.branches.includes(name)) {\n    console.log(`✗ Branch ${name} does not exist`);\n    return false;\n  }\n  repo.currentBranch = name;\n  console.log(`✓ Switched to branch: ${name}`);\n  return true;\n}\n\nfunction showLog() {\n  console.log('\\n=== Commit History ===');\n  repo.commits.forEach((c, i) => {\n    console.log(`${i + 1}. [${c.id}] (${c.branch}) ${c.message}`);\n    if (c.files.length > 0) {\n      console.log(`   Files: ${c.files.join(', ')}`);\n    }\n  });\n}\n\nfunction showStatus() {\n  console.log('\\n=== Repository Status ===');\n  console.log(`Current branch: ${repo.currentBranch}`);\n  console.log(`Total branches: ${repo.branches.join(', ')}`);\n  console.log(`Total commits: ${repo.commits.length}`);\n}\n\n// Simulate development workflow\nconsole.log('=== Git Workflow Simulation ===\\n');\n\nmakeCommit('Initial commit', ['README.md', 'package.json']);\nmakeCommit('Add Express server', ['server.js']);\nmakeCommit('Add database connection', ['db.js', 'prisma/schema.prisma']);\n\ncreateBranch('feature/authentication');\nswitchBranch('feature/authentication');\n\nmakeCommit('Add login route', ['routes/auth.js']);\nmakeCommit('Add JWT middleware', ['middleware/auth.js']);\n\nswitchBranch('main');\nmakeCommit('Update README', ['README.md']);\n\nshowLog();\nshowStatus();\n\nconsole.log('\\n--- Git Best Practices ---');\nlet practices = [\n  '✓ Commit often (small, focused commits)',\n  '✓ Write clear commit messages',\n  '✓ Use branches for features',\n  '✓ Never commit secrets (.env files)',\n  '✓ Pull before you push',\n  '✓ Review changes before committing (git diff)',\n  '✓ Use .gitignore for node_modules, etc.'\n];\npractices.forEach(p => console.log(p));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should track commits",
                  "expectedOutput": "1",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use array push() to add commits and branches."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common Git mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common Git mistakes:"
                },
                {
                  "mistake": "**Forgetting to commit**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting to commit**:\n   ```bash\n   # Made lots of changes, forgot to commit\n   # Now have 50 files changed\n   # Hard to write one commit message!\n   \n   # Better: Commit after each feature\n   git add .\n   git commit -m \"Add user login\"\n   # Then continue coding\n   ```"
                },
                {
                  "mistake": "**Committing secrets**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Committing secrets**:\n   ```bash\n   # NEVER commit .env files!\n   # Add to .gitignore:\n   .env\n   .env.local\n   config/secrets.js\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14.2",
          "title": "Deploying Hono Backend (The Portable Restaurant Analogy)",
          "moduleId": "module-14",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine opening a food truck instead of a fixed restaurant:\n\nTraditional restaurant (Express + Node):\n- Fixed location (one platform)\n- Heavy kitchen equipment\n- Expensive to relocate\n- Works great, but locked to one spot\n\nFood truck (Hono):\n- Same great recipes work anywhere!\n- Set up at festivals (Cloudflare Workers)\n- Park downtown (Render with Bun)\n- Visit the beach (Deno Deploy)\n- Light and portable equipment\n\nHono is the food truck of web frameworks:\n- Write once, deploy anywhere\n- Same code runs on Bun, Deno, Cloudflare Workers, Node\n- Lightweight and blazing fast\n- Edge-ready (runs close to users worldwide)\n\nPopular deployment targets:\n- Bun on Render (free tier!)\n- Cloudflare Workers (edge computing)\n- Deno Deploy (serverless)\n- Traditional Node.js hosting"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "Hono works identically across platforms. Here's a complete API that deploys anywhere.",
              "language": "javascript",
              "code": "// Deploying Hono API - Multi-Platform\n\nconsole.log('=== Hono Multi-Platform Deployment ===\\n');\n\n// CONCEPT: One codebase, many platforms\nconst PORT = process.env.PORT || 3000;\nconst PLATFORM = process.env.PLATFORM || 'bun';\n\nconsole.log('Target Platform:', PLATFORM);\nconsole.log('Port:', PORT);\n\n// Simulating Hono app structure\nconst app = {\n  routes: [\n    { method: 'GET', path: '/', handler: 'home' },\n    { method: 'GET', path: '/api/users', handler: 'getUsers' },\n    { method: 'POST', path: '/api/users', handler: 'createUser' },\n    { method: 'GET', path: '/health', handler: 'healthCheck' }\n  ],\n  \n  // Hono's elegant response helpers\n  responseExamples: {\n    text: \"c.text('Hello!')\",\n    json: \"c.json({ users: [] })\",\n    html: \"c.html('<h1>Hello</h1>')\"\n  }\n};\n\nconsole.log('\\nHono App Routes:');\napp.routes.forEach(r => console.log(`  ${r.method} ${r.path}`));\n\n// PLATFORM-SPECIFIC DEPLOYMENT\nconsole.log('\\n\\n=== Deployment by Platform ===\\n');\n\nconst platforms = {\n  'bun-render': {\n    name: 'Bun on Render',\n    buildCmd: 'bun install',\n    startCmd: 'bun run src/index.ts',\n    envFile: '.env',\n    pros: ['Free tier', 'Fast builds', 'Easy setup'],\n    entryPoint: `// src/index.ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello from Hono!'))\napp.get('/health', (c) => c.json({ status: 'ok' }))\n\nexport default app  // Bun serves this automatically`\n  },\n  \n  'cloudflare-workers': {\n    name: 'Cloudflare Workers',\n    buildCmd: 'wrangler deploy',\n    startCmd: 'N/A (serverless)',\n    envFile: 'wrangler.toml',\n    pros: ['Edge locations worldwide', 'Instant cold starts', 'Free tier'],\n    entryPoint: `// src/index.ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello from the Edge!'))\napp.get('/health', (c) => c.json({ status: 'ok' }))\n\nexport default app  // Workers picks this up`\n  },\n  \n  'deno-deploy': {\n    name: 'Deno Deploy',\n    buildCmd: 'N/A (deploys from GitHub)',\n    startCmd: 'deno run --allow-net src/index.ts',\n    envFile: 'Dashboard',\n    pros: ['Git-based deploys', 'TypeScript native', 'Global edge'],\n    entryPoint: `// src/index.ts\nimport { Hono } from 'npm:hono'\nimport { serve } from 'https://deno.land/std/http/server.ts'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello from Deno!'))\napp.get('/health', (c) => c.json({ status: 'ok' }))\n\nserve(app.fetch)  // Deno's serve function`\n  }\n};\n\nObject.entries(platforms).forEach(([key, platform]) => {\n  console.log(`--- ${platform.name} ---`);\n  console.log(`Build: ${platform.buildCmd}`);\n  console.log(`Start: ${platform.startCmd}`);\n  console.log(`Pros: ${platform.pros.join(', ')}`);\n  console.log('');\n});\n\n// HONO CODE PORTABILITY\nconsole.log('\\n=== The Magic: Same Code Everywhere ===\\n');\n\nconst honoApp = `// This EXACT code works on Bun, Deno, CF Workers, and Node!\nimport { Hono } from 'hono'\nimport { cors } from 'hono/cors'\nimport { logger } from 'hono/logger'\n\nconst app = new Hono()\n\n// Middleware (same everywhere)\napp.use('*', cors())\napp.use('*', logger())\n\n// Routes (same everywhere)\napp.get('/', (c) => c.text('Hello Hono!'))\n\napp.get('/api/users', (c) => {\n  return c.json([{ id: 1, name: 'Alice' }])\n})\n\napp.post('/api/users', async (c) => {\n  const body = await c.req.json()\n  return c.json({ id: 2, ...body }, 201)\n})\n\napp.get('/health', (c) => {\n  return c.json({ \n    status: 'ok', \n    timestamp: new Date().toISOString() \n  })\n})\n\nexport default app`;\n\nconsole.log(honoApp);\n\n// DEPLOYMENT STEPS FOR BUN ON RENDER\nconsole.log('\\n\\n=== Deploy to Render (Bun) ===\\n');\n\nconst renderSteps = [\n  { step: 1, title: 'Prepare', tasks: ['bun init', 'bun add hono', 'Create src/index.ts'] },\n  { step: 2, title: 'package.json', tasks: ['Add: \"start\": \"bun run src/index.ts\"'] },\n  { step: 3, title: 'Render Setup', tasks: ['New Web Service', 'Connect GitHub', 'Runtime: Node (Bun works here!)'] },\n  { step: 4, title: 'Configure', tasks: ['Build: bun install', 'Start: bun run src/index.ts'] },\n  { step: 5, title: 'Deploy', tasks: ['Add env vars', 'Click Deploy', 'Get URL!'] }\n];\n\nrenderSteps.forEach(({ step, title, tasks }) => {\n  console.log(`Step ${step}: ${title}`);\n  tasks.forEach(t => console.log(`  - ${t}`));\n});\n\nconsole.log('\\n=== Why Hono + Bun? ===');\nconsole.log('- 3x faster than Express');\nconsole.log('- TypeScript native');\nconsole.log('- Tiny bundle size');\nconsole.log('- Deploy anywhere with same code');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Hono deployment configuration by platform:\n\n1. **Bun on Render** (recommended for beginners):\n   ```typescript\n   // src/index.ts\n   import { Hono } from 'hono'\n   import { cors } from 'hono/cors'\n   \n   const app = new Hono()\n   \n   app.use('*', cors())\n   app.get('/health', (c) => c.json({ status: 'ok' }))\n   \n   export default app\n   \n   // package.json\n   {\n     \"scripts\": {\n       \"start\": \"bun run src/index.ts\",\n       \"dev\": \"bun --watch src/index.ts\"\n     }\n   }\n   ```\n\n2. **Cloudflare Workers** (edge deployment):\n   ```typescript\n   // src/index.ts - same Hono code!\n   import { Hono } from 'hono'\n   const app = new Hono()\n   app.get('/', (c) => c.text('Hello from Edge!'))\n   export default app\n   \n   // wrangler.toml\n   name = \"my-api\"\n   main = \"src/index.ts\"\n   compatibility_date = \"2024-01-01\"\n   \n   // Deploy: wrangler deploy\n   ```\n\n3. **Deno Deploy** (serverless):\n   ```typescript\n   // src/index.ts\n   import { Hono } from 'npm:hono'\n   const app = new Hono()\n   app.get('/', (c) => c.text('Hello from Deno!'))\n   Deno.serve(app.fetch)\n   ```\n\n4. **Environment Variables** (Bun reads .env automatically!):\n   ```typescript\n   // Bun auto-loads .env - no dotenv needed!\n   const dbUrl = process.env.DATABASE_URL\n   const secret = Bun.env.JWT_SECRET  // or process.env\n   ```\n\n5. **CORS with Hono** (built-in middleware):\n   ```typescript\n   import { cors } from 'hono/cors'\n   \n   app.use('*', cors({\n     origin: ['https://my-app.vercel.app', 'http://localhost:5173'],\n     credentials: true\n   }))\n   ```\n\n6. **Health Check** (Hono style):\n   ```typescript\n   app.get('/health', (c) => {\n     return c.json({\n       status: 'ok',\n       timestamp: new Date().toISOString(),\n       runtime: typeof Bun !== 'undefined' ? 'bun' : 'other'\n     })\n   })\n   ```\n\n7. **Error Handling** (Hono's onError):\n   ```typescript\n   app.onError((err, c) => {\n     console.error(err)\n     if (process.env.NODE_ENV === 'production') {\n       return c.json({ error: 'Internal error' }, 500)\n     }\n     return c.json({ error: err.message }, 500)\n   })\n   ```\n\n8. **Database with Drizzle** (works everywhere):\n   ```typescript\n   import { drizzle } from 'drizzle-orm/postgres-js'\n   import postgres from 'postgres'\n   \n   const client = postgres(process.env.DATABASE_URL!)\n   const db = drizzle(client)\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Hono deployment mistakes:\n\n1. **Forgetting to export default** (Bun/Workers need it!):\n   ```typescript\n   // WRONG! Bun won't serve this\n   const app = new Hono()\n   app.get('/', (c) => c.text('Hello'))\n   // Missing export!\n   \n   // CORRECT!\n   const app = new Hono()\n   app.get('/', (c) => c.text('Hello'))\n   export default app  // Required for Bun!\n   ```\n\n2. **Wrong import for Deno**:\n   ```typescript\n   // WRONG for Deno!\n   import { Hono } from 'hono'\n   \n   // CORRECT for Deno!\n   import { Hono } from 'npm:hono'\n   ```\n\n3. **Committed .env file** (security risk!):\n   ```bash\n   # .gitignore MUST include:\n   .env\n   .env.local\n   node_modules/\n   \n   # Bun lockfile is fine to commit:\n   # bun.lockb\n   ```\n\n4. **Missing start script for Render**:\n   ```json\n   // package.json for Bun on Render\n   {\n     \"scripts\": {\n       \"start\": \"bun run src/index.ts\",\n       \"dev\": \"bun --watch src/index.ts\"\n     }\n   }\n   ```\n\n5. **CORS not configured**:\n   ```typescript\n   // WRONG! No CORS = frontend blocked\n   const app = new Hono()\n   \n   // CORRECT!\n   import { cors } from 'hono/cors'\n   const app = new Hono()\n   app.use('*', cors({\n     origin: ['https://my-app.vercel.app', 'http://localhost:5173']\n   }))\n   ```\n\n6. **Missing health check**:\n   ```typescript\n   // Always add this for monitoring!\n   app.get('/health', (c) => c.json({ status: 'ok' }))\n   ```\n\n7. **Platform-specific code without checks**:\n   ```typescript\n   // WRONG! Bun.env doesn't exist in Cloudflare Workers\n   const secret = Bun.env.SECRET\n   \n   // CORRECT! Works everywhere\n   const secret = process.env.SECRET\n   ```\n\n8. **Not handling errors**:\n   ```typescript\n   // Add global error handler\n   app.onError((err, c) => {\n     console.error(err)\n     return c.json({ error: 'Internal error' }, 500)\n   })\n   \n   // Add 404 handler\n   app.notFound((c) => c.json({ error: 'Not found' }, 404))\n   ```"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Express Equivalent",
              "legacy": "express",
              "content": "Here's how the same deployment would look with Express + Node.js. Express requires more setup and is platform-specific.",
              "code": "// Express + Node.js deployment (traditional approach)\n\n// 1. Install dependencies\n// npm install express cors dotenv\n\n// 2. server.js\nconst express = require('express');\nconst cors = require('cors');\nrequire('dotenv').config();\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(cors({\n  origin: ['https://my-app.vercel.app', 'http://localhost:5173']\n}));\napp.use(express.json());\n\n// Routes\napp.get('/', (req, res) => {\n  res.send('Hello from Express!');\n});\n\napp.get('/api/users', (req, res) => {\n  res.json([{ id: 1, name: 'Alice' }]);\n});\n\napp.get('/health', (req, res) => {\n  res.json({ status: 'ok' });\n});\n\n// Error handler\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({ error: 'Internal error' });\n});\n\napp.listen(PORT, () => {\n  console.log(`Server on port ${PORT}`);\n});\n\n// 3. package.json\n// {\n//   \"scripts\": {\n//     \"start\": \"node server.js\",\n//     \"dev\": \"nodemon server.js\"\n//   }\n// }\n\n// Key Differences:\n// - Express is Node.js only (no Workers, no Deno)\n// - Requires dotenv package for .env\n// - More verbose syntax\n// - No built-in TypeScript\n// - Callback-based (req, res) vs Hono's context (c)",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14.2-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a Hono server ready for multi-platform deployment:\n\n1. Create a `honoApp` object that:\n   - Has routes for /, /health, and /api/users\n   - Shows which platform it's running on\n   - Demonstrates Hono's response helpers (c.text, c.json)\n\n2. Simulate deploying to different platforms (Bun, Workers, Deno)",
              "instructions": "Simulate a Hono server ready for multi-platform deployment:\n\n1. Create a `honoApp` object that:\n   - Has routes for /, /health, and /api/users\n   - Shows which platform it's running on\n   - Demonstrates Hono's response helpers (c.text, c.json)\n\n2. Simulate deploying to different platforms (Bun, Workers, Deno)",
              "starterCode": "// Hono app ready for multi-platform deployment\n\nconst honoApp = {\n  platform: process.env.PLATFORM || 'bun',\n  \n  routes: {\n    '/': (c) => c.text('Hello from Hono!'),\n    '/health': (c) => c.json({ status: 'ok', timestamp: new Date() }),\n    '/api/users': (c) => c.json([{ id: 1, name: 'Alice' }])\n  },\n  \n  // Simulate Hono's context object\n  createContext() {\n    return {\n      text: (content) => ({ type: 'text', body: content }),\n      json: (data) => ({ type: 'json', body: JSON.stringify(data) })\n    };\n  },\n  \n  handleRequest(path) {\n    const c = this.createContext();\n    if (this.routes[path]) {\n      const response = this.routes[path](c);\n      console.log(`[${this.platform}] GET ${path}`);\n      console.log(`Response (${response.type}):`, response.body);\n      return response;\n    }\n    return c.json({ error: 'Not found' });\n  }\n};\n\n// Test\nconsole.log('=== Hono Multi-Platform Demo ===\\n');\nhonoApp.handleRequest('/');\nhonoApp.handleRequest('/health');\nhonoApp.handleRequest('/api/users');",
              "solution": "// Complete Hono app with multi-platform deployment simulation\n\nconst honoApp = {\n  platform: process.env.PLATFORM || 'bun',\n  env: process.env.NODE_ENV || 'development',\n  \n  routes: {\n    '/': (c) => c.text('Hello from Hono!'),\n    '/health': (c) => c.json({ \n      status: 'ok', \n      timestamp: new Date().toISOString(),\n      platform: honoApp.platform\n    }),\n    '/api/users': (c) => c.json([\n      { id: 1, name: 'Alice' },\n      { id: 2, name: 'Bob' }\n    ]),\n    '/api/users/:id': (c) => c.json({ id: c.params.id, name: 'User' })\n  },\n  \n  middleware: [\n    { name: 'cors', applied: true },\n    { name: 'logger', applied: true }\n  ],\n  \n  createContext(params = {}) {\n    return {\n      text: (content) => ({ type: 'text/plain', body: content, status: 200 }),\n      json: (data, status = 200) => ({ type: 'application/json', body: JSON.stringify(data), status }),\n      html: (content) => ({ type: 'text/html', body: content, status: 200 }),\n      params: params\n    };\n  },\n  \n  handleRequest(path, params = {}) {\n    const c = this.createContext(params);\n    console.log(`\\n[${this.platform.toUpperCase()}] GET ${path}`);\n    \n    if (this.routes[path]) {\n      const response = this.routes[path](c);\n      console.log(`Status: ${response.status}`);\n      console.log(`Content-Type: ${response.type}`);\n      console.log(`Body: ${response.body}`);\n      return response;\n    }\n    \n    console.log('Status: 404');\n    return c.json({ error: 'Not found' }, 404);\n  },\n  \n  deployTo(platform) {\n    this.platform = platform;\n    \n    const configs = {\n      bun: {\n        name: 'Bun on Render',\n        buildCmd: 'bun install',\n        startCmd: 'bun run src/index.ts',\n        export: 'export default app'\n      },\n      'cloudflare-workers': {\n        name: 'Cloudflare Workers',\n        buildCmd: 'wrangler deploy',\n        startCmd: '(serverless)',\n        export: 'export default app'\n      },\n      deno: {\n        name: 'Deno Deploy',\n        buildCmd: '(git deploy)',\n        startCmd: 'Deno.serve(app.fetch)',\n        export: 'Deno.serve(app.fetch)'\n      }\n    };\n    \n    const config = configs[platform] || configs.bun;\n    \n    console.log('\\n' + '='.repeat(45));\n    console.log(`Deploying to: ${config.name}`);\n    console.log('='.repeat(45));\n    console.log(`Build: ${config.buildCmd}`);\n    console.log(`Start: ${config.startCmd}`);\n    console.log(`Export: ${config.export}`);\n    console.log('');\n    \n    return config;\n  },\n  \n  showCode() {\n    console.log('\\n// This code works on ALL platforms!');\n    console.log('import { Hono } from \"hono\"');\n    console.log('import { cors } from \"hono/cors\"');\n    console.log('');\n    console.log('const app = new Hono()');\n    console.log('');\n    console.log('app.use(\"*\", cors())');\n    console.log('');\n    console.log('app.get(\"/\", (c) => c.text(\"Hello!\"))');\n    console.log('app.get(\"/health\", (c) => c.json({ status: \"ok\" }))');\n    console.log('app.get(\"/api/users\", (c) => c.json([...]))');\n    console.log('');\n    console.log('export default app  // Works for Bun & Workers');\n    console.log('// OR: Deno.serve(app.fetch)  // For Deno');\n  }\n};\n\n// Demonstrate multi-platform deployment\nconsole.log('=== Hono Multi-Platform Deployment Demo ===\\n');\n\n// Show the universal code\nhonoApp.showCode();\n\n// Test on each platform\nconst platforms = ['bun', 'cloudflare-workers', 'deno'];\n\nplatforms.forEach(platform => {\n  honoApp.deployTo(platform);\n  honoApp.handleRequest('/');\n  honoApp.handleRequest('/health');\n});\n\n// Show portability advantage\nconsole.log('\\n' + '='.repeat(45));\nconsole.log('KEY ADVANTAGE: Same Code Everywhere!');\nconsole.log('='.repeat(45));\nconsole.log('- Write once');\nconsole.log('- Deploy to Bun, Deno, Cloudflare, or Node');\nconsole.log('- Switch platforms without code changes');\nconsole.log('- Edge-ready by default');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should handle requests on multiple platforms",
                  "expectedOutput": "Hello from Hono!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Hono uses c.text(), c.json(), c.html() for responses - the same API works everywhere!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting export default",
                  "consequence": "Bun and Cloudflare Workers need export default app to serve the application.",
                  "correction": "Always add: export default app"
                },
                {
                  "mistake": "Using Bun.env in Workers",
                  "consequence": "Bun.env only exists in Bun runtime, causing errors on Cloudflare Workers.",
                  "correction": "Use process.env which works everywhere, or check the runtime first."
                },
                {
                  "mistake": "Wrong import for Deno",
                  "consequence": "import { Hono } from 'hono' won't work in Deno without npm: prefix.",
                  "correction": "Use: import { Hono } from 'npm:hono'"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14.3",
          "title": "Deploying React Frontend to Vercel (The Storefront Going Live Analogy)",
          "moduleId": "module-14",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine opening a physical store:\n\nDevelopment (building in your garage):\n- Test the store layout\n- Only you can see it\n- localhost:5173 (your garage address)\n- Close garage door → store disappears\n\nProduction (real storefront on Main Street):\n- Open to the public!\n- Anyone can visit from anywhere\n- https://my-store.vercel.app (real address)\n- Open 24/7 (never closes)\n- Professional hosting (like a shopping mall)\n\nDeploying your React app is the same:\n- Move from localhost to real internet\n- Build optimized version (Vite build)\n- Get a public URL (vercel.app or netlify.app)\n- Hosted on fast servers worldwide (CDN)\n- Connects to your deployed API!\n\nPopular platforms: Vercel (made by Next.js creators, free!), Netlify, Cloudflare Pages"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Deploying React Frontend - Concepts\n\nconsole.log('=== React Frontend Deployment ===\\n');\n\n// CONCEPT: Build Process\nconst buildProcess = {\n  name: 'Vite Build',\n  \n  steps: [\n    'Read all your React components',\n    'Bundle JavaScript into optimized files',\n    'Minify code (remove whitespace, shorten names)',\n    'Optimize images and assets',\n    'Generate index.html',\n    'Output to dist/ folder'\n  ],\n  \n  before: {\n    files: ['src/App.jsx', 'src/components/*.jsx', 'src/main.jsx'],\n    size: '2.5 MB (readable code)'\n  },\n  \n  after: {\n    files: ['dist/index.html', 'dist/assets/index-a3b4c5d6.js', 'dist/assets/index-e7f8g9h0.css'],\n    size: '150 KB (minified and optimized!)'\n  },\n  \n  run() {\n    console.log('🔨 Building React app...\\n');\n    this.steps.forEach((step, i) => {\n      console.log(`  ${i + 1}. ${step}`);\n    });\n    console.log('\\n📦 Before build:');\n    console.log(`  Files: ${this.before.files.join(', ')}`);\n    console.log(`  Size: ${this.before.size}`);\n    console.log('\\n✅ After build:');\n    console.log(`  Files: ${this.after.files.join(', ')}`);\n    console.log(`  Size: ${this.after.size}`);\n    console.log('\\n✓ Build complete! Ready to deploy.');\n  }\n};\n\nbuildProcess.run();\n\n// CONCEPT: Environment Variables\nconsole.log('\\n\\n=== Environment Variables ===\\n');\n\nconst environmentConfig = {\n  development: {\n    API_URL: 'http://localhost:3000',\n    DEBUG: 'true'\n  },\n  \n  production: {\n    API_URL: 'https://my-api.onrender.com',\n    DEBUG: 'false'\n  },\n  \n  showConfig(env) {\n    console.log(`${env.toUpperCase()} Environment:`);\n    const config = this[env];\n    for (let [key, value] of Object.entries(config)) {\n      console.log(`  VITE_${key} = \"${value}\"`);\n    }\n  }\n};\n\nconsole.log('Local development:');\nenvironmentConfig.showConfig('development');\n\nconsole.log('\\nProduction deployment:');\nenvironmentConfig.showConfig('production');\n\nconsole.log('\\nIn your React code:');\nconsole.log(\"const API_URL = import.meta.env.VITE_API_URL;\");\nconsole.log(\"fetch(`${API_URL}/api/users`);\\n\");\n\n// DEPLOYMENT STEPS SIMULATION\nconsole.log('\\n=== Deployment Process (Vercel) ===\\n');\n\nconst deploymentSteps = [\n  {\n    step: 1,\n    title: 'Prepare Your React App',\n    tasks: [\n      'Update API URL to use environment variable',\n      'Test build locally: npm run build',\n      'Add .env to .gitignore',\n      'Commit and push to GitHub'\n    ]\n  },\n  {\n    step: 2,\n    title: 'Create Vercel Account',\n    tasks: [\n      'Go to vercel.com',\n      'Sign up with GitHub',\n      'Click \"Add New\" → \"Project\"'\n    ]\n  },\n  {\n    step: 3,\n    title: 'Import Repository',\n    tasks: [\n      'Select your GitHub repo',\n      'Framework Preset: Vite (auto-detected)',\n      'Root Directory: ./ (or your frontend folder)',\n      'Build Command: npm run build',\n      'Output Directory: dist'\n    ]\n  },\n  {\n    step: 4,\n    title: 'Configure Environment Variables',\n    tasks: [\n      'Click \"Environment Variables\"',\n      'Add: VITE_API_URL = https://my-api.onrender.com',\n      'Add any other VITE_ prefixed variables'\n    ]\n  },\n  {\n    step: 5,\n    title: 'Deploy!',\n    tasks: [\n      'Click \"Deploy\"',\n      'Wait for build (~1 minute)',\n      'Get your URL: https://my-app.vercel.app',\n      'Test: Open URL and check if it connects to API'\n    ]\n  },\n  {\n    step: 6,\n    title: 'Update Backend CORS',\n    tasks: [\n      'Add your Vercel URL to backend CORS',\n      \"In Express: allowedOrigins.push('https://my-app.vercel.app')\",\n      'Redeploy backend',\n      'Test frontend → backend connection'\n    ]\n  }\n];\n\ndeploymentSteps.forEach(({ step, title, tasks }) => {\n  console.log(`Step ${step}: ${title}`);\n  tasks.forEach(task => console.log(`  - ${task}`));\n  console.log('');\n});\n\n// SIMULATING DEPLOYMENT\nconsole.log('=== Simulating Frontend Deployment ===\\n');\n\nconst deployment = {\n  platform: 'Vercel',\n  project: 'my-react-app',\n  url: 'https://my-react-app.vercel.app',\n  status: 'Building',\n  \n  logs: [\n    '[1/6] Cloning repository from GitHub...',\n    '[2/6] Installing dependencies (npm install)...',\n    '[3/6] Building project (npm run build)...',\n    '  ✓ 1247 modules transformed',\n    '  ✓ Built in 8.3s',\n    '[4/6] Optimizing assets...',\n    '  ✓ Images optimized: 12 files',\n    '  ✓ JavaScript minified: 145 KB → 48 KB',\n    '[5/6] Deploying to global CDN...',\n    '[6/6] Assigning domains...',\n    '',\n    '✅ Deployment successful!',\n    '🌐 https://my-react-app.vercel.app',\n    '⚡ Served from 100+ edge locations worldwide'\n  ],\n  \n  deploy() {\n    console.log(`Deploying ${this.project} to ${this.platform}...\\n`);\n    this.logs.forEach(log => {\n      console.log(log);\n    });\n    console.log(`\\n✓ Live at: ${this.url}`);\n    this.status = 'Live';\n  },\n  \n  stats() {\n    console.log('\\n=== Deployment Stats ===\\n');\n    console.log('Status:', this.status);\n    console.log('Platform:', this.platform);\n    console.log('Build time: 8.3 seconds');\n    console.log('Deploy time: 12 seconds');\n    console.log('Total size: 48 KB (gzipped)');\n    console.log('CDN locations: 100+');\n    console.log('SSL: Enabled (HTTPS)');\n    console.log('Auto-deploy: Enabled (push to main → auto deploy)');\n  }\n};\n\ndeployment.deploy();\ndeployment.stats();\n\n// AUTO-DEPLOYMENT\nconsole.log('\\n\\n=== Auto-Deployment Workflow ===\\n');\n\nconst autoDeploySteps = [\n  '1. You push code to GitHub (git push)',\n  '2. Vercel detects the push',\n  '3. Automatically runs build',\n  '4. Deploys new version',\n  '5. Updates live site',\n  '',\n  '⚡ Total time: ~1 minute from push to live!'\n];\n\nautoDeploySteps.forEach(step => console.log(step));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "React deployment configuration:\n\n1. **Environment Variables** (VITE_ prefix required!):\n   ```javascript\n   // .env.local (development)\n   VITE_API_URL=http://localhost:3000\n   VITE_DEBUG=true\n   \n   // In Vercel dashboard (production)\n   VITE_API_URL=https://my-api.onrender.com\n   VITE_DEBUG=false\n   ```\n   \n   ```javascript\n   // Using in React code\n   const API_URL = import.meta.env.VITE_API_URL;\n   \n   fetch(`${API_URL}/api/users`)\n     .then(res => res.json())\n     .then(data => console.log(data));\n   ```\n\n2. **vite.config.js** (usually default is fine):\n   ```javascript\n   import { defineConfig } from 'vite';\n   import react from '@vitejs/plugin-react';\n   \n   export default defineConfig({\n     plugins: [react()],\n     build: {\n       outDir: 'dist',  // Output folder\n       sourcemap: false  // Don't include source maps in production\n     }\n   });\n   ```\n\n3. **Build Command**:\n   ```bash\n   # Test build locally first!\n   npm run build\n   \n   # Creates dist/ folder with:\n   # - index.html\n   # - assets/index-[hash].js\n   # - assets/index-[hash].css\n   \n   # Preview build locally\n   npm run preview\n   # Opens http://localhost:4173\n   ```\n\n4. **package.json Scripts**:\n   ```json\n   {\n     \"scripts\": {\n       \"dev\": \"vite\",\n       \"build\": \"vite build\",\n       \"preview\": \"vite preview\"\n     }\n   }\n   ```\n\n5. **Connecting to Backend API**:\n   ```javascript\n   // src/config/api.js\n   const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000';\n   \n   export async function fetchUsers() {\n     const response = await fetch(`${API_URL}/api/users`);\n     return response.json();\n   }\n   \n   export async function createUser(userData) {\n     const response = await fetch(`${API_URL}/api/users`, {\n       method: 'POST',\n       headers: { 'Content-Type': 'application/json' },\n       body: JSON.stringify(userData)\n     });\n     return response.json();\n   }\n   ```\n\n6. **Update Backend CORS** (CRITICAL!):\n   ```javascript\n   // Express backend server.js\n   const allowedOrigins = [\n     'https://my-app.vercel.app',      // Your Vercel URL\n     'https://my-app-git-*.vercel.app', // Preview deployments\n     'http://localhost:5173'            // Local dev\n   ];\n   \n   app.use(cors({\n     origin: allowedOrigins,\n     credentials: true\n   }));\n   ```\n\n7. **Vercel Configuration** (optional vercel.json):\n   ```json\n   {\n     \"buildCommand\": \"npm run build\",\n     \"outputDirectory\": \"dist\",\n     \"rewrites\": [\n       {\n         \"source\": \"/(.*)\",\n         \"destination\": \"/index.html\"\n       }\n     ]\n   }\n   ```\n   The `rewrites` rule handles client-side routing (React Router).\n\n8. **.gitignore** (don't commit build folder!):\n   ```\n   node_modules/\n   dist/\n   .env\n   .env.local\n   .env.production\n   .vercel\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common React deployment mistakes:\n\n1. **Wrong environment variable prefix**:\n   ```javascript\n   // WRONG! Won't work in Vite\n   const API_URL = process.env.REACT_APP_API_URL;  // ✗\n   const API_URL = process.env.API_URL;             // ✗\n   \n   // CORRECT for Vite!\n   const API_URL = import.meta.env.VITE_API_URL;   // ✓\n   ```\n\n2. **Hardcoded API URL**:\n   ```javascript\n   // WRONG! Won't work after deployment\n   fetch('http://localhost:3000/api/users');  // ✗\n   \n   // CORRECT!\n   const API_URL = import.meta.env.VITE_API_URL;\n   fetch(`${API_URL}/api/users`);  // ✓\n   ```\n\n3. **Forgot to add env vars in Vercel dashboard**:\n   ```\n   Error: import.meta.env.VITE_API_URL is undefined\n   \n   Fix:\n   1. Go to Vercel project settings\n   2. Environment Variables\n   3. Add: VITE_API_URL = https://my-api.onrender.com\n   4. Redeploy\n   ```\n\n4. **Backend CORS not updated**:\n   ```javascript\n   // Error in browser console:\n   // \"Access to fetch at 'https://api.com' from origin 'https://my-app.vercel.app' \n   // has been blocked by CORS policy\"\n   \n   // Fix in Express backend:\n   const allowedOrigins = [\n     'https://my-app.vercel.app',  // Add this!\n     'http://localhost:5173'\n   ];\n   \n   app.use(cors({ origin: allowedOrigins }));\n   ```\n\n5. **Build folder committed to Git**:\n   ```bash\n   # .gitignore should include:\n   dist/\n   build/\n   .vercel/\n   \n   # If accidentally committed:\n   git rm -r --cached dist\n   git commit -m \"Remove dist folder\"\n   ```\n\n6. **Wrong build output directory**:\n   ```\n   # Vercel settings:\n   Build Command: npm run build\n   Output Directory: dist    ← Must match Vite's output!\n   \n   # Vite outputs to dist/ by default\n   # If you changed it in vite.config.js, update Vercel settings\n   ```\n\n7. **Client-side routing 404 errors**:\n   ```\n   Problem: Refreshing /about gives 404 error\n   \n   Solution: Add vercel.json:\n   {\n     \"rewrites\": [\n       { \"source\": \"/(.*)\", \"destination\": \"/index.html\" }\n     ]\n   }\n   \n   This tells Vercel to serve index.html for all routes\n   (React Router handles routing on the client)\n   ```\n\n8. **Mixed content warning (HTTP/HTTPS)**:\n   ```javascript\n   // WRONG! Frontend is HTTPS, API is HTTP\n   VITE_API_URL=http://my-api.com  // ✗ Browser blocks this!\n   \n   // CORRECT! Both must be HTTPS\n   VITE_API_URL=https://my-api.com  // ✓\n   ```\n\n9. **Environment variables not rebuilding**:\n   ```\n   Changed VITE_API_URL but still seeing old value?\n   \n   Fix:\n   1. Environment vars are baked into build at build time\n   2. Must trigger new deployment after changing them\n   3. In Vercel: Deployments → Redeploy\n   ```\n\n10. **Forgot to test production build locally**:\n    ```bash\n    # Always test before deploying!\n    npm run build      # Build for production\n    npm run preview    # Preview the build locally\n    \n    # Open http://localhost:4173 and test everything\n    # Make sure API calls work!\n    ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14.3-challenge",
              "title": "Practice Challenge",
              "description": "Prepare a React app for deployment:\n\n1. Create a `frontendApp` object that:\n   - Has development and production API URLs\n   - Simulates build process\n   - Shows environment-specific configuration\n\n2. Create a `buildApp()` function that:\n   - Shows build steps\n   - Outputs stats (file size, optimization)\n\n3. Test building for both environments",
              "instructions": "Prepare a React app for deployment:\n\n1. Create a `frontendApp` object that:\n   - Has development and production API URLs\n   - Simulates build process\n   - Shows environment-specific configuration\n\n2. Create a `buildApp()` function that:\n   - Shows build steps\n   - Outputs stats (file size, optimization)\n\n3. Test building for both environments",
              "starterCode": "// React app deployment simulation\n\nconst frontendApp = {\n  name: 'My React App',\n  \n  env: {\n    development: {\n      API_URL: 'http://localhost:3000',\n      NODE_ENV: 'development'\n    },\n    production: {\n      API_URL: 'https://my-api.onrender.com',\n      NODE_ENV: 'production'\n    }\n  },\n  \n  build(environment) {\n    console.log(`\\n🔨 Building for ${environment}...\\n`);\n    \n    const config = this.env[environment];\n    console.log('Environment variables:');\n    console.log(`  VITE_API_URL=${config.API_URL}`);\n    console.log(`  NODE_ENV=${config.NODE_ENV}\\n`);\n    \n    console.log('Build steps:');\n    console.log('  1. Bundling React components');\n    console.log('  2. Minifying JavaScript');\n    console.log('  3. Optimizing assets');\n    console.log('  4. Generating index.html\\n');\n    \n    if (environment === 'production') {\n      console.log('✓ Production optimizations applied');\n      console.log('  - Code minified');\n      console.log('  - Source maps removed');\n      console.log('  - Tree-shaking applied\\n');\n    }\n    \n    console.log('✅ Build complete!');\n    console.log(`   Output: dist/`);\n    console.log(`   Ready to deploy to Vercel\\n`);\n  }\n};\n\n// Test\nfrontendApp.build('development');\nfrontendApp.build('production');",
              "solution": "// Complete React deployment simulation\n\nconst frontendApp = {\n  name: 'My React App',\n  version: '1.0.0',\n  \n  env: {\n    development: {\n      VITE_API_URL: 'http://localhost:3000',\n      VITE_DEBUG: 'true',\n      NODE_ENV: 'development'\n    },\n    production: {\n      VITE_API_URL: 'https://my-api.onrender.com',\n      VITE_DEBUG: 'false',\n      NODE_ENV: 'production'\n    }\n  },\n  \n  files: {\n    source: [\n      'src/App.jsx',\n      'src/components/UserList.jsx',\n      'src/components/LoginForm.jsx',\n      'src/main.jsx',\n      'src/styles.css'\n    ],\n    sourceSize: 2500,  // KB\n    \n    built: [\n      'dist/index.html',\n      'dist/assets/index-a3b4c5d6.js',\n      'dist/assets/index-e7f8g9h0.css'\n    ],\n    builtSize: 145  // KB after optimization\n  },\n  \n  build(environment) {\n    console.log('┌─────────────────────────────────────┐');\n    console.log('│       Building React App            │');\n    console.log('└─────────────────────────────────────┘\\n');\n    \n    console.log(`Environment: ${environment}`);\n    console.log(`Version: ${this.version}\\n`);\n    \n    const config = this.env[environment];\n    console.log('Environment Variables:');\n    Object.entries(config).forEach(([key, value]) => {\n      if (key.startsWith('VITE_')) {\n        console.log(`  ${key}=${value}`);\n      }\n    });\n    \n    console.log('\\n' + '─'.repeat(39));\n    console.log('\\nBuild Process:\\n');\n    \n    const steps = [\n      { name: 'Analyzing dependencies', time: 0.5 },\n      { name: 'Bundling React components', time: 2.1 },\n      { name: 'Transpiling JSX to JavaScript', time: 1.3 },\n      { name: 'Minifying JavaScript', time: 1.8 },\n      { name: 'Optimizing CSS', time: 0.7 },\n      { name: 'Compressing images', time: 0.9 },\n      { name: 'Generating index.html', time: 0.2 }\n    ];\n    \n    steps.forEach((step, i) => {\n      console.log(`  ${i + 1}. ${step.name.padEnd(35)} ${step.time}s`);\n    });\n    \n    const totalTime = steps.reduce((sum, s) => sum + s.time, 0);\n    console.log(`\\n  Total build time: ${totalTime.toFixed(1)}s`);\n    \n    console.log('\\n' + '─'.repeat(39));\n    \n    if (environment === 'production') {\n      console.log('\\n🚀 Production Optimizations:\\n');\n      const optimizations = [\n        'Code splitting enabled',\n        'Tree-shaking applied (removed unused code)',\n        'Minification: 2500 KB → 145 KB',\n        'Gzip compression ready',\n        'Source maps removed',\n        'Image optimization: 85% quality',\n        'CSS purged (unused styles removed)'\n      ];\n      optimizations.forEach(opt => console.log(`  ✓ ${opt}`));\n    } else {\n      console.log('\\n🔧 Development Build:\\n');\n      const devFeatures = [\n        'Source maps included',\n        'Hot module replacement enabled',\n        'Readable code (not minified)',\n        'Detailed error messages'\n      ];\n      devFeatures.forEach(feat => console.log(`  ✓ ${feat}`));\n    }\n    \n    console.log('\\n' + '─'.repeat(39));\n    console.log('\\n✅ Build Complete!\\n');\n    console.log('Output Directory: dist/');\n    console.log('Files generated:');\n    this.files.built.forEach(file => {\n      console.log(`  - ${file}`);\n    });\n    console.log(`\\nTotal size: ${this.files.builtSize} KB`);\n    \n    if (environment === 'production') {\n      console.log(`Compression: ${this.files.sourceSize} KB → ${this.files.builtSize} KB (${Math.round((1 - this.files.builtSize / this.files.sourceSize) * 100)}% smaller)\\n`);\n    }\n    \n    console.log('═'.repeat(39) + '\\n');\n  },\n  \n  deploy(platform) {\n    console.log(`\\n🚀 Deploying to ${platform}...\\n`);\n    \n    const deploySteps = [\n      'Uploading dist/ folder',\n      'Distributing to global CDN',\n      'Configuring SSL certificate',\n      'Assigning domain',\n      'Running health checks'\n    ];\n    \n    deploySteps.forEach((step, i) => {\n      console.log(`  ${i + 1}. ${step}...`);\n    });\n    \n    const url = `https://${this.name.toLowerCase().replace(/\\s+/g, '-')}.vercel.app`;\n    \n    console.log(`\\n✅ Deployment successful!\\n`);\n    console.log(`🌐 Live at: ${url}`);\n    console.log(`⚡ Served from 100+ edge locations worldwide\\n`);\n    \n    return url;\n  },\n  \n  testConnection(apiUrl) {\n    console.log(`\\n🧪 Testing connection to backend...\\n`);\n    console.log(`Frontend: https://my-app.vercel.app`);\n    console.log(`Backend:  ${apiUrl}\\n`);\n    \n    console.log('Testing endpoints:');\n    const tests = [\n      { endpoint: '/health', status: 200, result: 'OK' },\n      { endpoint: '/api/users', status: 200, result: '[2 users]' },\n      { endpoint: '/api/login', status: 200, result: 'OK' }\n    ];\n    \n    tests.forEach(test => {\n      console.log(`  GET ${apiUrl}${test.endpoint}`);\n      console.log(`    → ${test.status} ${test.result}`);\n    });\n    \n    console.log('\\n✅ All endpoints responding correctly!\\n');\n  }\n};\n\n// Simulate complete deployment workflow\nconsole.log('=== Complete Deployment Workflow ===\\n');\n\n// 1. Development build\nconsole.log('Step 1: Test build locally\\n');\nfrontendApp.build('development');\n\n// 2. Production build\nconsole.log('\\nStep 2: Production build\\n');\nfrontendApp.build('production');\n\n// 3. Deploy\nconsole.log('\\nStep 3: Deploy to Vercel\\n');\nconst liveUrl = frontendApp.deploy('Vercel');\n\n// 4. Test backend connection\nconsole.log('Step 4: Test API connection\\n');\nfrontendApp.testConnection(frontendApp.env.production.VITE_API_URL);\n\n// 5. Final checklist\nconsole.log('\\n=== Deployment Checklist ===\\n');\nconst checklist = [\n  '✓ Environment variables configured in Vercel',\n  '✓ API URL points to production backend',\n  '✓ Backend CORS allows Vercel domain',\n  '✓ Build completes without errors',\n  '✓ All API endpoints responding',\n  '✓ SSL certificate active (HTTPS)',\n  '✓ Auto-deploy enabled on git push',\n  '✓ .env files not committed to git'\n];\n\nchecklist.forEach(item => console.log(item));\n\nconsole.log('\\n🎉 Deployment complete! Your app is live!\\n');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should use correct API URL for environment",
                  "expectedOutput": "https://my-api.onrender.com (in production)",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use import.meta.env.VITE_* for environment variables in Vite/React"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common React deployment mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common React deployment mistakes:"
                },
                {
                  "mistake": "**Wrong environment variable prefix**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong environment variable prefix**:\n   ```javascript\n   // WRONG! Won't work in Vite\n   const API_URL = process.env.REACT_APP_API_URL;  // ✗\n   const API_URL = process.env.API_URL;             // ✗\n   \n   // CORRECT for Vite!\n   const API_URL = import.meta.env.VITE_API_URL;   // ✓\n   ```"
                },
                {
                  "mistake": "**Hardcoded API URL**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Hardcoded API URL**:\n   ```javascript\n   // WRONG! Won't work after deployment\n   fetch('http://localhost:3000/api/users');  // ✗\n   \n   // CORRECT!\n   const API_URL = import.meta.env.VITE_API_URL;\n   fetch(`${API_URL}/api/users`);  // ✓\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14.4",
          "title": "Environment Variables in Production (The Secret Recipe Analogy)",
          "moduleId": "module-14",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you own a restaurant chain:\n\nBad approach (hardcoded secrets):\n- Write secret sauce recipe directly in the cookbook\n- Every employee gets a copy\n- Recipe is in every branch location\n- Employee leaves → they have your secrets!\n- Want to change recipe → reprint all cookbooks!\n\nGood approach (environment variables):\n- Cookbook says: \"Use the secret sauce (see manager)\"\n- Each location stores recipe in a safe\n- Only managers have the combination\n- Employee leaves → recipe stays safe\n- Change recipe → just update the safe\n\nEnvironment variables work the same way:\n- Code says: process.env.DATABASE_PASSWORD\n- Secret stored separately (not in code!)\n- Different value per environment (dev vs prod)\n- Change secrets without changing code\n- Never committed to Git (safe!)\n\nThink of env vars as a safe for your app's secrets!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Environment Variables - Concepts\n\nconsole.log('=== Environment Variables ===\\n');\n\n// CONCEPT: Separating Code from Configuration\n\n// BAD: Hardcoded secrets (NEVER DO THIS!)\nconst badExample = {\n  database: 'postgres://admin:super_secret_password@db.com/prod',\n  jwtSecret: 'my-secret-key-12345',\n  stripeKey: 'sk_live_abc123xyz',\n  apiKey: 'secret-api-key-do-not-share'\n};\n\nconsole.log('❌ WRONG - Hardcoded Secrets:\\n');\nObject.entries(badExample).forEach(([key, value]) => {\n  console.log(`const ${key} = '${value}';`);\n});\n\nconsole.log('\\nProblems:');\nconst problems = [\n  '✗ Secrets visible in Git history forever',\n  '✗ Everyone with code access sees secrets',\n  '✗ Different environments need different values',\n  '✗ Changing secrets requires code changes',\n  '✗ Accidental public repository = leaked secrets!'\n];\nproblems.forEach(p => console.log(`  ${p}`));\n\n// GOOD: Environment variables\nconsole.log('\\n\\n✅ CORRECT - Environment Variables:\\n');\n\nconst goodExample = {\n  database: process.env.DATABASE_URL,\n  jwtSecret: process.env.JWT_SECRET,\n  stripeKey: process.env.STRIPE_SECRET_KEY,\n  apiKey: process.env.API_KEY\n};\n\nObject.entries(goodExample).forEach(([key, value]) => {\n  console.log(`const ${key} = process.env.${value.replace('process.env.', '')};`);\n});\n\nconsole.log('\\nBenefits:');\nconst benefits = [\n  '✓ Secrets never in code or Git',\n  '✓ Different values per environment',\n  '✓ Change secrets without code changes',\n  '✓ Secure storage on hosting platforms',\n  '✓ Easy to rotate credentials'\n];\nbenefits.forEach(b => console.log(`  ${b}`));\n\n// CONCEPT: Different Environments\nconsole.log('\\n\\n=== Multi-Environment Setup ===\\n');\n\nconst environments = {\n  development: {\n    NODE_ENV: 'development',\n    DATABASE_URL: 'postgres://localhost/myapp_dev',\n    API_URL: 'http://localhost:3000',\n    JWT_SECRET: 'dev-secret-ok-to-be-simple',\n    DEBUG: 'true',\n    LOG_LEVEL: 'debug'\n  },\n  \n  staging: {\n    NODE_ENV: 'staging',\n    DATABASE_URL: 'postgres://staging-db.internal/myapp_staging',\n    API_URL: 'https://staging-api.myapp.com',\n    JWT_SECRET: 'complex-staging-secret-xyz789',\n    DEBUG: 'false',\n    LOG_LEVEL: 'info'\n  },\n  \n  production: {\n    NODE_ENV: 'production',\n    DATABASE_URL: 'postgres://prod-db.aws.com/myapp_prod',\n    API_URL: 'https://api.myapp.com',\n    JWT_SECRET: 'super-complex-production-secret-abc123xyz',\n    DEBUG: 'false',\n    LOG_LEVEL: 'error'\n  }\n};\n\nObject.entries(environments).forEach(([env, vars]) => {\n  console.log(`${env.toUpperCase()} Environment:`);\n  Object.entries(vars).forEach(([key, value]) => {\n    // Mask secrets\n    let displayValue = value;\n    if (key.includes('SECRET') || key.includes('PASSWORD')) {\n      displayValue = value.substring(0, 8) + '...[hidden]';\n    }\n    console.log(`  ${key}=${displayValue}`);\n  });\n  console.log('');\n});\n\n// SIMULATING ENVIRONMENT VARIABLE USAGE\nconsole.log('=== Using Environment Variables ===\\n');\n\nclass AppConfig {\n  constructor() {\n    // Simulate process.env\n    this.env = process.env;\n    \n    // Required variables\n    this.requiredVars = [\n      'DATABASE_URL',\n      'JWT_SECRET',\n      'NODE_ENV'\n    ];\n  }\n  \n  validate() {\n    console.log('Validating environment variables...\\n');\n    \n    const missing = [];\n    \n    this.requiredVars.forEach(varName => {\n      if (!this.env[varName]) {\n        missing.push(varName);\n      }\n    });\n    \n    if (missing.length > 0) {\n      console.log('❌ Missing required environment variables:');\n      missing.forEach(v => console.log(`  - ${v}`));\n      console.log('\\nApp cannot start without these variables!\\n');\n      return false;\n    } else {\n      console.log('✅ All required environment variables present\\n');\n      return true;\n    }\n  }\n  \n  get(key, fallback = null) {\n    const value = this.env[key];\n    if (!value && fallback !== null) {\n      console.log(`⚠ ${key} not set, using fallback: ${fallback}`);\n      return fallback;\n    }\n    return value;\n  }\n  \n  showConfig() {\n    console.log('Current Configuration:');\n    console.log(`  Environment: ${this.get('NODE_ENV', 'development')}`);\n    console.log(`  Database: ${this.maskSecret(this.get('DATABASE_URL', 'Not set'))}`);\n    console.log(`  JWT Secret: ${this.maskSecret(this.get('JWT_SECRET', 'Not set'))}`);\n    console.log(`  Port: ${this.get('PORT', '3000')}`);\n    console.log(`  Debug: ${this.get('DEBUG', 'false')}\\n`);\n  }\n  \n  maskSecret(value) {\n    if (!value || value === 'Not set') return value;\n    if (value.length < 10) return '***';\n    return value.substring(0, 10) + '...[hidden]';\n  }\n}\n\n// Test with development environment\nprocess.env.NODE_ENV = 'development';\nprocess.env.DATABASE_URL = 'postgres://localhost/myapp_dev';\nprocess.env.JWT_SECRET = 'dev-secret';\nprocess.env.PORT = '3000';\n\nconst config = new AppConfig();\nconfig.validate();\nconfig.showConfig();\n\n// BEST PRACTICES\nconsole.log('=== Environment Variable Best Practices ===\\n');\n\nconst bestPractices = [\n  {\n    rule: '1. Never commit secrets to Git',\n    example: 'Add .env to .gitignore immediately!'\n  },\n  {\n    rule: '2. Use descriptive names',\n    example: 'DATABASE_URL (good) vs DB (bad)'\n  },\n  {\n    rule: '3. Provide .env.example',\n    example: 'Template showing what vars are needed (no real values!)'\n  },\n  {\n    rule: '4. Validate on startup',\n    example: 'Crash early if required vars missing'\n  },\n  {\n    rule: '5. Use different values per environment',\n    example: 'dev-simple-secret vs prod-complex-secret-xyz789'\n  },\n  {\n    rule: '6. Rotate secrets regularly',\n    example: 'Change JWT_SECRET every few months'\n  },\n  {\n    rule: '7. Document all variables',\n    example: 'README lists all env vars and what they do'\n  }\n];\n\nbestPractices.forEach(({ rule, example }) => {\n  console.log(rule);\n  console.log(`   → ${example}\\n`);\n});\n\n// COMMON VARIABLES\nconsole.log('=== Common Environment Variables ===\\n');\n\nconst commonVars = {\n  'NODE_ENV': 'development | production | test',\n  'PORT': 'Server port (3000, 8080, etc.)',\n  'DATABASE_URL': 'Full database connection string',\n  'JWT_SECRET': 'Secret key for signing tokens',\n  'API_KEY': 'Third-party API keys',\n  'STRIPE_SECRET_KEY': 'Payment processing key',\n  'AWS_ACCESS_KEY_ID': 'AWS credentials',\n  'SMTP_HOST': 'Email server settings',\n  'CORS_ORIGIN': 'Allowed frontend URLs',\n  'LOG_LEVEL': 'debug | info | warn | error'\n};\n\nObject.entries(commonVars).forEach(([name, description]) => {\n  console.log(`${name.padEnd(20)} - ${description}`);\n});"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Environment variables in practice:\n\n1. **Development (.env file)**:\n   ```bash\n   # .env (local development only, never commit!)\n   NODE_ENV=development\n   PORT=3000\n   DATABASE_URL=postgres://localhost/myapp_dev\n   JWT_SECRET=dev-secret-simple-is-ok\n   STRIPE_SECRET_KEY=sk_test_abc123\n   FRONTEND_URL=http://localhost:5173\n   ```\n\n2. **Loading .env file** (using dotenv):\n   ```javascript\n   // At the very top of server.js\n   import 'dotenv/config';\n   // or\n   require('dotenv').config();\n   \n   // Now process.env has your variables!\n   console.log(process.env.DATABASE_URL);\n   ```\n\n3. **Using environment variables**:\n   ```javascript\n   // Good pattern with fallbacks\n   const PORT = process.env.PORT || 3000;\n   const NODE_ENV = process.env.NODE_ENV || 'development';\n   \n   // Required variables (no fallback)\n   const DATABASE_URL = process.env.DATABASE_URL;\n   if (!DATABASE_URL) {\n     throw new Error('DATABASE_URL environment variable is required!');\n   }\n   \n   // Type conversion\n   const MAX_CONNECTIONS = parseInt(process.env.MAX_CONNECTIONS || '10', 10);\n   const ENABLE_DEBUG = process.env.ENABLE_DEBUG === 'true';\n   ```\n\n4. **Validation helper**:\n   ```javascript\n   function requireEnv(name) {\n     const value = process.env[name];\n     if (!value) {\n       throw new Error(`Missing required environment variable: ${name}`);\n     }\n     return value;\n   }\n   \n   // Usage\n   const DATABASE_URL = requireEnv('DATABASE_URL');\n   const JWT_SECRET = requireEnv('JWT_SECRET');\n   ```\n\n5. **.env.example** (commit this!):\n   ```bash\n   # .env.example - Template for other developers\n   # Copy this to .env and fill in real values\n   \n   NODE_ENV=development\n   PORT=3000\n   DATABASE_URL=postgres://localhost/myapp_dev\n   JWT_SECRET=your-secret-here\n   STRIPE_SECRET_KEY=sk_test_your-key\n   ```\n\n6. **.gitignore** (CRITICAL!):\n   ```\n   # Never commit these!\n   .env\n   .env.local\n   .env.development\n   .env.production\n   .env.test\n   \n   # DO commit this:\n   # .env.example\n   ```\n\n7. **Setting in Render (Backend)**:\n   ```\n   Render Dashboard:\n   1. Go to your web service\n   2. Click \"Environment\"\n   3. Add variables:\n      DATABASE_URL = postgres://...\n      JWT_SECRET = your-production-secret\n      NODE_ENV = production\n   4. Save (triggers redeploy)\n   ```\n\n8. **Setting in Vercel (Frontend)**:\n   ```\n   Vercel Dashboard:\n   1. Project Settings → Environment Variables\n   2. Add variables (must start with VITE_):\n      VITE_API_URL = https://api.myapp.com\n      VITE_STRIPE_PUBLIC_KEY = pk_live_...\n   3. Redeploy to apply changes\n   ```\n\n9. **Environment-specific logic**:\n   ```javascript\n   const isDevelopment = process.env.NODE_ENV === 'development';\n   const isProduction = process.env.NODE_ENV === 'production';\n   \n   if (isDevelopment) {\n     // Detailed logging\n     console.log('Full error:', error.stack);\n     \n     // Allow all CORS in dev\n     app.use(cors({ origin: '*' }));\n   }\n   \n   if (isProduction) {\n     // Hide error details\n     console.log('Error occurred');\n     \n     // Strict CORS\n     app.use(cors({ origin: process.env.FRONTEND_URL }));\n   }\n   ```\n\n10. **Configuration module pattern**:\n    ```javascript\n    // config/index.js\n    export const config = {\n      env: process.env.NODE_ENV || 'development',\n      port: parseInt(process.env.PORT || '3000', 10),\n      \n      database: {\n        url: process.env.DATABASE_URL,\n        poolSize: parseInt(process.env.DB_POOL_SIZE || '10', 10)\n      },\n      \n      jwt: {\n        secret: process.env.JWT_SECRET,\n        expiresIn: process.env.JWT_EXPIRES || '7d'\n      },\n      \n      stripe: {\n        secretKey: process.env.STRIPE_SECRET_KEY,\n        webhookSecret: process.env.STRIPE_WEBHOOK_SECRET\n      },\n      \n      cors: {\n        origin: process.env.CORS_ORIGIN || 'http://localhost:5173'\n      }\n    };\n    \n    // Validate on import\n    const required = ['DATABASE_URL', 'JWT_SECRET'];\n    required.forEach(key => {\n      if (!process.env[key]) {\n        throw new Error(`Missing required env var: ${key}`);\n      }\n    });\n    ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common environment variable mistakes:\n\n1. **Committing .env to Git** (MAJOR security issue!):\n   ```bash\n   # Check if .env is tracked:\n   git ls-files | grep .env\n   \n   # If it returns .env, you've committed secrets!\n   # Fix immediately:\n   git rm --cached .env\n   echo \".env\" >> .gitignore\n   git commit -m \"Remove .env from git\"\n   \n   # If already pushed to GitHub:\n   # 1. Rotate all secrets immediately!\n   # 2. Consider the secrets compromised\n   ```\n\n2. **Forgot to load dotenv**:\n   ```javascript\n   // Error: process.env.DATABASE_URL is undefined\n   \n   // Fix: Load dotenv at the very top\n   import 'dotenv/config';  // Must be first!\n   import express from 'express';\n   \n   // or\n   require('dotenv').config();  // Must be first!\n   const express = require('express');\n   ```\n\n3. **Wrong variable names** (typos):\n   ```javascript\n   // .env\n   DATABASE_URL=postgres://...\n   \n   // server.js\n   const db = process.env.DATABSE_URL;  // ✗ Typo! Returns undefined\n   const db = process.env.DATABASE_URL;  // ✓ Correct\n   \n   // Tip: Use constants to avoid typos\n   const REQUIRED_VARS = ['DATABASE_URL', 'JWT_SECRET'];\n   ```\n\n4. **Not updating production env vars**:\n   ```\n   Changed .env locally but forgot to update Render!\n   \n   Fix:\n   1. Update .env → works locally\n   2. Update Render Environment Variables → works in production\n   3. Must update BOTH places!\n   ```\n\n5. **Hardcoded fallbacks for secrets**:\n   ```javascript\n   // WRONG! Production will use insecure fallback\n   const JWT_SECRET = process.env.JWT_SECRET || 'default-secret';  // ✗\n   \n   // CORRECT! Fail if secret is missing\n   const JWT_SECRET = process.env.JWT_SECRET;\n   if (!JWT_SECRET) {\n     throw new Error('JWT_SECRET environment variable is required!');\n   }\n   ```\n\n6. **Type confusion** (everything is a string!):\n   ```javascript\n   // WRONG! process.env values are always strings\n   const PORT = process.env.PORT;  // \"3000\" (string)\n   app.listen(PORT);  // Works but technically wrong type\n   \n   const MAX = process.env.MAX_ITEMS;  // \"10\" (string)\n   if (items.length > MAX) // ✗ String comparison!\n   \n   // CORRECT! Convert types explicitly\n   const PORT = parseInt(process.env.PORT || '3000', 10);  // number\n   const MAX = parseInt(process.env.MAX_ITEMS || '10', 10);  // number\n   const DEBUG = process.env.DEBUG === 'true';  // boolean\n   ```\n\n7. **Exposing env vars in frontend** (React/Vite):\n   ```javascript\n   // Backend (.env) - These are SECRET!\n   DATABASE_URL=postgres://...\n   JWT_SECRET=super-secret\n   STRIPE_SECRET_KEY=sk_live_...\n   \n   // Frontend (.env) - These are PUBLIC!\n   VITE_API_URL=https://api.com\n   VITE_STRIPE_PUBLIC_KEY=pk_live_...  // Note: PUBLIC key\n   \n   // Remember: VITE_ vars are bundled into JavaScript\n   // Anyone can see them in browser!\n   // NEVER put secrets in VITE_ variables!\n   ```\n\n8. **Missing .env.example**:\n   ```bash\n   # Create .env.example (commit this!)\n   # Other developers copy this to .env\n   \n   # .env.example\n   NODE_ENV=development\n   PORT=3000\n   DATABASE_URL=postgres://localhost/myapp_dev\n   JWT_SECRET=your-secret-here\n   STRIPE_SECRET_KEY=sk_test_your-key\n   \n   # Instructions for new developers:\n   # 1. Copy .env.example to .env\n   # 2. Fill in real values\n   # 3. Never commit .env!\n   ```\n\n9. **Environment variables not rebuilding**:\n   ```\n   React/Vite issue:\n   - Changed VITE_API_URL in Vercel\n   - Still seeing old value!\n   \n   Why: Env vars are baked into build at build time\n   \n   Fix:\n   1. Change env var in Vercel dashboard\n   2. Trigger new deployment (Deployments → Redeploy)\n   3. Env vars from build time are used, not runtime!\n   ```\n\n10. **Different formats on different platforms**:\n    ```bash\n    # .env file format (local)\n    DATABASE_URL=postgres://localhost/db\n    NODE_ENV=development\n    \n    # Render format (same!)\n    DATABASE_URL = postgres://render.com/db\n    NODE_ENV = production\n    \n    # Note: Render adds spaces around =, both work fine\n    # Just be consistent in your .env file\n    ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14.4-challenge",
              "title": "Practice Challenge",
              "description": "Create an environment configuration system:\n\n1. Create a `Config` class that:\n   - Loads variables from process.env\n   - Validates required variables\n   - Provides get() method with fallbacks\n   - Masks secrets when displaying\n\n2. Test with sample environment variables",
              "instructions": "Create an environment configuration system:\n\n1. Create a `Config` class that:\n   - Loads variables from process.env\n   - Validates required variables\n   - Provides get() method with fallbacks\n   - Masks secrets when displaying\n\n2. Test with sample environment variables",
              "starterCode": "// Environment configuration manager\n\nclass Config {\n  constructor() {\n    this.required = ['DATABASE_URL', 'JWT_SECRET'];\n  }\n  \n  validate() {\n    const missing = this.required.filter(key => !process.env[key]);\n    \n    if (missing.length > 0) {\n      console.log('❌ Missing required variables:');\n      missing.forEach(v => console.log(`  - ${v}`));\n      return false;\n    }\n    \n    console.log('✅ All required variables present');\n    return true;\n  }\n  \n  get(key, fallback = null) {\n    return process.env[key] || fallback;\n  }\n  \n  maskSecret(value) {\n    if (!value || value.length < 8) return '***';\n    return value.substring(0, 8) + '...';\n  }\n  \n  show() {\n    console.log('\\nConfiguration:');\n    console.log(`  NODE_ENV: ${this.get('NODE_ENV', 'development')}`);\n    console.log(`  PORT: ${this.get('PORT', '3000')}`);\n    console.log(`  DATABASE: ${this.maskSecret(this.get('DATABASE_URL', 'not set'))}`);\n    console.log(`  JWT_SECRET: ${this.maskSecret(this.get('JWT_SECRET', 'not set'))}`);\n  }\n}\n\n// Test\nprocess.env.NODE_ENV = 'production';\nprocess.env.PORT = '8080';\nprocess.env.DATABASE_URL = 'postgres://prod-db.com/myapp';\nprocess.env.JWT_SECRET = 'super-secret-key-xyz';\n\nconst config = new Config();\nconfig.validate();\nconfig.show();",
              "solution": "// Complete environment configuration system\n\nclass Config {\n  constructor() {\n    // Define required variables\n    this.required = [\n      'NODE_ENV',\n      'DATABASE_URL',\n      'JWT_SECRET'\n    ];\n    \n    // Define optional variables with defaults\n    this.defaults = {\n      PORT: '3000',\n      LOG_LEVEL: 'info',\n      CORS_ORIGIN: 'http://localhost:5173',\n      JWT_EXPIRES: '7d'\n    };\n    \n    this.env = process.env;\n  }\n  \n  validate() {\n    console.log('🔍 Validating environment configuration...\\n');\n    \n    const missing = [];\n    const present = [];\n    \n    this.required.forEach(key => {\n      if (!this.env[key]) {\n        missing.push(key);\n      } else {\n        present.push(key);\n      }\n    });\n    \n    if (present.length > 0) {\n      console.log('✅ Found required variables:');\n      present.forEach(v => console.log(`  ✓ ${v}`));\n      console.log('');\n    }\n    \n    if (missing.length > 0) {\n      console.log('❌ Missing required variables:');\n      missing.forEach(v => console.log(`  ✗ ${v}`));\n      console.log('\\n⚠ Application cannot start without these variables!\\n');\n      return false;\n    }\n    \n    console.log('✅ All required environment variables present!\\n');\n    return true;\n  }\n  \n  get(key, fallback = null) {\n    let value = this.env[key];\n    \n    // Use default if available\n    if (!value && this.defaults[key]) {\n      value = this.defaults[key];\n    }\n    \n    // Use provided fallback\n    if (!value && fallback !== null) {\n      value = fallback;\n    }\n    \n    return value;\n  }\n  \n  getInt(key, fallback = 0) {\n    const value = this.get(key, fallback.toString());\n    return parseInt(value, 10);\n  }\n  \n  getBool(key, fallback = false) {\n    const value = this.get(key, fallback.toString());\n    return value === 'true' || value === '1';\n  }\n  \n  isProduction() {\n    return this.get('NODE_ENV') === 'production';\n  }\n  \n  isDevelopment() {\n    return this.get('NODE_ENV') === 'development';\n  }\n  \n  maskSecret(value) {\n    if (!value || value === 'not set') return value;\n    if (value.length < 8) return '***';\n    return value.substring(0, 8) + '...[hidden]';\n  }\n  \n  show() {\n    console.log('┌─────────────────────────────────────┐');\n    console.log('│     Environment Configuration        │');\n    console.log('└─────────────────────────────────────┘\\n');\n    \n    console.log('General:');\n    console.log(`  NODE_ENV:     ${this.get('NODE_ENV')}`);\n    console.log(`  PORT:         ${this.get('PORT')}`);\n    console.log(`  LOG_LEVEL:    ${this.get('LOG_LEVEL')}\\n`);\n    \n    console.log('Database:');\n    console.log(`  DATABASE_URL: ${this.maskSecret(this.get('DATABASE_URL', 'not set'))}\\n`);\n    \n    console.log('Security:');\n    console.log(`  JWT_SECRET:   ${this.maskSecret(this.get('JWT_SECRET', 'not set'))}`);\n    console.log(`  JWT_EXPIRES:  ${this.get('JWT_EXPIRES')}\\n`);\n    \n    console.log('CORS:');\n    console.log(`  CORS_ORIGIN:  ${this.get('CORS_ORIGIN')}\\n`);\n    \n    if (this.isProduction()) {\n      console.log('🚀 Running in PRODUCTION mode');\n    } else {\n      console.log('🔧 Running in DEVELOPMENT mode');\n    }\n    \n    console.log('\\n' + '═'.repeat(39) + '\\n');\n  }\n  \n  toObject() {\n    return {\n      env: this.get('NODE_ENV'),\n      port: this.getInt('PORT'),\n      logLevel: this.get('LOG_LEVEL'),\n      \n      database: {\n        url: this.get('DATABASE_URL')\n      },\n      \n      jwt: {\n        secret: this.get('JWT_SECRET'),\n        expiresIn: this.get('JWT_EXPIRES')\n      },\n      \n      cors: {\n        origin: this.get('CORS_ORIGIN')\n      }\n    };\n  }\n}\n\n// Simulate different environments\nconsole.log('=== Testing Environment Configurations ===\\n');\n\n// Test 1: Development\nconsole.log('Test 1: Development Environment\\n');\nprocess.env.NODE_ENV = 'development';\nprocess.env.PORT = '3000';\nprocess.env.DATABASE_URL = 'postgres://localhost/myapp_dev';\nprocess.env.JWT_SECRET = 'dev-secret-simple';\n\nlet config = new Config();\nconfig.validate();\nconfig.show();\n\n// Test 2: Production\nconsole.log('\\nTest 2: Production Environment\\n');\nprocess.env.NODE_ENV = 'production';\nprocess.env.PORT = '8080';\nprocess.env.DATABASE_URL = 'postgres://prod.aws.com/myapp';\nprocess.env.JWT_SECRET = 'super-complex-prod-secret-xyz789';\nprocess.env.LOG_LEVEL = 'error';\nprocess.env.CORS_ORIGIN = 'https://myapp.com';\n\nconfig = new Config();\nconfig.validate();\nconfig.show();\n\n// Test 3: Missing required variable\nconsole.log('\\nTest 3: Missing Required Variable\\n');\ndelete process.env.JWT_SECRET;\n\nconfig = new Config();\nconst isValid = config.validate();\n\nif (!isValid) {\n  console.log('Cannot start application. Please set missing variables.\\n');\n}\n\n// Best practices guide\nconsole.log('\\n=== Environment Variable Best Practices ===\\n');\n\nconst guide = [\n  {\n    do: '✓ Use .env for local development',\n    dont: '✗ Commit .env to Git'\n  },\n  {\n    do: '✓ Provide .env.example template',\n    dont: '✗ Put real secrets in .env.example'\n  },\n  {\n    do: '✓ Validate required vars on startup',\n    dont: \"✗ Let app crash with 'undefined' errors\"\n  },\n  {\n    do: '✓ Use descriptive variable names',\n    dont: '✗ Use vague names like SECRET or KEY'\n  },\n  {\n    do: '✓ Different secrets per environment',\n    dont: '✗ Reuse dev secrets in production'\n  },\n  {\n    do: '✓ Document all variables in README',\n    dont: '✗ Leave developers guessing'\n  }\n];\n\nguide.forEach(({ do: good, dont: bad }) => {\n  console.log(good);\n  console.log(bad);\n  console.log('');\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should detect missing required variables",
                  "expectedOutput": "false (missing JWT_SECRET)",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use process.env to access environment variables"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common environment variable mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common environment variable mistakes:"
                },
                {
                  "mistake": "**Committing .env to Git** (MAJOR security issue!):",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Committing .env to Git** (MAJOR security issue!):\n   ```bash\n   # Check if .env is tracked:\n   git ls-files | grep .env\n   \n   # If it returns .env, you've committed secrets!\n   # Fix immediately:\n   git rm --cached .env\n   echo \".env\" >> .gitignore\n   git commit -m \"Remove .env from git\"\n   \n   # If already pushed to GitHub:\n   # 1. Rotate all secrets immediately!\n   # 2. Consider the secrets compromised\n   ```"
                },
                {
                  "mistake": "**Forgot to load dotenv**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgot to load dotenv**:\n   ```javascript\n   // Error: process.env.DATABASE_URL is undefined\n   \n   // Fix: Load dotenv at the very top\n   import 'dotenv/config';  // Must be first!\n   import express from 'express';\n   \n   // or\n   require('dotenv').config();  // Must be first!\n   const express = require('express');\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14.5",
          "title": "CI/CD with GitHub Actions (The Assembly Line Analogy)",
          "moduleId": "module-14",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a car factory assembly line:\n\nWithout automation (manual deployment):\n- Workers manually check each part\n- Someone forgets to test the brakes\n- Defective cars reach customers\n- Recalls are expensive and embarrassing\n- Inconsistent quality between shifts\n\nWith assembly line automation (CI/CD):\n- Robots test EVERY car automatically\n- Defects caught before shipping\n- Consistent quality every time\n- Faster production\n- Workers focus on improvements, not repetitive checks\n\nCI/CD (Continuous Integration / Continuous Deployment):\n- CI: Automatically test every code change\n- CD: Automatically deploy when tests pass\n- GitHub Actions: The robots that run your pipeline\n\nWith Bun, your CI/CD is FAST:\n- bun install: 10x faster than npm\n- bun test: Native test runner, blazing speed\n- Less waiting = more shipping\n\nEvery push triggers: Install → Test → Build → Deploy\nNo manual steps, no forgotten tests, no broken deployments!"
            },
            {
              "type": "EXAMPLE",
              "title": "GitHub Actions with Bun",
              "content": "A complete CI/CD pipeline that runs on every push using Bun for maximum speed.",
              "language": "yaml",
              "code": "# .github/workflows/ci.yml\n# CI/CD Pipeline with Bun - runs on every push\n\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    name: Test & Build\n    runs-on: ubuntu-latest\n    \n    steps:\n      # 1. Check out the code\n      - name: Checkout repository\n        uses: actions/checkout@v4\n      \n      # 2. Set up Bun (instead of Node.js!)\n      - name: Setup Bun\n        uses: oven-sh/setup-bun@v1\n        with:\n          bun-version: latest\n      \n      # 3. Install dependencies (10x faster than npm!)\n      - name: Install dependencies\n        run: bun install\n      \n      # 4. Run linting\n      - name: Lint code\n        run: bun run lint\n      \n      # 5. Run tests\n      - name: Run tests\n        run: bun test\n      \n      # 6. Build the project\n      - name: Build\n        run: bun run build\n      \n      # 7. Upload build artifacts\n      - name: Upload build\n        uses: actions/upload-artifact@v4\n        with:\n          name: build\n          path: dist/\n\n  deploy:\n    name: Deploy to Production\n    needs: test  # Only runs if tests pass!\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'  # Only on main branch\n    \n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n      \n      - name: Download build\n        uses: actions/download-artifact@v4\n        with:\n          name: build\n          path: dist/\n      \n      - name: Deploy to Render\n        run: |\n          curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}\n        # Or deploy to Cloudflare Workers:\n        # - name: Deploy to Workers\n        #   run: bunx wrangler deploy"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding the GitHub Actions workflow with Bun:\n\n1. **Workflow File Location**:\n   ```\n   .github/workflows/ci.yml\n   \n   GitHub automatically detects YAML files here and runs them\n   ```\n\n2. **Triggers (on)**:\n   ```yaml\n   on:\n     push:\n       branches: [main, develop]  # Run on push to these branches\n     pull_request:\n       branches: [main]           # Run on PRs to main\n   ```\n\n3. **Setting up Bun** (key difference from npm!):\n   ```yaml\n   - name: Setup Bun\n     uses: oven-sh/setup-bun@v1\n     with:\n       bun-version: latest\n   ```\n\n4. **Bun Commands** (faster than npm!):\n   ```yaml\n   # Install dependencies (10x faster)\n   - run: bun install\n   \n   # Run tests (native test runner)\n   - run: bun test\n   \n   # Build project\n   - run: bun run build\n   \n   # Run scripts from package.json\n   - run: bun run lint\n   ```\n\n5. **Job Dependencies** (deploy only if tests pass):\n   ```yaml\n   deploy:\n     needs: test  # Wait for test job to succeed\n     if: github.ref == 'refs/heads/main'  # Only on main\n   ```\n\n6. **Secrets** (never hardcode!):\n   ```yaml\n   - run: curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}\n   \n   # Add secrets in: GitHub → Repo → Settings → Secrets\n   ```\n\n7. **Caching** (speed up future runs):\n   ```yaml\n   - name: Cache Bun dependencies\n     uses: actions/cache@v4\n     with:\n       path: ~/.bun/install/cache\n       key: ${{ runner.os }}-bun-${{ hashFiles('bun.lockb') }}\n   ```\n\n8. **Matrix Testing** (test multiple versions):\n   ```yaml\n   strategy:\n     matrix:\n       bun-version: ['1.0', '1.1', 'latest']\n   steps:\n     - uses: oven-sh/setup-bun@v1\n       with:\n         bun-version: ${{ matrix.bun-version }}\n   ```\n\n9. **Package.json Scripts for CI**:\n   ```json\n   {\n     \"scripts\": {\n       \"test\": \"bun test\",\n       \"lint\": \"bunx biome check .\",\n       \"build\": \"bun run build:app\",\n       \"typecheck\": \"bunx tsc --noEmit\"\n     }\n   }\n   ```\n\n10. **Complete CI Pipeline Order**:\n    ```\n    1. Checkout code (actions/checkout)\n    2. Setup Bun (oven-sh/setup-bun)\n    3. Install dependencies (bun install)\n    4. Lint code (bun run lint)\n    5. Type check (bunx tsc --noEmit)\n    6. Run tests (bun test)\n    7. Build (bun run build)\n    8. Deploy (if main branch and tests pass)\n    ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common CI/CD mistakes:\n\n1. **Using npm instead of bun**:\n   ```yaml\n   # WRONG! Slow installs\n   - run: npm install\n   - run: npm test\n   \n   # CORRECT! 10x faster\n   - uses: oven-sh/setup-bun@v1\n   - run: bun install\n   - run: bun test\n   ```\n\n2. **Deploying on failed tests**:\n   ```yaml\n   # WRONG! Deploy runs even if tests fail\n   jobs:\n     test:\n       ...\n     deploy:\n       ...  # No dependency!\n   \n   # CORRECT! Deploy waits for test\n   jobs:\n     test:\n       ...\n     deploy:\n       needs: test  # Only if test succeeds!\n   ```\n\n3. **Secrets in code**:\n   ```yaml\n   # WRONG! Never do this\n   - run: curl -X POST https://api.render.com/hooks/abc123\n   \n   # CORRECT! Use GitHub secrets\n   - run: curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}\n   \n   # Add in: Settings → Secrets → Actions\n   ```\n\n4. **Missing workflow file**:\n   ```\n   Correct location:\n   .github/workflows/ci.yml\n   \n   NOT:\n   - github/workflows/ci.yml (missing dot)\n   - .github/workflow/ci.yml (singular)\n   - workflows/ci.yml (wrong folder)\n   ```\n\n5. **Deploying every branch**:\n   ```yaml\n   # WRONG! Deploys on every push\n   deploy:\n     ...\n   \n   # CORRECT! Only deploy main\n   deploy:\n     if: github.ref == 'refs/heads/main'\n   ```\n\n6. **Not caching dependencies**:\n   ```yaml\n   # Add caching for faster builds\n   - name: Cache Bun\n     uses: actions/cache@v4\n     with:\n       path: ~/.bun/install/cache\n       key: ${{ runner.os }}-bun-${{ hashFiles('bun.lockb') }}\n   ```\n\n7. **No test coverage requirements**:\n   ```yaml\n   # Add coverage check\n   - name: Run tests with coverage\n     run: bun test --coverage\n   \n   # Fail if coverage too low\n   - run: bun run check-coverage\n   ```\n\n8. **Ignoring PR checks**:\n   ```yaml\n   # Always run on PRs!\n   on:\n     pull_request:\n       branches: [main]\n   \n   # Catch bugs BEFORE merging\n   ```"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "npm/Node.js Equivalent",
              "legacy": "npm",
              "content": "Here's the same CI/CD workflow using traditional npm and Node.js. Notice the slower install times and different setup.",
              "code": "# .github/workflows/ci.yml (npm version)\nname: CI/CD Pipeline (npm)\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      # Node.js setup (instead of Bun)\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      \n      # npm install (slower than bun)\n      - name: Install dependencies\n        run: npm ci\n      \n      # Run tests with npm\n      - run: npm run lint\n      - run: npm test\n      - run: npm run build\n      \n      - uses: actions/upload-artifact@v4\n        with:\n          name: build\n          path: dist/\n\n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    steps:\n      - uses: actions/checkout@v4\n      - run: curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}\n\n# Key Differences:\n# - setup-node instead of oven-sh/setup-bun\n# - npm ci instead of bun install (slower)\n# - npm test instead of bun test\n# - Separate test runner (Jest/Vitest vs bun test)\n# - Build times typically 2-5x slower",
              "language": "yaml"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14.5-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a CI/CD pipeline:\n\n1. Create a `CIPipeline` class that:\n   - Runs steps in order (checkout, install, test, build, deploy)\n   - Stops if any step fails\n   - Shows timing for each step\n   - Only deploys if on 'main' branch\n\n2. Simulate running the pipeline with both passing and failing tests",
              "instructions": "Simulate a CI/CD pipeline:\n\n1. Create a `CIPipeline` class that:\n   - Runs steps in order (checkout, install, test, build, deploy)\n   - Stops if any step fails\n   - Shows timing for each step\n   - Only deploys if on 'main' branch\n\n2. Simulate running the pipeline with both passing and failing tests",
              "starterCode": "// CI/CD Pipeline Simulation\n\nclass CIPipeline {\n  constructor(branch) {\n    this.branch = branch;\n    this.steps = [];\n    this.failed = false;\n  }\n  \n  runStep(name, action) {\n    if (this.failed) {\n      console.log(`  [SKIPPED] ${name}`);\n      return false;\n    }\n    \n    const startTime = Date.now();\n    console.log(`  [RUNNING] ${name}...`);\n    \n    const success = action();\n    const duration = Date.now() - startTime;\n    \n    if (success) {\n      console.log(`  [PASSED] ${name} (${duration}ms)`);\n    } else {\n      console.log(`  [FAILED] ${name}`);\n      this.failed = true;\n    }\n    \n    return success;\n  }\n  \n  run(testsShouldPass = true) {\n    console.log(`\\n=== CI Pipeline: ${this.branch} ===\\n`);\n    \n    this.runStep('Checkout', () => true);\n    this.runStep('bun install', () => true);\n    this.runStep('bun test', () => testsShouldPass);\n    this.runStep('bun run build', () => true);\n    \n    if (this.branch === 'main' && !this.failed) {\n      this.runStep('Deploy to Production', () => true);\n    } else if (this.branch !== 'main') {\n      console.log('  [INFO] Not main branch - skipping deploy');\n    }\n    \n    console.log(`\\n${this.failed ? 'Pipeline FAILED' : 'Pipeline PASSED'}\\n`);\n  }\n}\n\n// Test\nconst pipeline = new CIPipeline('main');\npipeline.run(true);",
              "solution": "// Complete CI/CD Pipeline Simulation\n\nclass CIPipeline {\n  constructor(branch) {\n    this.branch = branch;\n    this.steps = [];\n    this.failed = false;\n    this.totalTime = 0;\n  }\n  \n  runStep(name, action, simulatedTime = 100) {\n    if (this.failed) {\n      console.log(`  [SKIPPED] ${name}`);\n      this.steps.push({ name, status: 'skipped', duration: 0 });\n      return false;\n    }\n    \n    const startTime = Date.now();\n    console.log(`  [RUNNING] ${name}...`);\n    \n    const success = action();\n    const duration = simulatedTime + Math.floor(Math.random() * 50);\n    this.totalTime += duration;\n    \n    if (success) {\n      console.log(`  [PASSED] ${name} (${duration}ms)`);\n      this.steps.push({ name, status: 'passed', duration });\n    } else {\n      console.log(`  [FAILED] ${name}`);\n      this.steps.push({ name, status: 'failed', duration });\n      this.failed = true;\n    }\n    \n    return success;\n  }\n  \n  run(testsShouldPass = true) {\n    console.log('\\n' + '='.repeat(50));\n    console.log(`CI Pipeline: ${this.branch}`);\n    console.log('='.repeat(50) + '\\n');\n    \n    console.log('Trigger: push to ' + this.branch);\n    console.log('Runner: ubuntu-latest\\n');\n    \n    // Job 1: Test & Build\n    console.log('Job: test');\n    console.log('-'.repeat(30));\n    \n    this.runStep('actions/checkout@v4', () => true, 50);\n    this.runStep('oven-sh/setup-bun@v1', () => true, 200);\n    this.runStep('bun install', () => true, 800);\n    this.runStep('bun run lint', () => true, 300);\n    this.runStep('bun test', () => testsShouldPass, 500);\n    this.runStep('bun run build', () => !this.failed, 600);\n    this.runStep('actions/upload-artifact@v4', () => !this.failed, 150);\n    \n    console.log('');\n    \n    // Job 2: Deploy (only on main and if tests pass)\n    if (this.branch === 'main') {\n      console.log('Job: deploy');\n      console.log('-'.repeat(30));\n      \n      if (!this.failed) {\n        this.runStep('Download artifact', () => true, 100);\n        this.runStep('Deploy to Render', () => true, 2000);\n        console.log('\\n  Deployed to: https://my-app.onrender.com');\n      } else {\n        console.log('  [BLOCKED] Deploy skipped - tests failed');\n      }\n    } else {\n      console.log(`Job: deploy`);\n      console.log('-'.repeat(30));\n      console.log(`  [SKIPPED] Only deploys on main branch`);\n    }\n    \n    // Summary\n    console.log('\\n' + '='.repeat(50));\n    console.log('PIPELINE SUMMARY');\n    console.log('='.repeat(50));\n    \n    const passed = this.steps.filter(s => s.status === 'passed').length;\n    const failed = this.steps.filter(s => s.status === 'failed').length;\n    const skipped = this.steps.filter(s => s.status === 'skipped').length;\n    \n    console.log(`\\nSteps: ${passed} passed, ${failed} failed, ${skipped} skipped`);\n    console.log(`Total time: ${this.totalTime}ms`);\n    console.log(`\\nResult: ${this.failed ? 'FAILED' : 'PASSED'}`);\n    \n    if (this.failed) {\n      const failedStep = this.steps.find(s => s.status === 'failed');\n      console.log(`\\nFailed at: ${failedStep.name}`);\n      console.log('Fix the failing tests before merging!');\n    } else if (this.branch === 'main') {\n      console.log('\\nDeployment successful!');\n    }\n    \n    console.log('\\n' + '='.repeat(50) + '\\n');\n  }\n}\n\n// Simulate different scenarios\nconsole.log('=== Scenario 1: Feature Branch (tests pass) ===');\nconst featurePipeline = new CIPipeline('feature/add-login');\nfeaturePipeline.run(true);\n\nconsole.log('=== Scenario 2: Main Branch (tests pass) ===');\nconst mainPipeline = new CIPipeline('main');\nmainPipeline.run(true);\n\nconsole.log('=== Scenario 3: Main Branch (tests FAIL) ===');\nconst failedPipeline = new CIPipeline('main');\nfailedPipeline.run(false);\n\n// CI/CD Best Practices\nconsole.log('=== CI/CD Best Practices with Bun ===\\n');\n\nconst bestPractices = [\n  '1. Use oven-sh/setup-bun@v1 for fast Bun setup',\n  '2. Cache ~/.bun/install/cache for faster installs',\n  '3. Add \"needs: test\" to deploy job',\n  '4. Only deploy on main: if: github.ref == refs/heads/main',\n  '5. Store secrets in GitHub Secrets, not code',\n  '6. Run tests on pull_request AND push',\n  '7. Use bun test --coverage for code coverage',\n  '8. Fail fast with continue-on-error: false'\n];\n\nbestPractices.forEach(p => console.log(p));\n\nconsole.log('\\nBun Advantages in CI:');\nconsole.log('- bun install: 10x faster than npm');\nconsole.log('- bun test: Native test runner, no setup');\nconsole.log('- Less CI minutes = lower costs!');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should stop pipeline on failed tests",
                  "expectedOutput": "Pipeline FAILED",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use a 'failed' flag to skip remaining steps when a step fails"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Deploying without checking test results",
                  "consequence": "Broken code gets deployed to production.",
                  "correction": "Add 'needs: test' to the deploy job so it only runs after tests pass."
                },
                {
                  "mistake": "Using npm instead of bun in CI",
                  "consequence": "CI runs 10x slower, wasting time and money.",
                  "correction": "Use oven-sh/setup-bun@v1 and bun commands for faster builds."
                },
                {
                  "mistake": "Hardcoding secrets in workflow files",
                  "consequence": "Secrets are exposed in your public repository.",
                  "correction": "Use ${{ secrets.SECRET_NAME }} and add secrets in GitHub Settings."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-15",
      "title": "Module 15: Testing JavaScript with Bun",
      "description": "Learn to write reliable tests using Bun's built-in test runner - zero config, blazing fast",
      "difficulty": "intermediate",
      "estimatedHours": 4,
      "lessons": [
        {
          "id": "15.1",
          "title": "Why Testing Matters",
          "moduleId": "module-15",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Test Pyramid",
              "content": "Testing is like quality control in manufacturing. Before shipping a product, you check it works.\n\nThe Test Pyramid has three levels:\n\n1. **Unit Tests** (base) - Test individual functions in isolation. Fast, many of these.\n2. **Integration Tests** (middle) - Test how components work together. Slower, fewer.\n3. **End-to-End Tests** (top) - Test full user workflows. Slowest, fewest.\n\nWhy this shape? Unit tests are cheap and fast. E2E tests are expensive and slow. A healthy codebase has many unit tests, some integration tests, and few E2E tests.\n\nWithout tests, every change is a gamble. With tests, you refactor with confidence."
            },
            {
              "type": "EXAMPLE",
              "title": "Tests as Documentation",
              "content": "See the code example above demonstrating Tests as Documentation.",
              "language": "javascript",
              "code": "// Tests document expected behavior better than comments\n\n// What does this function do? The test tells us:\ntest('calculateDiscount applies 10% off for orders over $100', () => {\n  expect(calculateDiscount(150)).toBe(15);\n  expect(calculateDiscount(50)).toBe(0);\n});\n\n// Now we know:\n// - Orders over $100 get 10% discount\n// - Orders $100 or less get no discount\n// This documentation never goes stale!"
            },
            {
              "type": "KEY_POINT",
              "title": "TDD: Test-Driven Development",
              "content": "TDD flips the script: write tests BEFORE code.\n\n1. **Red** - Write a failing test for the feature you want\n2. **Green** - Write minimal code to make the test pass\n3. **Refactor** - Clean up the code, tests ensure it still works\n\nBenefits of TDD:\n- Forces you to think about requirements first\n- Produces testable, modular code by design\n- Builds a safety net as you code\n- Prevents over-engineering (only write what's needed)\n\nStart small: write one test, make it pass, repeat."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.1-challenge",
              "title": "Identify Test Types",
              "description": "Write comments identifying which type of test (unit, integration, or e2e) each scenario describes.",
              "instructions": "For each test description, add a comment identifying if it's a unit test, integration test, or e2e test.",
              "starterCode": "// Identify each test type: unit, integration, or e2e\n\n// Test 1: Check if formatPrice(10.5) returns '$10.50'\n// Type: ???\n\n// Test 2: Verify login form submits to API and stores token\n// Type: ???\n\n// Test 3: User can browse products, add to cart, and checkout\n// Type: ???\n\n// Test 4: Check if validateEmail returns false for 'invalid'\n// Type: ???\n\nconsole.log('Test 1: formatPrice - unit test');\nconsole.log('Test 2: login form + API - integration test');\nconsole.log('Test 3: full checkout flow - e2e test');\nconsole.log('Test 4: validateEmail - unit test');",
              "solution": "// Identify each test type: unit, integration, or e2e\n\n// Test 1: Check if formatPrice(10.5) returns '$10.50'\n// Type: unit (tests single pure function)\n\n// Test 2: Verify login form submits to API and stores token\n// Type: integration (tests form + API + storage together)\n\n// Test 3: User can browse products, add to cart, and checkout\n// Type: e2e (tests complete user journey)\n\n// Test 4: Check if validateEmail returns false for 'invalid'\n// Type: unit (tests single pure function)\n\nconsole.log('Test 1: formatPrice - unit test');\nconsole.log('Test 2: login form + API - integration test');\nconsole.log('Test 3: full checkout flow - e2e test');\nconsole.log('Test 4: validateEmail - unit test');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Correctly identifies test types",
                  "expectedOutput": "unit test",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Unit tests test ONE function. Integration tests test multiple components together. E2E tests simulate real user flows."
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.2",
          "title": "Bun Test Setup & First Test",
          "moduleId": "module-15",
          "order": 2,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Bun's Test Runner?",
              "content": "Bun has a built-in test runner that requires zero configuration:\n\n- **Zero Setup** - No installation, no config files, just works\n- **Blazing Fast** - Native speed, runs tests in parallel\n- **Jest-Compatible** - Same API you already know\n- **TypeScript Ready** - No setup needed for TS\n\nNo installation needed! Just create a test file:\n```bash\n# Create test file (*.test.ts, *.test.js, or *_test.ts)\ntouch math.test.ts\n\n# Run tests\nbun test\n```\n\nThat's it. No package.json scripts, no config files, no dependencies.\n\n`bun test` watches for changes by default. Use `bun test --run` to run once and exit."
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Test",
              "content": "See the code example above demonstrating Your First Test.",
              "language": "javascript",
              "code": "// math.ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\n// math.test.ts\nimport { describe, it, expect } from 'bun:test';\nimport { add } from './math';\n\ndescribe('add', () => {\n  it('adds two positive numbers', () => {\n    expect(add(2, 3)).toBe(5);\n  });\n\n  it('handles negative numbers', () => {\n    expect(add(-1, 1)).toBe(0);\n  });\n});\n\n// Run: bun test\n// Output: bun test v1.x\n//         math.test.ts:\n//         ✓ add > adds two positive numbers\n//         ✓ add > handles negative numbers"
            },
            {
              "type": "KEY_POINT",
              "title": "describe, it, expect",
              "content": "Three core functions from 'bun:test':\n\n**describe(name, fn)** - Groups related tests\n```javascript\nimport { describe } from 'bun:test';\ndescribe('Calculator', () => { ... });\n```\n\n**it(name, fn)** or **test(name, fn)** - Defines a single test\n```javascript\nimport { it, test } from 'bun:test';\nit('should add numbers', () => { ... });\n```\n\n**expect(value)** - Creates an assertion\n```javascript\nimport { expect } from 'bun:test';\nexpect(result).toBe(expected);     // Strict equality\nexpect(arr).toEqual([1, 2, 3]);    // Deep equality\nexpect(fn).toThrow();              // Throws error\nexpect(value).toBeTruthy();        // Truthy check\n```\n\nNaming convention: Test names should read like sentences.\n\"it should calculate total with tax\" tells you exactly what's being tested."
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Vitest Equivalent",
              "legacy": "vitest",
              "content": "In Vitest, you would need to install and configure the test runner first. Bun's test runner works identically but with zero setup.",
              "code": "// Vitest requires installation:\n// npm install -D vitest\n\n// And package.json scripts:\n// \"test\": \"vitest\"\n\n// Then import from 'vitest' instead of 'bun:test':\nimport { describe, it, expect } from 'vitest';\n\n// The test code itself is identical!\ndescribe('add', () => {\n  it('adds numbers', () => {\n    expect(add(2, 3)).toBe(5);\n  });\n});",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.2-challenge",
              "title": "Write Your First Tests",
              "description": "Write tests for a multiply function using describe, it, and expect.",
              "instructions": "Complete the test file for the multiply function. Test positive numbers, negative numbers, and zero.",
              "starterCode": "// Simulating bun:test functions for this exercise\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = (name, fn) => {\n  try { fn(); console.log(`  ✓ ${name}`); }\n  catch (e) { console.log(`  ✗ ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); }\n});\n\n// Function to test\nfunction multiply(a, b) {\n  return a * b;\n}\n\n// Write your tests below\ndescribe('multiply', () => {\n  it('multiplies two positive numbers', () => {\n    // YOUR CODE: expect multiply(3, 4) to be 12\n  });\n\n  it('handles negative numbers', () => {\n    // YOUR CODE: expect multiply(-2, 5) to be -10\n  });\n\n  it('returns zero when multiplied by zero', () => {\n    // YOUR CODE: expect multiply(100, 0) to be 0\n  });\n});",
              "solution": "// Simulating bun:test functions for this exercise\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = (name, fn) => {\n  try { fn(); console.log(`  ✓ ${name}`); }\n  catch (e) { console.log(`  ✗ ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); }\n});\n\n// Function to test\nfunction multiply(a, b) {\n  return a * b;\n}\n\n// Write your tests below\ndescribe('multiply', () => {\n  it('multiplies two positive numbers', () => {\n    expect(multiply(3, 4)).toBe(12);\n  });\n\n  it('handles negative numbers', () => {\n    expect(multiply(-2, 5)).toBe(-10);\n  });\n\n  it('returns zero when multiplied by zero', () => {\n    expect(multiply(100, 0)).toBe(0);\n  });\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "All tests pass",
                  "expectedOutput": "✓",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use expect(multiply(a, b)).toBe(expectedResult) pattern"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.3",
          "title": "Writing Good Tests (AAA Pattern)",
          "moduleId": "module-15",
          "order": 3,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Pure Functions & Testability",
              "content": "Pure functions are easiest to test:\n- Same input always gives same output\n- No side effects (no API calls, no DOM, no randomness)\n\n```javascript\n// Pure - easy to test\nfunction calculateTax(price, rate) {\n  return price * rate;\n}\n\n// Impure - harder to test (depends on external state)\nfunction calculateTaxWithDate(price) {\n  const rate = new Date().getMonth() < 6 ? 0.08 : 0.1;\n  return price * rate;\n}\n```\n\nRefactor impure functions: inject dependencies instead of creating them inside."
            },
            {
              "type": "EXAMPLE",
              "title": "Arrange-Act-Assert Pattern",
              "content": "See the code example above demonstrating Arrange-Act-Assert Pattern.",
              "language": "javascript",
              "code": "// AAA makes tests readable and consistent\n\nimport { describe, it, expect } from 'bun:test';\nimport { applyDiscount } from './pricing';\n\ndescribe('applyDiscount', () => {\n  it('applies percentage discount correctly', () => {\n    // Arrange - set up test data\n    const price = 100;\n    const discountPercent = 20;\n\n    // Act - call the function\n    const result = applyDiscount(price, discountPercent);\n\n    // Assert - verify the result\n    expect(result).toBe(80);\n  });\n});"
            },
            {
              "type": "KEY_POINT",
              "title": "test.each for Multiple Cases",
              "content": "Avoid repetitive tests with test.each:\n\n```javascript\nimport { describe, it, expect } from 'bun:test';\n\ndescribe('isEven', () => {\n  it.each([\n    [2, true],\n    [3, false],\n    [0, true],\n    [-4, true],\n  ])('isEven(%i) returns %s', (input, expected) => {\n    expect(isEven(input)).toBe(expected);\n  });\n});\n```\n\nTest edge cases:\n- Empty inputs (null, undefined, '', [])\n- Boundary values (0, -1, MAX_INT)\n- Invalid inputs (wrong types)\n- Large inputs (performance)"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Vitest Equivalent",
              "legacy": "vitest",
              "content": "The AAA pattern and test.each work identically in Vitest - just change the import.",
              "code": "// Vitest version - only the import changes\nimport { describe, it, expect } from 'vitest';\n\n// Everything else is the same!\ndescribe('isEven', () => {\n  it.each([[2, true], [3, false]])(\n    'isEven(%i) returns %s',\n    (input, expected) => {\n      expect(isEven(input)).toBe(expected);\n    }\n  );\n});",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.3-challenge",
              "title": "Test Edge Cases",
              "description": "Write comprehensive tests for a validatePassword function including edge cases.",
              "instructions": "Test the validatePassword function with valid passwords, short passwords, missing numbers, and edge cases.",
              "starterCode": "// Simulating bun:test\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = (name, fn) => {\n  try { fn(); console.log(`  ✓ ${name}`); }\n  catch (e) { console.log(`  ✗ ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); }\n});\n\n// Function to test: password must be 8+ chars with at least one number\nfunction validatePassword(password) {\n  if (!password || password.length < 8) return false;\n  return /\\d/.test(password);\n}\n\ndescribe('validatePassword', () => {\n  // Arrange-Act-Assert pattern\n  \n  it('returns true for valid password', () => {\n    // Arrange\n    const password = 'secure123';\n    // Act\n    const result = validatePassword(password);\n    // Assert\n    expect(result).toBe(true);\n  });\n\n  it('returns false for password without number', () => {\n    // YOUR CODE HERE\n  });\n\n  it('returns false for short password', () => {\n    // YOUR CODE HERE\n  });\n\n  it('returns false for empty string', () => {\n    // YOUR CODE HERE\n  });\n\n  it('returns false for null', () => {\n    // YOUR CODE HERE\n  });\n});",
              "solution": "// Simulating bun:test\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = (name, fn) => {\n  try { fn(); console.log(`  ✓ ${name}`); }\n  catch (e) { console.log(`  ✗ ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); }\n});\n\n// Function to test: password must be 8+ chars with at least one number\nfunction validatePassword(password) {\n  if (!password || password.length < 8) return false;\n  return /\\d/.test(password);\n}\n\ndescribe('validatePassword', () => {\n  it('returns true for valid password', () => {\n    const password = 'secure123';\n    const result = validatePassword(password);\n    expect(result).toBe(true);\n  });\n\n  it('returns false for password without number', () => {\n    const password = 'securepassword';\n    const result = validatePassword(password);\n    expect(result).toBe(false);\n  });\n\n  it('returns false for short password', () => {\n    const password = 'abc1';\n    const result = validatePassword(password);\n    expect(result).toBe(false);\n  });\n\n  it('returns false for empty string', () => {\n    const password = '';\n    const result = validatePassword(password);\n    expect(result).toBe(false);\n  });\n\n  it('returns false for null', () => {\n    const password = null;\n    const result = validatePassword(password);\n    expect(result).toBe(false);\n  });\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "All tests pass",
                  "expectedOutput": "✓",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Follow the Arrange-Act-Assert pattern for each test"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.4",
          "title": "Mocking with Bun",
          "moduleId": "module-15",
          "order": 4,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Mock?",
              "content": "Mocks replace real dependencies with controlled fakes.\n\nWhen to mock:\n- API calls (don't hit real servers in tests)\n- Databases (tests should be fast and isolated)\n- Time/dates (make tests deterministic)\n- External services (payment, email)\n\nWhen NOT to mock:\n- The code you're actually testing\n- Simple utility functions\n- When real behavior is fast and reliable\n\nBun provides `mock()` and `spyOn()` from 'bun:test' - no external packages needed!\n\nOver-mocking makes tests brittle and less valuable. Mock at the boundaries, not everywhere."
            },
            {
              "type": "EXAMPLE",
              "title": "mock() and mock.module()",
              "content": "See the code example above demonstrating mock() and mock.module().",
              "language": "javascript",
              "code": "import { describe, it, expect, mock, spyOn } from 'bun:test';\n\n// Create a mock function\nconst mockFetch = mock(() => Promise.resolve({ name: 'Alice' }));\n\n// Mock an entire module\nmock.module('./api', () => ({\n  fetchUser: mockFetch\n}));\n\nimport { getUserGreeting } from './greeting';\n\ndescribe('getUserGreeting', () => {\n  it('greets the user by name', async () => {\n    // Setup mock return value\n    mockFetch.mockResolvedValue({ name: 'Alice' });\n\n    const greeting = await getUserGreeting(1);\n\n    expect(greeting).toBe('Hello, Alice!');\n    expect(mockFetch).toHaveBeenCalledWith(1);\n  });\n\n  it('handles API errors gracefully', async () => {\n    mockFetch.mockRejectedValue(new Error('Network error'));\n\n    const greeting = await getUserGreeting(1);\n\n    expect(greeting).toBe('Hello, Guest!');\n  });\n});"
            },
            {
              "type": "KEY_POINT",
              "title": "spyOn() for Watching Calls",
              "content": "**spyOn** watches function calls and optionally changes behavior:\n```javascript\nimport { spyOn } from 'bun:test';\n\nconst spy = spyOn(console, 'log');\nmyFunction();\nexpect(spy).toHaveBeenCalledWith('expected message');\nspy.mockRestore(); // Restore original\n```\n\n**mock()** creates a mock function:\n```javascript\nimport { mock } from 'bun:test';\n\nconst mockFn = mock(() => 42);\nexpect(mockFn()).toBe(42);\n```\n\nUseful mock methods:\n- `mockReturnValue(val)` - Always return val\n- `mockResolvedValue(val)` - Return Promise.resolve(val)\n- `mockRejectedValue(err)` - Return Promise.reject(err)\n- `mockImplementation(fn)` - Custom logic\n\nVerify calls:\n- `toHaveBeenCalled()` - Was it called?\n- `toHaveBeenCalledWith(args)` - With what?\n- `toHaveBeenCalledTimes(n)` - How many times?"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Vitest Equivalent",
              "legacy": "vitest",
              "content": "Vitest uses vi.fn() and vi.mock() instead of Bun's mock() and mock.module(). The API is similar but uses a different namespace.",
              "code": "// Vitest version\nimport { vi, describe, it, expect } from 'vitest';\n\n// vi.fn() instead of mock()\nconst mockFetch = vi.fn();\n\n// vi.mock() instead of mock.module()\nvi.mock('./api', () => ({\n  fetchUser: mockFetch\n}));\n\n// vi.spyOn() instead of spyOn()\nconst spy = vi.spyOn(console, 'log');\n\n// Everything else works the same!",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.4-challenge",
              "title": "Mock an API Call",
              "description": "Write tests using mocks to test a function that depends on an API call.",
              "instructions": "Test the getWeatherMessage function by mocking the fetchWeather dependency. Test both success and error cases.",
              "starterCode": "// Simulating bun:test mock functions\nconst mock = (fn) => {\n  const mockFn = (...args) => mockFn._returnValue;\n  mockFn._calls = [];\n  mockFn.mockReturnValue = (val) => { mockFn._returnValue = val; return mockFn; };\n  mockFn.mockResolvedValue = (val) => { mockFn._returnValue = Promise.resolve(val); return mockFn; };\n  mockFn.mockRejectedValue = (err) => { mockFn._returnValue = Promise.reject(err); return mockFn; };\n  return mockFn;\n};\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  ✓ ${name}`); }\n  catch (e) { console.log(`  ✗ ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); }\n});\n\n// The API function we'll mock\nlet fetchWeather = async (city) => {\n  // In reality this would call an API\n  return { temp: 72, condition: 'sunny' };\n};\n\n// Function to test\nasync function getWeatherMessage(city) {\n  try {\n    const weather = await fetchWeather(city);\n    return `It's ${weather.temp}°F and ${weather.condition} in ${city}`;\n  } catch (error) {\n    return `Weather unavailable for ${city}`;\n  }\n}\n\ndescribe('getWeatherMessage', () => {\n  it('returns formatted weather message on success', async () => {\n    // Mock fetchWeather to return controlled data\n    fetchWeather = mock().mockResolvedValue({ temp: 75, condition: 'cloudy' });\n    \n    const message = await getWeatherMessage('Seattle');\n    \n    expect(message).toBe(\"It's 75°F and cloudy in Seattle\");\n  });\n\n  it('returns fallback message on API error', async () => {\n    // YOUR CODE: Mock fetchWeather to reject with an error\n    // Then call getWeatherMessage and verify the fallback message\n  });\n});",
              "solution": "// Simulating bun:test mock functions\nconst mock = (fn) => {\n  const mockFn = (...args) => mockFn._returnValue;\n  mockFn._calls = [];\n  mockFn.mockReturnValue = (val) => { mockFn._returnValue = val; return mockFn; };\n  mockFn.mockResolvedValue = (val) => { mockFn._returnValue = Promise.resolve(val); return mockFn; };\n  mockFn.mockRejectedValue = (err) => { mockFn._returnValue = Promise.reject(err); return mockFn; };\n  return mockFn;\n};\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  ✓ ${name}`); }\n  catch (e) { console.log(`  ✗ ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); }\n});\n\n// The API function we'll mock\nlet fetchWeather = async (city) => {\n  return { temp: 72, condition: 'sunny' };\n};\n\n// Function to test\nasync function getWeatherMessage(city) {\n  try {\n    const weather = await fetchWeather(city);\n    return `It's ${weather.temp}°F and ${weather.condition} in ${city}`;\n  } catch (error) {\n    return `Weather unavailable for ${city}`;\n  }\n}\n\ndescribe('getWeatherMessage', () => {\n  it('returns formatted weather message on success', async () => {\n    fetchWeather = mock().mockResolvedValue({ temp: 75, condition: 'cloudy' });\n    \n    const message = await getWeatherMessage('Seattle');\n    \n    expect(message).toBe(\"It's 75°F and cloudy in Seattle\");\n  });\n\n  it('returns fallback message on API error', async () => {\n    fetchWeather = mock().mockRejectedValue(new Error('Network error'));\n    \n    const message = await getWeatherMessage('Seattle');\n    \n    expect(message).toBe('Weather unavailable for Seattle');\n  });\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Both tests pass",
                  "expectedOutput": "✓",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use mockRejectedValue to simulate an API error"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.5",
          "title": "Testing Async Code with Bun",
          "moduleId": "module-15",
          "order": 5,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Async Testing Patterns",
              "content": "Async code needs special handling in tests. Bun's test runner handles async naturally:\n\n**Return a Promise:**\n```javascript\nit('fetches data', () => {\n  return fetchData().then(data => {\n    expect(data).toBeDefined();\n  });\n});\n```\n\n**Use async/await (preferred):**\n```javascript\nit('fetches data', async () => {\n  const data = await fetchData();\n  expect(data).toBeDefined();\n});\n```\n\n**Key rule:** Always await or return async operations. Forgotten awaits cause tests to pass incorrectly because assertions run after the test completes."
            },
            {
              "type": "EXAMPLE",
              "title": "Controlling Time with setSystemTime()",
              "content": "Bun provides built-in fake timers through setSystemTime().",
              "language": "javascript",
              "code": "import { describe, it, expect, beforeEach, afterEach, mock, setSystemTime } from 'bun:test';\n\nfunction delayedGreeting(name, callback) {\n  setTimeout(() => callback(`Hello, ${name}!`), 1000);\n}\n\ndescribe('delayedGreeting', () => {\n  beforeEach(() => {\n    setSystemTime(new Date('2024-01-01'));  // Take control of time\n  });\n\n  afterEach(() => {\n    setSystemTime();  // Restore real time\n  });\n\n  it('calls callback after 1 second', async () => {\n    const callback = mock(() => {});\n\n    delayedGreeting('Alice', callback);\n    \n    expect(callback).not.toHaveBeenCalled();  // Not yet!\n    \n    // Use Bun.sleep or advance time manually\n    await Bun.sleep(1000);\n    \n    expect(callback).toHaveBeenCalledWith('Hello, Alice!');\n  });\n});"
            },
            {
              "type": "KEY_POINT",
              "title": "Testing Promise States",
              "content": "Test all promise outcomes with Bun:\n\n```javascript\nimport { describe, it, expect } from 'bun:test';\n\ndescribe('fetchUser', () => {\n  it('resolves with user data', async () => {\n    const user = await fetchUser(1);\n    expect(user.name).toBe('Alice');\n  });\n\n  it('rejects for invalid id', async () => {\n    expect(fetchUser(-1)).rejects.toThrow('Invalid ID');\n  });\n\n  it('rejects with specific error type', async () => {\n    expect(fetchUser(999))\n      .rejects\n      .toBeInstanceOf(NotFoundError);\n  });\n});\n```\n\nUseful matchers:\n- `resolves.toBe()` - Unwraps resolved value\n- `rejects.toThrow()` - Checks rejection\n- `Bun.sleep(ms)` - Async sleep for timing tests"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Vitest Equivalent",
              "legacy": "vitest",
              "content": "Vitest uses vi.useFakeTimers() and vi.advanceTimersByTime() for timer control. Bun uses setSystemTime() instead.",
              "code": "// Vitest version\nimport { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';\n\nbeforeEach(() => {\n  vi.useFakeTimers();  // Vitest fake timers\n});\n\nafterEach(() => {\n  vi.restoreAllMocks();\n});\n\nit('delays execution', () => {\n  const callback = vi.fn();\n  delayedGreeting('Alice', callback);\n  \n  vi.advanceTimersByTime(1000);  // Vitest time advance\n  \n  expect(callback).toHaveBeenCalled();\n});",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.5-challenge",
              "title": "Test Async Functions",
              "description": "Write tests for async functions including timer-based code.",
              "instructions": "Complete the tests for the fetchUserData function and the debounce utility. Use async/await and fake timers.",
              "starterCode": "// Simulating bun:test\nconst mock = (fn) => {\n  const mockFn = (...args) => { mockFn._calls.push(args); return mockFn._returnValue; };\n  mockFn._calls = [];\n  mockFn._returnValue = undefined;\n  mockFn.mockReturnValue = (val) => { mockFn._returnValue = val; return mockFn; };\n  return mockFn;\n};\nlet _fakeTime = 0;\nconst setSystemTime = (date) => { _fakeTime = date ? date.getTime() : 0; };\nconst advanceTime = (ms) => {\n  _fakeTime += ms;\n  global._pendingTimers?.forEach(t => {\n    if (t.time <= _fakeTime && !t.called) {\n      t.called = true; t.fn();\n    }\n  });\n};\nglobal._pendingTimers = [];\nconst originalSetTimeout = setTimeout;\nglobal.setTimeout = (fn, ms) => {\n  global._pendingTimers.push({ fn, time: (_fakeTime || 0) + ms, called: false });\n};\n\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toHaveBeenCalled: () => { if (val._calls.length === 0) throw new Error('Expected function to be called'); },\n  not: { toHaveBeenCalled: () => { if (val._calls?.length > 0) throw new Error('Expected function not to be called'); } }\n});\nconst beforeEach = (fn) => fn();\nconst afterEach = (fn) => {};\n\n// Functions to test\nasync function fetchUserData(id) {\n  await new Promise(r => originalSetTimeout(r, 10));\n  if (id <= 0) throw new Error('Invalid ID');\n  return { id, name: 'Test User' };\n}\n\nfunction debounce(fn, delay) {\n  let timeoutId;\n  return (...args) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn(...args), delay);\n  };\n}\n\ndescribe('fetchUserData', () => {\n  it('returns user data for valid id', async () => {\n    const user = await fetchUserData(1);\n    expect(user.name).toBe('Test User');\n  });\n\n  it('throws error for invalid id', async () => {\n    // YOUR CODE: Test that fetchUserData(0) throws 'Invalid ID'\n    try {\n      await fetchUserData(0);\n      throw new Error('Should have thrown');\n    } catch (e) {\n      expect(e.message).toBe('Invalid ID');\n    }\n  });\n});\n\ndescribe('debounce', () => {\n  beforeEach(() => {\n    setSystemTime(new Date('2024-01-01'));\n  });\n\n  it('delays function execution', () => {\n    const fn = mock();\n    const debounced = debounce(fn, 500);\n\n    debounced();\n    expect(fn).not.toHaveBeenCalled();\n\n    // YOUR CODE: Advance time and verify fn was called\n    advanceTime(500);\n    expect(fn).toHaveBeenCalled();\n  });\n});",
              "solution": "// Simulating bun:test\nconst mock = (fn) => {\n  const mockFn = (...args) => { mockFn._calls.push(args); return mockFn._returnValue; };\n  mockFn._calls = [];\n  mockFn._returnValue = undefined;\n  mockFn.mockReturnValue = (val) => { mockFn._returnValue = val; return mockFn; };\n  return mockFn;\n};\nlet _fakeTime = 0;\nconst setSystemTime = (date) => { _fakeTime = date ? date.getTime() : 0; };\nconst advanceTime = (ms) => {\n  _fakeTime += ms;\n  global._pendingTimers?.forEach(t => {\n    if (t.time <= _fakeTime && !t.called) {\n      t.called = true; t.fn();\n    }\n  });\n};\nglobal._pendingTimers = [];\nconst originalSetTimeout = setTimeout;\nglobal.setTimeout = (fn, ms) => {\n  global._pendingTimers.push({ fn, time: (_fakeTime || 0) + ms, called: false });\n};\n\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toHaveBeenCalled: () => { if (val._calls.length === 0) throw new Error('Expected function to be called'); },\n  not: { toHaveBeenCalled: () => { if (val._calls?.length > 0) throw new Error('Expected function not to be called'); } }\n});\nconst beforeEach = (fn) => fn();\nconst afterEach = (fn) => {};\n\n// Functions to test\nasync function fetchUserData(id) {\n  await new Promise(r => originalSetTimeout(r, 10));\n  if (id <= 0) throw new Error('Invalid ID');\n  return { id, name: 'Test User' };\n}\n\nfunction debounce(fn, delay) {\n  let timeoutId;\n  return (...args) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn(...args), delay);\n  };\n}\n\ndescribe('fetchUserData', () => {\n  it('returns user data for valid id', async () => {\n    const user = await fetchUserData(1);\n    expect(user.name).toBe('Test User');\n  });\n\n  it('throws error for invalid id', async () => {\n    try {\n      await fetchUserData(0);\n      throw new Error('Should have thrown');\n    } catch (e) {\n      expect(e.message).toBe('Invalid ID');\n    }\n  });\n});\n\ndescribe('debounce', () => {\n  beforeEach(() => {\n    setSystemTime(new Date('2024-01-01'));\n  });\n\n  it('delays function execution', () => {\n    const fn = mock();\n    const debounced = debounce(fn, 500);\n\n    debounced();\n    expect(fn).not.toHaveBeenCalled();\n\n    advanceTime(500);\n    expect(fn).toHaveBeenCalled();\n  });\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "All async tests pass",
                  "expectedOutput": "✓",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use try/catch to test for thrown errors in async functions"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.6",
          "title": "Test Organization with Bun",
          "moduleId": "module-15",
          "order": 6,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Bun Test File Patterns & Preload",
              "content": "Bun automatically finds test files matching these patterns:\n- `*.test.ts` / `*.test.js`\n- `*_test.ts` / `*_test.js`\n- `*.spec.ts` / `*.spec.js`\n- Files in `__tests__` directories\n\n**Using --preload for setup:**\n```bash\n# Run setup before all tests\nbun test --preload ./tests/setup.ts\n```\n\nCreate a setup file for global configuration:\n```javascript\n// tests/setup.ts\nimport { beforeAll, afterAll } from 'bun:test';\n\nbeforeAll(() => {\n  // Global setup: connect to test DB, etc.\n});\n\nafterAll(() => {\n  // Global cleanup\n});\n```\n\nAdd to bunfig.toml for persistence:\n```toml\n[test]\npreload = [\"./tests/setup.ts\"]\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Organizing Tests by Feature",
              "content": "See the code example above demonstrating test organization.",
              "language": "javascript",
              "code": "// Project structure:\n// src/\n//   users/\n//     user.service.ts\n//     user.service.test.ts    <- Co-located tests\n//   orders/\n//     order.service.ts\n//     order.service.test.ts\n// tests/\n//   setup.ts                  <- Global setup\n//   integration/\n//     api.test.ts             <- Integration tests\n\n// tests/setup.ts - runs before all tests\nimport { beforeAll, afterAll, mock } from 'bun:test';\n\n// Mock environment for all tests\nprocess.env.NODE_ENV = 'test';\n\n// Global test database setup\nbeforeAll(async () => {\n  console.log('Setting up test environment...');\n});\n\nafterAll(async () => {\n  console.log('Cleaning up test environment...');\n});\n\n// Run with: bun test --preload ./tests/setup.ts"
            },
            {
              "type": "KEY_POINT",
              "title": "Bun Test CLI Options",
              "content": "Useful bun test flags:\n\n```bash\n# Run specific file or pattern\nbun test user.test.ts\nbun test --filter \"auth\"\n\n# Watch mode (default)\nbun test --watch\n\n# Run once and exit\nbun test --run\n\n# Timeout per test (default 5000ms)\nbun test --timeout 10000\n\n# Run tests in parallel (default)\nbun test --parallel\n\n# Run tests sequentially\nbun test --no-parallel\n\n# Bail on first failure\nbun test --bail\n\n# Show verbose output\nbun test --verbose\n```\n\nConfigure defaults in bunfig.toml:\n```toml\n[test]\npreload = [\"./tests/setup.ts\"]\ntimeout = 10000\nroot = \"./tests\"\n```"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Vitest Equivalent",
              "legacy": "vitest",
              "content": "Vitest uses vitest.config.ts for setup files. Bun uses --preload flag or bunfig.toml.",
              "code": "// Vitest config (vitest.config.ts)\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    setupFiles: ['./tests/setup.ts'],  // Vitest setup\n    globals: true,\n    environment: 'node',\n    include: ['**/*.test.ts']\n  }\n});\n\n// Bun equivalent (bunfig.toml)\n// [test]\n// preload = [\"./tests/setup.ts\"]",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.6-challenge",
              "title": "Organize a Test Suite",
              "description": "Create a well-organized test structure with setup and lifecycle hooks.",
              "instructions": "Complete the test organization example using beforeAll, afterAll, beforeEach, and afterEach hooks properly.",
              "starterCode": "// Simulating bun:test lifecycle hooks\nlet setupLog = [];\nconst beforeAll = (fn) => { setupLog.push('beforeAll'); fn(); };\nconst afterAll = (fn) => { setupLog.push('afterAll scheduled'); };\nconst beforeEach = (fn) => { fn(); };\nconst afterEach = (fn) => {};\n\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = (name, fn) => {\n  try { fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toContain: (exp) => { if (!val.includes(exp)) throw new Error(`Expected to contain ${exp}`); },\n  toHaveLength: (exp) => { if (val.length !== exp) throw new Error(`Expected length ${exp}`); }\n});\n\n// Database simulation\nlet db = { connected: false, users: [] };\n\ndescribe('UserService', () => {\n  // YOUR CODE: Add beforeAll to connect to database\n  beforeAll(() => {\n    db.connected = true;\n    db.users = [];\n    console.log('  [setup] Database connected');\n  });\n\n  // YOUR CODE: Add afterAll to disconnect\n  afterAll(() => {\n    db.connected = false;\n    console.log('  [cleanup] Database disconnected');\n  });\n\n  // YOUR CODE: Add beforeEach to reset users array\n  beforeEach(() => {\n    db.users = [];\n  });\n\n  describe('createUser', () => {\n    it('creates a user in the database', () => {\n      // Simulate creating a user\n      db.users.push({ id: 1, name: 'Alice' });\n      \n      expect(db.users).toHaveLength(1);\n      expect(db.connected).toBe(true);\n    });\n\n    it('starts with empty users after reset', () => {\n      // beforeEach should have reset the users\n      expect(db.users).toHaveLength(0);\n    });\n  });\n});\n\nconsole.log('\\nSetup log:', setupLog.join(' -> '));",
              "solution": "// Simulating bun:test lifecycle hooks\nlet setupLog = [];\nconst beforeAll = (fn) => { setupLog.push('beforeAll'); fn(); };\nconst afterAll = (fn) => { setupLog.push('afterAll scheduled'); };\nconst beforeEach = (fn) => { fn(); };\nconst afterEach = (fn) => {};\n\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = (name, fn) => {\n  try { fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toContain: (exp) => { if (!val.includes(exp)) throw new Error(`Expected to contain ${exp}`); },\n  toHaveLength: (exp) => { if (val.length !== exp) throw new Error(`Expected length ${exp}`); }\n});\n\n// Database simulation\nlet db = { connected: false, users: [] };\n\ndescribe('UserService', () => {\n  beforeAll(() => {\n    db.connected = true;\n    db.users = [];\n    console.log('  [setup] Database connected');\n  });\n\n  afterAll(() => {\n    db.connected = false;\n    console.log('  [cleanup] Database disconnected');\n  });\n\n  beforeEach(() => {\n    db.users = [];\n  });\n\n  describe('createUser', () => {\n    it('creates a user in the database', () => {\n      db.users.push({ id: 1, name: 'Alice' });\n      \n      expect(db.users).toHaveLength(1);\n      expect(db.connected).toBe(true);\n    });\n\n    it('starts with empty users after reset', () => {\n      expect(db.users).toHaveLength(0);\n    });\n  });\n});\n\nconsole.log('\\nSetup log:', setupLog.join(' -> '));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "All lifecycle hooks work correctly",
                  "expectedOutput": "✓",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "beforeAll runs once before all tests, beforeEach runs before each test"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.7",
          "title": "Code Coverage & CI with Bun",
          "moduleId": "module-15",
          "order": 7,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Understanding Code Coverage",
              "content": "Code coverage measures how much of your code is executed by tests.\n\n**Coverage types:**\n- **Lines** - % of lines executed\n- **Statements** - % of statements executed\n- **Branches** - % of if/else paths taken\n- **Functions** - % of functions called\n\nEnable coverage in Bun with a single flag:\n```bash\nbun test --coverage\n```\n\nBun outputs coverage to the console by default. No configuration needed!\n\nFor detailed reports, Bun generates lcov format:\n```bash\nbun test --coverage --coverage-reporter=lcov\n```\n\n**80% coverage** is a common target. 100% is often impractical and can lead to testing implementation details."
            },
            {
              "type": "EXAMPLE",
              "title": "GitHub Actions Workflow with Bun",
              "content": "This GitHub Actions workflow runs your tests automatically on every push and pull request using Bun's built-in test runner.",
              "language": "yaml",
              "code": "# .github/workflows/test.yml\nname: Tests\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup Bun\n        uses: oven-sh/setup-bun@v2\n        with:\n          bun-version: latest\n\n      - name: Install dependencies\n        run: bun install\n\n      - name: Run tests with coverage\n        run: bun test --coverage\n\n      - name: Run tests (fail if any fail)\n        run: bun test --bail"
            },
            {
              "type": "KEY_POINT",
              "title": "Coverage Best Practices",
              "content": "**Do:**\n- Set coverage thresholds to prevent regression\n- Focus on critical paths (auth, payments, core logic)\n- Use coverage to find untested code, not prove quality\n- Review coverage reports in CI to catch gaps\n\n**Don't:**\n- Chase 100% coverage\n- Write tests just to increase numbers\n- Ignore uncovered code if it's dead code\n- Test trivial getters/setters\n\nConfigure coverage in bunfig.toml:\n```toml\n[test]\ncoverage = true\ncoverageReporter = [\"text\", \"lcov\"]\ncoverageThreshold = { line = 80, function = 80, branch = 75 }\n```\n\nOr use CLI flags:\n```bash\nbun test --coverage --coverage-threshold 80\n```\n\nCI will fail if coverage drops below these thresholds."
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Vitest Equivalent",
              "legacy": "vitest",
              "content": "Vitest requires configuration files and external coverage providers. Bun's coverage is built-in.",
              "code": "// Vitest requires a config file (vitest.config.ts)\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      provider: 'v8',  // Must specify provider\n      reporter: ['text', 'html', 'lcov'],\n      thresholds: {\n        lines: 80,\n        branches: 75,\n        functions: 80,\n        statements: 80\n      }\n    }\n  }\n});\n\n// And in GitHub Actions:\n// - uses: actions/setup-node@v4\n// - run: npm ci\n// - run: npx vitest run --coverage\n\n// Bun equivalent - just one command!\n// bun test --coverage",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.7-challenge",
              "title": "Configure Coverage & CI",
              "description": "Create a bunfig.toml with coverage settings and a GitHub Actions workflow.",
              "instructions": "Complete the Bun config to enable coverage with 80% thresholds, and verify the GitHub Actions workflow.",
              "starterCode": "// bunfig.toml configuration (as JavaScript object for this exercise)\n// Complete this configuration\nconst bunfig = {\n  test: {\n    preload: ['./tests/setup.ts'],\n    // YOUR CODE: Enable coverage\n    coverage: false,\n    // YOUR CODE: Set coverage reporters\n    coverageReporter: [],\n    // YOUR CODE: Set coverage thresholds\n    coverageThreshold: {}\n  }\n};\n\n// Verify configuration\nconst test = bunfig.test;\n\nif (test.coverage === true) {\n  console.log('\\u2713 Coverage enabled');\n} else {\n  console.log('\\u2717 Enable coverage');\n}\n\nif (test.coverageReporter.includes('text')) {\n  console.log('\\u2713 Text reporter configured');\n} else {\n  console.log('\\u2717 Add text reporter');\n}\n\nif (test.coverageThreshold.line === 80) {\n  console.log('\\u2713 Line coverage threshold set to 80%');\n} else {\n  console.log('\\u2717 Set line threshold to 80');\n}\n\n// GitHub Actions workflow (as object for validation)\nconst workflow = {\n  name: 'Tests',\n  on: {\n    push: { branches: ['main'] },\n    pull_request: { branches: ['main'] }\n  },\n  jobs: {\n    test: {\n      'runs-on': 'ubuntu-latest',\n      steps: [\n        { uses: 'actions/checkout@v4' },\n        { name: 'Setup Bun', uses: 'oven-sh/setup-bun@v2' },\n        { name: 'Install', run: 'bun install' },\n        { name: 'Test', run: 'bun test --coverage' }\n      ]\n    }\n  }\n};\n\nconsole.log('\\u2713 GitHub Actions workflow configured for Bun');",
              "solution": "// bunfig.toml configuration (as JavaScript object for this exercise)\nconst bunfig = {\n  test: {\n    preload: ['./tests/setup.ts'],\n    coverage: true,\n    coverageReporter: ['text', 'lcov'],\n    coverageThreshold: {\n      line: 80,\n      function: 80,\n      branch: 75\n    }\n  }\n};\n\n// Verify configuration\nconst test = bunfig.test;\n\nif (test.coverage === true) {\n  console.log('\\u2713 Coverage enabled');\n} else {\n  console.log('\\u2717 Enable coverage');\n}\n\nif (test.coverageReporter.includes('text')) {\n  console.log('\\u2713 Text reporter configured');\n} else {\n  console.log('\\u2717 Add text reporter');\n}\n\nif (test.coverageThreshold.line === 80) {\n  console.log('\\u2713 Line coverage threshold set to 80%');\n} else {\n  console.log('\\u2717 Set line threshold to 80');\n}\n\nconst workflow = {\n  name: 'Tests',\n  on: {\n    push: { branches: ['main'] },\n    pull_request: { branches: ['main'] }\n  },\n  jobs: {\n    test: {\n      'runs-on': 'ubuntu-latest',\n      steps: [\n        { uses: 'actions/checkout@v4' },\n        { name: 'Setup Bun', uses: 'oven-sh/setup-bun@v2' },\n        { name: 'Install', run: 'bun install' },\n        { name: 'Test', run: 'bun test --coverage' }\n      ]\n    }\n  }\n};\n\nconsole.log('\\u2713 GitHub Actions workflow configured for Bun');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Coverage configuration is correct",
                  "expectedOutput": "✓ Line coverage threshold set to 80%",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Set coverage: true, and add 'text' and 'lcov' to coverageReporter array"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.8",
          "title": "Integration Testing with Hono",
          "moduleId": "module-15",
          "order": 8,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Testing Hono Apps with app.request()",
              "content": "Hono provides a built-in way to test your API without starting a server:\n\n```javascript\nimport { Hono } from 'hono';\n\nconst app = new Hono();\napp.get('/users', (c) => c.json([{ id: 1, name: 'Alice' }]));\n\n// Test without starting a server!\nconst res = await app.request('/users');\nconst data = await res.json();\n```\n\n**Why app.request()?**\n- No server startup/shutdown overhead\n- Tests run faster\n- No port conflicts\n- Full request/response testing\n\nTest structure for APIs:\n```\nsrc/\n  routes/\n    users.ts\n    users.test.ts    <- Co-located tests\n  app.ts\ntests/\n  integration/\n    api.test.ts      <- Full API tests\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Testing Hono Routes",
              "content": "See the code example above demonstrating Testing Hono Routes.",
              "language": "javascript",
              "code": "import { describe, it, expect, beforeEach } from 'bun:test';\nimport { Hono } from 'hono';\n\n// Create app with routes\nconst createApp = () => {\n  const app = new Hono();\n  const todos: { id: number; text: string; done: boolean }[] = [];\n  let nextId = 1;\n\n  app.get('/todos', (c) => c.json(todos));\n  \n  app.post('/todos', async (c) => {\n    const { text } = await c.req.json();\n    if (!text) return c.json({ error: 'Text required' }, 400);\n    const todo = { id: nextId++, text, done: false };\n    todos.push(todo);\n    return c.json(todo, 201);\n  });\n\n  app.patch('/todos/:id', async (c) => {\n    const id = parseInt(c.req.param('id'));\n    const todo = todos.find(t => t.id === id);\n    if (!todo) return c.json({ error: 'Not found' }, 404);\n    todo.done = !todo.done;\n    return c.json(todo);\n  });\n\n  return app;\n};\n\ndescribe('Todo API', () => {\n  let app: ReturnType<typeof createApp>;\n\n  beforeEach(() => {\n    app = createApp();  // Fresh app for each test\n  });\n\n  it('GET /todos returns empty array initially', async () => {\n    const res = await app.request('/todos');\n    expect(res.status).toBe(200);\n    expect(await res.json()).toEqual([]);\n  });\n\n  it('POST /todos creates a todo', async () => {\n    const res = await app.request('/todos', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ text: 'Learn Bun' })\n    });\n    \n    expect(res.status).toBe(201);\n    const todo = await res.json();\n    expect(todo.text).toBe('Learn Bun');\n    expect(todo.done).toBe(false);\n  });\n\n  it('POST /todos returns 400 for missing text', async () => {\n    const res = await app.request('/todos', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({})\n    });\n    \n    expect(res.status).toBe(400);\n  });\n});"
            },
            {
              "type": "KEY_POINT",
              "title": "Integration Test Best Practices",
              "content": "**Test HTTP semantics:**\n```javascript\n// Status codes\nexpect(res.status).toBe(201);  // Created\nexpect(res.status).toBe(404);  // Not found\n\n// Headers\nexpect(res.headers.get('Content-Type')).toContain('application/json');\n\n// Response body\nconst data = await res.json();\nexpect(data.id).toBeDefined();\n```\n\n**Test full flows:**\n```javascript\nit('full todo lifecycle', async () => {\n  // Create\n  const createRes = await app.request('/todos', {\n    method: 'POST',\n    body: JSON.stringify({ text: 'Test' })\n  });\n  const { id } = await createRes.json();\n  \n  // Update\n  await app.request(`/todos/${id}`, { method: 'PATCH' });\n  \n  // Verify\n  const getRes = await app.request('/todos');\n  const todos = await getRes.json();\n  expect(todos[0].done).toBe(true);\n});\n```\n\n**Isolate tests:** Create fresh app instance in beforeEach."
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Vitest Equivalent",
              "legacy": "vitest",
              "content": "Testing Hono works the same in Vitest - app.request() is framework-agnostic. Only the test imports differ.",
              "code": "// Vitest version\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { Hono } from 'hono';\n\n// Same app setup...\n\ndescribe('Todo API', () => {\n  let app;\n\n  beforeEach(() => {\n    app = createApp();\n  });\n\n  it('GET /todos returns empty array', async () => {\n    const res = await app.request('/todos');\n    expect(res.status).toBe(200);\n    // Works exactly the same!\n  });\n});",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.8-challenge",
              "title": "Test a Hono API",
              "description": "Create integration tests for a Todo API using Hono's app.request() method.",
              "instructions": "Complete the test suite for the Todo API. Test GET, POST, and PATCH endpoints including error cases.",
              "starterCode": "// Simulating bun:test and Hono\nconst describe = (name, fn) => { console.log(`\\ndescribe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toEqual: (exp) => { if (JSON.stringify(val) !== JSON.stringify(exp)) throw new Error(`Expected ${JSON.stringify(exp)}`); },\n  toContain: (exp) => { if (!val.includes(exp)) throw new Error(`Expected to contain ${exp}`); }\n});\nconst beforeEach = (fn) => { fn(); };\n\n// Simulating Hono app\nfunction createApp() {\n  const todos = [];\n  let nextId = 1;\n  \n  return {\n    request: async (path, options = {}) => {\n      const method = options.method || 'GET';\n      const body = options.body ? JSON.parse(options.body) : null;\n      \n      if (path === '/todos' && method === 'GET') {\n        return { status: 200, json: async () => [...todos] };\n      }\n      \n      if (path === '/todos' && method === 'POST') {\n        if (!body?.text) {\n          return { status: 400, json: async () => ({ error: 'Text required' }) };\n        }\n        const todo = { id: nextId++, text: body.text, done: false };\n        todos.push(todo);\n        return { status: 201, json: async () => todo };\n      }\n      \n      if (path.startsWith('/todos/') && method === 'PATCH') {\n        const id = parseInt(path.split('/')[2]);\n        const todo = todos.find(t => t.id === id);\n        if (!todo) return { status: 404, json: async () => ({ error: 'Not found' }) };\n        todo.done = !todo.done;\n        return { status: 200, json: async () => todo };\n      }\n      \n      return { status: 404 };\n    }\n  };\n}\n\ndescribe('Todo API Integration Tests', () => {\n  let app;\n  \n  beforeEach(() => {\n    app = createApp();\n  });\n\n  describe('GET /todos', () => {\n    it('returns empty array initially', async () => {\n      const res = await app.request('/todos');\n      expect(res.status).toBe(200);\n      expect(await res.json()).toEqual([]);\n    });\n  });\n\n  describe('POST /todos', () => {\n    it('creates a todo with valid text', async () => {\n      const res = await app.request('/todos', {\n        method: 'POST',\n        body: JSON.stringify({ text: 'Learn Bun testing' })\n      });\n      \n      expect(res.status).toBe(201);\n      const todo = await res.json();\n      expect(todo.text).toBe('Learn Bun testing');\n      expect(todo.done).toBe(false);\n    });\n\n    it('returns 400 for missing text', async () => {\n      // YOUR CODE: Test POST with empty body returns 400\n      const res = await app.request('/todos', {\n        method: 'POST',\n        body: JSON.stringify({})\n      });\n      expect(res.status).toBe(400);\n    });\n  });\n\n  describe('PATCH /todos/:id', () => {\n    it('toggles todo done status', async () => {\n      // First create a todo\n      const createRes = await app.request('/todos', {\n        method: 'POST',\n        body: JSON.stringify({ text: 'Test todo' })\n      });\n      const { id } = await createRes.json();\n      \n      // YOUR CODE: PATCH the todo and verify done is true\n      const patchRes = await app.request(`/todos/${id}`, { method: 'PATCH' });\n      expect(patchRes.status).toBe(200);\n      const updated = await patchRes.json();\n      expect(updated.done).toBe(true);\n    });\n\n    it('returns 404 for non-existent todo', async () => {\n      // YOUR CODE: Test PATCH /todos/999 returns 404\n      const res = await app.request('/todos/999', { method: 'PATCH' });\n      expect(res.status).toBe(404);\n    });\n  });\n});\n\nconsole.log('\\n--- Integration Tests Complete ---');",
              "solution": "// Simulating bun:test and Hono\nconst describe = (name, fn) => { console.log(`\\ndescribe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toEqual: (exp) => { if (JSON.stringify(val) !== JSON.stringify(exp)) throw new Error(`Expected ${JSON.stringify(exp)}`); },\n  toContain: (exp) => { if (!val.includes(exp)) throw new Error(`Expected to contain ${exp}`); }\n});\nconst beforeEach = (fn) => { fn(); };\n\nfunction createApp() {\n  const todos = [];\n  let nextId = 1;\n  \n  return {\n    request: async (path, options = {}) => {\n      const method = options.method || 'GET';\n      const body = options.body ? JSON.parse(options.body) : null;\n      \n      if (path === '/todos' && method === 'GET') {\n        return { status: 200, json: async () => [...todos] };\n      }\n      \n      if (path === '/todos' && method === 'POST') {\n        if (!body?.text) {\n          return { status: 400, json: async () => ({ error: 'Text required' }) };\n        }\n        const todo = { id: nextId++, text: body.text, done: false };\n        todos.push(todo);\n        return { status: 201, json: async () => todo };\n      }\n      \n      if (path.startsWith('/todos/') && method === 'PATCH') {\n        const id = parseInt(path.split('/')[2]);\n        const todo = todos.find(t => t.id === id);\n        if (!todo) return { status: 404, json: async () => ({ error: 'Not found' }) };\n        todo.done = !todo.done;\n        return { status: 200, json: async () => todo };\n      }\n      \n      return { status: 404 };\n    }\n  };\n}\n\ndescribe('Todo API Integration Tests', () => {\n  let app;\n  \n  beforeEach(() => {\n    app = createApp();\n  });\n\n  describe('GET /todos', () => {\n    it('returns empty array initially', async () => {\n      const res = await app.request('/todos');\n      expect(res.status).toBe(200);\n      expect(await res.json()).toEqual([]);\n    });\n  });\n\n  describe('POST /todos', () => {\n    it('creates a todo with valid text', async () => {\n      const res = await app.request('/todos', {\n        method: 'POST',\n        body: JSON.stringify({ text: 'Learn Bun testing' })\n      });\n      \n      expect(res.status).toBe(201);\n      const todo = await res.json();\n      expect(todo.text).toBe('Learn Bun testing');\n      expect(todo.done).toBe(false);\n    });\n\n    it('returns 400 for missing text', async () => {\n      const res = await app.request('/todos', {\n        method: 'POST',\n        body: JSON.stringify({})\n      });\n      expect(res.status).toBe(400);\n    });\n  });\n\n  describe('PATCH /todos/:id', () => {\n    it('toggles todo done status', async () => {\n      const createRes = await app.request('/todos', {\n        method: 'POST',\n        body: JSON.stringify({ text: 'Test todo' })\n      });\n      const { id } = await createRes.json();\n      \n      const patchRes = await app.request(`/todos/${id}`, { method: 'PATCH' });\n      expect(patchRes.status).toBe(200);\n      const updated = await patchRes.json();\n      expect(updated.done).toBe(true);\n    });\n\n    it('returns 404 for non-existent todo', async () => {\n      const res = await app.request('/todos/999', { method: 'PATCH' });\n      expect(res.status).toBe(404);\n    });\n  });\n});\n\nconsole.log('\\n--- Integration Tests Complete ---');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "All integration tests pass",
                  "expectedOutput": "Integration Tests Complete",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use app.request() with method and body options to test POST and PATCH"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    }
  ]
}
