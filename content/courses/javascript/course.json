{
  "id": "javascript",
  "language": "javascript",
  "title": "JavaScript & TypeScript Full Course",
  "description": "Master JavaScript from basics to advanced with TypeScript, covering 95 interactive lessons with real-world challenges. Updated for ES2025 with Bun/Hono stack.",
  "difficulty": "beginner",
  "estimatedHours": 42,
  "prerequisites": [],
  "modules": [
    {
      "id": "module-01",
      "title": "Module 1: The Absolute Basics (The 'What')",
      "description": "Understanding what programming is and writing your first lines of code",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "1.1",
          "title": "What Is Programming? (The Recipe Analogy)",
          "moduleId": "module-01",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're teaching a very literal robot to make a peanut butter and jelly sandwich. You can't just say 'make a sandwich' - the robot doesn't know what that means!\n\nYou have to break it down into tiny, specific steps: 'Pick up the knife. Dip the knife into the peanut butter jar. Spread the peanut butter on one slice of bread.' That's exactly what programming is.\n\nProgramming is writing a list of very specific instructions that a computer can follow. The computer is like that literal robot - it will do exactly what you tell it to do, but nothing more. It can't guess what you mean, and it can't read your mind. You have to be crystal clear.\n\nThe 'language' we use to give these instructions is called a programming language. Today, we're learning JavaScript, which is like giving instructions to a web browser."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// This is a comment - the computer ignores this line.\n// Comments are notes we leave for ourselves.\n\n// This is an instruction to the computer:\nconsole.log('Hello, World!');\n\n// The computer will display the text 'Hello, World!' on the screen."
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down that code line by line:\n\n1. Lines starting with // are comments. They're ignored by the computer. Think of them as sticky notes you leave for yourself (or other programmers) to explain what the code does.\n\n2. console.log('Hello, World!'); - This is an instruction (we'll call it a 'statement' later). Let's unpack it:\n   - console is like a special message board built into your web browser\n   - log means 'write a message'\n   - The text inside the parentheses and quotes ('Hello, World!') is the message we want to write\n   - The semicolon ; at the end is like a period at the end of a sentence - it tells the computer 'this instruction is complete'\n\nSo the whole thing means: 'Computer, write the message Hello, World! to the console.'"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes beginners make:\n\n1. Forgetting the quotes: console.log(Alice); won't work because the computer thinks Alice is a variable (a 'box' we'll learn about soon), not text.\n\n2. Forgetting the semicolon: While JavaScript is forgiving about this, it's good practice to always end statements with ;\n\n3. Misspelling console or log: Programming is case-sensitive! Console.log or console.Log won't work.\n\n4. Missing parentheses: console.log 'Alice'; won't work. The parentheses are how we 'pass' the message to the log function."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.1-challenge",
              "title": "Practice Challenge",
              "description": "Now it's your turn! Your challenge: Write code that displays your own name to the console. Replace 'Your Name Here' with your actual name (keep the quotes!).",
              "instructions": "Now it's your turn! Your challenge: Write code that displays your own name to the console. Replace 'Your Name Here' with your actual name (keep the quotes!).",
              "starterCode": "// Your code here: Replace 'Your Name Here' with your name\nconsole.log('Your Name Here');",
              "solution": "console.log('Alice');  // Replace Alice with your actual name",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays a name to the console",
                  "expectedOutput": "Alice",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Uses console.log to output text",
                  "expectedOutput": "Your Name Here",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Make sure to keep the quotes around your name, and don't forget the semicolon at the end!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes beginners make:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes beginners make:"
                },
                {
                  "mistake": "Forgetting the quotes: console.log(Alice); won't work because the computer thinks Alice is a variable (a 'box' we'll learn about soon), not text.",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting the quotes: console.log(Alice); won't work because the computer thinks Alice is a variable (a 'box' we'll learn about soon), not text."
                },
                {
                  "mistake": "Forgetting the semicolon: While JavaScript is forgiving about this, it's good practice to always end statements with ;",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting the semicolon: While JavaScript is forgiving about this, it's good practice to always end statements with ;"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.2",
          "title": "Your First Workspace (Running JavaScript)",
          "moduleId": "module-01",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of the code editor as your workshop - it's where you'll build and test your code. Just like a carpenter has a workbench where they can quickly test if a joint fits or a piece is the right size, Code Tutor is where you can quickly try out JavaScript code and see the results immediately.\n\nCode Tutor runs JavaScript using Node.js - the same JavaScript engine that powers web browsers, but running on your computer. This means you can write and test JavaScript code without needing a web browser. The `console.log()` function works exactly the same way!\n\n**To run JavaScript, you'll need Node.js installed:**\n\n1. Download Node.js from https://nodejs.org\n2. Install it (the default options are fine)\n3. Restart Code Tutor\n\nOnce installed, write your code and click 'Run Code' to see the results!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// You can do math in the console!\nconsole.log(5 + 3);\n\n// You can write multiple messages\nconsole.log('First message');\nconsole.log('Second message');\nconsole.log('Third message');\n\n// You can even do math inside the message\nconsole.log('The answer is: ' + (10 * 2));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's look at what's happening:\n\n1. console.log(5 + 3); - The computer will actually do the math (5 + 3 = 8) and then display '8'. The computer evaluates (figures out) what's inside the parentheses first, then displays the result.\n\n2. Multiple console.log statements run in order, from top to bottom. The computer executes them one at a time, like following a recipe step by step.\n\n3. The + symbol does two things in JavaScript:\n   - When used with numbers, it adds them: 5 + 3 = 8\n   - When used with text (in quotes), it joins them together: 'Hello' + ' ' + 'World' becomes 'Hello World'\n\n4. Notice the parentheses around (10 * 2) in the last example? That tells the computer 'do this math first, then join it with the text.'"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Putting quotes around the numbers: console.log('100 - 45'); will display the text '100 - 45' instead of doing the math. Remove the quotes to make the computer calculate it.\n\n2. Forgetting the console.log part: Just writing 100 - 45; won't display anything. You need console.log() to actually show the result.\n\n3. Wrong symbols: Make sure you use * for multiplication (not x), and - for subtraction (not a dash that might look similar)."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.2-challenge",
              "title": "Practice Challenge",
              "description": "Create a mini calculator! Write code that:\n1. Displays the result of 15 + 27\n2. Displays the result of 100 - 45\n3. Displays the result of 6 * 7 (the * symbol means multiply)",
              "instructions": "Create a mini calculator! Write code that:\n1. Displays the result of 15 + 27\n2. Displays the result of 100 - 45\n3. Displays the result of 6 * 7 (the * symbol means multiply)",
              "starterCode": "// Calculate and display 15 + 27\nconsole.log(15 + 27);\n\n// Calculate and display 100 - 45\n// Your code here\n\n// Calculate and display 6 * 7\n// Your code here",
              "solution": "console.log(15 + 27);\nconsole.log(100 - 45);\nconsole.log(6 * 7);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays 42 (the result of 15 + 27)",
                  "expectedOutput": "42",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Follow the same pattern as the first line: console.log(), put the math inside the parentheses, and end with a semicolon."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Putting quotes around the numbers: console.log('100 - 45'); will display the text '100 - 45' instead of doing the math. Remove the quotes to make the computer calculate it.",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Putting quotes around the numbers: console.log('100 - 45'); will display the text '100 - 45' instead of doing the math. Remove the quotes to make the computer calculate it."
                },
                {
                  "mistake": "Forgetting the console.log part: Just writing 100 - 45; won't display anything. You need console.log() to actually show the result.",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting the console.log part: Just writing 100 - 45; won't display anything. You need console.log() to actually show the result."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.3",
          "title": "Leaving Notes for Yourself (Comments)",
          "moduleId": "module-01",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're cooking a complex recipe, and you write little notes in the margins: 'This takes 20 minutes' or 'Make sure the oven is preheated!' Those notes aren't part of the recipe itself - they're reminders to yourself.\n\nComments in code work the same way. They're notes you leave for yourself (or other programmers) that the computer completely ignores. The computer will skip right over them like they don't exist.\n\nWhy are comments important? Because code that makes perfect sense today might be confusing in a month. Comments explain WHY you wrote the code a certain way, not just WHAT the code does."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// This is a single-line comment\n// The computer ignores everything after the //\n\nconsole.log('This runs!');  // You can also put comments at the end of a line\n\n// console.log('This does NOT run because it is commented out');\n\n/*\n  This is a multi-line comment.\n  Everything between the /* and */ is ignored.\n  This is useful for longer explanations.\n*/\n\nconsole.log('This also runs!');\n\n/* You can also use multi-line comments\n   to temporarily 'turn off' code:\n   console.log('This is turned off');\n   console.log('So is this');\n*/"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Two types of comments:\n\n1. Single-line comments: //\n   - Everything after // on that line is ignored\n   - Great for short notes\n   - Example: // This calculates the total price\n\n2. Multi-line comments: /* */\n   - Everything between /* and */ is ignored, even across multiple lines\n   - Great for longer explanations or temporarily disabling multiple lines of code\n   - Example:\n     /*\n       This function is complex, so here's how it works:\n       First, it checks if the user is logged in...\n     */\n\nPro tip: Use comments to explain WHY, not WHAT. The code itself shows WHAT it does. Comments should explain WHY you made that choice.\n\nGood comment: // Using 30-day trial period instead of 7-day based on user feedback\nBad comment: // This sets the trial period to 30"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting the space after //: While //comment works, // comment is more readable.\n\n2. Trying to nest multi-line comments: /* /* nested */ */ doesn't work. Once the computer sees */, it thinks the comment is over.\n\n3. Not closing a multi-line comment: If you forget the */, everything after /* will be treated as a comment, and your code won't run!\n\n4. Over-commenting: Don't comment every single line. Comment the WHY and the complex parts, not the obvious stuff."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.3-challenge",
              "title": "Practice Challenge",
              "description": "Practice using comments! Add a single-line comment above the console.log explaining what the code does. Then, comment out the second console.log (so it doesn't run) using //.",
              "instructions": "Practice using comments! Add a single-line comment above the console.log explaining what the code does. Then, comment out the second console.log (so it doesn't run) using //.",
              "starterCode": "console.log('I am learning JavaScript!');\n\nconsole.log('Comment me out!');",
              "solution": "// This displays a message about learning JavaScript\nconsole.log('I am learning JavaScript!');\n\n// console.log('Comment me out!');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Only the first message is displayed",
                  "expectedOutput": "I am learning JavaScript!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Put // at the beginning of the line you want to comment out."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting the space after //: While //comment works, // comment is more readable.",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting the space after //: While //comment works, // comment is more readable."
                },
                {
                  "mistake": "Trying to nest multi-line comments: /* /* nested */ */ doesn't work. Once the computer sees */, it thinks the comment is over.",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Trying to nest multi-line comments: /* /* nested */ */ doesn't work. Once the computer sees */, it thinks the comment is over."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-02",
      "title": "Module 2: Storing & Using Information (The 'Boxes')",
      "description": "Learn how to store and label information for later use",
      "difficulty": "beginner",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "2.1",
          "title": "Variables: Your Labeled Storage Boxes (let and const)",
          "moduleId": "module-02",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have a storage room with many boxes. Each box can hold one thing, and you put a label on each box so you remember what's inside.\n\n'Age: 25' - A box labeled 'Age' that contains the number 25\n'Name: Alice' - A box labeled 'Name' that contains the text 'Alice'\n'Is Student: true' - A box labeled 'Is Student' that contains the answer 'yes' (true)\n\nIn programming, these labeled boxes are called VARIABLES. A variable is just a named container that holds a piece of information. You create a variable, give it a name (the label), and store something in it (the contents).\n\nWhy are variables useful? Because you can create a box once and then use what's inside it many times throughout your code. If you need to change what's in the box, you change it in ONE place, and everywhere that uses that box automatically gets the new value."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Creating a variable with 'let'\n// 'let' means 'create a new box'\nlet age = 25;\nlet name = 'Alice';\nlet isStudent = true;\n\n// Now we can use these boxes!\nconsole.log(name);  // Displays: Alice\nconsole.log(age);   // Displays: 25\n\n// We can change what's inside a 'let' box\nage = 26;  // It's Alice's birthday!\nconsole.log(age);  // Displays: 26\n\n// Creating a variable with 'const'\n// 'const' means 'constant' - a box whose contents CANNOT change\nconst birthYear = 1998;\nconsole.log(birthYear);  // Displays: 1998\n\n// This would cause an ERROR:\n// birthYear = 1999;  // Can't change a const!"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down the anatomy of creating a variable:\n\nlet age = 25;\n│   │   │ │\n│   │   │ └─ The value (what goes IN the box)\n│   │   └─── The equals sign (means 'store this value')\n│   └─────── The variable name (the label on the box)\n└─────────── The keyword 'let' (tells the computer to create a box)\n\nThink of it as: let [label] = [contents];\n\nTwo keywords for creating variables:\n\n1. let - Use this when the value might change later\n   - Example: let score = 0; (score will increase during a game)\n   \n2. const - Use this when the value will NEVER change\n   - Example: const PI = 3.14159; (pi is always pi)\n   - If you try to change a const, you'll get an error\n\nVariable naming rules:\n- Must start with a letter, $, or _\n- Can contain letters, numbers, $, or _ (but not spaces!)\n- Cannot be a reserved word (like 'let', 'const', 'if', etc.)\n- Case sensitive: 'age' and 'Age' are different variables\n\nNaming conventions (not required, but everyone does it):\n- Use camelCase: firstName, not firstname or first_name\n- Use descriptive names: userAge, not x or ua\n- Start with lowercase: age, not Age (unless it's a special case we'll learn later)"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting 'let' or 'const': Writing just age = 25; instead of let age = 25; In strict mode, this causes an error.\n\n2. Using 'let' or 'const' when USING a variable: You only use 'let' or 'const' when CREATING the variable. After that, just use the name:\n   Correct: let age = 25; age = 26;\n   Wrong: let age = 25; let age = 26; (Can't create the same box twice!)\n\n3. Trying to change a 'const': Remember, const means 'constant'. Once set, it cannot be changed.\n\n4. Misspelling variable names: If you create 'userName' but later try to use 'username', JavaScript will say 'username is not defined' because it's looking for a box with that exact label.\n\n5. Not using quotes for text: let name = Alice; won't work. Text must be in quotes: let name = 'Alice';"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.1-challenge",
              "title": "Practice Challenge",
              "description": "Create three variables:\n1. A 'const' variable called 'city' that stores your favorite city name (as text in quotes)\n2. A 'let' variable called 'temperature' that stores the number 72\n3. Use console.log to display both variables",
              "instructions": "Create three variables:\n1. A 'const' variable called 'city' that stores your favorite city name (as text in quotes)\n2. A 'let' variable called 'temperature' that stores the number 72\n3. Use console.log to display both variables",
              "starterCode": "// Create your variables here\n\n// Display them here",
              "solution": "const city = 'New York';\nlet temperature = 72;\n\nconsole.log(city);\nconsole.log(temperature);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays the city name",
                  "expectedOutput": "New York",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Displays the temperature value",
                  "expectedOutput": "72",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Uses const for city variable",
                  "expectedOutput": "New York",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Remember: const city = 'some city'; and let temperature = 72; Then use console.log for each."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting 'let' or 'const': Writing just age = 25; instead of let age = 25; In strict mode, this causes an error.",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting 'let' or 'const': Writing just age = 25; instead of let age = 25; In strict mode, this causes an error."
                },
                {
                  "mistake": "Using 'let' or 'const' when USING a variable: You only use 'let' or 'const' when CREATING the variable. After that, just use the name:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using 'let' or 'const' when USING a variable: You only use 'let' or 'const' when CREATING the variable. After that, just use the name:\n   Correct: let age = 25; age = 26;\n   Wrong: let age = 25; let age = 26; (Can't create the same box twice!)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.2",
          "title": "Types of Information: Strings, Numbers, and Booleans",
          "moduleId": "module-02",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Just like in real life, we store different TYPES of things in different ways:\n\n- Words and sentences: We write them down as text (String)\n- Counting and measuring: We use numbers (Number)\n- Yes/No questions: We use true or false (Boolean)\n\nJavaScript has different 'types' of data for the same reason. Each type works differently and has different things you can do with it.\n\nThink of it like different types of storage containers:\n- A filing cabinet is for documents (text/strings)\n- A scale is for numbers (you can add, subtract, compare)\n- A light switch is for true/false (on or off, yes or no)\n\nYou wouldn't try to do math with words, and you wouldn't try to write a letter with numbers. JavaScript keeps track of what TYPE each variable is so it knows how to work with it."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// STRINGS (text) - always in quotes\nlet firstName = 'Alice';\nlet lastName = \"Smith\";  // Single or double quotes both work\nlet greeting = 'Hello, World!';\n\n// You can join strings together with +\nlet fullName = firstName + ' ' + lastName;\nconsole.log(fullName);  // Displays: Alice Smith\n\n// NUMBERS - no quotes!\nlet age = 25;\nlet price = 19.99;  // Decimals are fine\nlet temperature = -5;  // Negative numbers too\n\n// You can do math with numbers\nlet total = price + 10;\nconsole.log(total);  // Displays: 29.99\n\n// BOOLEANS (true or false) - no quotes!\nlet isStudent = true;\nlet hasGraduated = false;\nlet isRaining = true;\n\nconsole.log(isStudent);  // Displays: true\n\n// A common mistake: don't put quotes around booleans!\nlet wrong = 'true';  // This is a STRING containing the word 'true'\nlet right = true;    // This is a BOOLEAN with the value true"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "The three basic data types:\n\n1. STRING - Text\n   - Always enclosed in quotes (single ' or double \")\n   - Can be empty: let empty = '';\n   - Can contain numbers as text: let code = '12345';\n   - Use + to join strings: 'Hello' + ' ' + 'World' = 'Hello World'\n\n2. NUMBER - Numeric values\n   - NO quotes\n   - Can be positive, negative, or decimal\n   - Can do math: +, -, *, / (division), % (remainder)\n   - Special values: Infinity, -Infinity, NaN (Not a Number)\n\n3. BOOLEAN - True or False\n   - Only two possible values: true or false\n   - NO quotes (quotes would make it a string)\n   - Used for yes/no, on/off, exists/doesn't exist\n   - We'll use these a lot when making decisions (if statements)\n\nHow to remember:\n- If it's text, it needs quotes → String\n- If it's a number for math, no quotes → Number\n- If it's true or false, no quotes → Boolean\n\nThe + operator:\n- With numbers: 5 + 3 = 8 (addition)\n- With strings: 'Hello' + 'World' = 'HelloWorld' (joining)\n- Mixed: 'Age: ' + 25 = 'Age: 25' (converts number to string and joins)"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Quotes around numbers: let age = '25'; makes age a STRING, not a NUMBER. You can't do math with it: '25' + 5 = '255' (string joining, not 30).\n\n2. Quotes around booleans: let isStudent = 'true'; makes it a STRING containing the word 'true', not the boolean value true.\n\n3. Forgetting quotes around text: let name = Alice; won't work. JavaScript thinks Alice is a variable, not text. Use let name = 'Alice';\n\n4. Mixing up + for numbers vs strings:\n   - 5 + 5 = 10 (math)\n   - '5' + '5' = '55' (joining strings)\n   - '5' + 5 = '55' (JavaScript converts the number to a string)\n\n5. Case matters: true and false must be lowercase. True or FALSE won't work."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.2-challenge",
              "title": "Practice Challenge",
              "description": "Create a mini profile:\n1. Create a const 'userName' with your name (string)\n2. Create a let 'userAge' with your age (number)\n3. Create a const 'isLearning' set to true (boolean)\n4. Display a message: 'Name: [name], Age: [age], Learning: [boolean]' by joining strings and variables",
              "instructions": "Create a mini profile:\n1. Create a const 'userName' with your name (string)\n2. Create a let 'userAge' with your age (number)\n3. Create a const 'isLearning' set to true (boolean)\n4. Display a message: 'Name: [name], Age: [age], Learning: [boolean]' by joining strings and variables",
              "starterCode": "// Create your variables\n\n// Create a message by joining strings with +\n// Example: 'Name: ' + userName + ', Age: ' + userAge ...\nlet message = // YOUR CODE HERE\n\nconsole.log(message);",
              "solution": "const userName = 'Alice';\nlet userAge = 25;\nconst isLearning = true;\n\nlet message = 'Name: ' + userName + ', Age: ' + userAge + ', Learning: ' + isLearning;\n\nconsole.log(message);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays a formatted profile message with name, age, and learning status",
                  "expectedOutput": "Name: Alice, Age: 25, Learning: true",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Output contains the Name label",
                  "expectedOutput": "Name:",
                  "isVisible": false
                },
                {
                  "id": "test-3",
                  "description": "Output contains the Learning label with boolean",
                  "expectedOutput": "Learning: true",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use + to join strings and variables: 'Name: ' + userName + ', Age: ' + userAge + ', Learning: ' + isLearning"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Quotes around numbers: let age = '25'; makes age a STRING, not a NUMBER. You can't do math with it: '25' + 5 = '255' (string joining, not 30).",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Quotes around numbers: let age = '25'; makes age a STRING, not a NUMBER. You can't do math with it: '25' + 5 = '255' (string joining, not 30)."
                },
                {
                  "mistake": "Quotes around booleans: let isStudent = 'true'; makes it a STRING containing the word 'true', not the boolean value true.",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Quotes around booleans: let isStudent = 'true'; makes it a STRING containing the word 'true', not the boolean value true."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-03",
      "title": "Module 3: Making Decisions (The 'Forks in the Road')",
      "description": "Teach your program to make choices based on conditions",
      "difficulty": "beginner",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "3.1",
          "title": "Teaching Your Code to Choose (if Statements)",
          "moduleId": "module-03",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're a traffic cop at an intersection. When you see a red light, you tell cars to STOP. When you see a green light, you tell them to GO. You're making a decision based on a condition (the light color).\n\nThat's exactly what an 'if' statement does in code. It checks a condition (is something true or false?), and based on the answer, it decides what action to take.\n\nThink of it like a flowchart with a diamond-shaped decision box: 'Is it raining?' If YES, take umbrella. If NO, leave it home. In code, we call these YES/NO questions 'conditions', and they always evaluate to either true or false (remember booleans from Module 2?)."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "let temperature = 75;\n\n// The 'if' statement: \"IF this condition is true, THEN do this\"\nif (temperature > 70) {\n  console.log('It is warm outside!');\n}\n\nconsole.log('This line runs no matter what');\n\n// Another example\nlet isRaining = true;\n\nif (isRaining) {\n  console.log('Take an umbrella');\n}\n\n// You can check if something is false\nlet hasKeys = false;\n\nif (!hasKeys) {  // The ! means \"NOT\"\n  console.log('Go back and get your keys!');\n}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down an if statement:\n\nif (condition) {\n│  │          │ │\n│  │          │ └─ The code to run (the 'action')\n│  │          └─── Closing parenthesis\n│  └─────────────── The condition (must be true/false)\n└────────────────── The 'if' keyword\n\nKey points:\n\n1. if - This keyword says \"I'm about to check a condition\"\n\n2. (condition) - This must be something that evaluates to true or false\n   - temperature > 70 → either true or false\n   - isRaining → already a boolean (true or false)\n   - !hasKeys → the ! flips the boolean (false becomes true)\n\n3. { } - Curly braces contain the code that runs IF the condition is true\n   - If the condition is false, everything inside { } is skipped\n   - You can have multiple lines of code inside { }\n\n4. Code outside the if statement runs no matter what\n\nThe ! operator (NOT):\n- !true → false\n- !false → true\n- It flips/inverts the boolean value"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting parentheses around the condition: if age >= 18 won't work. Must be if (age >= 18)\n\n2. Using = instead of ==  or ===:\n   - if (age = 18) is WRONG - this assigns 18 to age!\n   - if (age === 18) is CORRECT - this checks if age equals 18\n\n3. Forgetting curly braces: While technically optional for single-line if statements, always use { } to avoid bugs later.\n\n4. Putting a semicolon after the condition: if (age >= 18); is wrong. The semicolon ends the if statement before it does anything!\n\n5. Trying to use 'AND' or 'OR' in English: if (age > 17 and age < 65) won't work. JavaScript uses && for 'and' and || for 'or' (we'll learn these soon)."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.1-challenge",
              "title": "Practice Challenge",
              "description": "Create a simple age checker:\n1. Create a variable 'age' and set it to any number\n2. Write an if statement that displays 'You can vote!' if age is 18 or greater\n3. Test it with different ages (try 17, then try 18)",
              "instructions": "Create a simple age checker:\n1. Create a variable 'age' and set it to any number\n2. Write an if statement that displays 'You can vote!' if age is 18 or greater\n3. Test it with different ages (try 17, then try 18)",
              "starterCode": "// Create your age variable\nlet age = 17;\n\n// Your code here\n",
              "solution": "let age = 18;\n\nif (age >= 18) {\n  console.log('You can vote!');\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Works for age 18 or above",
                  "expectedOutput": "You can vote!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the >= operator (greater than or equal to). Format: if (age >= 18) { console.log('You can vote!'); }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting parentheses around the condition: if age >= 18 won't work. Must be if (age >= 18)",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting parentheses around the condition: if age >= 18 won't work. Must be if (age >= 18)"
                },
                {
                  "mistake": "Using = instead of ==  or ===:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using = instead of ==  or ===:\n   - if (age = 18) is WRONG - this assigns 18 to age!\n   - if (age === 18) is CORRECT - this checks if age equals 18"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.2",
          "title": "Multiple Paths (else if and else)",
          "moduleId": "module-03",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're getting dressed based on the weather. Here's your thought process:\n\n'IF it's snowing → wear a heavy coat'\n'ELSE IF it's raining → wear a raincoat'\n'ELSE IF it's cold → wear a jacket'\n'ELSE → wear a t-shirt' (default for all other cases)\n\nYou're checking multiple conditions in order, and taking the FIRST one that's true. Once you've made a decision, you don't check the rest - you're already dressed!\n\nThis is exactly how else if and else work in programming. You can have multiple 'forks in the road', and your code will take the first path where the condition is true."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "let temperature = 45;\n\n// Multiple conditions with if...else if...else\nif (temperature > 80) {\n  console.log('It is hot! Wear shorts.');\n} else if (temperature > 60) {\n  console.log('It is nice! Wear a t-shirt.');\n} else if (temperature > 40) {\n  console.log('It is cold! Wear a jacket.');\n} else {\n  console.log('It is freezing! Wear a heavy coat.');\n}\n\n// Another example: letter grades\nlet score = 85;\n\nif (score >= 90) {\n  console.log('Grade: A');\n} else if (score >= 80) {\n  console.log('Grade: B');\n} else if (score >= 70) {\n  console.log('Grade: C');\n} else if (score >= 60) {\n  console.log('Grade: D');\n} else {\n  console.log('Grade: F');\n}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "The structure:\n\nif (first condition) {\n  // Runs if first condition is true\n} else if (second condition) {\n  // Runs if first is false BUT second is true  \n} else if (third condition) {\n  // Runs if first and second are false BUT third is true\n} else {\n  // Runs if ALL above conditions are false (the 'default')\n}\n\nImportant rules:\n\n1. You MUST start with 'if' - you can't have 'else if' or 'else' without an 'if' first\n\n2. You can have as many 'else if' blocks as you want (0, 1, 5, 100...)\n\n3. The 'else' block is optional - it's the \"catch-all\" for when nothing else is true\n\n4. ONLY ONE block of code will run - the first one with a true condition\n   - If the first 'if' is true, the rest are skipped completely\n   - If the first 'if' is false, check the first 'else if'\n   - And so on...\n\n5. Order matters! In the grade example:\n   - We check >= 90 first\n   - Then >= 80 (which also includes 90-100, but we already handled those)\n   - If we checked >= 60 first, everyone would get a 'D' because 90 >= 60 is true!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Wrong order of conditions:\n   if (score >= 60) { ... } else if (score >= 90) { ... }\n   This is wrong! If score is 95, the first condition (>= 60) is true, so it stops there. Always check from most specific to least specific.\n\n2. Using separate if statements instead of else if:\n   if (temp > 80) { ... }\n   if (temp > 60) { ... }  // WRONG - both could run!\n   Instead use: else if (temp > 60) { ... }\n\n3. Forgetting the 'else' keyword: writing if (cond1) { } if (cond2) { } won't work as intended.\n\n4. Putting code between the blocks:\n   if (x > 5) { }\n   console.log('hello');  // This runs no matter what!\n   else { }  // ERROR - can't have code between if and else"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.2-challenge",
              "title": "Practice Challenge",
              "description": "Create a movie rating advisor:\n1. Create a variable 'age' with a number\n2. If age is under 13: display 'You can watch G and PG movies'\n3. Else if age is under 17: display 'You can watch G, PG, and PG-13 movies'\n4. Else: display 'You can watch all movies including R-rated'",
              "instructions": "Create a movie rating advisor:\n1. Create a variable 'age' with a number\n2. If age is under 13: display 'You can watch G and PG movies'\n3. Else if age is under 17: display 'You can watch G, PG, and PG-13 movies'\n4. Else: display 'You can watch all movies including R-rated'",
              "starterCode": "let age = 15;\n\n// Write your if...else if...else statement here\n",
              "solution": "let age = 15;\n\nif (age < 13) {\n  console.log('You can watch G and PG movies');\n} else if (age < 17) {\n  console.log('You can watch G, PG, and PG-13 movies');\n} else {\n  console.log('You can watch all movies including R-rated');\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Correctly handles age 15",
                  "expectedOutput": "You can watch G, PG, and PG-13 movies",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use if (age < 13), then else if (age < 17), then else for the rest."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Wrong order of conditions:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Wrong order of conditions:\n   if (score >= 60) { ... } else if (score >= 90) { ... }\n   This is wrong! If score is 95, the first condition (>= 60) is true, so it stops there. Always check from most specific to least specific."
                },
                {
                  "mistake": "Using separate if statements instead of else if:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using separate if statements instead of else if:\n   if (temp > 80) { ... }\n   if (temp > 60) { ... }  // WRONG - both could run!\n   Instead use: else if (temp > 60) { ... }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.3",
          "title": "Comparison Operators (How to Compare Things)",
          "moduleId": "module-03",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "When you're shopping, you constantly compare things:\n\n'Is this apple bigger than that one?' (>)\n'Is this shirt the same price as that one?' (===)\n'Is this milk carton NOT expired?' (not equal to today's date)\n\nIn programming, we have special symbols for making these comparisons. They're called 'comparison operators', and they always give you a true/false answer - perfect for use in if statements!\n\nThink of them as questions you can ask:\n- '>' means 'Is this bigger?'\n- '<' means 'Is this smaller?'\n- '===' means 'Are these exactly the same?'\n- '!==' means 'Are these different?'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Greater than (>)\nlet age = 25;\nif (age > 18) {\n  console.log('You are an adult');  // true, runs\n}\n\n// Less than (<)\nlet temperature = 32;\nif (temperature < 40) {\n  console.log('It is very cold');  // true, runs\n}\n\n// Greater than or equal to (>=)\nlet score = 60;\nif (score >= 60) {\n  console.log('You passed!');  // true, runs (60 equals 60)\n}\n\n// Less than or equal to (<=)\nlet speed = 55;\nif (speed <= 55) {\n  console.log('You are within the speed limit');  // true, runs\n}\n\n// Equal to (===)\nlet userAnswer = 'Paris';\nif (userAnswer === 'Paris') {\n  console.log('Correct!');  // true, runs\n}\n\n// Not equal to (!==)\nlet status = 'pending';\nif (status !== 'complete') {\n  console.log('Still waiting...');  // true, runs\n}\n\n// You can also store comparison results in variables!\nlet isAdult = age >= 18;  // isAdult now holds true or false\nconsole.log(isAdult);  // Displays: true"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "The six comparison operators:\n\n1. >   Greater than\n   - 5 > 3 → true\n   - 3 > 5 → false\n   - 5 > 5 → false (not greater, they're equal)\n\n2. <   Less than\n   - 3 < 5 → true\n   - 5 < 3 → false\n   - 5 < 5 → false\n\n3. >=  Greater than OR equal to\n   - 5 >= 5 → true (the equal part makes it true)\n   - 6 >= 5 → true\n   - 4 >= 5 → false\n\n4. <=  Less than OR equal to\n   - 5 <= 5 → true\n   - 4 <= 5 → true\n   - 6 <= 5 → false\n\n5. === Exactly equal to (strict equality)\n   - 5 === 5 → true\n   - 5 === '5' → false (number vs string)\n   - 'cat' === 'cat' → true\n   - 'Cat' === 'cat' → false (case matters!)\n\n6. !== Not equal to (strict inequality)\n   - 5 !== 3 → true (they are different)\n   - 5 !== 5 → false (they are the same)\n\nAll comparison operators return a boolean (true or false). You can use them:\n- Directly in if statements: if (age > 18)\n- Store in variables: let canVote = age >= 18;\n- Display them: console.log(5 > 3);  // Shows: true"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Using = instead of ===:\n   if (age = 18)  // WRONG - this assigns 18 to age!\n   if (age === 18)  // CORRECT - this compares\n\n2. Using == instead of ===:\n   JavaScript has == (loose equality) and === (strict equality)\n   - 5 == '5' → true (converts types, then compares)\n   - 5 === '5' → false (different types)\n   ALWAYS use === and !== to avoid surprises\n\n3. Comparing strings with > or <:\n   'apple' < 'banana' → true (alphabetical order works!)\n   But '10' < '2' → true (compares as strings, not numbers)\n   To compare string numbers, convert first: Number('10') < Number('2') → false\n\n4. Case sensitivity:\n   'Hello' === 'hello' → false\n   To ignore case: 'Hello'.toLowerCase() === 'hello'.toLowerCase()\n\n5. Confusing >= and =>:\n   >= is greater-than-or-equal (comparison)\n   => is for arrow functions (we'll learn later)"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.3-challenge",
              "title": "Practice Challenge",
              "description": "Create a simple login validator:\n1. Create two variables: 'password' (a string) and 'confirmPassword' (another string)\n2. If they are equal (===), display 'Passwords match!'\n3. If they are not equal (!==), display 'Passwords do not match'",
              "instructions": "Create a simple login validator:\n1. Create two variables: 'password' (a string) and 'confirmPassword' (another string)\n2. If they are equal (===), display 'Passwords match!'\n3. If they are not equal (!==), display 'Passwords do not match'",
              "starterCode": "let password = 'secret123';\nlet confirmPassword = 'secret123';\n\n// Write your if...else statement here\n",
              "solution": "let password = 'secret123';\nlet confirmPassword = 'secret123';\n\nif (password === confirmPassword) {\n  console.log('Passwords match!');\n} else {\n  console.log('Passwords do not match');\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Detects matching passwords",
                  "expectedOutput": "Passwords match!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use === to check if they're equal: if (password === confirmPassword)"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Using = instead of ===:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using = instead of ===:\n   if (age = 18)  // WRONG - this assigns 18 to age!\n   if (age === 18)  // CORRECT - this compares"
                },
                {
                  "mistake": "Using == instead of ===:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using == instead of ===:\n   JavaScript has == (loose equality) and === (strict equality)\n   - 5 == '5' → true (converts types, then compares)\n   - 5 === '5' → false (different types)\n   ALWAYS use === and !== to avoid surprises"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.4",
          "title": "The Loose vs Strict Check (== vs ===)",
          "moduleId": "module-03",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're checking if two people are 'the same':\n\n**Loose check (==)**: 'Are they the same height?' You might say yes even if one person is wearing heels - you're flexible about what 'same' means.\n\n**Strict check (===)**: 'Are they the EXACT same height, measured precisely, wearing the exact same shoes?' You're being very specific.\n\nIn JavaScript:\n- == (loose equality) tries to be helpful by converting types: '5' == 5 → true\n- === (strict equality) requires exact match: '5' === 5 → false\n\nAlmost all professional JavaScript developers use === exclusively because it's more predictable and prevents bugs."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// The difference between == and ===\n\n// == (loose equality) - converts types\nconsole.log(5 == '5');     // true (converts '5' to number)\nconsole.log(true == 1);    // true (converts true to 1)\nconsole.log(false == 0);   // true (converts false to 0)\nconsole.log(null == undefined);  // true (special case)\n\n// === (strict equality) - no conversion\nconsole.log(5 === '5');    // false (number vs string)\nconsole.log(true === 1);   // false (boolean vs number)\nconsole.log(false === 0);  // false (boolean vs number)\nconsole.log(null === undefined);  // false (different types)\n\n// Real-world example where == causes bugs\nlet userInput = '0';  // User typed '0' in a form\n\nif (userInput == false) {\n  console.log('This runs! But did the user mean false?');\n}\n\nif (userInput === false) {\n  console.log('This does NOT run - safer!');\n}\n\n// Best practice: ALWAYS use ===\nlet count = 0;\nif (count === 0) {\n  console.log('Count is zero');\n}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding the two equality operators:\n\n== (Loose Equality)\n- Also called 'abstract equality'\n- Converts types before comparing\n- Can lead to unexpected results\n- Example: '5' == 5 → JavaScript converts '5' to 5, then compares → true\n\n=== (Strict Equality)\n- Also called 'strict equality'\n- No type conversion\n- Both value AND type must match\n- Example: '5' === 5 → Different types (string vs number) → false\n\nThe same applies to inequality:\n\n!= (Loose Inequality)\n- Converts types before comparing\n- 5 != '5' → false (they're 'equal' after conversion)\n\n!== (Strict Inequality)  \n- No type conversion\n- 5 !== '5' → true (different types, so not equal)\n\nType coercion with ==:\n- true == 1 → true\n- false == 0 → true\n- '' == 0 → true (empty string)\n- ' ' == 0 → true (space string)\n- [] == 0 → true (empty array)\n- null == undefined → true\n\nThese are all FALSE with ===!\n\n**Best Practice**: Use === and !== exclusively. The only time to use == is if you specifically want type coercion, which is rare."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Using == when you mean ===:\n   This is SO common. Most bugs from == are subtle and hard to spot.\n   Rule of thumb: ALWAYS use ===\n\n2. Not understanding type coercion:\n   if (userInput == true)  // Almost never what you want\n   Better: if (userInput === true) or just if (userInput)\n\n3. Assuming null == 0:\n   Actually, null == 0 → false\n   But null == undefined → true\n   Weird, right? That's why we use ===\n\n4. Forgetting that form inputs are strings:\n   <input type='number'> still gives you a string!\n   Always convert: Number(input.value)\n\n5. Triple equals in other languages:\n   PHP has ===, but most languages (Java, Python, C#) only have ==\n   JavaScript is unique in needing this distinction"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.4-challenge",
              "title": "Practice Challenge",
              "description": "Debug this code! A user typed their age in a form (stored as a string). We want to check if they're 18, but the code isn't working:\n\nlet userAge = '18';  // String from form input\nif (userAge === 18) {\n  console.log('You are 18!');\n} else {\n  console.log('You are not 18');\n}\n\nFix it TWO ways:\n1. Convert userAge to a number before comparing (use Number(userAge))\n2. Compare as strings (userAge === '18')",
              "instructions": "Debug this code! A user typed their age in a form (stored as a string). We want to check if they're 18, but the code isn't working:\n\nlet userAge = '18';  // String from form input\nif (userAge === 18) {\n  console.log('You are 18!');\n} else {\n  console.log('You are not 18');\n}\n\nFix it TWO ways:\n1. Convert userAge to a number before comparing (use Number(userAge))\n2. Compare as strings (userAge === '18')",
              "starterCode": "// Method 1: Convert to number\nlet userAge = '18';\n// YOUR CODE HERE\n\n// Method 2: Compare as strings  \nlet userAge2 = '18';\n// YOUR CODE HERE",
              "solution": "// Method 1: Convert to number\nlet userAge = '18';\nif (Number(userAge) === 18) {\n  console.log('You are 18!');\n}\n\n// Method 2: Compare as strings\nlet userAge2 = '18';\nif (userAge2 === '18') {\n  console.log('You are 18!');\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Compares correctly",
                  "expectedOutput": "You are 18!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Method 1: if (Number(userAge) === 18)\nMethod 2: if (userAge === '18')"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Using == when you mean ===:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using == when you mean ===:\n   This is SO common. Most bugs from == are subtle and hard to spot.\n   Rule of thumb: ALWAYS use ==="
                },
                {
                  "mistake": "Not understanding type coercion:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Not understanding type coercion:\n   if (userInput == true)  // Almost never what you want\n   Better: if (userInput === true) or just if (userInput)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.5",
          "title": "Combining Conditions (Logical Operators: &&, ||, !)",
          "moduleId": "module-03",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Sometimes you need to check multiple conditions at once:\n\n'Can I go to the movies?' \n- I need money AND I need time AND the movie needs to be showing\n- If ANY of these are false, I can't go\n\nThis is what the && operator does - it means 'AND'. All conditions must be true.\n\nOr consider:\n'Should I bring an umbrella?'\n- IF it's raining OR IF it's cloudy OR IF the forecast says rain\n- If ANY of these are true, bring it\n\nThis is what the || operator does - it means 'OR'. At least one condition must be true.\n\nWe also have ! which means 'NOT' - it flips true to false and vice versa."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// AND operator (&&) - ALL must be true\nlet hasTicket = true;\nlet hasTime = true;\nlet isShowing = true;\n\nif (hasTicket && hasTime && isShowing) {\n  console.log('You can watch the movie!');  // All true, this runs\n}\n\nlet age = 25;\nlet hasLicense = true;\n\nif (age >= 16 && hasLicense) {\n  console.log('You can drive');  // Both true, this runs\n}\n\n// OR operator (||) - AT LEAST ONE must be true\nlet isWeekend = true;\nlet isHoliday = false;\n\nif (isWeekend || isHoliday) {\n  console.log('You can sleep in!');  // One is true, this runs\n}\n\nlet temperature = 95;\nif (temperature > 90 || temperature < 32) {\n  console.log('Extreme weather!');  // First condition true, runs\n}\n\n// NOT operator (!) - flips true/false\nlet isRaining = false;\n\nif (!isRaining) {\n  console.log('No umbrella needed');  // !false = true, runs\n}\n\n// Combining operators\nlet hour = 14;\nlet isWeekday = true;\n\nif ((hour >= 9 && hour <= 17) && isWeekday) {\n  console.log('Office is open');\n}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "The three logical operators:\n\n1. && (AND)\n   - true && true → true\n   - true && false → false\n   - false && true → false\n   - false && false → false\n   - ALL conditions must be true for the result to be true\n\n2. || (OR)\n   - true || true → true\n   - true || false → true\n   - false || true → true\n   - false || false → false\n   - AT LEAST ONE condition must be true for the result to be true\n\n3. ! (NOT)\n   - !true → false\n   - !false → true\n   - Flips/inverts the boolean value\n\nOrder of operations:\n1. ! (NOT) happens first\n2. && (AND) happens second\n3. || (OR) happens last\n\nExample:\n!false && true || false\n= true && true || false  // ! first\n= true || false          // && second\n= true                   // || last\n\nUse parentheses for clarity:\n(age >= 18) && (hasLicense)\n\nShort-circuit evaluation:\n- With &&: If first is false, second is never checked\n  - false && (anything) → immediately false\n- With ||: If first is true, second is never checked\n  - true || (anything) → immediately true\n\nThis is useful but can cause subtle bugs if you're not careful!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Using 'and' or 'or' instead of symbols:\n   if (age > 18 and hasLicense)  // WRONG\n   if (age > 18 && hasLicense)   // CORRECT\n\n2. Confusing && and ||:\n   if (isWeekend || hasWork)  // Do I work on weekends or any day?\n   vs\n   if (isWeekend && !hasWork) // Free weekend?\n   Read them out loud to check!\n\n3. Forgetting parentheses with mixed operators:\n   if (a || b && c)  // Unclear!\n   if (a || (b && c))  // Better\n   if ((a || b) && c)  // Different meaning!\n\n4. Double negatives:\n   if (!!isLoggedIn)  // Just use: if (isLoggedIn)\n   Don't overthink it!\n\n5. Not understanding short-circuit:\n   if (user && user.name)  // Safe - checks user exists first\n   if (user.name && user)  // DANGEROUS - might error if user is null\n\n6. Trying to check multiple values at once:\n   if (x === 1 || 2 || 3)  // WRONG - doesn't work!\n   if (x === 1 || x === 2 || x === 3)  // CORRECT\n   Or better: if ([1,2,3].includes(x))  // We'll learn this later!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.5-challenge",
              "title": "Practice Challenge",
              "description": "Create a simple access control system for a secure building:\n1. Create variables: isEmployee (boolean), hasKeycard (boolean), securityLevel (number 1-3)\n2. Access is granted if:\n   - Person is an employee AND has a keycard\n   - OR security level is 3 (admin access)\n3. Display 'Access Granted' or 'Access Denied'",
              "instructions": "Create a simple access control system for a secure building:\n1. Create variables: isEmployee (boolean), hasKeycard (boolean), securityLevel (number 1-3)\n2. Access is granted if:\n   - Person is an employee AND has a keycard\n   - OR security level is 3 (admin access)\n3. Display 'Access Granted' or 'Access Denied'",
              "starterCode": "let isEmployee = true;\nlet hasKeycard = true;\nlet securityLevel = 2;\n\n// Write your if statement here\n// Access granted if: (isEmployee AND hasKeycard) OR securityLevel is 3\n",
              "solution": "let isEmployee = true;\nlet hasKeycard = true;\nlet securityLevel = 2;\n\nif ((isEmployee && hasKeycard) || securityLevel === 3) {\n  console.log('Access Granted');\n} else {\n  console.log('Access Denied');\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Grants access for employee with keycard",
                  "expectedOutput": "Access Granted",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use parentheses to group: if ((isEmployee && hasKeycard) || securityLevel === 3)"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Using 'and' or 'or' instead of symbols:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using 'and' or 'or' instead of symbols:\n   if (age > 18 and hasLicense)  // WRONG\n   if (age > 18 && hasLicense)   // CORRECT"
                },
                {
                  "mistake": "Confusing && and ||:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Confusing && and ||:\n   if (isWeekend || hasWork)  // Do I work on weekends or any day?\n   vs\n   if (isWeekend && !hasWork) // Free weekend?\n   Read them out loud to check!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-04",
      "title": "Module 4: Repeating Actions (The 'Loops')",
      "description": "Automate repetitive tasks using loops",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "4.1",
          "title": "Doing Something a Specific Number of Times (for Loops)",
          "moduleId": "module-04",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're a teacher taking attendance. You have a list of 25 students, and you need to call out each name, one by one:\n\n'Student 1: Are you here?'\n'Student 2: Are you here?'\n'Student 3: Are you here?'\n...and so on until student 25.\n\nYou're doing the SAME action 25 times, just changing the number. This is tedious to write out, but perfect for a loop!\n\nA 'for loop' is like saying: 'Start at 1, keep going until 25, and for each number, do this action.' The loop handles the counting automatically - you just tell it what to do each time."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Basic for loop - count from 0 to 4\nfor (let i = 0; i < 5; i++) {\n  console.log('Count: ' + i);\n}\n// Displays: Count: 0, Count: 1, Count: 2, Count: 3, Count: 4\n\n// Count from 1 to 10\nfor (let i = 1; i <= 10; i++) {\n  console.log(i);\n}\n\n// Count by twos (even numbers)\nfor (let i = 0; i <= 10; i += 2) {\n  console.log(i);  // 0, 2, 4, 6, 8, 10\n}\n\n// Count backwards\nfor (let i = 10; i >= 1; i--) {\n  console.log(i);\n}\nconsole.log('Blast off!');\n\n// Practical example: calculate total\nlet total = 0;\nfor (let i = 1; i <= 5; i++) {\n  total += i;  // Same as: total = total + i\n}\nconsole.log('Sum of 1 to 5: ' + total);  // 15"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Anatomy of a for loop:\n\nfor (initialization; condition; update) {\n     │              │          │\n     │              │          └─ What happens after each loop\n     │              └──────────── When to keep looping\n     └─────────────────────────── Where to start\n  // Code to repeat\n}\n\nLet's break down: for (let i = 0; i < 5; i++)\n\n1. **Initialization** (let i = 0)\n   - Runs ONCE at the very beginning\n   - Creates a counter variable (usually named i)\n   - Sets its starting value\n\n2. **Condition** (i < 5)\n   - Checked BEFORE each loop iteration\n   - If true, run the loop body\n   - If false, exit the loop\n\n3. **Update** (i++)\n   - Runs AFTER each loop iteration\n   - Usually increments the counter\n   - i++ means 'add 1 to i' (same as i = i + 1)\n\nHow it flows:\n1. let i = 0           (start)\n2. Is i < 5? Yes (0 < 5)  → run loop body\n3. i++ → i is now 1\n4. Is i < 5? Yes (1 < 5)  → run loop body\n5. i++ → i is now 2\n6. Is i < 5? Yes (2 < 5)  → run loop body\n7. i++ → i is now 3\n8. Is i < 5? Yes (3 < 5)  → run loop body\n9. i++ → i is now 4\n10. Is i < 5? Yes (4 < 5) → run loop body\n11. i++ → i is now 5\n12. Is i < 5? No (5 is NOT < 5) → EXIT LOOP\n\nCommon patterns:\n- Count up: i++\n- Count down: i--\n- Skip by 2: i += 2\n- Count by 10s: i += 10"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Off-by-one errors (VERY common!):\n   for (let i = 0; i < 5; i++)  // Runs 5 times (0,1,2,3,4)\n   for (let i = 1; i < 5; i++)  // Runs 4 times (1,2,3,4)\n   for (let i = 1; i <= 5; i++) // Runs 5 times (1,2,3,4,5)\n   Always test: does this loop run the right number of times?\n\n2. Infinite loops:\n   for (let i = 0; i < 5; i--) // i gets SMALLER, never reaches 5!\n   This will crash your program!\n\n3. Forgetting to increment:\n   for (let i = 0; i < 5; ) // Missing i++\n   Another infinite loop!\n\n4. Using = instead of ==:\n   for (let i = 0; i = 5; i++)  // WRONG - assigns 5 to i!\n   for (let i = 0; i < 5; i++)  // CORRECT\n\n5. Modifying the loop variable inside:\n   for (let i = 0; i < 5; i++) {\n     i = 0;  // BAD - creates infinite loop!\n   }\n   Don't change i inside the loop body!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.1-challenge",
              "title": "Practice Challenge",
              "description": "Create a multiplication table for 7:\nUse a for loop to display:\n7 x 1 = 7\n7 x 2 = 14\n7 x 3 = 21\n...up to...\n7 x 10 = 70\n\nHint: Loop from 1 to 10, and each time display: console.log('7 x ' + i + ' = ' + (7 * i));",
              "instructions": "Create a multiplication table for 7:\nUse a for loop to display:\n7 x 1 = 7\n7 x 2 = 14\n7 x 3 = 21\n...up to...\n7 x 10 = 70\n\nHint: Loop from 1 to 10, and each time display: console.log('7 x ' + i + ' = ' + (7 * i));",
              "starterCode": "// Create a for loop that goes from 1 to 10\n// Each time, display the multiplication\n",
              "solution": "for (let i = 1; i <= 10; i++) {\n  console.log('7 x ' + i + ' = ' + (7 * i));\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays 7 x 1 = 7",
                  "expectedOutput": "7 x 1 = 7",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "for (let i = 1; i <= 10; i++) { console.log('7 x ' + i + ' = ' + (7 * i)); }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Off-by-one errors (VERY common!):",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Off-by-one errors (VERY common!):\n   for (let i = 0; i < 5; i++)  // Runs 5 times (0,1,2,3,4)\n   for (let i = 1; i < 5; i++)  // Runs 4 times (1,2,3,4)\n   for (let i = 1; i <= 5; i++) // Runs 5 times (1,2,3,4,5)\n   Always test: does this loop run the right number of times?"
                },
                {
                  "mistake": "Infinite loops:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Infinite loops:\n   for (let i = 0; i < 5; i--) // i gets SMALLER, never reaches 5!\n   This will crash your program!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "4.2",
          "title": "Looping Until a Condition Changes (while Loops)",
          "moduleId": "module-04",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're filling a bathtub. You don't know EXACTLY how many seconds it will take - you just know you need to keep the water running WHILE the tub is not full.\n\nEvery few seconds you check: 'Is it full yet?' No → keep filling. 'Is it full yet?' No → keep filling. 'Is it full yet?' YES → turn off the water!\n\nThis is what a 'while loop' does. Unlike a for loop (where you know how many times to repeat), a while loop keeps going UNTIL a condition becomes false. You don't know how many times it will run - you just know the condition that needs to be met to stop."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Basic while loop - count to 5\nlet count = 0;\n\nwhile (count < 5) {\n  console.log('Count: ' + count);\n  count++;  // IMPORTANT: Don't forget to update!\n}\n\n// Practical example: password attempts\nlet password = 'secret';\nlet userInput = 'wrong';\nlet attempts = 0;\nlet maxAttempts = 3;\n\nwhile (userInput !== password && attempts < maxAttempts) {\n  console.log('Attempt ' + (attempts + 1) + ': Incorrect password');\n  // In a real app, you'd ask for input here\n  // For this example, we'll just increment\n  attempts++;\n  if (attempts === 2) {\n    userInput = 'secret';  // Correct on 3rd try\n  }\n}\n\nif (userInput === password) {\n  console.log('Access granted!');\n} else {\n  console.log('Too many failed attempts');\n}\n\n// Countdown example\nlet countdown = 5;\nwhile (countdown > 0) {\n  console.log(countdown);\n  countdown--;\n}\nconsole.log('Liftoff!');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Structure of a while loop:\n\nwhile (condition) {\n       │\n       └─ Keep looping while this is true\n  // Code to repeat\n  // MUST update something that affects the condition!\n}\n\nHow it works:\n1. Check the condition\n2. If true: run the loop body, then go back to step 1\n3. If false: exit the loop\n\nCritical difference from for loop:\n- for loop: Use when you KNOW how many times to loop\n  for (let i = 0; i < 10; i++) { }  // Exactly 10 times\n\n- while loop: Use when you DON'T know how many times\n  while (notFullYet) { }  // Until it's full (who knows how long?)\n\n**WARNING**: You MUST change something in the loop that affects the condition, or you'll create an infinite loop!\n\nGood (will eventually stop):\nlet x = 0;\nwhile (x < 5) {\n  console.log(x);\n  x++;  // x changes, will eventually reach 5\n}\n\nBAD (infinite loop!):\nlet x = 0;\nwhile (x < 5) {\n  console.log(x);  // x never changes!\n  // Loop runs forever!\n}\n\nCommon while loop patterns:\n- Keep trying until success\n- Process until data runs out\n- Wait for a condition to change"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting to update the condition variable:\n   let x = 0;\n   while (x < 10) {\n     console.log(x);  // x never changes - INFINITE LOOP!\n   }\n\n2. Updating in the wrong direction:\n   let x = 0;\n   while (x < 10) {\n     console.log(x);\n     x--;  // x gets MORE negative - INFINITE LOOP!\n   }\n\n3. Wrong comparison operator:\n   let x = 0;\n   while (x < 10) {\n     console.log(x);\n     x--;  // Should be x++\n   }\n\n4. Condition that's never true:\n   let x = 5;\n   while (x < 0) {  // 5 is not < 0\n     // This never runs at all!\n   }\n\n5. Not initializing before the loop:\n   while (count < 10) {  // count is not defined!\n     count++;\n   }\n   Must declare: let count = 0; BEFORE the while loop"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.2-challenge",
              "title": "Practice Challenge",
              "description": "Create a simple number guessing game:\n1. Set a target number (e.g., 7)\n2. Set a guess variable to 1\n3. Use a while loop that runs while guess is not equal to target\n4. Each time through the loop:\n   - Display: 'Guess: [number] - Wrong!'\n   - Increment guess by 1\n5. After the loop, display: 'Guess: [number] - Correct!'",
              "instructions": "Create a simple number guessing game:\n1. Set a target number (e.g., 7)\n2. Set a guess variable to 1\n3. Use a while loop that runs while guess is not equal to target\n4. Each time through the loop:\n   - Display: 'Guess: [number] - Wrong!'\n   - Increment guess by 1\n5. After the loop, display: 'Guess: [number] - Correct!'",
              "starterCode": "let target = 7;\nlet guess = 1;\n\n// Write your while loop here\n\n// After the loop, display the correct message\n",
              "solution": "let target = 7;\nlet guess = 1;\n\nwhile (guess !== target) {\n  console.log('Guess: ' + guess + ' - Wrong!');\n  guess++;\n}\n\nconsole.log('Guess: ' + guess + ' - Correct!');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Keeps guessing until correct",
                  "expectedOutput": "Guess: 1 - Wrong!\nGuess: 2 - Wrong!\nGuess: 3 - Correct!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "while (guess !== target) { console.log('Guess: ' + guess + ' - Wrong!'); guess++; }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting to update the condition variable:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting to update the condition variable:\n   let x = 0;\n   while (x < 10) {\n     console.log(x);  // x never changes - INFINITE LOOP!\n   }"
                },
                {
                  "mistake": "Updating in the wrong direction:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Updating in the wrong direction:\n   let x = 0;\n   while (x < 10) {\n     console.log(x);\n     x--;  // x gets MORE negative - INFINITE LOOP!\n   }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "4.3",
          "title": "Breaking Out Early (break and continue)",
          "moduleId": "module-04",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're looking through a stack of 100 papers for a specific document:\n\n**break**: You find the document on paper #37. You don't need to look through the remaining 63 papers - you STOP immediately and leave. That's what 'break' does - it exits the loop early.\n\n**continue**: You're reading through papers, but whenever you see a blank page, you skip it and go to the next one without processing it. That's what 'continue' does - it skips to the next iteration of the loop.\n\nBoth are useful for making loops more efficient and handling special cases."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// BREAK - exit the loop early\nconsole.log('--- Using break ---');\nfor (let i = 1; i <= 10; i++) {\n  if (i === 5) {\n    console.log('Found 5! Stopping.');\n    break;  // Exit the entire loop\n  }\n  console.log(i);\n}\nconsole.log('Loop finished');\n// Output: 1, 2, 3, 4, Found 5! Stopping., Loop finished\n\n// CONTINUE - skip to next iteration\nconsole.log('--- Using continue ---');\nfor (let i = 1; i <= 10; i++) {\n  if (i % 2 === 0) {  // If even number\n    continue;  // Skip the rest, go to next iteration\n  }\n  console.log(i);  // Only odd numbers print\n}\n// Output: 1, 3, 5, 7, 9\n\n// Practical: searching for a value\nlet numbers = [5, 8, 12, 15, 20, 25];\nlet target = 15;\nlet found = false;\n\nfor (let i = 0; i < numbers.length; i++) {\n  if (numbers[i] === target) {\n    console.log('Found ' + target + ' at position ' + i);\n    found = true;\n    break;  // No need to keep searching!\n  }\n}\n\nif (!found) {\n  console.log(target + ' not found');\n}\n\n// Skip invalid data\nfor (let i = 1; i <= 5; i++) {\n  if (i === 3) {\n    console.log('Skipping 3');\n    continue;\n  }\n  console.log('Processing: ' + i);\n}\n// Processes 1, 2, skips 3, processes 4, 5"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Two flow control keywords:\n\n**break**\n- Immediately exits the loop\n- Execution continues after the loop\n- Use when you've found what you're looking for\n- Use when a condition makes continuing pointless\n\nExample:\nfor (let i = 0; i < 100; i++) {\n  if (found) {\n    break;  // Don't check remaining 90 items\n  }\n}\nconsole.log('Continue here');  // This runs after break\n\n**continue**\n- Skips the rest of the current iteration\n- Goes directly to the next iteration\n- Use to skip invalid/unwanted values\n- Use to avoid deep nesting\n\nExample:\nfor (let i = 0; i < 10; i++) {\n  if (i === 5) {\n    continue;  // Skip when i is 5\n  }\n  console.log(i);  // This doesn't run when i is 5\n  // But runs for all other values\n}\n\nComparing break vs continue:\n\nbreak:\nfor (let i = 0; i < 5; i++) {\n  if (i === 3) break;\n  console.log(i);\n}\n// Prints: 0, 1, 2 (then EXITS loop)\n\ncontinue:\nfor (let i = 0; i < 5; i++) {\n  if (i === 3) continue;\n  console.log(i);\n}\n// Prints: 0, 1, 2, 4 (SKIPS 3, continues loop)\n\nImportant: break and continue only affect the INNERMOST loop they're in. If you have nested loops, they don't break out of all loops."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Using break outside a loop:\n   if (x > 5) {\n     break;  // ERROR - not in a loop!\n   }\n   break only works inside loops or switch statements\n\n2. Confusing break and return:\n   - break exits a loop\n   - return exits a function (we'll learn soon)\n   Don't mix them up!\n\n3. Expecting break to exit nested loops:\n   for (let i = 0; i < 3; i++) {\n     for (let j = 0; j < 3; j++) {\n       if (j === 1) break;  // Only exits inner loop!\n     }\n   }\n   To exit all loops, use a flag or a function with return\n\n4. Forgetting to update counter before continue:\n   let i = 0;\n   while (i < 10) {\n     if (i === 5) continue;  // INFINITE LOOP!\n     console.log(i);\n     i++;  // Never reached when i is 5\n   }\n   Fix: Put i++ before the continue check\n\n5. Overusing break/continue:\n   Sometimes an if statement is clearer:\n   for (let i = 0; i < 10; i++) {\n     if (i !== 5) {  // Clearer than using continue\n       console.log(i);\n     }\n   }"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.3-challenge",
              "title": "Practice Challenge",
              "description": "Create a loop that finds the first number divisible by 7 between 1 and 50:\n1. Use a for loop from 1 to 50\n2. Check if the number is divisible by 7 (use i % 7 === 0)\n3. When you find it, display 'First number divisible by 7: [number]'\n4. Use 'break' to exit the loop (no need to check the rest)",
              "instructions": "Create a loop that finds the first number divisible by 7 between 1 and 50:\n1. Use a for loop from 1 to 50\n2. Check if the number is divisible by 7 (use i % 7 === 0)\n3. When you find it, display 'First number divisible by 7: [number]'\n4. Use 'break' to exit the loop (no need to check the rest)",
              "starterCode": "// Loop from 1 to 50\n// Check if divisible by 7\n// Display and break when found\n",
              "solution": "for (let i = 1; i <= 50; i++) {\n  if (i % 7 === 0) {\n    console.log('First number divisible by 7: ' + i);\n    break;\n  }\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Finds first number divisible by 7",
                  "expectedOutput": "First number divisible by 7: 7",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "for (let i = 1; i <= 50; i++) { if (i % 7 === 0) { console.log('First number divisible by 7: ' + i); break; } }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Using break outside a loop:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using break outside a loop:\n   if (x > 5) {\n     break;  // ERROR - not in a loop!\n   }\n   break only works inside loops or switch statements"
                },
                {
                  "mistake": "Confusing break and return:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Confusing break and return:\n   - break exits a loop\n   - return exits a function (we'll learn soon)\n   Don't mix them up!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "4.4",
          "title": "Looping Through Lists (for...of)",
          "moduleId": "module-04",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have a playlist of songs, and you want to play each one in order. You don't care about the position (song #1, song #2, etc.) - you just want to go through each song:\n\n'Play song: Song A'\n'Play song: Song B'\n'Play song: Song C'\n\nYou're iterating through the LIST, not counting numbers. This is perfect for the 'for...of' loop - it's designed specifically for going through each item in a list (array) without worrying about indices or counters."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Old way: using a regular for loop with an index\nlet fruits = ['apple', 'banana', 'cherry'];\n\nfor (let i = 0; i < fruits.length; i++) {\n  console.log(fruits[i]);  // Need to use fruits[i] to get the item\n}\n\n// New way: for...of loop (much cleaner!)\nfor (let fruit of fruits) {\n  console.log(fruit);  // Direct access to each item\n}\n\n// Another example: summing numbers\nlet numbers = [10, 20, 30, 40, 50];\nlet total = 0;\n\nfor (let num of numbers) {\n  total += num;\n}\nconsole.log('Total: ' + total);  // 150\n\n// Works with strings too! (string is a list of characters)\nlet word = 'hello';\n\nfor (let letter of word) {\n  console.log(letter);  // h, e, l, l, o\n}\n\n// Practical: find if item exists\nlet shoppingCart = ['milk', 'eggs', 'bread', 'butter'];\nlet lookingFor = 'eggs';\nlet hasItem = false;\n\nfor (let item of shoppingCart) {\n  if (item === lookingFor) {\n    hasItem = true;\n    break;\n  }\n}\n\nconsole.log(hasItem ? 'Found it!' : 'Not in cart');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding for...of:\n\nfor (let item of array) {\n     │   │    │    │\n     │   │    │    └─ The array to loop through\n     │   │    └────── The 'of' keyword\n     │   └─────────── Variable to hold each item (you choose the name)\n     └─────────────── let (or const)\n  // Use 'item' here\n}\n\nComparing loop types:\n\n// Regular for loop - use when you need the INDEX\nfor (let i = 0; i < arr.length; i++) {\n  console.log('Position ' + i + ': ' + arr[i]);\n}\n\n// for...of loop - use when you just need the ITEMS\nfor (let item of arr) {\n  console.log(item);  // Don't care about position\n}\n\n// while loop - use when you don't know how many times\nwhile (notDone) {\n  // Keep going until condition changes\n}\n\nWhen to use for...of:\n✓ Going through all items in an array\n✓ Don't need the index/position\n✓ Cleaner, more readable code\n\nWhen NOT to use for...of:\n✗ Need the index number\n✗ Need to modify the array while looping\n✗ Looping a specific number of times (use regular for)\n\nNote: You can use 'const' instead of 'let' in for...of:\nfor (const fruit of fruits) {\n  // fruit is reassigned each iteration, so const works!\n}\n\nArray.length:\n- Every array has a .length property\n- fruits.length → 3 (number of items)\n- Use in regular for loops: i < arr.length"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Using 'in' instead of 'of':\n   for (let fruit in fruits)  // WRONG - gives index, not item!\n   for (let fruit of fruits)  // CORRECT - gives the item\n   \n   Confusing, right? Remember: 'of' for values, 'in' for keys (we'll learn later)\n\n2. Trying to get the index:\n   for (let fruit of fruits) {\n     console.log(i);  // ERROR - i doesn't exist!\n   }\n   If you need the index, use a regular for loop or .forEach() (later)\n\n3. Modifying the array while looping:\n   for (let fruit of fruits) {\n     fruits.push('new');  // DANGEROUS - might cause infinite loop!\n   }\n   Don't modify the array you're looping through\n\n4. Expecting it to work on objects:\n   let person = {name: 'Alice', age: 25};\n   for (let prop of person)  // ERROR - for...of doesn't work on plain objects!\n   Use for...in for objects (later lesson)\n\n5. Using wrong variable name:\n   for (let fruit of fruits) {\n     console.log(fruits);  // Prints whole array each time!\n   }\n   Should be: console.log(fruit);  // Just one item"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.4-challenge",
              "title": "Practice Challenge",
              "description": "You have a list of temperatures in Celsius. Convert each to Fahrenheit and display it:\n1. Given array: [0, 10, 20, 30, 40]\n2. Use a for...of loop\n3. For each temperature, convert to Fahrenheit: (celsius * 9/5) + 32\n4. Display: '[celsius]°C is [fahrenheit]°F'",
              "instructions": "You have a list of temperatures in Celsius. Convert each to Fahrenheit and display it:\n1. Given array: [0, 10, 20, 30, 40]\n2. Use a for...of loop\n3. For each temperature, convert to Fahrenheit: (celsius * 9/5) + 32\n4. Display: '[celsius]°C is [fahrenheit]°F'",
              "starterCode": "let celsiusTemps = [0, 10, 20, 30, 40];\n\n// Use for...of to loop through each temperature\n// Convert and display each one\n",
              "solution": "let celsiusTemps = [0, 10, 20, 30, 40];\n\nfor (let celsius of celsiusTemps) {\n  let fahrenheit = (celsius * 9/5) + 32;\n  console.log(celsius + '°C is ' + fahrenheit + '°F');\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Converts 0°C correctly",
                  "expectedOutput": "0°C is 32°F",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "for (let celsius of celsiusTemps) { let fahrenheit = (celsius * 9/5) + 32; console.log(...); }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Using 'in' instead of 'of':",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using 'in' instead of 'of':\n   for (let fruit in fruits)  // WRONG - gives index, not item!\n   for (let fruit of fruits)  // CORRECT - gives the item\n   \n   Confusing, right? Remember: 'of' for values, 'in' for keys (we'll learn later)"
                },
                {
                  "mistake": "Trying to get the index:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Trying to get the index:\n   for (let fruit of fruits) {\n     console.log(i);  // ERROR - i doesn't exist!\n   }\n   If you need the index, use a regular for loop or .forEach() (later)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-05",
      "title": "Module 5: Grouping Information (The 'Containers')",
      "description": "Store and organize multiple pieces of related information using arrays and objects",
      "difficulty": "beginner",
      "estimatedHours": 3.8,
      "lessons": [
        {
          "id": "5.1",
          "title": "Ordered Lists of Things (Arrays)",
          "moduleId": "module-05",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have a shopping list written on paper:\n\n1. Milk\n2. Eggs\n3. Bread\n4. Butter\n\nThis is an ordered list - each item has a position (1st, 2nd, 3rd, etc.). In programming, we call this an ARRAY. It's a single variable that can hold multiple values in a specific order.\n\nThink of an array like a train with numbered cars: Car 0 has apples, Car 1 has bananas, Car 2 has cherries. The numbers (0, 1, 2) are called 'indices' (plural of index), and they tell you where each item is located.\n\nImportant quirk: Programming counts from 0, not 1! So the first item is at position 0, the second at position 1, and so on."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Creating an array\nlet fruits = ['apple', 'banana', 'cherry'];\n\n// Accessing items by index (position)\nconsole.log(fruits[0]);  // apple (first item)\nconsole.log(fruits[1]);  // banana (second item)\nconsole.log(fruits[2]);  // cherry (third item)\n\n// Arrays can hold different types\nlet mixed = ['text', 42, true, null];\nconsole.log(mixed[1]);  // 42\n\n// Empty array\nlet empty = [];\n\n// Array length (how many items)\nconsole.log(fruits.length);  // 3\n\n// Last item (using length)\nlet lastFruit = fruits[fruits.length - 1];\nconsole.log(lastFruit);  // cherry\n\n// Changing an item\nfruits[1] = 'blueberry';\nconsole.log(fruits);  // ['apple', 'blueberry', 'cherry']\n\n// Loop through array\nfor (let i = 0; i < fruits.length; i++) {\n  console.log('Item ' + i + ': ' + fruits[i]);\n}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Array syntax:\n\n// Creating arrays\nlet arrayName = [item1, item2, item3];\nlet empty = [];\n\n// Accessing items (zero-indexed!)\narray[0]  // First item\narray[1]  // Second item\narray[2]  // Third item\n\n// Index visualization:\nlet numbers = [10, 20, 30, 40, 50];\n//  Index:     0   1   2   3   4\n//  Value:    10  20  30  40  50\n\nnumbers[0] → 10\nnumbers[4] → 50\nnumbers[5] → undefined (doesn't exist)\n\nKey properties:\n\n1. .length - number of items\n   - ['a', 'b', 'c'].length → 3\n   - [].length → 0\n\n2. Zero-indexed\n   - First item: array[0]\n   - Last item: array[array.length - 1]\n\n3. Mutable (can be changed)\n   - array[0] = 'new value'\n\n4. Can hold any type\n   - [1, 'text', true, {}, []]  // all valid\n\nCommon patterns:\n\n// Last item\nlet last = array[array.length - 1];\n\n// Check if empty\nif (array.length === 0) {\n  console.log('Empty');\n}\n\n// Loop through all items\nfor (let i = 0; i < array.length; i++) {\n  // use array[i]\n}"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Starting at index 1 instead of 0:\n   array[1]  // This is the SECOND item, not first!\n   array[0]  // This is the first item\n\n2. Accessing index === length:\n   let arr = ['a', 'b', 'c'];  // length is 3\n   arr[3]  // undefined - no such index!\n   // Valid indices: 0, 1, 2\n\n3. Forgetting .length is a property, not a method:\n   array.length()  // WRONG\n   array.length    // CORRECT (no parentheses)\n\n4. Confusing length with last index:\n   let arr = ['a', 'b', 'c'];\n   arr.length       // 3 (count of items)\n   arr[arr.length]  // undefined!\n   arr[arr.length - 1]  // 'c' (last item)\n\n5. Treating arrays like single values:\n   let arr = [1, 2, 3];\n   console.log(arr);  // Prints whole array [1, 2, 3]\n   console.log(arr[0]);  // Prints just first item: 1"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.1-challenge",
              "title": "Practice Challenge",
              "description": "Create a simple gradebook:\n1. Create an array of test scores: [85, 92, 78, 95, 88]\n2. Display the first score (index 0)\n3. Display the last score (use .length - 1)\n4. Calculate and display the average score (sum all, divide by length)",
              "instructions": "Create a simple gradebook:\n1. Create an array of test scores: [85, 92, 78, 95, 88]\n2. Display the first score (index 0)\n3. Display the last score (use .length - 1)\n4. Calculate and display the average score (sum all, divide by length)",
              "starterCode": "let scores = [85, 92, 78, 95, 88];\n\n// Display first score\n\n// Display last score\n\n// Calculate average\nlet total = 0;\n// Use a loop to sum all scores\n// Then divide by scores.length\n",
              "solution": "let scores = [85, 92, 78, 95, 88];\n\nconsole.log('First score: ' + scores[0]);\nconsole.log('Last score: ' + scores[scores.length - 1]);\n\nlet total = 0;\nfor (let i = 0; i < scores.length; i++) {\n  total += scores[i];\n}\n\nlet average = total / scores.length;\nconsole.log('Average: ' + average);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays first score",
                  "expectedOutput": "85",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "First: scores[0], Last: scores[scores.length - 1], Average: sum all in loop, divide by scores.length"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Starting at index 1 instead of 0:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Starting at index 1 instead of 0:\n   array[1]  // This is the SECOND item, not first!\n   array[0]  // This is the first item"
                },
                {
                  "mistake": "Accessing index === length:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Accessing index === length:\n   let arr = ['a', 'b', 'c'];  // length is 3\n   arr[3]  // undefined - no such index!\n   // Valid indices: 0, 1, 2"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.2",
          "title": "Adding and Removing Items (Array Methods: push, pop, shift, unshift)",
          "moduleId": "module-05",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine your array is a line of people:\n\n**push()**: Someone new joins the END of the line\n**pop()**: The person at the END of the line leaves\n**unshift()**: Someone cuts in at the FRONT of the line\n**shift()**: The person at the FRONT of the line leaves\n\nThese four methods let you add or remove items from either end of an array. They're like doors - two at the back (push/pop) and two at the front (shift/unshift)."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "let fruits = ['apple', 'banana'];\nconsole.log(fruits);  // ['apple', 'banana']\n\n// push() - add to the END\nfruits.push('cherry');\nconsole.log(fruits);  // ['apple', 'banana', 'cherry']\n\n// Can push multiple at once\nfruits.push('date', 'elderberry');\nconsole.log(fruits);  // ['apple', 'banana', 'cherry', 'date', 'elderberry']\n\n// pop() - remove from the END, returns the removed item\nlet removed = fruits.pop();\nconsole.log(removed);  // 'elderberry'\nconsole.log(fruits);  // ['apple', 'banana', 'cherry', 'date']\n\n// unshift() - add to the FRONT\nfruits.unshift('apricot');\nconsole.log(fruits);  // ['apricot', 'apple', 'banana', 'cherry', 'date']\n\n// shift() - remove from the FRONT, returns the removed item\nlet firstItem = fruits.shift();\nconsole.log(firstItem);  // 'apricot'\nconsole.log(fruits);  // ['apple', 'banana', 'cherry', 'date']\n\n// Practical: stack (Last In, First Out)\nlet stack = [];\nstack.push('task 1');\nstack.push('task 2');\nstack.push('task 3');\nlet current = stack.pop();  // 'task 3' - most recent\n\n// Practical: queue (First In, First Out)\nlet queue = [];\nqueue.push('person 1');\nqueue.push('person 2');\nqueue.push('person 3');\nlet next = queue.shift();  // 'person 1' - first in line"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "The four basic array methods:\n\n1. push(item) - add to END\n   - Adds one or more items to the end\n   - Returns new length\n   - Example: arr.push('x') → adds 'x' to end\n\n2. pop() - remove from END\n   - Removes last item\n   - Returns the removed item\n   - Example: let last = arr.pop()\n\n3. unshift(item) - add to FRONT\n   - Adds one or more items to the beginning\n   - Shifts all existing items to higher indices\n   - Returns new length\n   - Example: arr.unshift('x') → adds 'x' to front\n\n4. shift() - remove from FRONT\n   - Removes first item\n   - Shifts all remaining items to lower indices\n   - Returns the removed item\n   - Example: let first = arr.shift()\n\nMemory trick:\n- push/pop: work with the END (both have 'p')\n- shift/unshift: work with the FRONT\n- push/unshift: ADD items\n- pop/shift: REMOVE items\n\nPerformance notes:\n- push() and pop(): Fast (O(1))\n- shift() and unshift(): Slower (O(n)) because indices must be recalculated\n- For large arrays, avoid shift/unshift if performance matters\n\nThese methods MODIFY the original array:\nlet arr = [1, 2];\narr.push(3);  // arr is now [1, 2, 3]\n// The original array changed!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting these methods modify the array:\n   let arr = [1, 2, 3];\n   arr.push(4);  // arr is NOW [1, 2, 3, 4]\n   // It's not arr2 = arr.push(4)\n\n2. Expecting push/pop to work on both ends:\n   arr.pop()  // Removes from END, not front\n   // Use shift() to remove from front\n\n3. Not using the return value:\n   arr.pop();  // Item is removed AND returned\n   let item = arr.pop();  // Save the removed item!\n\n4. Confusing shift/unshift names:\n   shift = remove first (shifts everything left)\n   unshift = add to first (unshifts everything right)\n   Confusing, but that's the name!\n\n5. Using on non-arrays:\n   let str = 'hello';\n   str.push('x');  // ERROR - strings don't have push\n   // Convert to array first: str.split('')"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.2-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a simple to-do list:\n1. Start with an empty array: let todos = []\n2. Add 'Buy groceries' to the end\n3. Add 'Clean room' to the end\n4. Add 'URGENT: Pay bills' to the FRONT (it's urgent!)\n5. Display the array\n6. Complete the first task (remove it with shift())\n7. Display the updated array",
              "instructions": "Simulate a simple to-do list:\n1. Start with an empty array: let todos = []\n2. Add 'Buy groceries' to the end\n3. Add 'Clean room' to the end\n4. Add 'URGENT: Pay bills' to the FRONT (it's urgent!)\n5. Display the array\n6. Complete the first task (remove it with shift())\n7. Display the updated array",
              "starterCode": "let todos = [];\n\n// Add tasks\n\n// Display\n\n// Complete first task\n\n// Display again\n",
              "solution": "let todos = [];\n\ntodos.push('Buy groceries');\ntodos.push('Clean room');\ntodos.unshift('URGENT: Pay bills');\n\nconsole.log('Todos:', todos);\n// ['URGENT: Pay bills', 'Buy groceries', 'Clean room']\n\nlet completed = todos.shift();\nconsole.log('Completed:', completed);\nconsole.log('Remaining todos:', todos);\n// ['Buy groceries', 'Clean room']",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Builds todo list correctly",
                  "expectedOutput": "3",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "push() for end, unshift() for front, shift() to remove first"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting these methods modify the array:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting these methods modify the array:\n   let arr = [1, 2, 3];\n   arr.push(4);  // arr is NOW [1, 2, 3, 4]\n   // It's not arr2 = arr.push(4)"
                },
                {
                  "mistake": "Expecting push/pop to work on both ends:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Expecting push/pop to work on both ends:\n   arr.pop()  // Removes from END, not front\n   // Use shift() to remove from front"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.3",
          "title": "Transforming Arrays (map, filter, reduce)",
          "moduleId": "module-05",
          "order": 3,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding Functional Array Transformation",
              "content": "Imagine you have a stack of photographs and want to create different versions for different purposes. You could:\n\n1. **Transform each photo** (like adding a filter to every photo) - this is map()\n2. **Select certain photos** (keeping only landscape shots) - this is filter()\n3. **Combine all photos** into a single collage - this is reduce()\n\nThe key insight is that you NEVER modify the original photos. Instead, you create NEW versions. This is called **immutability** - keeping your original data unchanged.\n\nWhy does immutability matter?\n\n- **Debugging is easier**: If something goes wrong, your original data is still intact\n- **Code is predictable**: Functions that don't change their inputs are easier to understand\n- **Undo is possible**: You can always go back to the original\n- **Modern frameworks require it**: React, Vue, and other frameworks expect you to create new arrays instead of modifying existing ones\n\nThink of these methods like a photo editing app that always creates a copy before making changes. The 'History' panel works because each edit creates a new version, not because the app remembers every pixel change.\n\nThese three methods - map(), filter(), and reduce() - are the foundation of functional programming in JavaScript. Once you master them, you'll write cleaner, more expressive code that's easier to test and maintain."
            },
            {
              "type": "EXAMPLE",
              "title": "map() - Transform Every Element",
              "content": "The map() method creates a NEW array by applying a transformation function to every element. The original array is never modified. The new array always has the same number of elements as the original - map transforms but never adds or removes items.",
              "language": "javascript",
              "code": "// map() transforms EVERY element and returns a NEW array\n// Original array is NEVER modified\n\n// Example 1: Double every number\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = numbers.map(function(num) {\n  return num * 2;\n});\nconsole.log(doubled);   // [2, 4, 6, 8, 10]\nconsole.log(numbers);   // [1, 2, 3, 4, 5] - UNCHANGED!\n\n// Example 2: Square every number (arrow function shorthand)\nlet squared = numbers.map(num => num * num);\nconsole.log(squared);   // [1, 4, 9, 16, 25]\n\n// Example 3: Extract property from objects\nlet users = [\n  { name: 'Alice', age: 25, email: 'alice@example.com' },\n  { name: 'Bob', age: 30, email: 'bob@example.com' },\n  { name: 'Charlie', age: 35, email: 'charlie@example.com' }\n];\n\nlet names = users.map(user => user.name);\nconsole.log(names);   // ['Alice', 'Bob', 'Charlie']\n\nlet emails = users.map(user => user.email);\nconsole.log(emails);  // ['alice@example.com', 'bob@example.com', 'charlie@example.com']\n\n// Example 4: Format data for display\nlet prices = [19.99, 45.50, 99.00, 12.75];\nlet formatted = prices.map(price => '$' + price.toFixed(2));\nconsole.log(formatted);  // ['$19.99', '$45.50', '$99.00', '$12.75']\n\n// Example 5: Calculate with tax\nlet taxRate = 0.08;  // 8% tax\nlet withTax = prices.map(price => {\n  let tax = price * taxRate;\n  let total = price + tax;\n  return Math.round(total * 100) / 100;  // Round to 2 decimal places\n});\nconsole.log(withTax);  // [21.59, 49.14, 106.92, 13.77]\n\n// Example 6: Transform objects into new objects\nlet products = [\n  { name: 'Laptop', price: 1000 },\n  { name: 'Mouse', price: 25 },\n  { name: 'Keyboard', price: 75 }\n];\n\nlet productCards = products.map(product => {\n  return {\n    title: product.name.toUpperCase(),\n    displayPrice: '$' + product.price.toFixed(2),\n    originalProduct: product\n  };\n});\nconsole.log(productCards);\n// [\n//   { title: 'LAPTOP', displayPrice: '$1000.00', originalProduct: {...} },\n//   { title: 'MOUSE', displayPrice: '$25.00', originalProduct: {...} },\n//   { title: 'KEYBOARD', displayPrice: '$75.00', originalProduct: {...} }\n// ]\n\n// Verify original array is unchanged\nconsole.log(products[0].name);  // 'Laptop' (not 'LAPTOP')"
            },
            {
              "type": "EXAMPLE",
              "title": "filter() - Keep What Matches",
              "content": "The filter() method creates a NEW array containing only the elements that pass a test (return true from the callback). The original array is never modified. The new array may be shorter than the original, or even empty if nothing matches.",
              "language": "javascript",
              "code": "// filter() keeps elements that pass a test and returns a NEW array\n// Original array is NEVER modified\n\n// Example 1: Filter numbers by condition\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nlet evenNumbers = numbers.filter(num => num % 2 === 0);\nconsole.log(evenNumbers);  // [2, 4, 6, 8, 10]\n\nlet bigNumbers = numbers.filter(num => num > 5);\nconsole.log(bigNumbers);   // [6, 7, 8, 9, 10]\n\nlet smallEven = numbers.filter(num => num % 2 === 0 && num < 6);\nconsole.log(smallEven);    // [2, 4]\n\n// Original unchanged\nconsole.log(numbers);  // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n// Example 2: Remove falsy values (null, undefined, 0, '', false)\nlet messy = [0, 'hello', null, 42, undefined, '', 'world', false, true];\nlet truthy = messy.filter(item => item);  // Truthy check\nconsole.log(truthy);  // ['hello', 42, 'world', true]\n\n// More explicit version:\nlet notNull = messy.filter(item => item !== null && item !== undefined);\nconsole.log(notNull);  // [0, 'hello', 42, '', 'world', false, true]\n\n// Example 3: Filter objects by property\nlet users = [\n  { name: 'Alice', age: 25, active: true },\n  { name: 'Bob', age: 17, active: true },\n  { name: 'Charlie', age: 30, active: false },\n  { name: 'Diana', age: 22, active: true }\n];\n\n// Get active adult users\nlet activeAdults = users.filter(user => user.active && user.age >= 18);\nconsole.log(activeAdults);\n// [\n//   { name: 'Alice', age: 25, active: true },\n//   { name: 'Diana', age: 22, active: true }\n// ]\n\n// Get inactive users\nlet inactive = users.filter(user => !user.active);\nconsole.log(inactive);\n// [{ name: 'Charlie', age: 30, active: false }]\n\n// Example 4: Filter by string content\nlet products = ['Apple iPhone', 'Samsung Galaxy', 'Apple Watch', 'Google Pixel'];\n\nlet appleProducts = products.filter(p => p.includes('Apple'));\nconsole.log(appleProducts);  // ['Apple iPhone', 'Apple Watch']\n\nlet startsWithS = products.filter(p => p.startsWith('S'));\nconsole.log(startsWithS);    // ['Samsung Galaxy']\n\n// Example 5: Edge case - empty result\nlet scores = [45, 62, 78, 55, 80];\nlet perfect = scores.filter(score => score === 100);\nconsole.log(perfect);        // [] - empty array, no matches\nconsole.log(perfect.length); // 0\n\n// Example 6: Remove specific items\nlet tasks = ['Buy milk', 'Clean room', 'Do homework', 'Exercise'];\nlet taskToRemove = 'Clean room';\nlet remaining = tasks.filter(task => task !== taskToRemove);\nconsole.log(remaining);  // ['Buy milk', 'Do homework', 'Exercise']"
            },
            {
              "type": "EXAMPLE",
              "title": "reduce() - The Swiss Army Knife",
              "content": "The reduce() method processes an array and 'reduces' it to a SINGLE value. That value can be anything: a number (sum, product), a string, an object, or even another array. Think of it as a snowball rolling downhill, accumulating more data at each step. The 'accumulator' holds the running result, and each element adds to or modifies it.",
              "language": "javascript",
              "code": "// reduce() accumulates array elements into a SINGLE result\n// Think of it like a snowball rolling downhill, getting bigger\n\n// Syntax: array.reduce((accumulator, currentItem) => newAccumulator, initialValue)\n\n// Example 1: Sum of numbers (step by step)\nlet numbers = [10, 20, 30, 40];\n\nlet sum = numbers.reduce(function(accumulator, currentNumber) {\n  console.log(`acc: ${accumulator}, current: ${currentNumber}, new acc: ${accumulator + currentNumber}`);\n  return accumulator + currentNumber;\n}, 0);  // 0 is the initial value\n\n// Console output:\n// acc: 0, current: 10, new acc: 10\n// acc: 10, current: 20, new acc: 30\n// acc: 30, current: 30, new acc: 60\n// acc: 60, current: 40, new acc: 100\nconsole.log('Sum:', sum);  // Sum: 100\n\n// Example 2: Product of numbers\nlet factors = [2, 3, 4, 5];\nlet product = factors.reduce((acc, num) => acc * num, 1);  // Start with 1 for multiplication\nconsole.log('Product:', product);  // Product: 120 (2*3*4*5)\n\n// Example 3: Find maximum value\nlet scores = [72, 95, 88, 64, 91];\nlet maxScore = scores.reduce((max, score) => score > max ? score : max, scores[0]);\nconsole.log('Max:', maxScore);  // Max: 95\n\n// Example 4: Count occurrences (building an object)\nlet fruits = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple'];\n\nlet fruitCounts = fruits.reduce((counts, fruit) => {\n  // If fruit exists in counts, increment it; otherwise start at 1\n  counts[fruit] = (counts[fruit] || 0) + 1;\n  return counts;\n}, {});  // Start with empty object\n\nconsole.log(fruitCounts);  // { apple: 3, banana: 2, cherry: 1 }\n\n// Example 5: Group objects by property\nlet people = [\n  { name: 'Alice', department: 'Engineering' },\n  { name: 'Bob', department: 'Marketing' },\n  { name: 'Charlie', department: 'Engineering' },\n  { name: 'Diana', department: 'Marketing' },\n  { name: 'Eve', department: 'Engineering' }\n];\n\nlet byDepartment = people.reduce((groups, person) => {\n  let dept = person.department;\n  // If department doesn't exist yet, create empty array\n  if (!groups[dept]) {\n    groups[dept] = [];\n  }\n  // Add person to their department\n  groups[dept].push(person);\n  return groups;\n}, {});\n\nconsole.log(byDepartment);\n// {\n//   Engineering: [{name: 'Alice'...}, {name: 'Charlie'...}, {name: 'Eve'...}],\n//   Marketing: [{name: 'Bob'...}, {name: 'Diana'...}]\n// }\n\n// Example 6: Flatten nested arrays\nlet nested = [[1, 2], [3, 4], [5, 6]];\nlet flat = nested.reduce((acc, innerArray) => {\n  return acc.concat(innerArray);  // or [...acc, ...innerArray]\n}, []);\nconsole.log(flat);  // [1, 2, 3, 4, 5, 6]\n\n// Example 7: Build an object from array of pairs\nlet pairs = [['name', 'Alice'], ['age', 25], ['city', 'NYC']];\nlet obj = pairs.reduce((result, [key, value]) => {\n  result[key] = value;\n  return result;\n}, {});\nconsole.log(obj);  // { name: 'Alice', age: 25, city: 'NYC' }\n\n// Example 8: Calculate cart total with quantities\nlet cart = [\n  { name: 'Laptop', price: 1000, quantity: 1 },\n  { name: 'Mouse', price: 25, quantity: 2 },\n  { name: 'USB Cable', price: 10, quantity: 3 }\n];\n\nlet cartTotal = cart.reduce((total, item) => {\n  return total + (item.price * item.quantity);\n}, 0);\nconsole.log('Cart total: $' + cartTotal);  // Cart total: $1080"
            },
            {
              "type": "EXAMPLE",
              "title": "Chaining Methods Together",
              "content": "One of the most powerful aspects of map, filter, and reduce is that you can CHAIN them together. Since map and filter both return arrays, you can call another method on the result. This lets you build data transformation pipelines that are readable and expressive.",
              "language": "javascript",
              "code": "// Chaining: Connect multiple array methods into a pipeline\n// Each method returns an array (or value), which feeds into the next\n\n// Example 1: Get names of adult users\nlet users = [\n  { name: 'Alice', age: 25, active: true },\n  { name: 'Bob', age: 17, active: true },\n  { name: 'Charlie', age: 30, active: false },\n  { name: 'Diana', age: 22, active: true },\n  { name: 'Eve', age: 15, active: true }\n];\n\nlet adultNames = users\n  .filter(user => user.age >= 18)      // Keep users 18+\n  .map(user => user.name);             // Extract just names\n\nconsole.log(adultNames);  // ['Alice', 'Charlie', 'Diana']\n\n// Example 2: Active adult names (multiple filters, then map)\nlet activeAdultNames = users\n  .filter(user => user.age >= 18)       // Keep adults\n  .filter(user => user.active)          // Keep active ones\n  .map(user => user.name);              // Get names\n\nconsole.log(activeAdultNames);  // ['Alice', 'Diana']\n\n// Example 3: Calculate total price of in-stock items\nlet products = [\n  { name: 'Laptop', price: 1000, inStock: true },\n  { name: 'Phone', price: 800, inStock: false },\n  { name: 'Tablet', price: 500, inStock: true },\n  { name: 'Watch', price: 300, inStock: true },\n  { name: 'Headphones', price: 150, inStock: false }\n];\n\nlet inStockTotal = products\n  .filter(product => product.inStock)           // Only in-stock items\n  .map(product => product.price)                // Get prices\n  .reduce((sum, price) => sum + price, 0);      // Sum them up\n\nconsole.log('In-stock total: $' + inStockTotal);  // In-stock total: $1800\n\n// Example 4: Complex data transformation\nlet orders = [\n  { id: 1, items: ['apple', 'banana'], total: 15.00, status: 'completed' },\n  { id: 2, items: ['orange'], total: 8.50, status: 'pending' },\n  { id: 3, items: ['apple', 'cherry', 'grape'], total: 22.00, status: 'completed' },\n  { id: 4, items: ['banana', 'mango'], total: 12.00, status: 'cancelled' }\n];\n\n// Get formatted list of completed order totals\nlet completedOrderSummary = orders\n  .filter(order => order.status === 'completed')  // Only completed\n  .map(order => ({                                // Transform to summary\n    orderId: order.id,\n    itemCount: order.items.length,\n    formattedTotal: '$' + order.total.toFixed(2)\n  }));\n\nconsole.log(completedOrderSummary);\n// [\n//   { orderId: 1, itemCount: 2, formattedTotal: '$15.00' },\n//   { orderId: 3, itemCount: 3, formattedTotal: '$22.00' }\n// ]\n\n// Example 5: Process and reduce in one chain\nlet transactions = [\n  { type: 'deposit', amount: 100 },\n  { type: 'withdrawal', amount: 30 },\n  { type: 'deposit', amount: 50 },\n  { type: 'withdrawal', amount: 20 },\n  { type: 'deposit', amount: 200 }\n];\n\nlet balance = transactions\n  .map(t => t.type === 'deposit' ? t.amount : -t.amount)  // Convert to +/-\n  .reduce((total, amount) => total + amount, 0);          // Sum it up\n\nconsole.log('Balance: $' + balance);  // Balance: $300\n\n// Example 6: Find top 3 scorers\nlet players = [\n  { name: 'Alice', score: 850 },\n  { name: 'Bob', score: 920 },\n  { name: 'Charlie', score: 780 },\n  { name: 'Diana', score: 1050 },\n  { name: 'Eve', score: 890 }\n];\n\nlet top3 = [...players]                              // Copy array (sort mutates!)\n  .sort((a, b) => b.score - a.score)                 // Sort descending by score\n  .slice(0, 3)                                       // Take first 3\n  .map(p => `${p.name}: ${p.score}`);                // Format as strings\n\nconsole.log('Top 3:', top3);\n// Top 3: ['Diana: 1050', 'Bob: 920', 'Eve: 890']"
            },
            {
              "type": "THEORY",
              "title": "How Each Method Works",
              "content": "**map(callback) - Transform every element**\n\nSyntax:\n```javascript\nlet newArray = array.map((element, index, array) => {\n  return transformedElement;\n});\n```\n\n- Calls callback for EVERY element\n- Returns a NEW array with the SAME length\n- Each element in new array = return value of callback\n- Original array is unchanged\n- If you forget to return, you get undefined for that element\n\n**filter(callback) - Select matching elements**\n\nSyntax:\n```javascript\nlet newArray = array.filter((element, index, array) => {\n  return true; // keep element\n  return false; // discard element\n});\n```\n\n- Calls callback for EVERY element\n- Returns a NEW array (possibly shorter or empty)\n- Keeps elements where callback returns truthy value\n- Original array is unchanged\n- Empty array [] if nothing matches\n\n**reduce(callback, initialValue) - Accumulate into single value**\n\nSyntax:\n```javascript\nlet result = array.reduce((accumulator, element, index, array) => {\n  return newAccumulator; // This becomes accumulator for next iteration\n}, initialValue);\n```\n\n- accumulator: The running result (starts as initialValue)\n- element: Current array element being processed\n- Returns a SINGLE value (can be any type!)\n- Without initialValue, first element is used as initial accumulator\n- Always provide initialValue to avoid edge case bugs\n\n**Callback parameters (all three methods):**\n\n1. element - The current element being processed (always available)\n2. index - The index of current element (optional, often not needed)\n3. array - The original array (optional, rarely needed)\n\n**Arrow function shortcuts:**\n\n```javascript\n// If body is single expression, return is implicit:\narray.map(x => x * 2)           // Returns doubled values\narray.filter(x => x > 10)       // Returns truthy condition\narray.reduce((a, b) => a + b)   // Returns sum\n\n// If body needs multiple statements, use braces and explicit return:\narray.map(x => {\n  let doubled = x * 2;\n  let formatted = '$' + doubled;\n  return formatted;\n});\n```\n\n**Return value comparison:**\n\n| Method | Returns | Length vs Original |\n|--------|---------|--------------------|\n| map | New array | Same length |\n| filter | New array | Same or shorter |\n| reduce | Single value | N/A (not an array) |"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "**1. Forgetting to return inside arrow function with braces**\n\n```javascript\n// WRONG - no return, results in [undefined, undefined, ...]\nlet doubled = numbers.map(x => { x * 2 });\n\n// CORRECT - explicit return with braces\nlet doubled = numbers.map(x => { return x * 2; });\n\n// CORRECT - implicit return without braces\nlet doubled = numbers.map(x => x * 2);\n```\n\n**2. Mutating the accumulator object in reduce**\n\n```javascript\n// RISKY - mutating the same object\nlet counts = items.reduce((acc, item) => {\n  acc[item] = (acc[item] || 0) + 1;\n  return acc;  // Returning mutated object works but can cause bugs\n}, {});\n\n// SAFER - create new object each time (for complex cases)\nlet counts = items.reduce((acc, item) => {\n  return {\n    ...acc,\n    [item]: (acc[item] || 0) + 1\n  };\n}, {});\n```\n\n**3. Forgetting reduce's initial value**\n\n```javascript\n// RISKY - no initial value\nlet sum = [].reduce((a, b) => a + b);  // TypeError! Empty array!\n\n// SAFE - always provide initial value\nlet sum = [].reduce((a, b) => a + b, 0);  // Returns 0\n```\n\n**4. Thinking map can filter (it cannot)**\n\n```javascript\n// WRONG - map always returns same length array\nlet adults = users.map(user => {\n  if (user.age >= 18) return user;\n  // Returns undefined for non-adults!\n});\n// Result: [Alice, undefined, Charlie, undefined, ...]\n\n// CORRECT - use filter for selection, map for transformation\nlet adults = users.filter(user => user.age >= 18);\nlet adultNames = users.filter(u => u.age >= 18).map(u => u.name);\n```\n\n**5. Not saving the result (these methods don't mutate)**\n\n```javascript\nlet numbers = [3, 1, 2];\nnumbers.map(x => x * 2);     // Creates new array but throws it away!\nconsole.log(numbers);        // Still [3, 1, 2]\n\n// CORRECT - save the result\nlet doubled = numbers.map(x => x * 2);\nconsole.log(doubled);        // [6, 2, 4]\n```\n\n**6. Performance: Excessive chaining for large arrays**\n\n```javascript\n// Creates 3 intermediate arrays - fine for small arrays\nlet result = hugeArray\n  .filter(x => x > 0)\n  .map(x => x * 2)\n  .filter(x => x < 100);\n\n// For very large arrays, single reduce might be faster:\nlet result = hugeArray.reduce((acc, x) => {\n  if (x > 0) {\n    let doubled = x * 2;\n    if (doubled < 100) {\n      acc.push(doubled);\n    }\n  }\n  return acc;\n}, []);\n```\n\n**7. Confusing return types**\n\n```javascript\n// filter returns ARRAY of matching items\nlet adults = users.filter(u => u.age >= 18);  // Array!\n\n// find returns SINGLE item (or undefined) - different method!\nlet firstAdult = users.find(u => u.age >= 18);  // Single object!\n\n// reduce returns WHATEVER you return from callback\nlet sum = numbers.reduce((a, b) => a + b, 0);      // Number\nlet joined = words.reduce((a, b) => a + ' ' + b);  // String\nlet grouped = items.reduce(..., {});               // Object\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.3-challenge",
              "title": "E-Commerce Data Pipeline",
              "description": "You are building an e-commerce dashboard. Given an array of products, use map, filter, and reduce to transform the data for display. This challenge tests your ability to chain all three transformation methods together to solve a real-world problem.",
              "instructions": "Given an array of products with name, price, category, and inStock properties:\n\n1. Filter to only 'electronics' category products that are in stock\n2. Map to add a 10% tax to each price (multiply by 1.10), rounded to 2 decimal places\n3. Reduce to get the total price of all filtered products\n4. Finally, chain all three operations into a single elegant pipeline\n\nExpected behavior:\n- Start with products array\n- Filter: electronics + inStock = Laptop ($1000), Mouse ($25), Keyboard ($75)\n- Map with tax: $1100.00, $27.50, $82.50\n- Reduce total: $1210.00",
              "starterCode": "let products = [\n  { name: 'Laptop', price: 1000, category: 'electronics', inStock: true },\n  { name: 'Shirt', price: 25, category: 'clothing', inStock: true },\n  { name: 'Mouse', price: 25, category: 'electronics', inStock: true },\n  { name: 'Pants', price: 50, category: 'clothing', inStock: false },\n  { name: 'Keyboard', price: 75, category: 'electronics', inStock: true },\n  { name: 'Monitor', price: 300, category: 'electronics', inStock: false },\n  { name: 'Headphones', price: 150, category: 'electronics', inStock: false }\n];\n\nconst TAX_RATE = 0.10;  // 10% tax\n\n// Step 1: Filter to in-stock electronics only\nlet inStockElectronics = products.filter(/* your code */);\nconsole.log('In-stock electronics:', inStockElectronics.map(p => p.name));\n// Expected: ['Laptop', 'Mouse', 'Keyboard']\n\n// Step 2: Map to add tax to prices\nlet pricesWithTax = inStockElectronics.map(/* your code */);\nconsole.log('Prices with tax:', pricesWithTax);\n// Expected: [1100, 27.5, 82.5]\n\n// Step 3: Reduce to get total\nlet total = pricesWithTax.reduce(/* your code */);\nconsole.log('Total:', total);\n// Expected: 1210\n\n// Step 4: Chain all three into one elegant pipeline\nlet totalChained = products\n  // .filter(...)\n  // .map(...)\n  // .reduce(...);\n\nconsole.log('Total (chained): $' + totalChained.toFixed(2));\n// Expected: $1210.00",
              "solution": "let products = [\n  { name: 'Laptop', price: 1000, category: 'electronics', inStock: true },\n  { name: 'Shirt', price: 25, category: 'clothing', inStock: true },\n  { name: 'Mouse', price: 25, category: 'electronics', inStock: true },\n  { name: 'Pants', price: 50, category: 'clothing', inStock: false },\n  { name: 'Keyboard', price: 75, category: 'electronics', inStock: true },\n  { name: 'Monitor', price: 300, category: 'electronics', inStock: false },\n  { name: 'Headphones', price: 150, category: 'electronics', inStock: false }\n];\n\nconst TAX_RATE = 0.10;\n\n// Step 1: Filter to in-stock electronics only\nlet inStockElectronics = products.filter(product => \n  product.category === 'electronics' && product.inStock\n);\nconsole.log('In-stock electronics:', inStockElectronics.map(p => p.name));\n// ['Laptop', 'Mouse', 'Keyboard']\n\n// Step 2: Map to add tax to prices\nlet pricesWithTax = inStockElectronics.map(product => \n  Math.round(product.price * (1 + TAX_RATE) * 100) / 100\n);\nconsole.log('Prices with tax:', pricesWithTax);\n// [1100, 27.5, 82.5]\n\n// Step 3: Reduce to get total\nlet total = pricesWithTax.reduce((sum, price) => sum + price, 0);\nconsole.log('Total:', total);\n// 1210\n\n// Step 4: Chain all three into one elegant pipeline\nlet totalChained = products\n  .filter(p => p.category === 'electronics' && p.inStock)\n  .map(p => Math.round(p.price * (1 + TAX_RATE) * 100) / 100)\n  .reduce((sum, price) => sum + price, 0);\n\nconsole.log('Total (chained): $' + totalChained.toFixed(2));\n// $1210.00",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Filters to correct products",
                  "expectedOutput": "3",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Applies tax correctly",
                  "expectedOutput": "1100",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Calculates total correctly",
                  "expectedOutput": "1210",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For filter: check both category === 'electronics' AND inStock === true"
                },
                {
                  "level": 2,
                  "text": "For map with tax: price * (1 + TAX_RATE) or price * 1.10"
                },
                {
                  "level": 3,
                  "text": "For reduce: start with 0 and add each price: (sum, price) => sum + price, 0"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting inStock check in filter",
                  "consequence": "Includes out-of-stock items in the calculation",
                  "correction": "Use: product.category === 'electronics' && product.inStock"
                },
                {
                  "mistake": "Not providing initial value for reduce",
                  "consequence": "Error on empty array, or wrong result type",
                  "correction": "Always use: .reduce((sum, price) => sum + price, 0)"
                },
                {
                  "mistake": "Mutating original products array",
                  "consequence": "Original data is corrupted for other uses",
                  "correction": "map/filter/reduce create new arrays - never modify original"
                },
                {
                  "mistake": "Forgetting to round tax calculation",
                  "consequence": "Results like 27.500000000000004 due to floating point",
                  "correction": "Use Math.round(price * 1.10 * 100) / 100 for 2 decimal places"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.4",
          "title": "Searching Arrays (find, findIndex, some, every, includes)",
          "moduleId": "module-05",
          "order": 4,
          "estimatedMinutes": 35,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding Array Search Operations",
              "content": "Imagine you're a detective searching through a filing cabinet of case files. Different search methods serve different purposes:\n\n**find() / findIndex()**: 'Find the first case involving robbery' - You flip through files until you find ONE match. find() gives you the file itself; findIndex() tells you which drawer it was in (the position).\n\n**some() / every()**: 'Are there ANY unsolved cases?' vs 'Are ALL cases filed correctly?' - some() checks if at least one matches (like asking 'Is anyone home?'); every() checks if ALL match (like asking 'Is everyone ready?'). Both stop early when they know the answer.\n\n**includes() / indexOf()**: 'Is Case #4521 in here?' - Simple yes/no existence checks for primitive values. includes() just says true/false; indexOf() tells you where it is (or -1 if not found).\n\n**at()**: 'Give me the last file' - Modern way to access items, especially from the end. at(-1) is cleaner than arr[arr.length - 1].\n\n**findLast() / findLastIndex()**: 'Find the most recent robbery case' - Like find(), but searches from the END. Perfect when you want the latest match, not the first.\n\nEach method is optimized for a specific question you might ask about your data."
            },
            {
              "type": "EXAMPLE",
              "title": "find() and findIndex() - Locate First Match",
              "content": "find() returns the first element that matches your condition. findIndex() returns its position (index). Both stop searching once a match is found, making them efficient for large arrays.",
              "language": "javascript",
              "code": "// === find() - Returns the ELEMENT itself ===\nlet users = [\n  { id: 1, name: 'Alice', role: 'admin' },\n  { id: 2, name: 'Bob', role: 'user' },\n  { id: 3, name: 'Charlie', role: 'admin' },\n  { id: 4, name: 'Diana', role: 'user' }\n];\n\n// Find first admin\nlet firstAdmin = users.find(user => user.role === 'admin');\nconsole.log(firstAdmin);  // { id: 1, name: 'Alice', role: 'admin' }\n\n// Find user by ID\nlet user2 = users.find(user => user.id === 2);\nconsole.log(user2.name);  // 'Bob'\n\n// When nothing is found - returns undefined\nlet manager = users.find(user => user.role === 'manager');\nconsole.log(manager);  // undefined\n\n// IMPORTANT: Always check for undefined!\nif (manager) {\n  console.log(manager.name);\n} else {\n  console.log('No manager found');\n}\n\n// === findIndex() - Returns the POSITION (index) ===\nlet numbers = [10, 25, 30, 45, 50];\n\n// Find position of first number > 25\nlet index = numbers.findIndex(n => n > 25);\nconsole.log(index);  // 2 (the value 30 is at index 2)\n\n// When nothing is found - returns -1\nlet notFound = numbers.findIndex(n => n > 100);\nconsole.log(notFound);  // -1\n\n// Practical: Remove an item by finding its index\nlet userIndex = users.findIndex(u => u.id === 2);\nif (userIndex !== -1) {\n  users.splice(userIndex, 1);  // Remove Bob\n}\nconsole.log(users.length);  // 3 (Bob removed)\n\n// === find() vs filter() - Key Difference ===\nlet scores = [85, 92, 78, 95, 88];\n\n// find() returns FIRST match (or undefined)\nlet firstHigh = scores.find(s => s > 90);\nconsole.log(firstHigh);  // 92 (just one value)\n\n// filter() returns ALL matches (as array)\nlet allHigh = scores.filter(s => s > 90);\nconsole.log(allHigh);  // [92, 95] (array of all matches)\n\n// Use find() when you need just one item\n// Use filter() when you need all matching items"
            },
            {
              "type": "EXAMPLE",
              "title": "some() and every() - Test Conditions Across Array",
              "content": "some() checks if AT LEAST ONE element passes the test (returns true/false). every() checks if ALL elements pass (returns true/false). Both use short-circuit evaluation - they stop as soon as they know the answer.",
              "language": "javascript",
              "code": "// === some() - Does ANY element match? ===\nlet ages = [12, 15, 18, 21, 25];\n\n// Is there at least one adult (18+)?\nlet hasAdult = ages.some(age => age >= 18);\nconsole.log(hasAdult);  // true\n\n// Short-circuit: stops at 18, doesn't check 21 or 25\n\n// === every() - Do ALL elements match? ===\nlet allAdults = ages.every(age => age >= 18);\nconsole.log(allAdults);  // false (12 and 15 are not adults)\n\n// Short-circuit: stops at 12 (first failure)\n\n// === Real-world: Form Validation ===\nlet formFields = [\n  { name: 'email', value: 'test@example.com', valid: true },\n  { name: 'password', value: '12345', valid: false },\n  { name: 'username', value: 'johndoe', valid: true }\n];\n\n// Are ALL fields valid? (Must ALL be valid to submit)\nlet canSubmit = formFields.every(field => field.valid);\nconsole.log('Can submit form:', canSubmit);  // false\n\n// Is there ANY invalid field? (For showing error message)\nlet hasErrors = formFields.some(field => !field.valid);\nconsole.log('Has errors:', hasErrors);  // true\n\n// === Real-world: Permission Checking ===\nlet userPermissions = ['read', 'write', 'delete'];\nlet requiredPermissions = ['read', 'write'];\n\n// Does user have ALL required permissions?\nlet hasAllPermissions = requiredPermissions.every(\n  perm => userPermissions.includes(perm)\n);\nconsole.log('Authorized:', hasAllPermissions);  // true\n\n// Does user have ANY admin permissions?\nlet adminPerms = ['admin', 'superuser'];\nlet isAdmin = adminPerms.some(\n  perm => userPermissions.includes(perm)\n);\nconsole.log('Is admin:', isAdmin);  // false\n\n// === Empty Array Behavior (Important!) ===\nlet empty = [];\nconsole.log(empty.some(x => x > 0));   // false (no element to match)\nconsole.log(empty.every(x => x > 0));  // true (vacuously true!)\n\n// Why every([]) is true:\n// 'All items in empty array pass' is technically true\n// because there are no items to fail the test"
            },
            {
              "type": "EXAMPLE",
              "title": "includes() vs indexOf() - Simple Existence Checks",
              "content": "includes() returns true/false for existence. indexOf() returns the position (or -1). The key difference is how they handle NaN - includes() can find NaN, indexOf() cannot!",
              "language": "javascript",
              "code": "// === includes() - Returns true or false ===\nlet fruits = ['apple', 'banana', 'cherry', 'date'];\n\nconsole.log(fruits.includes('banana'));  // true\nconsole.log(fruits.includes('mango'));   // false\n\n// With numbers\nlet numbers = [1, 2, 3, 4, 5];\nconsole.log(numbers.includes(3));  // true\nconsole.log(numbers.includes(10)); // false\n\n// === indexOf() - Returns position or -1 ===\nconsole.log(fruits.indexOf('cherry'));  // 2\nconsole.log(fruits.indexOf('mango'));   // -1 (not found)\n\n// === Second parameter: fromIndex ===\nlet letters = ['a', 'b', 'c', 'a', 'b', 'c'];\n\n// Start searching from index 2\nconsole.log(letters.indexOf('a', 2));     // 3 (second 'a')\nconsole.log(letters.includes('a', 2));    // true (finds second 'a')\n\n// Start from index 4 - 'a' not found after that\nconsole.log(letters.indexOf('a', 4));     // -1\nconsole.log(letters.includes('a', 4));    // false\n\n// === Critical Difference: NaN Handling ===\nlet values = [1, 2, NaN, 4, 5];\n\n// includes() CAN find NaN\nconsole.log(values.includes(NaN));  // true\n\n// indexOf() CANNOT find NaN (uses strict equality)\nconsole.log(values.indexOf(NaN));   // -1 (!!)\n\n// Why? NaN === NaN is false in JavaScript!\nconsole.log(NaN === NaN);  // false\n\n// includes() uses SameValueZero algorithm which handles NaN\n// indexOf() uses strict equality (===) which fails for NaN\n\n// === When to use which? ===\n// Use includes() when you just need true/false\nif (fruits.includes('banana')) {\n  console.log('We have bananas!');\n}\n\n// Use indexOf() when you need the position\nlet pos = fruits.indexOf('cherry');\nif (pos !== -1) {\n  console.log('Cherry is at position ' + pos);\n}\n\n// === With objects - Reference Equality Trap! ===\nlet users = [{ name: 'Alice' }, { name: 'Bob' }];\nlet alice = { name: 'Alice' };\n\n// This is FALSE! Different object references\nconsole.log(users.includes(alice));  // false\nconsole.log(users.indexOf(alice));   // -1\n\n// The object in the array is not the same object as 'alice'\n// They look the same but are different objects in memory\n// Use find() for searching objects by property:\nlet found = users.find(u => u.name === 'Alice');\nconsole.log(found);  // { name: 'Alice' }"
            },
            {
              "type": "EXAMPLE",
              "title": "at() for Negative Indexing (ES2022+)",
              "content": "The at() method provides a cleaner way to access array elements, especially from the end. While bracket notation requires length calculations for negative access, at() handles negative indices directly.",
              "language": "javascript",
              "code": "// === The Old Way: Accessing from the end ===\nlet colors = ['red', 'green', 'blue', 'yellow', 'purple'];\n\n// Get last element - clunky!\nlet last = colors[colors.length - 1];\nconsole.log(last);  // 'purple'\n\n// Get second-to-last - even clunkier!\nlet secondLast = colors[colors.length - 2];\nconsole.log(secondLast);  // 'yellow'\n\n// === The New Way: at() with negative indices ===\nconsole.log(colors.at(-1));   // 'purple' (last)\nconsole.log(colors.at(-2));   // 'yellow' (second-to-last)\nconsole.log(colors.at(-3));   // 'blue' (third-to-last)\n\n// Positive indices work too (same as bracket notation)\nconsole.log(colors.at(0));    // 'red' (first)\nconsole.log(colors.at(2));    // 'blue' (third)\n\n// === Comparison: When at() is clearer ===\nlet history = ['action1', 'action2', 'action3', 'action4'];\n\n// Get last action (undo feature)\n// Old way:\nlet lastActionOld = history[history.length - 1];\n// New way:\nlet lastAction = history.at(-1);\nconsole.log(lastAction);  // 'action4'\n\n// === Out of bounds behavior ===\nconsole.log(colors.at(100));   // undefined\nconsole.log(colors.at(-100));  // undefined\n// Same as bracket notation - returns undefined for invalid indices\n\n// === Works with strings too! ===\nlet greeting = 'Hello, World!';\nconsole.log(greeting.at(0));   // 'H'\nconsole.log(greeting.at(-1));  // '!'\nconsole.log(greeting.at(-6));  // 'W'\n\n// === Practical: Queue and Stack Operations ===\nlet queue = ['task1', 'task2', 'task3'];\n\n// Peek at first (next to process)\nlet nextTask = queue.at(0);\nconsole.log('Next task:', nextTask);  // 'task1'\n\nlet stack = ['undo1', 'undo2', 'undo3'];\n\n// Peek at last (most recent)\nlet lastUndo = stack.at(-1);\nconsole.log('Last undo:', lastUndo);  // 'undo3'\n\n// === When to use at() vs bracket notation ===\n// Use at() for:\n//   - Negative indices (cleaner syntax)\n//   - When index is calculated/variable and might be negative\n\n// Use bracket notation for:\n//   - Simple positive indices (arr[0], arr[1])\n//   - When you need to assign values (at() is read-only)\n\ncolors[0] = 'orange';      // Works - assignment\n// colors.at(0) = 'orange'; // ERROR - at() is for reading only"
            },
            {
              "type": "EXAMPLE",
              "title": "findLast() and findLastIndex() (ES2023)",
              "content": "These methods search from the END of the array, perfect when you need the most recent or last matching element. They work exactly like find() and findIndex() but in reverse order.",
              "language": "javascript",
              "code": "// === findLast() - Find from the end ===\nlet transactions = [\n  { id: 1, type: 'deposit', amount: 100, date: '2024-01-01' },\n  { id: 2, type: 'withdrawal', amount: 50, date: '2024-01-05' },\n  { id: 3, type: 'deposit', amount: 200, date: '2024-01-10' },\n  { id: 4, type: 'withdrawal', amount: 75, date: '2024-01-15' },\n  { id: 5, type: 'deposit', amount: 150, date: '2024-01-20' }\n];\n\n// Find MOST RECENT deposit\nlet lastDeposit = transactions.findLast(t => t.type === 'deposit');\nconsole.log(lastDeposit);\n// { id: 5, type: 'deposit', amount: 150, date: '2024-01-20' }\n\n// Compare with find() - finds FIRST deposit\nlet firstDeposit = transactions.find(t => t.type === 'deposit');\nconsole.log(firstDeposit);\n// { id: 1, type: 'deposit', amount: 100, date: '2024-01-01' }\n\n// === findLastIndex() - Position of last match ===\nlet numbers = [5, 12, 8, 130, 44, 3, 15];\n\n// Find position of LAST number > 10\nlet lastBigIndex = numbers.findLastIndex(n => n > 10);\nconsole.log(lastBigIndex);  // 6 (the value 15 at position 6)\n\n// Compare with findIndex() - finds FIRST\nlet firstBigIndex = numbers.findIndex(n => n > 10);\nconsole.log(firstBigIndex);  // 1 (the value 12 at position 1)\n\n// === Real-world: Error Logging ===\nlet logs = [\n  { level: 'info', message: 'App started', time: '09:00' },\n  { level: 'error', message: 'DB connection failed', time: '09:05' },\n  { level: 'info', message: 'Retrying...', time: '09:06' },\n  { level: 'error', message: 'Still failing', time: '09:07' },\n  { level: 'info', message: 'Connected!', time: '09:10' }\n];\n\n// Get the most recent error\nlet lastError = logs.findLast(log => log.level === 'error');\nconsole.log('Last error:', lastError.message);  // 'Still failing'\n\n// === Real-world: Version History ===\nlet versions = [\n  { version: '1.0', stable: true },\n  { version: '1.1', stable: true },\n  { version: '2.0-beta', stable: false },\n  { version: '2.0', stable: true },\n  { version: '2.1-alpha', stable: false }\n];\n\n// Find latest stable version\nlet latestStable = versions.findLast(v => v.stable);\nconsole.log('Latest stable:', latestStable.version);  // '2.0'\n\n// === When nothing is found ===\nlet emptyResult = transactions.findLast(t => t.type === 'transfer');\nconsole.log(emptyResult);  // undefined\n\nlet emptyIndex = numbers.findLastIndex(n => n > 1000);\nconsole.log(emptyIndex);  // -1\n\n// === Alternative before ES2023 ===\n// If you can't use findLast(), you can reverse and find:\nlet altLastDeposit = [...transactions].reverse().find(t => t.type === 'deposit');\nconsole.log(altLastDeposit.id);  // 5\n\n// But findLast() is cleaner and doesn't create a copy!"
            },
            {
              "type": "THEORY",
              "title": "Complete Syntax Reference",
              "content": "**Search Methods Quick Reference:**\n\n| Method | Returns | When Not Found | Use Case |\n|--------|---------|----------------|----------|\n| find(fn) | Element | undefined | First match |\n| findIndex(fn) | Number | -1 | Position of first match |\n| findLast(fn) | Element | undefined | Last match |\n| findLastIndex(fn) | Number | -1 | Position of last match |\n| some(fn) | Boolean | false | Any match exists? |\n| every(fn) | Boolean | true* | All match? |\n| includes(val) | Boolean | false | Value exists? |\n| indexOf(val) | Number | -1 | Position of value |\n| at(index) | Element | undefined | Access by index |\n\n*every() returns true for empty arrays (vacuously true)\n\n**Callback Function Signature:**\n```javascript\narray.method((element, index, array) => {\n  // element: current item being processed\n  // index: position in array (optional)\n  // array: the array being searched (optional)\n  return condition;  // true/false for search methods\n});\n```\n\n**Method Categories:**\n\n1. **Element Finders** (return the element):\n   - find(callback) - first match\n   - findLast(callback) - last match\n   - at(index) - by position\n\n2. **Position Finders** (return index number):\n   - findIndex(callback) - first match position\n   - findLastIndex(callback) - last match position\n   - indexOf(value) - simple value position\n\n3. **Boolean Testers** (return true/false):\n   - some(callback) - at least one matches\n   - every(callback) - all match\n   - includes(value) - value exists\n\n**Short-Circuit Behavior:**\n- find/findIndex: Stop at first match\n- findLast/findLastIndex: Stop at first match (from end)\n- some: Stops when true is found\n- every: Stops when false is found\n- includes/indexOf: Stop when found\n\n**Equality Comparison:**\n- includes() uses SameValueZero (finds NaN)\n- indexOf() uses strict equality === (cannot find NaN)\n- find/some/every use your callback logic"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "**1. Confusing find() with filter():**\n```javascript\n// find() returns ONE element (or undefined)\nlet result = arr.find(x => x > 5);  // Single value\n\n// filter() returns an ARRAY of all matches\nlet results = arr.filter(x => x > 5);  // Array\n```\n\n**2. Forgetting undefined checks with find():**\n```javascript\n// DANGEROUS - will crash if not found!\nlet user = users.find(u => u.id === 999);\nconsole.log(user.name);  // TypeError: Cannot read property 'name' of undefined\n\n// SAFE - check first!\nlet user = users.find(u => u.id === 999);\nif (user) {\n  console.log(user.name);\n} else {\n  console.log('User not found');\n}\n\n// Or use optional chaining:\nconsole.log(user?.name ?? 'Unknown');\n```\n\n**3. Using indexOf() with objects (reference equality):**\n```javascript\nlet users = [{ name: 'Alice' }];\nlet search = { name: 'Alice' };\n\nconsole.log(users.indexOf(search));  // -1 (different objects!)\nconsole.log(users.includes(search)); // false\n\n// Use find() for objects:\nlet found = users.find(u => u.name === 'Alice');  // Works!\n```\n\n**4. Expecting indexOf() to find NaN:**\n```javascript\nlet arr = [1, NaN, 3];\nconsole.log(arr.indexOf(NaN));   // -1 (can't find it!)\nconsole.log(arr.includes(NaN));  // true (this works)\n\n// Use includes() or find() for NaN\n```\n\n**5. Misunderstanding some() and every() with empty arrays:**\n```javascript\nlet empty = [];\nconsole.log(empty.some(x => x > 0));   // false - no element matches\nconsole.log(empty.every(x => x > 0));  // true - 'all zero elements pass'\n\n// Always consider the empty array case in your logic!\nif (items.length > 0 && items.every(isValid)) {\n  // Safe check\n}\n```\n\n**6. Using at() for assignment (it's read-only):**\n```javascript\narr.at(0) = 'new value';  // ERROR!\narr[0] = 'new value';     // Correct\n```\n\n**7. Browser compatibility:**\n```javascript\n// at() - ES2022 (most modern browsers)\n// findLast/findLastIndex - ES2023 (check browser support)\n// For older environments, use polyfills or alternatives\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.4-challenge",
              "title": "Product Catalog Search",
              "description": "You're building an e-commerce product search system. Use the array search methods to implement various product lookup features.\n\nYour product catalog:\n- Find a specific product by ID\n- Check if any products are on sale\n- Verify all products have valid prices\n- Check if 'Electronics' category exists\n- Get the last added product (most recent)\n- Find position of the first out-of-stock item",
              "instructions": "Complete each search operation using the appropriate array method:\n1. Use find() to get the product with id: 3\n2. Use some() to check if any product has onSale: true\n3. Use every() to verify all products have price > 0\n4. Use includes() to check if 'Electronics' is in categories array\n5. Use at(-1) to get the last product\n6. Use findIndex() to find position of first product with stock: 0",
              "starterCode": "let products = [\n  { id: 1, name: 'Laptop', price: 999, stock: 15, onSale: false },\n  { id: 2, name: 'Mouse', price: 29, stock: 50, onSale: true },\n  { id: 3, name: 'Keyboard', price: 79, stock: 0, onSale: false },\n  { id: 4, name: 'Monitor', price: 349, stock: 8, onSale: true },\n  { id: 5, name: 'Headphones', price: 149, stock: 25, onSale: false }\n];\n\nlet categories = ['Electronics', 'Clothing', 'Home', 'Books'];\n\n// 1. Find product with id: 3\nlet product3 = // YOUR CODE\nconsole.log('Product 3:', product3?.name);\n\n// 2. Check if any products are on sale\nlet hasAnySale = // YOUR CODE\nconsole.log('Has sales:', hasAnySale);\n\n// 3. Verify all products have valid prices (> 0)\nlet allValidPrices = // YOUR CODE\nconsole.log('All valid prices:', allValidPrices);\n\n// 4. Check if 'Electronics' category exists\nlet hasElectronics = // YOUR CODE\nconsole.log('Has Electronics:', hasElectronics);\n\n// 5. Get the last product in the array\nlet lastProduct = // YOUR CODE\nconsole.log('Last product:', lastProduct?.name);\n\n// 6. Find index of first out-of-stock item (stock: 0)\nlet outOfStockIndex = // YOUR CODE\nconsole.log('Out of stock at index:', outOfStockIndex);",
              "solution": "let products = [\n  { id: 1, name: 'Laptop', price: 999, stock: 15, onSale: false },\n  { id: 2, name: 'Mouse', price: 29, stock: 50, onSale: true },\n  { id: 3, name: 'Keyboard', price: 79, stock: 0, onSale: false },\n  { id: 4, name: 'Monitor', price: 349, stock: 8, onSale: true },\n  { id: 5, name: 'Headphones', price: 149, stock: 25, onSale: false }\n];\n\nlet categories = ['Electronics', 'Clothing', 'Home', 'Books'];\n\n// 1. Find product with id: 3\nlet product3 = products.find(p => p.id === 3);\nconsole.log('Product 3:', product3?.name);  // 'Keyboard'\n\n// 2. Check if any products are on sale\nlet hasAnySale = products.some(p => p.onSale);\nconsole.log('Has sales:', hasAnySale);  // true\n\n// 3. Verify all products have valid prices (> 0)\nlet allValidPrices = products.every(p => p.price > 0);\nconsole.log('All valid prices:', allValidPrices);  // true\n\n// 4. Check if 'Electronics' category exists\nlet hasElectronics = categories.includes('Electronics');\nconsole.log('Has Electronics:', hasElectronics);  // true\n\n// 5. Get the last product in the array\nlet lastProduct = products.at(-1);\nconsole.log('Last product:', lastProduct?.name);  // 'Headphones'\n\n// 6. Find index of first out-of-stock item (stock: 0)\nlet outOfStockIndex = products.findIndex(p => p.stock === 0);\nconsole.log('Out of stock at index:', outOfStockIndex);  // 2",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Finds product with id 3",
                  "expectedOutput": "Keyboard",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Detects sale items with some()",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Verifies all prices with every()",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Checks category with includes()",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "test-5",
                  "description": "Gets last product with at(-1)",
                  "expectedOutput": "Headphones",
                  "isVisible": true
                },
                {
                  "id": "test-6",
                  "description": "Finds out-of-stock index",
                  "expectedOutput": "2",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For find(), use: products.find(p => p.id === 3)"
                },
                {
                  "level": 2,
                  "text": "For some(), check the onSale property: products.some(p => p.onSale)"
                },
                {
                  "level": 3,
                  "text": "For every(), check prices: products.every(p => p.price > 0). For includes(): categories.includes('Electronics')"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using filter() instead of find() for single item lookup",
                  "consequence": "Returns an array with one item instead of the item itself",
                  "correction": "Use find() to get a single element: products.find(p => p.id === 3)"
                },
                {
                  "mistake": "Using indexOf() to search objects",
                  "consequence": "indexOf uses reference equality, so it won't find objects by their properties",
                  "correction": "Use find() or findIndex() with a callback to search objects: products.findIndex(p => p.stock === 0)"
                },
                {
                  "mistake": "Forgetting to handle undefined from find()",
                  "consequence": "Accessing properties on undefined causes TypeError",
                  "correction": "Use optional chaining (product?.name) or check if the result exists before accessing properties"
                },
                {
                  "mistake": "Using arr[arr.length - 1] instead of at(-1)",
                  "consequence": "More verbose and error-prone code",
                  "correction": "Use at(-1) for cleaner access to the last element"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.5",
          "title": "Dictionaries: Storing Information with Labels (Objects)",
          "moduleId": "module-05",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're filling out a form about yourself:\n\nName: Alice\nAge: 25\nCity: New York\nIs Student: true\n\nEach piece of info has a LABEL (Name, Age, etc.) and a VALUE ('Alice', 25, etc.). This is different from an array, where items are accessed by position numbers. Here, you access items by NAME.\n\nIn JavaScript, this is called an OBJECT. Think of it like a real dictionary: you look up a WORD (the key) to find its DEFINITION (the value). Or like a person's contact card: each field (label) has a value.\n\nObjects are perfect for representing things with named properties: a user, a product, a car, etc."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Creating an object\nlet person = {\n  name: 'Alice',\n  age: 25,\n  city: 'New York',\n  isStudent: false\n};\n\n// Accessing properties (two ways)\nconsole.log(person.name);      // Alice (dot notation)\nconsole.log(person['age']);    // 25 (bracket notation)\n\n// Changing a property\nperson.age = 26;\nconsole.log(person.age);  // 26\n\n// Adding a new property\nperson.email = 'alice@example.com';\nconsole.log(person.email);  // alice@example.com\n\n// Deleting a property\ndelete person.isStudent;\nconsole.log(person.isStudent);  // undefined\n\n// Object with different types\nlet product = {\n  name: 'Laptop',\n  price: 999.99,\n  inStock: true,\n  specs: ['16GB RAM', '512GB SSD'],  // Array inside object!\n  manufacturer: {\n    name: 'Dell',\n    country: 'USA'\n  }  // Object inside object!\n};\n\nconsole.log(product.specs[0]);  // 16GB RAM\nconsole.log(product.manufacturer.name);  // Dell\n\n// Empty object\nlet empty = {};"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Object syntax:\n\n// Creating an object\nlet objectName = {\n  key1: value1,\n  key2: value2,\n  key3: value3\n};\n\nKey points:\n\n1. Surrounded by curly braces { }\n2. Key-value pairs separated by commas\n3. Key and value separated by colon :\n4. Keys are usually unquoted (unless they have spaces)\n5. Values can be any type\n\nAccessing properties:\n\n// Dot notation (most common)\nobject.propertyName\n\n// Bracket notation (for special cases)\nobject['property name']  // Property has space\nobject[variableName]     // Property name is in a variable\n\nWhen to use brackets:\n- Property name has spaces/special chars: obj['first name']\n- Property name is in a variable: let prop = 'age'; obj[prop]\n- Property name is computed: obj['item' + i]\n\nModifying objects:\n\n// Change existing property\nobj.name = 'new value';\n\n// Add new property\nobj.newProperty = 'value';\n\n// Delete property\ndelete obj.property;\n\n// Check if property exists\nif (obj.property !== undefined) { }\n// OR\nif ('property' in obj) { }\n\nNested structures:\nlet user = {\n  name: 'Alice',\n  address: {\n    street: '123 Main St',\n    city: 'NYC'\n  },\n  hobbies: ['reading', 'coding']\n};\n\nuser.address.city  // NYC\nuser.hobbies[0]    // reading"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting commas between properties:\n   {name: 'Alice' age: 25}  // WRONG - missing comma\n   {name: 'Alice', age: 25}  // CORRECT\n\n2. Using = instead of ::\n   {name = 'Alice'}  // WRONG\n   {name: 'Alice'}   // CORRECT\n\n3. Trailing comma on last property:\n   {name: 'Alice', age: 25,}  // Works in modern JS, but some old browsers error\n\n4. Confusing arrays and objects:\n   let arr = [1, 2, 3];    // Square brackets\n   let obj = {a: 1, b: 2}; // Curly braces\n\n5. Trying to use dot notation with spaces:\n   obj.first name  // WRONG\n   obj['first name']  // CORRECT\n   obj.firstName   // BETTER - use camelCase\n\n6. Expecting specific order:\n   Objects don't guarantee property order (though modern JS usually preserves it)\n   If order matters, use an array!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.5-challenge",
              "title": "Practice Challenge",
              "description": "Create an object representing a book:\n1. Create object with: title (string), author (string), pages (number), isRead (boolean)\n2. Display the title\n3. Change isRead to true\n4. Add a new property 'rating' with a number 1-5\n5. Display the entire object",
              "instructions": "Create an object representing a book:\n1. Create object with: title (string), author (string), pages (number), isRead (boolean)\n2. Display the title\n3. Change isRead to true\n4. Add a new property 'rating' with a number 1-5\n5. Display the entire object",
              "starterCode": "// Create your book object\n\n// Display title\n\n// Mark as read\n\n// Add rating\n\n// Display object\n",
              "solution": "let book = {\n  title: '1984',\n  author: 'George Orwell',\n  pages: 328,\n  isRead: false\n};\n\nconsole.log('Title:', book.title);\n\nbook.isRead = true;\n\nbook.rating = 5;\n\nconsole.log('Book:', book);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Creates book object correctly",
                  "expectedOutput": "Harry Potter",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "let book = {title: '...', author: '...', pages: 300, isRead: false};"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting commas between properties:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting commas between properties:\n   {name: 'Alice' age: 25}  // WRONG - missing comma\n   {name: 'Alice', age: 25}  // CORRECT"
                },
                {
                  "mistake": "Using = instead of ::",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using = instead of ::\n   {name = 'Alice'}  // WRONG\n   {name: 'Alice'}   // CORRECT"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.6",
          "title": "Working with Object Properties (Iterating and Manipulating)",
          "moduleId": "module-05",
          "order": 6,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're a store clerk inventorying products. You need to go through each product and check its details:\n\n'Product 1: Name = Laptop, Price = $1000'\n'Product 2: Name = Mouse, Price = $25'\n\nJust like we looped through arrays, we need to loop through objects. But objects don't have index numbers - they have property NAMES. JavaScript gives us special tools to work with object properties: get all keys, all values, or all key-value pairs."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "let student = {\n  name: 'Alice',\n  age: 20,\n  grade: 'A',\n  major: 'Computer Science'\n};\n\n// Get all property names (keys)\nlet keys = Object.keys(student);\nconsole.log(keys);  // ['name', 'age', 'grade', 'major']\n\n// Get all property values\nlet values = Object.values(student);\nconsole.log(values);  // ['Alice', 20, 'A', 'Computer Science']\n\n// Get all key-value pairs\nlet entries = Object.entries(student);\nconsole.log(entries);  // [['name', 'Alice'], ['age', 20], ...]\n\n// Loop through keys\nfor (let key of Object.keys(student)) {\n  console.log(key + ': ' + student[key]);\n}\n\n// Loop through key-value pairs (more elegant)\nfor (let [key, value] of Object.entries(student)) {\n  console.log(key + ': ' + value);\n}\n\n// for...in loop (older way)\nfor (let key in student) {\n  console.log(key + ': ' + student[key]);\n}\n\n// Practical: calculate total prices\nlet cart = {\n  laptop: 1000,\n  mouse: 25,\n  keyboard: 75\n};\n\nlet total = 0;\nfor (let price of Object.values(cart)) {\n  total += price;\n}\nconsole.log('Total: $' + total);  // $1100"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Three key Object methods:\n\n1. **Object.keys(obj)**\n   - Returns array of property names\n   - {a: 1, b: 2} → ['a', 'b']\n   - Use when you need property names\n\n2. **Object.values(obj)**\n   - Returns array of property values\n   - {a: 1, b: 2} → [1, 2]\n   - Use when you only need values\n\n3. **Object.entries(obj)**\n   - Returns array of [key, value] pairs\n   - {a: 1, b: 2} → [['a', 1], ['b', 2]]\n   - Use when you need both keys and values\n\nLoop patterns:\n\n// Pattern 1: Loop through keys\nfor (let key of Object.keys(obj)) {\n  console.log(key);          // Property name\n  console.log(obj[key]);     // Property value\n}\n\n// Pattern 2: Loop through values\nfor (let value of Object.values(obj)) {\n  console.log(value);  // Just the values\n}\n\n// Pattern 3: Loop through entries (destructuring)\nfor (let [key, value] of Object.entries(obj)) {\n  console.log(key, value);  // Both at once\n}\n\n// Pattern 4: for...in loop (older)\nfor (let key in obj) {\n  console.log(key, obj[key]);\n}\n\nDestructuring in loops:\n// This:\nfor (let entry of Object.entries(obj)) {\n  let key = entry[0];\n  let value = entry[1];\n}\n\n// Can be written as:\nfor (let [key, value] of Object.entries(obj)) {\n  // key and value are extracted automatically!\n}\n\nCounting properties:\nObject.keys(obj).length  // Number of properties"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Calling Object.keys() on non-object:\n   Object.keys([1,2,3])  // Works but returns ['0', '1', '2'] (indices as strings)\n   Object.keys('hello')  // Works but returns ['0', '1', '2', '3', '4']\n   \n2. Forgetting Object.keys() returns an array:\n   Object.keys(obj)  // Returns ARRAY of keys\n   // Must loop through: for (let key of Object.keys(obj))\n\n3. Confusing for...of and for...in:\n   for (let key of obj)  // ERROR - objects aren't iterable with for...of\n   for (let key in obj)  // CORRECT - for...in works on objects\n   for (let key of Object.keys(obj))  // ALSO CORRECT\n\n4. Not using destructuring with entries:\n   for (let entry of Object.entries(obj)) {\n     console.log(entry[0], entry[1]);  // Works but clunky\n   }\n   for (let [key, value] of Object.entries(obj)) {\n     console.log(key, value);  // Much cleaner!\n   }\n\n5. Expecting specific order:\n   Object properties don't have a guaranteed order\n   (Though modern JS usually maintains insertion order)"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.6-challenge",
              "title": "Practice Challenge",
              "description": "You have a product inventory object. Calculate:\n1. Total number of products (count of properties)\n2. Total value of all inventory (sum of all prices)\n3. Display each product with its price\n\nlet inventory = {\n  laptop: 1200,\n  mouse: 30,\n  keyboard: 80,\n  monitor: 350\n};",
              "instructions": "You have a product inventory object. Calculate:\n1. Total number of products (count of properties)\n2. Total value of all inventory (sum of all prices)\n3. Display each product with its price\n\nlet inventory = {\n  laptop: 1200,\n  mouse: 30,\n  keyboard: 80,\n  monitor: 350\n};",
              "starterCode": "let inventory = {\n  laptop: 1200,\n  mouse: 30,\n  keyboard: 80,\n  monitor: 350\n};\n\n// Count products\n\n// Calculate total value\n\n// Display each product\n",
              "solution": "let inventory = {\n  laptop: 1200,\n  mouse: 30,\n  keyboard: 80,\n  monitor: 350\n};\n\nlet productCount = Object.keys(inventory).length;\nconsole.log('Total products: ' + productCount);\n\nlet totalValue = 0;\nfor (let price of Object.values(inventory)) {\n  totalValue += price;\n}\nconsole.log('Total inventory value: $' + totalValue);\n\nconsole.log('Product list:');\nfor (let [product, price] of Object.entries(inventory)) {\n  console.log(product + ': $' + price);\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Counts products correctly",
                  "expectedOutput": "2",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Object.keys(inventory).length for count, loop through Object.values() to sum"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Calling Object.keys() on non-object:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Calling Object.keys() on non-object:\n   Object.keys([1,2,3])  // Works but returns ['0', '1', '2'] (indices as strings)\n   Object.keys('hello')  // Works but returns ['0', '1', '2', '3', '4']"
                },
                {
                  "mistake": "Forgetting Object.keys() returns an array:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting Object.keys() returns an array:\n   Object.keys(obj)  // Returns ARRAY of keys\n   // Must loop through: for (let key of Object.keys(obj))"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.7",
          "title": "Destructuring and Spread: Modern Data Extraction",
          "moduleId": "module-05",
          "order": 7,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Unpacking Your Suitcase",
              "content": "Imagine you come home from vacation with a packed suitcase. Instead of digging through the suitcase every time you need something, you unpack everything and put each item in its proper place:\n\n- Shirts go in the shirt drawer\n- Pants go in the pants drawer\n- Toiletries go in the bathroom\n\nNow each item has its own named location, making it much easier to access.\n\n**Destructuring** is exactly this process for data. When you receive an object or array, you can 'unpack' its values directly into individual variables. Instead of writing `user.name`, `user.age`, `user.email` repeatedly, you unpack once: `let { name, age, email } = user;`\n\n**Spread** is the opposite - it's like dumping all the contents of a drawer onto the bed to combine with other items. You can spread an array's elements or an object's properties into a new container.\n\nThese two features - destructuring (unpacking) and spread (spreading out) - are among the most commonly used modern JavaScript features. You'll see them everywhere in React, Vue, Node.js, and any modern JavaScript codebase."
            },
            {
              "type": "EXAMPLE",
              "title": "Object Destructuring Basics",
              "content": "Object destructuring lets you extract properties from an object into standalone variables. The variable names must match the property names (unless you rename them).",
              "language": "javascript",
              "code": "// === THE OLD WAY: Repetitive property access ===\nlet user = {\n  name: 'Alice',\n  age: 28,\n  email: 'alice@example.com',\n  city: 'New York'\n};\n\n// Tedious - we write 'user.' over and over\nlet name = user.name;\nlet age = user.age;\nlet email = user.email;\nconsole.log(name, age, email);  // Alice 28 alice@example.com\n\n// === THE NEW WAY: Destructuring ===\nlet user2 = {\n  name: 'Bob',\n  age: 32,\n  email: 'bob@example.com',\n  city: 'Los Angeles'\n};\n\n// Extract multiple properties in one line!\nlet { name: userName, age: userAge, email: userEmail } = user2;\nconsole.log(userName, userAge, userEmail);  // Bob 32 bob@example.com\n\n// Simpler: if variable names match property names\nlet { name: n, age: a, email: e, city: c } = user2;\n// Wait, let's use matching names (most common):\nlet person = { name: 'Charlie', age: 25, city: 'Chicago' };\nlet { name: personName, age: personAge, city: personCity } = person;\nconsole.log(personName, personAge);  // Charlie 25\n\n// === RENAMING: When you want different variable names ===\nlet product = { title: 'Laptop', price: 999 };\n\n// Rename 'title' to 'productName' and 'price' to 'cost'\nlet { title: productName, price: cost } = product;\nconsole.log(productName);  // 'Laptop'\nconsole.log(cost);         // 999\n// Note: 'title' and 'price' are NOT created as variables!\n\n// === DEFAULT VALUES: When property might not exist ===\nlet config = { theme: 'dark' };\n\n// 'language' doesn't exist, so use default 'en'\nlet { theme, language = 'en', fontSize = 16 } = config;\nconsole.log(theme);     // 'dark' (from object)\nconsole.log(language);  // 'en' (default - property was undefined)\nconsole.log(fontSize);  // 16 (default - property was undefined)\n\n// Default only applies if property is undefined, not null!\nlet settings = { volume: null };\nlet { volume = 50 } = settings;\nconsole.log(volume);  // null (not 50! null is a value, not undefined)\n\n// === COMBINING RENAME AND DEFAULT ===\nlet response = { status: 200 };\nlet { status: httpStatus = 500, message: errorMsg = 'Unknown' } = response;\nconsole.log(httpStatus);  // 200\nconsole.log(errorMsg);    // 'Unknown' (default)"
            },
            {
              "type": "EXAMPLE",
              "title": "Array Destructuring",
              "content": "Array destructuring extracts values by POSITION rather than by name. The first variable gets the first element, second variable gets the second element, and so on.",
              "language": "javascript",
              "code": "// === BASIC ARRAY DESTRUCTURING ===\nlet colors = ['red', 'green', 'blue', 'yellow', 'purple'];\n\n// Old way\nlet first = colors[0];\nlet second = colors[1];\nlet third = colors[2];\n\n// New way - destructure by position\nlet [primary, secondary, tertiary] = colors;\nconsole.log(primary);    // 'red'\nconsole.log(secondary);  // 'green'\nconsole.log(tertiary);   // 'blue'\n\n// === SKIPPING ELEMENTS ===\n// Use empty commas to skip positions\nlet numbers = [1, 2, 3, 4, 5];\n\nlet [firstNum, , thirdNum, , fifthNum] = numbers;\nconsole.log(firstNum);   // 1\nconsole.log(thirdNum);   // 3 (skipped 2)\nconsole.log(fifthNum);   // 5 (skipped 4)\n\n// === SWAPPING VALUES (Classic Interview Question!) ===\nlet a = 10;\nlet b = 20;\nconsole.log('Before:', a, b);  // Before: 10 20\n\n// Old way - needs a temporary variable\n// let temp = a; a = b; b = temp;\n\n// New way - elegant one-liner!\n[a, b] = [b, a];\nconsole.log('After:', a, b);   // After: 20 10\n\n// Works with more variables too!\nlet x = 1, y = 2, z = 3;\n[x, y, z] = [z, x, y];  // Rotate values\nconsole.log(x, y, z);   // 3 1 2\n\n// === DEFAULT VALUES ===\nlet sparse = [100];\n\nlet [val1, val2 = 'default', val3 = 'also default'] = sparse;\nconsole.log(val1);  // 100\nconsole.log(val2);  // 'default' (no second element)\nconsole.log(val3);  // 'also default' (no third element)\n\n// === REST ELEMENTS: Collect remaining items ===\nlet scores = [95, 87, 92, 78, 85, 90];\n\n// Get first score, collect the rest\nlet [highest, ...remaining] = scores;\nconsole.log(highest);    // 95\nconsole.log(remaining);  // [87, 92, 78, 85, 90]\n\n// Practical: separate first from rest\nlet [head, ...tail] = [1, 2, 3, 4, 5];\nconsole.log(head);  // 1\nconsole.log(tail);  // [2, 3, 4, 5]\n\n// Note: rest element MUST be last!\n// let [...first, last] = array;  // SYNTAX ERROR!\n\n// === PRACTICAL: Multiple Return Values ===\nfunction getMinMax(numbers) {\n  let min = Math.min(...numbers);\n  let max = Math.max(...numbers);\n  return [min, max];  // Return array\n}\n\nlet values = [5, 2, 9, 1, 7];\nlet [minimum, maximum] = getMinMax(values);\nconsole.log('Min:', minimum);  // Min: 1\nconsole.log('Max:', maximum);  // Max: 9\n\n// === PRACTICAL: Split and Destructure ===\nlet dateString = '2024-12-25';\nlet [year, month, day] = dateString.split('-');\nconsole.log(year, month, day);  // 2024 12 25"
            },
            {
              "type": "EXAMPLE",
              "title": "Nested Destructuring",
              "content": "When you have objects within objects or arrays within arrays, you can destructure multiple levels deep. This is especially useful for API responses with nested data.",
              "language": "javascript",
              "code": "// === NESTED OBJECT DESTRUCTURING ===\nlet user = {\n  id: 1,\n  name: 'Alice',\n  address: {\n    street: '123 Main St',\n    city: 'New York',\n    country: 'USA',\n    zip: '10001'\n  },\n  contacts: {\n    email: 'alice@example.com',\n    phone: '555-1234'\n  }\n};\n\n// Extract nested properties\nlet {\n  name,\n  address: { city, country },\n  contacts: { email }\n} = user;\n\nconsole.log(name);     // 'Alice'\nconsole.log(city);     // 'New York'\nconsole.log(country);  // 'USA'\nconsole.log(email);    // 'alice@example.com'\n\n// Note: 'address' and 'contacts' are NOT created as variables!\n// Only the nested properties (city, country, email) are extracted\n// To also get the parent object:\nlet {\n  address,                    // Gets the whole address object\n  address: { zip }            // Also extracts zip from it\n} = user;\nconsole.log(address);         // { street: '123 Main St', city: 'New York', ... }\nconsole.log(zip);             // '10001'\n\n// === NESTED ARRAY DESTRUCTURING ===\nlet matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n\n// Get specific elements from nested arrays\nlet [[a, b], [, d, e], [g]] = matrix;\nconsole.log(a, b);    // 1 2 (from first row)\nconsole.log(d, e);    // 5 6 (from second row, skipped 4)\nconsole.log(g);       // 7 (from third row)\n\n// === MIXED: Objects containing Arrays ===\nlet order = {\n  id: 'ORD-001',\n  items: ['Laptop', 'Mouse', 'Keyboard'],\n  customer: {\n    name: 'Bob',\n    email: 'bob@shop.com'\n  }\n};\n\nlet {\n  id: orderId,\n  items: [firstItem, secondItem],\n  customer: { name: customerName }\n} = order;\n\nconsole.log(orderId);       // 'ORD-001'\nconsole.log(firstItem);     // 'Laptop'\nconsole.log(secondItem);    // 'Mouse'\nconsole.log(customerName);  // 'Bob'\n\n// === SAFE NESTED DESTRUCTURING with Defaults ===\n// What if nested object might not exist?\nlet incompleteUser = {\n  name: 'Charlie'\n  // No address property!\n};\n\n// This would crash: let { address: { city } } = incompleteUser;\n// TypeError: Cannot destructure property 'city' of undefined\n\n// Safe way: provide default empty object\nlet { address: { city: userCity } = {} } = incompleteUser;\nconsole.log(userCity);  // undefined (but no crash!)\n\n// Even safer: default for the nested property too\nlet { address: { city: safeCity = 'Unknown' } = {} } = incompleteUser;\nconsole.log(safeCity);  // 'Unknown'\n\n// === PRACTICAL: API Response Handling ===\nlet apiResponse = {\n  data: {\n    user: {\n      profile: {\n        firstName: 'Diana',\n        lastName: 'Smith'\n      }\n    }\n  },\n  status: 200\n};\n\nlet {\n  data: {\n    user: {\n      profile: { firstName, lastName }\n    }\n  },\n  status\n} = apiResponse;\n\nconsole.log(`${firstName} ${lastName}`);  // 'Diana Smith'\nconsole.log(status);                       // 200"
            },
            {
              "type": "EXAMPLE",
              "title": "Spread Operator with Objects",
              "content": "The spread operator (...) 'spreads out' the properties of an object. It's commonly used for copying objects and merging multiple objects together. Important: spread creates a SHALLOW copy, not a deep copy.",
              "language": "javascript",
              "code": "// === COPYING OBJECTS ===\nlet original = { name: 'Alice', age: 28 };\n\n// Shallow copy using spread\nlet copy = { ...original };\nconsole.log(copy);  // { name: 'Alice', age: 28 }\n\n// Proof it's a copy, not a reference\ncopy.name = 'Bob';\nconsole.log(original.name);  // 'Alice' (unchanged!)\nconsole.log(copy.name);      // 'Bob'\n\n// === MERGING OBJECTS ===\nlet defaults = { theme: 'light', language: 'en', fontSize: 14 };\nlet userPrefs = { theme: 'dark', fontSize: 18 };\n\n// Merge: userPrefs overrides defaults\nlet settings = { ...defaults, ...userPrefs };\nconsole.log(settings);\n// { theme: 'dark', language: 'en', fontSize: 18 }\n\n// ORDER MATTERS! Later spreads override earlier ones\nlet result1 = { ...defaults, ...userPrefs };  // userPrefs wins\nlet result2 = { ...userPrefs, ...defaults };  // defaults wins\nconsole.log(result1.theme);  // 'dark' (from userPrefs)\nconsole.log(result2.theme);  // 'light' (from defaults)\n\n// === ADDING/OVERRIDING PROPERTIES ===\nlet person = { name: 'Charlie', age: 30 };\n\n// Add new properties\nlet personWithEmail = { ...person, email: 'charlie@test.com' };\nconsole.log(personWithEmail);\n// { name: 'Charlie', age: 30, email: 'charlie@test.com' }\n\n// Override existing property\nlet olderPerson = { ...person, age: 31 };\nconsole.log(olderPerson);  // { name: 'Charlie', age: 31 }\n\n// Combined: copy, override, and add\nlet updatedPerson = {\n  ...person,\n  age: 31,           // Override\n  city: 'Boston'     // Add new\n};\nconsole.log(updatedPerson);\n// { name: 'Charlie', age: 31, city: 'Boston' }\n\n// === SHALLOW COPY WARNING ===\n// Spread only copies one level deep!\nlet user = {\n  name: 'Diana',\n  address: { city: 'NYC', zip: '10001' }  // Nested object\n};\n\nlet userCopy = { ...user };\nuserCopy.name = 'Eve';              // OK - doesn't affect original\nuserCopy.address.city = 'Boston';   // PROBLEM - affects original!\n\nconsole.log(user.name);          // 'Diana' (unchanged)\nconsole.log(user.address.city);  // 'Boston' (CHANGED!)\n\n// The nested 'address' object is the SAME reference in both!\n// For deep copies, you need:\nlet deepCopy = JSON.parse(JSON.stringify(user));\n// Or use structuredClone() in modern environments:\n// let deepCopy = structuredClone(user);\n\n// === PRACTICAL: Immutable Updates (React Pattern) ===\nlet state = {\n  user: { name: 'Frank', score: 100 },\n  settings: { theme: 'dark' }\n};\n\n// Update score without mutating original state\nlet newState = {\n  ...state,\n  user: {\n    ...state.user,\n    score: state.user.score + 10\n  }\n};\n\nconsole.log(state.user.score);     // 100 (unchanged)\nconsole.log(newState.user.score);  // 110\n\n// === PRACTICAL: Removing Properties (Rest Pattern) ===\nlet fullUser = { id: 1, name: 'Grace', password: 'secret123', email: 'g@test.com' };\n\n// Remove password before sending to client\nlet { password, ...safeUser } = fullUser;\nconsole.log(safeUser);  // { id: 1, name: 'Grace', email: 'g@test.com' }\n// password is extracted but not used - effectively removed"
            },
            {
              "type": "EXAMPLE",
              "title": "Spread Operator with Arrays",
              "content": "Array spread works similarly to object spread - it 'spreads out' array elements. Perfect for combining arrays, creating copies, and converting iterables to arrays.",
              "language": "javascript",
              "code": "// === COPYING ARRAYS ===\nlet original = [1, 2, 3];\nlet copy = [...original];\n\ncopy.push(4);\nconsole.log(original);  // [1, 2, 3] (unchanged)\nconsole.log(copy);      // [1, 2, 3, 4]\n\n// === COMBINING ARRAYS ===\nlet first = [1, 2, 3];\nlet second = [4, 5, 6];\n\n// Old way: concat\nlet combined1 = first.concat(second);\n\n// New way: spread\nlet combined2 = [...first, ...second];\nconsole.log(combined2);  // [1, 2, 3, 4, 5, 6]\n\n// Can add elements in between\nlet combined3 = [...first, 'middle', ...second];\nconsole.log(combined3);  // [1, 2, 3, 'middle', 4, 5, 6]\n\n// === INSERTING ELEMENTS ===\nlet numbers = [1, 2, 5, 6];\n// Insert 3 and 4 at position 2\nlet expanded = [...numbers.slice(0, 2), 3, 4, ...numbers.slice(2)];\nconsole.log(expanded);  // [1, 2, 3, 4, 5, 6]\n\n// === SPREAD IN FUNCTION CALLS ===\nlet scores = [85, 92, 78, 95, 88];\n\n// Math.max expects individual arguments, not an array\n// Math.max([85, 92, 78]) returns NaN!\n// Spread the array into individual arguments:\nlet highest = Math.max(...scores);\nlet lowest = Math.min(...scores);\nconsole.log('Highest:', highest);  // 95\nconsole.log('Lowest:', lowest);    // 78\n\n// === CONVERT ITERABLE TO ARRAY ===\n// String to array of characters\nlet str = 'Hello';\nlet chars = [...str];\nconsole.log(chars);  // ['H', 'e', 'l', 'l', 'o']\n\n// Set to array\nlet uniqueSet = new Set([1, 2, 2, 3, 3, 3]);\nlet uniqueArray = [...uniqueSet];\nconsole.log(uniqueArray);  // [1, 2, 3]\n\n// NodeList to array (in browser)\n// let elements = [...document.querySelectorAll('div')];\n\n// === REMOVING DUPLICATES (One-liner!) ===\nlet withDupes = [1, 2, 2, 3, 1, 4, 3, 5];\nlet unique = [...new Set(withDupes)];\nconsole.log(unique);  // [1, 2, 3, 4, 5]\n\n// === PUSHING MULTIPLE ITEMS ===\nlet arr = [1, 2];\n\n// Old way: multiple pushes or apply\narr.push(3);\narr.push(4);\n\n// New way: spread in push\nlet newItems = [5, 6, 7];\narr.push(...newItems);\nconsole.log(arr);  // [1, 2, 3, 4, 5, 6, 7]\n\n// === CLONING AND MODIFYING ===\nlet todos = [\n  { id: 1, text: 'Learn JS', done: false },\n  { id: 2, text: 'Build app', done: false }\n];\n\n// Add new todo (immutably)\nlet newTodo = { id: 3, text: 'Deploy', done: false };\nlet updatedTodos = [...todos, newTodo];\nconsole.log(todos.length);        // 2 (unchanged)\nconsole.log(updatedTodos.length); // 3\n\n// Remove by id (immutably)\nlet withoutFirst = todos.filter(t => t.id !== 1);\nconsole.log(withoutFirst.length); // 1"
            },
            {
              "type": "EXAMPLE",
              "title": "Rest Pattern in Destructuring",
              "content": "The rest pattern (...) collects 'the rest' of the properties or elements that weren't explicitly destructured. It's the opposite of spread - instead of spreading out, it gathers up.",
              "language": "javascript",
              "code": "// === REST WITH OBJECTS ===\nlet user = {\n  id: 1,\n  name: 'Alice',\n  email: 'alice@test.com',\n  role: 'admin',\n  lastLogin: '2024-01-15'\n};\n\n// Extract specific properties, collect the rest\nlet { id, name, ...otherProps } = user;\nconsole.log(id);          // 1\nconsole.log(name);        // 'Alice'\nconsole.log(otherProps);  // { email: 'alice@test.com', role: 'admin', lastLogin: '2024-01-15' }\n\n// PRACTICAL: Omit sensitive fields\nlet userData = {\n  username: 'bob',\n  password: 'secret',\n  token: 'abc123',\n  profile: { name: 'Bob Smith' }\n};\n\n// Remove password and token, keep the rest\nlet { password, token, ...safeData } = userData;\nconsole.log(safeData);  // { username: 'bob', profile: { name: 'Bob Smith' } }\n\n// === REST WITH ARRAYS ===\nlet numbers = [1, 2, 3, 4, 5, 6, 7];\n\n// Get first two, collect rest\nlet [first, second, ...rest] = numbers;\nconsole.log(first);   // 1\nconsole.log(second);  // 2\nconsole.log(rest);    // [3, 4, 5, 6, 7]\n\n// Get first and last (using rest creatively)\nlet scores = [95, 87, 92, 78, 85];\nlet [highest, ...middle] = scores;\nlet lowest = middle.pop();  // Get last from rest\nconsole.log(highest);  // 95\nconsole.log(lowest);   // 85\nconsole.log(middle);   // [87, 92, 78]\n\n// === REST MUST BE LAST ===\n// These are SYNTAX ERRORS:\n// let { ...rest, name } = obj;     // Error!\n// let [...rest, last] = array;     // Error!\n// Rest pattern MUST be the last element\n\n// === COMBINING REST AND DEFAULTS ===\nlet config = { debug: true };\n\nlet { debug = false, verbose = false, ...options } = config;\nconsole.log(debug);    // true (from object)\nconsole.log(verbose);  // false (default)\nconsole.log(options);  // {} (nothing else left)\n\n// === PRACTICAL: Function Options Pattern ===\nfunction createUser({ name, email, ...options }) {\n  console.log('Creating user:', name);\n  console.log('Email:', email);\n  console.log('Additional options:', options);\n  \n  return {\n    name,\n    email,\n    createdAt: new Date(),\n    ...options  // Include all extra options\n  };\n}\n\nlet newUser = createUser({\n  name: 'Charlie',\n  email: 'c@test.com',\n  role: 'editor',\n  department: 'Marketing',\n  verified: true\n});\n\nconsole.log(newUser);\n// { name: 'Charlie', email: 'c@test.com', createdAt: Date, role: 'editor', department: 'Marketing', verified: true }"
            },
            {
              "type": "EXAMPLE",
              "title": "Function Parameter Destructuring",
              "content": "Destructuring can be used directly in function parameters, making functions cleaner and more flexible. This is the foundation of the 'options object' pattern used extensively in modern JavaScript.",
              "language": "javascript",
              "code": "// === BASIC PARAMETER DESTRUCTURING ===\n\n// Old way: access properties inside function\nfunction greetOld(user) {\n  console.log('Hello, ' + user.name + '! You are ' + user.age + ' years old.');\n}\n\n// New way: destructure in parameter\nfunction greet({ name, age }) {\n  console.log(`Hello, ${name}! You are ${age} years old.`);\n}\n\ngreet({ name: 'Alice', age: 28 });  // Hello, Alice! You are 28 years old.\n\n// === WITH DEFAULTS ===\nfunction createWidget({ width = 100, height = 100, color = 'blue' }) {\n  console.log(`Widget: ${width}x${height}, color: ${color}`);\n  return { width, height, color };\n}\n\ncreateWidget({ width: 200 });               // Widget: 200x100, color: blue\ncreateWidget({ color: 'red' });             // Widget: 100x100, color: red\ncreateWidget({ width: 50, height: 50 });    // Widget: 50x50, color: blue\ncreateWidget({});                            // Widget: 100x100, color: blue\n\n// === DEFAULT FOR ENTIRE PARAMETER ===\n// What if no object is passed at all?\nfunction greetSafe({ name = 'Guest', age = 0 } = {}) {\n  console.log(`Hello, ${name}! Age: ${age}`);\n}\n\ngreetSafe({ name: 'Bob' });  // Hello, Bob! Age: 0\ngreetSafe({});               // Hello, Guest! Age: 0\ngreetSafe();                 // Hello, Guest! Age: 0 (works because of = {})\n\n// Without the = {}, calling greetSafe() would crash!\n// Cannot destructure property 'name' of undefined\n\n// === ARRAY DESTRUCTURING IN PARAMETERS ===\nfunction processCoordinates([x, y, z = 0]) {\n  console.log(`X: ${x}, Y: ${y}, Z: ${z}`);\n}\n\nprocessCoordinates([10, 20]);      // X: 10, Y: 20, Z: 0\nprocessCoordinates([5, 15, 25]);   // X: 5, Y: 15, Z: 25\n\n// Practical: Swap function\nfunction swap([a, b]) {\n  return [b, a];\n}\nconsole.log(swap([1, 2]));  // [2, 1]\n\n// === NAMED PARAMETERS PATTERN ===\n// Much more readable than positional parameters!\n\n// Confusing: what do these arguments mean?\nfunction createButtonBad(text, width, height, primary, disabled) {\n  // ...\n}\ncreateButtonBad('Click', 120, 40, true, false);  // What's true? What's false?\n\n// Clear: named parameters via destructuring\nfunction createButton({ text, width = 100, height = 40, primary = false, disabled = false }) {\n  console.log(`Button: \"${text}\", ${width}x${height}`);\n  console.log(`Primary: ${primary}, Disabled: ${disabled}`);\n}\n\ncreateButton({\n  text: 'Submit',\n  primary: true,\n  width: 150\n});\n// Arguments are self-documenting!\n\n// === OPTIONS OBJECT PATTERN ===\nfunction fetchData(url, {\n  method = 'GET',\n  headers = {},\n  body = null,\n  timeout = 5000,\n  retries = 3\n} = {}) {\n  console.log(`Fetching: ${url}`);\n  console.log(`Method: ${method}, Timeout: ${timeout}ms, Retries: ${retries}`);\n  // ... actual fetch logic\n}\n\n// Use with defaults\nfetchData('https://api.example.com/users');\n// Fetching: https://api.example.com/users\n// Method: GET, Timeout: 5000ms, Retries: 3\n\n// Override some options\nfetchData('https://api.example.com/users', {\n  method: 'POST',\n  body: JSON.stringify({ name: 'Alice' }),\n  timeout: 10000\n});\n// Fetching: https://api.example.com/users\n// Method: POST, Timeout: 10000ms, Retries: 3\n\n// === COMBINING WITH REST ===\nfunction logUser({ name, email, ...metadata }) {\n  console.log(`User: ${name} (${email})`);\n  console.log('Metadata:', metadata);\n}\n\nlogUser({\n  name: 'Diana',\n  email: 'd@test.com',\n  role: 'admin',\n  team: 'engineering',\n  lastActive: '2024-01-20'\n});\n// User: Diana (d@test.com)\n// Metadata: { role: 'admin', team: 'engineering', lastActive: '2024-01-20' }"
            },
            {
              "type": "THEORY",
              "title": "Complete Syntax Reference",
              "content": "**Object Destructuring Syntax:**\n\n```javascript\n// Basic extraction\nlet { prop1, prop2 } = object;\n\n// With rename\nlet { prop: newName } = object;\n\n// With default\nlet { prop = defaultValue } = object;\n\n// Rename AND default\nlet { prop: newName = defaultValue } = object;\n\n// Nested extraction\nlet { outer: { inner } } = object;\n\n// Rest pattern\nlet { extracted, ...rest } = object;\n```\n\n**Array Destructuring Syntax:**\n\n```javascript\n// Basic extraction\nlet [first, second, third] = array;\n\n// Skip elements\nlet [first, , third] = array;\n\n// With default\nlet [first = 'default'] = array;\n\n// Rest pattern\nlet [first, ...rest] = array;\n\n// Swap values\n[a, b] = [b, a];\n```\n\n**Spread Operator Syntax:**\n\n```javascript\n// Copy object\nlet copy = { ...original };\n\n// Merge objects (later wins)\nlet merged = { ...obj1, ...obj2 };\n\n// Add/override properties\nlet updated = { ...obj, newProp: value };\n\n// Copy array\nlet arrCopy = [...original];\n\n// Combine arrays\nlet combined = [...arr1, ...arr2];\n\n// Spread in function call\nfunc(...argsArray);\n```\n\n**Key Differences:**\n\n| Feature | Destructuring | Spread |\n|---------|---------------|--------|\n| Purpose | Extract values | Expand values |\n| Position | Left side of = | Right side of = |\n| Objects | `let { a } = obj` | `{ ...obj }` |\n| Arrays | `let [a] = arr` | `[...arr]` |\n| Result | Individual variables | New object/array |\n\n**When to use which:**\n\n- **Destructuring**: When you need to pull out specific values from a structure\n- **Spread**: When you need to combine, copy, or expand values\n- **Rest (...)**: When you need to collect remaining values after destructuring"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "**1. Shallow Copy Confusion (Most Common!)**\n```javascript\nlet user = { name: 'Alice', address: { city: 'NYC' } };\nlet copy = { ...user };\ncopy.address.city = 'LA';  // ALSO changes user.address.city!\n\n// Fix: Deep copy for nested objects\nlet deepCopy = JSON.parse(JSON.stringify(user));\n// Or: let deepCopy = structuredClone(user);\n```\n\n**2. Destructuring undefined/null**\n```javascript\nlet user = null;\nlet { name } = user;  // TypeError!\n\n// Fix: Provide default empty object\nlet { name } = user || {};\n// Or use optional chaining first:\nlet name = user?.name;\n```\n\n**3. Forgetting Default for Missing Parameter**\n```javascript\nfunction greet({ name }) {\n  console.log(name);\n}\ngreet();  // TypeError: Cannot destructure 'name' of undefined\n\n// Fix: Add = {} default\nfunction greet({ name } = {}) {\n  console.log(name);  // undefined, but no crash\n}\n```\n\n**4. Order Matters for Spread**\n```javascript\n// These produce DIFFERENT results!\nlet result1 = { ...defaults, ...userPrefs };  // userPrefs wins\nlet result2 = { ...userPrefs, ...defaults };  // defaults wins\n\n// Later properties override earlier ones!\n```\n\n**5. Rest Must Be Last**\n```javascript\nlet { ...rest, name } = obj;  // SYNTAX ERROR!\nlet { name, ...rest } = obj;  // Correct\n\nlet [...rest, last] = arr;    // SYNTAX ERROR!\nlet [first, ...rest] = arr;   // Correct\n```\n\n**6. Expecting Destructuring to Create Missing Properties**\n```javascript\nlet { name } = {};  // name is undefined, not an error\nlet { name } = { title: 'Hi' };  // name is undefined\n\n// Destructuring extracts what exists\n// It doesn't create properties that don't exist\n```\n\n**7. Confusing Rename Syntax**\n```javascript\n// { oldName: newName } extracts oldName AS newName\nlet { title: name } = { title: 'Alice' };\nconsole.log(name);   // 'Alice'\nconsole.log(title);  // ReferenceError: title is not defined\n\n// The LEFT side is the property name\n// The RIGHT side is the new variable name\n```\n\n**8. Mutating Spread Copies (Still References for Nested)**\n```javascript\nlet original = [{ id: 1 }, { id: 2 }];\nlet copy = [...original];\n\n// The array is copied, but objects inside are same references!\ncopy[0].id = 999;\nconsole.log(original[0].id);  // 999 - CHANGED!\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.7-challenge-1",
              "title": "Practice Challenge: API Response Processing",
              "description": "You receive a complex API response with user data. Use destructuring and spread to extract and transform the data efficiently.\n\n1. Extract the user's firstName, lastName, and email from the nested response\n2. Extract the first two skills from the skills array\n3. Create a 'publicProfile' object that contains name, email, and skills, but NOT the password or ssn fields\n4. Merge the user's preferences with default preferences (user prefs should override defaults)",
              "instructions": "Use destructuring for extraction and spread for object manipulation. Focus on clean, readable code.",
              "starterCode": "// API Response from server\nlet apiResponse = {\n  status: 'success',\n  data: {\n    user: {\n      id: 12345,\n      credentials: {\n        firstName: 'Alice',\n        lastName: 'Johnson',\n        email: 'alice@example.com',\n        password: 'hashed_secret',\n        ssn: '123-45-6789'\n      },\n      skills: ['JavaScript', 'React', 'Node.js', 'Python', 'SQL'],\n      preferences: {\n        theme: 'dark',\n        notifications: true\n      }\n    }\n  }\n};\n\nlet defaultPreferences = {\n  theme: 'light',\n  notifications: false,\n  language: 'en',\n  timezone: 'UTC'\n};\n\n// 1. Extract firstName, lastName, email from nested structure\n// YOUR CODE HERE\nconsole.log(`User: ${firstName} ${lastName} (${email})`);\n\n// 2. Extract first two skills\n// YOUR CODE HERE\nconsole.log(`Primary skills: ${skill1}, ${skill2}`);\n\n// 3. Create publicProfile WITHOUT password and ssn\n// Hint: Use rest pattern to exclude, then spread to create new object\n// YOUR CODE HERE\nconsole.log('Public profile:', publicProfile);\n\n// 4. Merge preferences (user prefs override defaults)\n// YOUR CODE HERE\nconsole.log('Final preferences:', finalPrefs);",
              "solution": "let apiResponse = {\n  status: 'success',\n  data: {\n    user: {\n      id: 12345,\n      credentials: {\n        firstName: 'Alice',\n        lastName: 'Johnson',\n        email: 'alice@example.com',\n        password: 'hashed_secret',\n        ssn: '123-45-6789'\n      },\n      skills: ['JavaScript', 'React', 'Node.js', 'Python', 'SQL'],\n      preferences: {\n        theme: 'dark',\n        notifications: true\n      }\n    }\n  }\n};\n\nlet defaultPreferences = {\n  theme: 'light',\n  notifications: false,\n  language: 'en',\n  timezone: 'UTC'\n};\n\n// 1. Extract firstName, lastName, email from nested structure\nlet {\n  data: {\n    user: {\n      credentials: { firstName, lastName, email }\n    }\n  }\n} = apiResponse;\nconsole.log(`User: ${firstName} ${lastName} (${email})`);\n// User: Alice Johnson (alice@example.com)\n\n// 2. Extract first two skills\nlet {\n  data: {\n    user: {\n      skills: [skill1, skill2]\n    }\n  }\n} = apiResponse;\nconsole.log(`Primary skills: ${skill1}, ${skill2}`);\n// Primary skills: JavaScript, React\n\n// 3. Create publicProfile WITHOUT password and ssn\nlet { password, ssn, ...safeCredentials } = apiResponse.data.user.credentials;\nlet publicProfile = {\n  ...safeCredentials,\n  skills: apiResponse.data.user.skills\n};\nconsole.log('Public profile:', publicProfile);\n// { firstName: 'Alice', lastName: 'Johnson', email: 'alice@example.com', skills: [...] }\n\n// 4. Merge preferences (user prefs override defaults)\nlet finalPrefs = {\n  ...defaultPreferences,\n  ...apiResponse.data.user.preferences\n};\nconsole.log('Final preferences:', finalPrefs);\n// { theme: 'dark', notifications: true, language: 'en', timezone: 'UTC' }",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Extracts firstName correctly",
                  "expectedOutput": "Alice",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Creates publicProfile without password",
                  "expectedOutput": "undefined",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Merges preferences correctly",
                  "expectedOutput": "dark",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For nested destructuring: let { outer: { inner: { value } } } = obj;"
                },
                {
                  "level": 2,
                  "text": "To exclude properties: let { excluded1, excluded2, ...rest } = obj;"
                },
                {
                  "level": 3,
                  "text": "For merging with overrides: { ...defaults, ...overrides } - later values win"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Trying to access password after destructuring it out",
                  "consequence": "The variable exists but you want to exclude it from the result",
                  "correction": "Use rest pattern: let { password, ssn, ...safeData } = credentials;"
                },
                {
                  "mistake": "Wrong order when merging preferences",
                  "consequence": "Default values override user preferences",
                  "correction": "Spread defaults FIRST, then user prefs: { ...defaults, ...userPrefs }"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "5.7-challenge-2",
              "title": "Practice Challenge: Refactoring with Destructuring",
              "description": "Refactor the following verbose code to use modern destructuring and spread patterns. The functionality should remain exactly the same, but the code should be much cleaner.",
              "instructions": "Convert the old-style code to use:\n- Object destructuring for extracting properties\n- Array destructuring for extracting elements\n- Spread operator for copying and merging\n- Function parameter destructuring",
              "starterCode": "// ========== REFACTOR THIS CODE ==========\n\n// OLD CODE 1: Extract user properties\nlet user = { name: 'Bob', age: 30, city: 'Seattle', country: 'USA' };\nlet userName = user.name;\nlet userAge = user.age;\nlet userCity = user.city;\nconsole.log(userName, userAge, userCity);\n\n// YOUR REFACTORED VERSION:\n// (Use destructuring to extract all three in one line)\n\n\n// OLD CODE 2: Get first and rest of array\nlet numbers = [10, 20, 30, 40, 50];\nlet firstNumber = numbers[0];\nlet restNumbers = numbers.slice(1);\nconsole.log('First:', firstNumber, 'Rest:', restNumbers);\n\n// YOUR REFACTORED VERSION:\n// (Use array destructuring with rest)\n\n\n// OLD CODE 3: Merge objects\nlet defaults = { volume: 50, brightness: 80 };\nlet userSettings = { volume: 75 };\nlet merged = {};\nfor (let key in defaults) {\n  merged[key] = defaults[key];\n}\nfor (let key in userSettings) {\n  merged[key] = userSettings[key];\n}\nconsole.log('Merged:', merged);\n\n// YOUR REFACTORED VERSION:\n// (Use spread to merge in one line)\n\n\n// OLD CODE 4: Function with object parameter\nfunction displayProduct(product) {\n  let name = product.name;\n  let price = product.price;\n  let inStock = product.inStock !== undefined ? product.inStock : true;\n  console.log(name + ': $' + price + (inStock ? ' (In Stock)' : ' (Out of Stock)'));\n}\ndisplayProduct({ name: 'Laptop', price: 999 });\n\n// YOUR REFACTORED VERSION:\n// (Use parameter destructuring with default value)\n\n\n// OLD CODE 5: Swap two variables\nlet x = 100;\nlet y = 200;\nlet temp = x;\nx = y;\ny = temp;\nconsole.log('After swap: x =', x, ', y =', y);\n\n// YOUR REFACTORED VERSION:\n// (Use array destructuring to swap in one line)",
              "solution": "// ========== REFACTORED CODE ==========\n\n// REFACTORED 1: Extract user properties\nlet user = { name: 'Bob', age: 30, city: 'Seattle', country: 'USA' };\nlet { name: userName, age: userAge, city: userCity } = user;\nconsole.log(userName, userAge, userCity);\n// Bob 30 Seattle\n\n// REFACTORED 2: Get first and rest of array\nlet numbers = [10, 20, 30, 40, 50];\nlet [firstNumber, ...restNumbers] = numbers;\nconsole.log('First:', firstNumber, 'Rest:', restNumbers);\n// First: 10 Rest: [20, 30, 40, 50]\n\n// REFACTORED 3: Merge objects\nlet defaults = { volume: 50, brightness: 80 };\nlet userSettings = { volume: 75 };\nlet merged = { ...defaults, ...userSettings };\nconsole.log('Merged:', merged);\n// Merged: { volume: 75, brightness: 80 }\n\n// REFACTORED 4: Function with object parameter\nfunction displayProduct({ name, price, inStock = true }) {\n  console.log(`${name}: $${price}${inStock ? ' (In Stock)' : ' (Out of Stock)'}`);\n}\ndisplayProduct({ name: 'Laptop', price: 999 });\n// Laptop: $999 (In Stock)\n\n// REFACTORED 5: Swap two variables\nlet x = 100;\nlet y = 200;\n[x, y] = [y, x];\nconsole.log('After swap: x =', x, ', y =', y);\n// After swap: x = 200, y = 100",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "User properties extracted correctly",
                  "expectedOutput": "Bob",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Array destructuring with rest works",
                  "expectedOutput": "10",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Objects merged correctly",
                  "expectedOutput": "75",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Swap works correctly",
                  "expectedOutput": "200",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For object destructuring with rename: let { oldName: newName } = obj;"
                },
                {
                  "level": 2,
                  "text": "For array rest: let [first, ...rest] = array;"
                },
                {
                  "level": 3,
                  "text": "For function parameter defaults: function fn({ prop = defaultValue }) {}"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to rename destructured properties",
                  "consequence": "Variable name conflicts with existing code",
                  "correction": "Use { name: userName } syntax when needed"
                },
                {
                  "mistake": "Missing default value in function parameter",
                  "consequence": "TypeError when property is undefined",
                  "correction": "Use { prop = default } in the parameter destructuring"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.8",
          "title": "Safe Property Access (Optional Chaining and Nullish Coalescing)",
          "moduleId": "module-05",
          "order": 8,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're looking for a friend's phone number in an address book. The book has sections for each person, and each person might have contact info. But what if:\n\n- The person doesn't exist in the book?\n- The person exists but has no contact section?\n- The contact section exists but has no phone number?\n\nIn the old days, you'd have to check each step: 'Does the person exist? If yes, do they have contacts? If yes, is there a phone number?' This is tedious and error-prone.\n\n**Optional Chaining (?.)** is like saying 'give me the phone number if it exists at any level, otherwise just give me undefined - don't crash!'\n\n**Nullish Coalescing (??)** is like saying 'use this value, BUT if it's null or undefined, use this backup instead.' It's smarter than || because it respects valid falsy values like 0 or empty string."
            },
            {
              "type": "EXAMPLE",
              "title": "Optional Chaining (?.) Examples",
              "content": "Optional chaining (?.) lets you safely access nested properties without checking each level for null or undefined. If any part of the chain is null or undefined, it returns undefined instead of throwing an error.",
              "code": "// The problem: accessing nested properties that might not exist\nlet user = {\n  name: 'Alice',\n  address: {\n    city: 'New York'\n  }\n};\n\n// Old way - tedious and error-prone\nlet city;\nif (user && user.address && user.address.city) {\n  city = user.address.city;\n}\nconsole.log(city);  // 'New York'\n\n// With Optional Chaining - clean and safe!\nlet city2 = user?.address?.city;\nconsole.log(city2);  // 'New York'\n\n// When property doesn't exist\nlet user2 = { name: 'Bob' };  // No address!\nlet city3 = user2?.address?.city;\nconsole.log(city3);  // undefined (no error!)\n\n// Without ?. this would crash:\n// let city4 = user2.address.city;  // ERROR: Cannot read 'city' of undefined\n\n// Works with methods too!\nlet calculator = {\n  add: (a, b) => a + b\n};\nconsole.log(calculator.add?.(2, 3));       // 5\nconsole.log(calculator.subtract?.(5, 2));  // undefined (method doesn't exist)\n\n// Works with arrays!\nlet users = [{ name: 'Alice' }, { name: 'Bob' }];\nconsole.log(users?.[0]?.name);  // 'Alice'\nconsole.log(users?.[5]?.name);  // undefined (index 5 doesn't exist)\n\nlet noUsers = null;\nconsole.log(noUsers?.[0]?.name);  // undefined (noUsers is null)",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "Nullish Coalescing (??) Examples",
              "content": "Nullish coalescing (??) provides a default value only when the left side is null or undefined. Unlike the || operator, it preserves valid falsy values like 0, empty string, or false.",
              "code": "// The problem with || for default values\nlet count = 0;\nlet displayCount = count || 'No count';  // 'No count' - WRONG!\n// We wanted 0, but || treats 0 as falsy\n\nlet username = '';\nlet displayName = username || 'Anonymous';  // 'Anonymous' - maybe WRONG!\n// What if empty string was intentional?\n\n// Nullish Coalescing only checks for null/undefined\nlet count2 = 0;\nlet displayCount2 = count2 ?? 'No count';  // 0 - CORRECT!\nconsole.log(displayCount2);  // 0\n\nlet username2 = '';\nlet displayName2 = username2 ?? 'Anonymous';  // '' - keeps empty string\nconsole.log(displayName2);  // ''\n\n// Only null and undefined trigger the default\nconsole.log(null ?? 'default');       // 'default'\nconsole.log(undefined ?? 'default');  // 'default'\nconsole.log(0 ?? 'default');          // 0\nconsole.log('' ?? 'default');         // ''\nconsole.log(false ?? 'default');      // false\n\n// Practical example: API response handling\nlet apiResponse = {\n  user: {\n    settings: {\n      theme: 'dark',\n      fontSize: 0,  // Valid setting!\n      notifications: null  // Not set\n    }\n  }\n};\n\nlet theme = apiResponse?.user?.settings?.theme ?? 'light';\nconsole.log(theme);  // 'dark'\n\nlet fontSize = apiResponse?.user?.settings?.fontSize ?? 16;\nconsole.log(fontSize);  // 0 (not 16! because 0 is a valid value)\n\nlet notifications = apiResponse?.user?.settings?.notifications ?? true;\nconsole.log(notifications);  // true (null triggers default)",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "**Optional Chaining (?.)**\n\nThree forms of optional chaining:\n\n1. **Property access**: obj?.property\n   - Returns undefined if obj is null/undefined\n   - Otherwise returns obj.property\n\n2. **Method calls**: obj.method?.(args)\n   - Returns undefined if method doesn't exist\n   - Otherwise calls the method\n\n3. **Array access**: arr?.[index]\n   - Returns undefined if arr is null/undefined\n   - Otherwise returns arr[index]\n\n**How it works:**\n```\nuser?.address?.city\n```\nis equivalent to:\n```\nuser != null ? (user.address != null ? user.address.city : undefined) : undefined\n```\n\n**Nullish Coalescing (??)**\n\nSyntax: `leftValue ?? rightValue`\n\n- Returns rightValue only if leftValue is null or undefined\n- Otherwise returns leftValue (even if it's 0, '', or false)\n\n**Comparison with ||:**\n\n| Expression | || result | ?? result |\n|------------|-----------|----------|\n| 0 \\|\\| 'default' | 'default' | - |\n| 0 ?? 'default' | - | 0 |\n| '' \\|\\| 'default' | 'default' | - |\n| '' ?? 'default' | - | '' |\n| null \\|\\| 'default' | 'default' | - |\n| null ?? 'default' | - | 'default' |\n| undefined \\|\\| 'default' | 'default' | - |\n| undefined ?? 'default' | - | 'default' |\n\n**Combining both:**\n```javascript\nconst value = obj?.deeply?.nested?.value ?? 'default';\n```\nThis safely navigates the object and provides a default if the value is null/undefined."
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. **Using ?. when not needed:**\n   ```javascript\n   let name = user?.name;  // If you KNOW user exists, just use user.name\n   ```\n   Only use ?. when the value might be null/undefined.\n\n2. **Confusing ?? with ||:**\n   ```javascript\n   let port = config.port || 3000;  // WRONG if port could be 0\n   let port = config.port ?? 3000;  // CORRECT\n   ```\n\n3. **Optional chaining doesn't help with undefined properties:**\n   ```javascript\n   let user = { name: undefined };\n   console.log(user?.name);  // undefined (as expected)\n   // ?. checks if user exists, not if user.name has a value\n   ```\n\n4. **Cannot use ?. for assignment:**\n   ```javascript\n   user?.address = 'NYC';  // SYNTAX ERROR!\n   // Optional chaining is for reading, not writing\n   ```\n\n5. **Mixing ?? with || or && without parentheses:**\n   ```javascript\n   let a = null || undefined ?? 'default';  // SYNTAX ERROR!\n   let a = (null || undefined) ?? 'default';  // OK: 'default'\n   ```\n   JavaScript requires parentheses when mixing ?? with || or &&.\n\n6. **Overusing optional chaining (code smell):**\n   ```javascript\n   data?.users?.[0]?.profile?.settings?.theme?.color?.hex\n   // If you need this many ?., your data structure might need rethinking\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.8-challenge-1",
              "title": "Practice Challenge: Safe Data Access",
              "description": "You're building a user profile display. The API sometimes returns incomplete data. Use optional chaining and nullish coalescing to safely access properties and provide defaults.\n\n1. Get the user's city (default: 'Unknown')\n2. Get the user's email (default: 'No email provided')\n3. Get the user's age (default: 'Age not specified') - careful with 0!\n4. Get the first hobby (default: 'No hobbies listed')",
              "instructions": "Use optional chaining (?.) and nullish coalescing (??) to safely extract data with defaults.",
              "starterCode": "// This API data might have missing fields\nlet userData = {\n  name: 'Alice',\n  age: 0,  // Just born!\n  address: {\n    street: '123 Main St'\n    // Note: no city!\n  },\n  // Note: no email!\n  hobbies: ['reading', 'coding']\n};\n\n// Extract data safely with defaults\nlet city = // YOUR CODE HERE\nlet email = // YOUR CODE HERE  \nlet age = // YOUR CODE HERE\nlet firstHobby = // YOUR CODE HERE\n\nconsole.log('City:', city);\nconsole.log('Email:', email);\nconsole.log('Age:', age);\nconsole.log('First hobby:', firstHobby);",
              "solution": "let userData = {\n  name: 'Alice',\n  age: 0,\n  address: {\n    street: '123 Main St'\n  },\n  hobbies: ['reading', 'coding']\n};\n\nlet city = userData?.address?.city ?? 'Unknown';\nlet email = userData?.email ?? 'No email provided';\nlet age = userData?.age ?? 'Age not specified';\nlet firstHobby = userData?.hobbies?.[0] ?? 'No hobbies listed';\n\nconsole.log('City:', city);  // 'Unknown'\nconsole.log('Email:', email);  // 'No email provided'\nconsole.log('Age:', age);  // 0 (not 'Age not specified'!)\nconsole.log('First hobby:', firstHobby);  // 'reading'",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "City defaults to 'Unknown'",
                  "expectedOutput": "Unknown",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Age preserves 0 (doesn't use default)",
                  "expectedOutput": "0",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For city: userData?.address?.city ?? 'Unknown'"
                },
                {
                  "level": 2,
                  "text": "Remember: ?? only triggers on null/undefined, so age of 0 won't trigger the default!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using || instead of ?? for age",
                  "consequence": "Age of 0 would be replaced with the default string",
                  "correction": "Use ?? to preserve falsy values like 0: userData?.age ?? 'default'"
                },
                {
                  "mistake": "Not using ?. before array access",
                  "consequence": "Would crash if hobbies array is null/undefined",
                  "correction": "Use userData?.hobbies?.[0] to safely access array elements"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "5.8-challenge-2",
              "title": "Practice Challenge: Safe Method Calls",
              "description": "You have an object that may or may not have certain methods. Use optional chaining to safely call methods that might not exist.",
              "instructions": "Safely call methods using optional chaining for method calls.",
              "starterCode": "let calculator = {\n  add: (a, b) => a + b,\n  multiply: (a, b) => a * b\n  // Note: no subtract or divide methods!\n};\n\n// Safely call methods (return undefined if method doesn't exist)\nlet sum = // call add(5, 3)\nlet product = // call multiply(4, 2)\nlet difference = // call subtract(10, 4) - doesn't exist!\nlet quotient = // call divide(20, 5) - doesn't exist!\n\nconsole.log('Sum:', sum);\nconsole.log('Product:', product);\nconsole.log('Difference:', difference ?? 'Method not available');\nconsole.log('Quotient:', quotient ?? 'Method not available');",
              "solution": "let calculator = {\n  add: (a, b) => a + b,\n  multiply: (a, b) => a * b\n};\n\nlet sum = calculator.add?.(5, 3);\nlet product = calculator.multiply?.(4, 2);\nlet difference = calculator.subtract?.(10, 4);\nlet quotient = calculator.divide?.(20, 5);\n\nconsole.log('Sum:', sum);  // 8\nconsole.log('Product:', product);  // 8\nconsole.log('Difference:', difference ?? 'Method not available');  // 'Method not available'\nconsole.log('Quotient:', quotient ?? 'Method not available');  // 'Method not available'",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Existing methods work correctly",
                  "expectedOutput": "8",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Missing methods return undefined",
                  "expectedOutput": "Method not available",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use method?.() syntax to safely call methods"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Putting ?. before the parentheses wrong",
                  "consequence": "Syntax error",
                  "correction": "Use calculator.method?.(args) not calculator.method.?(args)"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.9",
          "title": "Modern Array Methods (ES2023-2025)",
          "moduleId": "module-05",
          "order": 9,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Remember how we learned about array methods like sort(), reverse(), and splice()? They all had one annoying problem: they MODIFY the original array. It's like editing a photo and accidentally saving over the original - you can't get it back!\n\nES2023-2025 introduced new 'non-mutating' versions of these methods. They're like making a copy before editing:\n\n- **toSorted()** - like sort(), but returns a NEW sorted array\n- **toReversed()** - like reverse(), but returns a NEW reversed array\n- **toSpliced()** - like splice(), but returns a NEW modified array\n- **with()** - like arr[i] = x, but returns a NEW array\n- **at()** - access elements with negative indices (like Python!)\n- **Object.groupBy()** - group array items by a key (super useful!)\n- **Map.groupBy()** - like Object.groupBy but with any key type\n\nThese methods are safer because they never change your original data. This is especially important in modern frameworks like React where you should never mutate state directly."
            },
            {
              "type": "EXAMPLE",
              "title": "The at() Method - Negative Indexing",
              "content": "The at() method lets you access array elements using negative indices. Negative indices count backward from the end, so at(-1) returns the last element - no more awkward array[array.length - 1] syntax!",
              "code": "// The old way to get the last element\nlet fruits = ['apple', 'banana', 'cherry', 'date'];\nlet last = fruits[fruits.length - 1];\nconsole.log(last);  // 'date'\n\n// With at() - so much cleaner!\nlet lastFruit = fruits.at(-1);\nconsole.log(lastFruit);  // 'date'\n\n// Negative indices count from the end\nconsole.log(fruits.at(0));   // 'apple' (first)\nconsole.log(fruits.at(1));   // 'banana' (second)\nconsole.log(fruits.at(-1));  // 'date' (last)\nconsole.log(fruits.at(-2));  // 'cherry' (second to last)\nconsole.log(fruits.at(-3));  // 'banana' (third to last)\n\n// Works with strings too!\nlet word = 'JavaScript';\nconsole.log(word.at(0));   // 'J'\nconsole.log(word.at(-1));  // 't'\nconsole.log(word.at(-2));  // 'p'\n\n// Practical: get the last item of a function result\nfunction getScores() {\n  return [85, 92, 78, 95, 88];\n}\nlet topScore = getScores().at(-1);\nconsole.log(topScore);  // 88\n\n// Compare: old way required intermediate variable or ugly syntax\nlet scores = getScores();\nlet oldWay = scores[scores.length - 1];  // More verbose",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "Non-Mutating Sort and Reverse",
              "content": "The toSorted() and toReversed() methods work like sort() and reverse(), but return NEW arrays instead of modifying the original. This is safer and essential for frameworks like React that require immutable state updates.",
              "code": "// THE PROBLEM: sort() and reverse() mutate the original array!\nlet numbers = [3, 1, 4, 1, 5, 9, 2, 6];\nlet sorted = numbers.sort((a, b) => a - b);\nconsole.log(sorted);   // [1, 1, 2, 3, 4, 5, 6, 9]\nconsole.log(numbers);  // [1, 1, 2, 3, 4, 5, 6, 9] - ORIGINAL CHANGED!\n\n// THE SOLUTION: toSorted() returns a NEW array\nlet numbers2 = [3, 1, 4, 1, 5, 9, 2, 6];\nlet sorted2 = numbers2.toSorted((a, b) => a - b);\nconsole.log(sorted2);   // [1, 1, 2, 3, 4, 5, 6, 9]\nconsole.log(numbers2);  // [3, 1, 4, 1, 5, 9, 2, 6] - ORIGINAL PRESERVED!\n\n// Same with reverse!\nlet letters = ['a', 'b', 'c', 'd'];\n\n// OLD: reverse() mutates\nlet reversed1 = letters.reverse();\nconsole.log(letters);  // ['d', 'c', 'b', 'a'] - original changed!\n\n// Reset and try toReversed()\nletters = ['a', 'b', 'c', 'd'];\nlet reversed2 = letters.toReversed();\nconsole.log(reversed2);  // ['d', 'c', 'b', 'a']\nconsole.log(letters);    // ['a', 'b', 'c', 'd'] - original preserved!\n\n// Practical: showing sorted data without affecting original\nlet products = [\n  { name: 'Laptop', price: 1000 },\n  { name: 'Mouse', price: 25 },\n  { name: 'Keyboard', price: 75 }\n];\n\n// Sort by price for display\nlet byPrice = products.toSorted((a, b) => a.price - b.price);\nconsole.log('Sorted by price:', byPrice.map(p => p.name));  // Mouse, Keyboard, Laptop\nconsole.log('Original order:', products.map(p => p.name));  // Laptop, Mouse, Keyboard",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "Non-Mutating Splice with toSpliced()",
              "content": "The toSpliced() method works like splice() for removing and adding elements, but returns a NEW array instead of modifying the original. Perfect for immutable updates when managing lists.",
              "code": "// splice() reminder: removes/adds elements AND mutates the array\nlet colors = ['red', 'green', 'blue', 'yellow'];\nlet removed = colors.splice(1, 2, 'purple');  // Remove 2 items at index 1, add 'purple'\nconsole.log(removed);  // ['green', 'blue'] (what was removed)\nconsole.log(colors);   // ['red', 'purple', 'yellow'] - MUTATED!\n\n// toSpliced() does the same but returns a NEW array\nlet colors2 = ['red', 'green', 'blue', 'yellow'];\nlet newColors = colors2.toSpliced(1, 2, 'purple');\nconsole.log(newColors);  // ['red', 'purple', 'yellow']\nconsole.log(colors2);    // ['red', 'green', 'blue', 'yellow'] - PRESERVED!\n\n// More examples:\nlet nums = [1, 2, 3, 4, 5];\n\n// Remove 2 items starting at index 1\nconsole.log(nums.toSpliced(1, 2));  // [1, 4, 5]\n\n// Remove 1 item at index 2, insert 'a', 'b'\nconsole.log(nums.toSpliced(2, 1, 'a', 'b'));  // [1, 2, 'a', 'b', 4, 5]\n\n// Insert without removing (delete count = 0)\nconsole.log(nums.toSpliced(2, 0, 'inserted'));  // [1, 2, 'inserted', 3, 4, 5]\n\n// Original is always unchanged\nconsole.log(nums);  // [1, 2, 3, 4, 5]\n\n// Practical: removing an item by index (common in React!)\nlet todoList = ['Buy milk', 'Clean room', 'Do homework', 'Exercise'];\nlet indexToRemove = 1;  // Remove 'Clean room'\n\n// Create new list without that item\nlet updatedList = todoList.toSpliced(indexToRemove, 1);\nconsole.log(updatedList);  // ['Buy milk', 'Do homework', 'Exercise']\nconsole.log(todoList);     // Original unchanged!",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "Object.groupBy() - Grouping Array Items",
              "content": "Object.groupBy() is a powerful new method that groups array items by a key you define. It returns an object where each key is a group name and each value is an array of items belonging to that group.",
              "code": "// Object.groupBy() groups array items by a key you define\n// This is SUPER useful for organizing data!\n\nlet products = [\n  { name: 'Apple', category: 'Fruit', price: 1.50 },\n  { name: 'Banana', category: 'Fruit', price: 0.75 },\n  { name: 'Carrot', category: 'Vegetable', price: 0.50 },\n  { name: 'Broccoli', category: 'Vegetable', price: 1.25 },\n  { name: 'Milk', category: 'Dairy', price: 3.00 }\n];\n\n// Group by category\nlet byCategory = Object.groupBy(products, product => product.category);\n\nconsole.log(byCategory);\n// {\n//   Fruit: [{name: 'Apple', ...}, {name: 'Banana', ...}],\n//   Vegetable: [{name: 'Carrot', ...}, {name: 'Broccoli', ...}],\n//   Dairy: [{name: 'Milk', ...}]\n// }\n\n// Access a specific group\nconsole.log(byCategory.Fruit);  // All fruit products\nconsole.log(byCategory.Vegetable.length);  // 2 vegetables\n\n// Group numbers by even/odd\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nlet byEvenOdd = Object.groupBy(numbers, n => n % 2 === 0 ? 'even' : 'odd');\nconsole.log(byEvenOdd);\n// { odd: [1, 3, 5, 7, 9], even: [2, 4, 6, 8, 10] }\n\n// Group students by grade\nlet students = [\n  { name: 'Alice', score: 95 },\n  { name: 'Bob', score: 82 },\n  { name: 'Charlie', score: 78 },\n  { name: 'Diana', score: 91 },\n  { name: 'Eve', score: 65 }\n];\n\nlet byGrade = Object.groupBy(students, student => {\n  if (student.score >= 90) return 'A';\n  if (student.score >= 80) return 'B';\n  if (student.score >= 70) return 'C';\n  return 'D';\n});\n\nconsole.log(byGrade);\n// {\n//   A: [Alice, Diana],\n//   B: [Bob],\n//   C: [Charlie],\n//   D: [Eve]\n// }\nconsole.log('A students:', byGrade.A.map(s => s.name));  // ['Alice', 'Diana']",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "Array.with() - Immutable Element Replacement",
              "content": "Array.with() replaces an element at a specific index and returns a NEW array, leaving the original unchanged. It's the immutable alternative to arr[index] = value assignment.",
              "code": "// Array.with() replaces an element at an index and returns a NEW array\n// Like bracket assignment, but without mutating the original!\n\nlet colors = ['red', 'green', 'blue', 'yellow'];\n\n// OLD WAY: Mutates the original array!\ncolors[1] = 'purple';\nconsole.log(colors);  // ['red', 'purple', 'blue', 'yellow'] - Changed!\n\n// Reset\ncolors = ['red', 'green', 'blue', 'yellow'];\n\n// NEW WAY with .with() - Original preserved!\nlet newColors = colors.with(1, 'purple');\nconsole.log(newColors);  // ['red', 'purple', 'blue', 'yellow']\nconsole.log(colors);     // ['red', 'green', 'blue', 'yellow'] - Unchanged!\n\n// Works with negative indices too (like at())\nlet fruits = ['apple', 'banana', 'cherry'];\nlet updated = fruits.with(-1, 'cranberry');  // Replace last element\nconsole.log(updated);  // ['apple', 'banana', 'cranberry']\nconsole.log(fruits);   // ['apple', 'banana', 'cherry'] - Original safe!\n\n// Chain with other immutable methods\nlet numbers = [5, 2, 8, 1, 9];\nlet result = numbers\n  .with(0, 100)           // Replace first with 100\n  .toSorted((a, b) => a - b)  // Sort ascending\n  .toReversed();          // Reverse\nconsole.log(result);   // [100, 9, 8, 2, 1]\nconsole.log(numbers);  // [5, 2, 8, 1, 9] - Original untouched!\n\n// Practical: Update item in React state\n// React requires immutable updates - .with() is perfect!\nlet todos = [\n  { id: 1, text: 'Buy milk', done: false },\n  { id: 2, text: 'Clean room', done: false },\n  { id: 3, text: 'Exercise', done: false }\n];\n\n// Mark second todo as complete (immutably)\nlet indexToUpdate = 1;\nlet updatedTodos = todos.with(indexToUpdate, {\n  ...todos[indexToUpdate],\n  done: true\n});\nconsole.log(updatedTodos[1].done);  // true\nconsole.log(todos[1].done);         // false - Original unchanged!",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "Map.groupBy() - Grouping with Complex Keys",
              "content": "Map.groupBy() works like Object.groupBy() but returns a Map instead of an object. Use it when you need non-string keys (booleans, objects, numbers) since Map preserves key types while objects convert everything to strings.",
              "code": "// Map.groupBy() is like Object.groupBy() but returns a Map\n// Why use Map? Keys can be ANY type (not just strings)!\n\nlet products = [\n  { name: 'Apple', category: 'Fruit', inStock: true },\n  { name: 'Banana', category: 'Fruit', inStock: false },\n  { name: 'Carrot', category: 'Vegetable', inStock: true },\n  { name: 'Milk', category: 'Dairy', inStock: true }\n];\n\n// Object.groupBy - Keys become strings\nlet objGrouped = Object.groupBy(products, p => p.inStock);\nconsole.log(objGrouped['true']);   // Works (string key)\nconsole.log(objGrouped[true]);     // undefined! Boolean converted to string\n\n// Map.groupBy - Keys keep their original type\nlet mapGrouped = Map.groupBy(products, p => p.inStock);\nconsole.log(mapGrouped.get(true));   // Products that are in stock\nconsole.log(mapGrouped.get(false));  // Products that are out of stock\n\n// Group by object reference (impossible with Object.groupBy!)\nlet categoryA = { name: 'Fruits' };\nlet categoryB = { name: 'Vegetables' };\n\nlet items = [\n  { product: 'Apple', cat: categoryA },\n  { product: 'Banana', cat: categoryA },\n  { product: 'Carrot', cat: categoryB }\n];\n\nlet byCategory = Map.groupBy(items, item => item.cat);\nconsole.log(byCategory.get(categoryA));  // Apple and Banana\nconsole.log(byCategory.get(categoryB));  // Carrot\n\n// Practical: Group DOM elements by their tag\n// (In browser) const elements = document.querySelectorAll('*');\n// const byTag = Map.groupBy([...elements], el => el.tagName);\n// console.log(byTag.get('DIV'));  // All div elements\n\n// Iterate over Map groups\nfor (let [key, items] of mapGrouped) {\n  console.log(`In stock: ${key}`, items.map(p => p.name));\n}\n// In stock: true ['Apple', 'Carrot', 'Milk']\n// In stock: false ['Banana']\n\n// Convert Map to Object if needed\nlet asObject = Object.fromEntries(mapGrouped);\nconsole.log(asObject);  // { true: [...], false: [...] }",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "**at(index)**\n- Access elements with positive or negative indices\n- Negative indices count from the end (-1 = last, -2 = second to last)\n- Returns undefined if index is out of bounds\n```javascript\narray.at(0)   // First element\narray.at(-1)  // Last element\narray.at(-2)  // Second to last\n```\n\n**toSorted(compareFn)**\n- Returns a NEW sorted array\n- Original array is unchanged\n- Same comparison function as sort()\n```javascript\nconst sorted = array.toSorted((a, b) => a - b);  // Ascending numbers\nconst sorted = array.toSorted((a, b) => b - a);  // Descending numbers\nconst sorted = array.toSorted();  // Default string sort\n```\n\n**toReversed()**\n- Returns a NEW reversed array\n- Original array is unchanged\n- No arguments needed\n```javascript\nconst reversed = array.toReversed();\n```\n\n**toSpliced(start, deleteCount, ...items)**\n- Returns a NEW array with elements removed/added\n- Original array is unchanged\n- Same parameters as splice()\n```javascript\narray.toSpliced(1, 2)        // Remove 2 elements at index 1\narray.toSpliced(1, 0, 'a')   // Insert 'a' at index 1\narray.toSpliced(1, 1, 'a')   // Replace element at index 1 with 'a'\n```\n\n**with(index, value)**\n- Returns a NEW array with element at index replaced\n- Supports negative indices (like at())\n- Original array is unchanged\n```javascript\narray.with(0, 'new')   // Replace first element\narray.with(-1, 'new')  // Replace last element\narray.with(2, 'new')   // Replace element at index 2\n```\n\n**Object.groupBy(array, keyFn)**\n- Groups array items into an object\n- keyFn returns the group key for each item\n- Returns an object where keys are group names, values are arrays\n```javascript\nObject.groupBy(items, item => item.category);\nObject.groupBy(numbers, n => n % 2 === 0 ? 'even' : 'odd');\n```\n\n**Map.groupBy(array, keyFn)**\n- Like Object.groupBy but returns a Map\n- Keys can be ANY type (not just strings)\n- Better for non-string keys like booleans, objects, or numbers\n```javascript\nMap.groupBy(items, item => item.inStock);  // Boolean keys work!\nMap.groupBy(items, item => item.category); // Object keys work!\n```\n\n**Why use non-mutating methods?**\n1. Safer - original data is preserved\n2. Predictable - easier to debug\n3. Functional programming style\n4. Required for React/Vue state management\n5. Enables method chaining without side effects"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. **Confusing at() with negative indexing on brackets:**\n   ```javascript\n   array[-1]    // undefined - doesn't work!\n   array.at(-1) // Last element - works!\n   ```\n\n2. **Forgetting toSorted/toReversed/with return new arrays:**\n   ```javascript\n   let nums = [3, 1, 2];\n   nums.toSorted();  // Returns [1, 2, 3] but you didn't save it!\n   nums.with(0, 99); // Returns [99, 1, 2] but you didn't save it!\n   console.log(nums);  // Still [3, 1, 2]\n   \n   // Correct:\n   let sorted = nums.toSorted();\n   let updated = nums.with(0, 99);\n   ```\n\n3. **Using toSorted() without comparison for numbers:**\n   ```javascript\n   [10, 2, 1].toSorted()  // [1, 10, 2] - sorted as strings!\n   [10, 2, 1].toSorted((a, b) => a - b)  // [1, 2, 10] - correct!\n   ```\n\n4. **Object.groupBy returns null prototype object:**\n   ```javascript\n   let grouped = Object.groupBy(items, fn);\n   // grouped doesn't have standard Object methods like hasOwnProperty\n   // Use Object.keys(grouped) or 'key' in grouped instead\n   ```\n\n5. **Using Object.groupBy when you need non-string keys:**\n   ```javascript\n   // Object.groupBy converts keys to strings\n   Object.groupBy(items, x => x.active);  // Keys: 'true', 'false' (strings)\n   \n   // Map.groupBy preserves key types\n   Map.groupBy(items, x => x.active);     // Keys: true, false (booleans)\n   ```\n\n6. **Browser compatibility:**\n   - at(): Supported in all modern browsers (2022+)\n   - toSorted/toReversed/toSpliced/with: ES2023 (mid-2023+)\n   - Object.groupBy/Map.groupBy: ES2024 (late 2023+)\n   - Check compatibility if supporting older browsers!\n\n7. **Mixing up splice and toSpliced return values:**\n   ```javascript\n   // splice returns REMOVED elements\n   // toSpliced returns the NEW array\n   let arr = [1, 2, 3];\n   arr.splice(1, 1);      // Returns [2] (removed)\n   arr.toSpliced(1, 1);   // Returns [1, 3] (new array)\n   ```\n\n8. **with() throws RangeError for invalid index:**\n   ```javascript\n   let arr = [1, 2, 3];\n   arr.with(10, 'x');  // RangeError! Index out of bounds\n   arr.with(-10, 'x'); // RangeError! Index out of bounds\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.9-challenge-1",
              "title": "Practice Challenge: Safe Array Operations",
              "description": "You're building a leaderboard. Use modern array methods to sort and display scores WITHOUT modifying the original data.\n\n1. Display the top 3 scores (highest first) using toSorted()\n2. Get the last place score using at()\n3. Remove the player at index 2 using toSpliced() and show the new list",
              "instructions": "Use toSorted(), at(), and toSpliced() to work with the data safely.",
              "starterCode": "let players = [\n  { name: 'Alice', score: 850 },\n  { name: 'Bob', score: 920 },\n  { name: 'Charlie', score: 780 },\n  { name: 'Diana', score: 1050 },\n  { name: 'Eve', score: 890 }\n];\n\n// 1. Get top 3 players (sorted by score, highest first)\nlet top3 = // YOUR CODE HERE\nconsole.log('Top 3:', top3.map(p => p.name));\n\n// 2. Get the last place player using at()\nlet lastPlace = // YOUR CODE HERE\nconsole.log('Last place:', lastPlace.name);\n\n// 3. Remove player at index 2 (Charlie) using toSpliced()\nlet withoutCharlie = // YOUR CODE HERE\nconsole.log('Without Charlie:', withoutCharlie.map(p => p.name));\n\n// Verify original is unchanged\nconsole.log('Original:', players.map(p => p.name));",
              "solution": "let players = [\n  { name: 'Alice', score: 850 },\n  { name: 'Bob', score: 920 },\n  { name: 'Charlie', score: 780 },\n  { name: 'Diana', score: 1050 },\n  { name: 'Eve', score: 890 }\n];\n\n// 1. Get top 3 players (sorted by score, highest first)\nlet top3 = players.toSorted((a, b) => b.score - a.score).slice(0, 3);\nconsole.log('Top 3:', top3.map(p => p.name));  // Diana, Bob, Eve\n\n// 2. Get the last place player using at()\nlet sorted = players.toSorted((a, b) => b.score - a.score);\nlet lastPlace = sorted.at(-1);\nconsole.log('Last place:', lastPlace.name);  // Charlie\n\n// 3. Remove player at index 2 (Charlie) using toSpliced()\nlet withoutCharlie = players.toSpliced(2, 1);\nconsole.log('Without Charlie:', withoutCharlie.map(p => p.name));\n\n// Verify original is unchanged\nconsole.log('Original:', players.map(p => p.name));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Top 3 are correctly sorted",
                  "expectedOutput": "Diana",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Original array is unchanged",
                  "expectedOutput": "Alice",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For descending sort: toSorted((a, b) => b.score - a.score)"
                },
                {
                  "level": 2,
                  "text": "Chain .slice(0, 3) after toSorted() to get top 3"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using sort() instead of toSorted()",
                  "consequence": "Original array gets mutated",
                  "correction": "Always use toSorted() when you need to preserve the original"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "5.9-challenge-2",
              "title": "Practice Challenge: Grouping Data",
              "description": "You have a list of orders. Use Object.groupBy() to organize them by status, then calculate the total value for each status group.",
              "instructions": "Group orders by status and calculate totals for each group.",
              "starterCode": "let orders = [\n  { id: 1, product: 'Laptop', price: 1000, status: 'completed' },\n  { id: 2, product: 'Mouse', price: 25, status: 'pending' },\n  { id: 3, product: 'Keyboard', price: 75, status: 'completed' },\n  { id: 4, product: 'Monitor', price: 300, status: 'cancelled' },\n  { id: 5, product: 'Headphones', price: 150, status: 'pending' },\n  { id: 6, product: 'Webcam', price: 80, status: 'completed' }\n];\n\n// 1. Group orders by status\nlet byStatus = // YOUR CODE HERE\n\nconsole.log('Completed orders:', byStatus.completed?.length ?? 0);\nconsole.log('Pending orders:', byStatus.pending?.length ?? 0);\nconsole.log('Cancelled orders:', byStatus.cancelled?.length ?? 0);\n\n// 2. Calculate total value of completed orders\nlet completedTotal = // YOUR CODE HERE\nconsole.log('Completed orders total: $' + completedTotal);",
              "solution": "let orders = [\n  { id: 1, product: 'Laptop', price: 1000, status: 'completed' },\n  { id: 2, product: 'Mouse', price: 25, status: 'pending' },\n  { id: 3, product: 'Keyboard', price: 75, status: 'completed' },\n  { id: 4, product: 'Monitor', price: 300, status: 'cancelled' },\n  { id: 5, product: 'Headphones', price: 150, status: 'pending' },\n  { id: 6, product: 'Webcam', price: 80, status: 'completed' }\n];\n\n// 1. Group orders by status\nlet byStatus = Object.groupBy(orders, order => order.status);\n\nconsole.log('Completed orders:', byStatus.completed?.length ?? 0);  // 3\nconsole.log('Pending orders:', byStatus.pending?.length ?? 0);  // 2\nconsole.log('Cancelled orders:', byStatus.cancelled?.length ?? 0);  // 1\n\n// 2. Calculate total value of completed orders\nlet completedTotal = byStatus.completed?.reduce((sum, order) => sum + order.price, 0) ?? 0;\nconsole.log('Completed orders total: $' + completedTotal);  // $1155",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Groups orders correctly",
                  "expectedOutput": "3",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Calculates total correctly",
                  "expectedOutput": "1155",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Object.groupBy(orders, order => order.status)"
                },
                {
                  "level": 2,
                  "text": "Use reduce() on byStatus.completed to sum prices"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not handling potentially undefined groups",
                  "consequence": "Error if a status doesn't exist",
                  "correction": "Use optional chaining: byStatus.completed?.length ?? 0"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.10",
          "title": "Modern Set Methods (ES2025)",
          "moduleId": "module-05",
          "order": 10,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Remember Sets from math class? A Set is a collection where every item is unique - no duplicates allowed!\n\nThink of it like a VIP guest list where each person can only be listed once. If you try to add 'Alice' twice, she's still only on the list once.\n\nES2025 introduces powerful new Set methods that let you combine, compare, and manipulate Sets - just like Venn diagrams!\n\n**New Set Methods:**\n- **union()** - Combine two sets (everyone in EITHER set)\n- **intersection()** - Find common items (everyone in BOTH sets)\n- **difference()** - Find what's unique to one set (in A but NOT in B)\n- **symmetricDifference()** - Find what's unique to either (in A OR B, but not both)\n- **isSubsetOf()** - Check if one set contains all items of another\n- **isSupersetOf()** - Check if set contains all items of another set\n- **isDisjointFrom()** - Check if sets have no common items"
            },
            {
              "type": "EXAMPLE",
              "title": "Creating and Using Sets",
              "content": "A Set is a collection of unique values - duplicates are automatically removed. Create Sets from arrays, add/remove items, and convert back to arrays when needed.",
              "code": "// Creating Sets\nlet fruits = new Set(['apple', 'banana', 'cherry']);\nlet moreFruits = new Set(['cherry', 'date', 'elderberry']);\n\n// Sets automatically remove duplicates\nlet numbers = new Set([1, 2, 2, 3, 3, 3]);\nconsole.log(numbers);  // Set { 1, 2, 3 } - duplicates removed!\n\n// Basic Set operations\nfruits.add('date');        // Add item\nfruits.delete('banana');   // Remove item\nfruits.has('apple');       // true - check if exists\nfruits.size;               // 3 - number of items\n\n// Convert to array\nlet fruitArray = [...fruits];  // ['apple', 'cherry', 'date']\n\n// Loop through a Set\nfor (let fruit of fruits) {\n  console.log(fruit);\n}\n\n// Remove duplicates from array (common pattern)\nlet dupes = [1, 2, 2, 3, 3, 3, 4];\nlet unique = [...new Set(dupes)];\nconsole.log(unique);  // [1, 2, 3, 4]",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "union() - Combining Sets",
              "content": "The union() method combines two Sets into one, returning all unique items from both. It's like creating a guest list for people invited to either party.",
              "code": "// union() returns all unique items from BOTH sets\n// Like 'everyone invited to EITHER party'\n\nlet frontend = new Set(['Alice', 'Bob', 'Charlie']);\nlet backend = new Set(['Charlie', 'Diana', 'Eve']);\n\nlet allDevs = frontend.union(backend);\nconsole.log(allDevs);\n// Set { 'Alice', 'Bob', 'Charlie', 'Diana', 'Eve' }\n// Notice: Charlie appears only once (no duplicates)\n\n// Practical: Combine permission sets\nlet adminPerms = new Set(['read', 'write', 'delete', 'admin']);\nlet userPerms = new Set(['read', 'write']);\n\nlet combinedPerms = adminPerms.union(userPerms);\nconsole.log(combinedPerms);\n// Set { 'read', 'write', 'delete', 'admin' }\n\n// Works with any iterable\nlet setA = new Set([1, 2, 3]);\nlet setB = new Set([3, 4, 5]);\nconsole.log(setA.union(setB));  // Set { 1, 2, 3, 4, 5 }\n\n// OLD WAY (before ES2025):\nlet oldUnion = new Set([...setA, ...setB]);\nconsole.log(oldUnion);  // Same result, but more verbose",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "intersection() - Finding Common Items",
              "content": "The intersection() method returns only the items that exist in BOTH Sets. It's like finding people who were invited to both parties - the overlap in a Venn diagram.",
              "code": "// intersection() returns items that exist in BOTH sets\n// Like 'people invited to BOTH parties'\n\nlet frontend = new Set(['Alice', 'Bob', 'Charlie']);\nlet backend = new Set(['Charlie', 'Diana', 'Eve']);\n\nlet fullStack = frontend.intersection(backend);\nconsole.log(fullStack);  // Set { 'Charlie' }\n// Only Charlie is in both teams!\n\n// Practical: Find common interests\nlet aliceHobbies = new Set(['reading', 'gaming', 'hiking', 'cooking']);\nlet bobHobbies = new Set(['gaming', 'music', 'hiking', 'sports']);\n\nlet commonHobbies = aliceHobbies.intersection(bobHobbies);\nconsole.log(commonHobbies);  // Set { 'gaming', 'hiking' }\n\n// Find users with both permissions\nlet canRead = new Set(['user1', 'user2', 'user3', 'admin']);\nlet canWrite = new Set(['user2', 'admin', 'editor']);\n\nlet canReadAndWrite = canRead.intersection(canWrite);\nconsole.log(canReadAndWrite);  // Set { 'user2', 'admin' }\n\n// OLD WAY (before ES2025):\nlet oldIntersection = new Set(\n  [...aliceHobbies].filter(x => bobHobbies.has(x))\n);\n// New way is much cleaner!",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "difference() - Finding Unique Items",
              "content": "The difference() method returns items that are in the first Set but NOT in the second. The order matters - A.difference(B) gives different results than B.difference(A).",
              "code": "// difference() returns items in the first set but NOT in the second\n// Like 'people only invited to MY party, not yours'\n\nlet myFriends = new Set(['Alice', 'Bob', 'Charlie', 'Diana']);\nlet yourFriends = new Set(['Charlie', 'Diana', 'Eve', 'Frank']);\n\nlet onlyMyFriends = myFriends.difference(yourFriends);\nconsole.log(onlyMyFriends);  // Set { 'Alice', 'Bob' }\n\nlet onlyYourFriends = yourFriends.difference(myFriends);\nconsole.log(onlyYourFriends);  // Set { 'Eve', 'Frank' }\n// Order matters! A.difference(B) !== B.difference(A)\n\n// Practical: Find missing items\nlet required = new Set(['name', 'email', 'password', 'age']);\nlet provided = new Set(['name', 'email']);\n\nlet missing = required.difference(provided);\nconsole.log(missing);  // Set { 'password', 'age' }\nconsole.log('Missing fields:', [...missing].join(', '));\n// 'Missing fields: password, age'\n\n// Find items to remove from cart\nlet cartBefore = new Set(['apple', 'banana', 'cherry', 'date']);\nlet cartAfter = new Set(['apple', 'cherry']);\n\nlet removed = cartBefore.difference(cartAfter);\nconsole.log('Removed:', removed);  // Set { 'banana', 'date' }",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "symmetricDifference() - Items Unique to Either Set",
              "content": "The symmetricDifference() method returns items that are in EITHER Set, but not in BOTH. It's the opposite of intersection - everything except the overlap.",
              "code": "// symmetricDifference() returns items in EITHER set, but not BOTH\n// Like 'people invited to only one party, not both'\n\nlet teamA = new Set(['Alice', 'Bob', 'Charlie']);\nlet teamB = new Set(['Charlie', 'Diana', 'Eve']);\n\nlet exclusiveMembers = teamA.symmetricDifference(teamB);\nconsole.log(exclusiveMembers);\n// Set { 'Alice', 'Bob', 'Diana', 'Eve' }\n// Charlie is in BOTH, so excluded!\n\n// This is the same as union minus intersection\n// (A union B) - (A intersection B) = symmetricDifference\n\n// Practical: Find changes between two versions\nlet version1Features = new Set(['login', 'dashboard', 'profile']);\nlet version2Features = new Set(['login', 'dashboard', 'settings', 'notifications']);\n\nlet changes = version1Features.symmetricDifference(version2Features);\nconsole.log('Changed features:', changes);\n// Set { 'profile', 'settings', 'notifications' }\n// 'profile' was removed, 'settings' and 'notifications' were added\n\n// Find students who didn't attend both days\nlet day1Attendance = new Set(['Alice', 'Bob', 'Charlie']);\nlet day2Attendance = new Set(['Bob', 'Charlie', 'Diana']);\n\nlet inconsistent = day1Attendance.symmetricDifference(day2Attendance);\nconsole.log('Missed a day:', inconsistent);  // Alice and Diana",
              "language": "javascript"
            },
            {
              "type": "EXAMPLE",
              "title": "Subset, Superset, and Disjoint Checks",
              "content": "These methods let you compare Sets: isSubsetOf() checks if all items exist in another Set, isSupersetOf() checks if a Set contains all items of another, and isDisjointFrom() checks if Sets have no common items.",
              "code": "// isSubsetOf() - Check if ALL items exist in another set\nlet basic = new Set(['read']);\nlet standard = new Set(['read', 'write']);\nlet premium = new Set(['read', 'write', 'delete', 'admin']);\n\nconsole.log(basic.isSubsetOf(standard));    // true - 'read' is in standard\nconsole.log(standard.isSubsetOf(premium));  // true - 'read', 'write' in premium\nconsole.log(premium.isSubsetOf(basic));     // false - premium has more items\n\n// isSupersetOf() - Check if set CONTAINS all items of another\nconsole.log(premium.isSupersetOf(standard));  // true\nconsole.log(premium.isSupersetOf(basic));     // true\nconsole.log(basic.isSupersetOf(premium));     // false\n\n// isDisjointFrom() - Check if sets have NO common items\nlet cats = new Set(['whiskers', 'mittens', 'shadow']);\nlet dogs = new Set(['buddy', 'max', 'bella']);\nlet mixed = new Set(['whiskers', 'buddy']);\n\nconsole.log(cats.isDisjointFrom(dogs));   // true - no overlap\nconsole.log(cats.isDisjointFrom(mixed));  // false - 'whiskers' in both\n\n// Practical: Permission validation\nlet requiredPerms = new Set(['read', 'write']);\nlet userPerms = new Set(['read', 'write', 'comment']);\n\nif (requiredPerms.isSubsetOf(userPerms)) {\n  console.log('Access granted!');\n} else {\n  let missing = requiredPerms.difference(userPerms);\n  console.log('Missing permissions:', [...missing]);\n}",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "**Set Basics:**\n```javascript\nnew Set()              // Empty set\nnew Set([1, 2, 3])     // Set from array\nset.add(value)         // Add item (returns set)\nset.delete(value)      // Remove item (returns boolean)\nset.has(value)         // Check existence (returns boolean)\nset.size               // Number of items\nset.clear()            // Remove all items\n[...set]               // Convert to array\n```\n\n**New ES2025 Methods:**\n\n**set.union(otherSet)**\n- Returns new Set with all items from both\n- No duplicates\n- Original sets unchanged\n\n**set.intersection(otherSet)**\n- Returns new Set with items in BOTH sets\n- Only common elements\n\n**set.difference(otherSet)**\n- Returns items in set but NOT in otherSet\n- Order matters! A.difference(B) !== B.difference(A)\n\n**set.symmetricDifference(otherSet)**\n- Returns items in EITHER set but not BOTH\n- Same as (A union B) - (A intersection B)\n\n**set.isSubsetOf(otherSet)**\n- Returns true if ALL items are in otherSet\n- Empty set is subset of everything\n\n**set.isSupersetOf(otherSet)**\n- Returns true if set CONTAINS all items of otherSet\n- Opposite of isSubsetOf\n\n**set.isDisjointFrom(otherSet)**\n- Returns true if sets have NO common items\n- intersection would be empty"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. **Forgetting Sets use reference equality for objects:**\n   ```javascript\n   let set = new Set();\n   set.add({ name: 'Alice' });\n   set.add({ name: 'Alice' });  // Added! Different object reference\n   console.log(set.size);  // 2 - both objects added!\n   ```\n\n2. **difference() order matters:**\n   ```javascript\n   let a = new Set([1, 2, 3]);\n   let b = new Set([2, 3, 4]);\n   a.difference(b);  // Set { 1 } - what's in A but not B\n   b.difference(a);  // Set { 4 } - what's in B but not A\n   // These are different!\n   ```\n\n3. **Runtime requirements (ES2025):**\n   - **Node.js 22+** required for Set methods\n   - **Chrome 122+**, **Firefox 127+**, **Safari 17+** for browser support\n   - Older environments will throw: `TypeError: set.union is not a function`\n   - Consider polyfills (core-js) or transpilation for older environments\n   - Code Tutor uses your local Node.js - update Node if methods don't work\n\n4. **Sets don't have array methods:**\n   ```javascript\n   let set = new Set([1, 2, 3]);\n   set.map(x => x * 2);  // ERROR! Sets don't have map()\n   [...set].map(x => x * 2);  // [2, 4, 6] - convert first!\n   ```\n\n5. **Modifying set while iterating:**\n   ```javascript\n   let set = new Set([1, 2, 3]);\n   for (let item of set) {\n     set.delete(item);  // Works but can be confusing\n   }\n   // Better: collect items to delete, then delete after loop\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.10-challenge",
              "title": "Practice Challenge: Set Operations",
              "description": "You're building a team management system. Use Set methods to:\n\n1. Find developers who work on BOTH frontend AND backend (intersection)\n2. Find developers who ONLY work on frontend (difference)\n3. Combine all developers into one team (union)\n4. Check if the senior team is a subset of all developers",
              "instructions": "Use the new Set methods: union(), intersection(), difference(), and isSubsetOf()",
              "starterCode": "let frontendTeam = new Set(['Alice', 'Bob', 'Charlie', 'Diana']);\nlet backendTeam = new Set(['Charlie', 'Diana', 'Eve', 'Frank']);\nlet seniorDevs = new Set(['Alice', 'Eve']);\n\n// 1. Find full-stack developers (in BOTH teams)\nlet fullStack = // YOUR CODE HERE\nconsole.log('Full-stack:', [...fullStack]);\n\n// 2. Find frontend-only developers (in frontend but NOT backend)\nlet frontendOnly = // YOUR CODE HERE\nconsole.log('Frontend only:', [...frontendOnly]);\n\n// 3. Combine all developers\nlet allDevs = // YOUR CODE HERE\nconsole.log('All developers:', [...allDevs]);\n\n// 4. Check if all seniors are in the combined team\nlet allSeniorsIncluded = // YOUR CODE HERE\nconsole.log('All seniors included:', allSeniorsIncluded);",
              "solution": "let frontendTeam = new Set(['Alice', 'Bob', 'Charlie', 'Diana']);\nlet backendTeam = new Set(['Charlie', 'Diana', 'Eve', 'Frank']);\nlet seniorDevs = new Set(['Alice', 'Eve']);\n\n// 1. Find full-stack developers (in BOTH teams)\nlet fullStack = frontendTeam.intersection(backendTeam);\nconsole.log('Full-stack:', [...fullStack]);  // ['Charlie', 'Diana']\n\n// 2. Find frontend-only developers (in frontend but NOT backend)\nlet frontendOnly = frontendTeam.difference(backendTeam);\nconsole.log('Frontend only:', [...frontendOnly]);  // ['Alice', 'Bob']\n\n// 3. Combine all developers\nlet allDevs = frontendTeam.union(backendTeam);\nconsole.log('All developers:', [...allDevs]);\n// ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve', 'Frank']\n\n// 4. Check if all seniors are in the combined team\nlet allSeniorsIncluded = seniorDevs.isSubsetOf(allDevs);\nconsole.log('All seniors included:', allSeniorsIncluded);  // true",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Full-stack developers found correctly",
                  "expectedOutput": "Charlie",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Seniors are subset of all devs",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "intersection() finds items in BOTH sets"
                },
                {
                  "level": 2,
                  "text": "difference(other) finds items in the set but NOT in other"
                },
                {
                  "level": 3,
                  "text": "isSubsetOf() returns true if all items exist in the other set"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using filter instead of Set methods",
                  "consequence": "More verbose code",
                  "correction": "Use intersection(), difference(), union() for cleaner code"
                },
                {
                  "mistake": "Confusing difference order",
                  "consequence": "Wrong results",
                  "correction": "A.difference(B) gives items in A but not B"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-06",
      "title": "Module 6: Creating Reusable Tools (The 'Recipes')",
      "description": "Write code once and reuse it many times with functions",
      "difficulty": "intermediate",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "6.1",
          "title": "What Is a Function? (The Recipe Analogy)",
          "moduleId": "module-06",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "A recipe is a list of instructions for making a specific dish. Once you write the recipe down, you can use it over and over without rewriting the steps each time.\n\nA function in programming is exactly like a recipe:\n- It has a NAME (e.g., 'Make Pancakes')\n- It has INGREDIENTS (inputs, called 'parameters')\n- It has INSTRUCTIONS (the code inside)\n- It produces a RESULT (output, called a 'return value')\n\nJust like you can call out 'Make Pancakes!' and the recipe executes, in code you can 'call' a function and it executes its instructions. Functions let you avoid repeating the same code - write once, use many times!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Defining a function\nfunction sayHello() {\n  console.log('Hello, World!');\n}\n\n// Calling (using) the function\nsayHello();  // Hello, World!\nsayHello();  // Hello, World!\n// Can call as many times as you want!\n\n// Function with a parameter (ingredient)\nfunction greet(name) {\n  console.log('Hello, ' + name + '!');\n}\n\ngreet('Alice');   // Hello, Alice!\ngreet('Bob');     // Hello, Bob!\ngreet('Charlie'); // Hello, Charlie!\n\n// Function that returns a value\nfunction add(a, b) {\n  return a + b;\n}\n\nlet sum = add(5, 3);\nconsole.log(sum);  // 8\n\nlet result = add(10, 20);\nconsole.log(result);  // 30"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Function anatomy:\n\nfunction functionName(parameter1, parameter2) {\n│        │            │                      │\n│        │            └──────────────────────┴─ Parameters (inputs)\n│        └──────────────────────────────────── Name (you choose)\n└───────────────────────────────────────────── 'function' keyword\n  // Code to run\n  return result;  // Optional: send back a value\n}\n\nKey parts:\n\n1. **function keyword** - Tells JavaScript you're creating a function\n\n2. **Name** - What you call the function (use camelCase)\n   - Should describe what it does: calculateTotal, getUserName, etc.\n\n3. **Parameters** - Inputs the function needs (inside parentheses)\n   - Can have 0, 1, 2, or many parameters\n   - Separated by commas\n   - Like variables that exist only inside the function\n\n4. **Function body** - The code inside { }\n   - The instructions to execute\n\n5. **return statement** - Sends a value back (optional)\n   - Function stops executing when it hits return\n   - If no return, function returns undefined\n\nCalling a function:\nfunctionName(argument1, argument2);\n\n- Use the function name\n- Add parentheses ()\n- Pass arguments (values) for parameters\n\nWithout () it's just a reference:\ngreet     // The function itself (reference)\ngreet()   // Calling the function (execution)"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting parentheses when calling:\n   greet  // Doesn't execute - just references the function\n   greet()  // Executes the function\n\n2. Confusing parameters and arguments:\n   function greet(name) { }  // 'name' is a parameter (placeholder)\n   greet('Alice');  // 'Alice' is an argument (actual value)\n\n3. Not returning a value when you need one:\n   function add(a, b) {\n     a + b;  // WRONG - doesn't return anything!\n   }\n   function add(a, b) {\n     return a + b;  // CORRECT\n   }\n\n4. Code after return never runs:\n   function test() {\n     return 5;\n     console.log('This never runs!');  // Unreachable\n   }\n\n5. Wrong number of arguments:\n   function add(a, b) { return a + b; }\n   add(5);  // b is undefined, returns NaN\n   add(5, 3, 7);  // Extra argument ignored, returns 8"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.1-challenge",
              "title": "Practice Challenge",
              "description": "Create a function that converts Celsius to Fahrenheit:\n1. Name it celsiusToFahrenheit\n2. It should take one parameter: celsius\n3. Formula: (celsius * 9/5) + 32\n4. Return the result\n5. Test by calling it with 0, 100, and 37",
              "instructions": "Create a function that converts Celsius to Fahrenheit:\n1. Name it celsiusToFahrenheit\n2. It should take one parameter: celsius\n3. Formula: (celsius * 9/5) + 32\n4. Return the result\n5. Test by calling it with 0, 100, and 37",
              "starterCode": "// Define your function here\n\n// Test it\nconsole.log(celsiusToFahrenheit(0));    // Should be 32\nconsole.log(celsiusToFahrenheit(100));  // Should be 212\nconsole.log(celsiusToFahrenheit(37));   // Should be 98.6",
              "solution": "function celsiusToFahrenheit(celsius) {\n  return (celsius * 9/5) + 32;\n}\n\nconsole.log(celsiusToFahrenheit(0));    // 32\nconsole.log(celsiusToFahrenheit(100));  // 212\nconsole.log(celsiusToFahrenheit(37));   // 98.6",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Converts 0°C correctly",
                  "expectedOutput": "32",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "function celsiusToFahrenheit(celsius) { return (celsius * 9/5) + 32; }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting parentheses when calling:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting parentheses when calling:\n   greet  // Doesn't execute - just references the function\n   greet()  // Executes the function"
                },
                {
                  "mistake": "Confusing parameters and arguments:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Confusing parameters and arguments:\n   function greet(name) { }  // 'name' is a parameter (placeholder)\n   greet('Alice');  // 'Alice' is an argument (actual value)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.2",
          "title": "The Modern Shorthand (Arrow Functions =>)",
          "moduleId": "module-06",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have two ways to give someone your address:\n\n**Long form**: 'My address is 123 Main Street, New York, NY 10001'\n\n**Short form**: '123 Main St, NYC'\n\nBoth give the same information, but the short form is quicker for simple cases. Arrow functions (=>) are the 'short form' for writing functions in modern JavaScript. They do the same thing as regular functions, but with less typing for simple cases."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Traditional function\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow function (same thing, shorter)\nconst add = (a, b) => {\n  return a + b;\n};\n\n// Even shorter (implicit return for one-liners)\nconst add = (a, b) => a + b;\n\n// Examples of different arrow function forms\n\n// No parameters\nconst sayHello = () => console.log('Hello!');\nsayHello();  // Hello!\n\n// One parameter (parentheses optional)\nconst double = num => num * 2;\nconsole.log(double(5));  // 10\n\n// Multiple parameters (need parentheses)\nconst multiply = (a, b) => a * b;\nconsole.log(multiply(3, 4));  // 12\n\n// Multiple lines (need curly braces and explicit return)\nconst greetPerson = (name) => {\n  let greeting = 'Hello, ' + name;\n  return greeting + '!';\n};\nconsole.log(greetPerson('Alice'));  // Hello, Alice!\n\n// Using with array methods\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = numbers.map(n => n * 2);\nconsole.log(doubled);  // [2, 4, 6, 8, 10]"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Arrow function syntax:\n\nconst functionName = (parameters) => { body };\n│     │              │            │  │      │\n│     │              │            │  │      └─ Function body\n│     │              │            │  └──────── Arrow\n│     │              └────────────┴─────────── Parameters\n│     └──────────────────────────────────────── Name\n└────────────────────────────────────────────── const (or let)\n\nShorthand rules:\n\n1. **No parameters**: Use empty ()\n   const greet = () => 'Hello';\n\n2. **One parameter**: Parentheses optional\n   const double = x => x * 2;\n   const double = (x) => x * 2;  // Also valid\n\n3. **Multiple parameters**: Need parentheses\n   const add = (a, b) => a + b;\n\n4. **One-line body**: Can omit { } and return\n   const add = (a, b) => a + b;  // Implicit return\n\n5. **Multi-line body**: Need { } and explicit return\n   const greet = (name) => {\n     let msg = 'Hello, ' + name;\n     return msg;\n   };\n\nComparing to traditional functions:\n\n// Traditional\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow (full form)\nconst add = (a, b) => {\n  return a + b;\n};\n\n// Arrow (short form)\nconst add = (a, b) => a + b;\n\nWhen to use arrow functions:\n✓ Short, simple functions\n✓ Callback functions (map, filter, etc.)\n✓ Modern JavaScript style\n\nWhen to use traditional functions:\n✓ Methods in objects/classes\n✓ Need 'this' keyword (advanced)\n✓ Personal preference for readability"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting parentheses with multiple parameters:\n   const add = a, b => a + b;  // WRONG\n   const add = (a, b) => a + b;  // CORRECT\n\n2. Forgetting curly braces for multi-line:\n   const greet = name =>\n     let msg = 'Hello';\n     return msg;  // WRONG - syntax error\n   \n   const greet = name => {\n     let msg = 'Hello';\n     return msg;  // CORRECT\n   };\n\n3. Trying to return an object without parentheses:\n   const getUser = () => {name: 'Alice'};  // WRONG - thinks { } is function body\n   const getUser = () => ({name: 'Alice'});  // CORRECT - wrapped in ()\n\n4. Using arrow function as method:\n   const person = {\n     name: 'Alice',\n     greet: () => console.log(this.name)  // WRONG - 'this' doesn't work as expected\n   };\n   Use traditional function for object methods\n\n5. Mixing up = and =>:\n   const add = (a, b) = a + b;  // WRONG - single =\n   const add = (a, b) => a + b;  // CORRECT - arrow =>"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.2-challenge",
              "title": "Practice Challenge",
              "description": "Convert these traditional functions to arrow functions:\n\n1. function square(x) { return x * x; }\n2. function isEven(num) { return num % 2 === 0; }\n3. function getFullName(first, last) { return first + ' ' + last; }\n\nUse the shortest form possible!",
              "instructions": "Convert these traditional functions to arrow functions:\n\n1. function square(x) { return x * x; }\n2. function isEven(num) { return num % 2 === 0; }\n3. function getFullName(first, last) { return first + ' ' + last; }\n\nUse the shortest form possible!",
              "starterCode": "// Convert to arrow functions\nconst square = // YOUR CODE HERE\n\nconst isEven = // YOUR CODE HERE\n\nconst getFullName = // YOUR CODE HERE\n\n// Test them\nconsole.log(square(5));  // 25\nconsole.log(isEven(4));  // true\nconsole.log(getFullName('John', 'Doe'));  // John Doe",
              "solution": "const square = x => x * x;\n\nconst isEven = num => num % 2 === 0;\n\nconst getFullName = (first, last) => first + ' ' + last;\n\n// Test them\nconsole.log(square(5));  // 25\nconsole.log(isEven(4));  // true\nconsole.log(getFullName('John', 'Doe'));  // John Doe",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Square function works",
                  "expectedOutput": "25",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use: const name = params => expression"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting parentheses with multiple parameters:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting parentheses with multiple parameters:\n   const add = a, b => a + b;  // WRONG\n   const add = (a, b) => a + b;  // CORRECT"
                },
                {
                  "mistake": "Forgetting curly braces for multi-line:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting curly braces for multi-line:\n   const greet = name =>\n     let msg = 'Hello';\n     return msg;  // WRONG - syntax error\n   \n   const greet = name => {\n     let msg = 'Hello';\n     return msg;  // CORRECT\n   };"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.3",
          "title": "Ingredients and Results (Parameters and Return Values)",
          "moduleId": "module-06",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "A coffee machine is a perfect analogy for functions with parameters and return values:\n\n**Inputs (Parameters)**: You put in coffee beans, water, and select a size\n**Process**: The machine does its work inside (you don't see this)\n**Output (Return Value)**: You get a cup of coffee\n\nSimilarly, a function:\n- Takes INPUTS (parameters)\n- Does some PROCESSING (the function body)\n- Gives back an OUTPUT (return value)\n\nJust like you can put different beans in the coffee machine and get different coffee, you can pass different parameters to a function and get different results."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Function with one parameter\nfunction greet(name) {\n  return 'Hello, ' + name + '!';\n}\n\nlet message = greet('Alice');\nconsole.log(message);  // Hello, Alice!\n\n// Function with multiple parameters\nfunction calculateArea(width, height) {\n  return width * height;\n}\n\nlet area = calculateArea(5, 10);\nconsole.log(area);  // 50\n\n// Parameters with default values (ES2015+)\nfunction greet(name = 'Guest') {\n  return 'Hello, ' + name + '!';\n}\n\nconsole.log(greet());        // Hello, Guest!\nconsole.log(greet('Bob'));   // Hello, Bob!\n\n// Function that doesn't return (returns undefined)\nfunction logMessage(msg) {\n  console.log(msg);\n  // No return statement\n}\n\nlet result = logMessage('Test');\nconsole.log(result);  // undefined\n\n// Returning early\nfunction divide(a, b) {\n  if (b === 0) {\n    return 'Cannot divide by zero';\n  }\n  return a / b;\n}\n\nconsole.log(divide(10, 2));  // 5\nconsole.log(divide(10, 0));  // Cannot divide by zero\n\n// Returning objects\nfunction createUser(name, age) {\n  return {\n    name: name,\n    age: age,\n    isAdult: age >= 18\n  };\n}\n\nlet user = createUser('Alice', 25);\nconsole.log(user);  // {name: 'Alice', age: 25, isAdult: true}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding parameters and returns:\n\n**Parameters** (Function Definition):\nfunction doSomething(param1, param2, param3) {\n                     │      │      │\n                     └──────┴──────┴─ Placeholders for values\n}\n\n**Arguments** (Function Call):\ndoSomething(value1, value2, value3);\n            │       │       │\n            └───────┴───────┴─ Actual values passed in\n\nParameter patterns:\n\n1. **No parameters**:\n   function sayHello() {\n     return 'Hello!';\n   }\n\n2. **One parameter**:\n   function double(x) {\n     return x * 2;\n   }\n\n3. **Multiple parameters**:\n   function add(a, b) {\n     return a + b;\n   }\n\n4. **Default parameters** (ES2015):\n   function greet(name = 'Guest', greeting = 'Hello') {\n     return greeting + ', ' + name;\n   }\n   greet();  // Hello, Guest\n   greet('Alice');  // Hello, Alice\n   greet('Bob', 'Hi');  // Hi, Bob\n\n5. **Rest parameters** (collect all remaining args):\n   function sum(...numbers) {\n     return numbers.reduce((total, n) => total + n, 0);\n   }\n   sum(1, 2, 3, 4);  // 10\n\nReturn value patterns:\n\n1. **Return a value**:\n   return 42;\n   return 'text';\n   return true;\n\n2. **Return early** (exit function immediately):\n   if (error) {\n     return 'Error';\n   }\n   // Rest of function\n\n3. **No return** (implicitly returns undefined):\n   function doSomething() {\n     console.log('Done');\n   }\n\n4. **Return object** (use parentheses with arrow functions):\n   const getUser = () => ({name: 'Alice', age: 25});\n\n5. **Return another function**:\n   function outer() {\n     return function inner() {\n       return 'Hello';\n     };\n   }"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Wrong number of arguments:\n   function add(a, b) { return a + b; }\n   add(5);  // b is undefined, returns NaN\n   add(5, 3, 7);  // 7 is ignored\n\n2. Not returning the value:\n   function add(a, b) {\n     a + b;  // Calculated but not returned!\n   }\n   let result = add(5, 3);  // undefined\n\n3. Trying to use parameters outside function:\n   function greet(name) {\n     return 'Hello, ' + name;\n   }\n   console.log(name);  // ERROR - name only exists inside function\n\n4. Forgetting to call the function:\n   let result = add;  // result is the function itself\n   let result = add(5, 3);  // result is 8\n\n5. Returning in wrong place:\n   function test() {\n     if (true) {\n       let x = 5;\n       return x;  // WRONG - x might not be accessible\n     }\n   }\n   Better: calculate first, then return"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.3-challenge",
              "title": "Practice Challenge",
              "description": "Create a function called calculateGrade that:\n1. Takes one parameter: score (a number 0-100)\n2. Returns a letter grade based on:\n   - 90+ = 'A'\n   - 80-89 = 'B'\n   - 70-79 = 'C'\n   - 60-69 = 'D'\n   - Below 60 = 'F'\n3. Test with scores: 95, 87, 72, 65, 45",
              "instructions": "Create a function called calculateGrade that:\n1. Takes one parameter: score (a number 0-100)\n2. Returns a letter grade based on:\n   - 90+ = 'A'\n   - 80-89 = 'B'\n   - 70-79 = 'C'\n   - 60-69 = 'D'\n   - Below 60 = 'F'\n3. Test with scores: 95, 87, 72, 65, 45",
              "starterCode": "function calculateGrade(score) {\n  // YOUR CODE HERE\n}\n\n// Test\nconsole.log(calculateGrade(95));  // Should be 'A'\nconsole.log(calculateGrade(87));  // Should be 'B'\nconsole.log(calculateGrade(72));  // Should be 'C'",
              "solution": "function calculateGrade(score) {\n  if (score >= 90) {\n    return 'A';\n  } else if (score >= 80) {\n    return 'B';\n  } else if (score >= 70) {\n    return 'C';\n  } else if (score >= 60) {\n    return 'D';\n  } else {\n    return 'F';\n  }\n}\n\nconsole.log(calculateGrade(95));  // A\nconsole.log(calculateGrade(87));  // B\nconsole.log(calculateGrade(72));  // C\nconsole.log(calculateGrade(65));  // D\nconsole.log(calculateGrade(45));  // F",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Returns 'A' for 95",
                  "expectedOutput": "A",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use if/else if/else with return statements"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Wrong number of arguments:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Wrong number of arguments:\n   function add(a, b) { return a + b; }\n   add(5);  // b is undefined, returns NaN\n   add(5, 3, 7);  // 7 is ignored"
                },
                {
                  "mistake": "Not returning the value:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Not returning the value:\n   function add(a, b) {\n     a + b;  // Calculated but not returned!\n   }\n   let result = add(5, 3);  // undefined"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.4",
          "title": "What's 'In the Kitchen'? (Scope and Variable Visibility)",
          "moduleId": "module-06",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a restaurant with different areas:\n\n**The Kitchen** (Function Scope): Chefs can use all the kitchen tools and ingredients. But customers in the dining room can't reach into the kitchen and grab a spatula.\n\n**The Dining Room** (Global Scope): Everyone can see and use things here - tables, chairs, menus.\n\n**A Chef's Personal Station** (Block Scope): Each chef has their own station. Their tools are theirs - other chefs can't use them.\n\nThis is SCOPE in programming - which parts of your code can 'see' and use which variables. Variables declared inside a function are like kitchen tools - only accessible inside that function. Variables declared outside are like the dining room - everyone can access them."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Global scope - accessible everywhere\nlet globalVar = 'I am global';\n\nfunction testScope() {\n  // Function scope - only accessible inside this function\n  let localVar = 'I am local';\n  \n  console.log(globalVar);  // Works - can access global\n  console.log(localVar);   // Works - we're inside the function\n}\n\ntestScope();\nconsole.log(globalVar);  // Works - global is accessible\n// console.log(localVar);   // ERROR - localVar doesn't exist here!\n\n// Block scope (let and const)\nif (true) {\n  let blockVar = 'I am in a block';\n  const alsoBlock = 'Me too';\n  var notBlock = 'I escape!';\n  \n  console.log(blockVar);  // Works\n}\n\n// console.log(blockVar);  // ERROR - blockVar is block-scoped\nconsole.log(notBlock);   // Works - var ignores block scope (bad!)\n\n// Nested scopes\nlet outer = 'outer';\n\nfunction outerFunc() {\n  let middle = 'middle';\n  \n  function innerFunc() {\n    let inner = 'inner';\n    \n    console.log(outer);   // Works - can see outer\n    console.log(middle);  // Works - can see parent\n    console.log(inner);   // Works - own scope\n  }\n  \n  innerFunc();\n  // console.log(inner);  // ERROR - can't see child scope\n}\n\nouterFunc();\n\n// Shadowing (be careful!)\nlet name = 'Global Alice';\n\nfunction greet() {\n  let name = 'Local Bob';  // Different variable!\n  console.log(name);  // Local Bob\n}\n\ngreet();\nconsole.log(name);  // Global Alice"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding scope:\n\n**1. Global Scope**\n- Variables declared outside any function\n- Accessible everywhere in your code\n- Use sparingly - can cause naming conflicts\n\nlet globalVar = 'accessible everywhere';\n\nfunction anywhere() {\n  console.log(globalVar);  // Can access\n}\n\n**2. Function Scope**\n- Variables declared inside a function\n- Only accessible inside that function\n- Includes parameters\n\nfunction myFunc(param) {  // param has function scope\n  let localVar = 'only here';  // localVar has function scope\n}\n\n**3. Block Scope** (let and const only)\n- Variables declared inside { }\n- Only accessible inside that block\n- if, for, while, etc. create blocks\n\nif (true) {\n  let x = 5;  // Block scoped\n  const y = 10;  // Block scoped\n  var z = 15;  // Function scoped (escapes block!)\n}\n\n**Scope Chain** (looking up variables):\n\nlet a = 'global';\n\nfunction outer() {\n  let b = 'outer';\n  \n  function inner() {\n    let c = 'inner';\n    \n    // JavaScript looks for variables in this order:\n    // 1. Current scope (inner) - c\n    // 2. Parent scope (outer) - b\n    // 3. Grandparent scope (global) - a\n  }\n}\n\n**Best Practices**:\n\n1. Use let and const (not var)\n   - They respect block scope\n   - Prevent accidental global variables\n\n2. Keep variables in smallest scope needed\n   - Declare inside functions/blocks when possible\n   - Reduces naming conflicts\n\n3. Avoid global variables\n   - Hard to track who modifies them\n   - Can cause bugs\n\n4. Don't shadow variables (same name in nested scopes)\n   - Confusing to read\n   - Use different names"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Using variables outside their scope:\n   function test() {\n     let x = 5;\n   }\n   console.log(x);  // ERROR - x only exists inside test()\n\n2. Forgetting var escapes block scope:\n   if (true) {\n     var x = 5;  // Function scoped, not block scoped!\n   }\n   console.log(x);  // 5 - var leaks out\n   \n   Always use let/const, never var!\n\n3. Shadowing by accident:\n   let name = 'Alice';\n   function greet() {\n     let name = 'Bob';  // Different variable!\n   }\n   Confusing - use different names\n\n4. Trying to access parameters outside function:\n   function add(a, b) {\n     return a + b;\n   }\n   console.log(a);  // ERROR - parameters are function-scoped\n\n5. Not understanding hoisting:\n   console.log(x);  // undefined (not error with var)\n   var x = 5;\n   \n   vs\n   \n   console.log(x);  // ERROR - cannot access before initialization\n   let x = 5;\n   \n   Another reason to use let/const!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.4-challenge",
              "title": "Practice Challenge",
              "description": "Debug this code - it has scope issues:\n\nfunction calculateTotal() {\n  let price = 100;\n  let tax = 0.08;\n  \n  if (price > 50) {\n    let discount = 10;\n  }\n  \n  let total = price - discount + (price * tax);\n  return total;\n}\n\nFix it so discount is accessible. Then calculate the total correctly.",
              "instructions": "Debug this code - it has scope issues:\n\nfunction calculateTotal() {\n  let price = 100;\n  let tax = 0.08;\n  \n  if (price > 50) {\n    let discount = 10;\n  }\n  \n  let total = price - discount + (price * tax);\n  return total;\n}\n\nFix it so discount is accessible. Then calculate the total correctly.",
              "starterCode": "function calculateTotal() {\n  let price = 100;\n  let tax = 0.08;\n  \n  if (price > 50) {\n    let discount = 10;\n  }\n  \n  let total = price - discount + (price * tax);\n  return total;\n}\n\nconsole.log(calculateTotal());",
              "solution": "function calculateTotal() {\n  let price = 100;\n  let tax = 0.08;\n  let discount = 0;  // Declare in function scope\n  \n  if (price > 50) {\n    discount = 10;  // Assign (no let)\n  }\n  \n  let total = price - discount + (price * tax);\n  return total;\n}\n\nconsole.log(calculateTotal());  // 98",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Calculates total correctly",
                  "expectedOutput": "98",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Declare discount outside the if block, or move the calculation inside"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Using variables outside their scope:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Using variables outside their scope:\n   function test() {\n     let x = 5;\n   }\n   console.log(x);  // ERROR - x only exists inside test()"
                },
                {
                  "mistake": "Forgetting var escapes block scope:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting var escapes block scope:\n   if (true) {\n     var x = 5;  // Function scoped, not block scoped!\n   }\n   console.log(x);  // 5 - var leaks out\n   \n   Always use let/const, never var!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-07",
      "title": "Module 7: Working with the Web Page (The 'Browser')",
      "description": "Make your code interact with HTML and create dynamic web pages",
      "difficulty": "intermediate",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "7.1",
          "title": "The Three Layers of a Webpage (HTML, CSS, and JavaScript)",
          "moduleId": "module-07",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Building a house has three distinct phases:\n\n**HTML (The Structure)**: This is like the wooden frame of a house - the walls, roof, floors. It defines WHAT exists (rooms, doors, windows) but not how they look or behave.\n\n**CSS (The Styling)**: This is like painting, decorating, choosing furniture. It makes the structure LOOK good - colors, fonts, layouts, spacing.\n\n**JavaScript (The Behavior)**: This is like the electrical wiring, plumbing, security system. It makes things WORK - lights turn on/off, doors lock/unlock, alarms sound.\n\nYou need all three! A house with just a frame is boring. A house with no wiring doesn't work. Together, they create a complete, functional, beautiful home."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "<!-- HTML: The structure (skeleton) -->\n<!DOCTYPE html>\n<html>\n<head>\n  <title>My Page</title>\n  <!-- CSS: The styling (clothes) -->\n  <style>\n    h1 {\n      color: blue;        /* Make heading blue */\n      font-size: 32px;    /* Make it big */\n    }\n    .highlight {\n      background-color: yellow;\n    }\n  </style>\n</head>\n<body>\n  <h1 id=\"title\">Hello, World!</h1>\n  <button id=\"myButton\">Click Me!</button>\n  <p id=\"message\"></p>\n\n  <!-- JavaScript: The behavior (brain) -->\n  <script>\n    // This code runs when the page loads\n    \n    // Find the button element\n    let button = document.getElementById('myButton');\n    \n    // Make something happen when button is clicked\n    button.addEventListener('click', function() {\n      // Find the message paragraph\n      let message = document.getElementById('message');\n      \n      // Change its text content\n      message.textContent = 'Button was clicked!';\n      \n      // Add styling class\n      message.className = 'highlight';\n    });\n  </script>\n</body>\n</html>"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding the three layers:\n\n**1. HTML (HyperText Markup Language)**\n- Defines the STRUCTURE and CONTENT\n- Uses tags: <tagname>content</tagname>\n- Common tags:\n  - <h1> to <h6>: Headings\n  - <p>: Paragraphs\n  - <div>: Generic container\n  - <button>: Clickable button\n  - <input>: Form input\n- Attributes give extra info:\n  - id=\"unique-name\" (unique identifier)\n  - class=\"style-class\" (styling group)\n\n**2. CSS (Cascading Style Sheets)**\n- Defines how HTML elements LOOK\n- Syntax: selector { property: value; }\n- Can be:\n  - Inline: <p style=\"color: red\">Text</p>\n  - Internal: <style> tags in <head>\n  - External: <link rel=\"stylesheet\" href=\"style.css\">\n- Selectors:\n  - h1 { } - All <h1> tags\n  - #myId { } - Element with id=\"myId\"\n  - .myClass { } - Elements with class=\"myClass\"\n\n**3. JavaScript (The Programming Language)**\n- Makes pages INTERACTIVE and DYNAMIC\n- Can:\n  - Find HTML elements\n  - Change their content\n  - Change their styling\n  - Respond to user actions (clicks, typing, etc.)\n  - Fetch data from servers\n  - Validate forms\n  - Animate elements\n\nHow they work together:\n1. HTML creates structure\n2. CSS makes it pretty\n3. JavaScript makes it interactive\n\nExample flow:\n1. User sees button (HTML)\n2. Button is styled blue (CSS)\n3. User clicks button (JavaScript detects)\n4. Message appears (JavaScript changes HTML)\n5. Message is highlighted (JavaScript adds CSS class)"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting quotes around IDs:\n   document.getElementById(heading)  // WRONG - thinks heading is a variable\n   document.getElementById('heading')  // CORRECT - string literal\n\n2. Running JavaScript before HTML loads:\n   <script>document.getElementById('myButton')</script>\n   <button id=\"myButton\">Click</button>\n   The script runs before button exists! Put scripts at end of <body>\n\n3. Typos in IDs (case-sensitive!):\n   HTML: <div id=\"myDiv\"></div>\n   JS: document.getElementById('mydiv')  // WRONG - lowercase d\n   JS: document.getElementById('myDiv')  // CORRECT\n\n4. Confusing textContent, innerHTML, and value:\n   - textContent: Text only (safe, no HTML)\n   - innerHTML: HTML content (can be dangerous!)\n   - value: For form inputs (<input>, <textarea>)\n\n5. Forgetting to attach event listener:\n   button.addEventListener('click', myFunction)  // Correct\n   button.addEventListener('click', myFunction())  // WRONG - calls immediately!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.1-challenge",
              "title": "Practice Challenge",
              "description": "You'll work with this HTML structure:\n\n<h1 id=\"heading\">Welcome</h1>\n<button id=\"changeButton\">Change Text</button>\n\nWrite JavaScript that:\n1. Finds the heading element (use document.getElementById)\n2. Finds the button element\n3. When button is clicked, change heading text to 'Hello, JavaScript!'",
              "instructions": "You'll work with this HTML structure:\n\n<h1 id=\"heading\">Welcome</h1>\n<button id=\"changeButton\">Change Text</button>\n\nWrite JavaScript that:\n1. Finds the heading element (use document.getElementById)\n2. Finds the button element\n3. When button is clicked, change heading text to 'Hello, JavaScript!'",
              "starterCode": "// Find the heading element\nlet heading = document.getElementById('heading');\n\n// Find the button element\nlet button = document.getElementById('changeButton');\n\n// Add click event listener\nbutton.addEventListener('click', function() {\n  // YOUR CODE HERE: Change heading.textContent\n});",
              "solution": "let heading = document.getElementById('heading');\nlet button = document.getElementById('changeButton');\n\nbutton.addEventListener('click', function() {\n  heading.textContent = 'Hello, JavaScript!';\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Changes heading text on click",
                  "expectedOutput": "Hello, JavaScript!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Inside the click function, use: heading.textContent = 'Hello, JavaScript!';"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting quotes around IDs:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting quotes around IDs:\n   document.getElementById(heading)  // WRONG - thinks heading is a variable\n   document.getElementById('heading')  // CORRECT - string literal"
                },
                {
                  "mistake": "Running JavaScript before HTML loads:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Running JavaScript before HTML loads:\n   <script>document.getElementById('myButton')</script>\n   <button id=\"myButton\">Click</button>\n   The script runs before button exists! Put scripts at end of <body>"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "7.2",
          "title": "The Browser's Live Blueprint (What Is the DOM?)",
          "moduleId": "module-07",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're building with LEGO blocks. You have the instruction manual (HTML code), but you also have the actual LEGO structure you've built (the DOM).\n\nThe **DOM (Document Object Model)** is the browser's LIVE representation of your webpage. It's not the HTML code itself - it's the browser's interpretation of that code, turned into a tree of objects that JavaScript can manipulate.\n\nThink of it like this:\n- **HTML**: Blueprint on paper (static text)\n- **DOM**: Actual LEGO construction (living, changeable structure)\n\nWhen you use JavaScript to change the DOM, you're rebuilding parts of the LEGO structure on the fly. The browser immediately shows your changes on screen."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// The DOM is a tree structure\n// HTML:\n// <html>\n//   <body>\n//     <h1>Title</h1>\n//     <p>Paragraph</p>\n//   </body>\n// </html>\n//\n// Becomes this tree:\n// document\n//   └─ html\n//      └─ body\n//         ├─ h1 (\"Title\")\n//         └─ p (\"Paragraph\")\n\n// Accessing the DOM\nconsole.log(document);  // The entire page\nconsole.log(document.body);  // The <body> element\nconsole.log(document.title);  // Page title\n\n// Finding elements (we'll learn more about this next)\nlet element = document.getElementById('myId');\nlet elements = document.getElementsByClassName('myClass');\nlet firstDiv = document.querySelector('div');\nlet allDivs = document.querySelectorAll('div');\n\n// The DOM is LIVE - changes appear immediately\nlet heading = document.getElementById('title');\nheading.textContent = 'New Title';  // Page updates instantly!\n\n// DOM nodes have properties\nconsole.log(heading.tagName);  // 'H1'\nconsole.log(heading.id);  // 'title'\nconsole.log(heading.className);  // CSS classes\n\n// DOM nodes have relationships (tree structure)\nlet parent = heading.parentElement;  // Element above\nlet children = parent.children;  // Elements below\nlet nextSibling = heading.nextElementSibling;  // Next element at same level"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding the DOM:\n\n**What is the DOM?**\n- Browser's representation of the HTML page\n- Tree structure of objects\n- Each HTML element becomes a JavaScript object\n- You can read and modify these objects\n- Changes appear instantly on the page\n\n**DOM Tree Structure:**\n\nHTML:\n<body>\n  <div id=\"container\">\n    <h1>Title</h1>\n    <p>Text</p>\n  </div>\n</body>\n\nDOM Tree:\ndocument\n  └─ body\n     └─ div (id=\"container\")\n        ├─ h1 (\"Title\")\n        └─ p (\"Text\")\n\n**Key DOM Methods:**\n\n1. Finding single elements:\n   - document.getElementById('id')\n   - document.querySelector('selector')\n\n2. Finding multiple elements:\n   - document.getElementsByClassName('class')\n   - document.getElementsByTagName('tag')\n   - document.querySelectorAll('selector')\n\n3. Element properties:\n   - element.textContent (text only)\n   - element.innerHTML (HTML content)\n   - element.value (for inputs)\n   - element.id (element's ID)\n   - element.className (CSS classes)\n   - element.style (inline CSS)\n\n4. Tree navigation:\n   - element.parentElement (parent)\n   - element.children (child elements)\n   - element.nextElementSibling (next)\n   - element.previousElementSibling (previous)\n\n**Important Concepts:**\n\n1. The DOM is LIVE\n   - Changes happen immediately\n   - No need to \"refresh\" or \"save\"\n\n2. Elements are objects\n   - They have properties you can read/write\n   - They have methods you can call\n\n3. Everything is a node\n   - Elements, text, comments, etc.\n   - Forms a tree structure\n\n4. querySelector is modern and flexible\n   - Uses CSS selectors\n   - More powerful than getElementBy...\n   - We'll use this primarily"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Confusing the DOM with HTML:\n   - HTML: Static code you write\n   - DOM: Live structure in browser\n   - Changing HTML file doesn't change running page\n   - Changing DOM changes page immediately\n\n2. Null reference errors:\n   let element = document.getElementById('wrong-id');\n   element.textContent = 'Hi';  // ERROR - element is null!\n   \n   Always check:\n   if (element !== null) {\n     element.textContent = 'Hi';\n   }\n\n3. Mixing up textContent and innerHTML:\n   element.textContent = '<b>Bold</b>';  // Shows literal <b> tags\n   element.innerHTML = '<b>Bold</b>';  // Renders as bold\n   \n   Use textContent for safety (prevents XSS attacks)\n\n4. Timing issues:\n   If JavaScript runs before HTML loads, elements don't exist yet\n   Solution: Put <script> at end of <body> or use DOMContentLoaded event\n\n5. getElementsByClassName returns collection, not array:\n   let items = document.getElementsByClassName('item');\n   items.forEach(...)  // ERROR - not an array!\n   Array.from(items).forEach(...)  // Correct"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.2-challenge",
              "title": "Practice Challenge",
              "description": "Given this HTML:\n<div id=\"container\">\n  <h1 id=\"title\">Original Title</h1>\n  <p id=\"description\">Original description</p>\n</div>\n\nWrite JavaScript that:\n1. Finds the container div\n2. Finds the title h1\n3. Finds the description p\n4. Change title to 'Updated Title'\n5. Change description to 'Updated description'\n6. Log the container's number of children",
              "instructions": "Given this HTML:\n<div id=\"container\">\n  <h1 id=\"title\">Original Title</h1>\n  <p id=\"description\">Original description</p>\n</div>\n\nWrite JavaScript that:\n1. Finds the container div\n2. Finds the title h1\n3. Finds the description p\n4. Change title to 'Updated Title'\n5. Change description to 'Updated description'\n6. Log the container's number of children",
              "starterCode": "// Find the elements\nlet container = // YOUR CODE\nlet title = // YOUR CODE\nlet description = // YOUR CODE\n\n// Update content\n// YOUR CODE\n\n// Log number of children\nconsole.log(container.children.length);",
              "solution": "let container = document.getElementById('container');\nlet title = document.getElementById('title');\nlet description = document.getElementById('description');\n\ntitle.textContent = 'Updated Title';\ndescription.textContent = 'Updated description';\n\nconsole.log(container.children.length);  // 2",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Updates both elements correctly",
                  "expectedOutput": "2",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use document.getElementById('id') for each element"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Confusing the DOM with HTML:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Confusing the DOM with HTML:\n   - HTML: Static code you write\n   - DOM: Live structure in browser\n   - Changing HTML file doesn't change running page\n   - Changing DOM changes page immediately"
                },
                {
                  "mistake": "Null reference errors:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Null reference errors:\n   let element = document.getElementById('wrong-id');\n   element.textContent = 'Hi';  // ERROR - element is null!\n   \n   Always check:\n   if (element !== null) {\n     element.textContent = 'Hi';\n   }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "7.3",
          "title": "Finding Elements on the Page (querySelector)",
          "moduleId": "module-07",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're in a huge library looking for books:\n\n**Old way** (getElementById, getElementsByClassName): You can only search by:\n- Call number (ID): \"Find book #12345\"\n- Category (class): \"Find all books in Science section\"\n\n**New way** (querySelector): You can search by ANYTHING:\n- \"Find the first red book on the third shelf\"\n- \"Find all books by Author X with 'JavaScript' in the title\"\n- \"Find the book inside the Special Collections room\"\n\nquerySelector uses CSS selectors, which means you can find elements in incredibly flexible ways. It's like having a super-powered library search system!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// querySelector finds the FIRST match\n// querySelectorAll finds ALL matches\n\n// By ID (same as getElementById, but with # prefix)\nlet title = document.querySelector('#title');\n\n// By class (same as getElementsByClassName, but with . prefix)\nlet firstItem = document.querySelector('.item');\nlet allItems = document.querySelectorAll('.item');\n\n// By tag name\nlet firstParagraph = document.querySelector('p');\nlet allParagraphs = document.querySelectorAll('p');\n\n// By attribute\nlet input = document.querySelector('[type=\"email\"]');\nlet required = document.querySelectorAll('[required]');\n\n// Combining selectors\nlet redButton = document.querySelector('button.red');\nlet containerDiv = document.querySelector('div#container');\n\n// Descendant selectors (inside)\nlet linkInNav = document.querySelector('nav a');\nlet itemsInList = document.querySelectorAll('ul.menu li');\n\n// Direct children (>)\nlet directChild = document.querySelector('div > p');\n\n// Pseudo-selectors\nlet firstChild = document.querySelector('li:first-child');\nlet lastChild = document.querySelector('li:last-child');\nlet evenItems = document.querySelectorAll('li:nth-child(even)');\n\n// Complex example\nlet specificButton = document.querySelector('div.container button.primary:not(.disabled)');\n// Finds: button with class 'primary', inside div with class 'container', not having class 'disabled'\n\n// querySelectorAll returns NodeList (array-like)\nlet buttons = document.querySelectorAll('button');\nconsole.log(buttons.length);  // Number of buttons\nbuttons.forEach(btn => {\n  console.log(btn.textContent);\n});"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "querySelector syntax (uses CSS selectors):\n\n**Basic Selectors:**\n\n1. By ID: #idName\n   document.querySelector('#myId')\n   // Same as: document.getElementById('myId')\n\n2. By class: .className\n   document.querySelector('.myClass')\n   document.querySelectorAll('.myClass')  // All matches\n\n3. By tag: tagname\n   document.querySelector('p')\n   document.querySelectorAll('div')\n\n4. By attribute: [attribute]\n   document.querySelector('[href]')  // Has href attribute\n   document.querySelector('[type=\"submit\"]')  // type=\"submit\"\n\n**Combinators:**\n\n1. Descendant: space (anywhere inside)\n   document.querySelector('div p')  // p inside any div\n\n2. Direct child: >\n   document.querySelector('div > p')  // p directly inside div\n\n3. Multiple selectors: comma\n   document.querySelectorAll('h1, h2, h3')  // All headings\n\n4. Combined: no space\n   document.querySelector('button.primary')  // button with class 'primary'\n\n**Pseudo-selectors:**\n\n1. :first-child, :last-child\n2. :nth-child(n) - The nth child\n3. :nth-child(even), :nth-child(odd)\n4. :not(selector) - Exclude matches\n5. :hover, :focus, :checked (for CSS, less useful in JS)\n\n**Differences from getElementBy...:**\n\nquerySelector:\n✓ More flexible (any CSS selector)\n✓ Consistent syntax\n✓ Returns null if not found\n✓ Modern and recommended\n✗ Slightly slower (negligible)\n\ngetElementBy...:\n✓ Slightly faster\n✓ Returns live collections (auto-updates)\n✗ Limited to ID, class, or tag\n✗ Different syntax for each\n\n**Best Practice:**\nUse querySelector/querySelectorAll for everything. They're more powerful and the syntax is consistent.\n\n**NodeList vs Array:**\nquerySelectorAll returns a NodeList (not an Array)\n- Has .length\n- Has .forEach() (modern browsers)\n- Doesn't have .map(), .filter(), etc.\n\nConvert to array if needed:\nlet itemsArray = Array.from(document.querySelectorAll('.item'));"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting the . or # prefix:\n   document.querySelector('myClass')  // WRONG - looks for <myClass> tag\n   document.querySelector('.myClass')  // CORRECT - looks for class\n\n2. Expecting querySelectorAll to be an array:\n   let items = document.querySelectorAll('.item');\n   items.map(...)  // ERROR - NodeList doesn't have map\n   \n   Convert first:\n   Array.from(items).map(...)\n   // Or use forEach (works on NodeList):\n   items.forEach(...)\n\n3. Confusing querySelector with querySelectorAll:\n   querySelector returns: first match or null\n   querySelectorAll returns: NodeList of all matches (can be empty)\n\n4. Complex selectors with typos:\n   'div.container button.primary'  // Correct\n   'div .container button .primary'  // WRONG - extra spaces change meaning\n\n5. Not checking for null:\n   let element = document.querySelector('.doesnt-exist');\n   element.textContent = 'Hi';  // ERROR - element is null!\n   \n   Always check:\n   if (element) {\n     element.textContent = 'Hi';\n   }"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.3-challenge",
              "title": "Practice Challenge",
              "description": "Given this HTML:\n<nav>\n  <ul class=\"menu\">\n    <li class=\"item\">Home</li>\n    <li class=\"item active\">About</li>\n    <li class=\"item\">Contact</li>\n  </ul>\n</nav>\n<div class=\"content\">\n  <button class=\"primary\">Save</button>\n  <button class=\"secondary\">Cancel</button>\n</div>\n\nWrite JavaScript using querySelector to:\n1. Find the active menu item\n2. Find all menu items\n3. Find the primary button\n4. Find all buttons\n5. Log the text of the active item",
              "instructions": "Given this HTML:\n<nav>\n  <ul class=\"menu\">\n    <li class=\"item\">Home</li>\n    <li class=\"item active\">About</li>\n    <li class=\"item\">Contact</li>\n  </ul>\n</nav>\n<div class=\"content\">\n  <button class=\"primary\">Save</button>\n  <button class=\"secondary\">Cancel</button>\n</div>\n\nWrite JavaScript using querySelector to:\n1. Find the active menu item\n2. Find all menu items\n3. Find the primary button\n4. Find all buttons\n5. Log the text of the active item",
              "starterCode": "// Find the active menu item\nlet activeItem = document.querySelector(/* YOUR SELECTOR */);\n\n// Find all menu items\nlet allItems = document.querySelectorAll(/* YOUR SELECTOR */);\n\n// Find the primary button\nlet primaryButton = document.querySelector(/* YOUR SELECTOR */);\n\n// Find all buttons\nlet allButtons = document.querySelectorAll(/* YOUR SELECTOR */);\n\n// Log the active item text\nconsole.log(activeItem.textContent);",
              "solution": "let activeItem = document.querySelector('.item.active');\nlet allItems = document.querySelectorAll('.item');\nlet primaryButton = document.querySelector('.primary');\nlet allButtons = document.querySelectorAll('button');\n\nconsole.log(activeItem.textContent);  // About",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Finds active item correctly",
                  "expectedOutput": "About",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use '.item.active' for active item, '.item' for all items, '.primary' for primary button, 'button' for all buttons"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting the . or # prefix:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting the . or # prefix:\n   document.querySelector('myClass')  // WRONG - looks for <myClass> tag\n   document.querySelector('.myClass')  // CORRECT - looks for class"
                },
                {
                  "mistake": "Expecting querySelectorAll to be an array:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Expecting querySelectorAll to be an array:\n   let items = document.querySelectorAll('.item');\n   items.map(...)  // ERROR - NodeList doesn't have map\n   \n   Convert first:\n   Array.from(items).map(...)\n   // Or use forEach (works on NodeList):\n   items.forEach(...)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "7.4",
          "title": "Changing What Users See (Modifying .textContent and .style)",
          "moduleId": "module-07",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have a puppet theater:\n\n**textContent**: This is like changing what the puppet SAYS. You're swapping out the dialogue.\n\n**style**: This is like changing what the puppet WEARS or how it LOOKS. You're changing the costume, makeup, lighting.\n\nJavaScript lets you be the puppeteer - you can change what elements say (their text) and how they look (their styling) on the fly, creating a dynamic, interactive show for your users."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Changing text content\nlet heading = document.querySelector('h1');\nheading.textContent = 'New Heading';\n\nlet paragraph = document.querySelector('p');\nparagraph.textContent = 'New paragraph text';\n\n// Changing inline styles (CSS properties)\nlet box = document.querySelector('.box');\nbox.style.color = 'red';  // Text color\nbox.style.backgroundColor = 'yellow';  // Background (note camelCase!)\nbox.style.fontSize = '24px';  // Font size\nbox.style.width = '200px';  // Width\nbox.style.padding = '20px';  // Padding\nbox.style.border = '2px solid black';  // Border\n\n// CSS properties with hyphens become camelCase in JavaScript\n// CSS: background-color → JavaScript: backgroundColor\n// CSS: font-size → JavaScript: fontSize\n// CSS: margin-top → JavaScript: marginTop\n\n// Working with classes (better than inline styles!)\nlet element = document.querySelector('.item');\n\n// Add a class\nelement.classList.add('active');\n\n// Remove a class\nelement.classList.remove('inactive');\n\n// Toggle a class (add if missing, remove if present)\nelement.classList.toggle('highlighted');\n\n// Check if class exists\nif (element.classList.contains('active')) {\n  console.log('Element is active');\n}\n\n// Practical example: Dark mode toggle\nlet button = document.querySelector('#darkModeBtn');\nbutton.addEventListener('click', function() {\n  document.body.classList.toggle('dark-mode');\n});\n\n// Changing multiple styles at once\nlet card = document.querySelector('.card');\nObject.assign(card.style, {\n  width: '300px',\n  height: '200px',\n  backgroundColor: '#f0f0f0',\n  borderRadius: '10px',\n  padding: '20px'\n});\n\n// Getting current styles\nlet computedStyle = window.getComputedStyle(element);\nconsole.log(computedStyle.color);  // Current color"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Modifying DOM elements:\n\n**1. Changing Text Content:**\n\n// textContent (recommended - safe, text only)\nelement.textContent = 'New text';\n\n// innerHTML (can include HTML, but risky!)\nelement.innerHTML = '<b>Bold text</b>';\n\n// innerText (similar to textContent, but respects CSS visibility)\nelement.innerText = 'New text';\n\n**Best practice**: Use textContent unless you specifically need HTML\n\n**2. Changing Inline Styles:**\n\nelement.style.propertyName = 'value';\n\nKey points:\n- CSS properties with hyphens become camelCase\n- Values are strings (include units: '20px', '50%')\n- This adds inline styles (highest priority)\n\nExamples:\nCSS Property        → JavaScript Property\ncolor               → color\nbackground-color    → backgroundColor\nfont-size           → fontSize\nmargin-top          → marginTop\nborder-radius       → borderRadius\nz-index             → zIndex\n\n**3. Working with Classes (Preferred Method):**\n\n// classList provides methods to manipulate classes\nelement.classList.add('class1', 'class2');\nelement.classList.remove('class1');\nelement.classList.toggle('class1');  // Add if missing, remove if present\nelement.classList.contains('class1');  // Returns true/false\nelement.classList.replace('old', 'new');\n\n// Old way (not recommended):\nelement.className = 'class1 class2';  // Replaces all classes\n\n**Why use classes instead of inline styles?**\n\n✓ Separation of concerns (CSS in CSS, JS in JS)\n✓ Easier to maintain\n✓ Can change multiple properties at once\n✓ Better performance\n✓ CSS can be cached\n✓ Easier to override\n\nExample:\n// Instead of:\nelement.style.color = 'red';\nelement.style.fontWeight = 'bold';\nelement.style.fontSize = '20px';\n\n// Do this:\nelement.classList.add('error');\n\n// And in CSS:\n.error {\n  color: red;\n  font-weight: bold;\n  font-size: 20px;\n}\n\n**4. Reading Styles:**\n\n// Inline styles only\nelement.style.color  // Only returns inline styles\n\n// All computed styles (including CSS)\nlet styles = window.getComputedStyle(element);\nstyles.color\nstyles.fontSize"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting camelCase for CSS properties:\n   element.style.background-color = 'red';  // SYNTAX ERROR\n   element.style.backgroundColor = 'red';  // CORRECT\n\n2. Forgetting units:\n   element.style.width = 200;  // WRONG - no effect\n   element.style.width = '200px';  // CORRECT\n\n3. Overusing inline styles instead of classes:\n   Bad:\n   element.style.color = 'red';\n   element.style.fontWeight = 'bold';\n   \n   Better:\n   element.classList.add('error');\n   // Define .error in CSS\n\n4. Confusing textContent, innerHTML, and innerText:\n   textContent: Safest, pure text\n   innerHTML: Can include HTML (security risk if user input!)\n   innerText: Respects CSS (slower)\n\n5. Not checking if element exists:\n   let el = document.querySelector('.missing');\n   el.textContent = 'Hi';  // ERROR if el is null!\n   \n   Always check:\n   if (el) {\n     el.textContent = 'Hi';\n   }"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.4-challenge",
              "title": "Practice Challenge",
              "description": "Create an interactive element:\n\n<div id=\"box\" class=\"normal\">Click Me!</div>\n\nWrite JavaScript that:\n1. Finds the box\n2. When clicked, toggles a 'highlighted' class\n3. Also changes the textContent to show if it's highlighted or normal\n\nCSS (already defined):\n.normal { background: gray; }\n.highlighted { background: yellow; }",
              "instructions": "Create an interactive element:\n\n<div id=\"box\" class=\"normal\">Click Me!</div>\n\nWrite JavaScript that:\n1. Finds the box\n2. When clicked, toggles a 'highlighted' class\n3. Also changes the textContent to show if it's highlighted or normal\n\nCSS (already defined):\n.normal { background: gray; }\n.highlighted { background: yellow; }",
              "starterCode": "let box = document.querySelector('#box');\n\nbox.addEventListener('click', function() {\n  // Toggle the highlighted class\n  \n  // Check if highlighted and update text\n  if (box.classList.contains('highlighted')) {\n    box.textContent = 'Highlighted!';\n  } else {\n    box.textContent = 'Click Me!';\n  }\n});",
              "solution": "let box = document.querySelector('#box');\n\nbox.addEventListener('click', function() {\n  box.classList.toggle('highlighted');\n  \n  if (box.classList.contains('highlighted')) {\n    box.textContent = 'Highlighted!';\n  } else {\n    box.textContent = 'Click Me!';\n  }\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Toggles class and updates text",
                  "expectedOutput": "Click Me!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use box.classList.toggle('highlighted') and box.classList.contains('highlighted')"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting camelCase for CSS properties:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting camelCase for CSS properties:\n   element.style.background-color = 'red';  // SYNTAX ERROR\n   element.style.backgroundColor = 'red';  // CORRECT"
                },
                {
                  "mistake": "Forgetting units:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting units:\n   element.style.width = 200;  // WRONG - no effect\n   element.style.width = '200px';  // CORRECT"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "7.5",
          "title": "Responding to User Actions (Event Listeners)",
          "moduleId": "module-07",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're a security guard at a building:\n\nYou're not actively doing anything most of the time - you're LISTENING and WAITING for specific events to happen:\n\n- **Event**: Someone presses the doorbell → **Response**: You open the door\n- **Event**: Fire alarm goes off → **Response**: You evacuate everyone\n- **Event**: Someone tries wrong password 3 times → **Response**: You lock them out\n\nEvent listeners work the same way. Your JavaScript code sits idle, LISTENING for specific events (clicks, key presses, mouse movements, etc.). When an event happens, your code RESPONDS by running a function."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Basic event listener\nlet button = document.querySelector('#myButton');\n\nbutton.addEventListener('click', function() {\n  console.log('Button was clicked!');\n});\n\n// Common events\nlet input = document.querySelector('#nameInput');\n\n// 'input' fires when user types\ninput.addEventListener('input', function(event) {\n  console.log('User typed:', event.target.value);\n});\n\n// 'change' fires when input loses focus after being changed\ninput.addEventListener('change', function(event) {\n  console.log('Input changed to:', event.target.value);\n});\n\n// 'focus' fires when element receives focus\ninput.addEventListener('focus', function() {\n  console.log('Input focused');\n});\n\n// 'blur' fires when element loses focus\ninput.addEventListener('blur', function() {\n  console.log('Input lost focus');\n});\n\n// Mouse events\nlet box = document.querySelector('.box');\n\nbox.addEventListener('mouseenter', function() {\n  console.log('Mouse entered box');\n});\n\nbox.addEventListener('mouseleave', function() {\n  console.log('Mouse left box');\n});\n\nbox.addEventListener('mousemove', function(event) {\n  console.log('Mouse position:', event.clientX, event.clientY);\n});\n\n// Keyboard events\ndocument.addEventListener('keydown', function(event) {\n  console.log('Key pressed:', event.key);\n  \n  if (event.key === 'Enter') {\n    console.log('Enter key pressed!');\n  }\n});\n\n// Form events\nlet form = document.querySelector('#myForm');\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();  // Prevent default form submission\n  console.log('Form submitted');\n  \n  // Get form data\n  let formData = new FormData(form);\n  console.log(formData.get('username'));\n});\n\n// Event object\nbutton.addEventListener('click', function(event) {\n  console.log('Event type:', event.type);  // 'click'\n  console.log('Target element:', event.target);  // The button\n  console.log('Mouse position:', event.clientX, event.clientY);\n});\n\n// Removing event listeners\nfunction handleClick() {\n  console.log('Clicked!');\n}\n\nbutton.addEventListener('click', handleClick);\nbutton.removeEventListener('click', handleClick);  // Must be same function\n\n// Multiple listeners on same event\nbutton.addEventListener('click', function() {\n  console.log('First listener');\n});\n\nbutton.addEventListener('click', function() {\n  console.log('Second listener');\n});\n// Both run when button is clicked!"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Event listeners syntax:\n\nelement.addEventListener(eventType, callbackFunction);\n│                        │          │\n│                        │          └─ Function to run when event fires\n│                        └──────────── Type of event to listen for\n└───────────────────────────────────── Element to listen on\n\n**Common Event Types:**\n\nMouse Events:\n- 'click' - Element is clicked\n- 'dblclick' - Element is double-clicked\n- 'mouseenter' - Mouse enters element\n- 'mouseleave' - Mouse leaves element\n- 'mousemove' - Mouse moves over element\n- 'mousedown' - Mouse button pressed\n- 'mouseup' - Mouse button released\n\nKeyboard Events:\n- 'keydown' - Key is pressed down\n- 'keyup' - Key is released\n- 'keypress' - Key is pressed (deprecated, use keydown)\n\nForm Events:\n- 'submit' - Form is submitted\n- 'input' - Input value changes (real-time)\n- 'change' - Input value changes (on blur)\n- 'focus' - Element receives focus\n- 'blur' - Element loses focus\n\nWindow/Document Events:\n- 'load' - Page fully loaded\n- 'DOMContentLoaded' - HTML loaded (before images)\n- 'resize' - Window resized\n- 'scroll' - Page scrolled\n\n**Event Object:**\n\nThe callback receives an event object:\n\nelement.addEventListener('click', function(event) {\n  // event contains information about the event\n});\n\nUseful properties:\n- event.type - Type of event ('click', 'keydown', etc.)\n- event.target - Element that triggered the event\n- event.currentTarget - Element the listener is attached to\n- event.key - Key that was pressed (keyboard events)\n- event.clientX, event.clientY - Mouse position\n- event.preventDefault() - Prevent default behavior\n- event.stopPropagation() - Stop event bubbling\n\n**Preventing Defaults:**\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();  // Stop form from actually submitting\n  // Handle with JavaScript instead\n});\n\nlink.addEventListener('click', function(event) {\n  event.preventDefault();  // Stop link from navigating\n  // Do something else\n});\n\n**Arrow Functions:**\n\n// Traditional function\nelement.addEventListener('click', function() {\n  console.log('Clicked');\n});\n\n// Arrow function (more modern)\nelement.addEventListener('click', () => {\n  console.log('Clicked');\n});\n\n// With event parameter\nelement.addEventListener('click', (event) => {\n  console.log(event.target);\n});"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Calling the function immediately:\n   button.addEventListener('click', myFunction());  // WRONG - runs now!\n   button.addEventListener('click', myFunction);  // CORRECT - runs on click\n\n2. Forgetting event.preventDefault() for forms:\n   form.addEventListener('submit', function(event) {\n     // Form submits and page reloads before your code runs!\n   });\n   \n   Must prevent default:\n   form.addEventListener('submit', function(event) {\n     event.preventDefault();  // Now your code can run\n   });\n\n3. Confusing input vs change:\n   'input' - Fires on every keystroke (real-time)\n   'change' - Fires when field loses focus (final value)\n\n4. Not getting input values correctly:\n   let value = input;  // WRONG - this is the element!\n   let value = input.value;  // CORRECT - this is the text\n\n5. Trying to remove anonymous function:\n   element.addEventListener('click', function() { });\n   element.removeEventListener('click', function() { });  // Doesn't work!\n   \n   Must use named function:\n   function handleClick() { }\n   element.addEventListener('click', handleClick);\n   element.removeEventListener('click', handleClick);  // Works!\n\n6. Forgetting 'this' context in arrow functions:\n   // Traditional function: 'this' is the element\n   button.addEventListener('click', function() {\n     console.log(this);  // The button\n   });\n   \n   // Arrow function: 'this' is lexical scope\n   button.addEventListener('click', () => {\n     console.log(this);  // NOT the button!\n   });"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.5-challenge",
              "title": "Practice Challenge",
              "description": "Create an interactive form validator:\n\n<form id=\"signupForm\">\n  <input type=\"text\" id=\"username\" placeholder=\"Username\">\n  <input type=\"email\" id=\"email\" placeholder=\"Email\">\n  <button type=\"submit\">Sign Up</button>\n  <p id=\"message\"></p>\n</form>\n\nWrite JavaScript that:\n1. When the form is submitted, prevent default behavior\n2. Get the username and email values\n3. If username is empty, show error message\n4. If email doesn't contain '@', show error message\n5. If both valid, show success message",
              "instructions": "Create an interactive form validator:\n\n<form id=\"signupForm\">\n  <input type=\"text\" id=\"username\" placeholder=\"Username\">\n  <input type=\"email\" id=\"email\" placeholder=\"Email\">\n  <button type=\"submit\">Sign Up</button>\n  <p id=\"message\"></p>\n</form>\n\nWrite JavaScript that:\n1. When the form is submitted, prevent default behavior\n2. Get the username and email values\n3. If username is empty, show error message\n4. If email doesn't contain '@', show error message\n5. If both valid, show success message",
              "starterCode": "let form = document.querySelector('#signupForm');\nlet message = document.querySelector('#message');\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();\n  \n  let username = document.querySelector('#username').value;\n  let email = document.querySelector('#email').value;\n  \n  // YOUR CODE HERE\n  // Check if username is empty\n  // Check if email contains '@'\n  // Show appropriate message\n});",
              "solution": "let form = document.querySelector('#signupForm');\nlet message = document.querySelector('#message');\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();\n  \n  let username = document.querySelector('#username').value;\n  let email = document.querySelector('#email').value;\n  \n  if (username === '') {\n    message.textContent = 'Username is required';\n    message.style.color = 'red';\n  } else if (!email.includes('@')) {\n    message.textContent = 'Please enter a valid email';\n    message.style.color = 'red';\n  } else {\n    message.textContent = 'Sign up successful!';\n    message.style.color = 'green';\n  }\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Validates empty username",
                  "expectedOutput": "Username required",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use if/else to check: username === '' and !email.includes('@')"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Calling the function immediately:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Calling the function immediately:\n   button.addEventListener('click', myFunction());  // WRONG - runs now!\n   button.addEventListener('click', myFunction);  // CORRECT - runs on click"
                },
                {
                  "mistake": "Forgetting event.preventDefault() for forms:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting event.preventDefault() for forms:\n   form.addEventListener('submit', function(event) {\n     // Form submits and page reloads before your code runs!\n   });\n   \n   Must prevent default:\n   form.addEventListener('submit', function(event) {\n     event.preventDefault();  // Now your code can run\n   });"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-08",
      "title": "Module 8: Asynchronous JavaScript (The 'Waiting Game')",
      "description": "Handle tasks that take time without freezing your application",
      "difficulty": "intermediate",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "8.1",
          "title": "The Restaurant Buzzer (Synchronous vs. Asynchronous)",
          "moduleId": "module-08",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine two different ways of ordering food:\n\n**Synchronous (Blocking)**: You stand at the counter. The cook makes your burger while you wait, staring at them. You can't do ANYTHING else until your burger is ready. If it takes 20 minutes, you stand there for 20 minutes. This is how most code works - one line after another, waiting for each to finish.\n\n**Asynchronous (Non-blocking)**: You order, get a buzzer, and sit down. While the kitchen makes your food, you can chat with friends, check your phone, or relax. When food is ready, the buzzer vibrates, and you go pick it up. You're not stuck waiting!\n\nJavaScript is single-threaded (one line at a time), but asynchronous code lets it START a slow task, move on to other things, then come back when the slow task is done. Perfect for network requests, file reading, or anything that takes time."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// SYNCHRONOUS (Blocking) - Everything waits\nconsole.log('Start');\nfor (let i = 0; i < 3; i++) {\n  console.log('Step ' + i);\n}\nconsole.log('End');\n// Output: Start, Step 0, Step 1, Step 2, End (in order)\n\n// ASYNCHRONOUS (Non-blocking) - Using setTimeout\nconsole.log('Start');\n\nsetTimeout(function() {\n  console.log('This runs after 2 seconds');\n}, 2000);\n\nconsole.log('End');\n// Output: Start, End, (wait 2 seconds), This runs after 2 seconds\n// Notice 'End' comes BEFORE the timeout!\n\n// Practical example: Loading data\nconsole.log('Fetching user data...');\n\n// Simulating a slow network request (async)\nsetTimeout(function() {\n  console.log('User data loaded: Alice, age 25');\n}, 1000);\n\nconsole.log('Continuing with other tasks...');\n// Output:\n// Fetching user data...\n// Continuing with other tasks...\n// (1 second later) User data loaded: Alice, age 25\n\n// Multiple async operations\nconsole.log('Cooking eggs');\n\nsetTimeout(() => console.log('Eggs done!'), 2000);\nsetTimeout(() => console.log('Toast done!'), 1000);\nsetTimeout(() => console.log('Coffee done!'), 1500);\n\nconsole.log('Started all cooking tasks');\n// Output:\n// Cooking eggs\n// Started all cooking tasks\n// (1s) Toast done!\n// (1.5s) Coffee done!\n// (2s) Eggs done!"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding sync vs async:\n\n**Synchronous Code (Default):**\n- Runs line by line\n- Each line waits for the previous to complete\n- Blocking (stops everything until done)\n\nlet a = 1;\nlet b = 2;\nlet c = a + b;  // Waits for a and b\nconsole.log(c);  // Waits for c\n\n**Asynchronous Code:**\n- Starts a task\n- Doesn't wait for it to finish\n- Continues to next line immediately\n- Comes back when task completes\n\nCommon async operations:\n- setTimeout / setInterval (timers)\n- fetch() (network requests)\n- Reading files (Node.js)\n- Database queries\n- User interactions (clicks are async events)\n\n**setTimeout Syntax:**\n\nsetTimeout(callbackFunction, delayInMilliseconds);\n\nExamples:\nsetTimeout(() => console.log('Hi'), 1000);  // After 1 second\nsetTimeout(myFunction, 500);  // After 0.5 seconds\nsetTimeout(() => {\n  console.log('Multiple');\n  console.log('Lines');\n}, 2000);  // After 2 seconds\n\n**setInterval (Repeating Timer):**\n\nsetInterval(callbackFunction, intervalInMilliseconds);\n\nlet count = 0;\nlet intervalId = setInterval(() => {\n  count++;\n  console.log('Count:', count);\n  \n  if (count === 5) {\n    clearInterval(intervalId);  // Stop the interval\n  }\n}, 1000);  // Every 1 second\n\n**Why Async Matters:**\n\n// Synchronous (BAD for web):\nlet data = fetchDataFromServer();  // Takes 3 seconds, UI freezes!\nconsole.log(data);\n\n// Asynchronous (GOOD for web):\nfetchDataFromServer((data) => {\n  console.log(data);\n});  // UI stays responsive!\n\n**The Event Loop:**\n\nJavaScript has:\n1. Call stack (current code running)\n2. Web APIs (setTimeout, fetch, etc.)\n3. Callback queue (waiting callbacks)\n4. Event loop (moves callbacks to stack when empty)\n\nThis is how async works without multiple threads!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Expecting async code to run in order:\n   setTimeout(() => console.log('A'), 1000);\n   console.log('B');\n   // Output: B, (wait), A  (not A, B!)\n\n2. Not storing interval ID to clear it:\n   setInterval(() => console.log('Hi'), 1000);\n   // Can't stop it now!\n   \n   Correct:\n   let id = setInterval(() => console.log('Hi'), 1000);\n   clearInterval(id);  // Can stop it\n\n3. Confusing milliseconds with seconds:\n   setTimeout(() => console.log('Hi'), 5);  // 5 milliseconds!\n   setTimeout(() => console.log('Hi'), 5000);  // 5 seconds\n\n4. Creating infinite intervals:\n   setInterval(() => {\n     // Runs forever!\n   }, 1000);\n   // Remember to clearInterval when done\n\n5. Trying to 'wait' for async with sync code:\n   setTimeout(() => data = fetchData(), 1000);\n   console.log(data);  // undefined! Timeout hasn't run yet\n   \n   Must use callbacks or promises (next lessons)"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "8.1-challenge",
              "title": "Practice Challenge",
              "description": "Create a countdown timer that:\n1. Starts at 3\n2. Logs the number every second\n3. Logs 'Liftoff!' after 0\n\nExpected output (over 4 seconds):\n3\n2\n1\n0\nLiftoff!",
              "instructions": "Create a countdown timer that:\n1. Starts at 3\n2. Logs the number every second\n3. Logs 'Liftoff!' after 0\n\nExpected output (over 4 seconds):\n3\n2\n1\n0\nLiftoff!",
              "starterCode": "let count = 3;\n\n// Create an interval that runs every 1000ms\nlet intervalId = setInterval(() => {\n  // YOUR CODE HERE\n  // Log count\n  // Decrease count\n  // If count < 0, log 'Liftoff!' and stop interval\n}, 1000);",
              "solution": "let count = 3;\n\nlet intervalId = setInterval(() => {\n  console.log(count);\n  count--;\n  \n  if (count < 0) {\n    console.log('Liftoff!');\n    clearInterval(intervalId);\n  }\n}, 1000);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Countdown works correctly",
                  "expectedOutput": "3\n2\n1\n0\nLiftoff!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Log count, then count--, then if (count < 0) clearInterval and log Liftoff"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Expecting async code to run in order:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Expecting async code to run in order:\n   setTimeout(() => console.log('A'), 1000);\n   console.log('B');\n   // Output: B, (wait), A  (not A, B!)"
                },
                {
                  "mistake": "Not storing interval ID to clear it:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Not storing interval ID to clear it:\n   setInterval(() => console.log('Hi'), 1000);\n   // Can't stop it now!\n   \n   Correct:\n   let id = setInterval(() => console.log('Hi'), 1000);\n   clearInterval(id);  // Can stop it"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "8.2",
          "title": "The Promise of a Future Result (Promises)",
          "moduleId": "module-08",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "You order a pizza for delivery:\n\n1. **You place the order** (create a Promise) - The restaurant promises to either deliver your pizza OR call you with a problem.\n\n2. **You wait** (Promise is 'pending') - The pizza is being made. You don't have it yet, but you have a promise.\n\n3. **Two possible outcomes**:\n   - **Fulfilled (Resolved)**: Pizza arrives! You eat it (the 'then' callback runs)\n   - **Rejected**: Restaurant calls - they're out of ingredients (the 'catch' callback runs)\n\nA Promise is JavaScript's way of saying: 'I'll get you a result eventually. Here's a guarantee (promise) that I'll let you know when it's done, whether it succeeds or fails.'"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Creating a Promise\nlet myPromise = new Promise((resolve, reject) => {\n  // Simulating async operation\n  let success = true;\n  \n  setTimeout(() => {\n    if (success) {\n      resolve('Operation successful!');  // Fulfilled\n    } else {\n      reject('Operation failed!');  // Rejected\n    }\n  }, 1000);\n});\n\n// Using a Promise\nmyPromise\n  .then((result) => {\n    console.log('Success:', result);\n  })\n  .catch((error) => {\n    console.log('Error:', error);\n  });\n\n// Practical example: Fetching data\nfunction fetchUserData(userId) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId > 0) {\n        resolve({ id: userId, name: 'Alice' });\n      } else {\n        reject('Invalid user ID');\n      }\n    }, 1000);\n  });\n}\n\nfetchUserData(1)\n  .then((user) => {\n    console.log('User:', user.name);\n  })\n  .catch((error) => {\n    console.log('Error:', error);\n  });\n\n// Chaining Promises\nfetchUserData(1)\n  .then((user) => {\n    console.log('Got user:', user.name);\n    return fetchUserPosts(user.id);  // Returns another promise\n  })\n  .then((posts) => {\n    console.log('Got posts:', posts);\n  })\n  .catch((error) => {\n    console.log('Error:', error);\n  });\n\n// Promise.all - Wait for multiple promises\nlet promise1 = fetchUserData(1);\nlet promise2 = fetchUserData(2);\nlet promise3 = fetchUserData(3);\n\nPromise.all([promise1, promise2, promise3])\n  .then((results) => {\n    console.log('All users:', results);\n  })\n  .catch((error) => {\n    console.log('At least one failed:', error);\n  });\n\n// Promise.race - First one to finish\nPromise.race([promise1, promise2, promise3])\n  .then((result) => {\n    console.log('First result:', result);\n  });\n\n// Promise.withResolvers() - ES2024 new feature!\nlet { promise, resolve, reject } = Promise.withResolvers();\n\n// Can resolve/reject from anywhere\nsetTimeout(() => resolve('Done!'), 1000);\n\npromise.then(result => console.log(result));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Promise syntax:\n\n**Creating a Promise:**\n\nlet promise = new Promise((resolve, reject) => {\n                           │        │\n                           │        └─ Call when operation fails\n                           └────────── Call when operation succeeds\n  // Do async work\n  if (success) {\n    resolve(successValue);\n  } else {\n    reject(errorValue);\n  }\n});\n\n**Using a Promise:**\n\npromise\n  .then((result) => {\n    // Runs if promise resolves (success)\n    console.log(result);\n  })\n  .catch((error) => {\n    // Runs if promise rejects (failure)\n    console.log(error);\n  })\n  .finally(() => {\n    // Always runs (success or failure)\n    console.log('Done');\n  });\n\n**Promise States:**\n\n1. Pending - Initial state, not yet resolved or rejected\n2. Fulfilled - Operation completed successfully (resolve called)\n3. Rejected - Operation failed (reject called)\n\nOnce settled (fulfilled or rejected), state can't change!\n\n**Promise Chaining:**\n\nfetch('/api/user')\n  .then(response => response.json())  // Parse JSON\n  .then(user => {\n    console.log('User:', user);\n    return fetch('/api/posts/' + user.id);  // Next request\n  })\n  .then(response => response.json())\n  .then(posts => {\n    console.log('Posts:', posts);\n  })\n  .catch(error => {\n    console.log('Error anywhere in chain:', error);\n  });\n\n**Promise Utilities:**\n\n1. Promise.all([p1, p2, p3])\n   - Waits for ALL to resolve\n   - Rejects if ANY rejects\n   - Returns array of results\n\n2. Promise.race([p1, p2, p3])\n   - Returns when FIRST settles (resolve or reject)\n\n3. Promise.allSettled([p1, p2, p3])\n   - Waits for ALL to settle\n   - Never rejects\n   - Returns array of {status, value/reason}\n\n4. Promise.any([p1, p2, p3])\n   - Returns when FIRST resolves\n   - Rejects only if ALL reject\n\n5. Promise.withResolvers() - ES2024!\n   - Returns {promise, resolve, reject}\n   - Useful when you need to resolve/reject from outside\n\n**Error Handling:**\n\n// Catch errors\npromise.catch(error => console.log(error));\n\n// Or use second argument to then\npromise.then(\n  result => console.log(result),\n  error => console.log(error)\n);"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting to return a promise from a function:\n   function getData() {\n     new Promise((resolve) => { ... });  // WRONG - not returned!\n   }\n   \n   function getData() {\n     return new Promise((resolve) => { ... });  // CORRECT\n   }\n\n2. Not returning in .then() for chaining:\n   promise\n     .then(data => {\n       processData(data);  // Returns undefined!\n     })\n     .then(result => {\n       console.log(result);  // undefined\n     });\n   \n   Must return:\n   .then(data => {\n     return processData(data);\n   })\n\n3. Calling resolve/reject multiple times:\n   new Promise((resolve) => {\n     resolve('first');\n     resolve('second');  // Ignored!\n   });\n   // Only first resolve/reject counts\n\n4. Mixing callbacks and promises:\n   // Don't do this:\n   getData(function(result) {\n     // Old callback style mixed with promises\n   });\n   \n   // Use promises consistently\n\n5. Not catching errors:\n   fetch('/api/data')\n     .then(response => response.json());\n   // If error occurs, it's unhandled!\n   \n   Always add .catch():\n   fetch('/api/data')\n     .then(response => response.json())\n     .catch(error => console.log(error));"
            },
            {
              "type": "EXAMPLE",
              "title": "Promise.try() - Safe Error Handling",
              "content": "Promise.try() wraps any function and catches both sync AND async errors. This solves the problem where synchronous throws inside promise chains cause unhandled exceptions.",
              "language": "javascript",
              "code": "// BEFORE: Manual wrapping for sync errors\nfunction loadConfigOld(path) {\n  return Promise.resolve().then(() => {\n    if (!path) throw new Error('Path required');\n    return Bun.file(path).json();\n  });\n}\n\n// AFTER: Promise.try() handles sync errors elegantly\nfunction loadConfig(path) {\n  return Promise.try(() => {\n    if (!path) throw new Error('Path required');\n    return Bun.file(path).json();\n  });\n}\n\n// Usage - both sync and async errors are caught\nloadConfig(null)\n  .catch(err => console.log('Caught:', err.message));\n// Output: Caught: Path required"
            },
            {
              "type": "KEY_POINT",
              "title": "When to Use Promise.try()",
              "content": "Use `Promise.try()` when:\n\n1. **Your callback might throw synchronously** - Validation, parsing, etc.\n2. **You want consistent error handling** - All errors go to `.catch()`\n3. **Mixing sync and async code** - The callback can return a value OR a Promise\n\n```javascript\n// Works with sync returns\nPromise.try(() => 42).then(console.log); // 42\n\n// Works with async returns\nPromise.try(() => fetch('/api')).then(console.log); // Response\n\n// Works with sync throws\nPromise.try(() => { throw new Error('Oops'); }).catch(console.log); // Error: Oops\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Promise.withResolvers() - The Modern Way",
              "content": "ES2024 introduces `Promise.withResolvers()` which gives you the promise, resolve, and reject functions separately. This is cleaner than the traditional executor pattern.",
              "language": "javascript",
              "code": "// TRADITIONAL: Executor callback (still valid but verbose)\nfunction rollDiceOld() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(Math.floor(Math.random() * 6) + 1);\n    }, 1000);\n  });\n}\n\n// MODERN: Promise.withResolvers() (ES2024)\nfunction rollDice() {\n  const { promise, resolve } = Promise.withResolvers();\n  setTimeout(() => {\n    resolve(Math.floor(Math.random() * 6) + 1);\n  }, 1000);\n  return promise;\n}\n\n// Usage is identical\nrollDice().then(result => console.log('You rolled:', result));"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Traditional Promise Constructor",
              "legacy": "es2020",
              "content": "Before ES2024, you had to use the executor callback pattern. This is still valid and works everywhere, but Promise.withResolvers() is cleaner for complex cases where you need to pass resolve/reject to other functions.",
              "language": "javascript",
              "code": "// The executor pattern (pre-ES2024)\nconst promise = new Promise((resolve, reject) => {\n  // resolve and reject are only available here\n  doAsyncWork((err, result) => {\n    if (err) reject(err);\n    else resolve(result);\n  });\n});"
            },
            {
              "type": "KEY_POINT",
              "title": "Top-Level Await is the Standard",
              "content": "In ES modules (`.mjs` files or `\"type\": \"module\"` in package.json), you can use `await` at the top level without wrapping in an async function:\n\n```javascript\n// index.js (ESM module)\nconst config = await Bun.file('config.json').json();\nconst db = await connectDatabase(config.database);\n\nconsole.log('Server starting with config:', config.name);\n\nexport default {\n  port: config.port,\n  fetch: app.fetch,\n};\n```\n\n**This is now the standard pattern for:**\n- Server startup sequences\n- Loading configuration\n- Database connections\n- Any async initialization"
            },
            {
              "type": "EXAMPLE",
              "title": "Top-Level Await in Practice",
              "content": "No more IIFE (Immediately Invoked Function Expression) hacks!",
              "language": "javascript",
              "code": "// OLD WAY (pre-ESM): Wrap everything in async IIFE\n(async () => {\n  const data = await fetchData();\n  console.log(data);\n})();\n\n// NEW WAY (ESM): Just use await directly!\nconst data = await fetchData();\nconsole.log(data);\n\n// Real example: Server with Bun + Hono\nimport { Hono } from 'hono';\n\nconst config = await Bun.file('config.json').json();\nconst app = new Hono();\n\napp.get('/', (c) => c.text(`Running on port ${config.port}`));\n\nexport default {\n  port: config.port,\n  fetch: app.fetch,\n};"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "8.2-challenge",
              "title": "Practice Challenge",
              "description": "Create a function that simulates a dice roll:\n\nfunction rollDice() {\n  // Returns a promise that resolves after 1 second\n  // Resolves with a random number 1-6\n}\n\nUse it like:\nrollDice()\n  .then(result => console.log('Rolled:', result));\n\nHint: Use Math.floor(Math.random() * 6) + 1 for random 1-6",
              "instructions": "Create a function that simulates a dice roll:\n\nfunction rollDice() {\n  // Returns a promise that resolves after 1 second\n  // Resolves with a random number 1-6\n}\n\nUse it like:\nrollDice()\n  .then(result => console.log('Rolled:', result));\n\nHint: Use Math.floor(Math.random() * 6) + 1 for random 1-6",
              "starterCode": "function rollDice() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      // YOUR CODE: Generate random number 1-6 and resolve with it\n    }, 1000);\n  });\n}\n\n// Test it\nrollDice()\n  .then(result => {\n    console.log('You rolled:', result);\n  });",
              "solution": "function rollDice() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      let roll = Math.floor(Math.random() * 6) + 1;\n      resolve(roll);\n    }, 1000);\n  });\n}\n\nrollDice()\n  .then(result => {\n    console.log('You rolled:', result);\n  });",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Returns a number",
                  "expectedOutput": "4",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "let roll = Math.floor(Math.random() * 6) + 1; resolve(roll);"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting to return a promise from a function:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting to return a promise from a function:\n   function getData() {\n     new Promise((resolve) => { ... });  // WRONG - not returned!\n   }\n   \n   function getData() {\n     return new Promise((resolve) => { ... });  // CORRECT\n   }"
                },
                {
                  "mistake": "Not returning in .then() for chaining:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Not returning in .then() for chaining:\n   promise\n     .then(data => {\n       processData(data);  // Returns undefined!\n     })\n     .then(result => {\n       console.log(result);  // undefined\n     });\n   \n   Must return:\n   .then(data => {\n     return processData(data);\n   })"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "8.3",
          "title": "Import Attributes (The Customs Declaration Analogy)",
          "moduleId": "module-08",
          "order": 3,
          "estimatedMinutes": 20,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Customs Declaration",
              "content": "Imagine you're receiving packages at a shipping dock. Some packages contain food, others contain electronics, and some might even contain hazardous materials. You wouldn't want to handle them all the same way!\n\nImport Attributes work like customs declarations. When you import a file, you tell JavaScript EXACTLY what type of content you're expecting. This prevents security issues where a .json file could secretly contain executable code."
            },
            {
              "type": "EXAMPLE",
              "title": "Import Attributes Syntax",
              "content": "Use the `with` keyword to declare what type of content you're importing:",
              "language": "javascript",
              "code": "// Import JSON with type assertion\nimport config from './config.json' with { type: 'json' };\nimport packageJson from '../package.json' with { type: 'json' };\n\nconsole.log(`Running ${packageJson.name} v${packageJson.version}`);\nconsole.log(`Database: ${config.database.host}`);\n\n// Import CSS (browser/bundler contexts)\nimport styles from './styles.css' with { type: 'css' };\n\n// Dynamic import with attributes\nconst data = await import('./data.json', { with: { type: 'json' } });"
            },
            {
              "type": "THEORY",
              "title": "Why Import Attributes Matter",
              "content": "Import Attributes (ES2025) solve three problems:\n\n**1. Security**\n```javascript\n// Without attributes - what if evil.json contains executable code?\nimport data from './evil.json';  // DANGEROUS\n\n// With attributes - JavaScript enforces it's ONLY JSON\nimport data from './evil.json' with { type: 'json' };  // SAFE\n```\n\n**2. Clarity**\nAnyone reading your code knows exactly what type of file you're importing.\n\n**3. Portability**\nThe same syntax works across Bun, Node.js, Deno, and browsers. No more runtime-specific import hacks!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "1. **Forgetting the `with` keyword**: It's `with { type: 'json' }`, not `as json` or `type: 'json'`\n\n2. **Wrong type value**: The type must match the file content. `{ type: 'json' }` for JSON, `{ type: 'css' }` for CSS.\n\n3. **Dynamic imports use different syntax**:\n```javascript\n// Static import\nimport data from './data.json' with { type: 'json' };\n\n// Dynamic import - note the nested object\nconst data = await import('./data.json', { with: { type: 'json' } });\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "8.3-challenge",
              "title": "Import Configuration Safely",
              "description": "Import the config.json file using Import Attributes and log the app name.",
              "instructions": "Import the config.json file using Import Attributes and log the app name.",
              "starterCode": "// Import config.json with proper type attribute\n// YOUR CODE HERE\n\nconsole.log(config.appName);",
              "solution": "import config from './config.json' with { type: 'json' };\n\nconsole.log(config.appName);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Uses import with type attribute",
                  "expectedOutput": "MyApp",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the 'with' keyword after the import path: with { type: 'json' }"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using require() instead of import",
                  "consequence": "require() is CommonJS and doesn't support Import Attributes",
                  "correction": "import config from './config.json' with { type: 'json' };"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "cjs-esm-interop",
          "title": "CommonJS vs ES Modules: Understanding Both Worlds",
          "moduleId": "module-08",
          "order": 4,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "CONCEPT",
              "title": "The Two Module Systems",
              "content": "JavaScript has a unique challenge in the programming world: it evolved with TWO competing module systems, each with its own syntax, behavior, and ecosystem. Understanding both is essential for any modern JavaScript developer.\n\n**CommonJS (CJS)** - Born in 2009 for Node.js\nWhen Node.js was created, JavaScript had no native module system. Ryan Dahl needed a way to organize server-side code, so CommonJS was invented. It uses `require()` to import and `module.exports` to export. CommonJS modules load SYNCHRONOUSLY - the entire file is read and executed before the next line runs. This works great on servers where files are local, but would freeze browsers waiting for network requests.\n\n**ES Modules (ESM)** - The Official Standard (ES2015/ES6)\nIn 2015, JavaScript finally got an official module system as part of the ES6 specification. It uses `import` and `export` keywords. ESM modules are STATIC - imports are analyzed at parse time before code runs. This enables tree-shaking (removing unused code) and better optimization. ESM also supports asynchronous loading, making it perfect for browsers.\n\n**The Current State (2024-2025)**\nToday, ESM is the clear winner and the future of JavaScript. Node.js has full ESM support since v12. All modern browsers support ESM natively. New projects should use ESM by default. However, millions of npm packages still use CommonJS, so understanding interoperability is crucial. Bun, Deno, and modern bundlers all prefer ESM but maintain CJS compatibility."
            },
            {
              "type": "CODE",
              "title": "CommonJS Syntax (require/exports)",
              "content": "CommonJS is the traditional Node.js module system. It uses the `require()` function to import modules and `module.exports` or `exports` to expose functionality. Understanding this syntax is essential because many npm packages still use it.",
              "language": "javascript",
              "code": "// ============================================\n// EXPORTING IN COMMONJS\n// ============================================\n\n// math.js - Exporting multiple values\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction subtract(a, b) {\n  return a - b;\n}\n\n// Method 1: Assign to module.exports object\nmodule.exports = {\n  add: add,\n  subtract: subtract\n};\n\n// Method 2: Shorthand with ES6 property shorthand\nmodule.exports = { add, subtract };\n\n// Method 3: Add properties individually\nmodule.exports.add = add;\nmodule.exports.subtract = subtract;\n\n// Method 4: Using exports shorthand (same as module.exports)\nexports.add = add;\nexports.subtract = subtract;\n\n// WARNING: This BREAKS exports (reassigning the reference)\nexports = { add, subtract }; // WRONG! This doesn't work!\n\n// ============================================\n// EXPORTING A SINGLE VALUE (Default-like)\n// ============================================\n\n// logger.js - Single export\nclass Logger {\n  log(message) {\n    console.log(`[LOG]: ${message}`);\n  }\n}\n\nmodule.exports = Logger; // Export the class itself\n\n// ============================================\n// IMPORTING IN COMMONJS\n// ============================================\n\n// app.js - Importing modules\n\n// Import the entire module object\nconst math = require('./math.js');\nconsole.log(math.add(2, 3)); // 5\nconsole.log(math.subtract(5, 2)); // 3\n\n// Destructure during import\nconst { add, subtract } = require('./math.js');\nconsole.log(add(2, 3)); // 5\n\n// Import single export\nconst Logger = require('./logger.js');\nconst logger = new Logger();\nlogger.log('Hello!'); // [LOG]: Hello!\n\n// ============================================\n// MODULE RESOLUTION\n// ============================================\n\n// Relative paths (your own files)\nconst utils = require('./utils');      // ./utils.js\nconst config = require('../config');   // ../config.js\nconst data = require('./data/users');  // ./data/users.js\n\n// Node modules (from node_modules folder)\nconst express = require('express');    // node_modules/express\nconst lodash = require('lodash');      // node_modules/lodash\n\n// Built-in Node.js modules\nconst fs = require('fs');              // File system\nconst path = require('path');          // Path utilities\nconst http = require('http');          // HTTP server\n\n// Node.js 16+ recommends 'node:' prefix for built-ins\nconst fs = require('node:fs');\nconst path = require('node:path');"
            },
            {
              "type": "CODE",
              "title": "ES Modules Syntax (import/export)",
              "content": "ES Modules (ESM) is the official JavaScript module standard. It offers cleaner syntax, static analysis for optimization, and native browser support. This is the modern way to write JavaScript modules and should be your default choice for new projects.",
              "language": "javascript",
              "code": "// ============================================\n// NAMED EXPORTS\n// ============================================\n\n// math.js - Multiple named exports\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function subtract(a, b) {\n  return a - b;\n}\n\nexport const PI = 3.14159;\n\n// Or export at the end (equivalent)\nfunction multiply(a, b) {\n  return a * b;\n}\nconst E = 2.71828;\nexport { multiply, E };\n\n// Export with renaming\nexport { multiply as mult, E as EULER };\n\n// ============================================\n// DEFAULT EXPORTS\n// ============================================\n\n// logger.js - Default export (one per file)\nexport default class Logger {\n  log(message) {\n    console.log(`[LOG]: ${message}`);\n  }\n}\n\n// Alternative: export default at the end\nclass Calculator {\n  add(a, b) { return a + b; }\n}\nexport default Calculator;\n\n// Can combine default with named exports\nexport default class User {}\nexport function createUser() {}\nexport const DEFAULT_ROLE = 'guest';\n\n// ============================================\n// IMPORTING NAMED EXPORTS\n// ============================================\n\n// Import specific exports\nimport { add, subtract } from './math.js';\nconsole.log(add(2, 3)); // 5\n\n// Import with renaming\nimport { add as sum, PI } from './math.js';\nconsole.log(sum(2, 3)); // 5\n\n// Import all as namespace object\nimport * as math from './math.js';\nconsole.log(math.add(2, 3)); // 5\nconsole.log(math.PI); // 3.14159\n\n// ============================================\n// IMPORTING DEFAULT EXPORTS\n// ============================================\n\n// Default import (no curly braces, any name works)\nimport Logger from './logger.js';\nimport MyLogger from './logger.js'; // Same thing, different name\n\nconst logger = new Logger();\n\n// Combine default and named imports\nimport User, { createUser, DEFAULT_ROLE } from './user.js';\n\n// ============================================\n// RE-EXPORTS (Barrel Exports)\n// ============================================\n\n// index.js - Re-export from other modules\nexport { add, subtract } from './math.js';\nexport { default as Logger } from './logger.js';\nexport * from './utils.js'; // Re-export everything\n\n// Now consumers can import from one place:\nimport { add, Logger } from './index.js';\n\n// ============================================\n// DYNAMIC IMPORTS\n// ============================================\n\n// Load module at runtime (returns Promise)\nconst module = await import('./heavy-module.js');\nmodule.doSomething();\n\n// Conditional loading\nif (needsFeature) {\n  const { feature } = await import('./feature.js');\n  feature();\n}\n\n// With destructuring\nconst { add, subtract } = await import('./math.js');"
            },
            {
              "type": "CODE",
              "title": "package.json Configuration",
              "content": "The package.json file controls how Node.js interprets your modules. The `type` field determines whether .js files are treated as CommonJS or ES Modules. Understanding this configuration is essential for avoiding confusing module errors.",
              "language": "json",
              "code": "// ============================================\n// BASIC MODULE TYPE CONFIGURATION\n// ============================================\n\n// package.json - ES Modules project (RECOMMENDED for new projects)\n{\n  \"name\": \"my-esm-project\",\n  \"type\": \"module\",\n  \"version\": \"1.0.0\"\n}\n// With \"type\": \"module\":\n//   - .js files are treated as ES Modules\n//   - Use import/export syntax\n//   - Use .cjs extension for CommonJS files\n\n// package.json - CommonJS project (legacy default)\n{\n  \"name\": \"my-cjs-project\",\n  \"type\": \"commonjs\",\n  \"version\": \"1.0.0\"\n}\n// With \"type\": \"commonjs\" (or no type field):\n//   - .js files are treated as CommonJS\n//   - Use require/module.exports syntax\n//   - Use .mjs extension for ES Module files\n\n// ============================================\n// FILE EXTENSIONS OVERRIDE package.json\n// ============================================\n\n// .mjs - ALWAYS ES Module (regardless of package.json)\nimport { something } from './other.mjs';\nexport const value = 42;\n\n// .cjs - ALWAYS CommonJS (regardless of package.json)\nconst something = require('./other.cjs');\nmodule.exports = { value: 42 };\n\n// .js - Determined by nearest package.json \"type\" field\n\n// ============================================\n// THE \"exports\" FIELD (Modern Package Authoring)\n// ============================================\n\n// package.json - Modern package with exports field\n{\n  \"name\": \"my-library\",\n  \"version\": \"2.0.0\",\n  \"type\": \"module\",\n  \n  // Main entry (legacy, still useful for older tools)\n  \"main\": \"./dist/index.cjs\",\n  \n  // Module entry (for bundlers)\n  \"module\": \"./dist/index.mjs\",\n  \n  // Exports field (Node.js 12+, recommended)\n  \"exports\": {\n    // Main entry point\n    \".\": {\n      \"import\": \"./dist/index.mjs\",\n      \"require\": \"./dist/index.cjs\",\n      \"types\": \"./dist/index.d.ts\"\n    },\n    // Subpath exports\n    \"./utils\": {\n      \"import\": \"./dist/utils.mjs\",\n      \"require\": \"./dist/utils.cjs\"\n    },\n    // Pattern exports\n    \"./components/*\": \"./dist/components/*.js\"\n  },\n  \n  // TypeScript types\n  \"types\": \"./dist/index.d.ts\"\n}\n\n// Usage by consumers:\nimport lib from 'my-library';           // Uses exports[\".\"]\nimport { helper } from 'my-library/utils'; // Uses exports[\"./utils\"]"
            },
            {
              "type": "CODE",
              "title": "Importing CJS from ESM",
              "content": "When working in ES Modules, you will often need to import CommonJS packages. Node.js provides good interoperability, but there are some gotchas to understand. Most npm packages are still CommonJS, so this knowledge is essential.",
              "language": "javascript",
              "code": "// ============================================\n// BASIC CJS IMPORT IN ESM\n// ============================================\n\n// Most CJS packages work with default import\nimport express from 'express';        // CJS package\nimport lodash from 'lodash';          // CJS package\nimport chalk from 'chalk';            // CJS package\n\nconst app = express();\nconst result = lodash.chunk([1, 2, 3, 4], 2);\n\n// ============================================\n// THE DEFAULT EXPORT GOTCHA\n// ============================================\n\n// CJS module (old-package.js)\nmodule.exports = {\n  foo: 'bar',\n  doSomething: function() {}\n};\n\n// In ESM, this becomes the DEFAULT export\nimport pkg from 'old-package';\nconsole.log(pkg.foo);      // 'bar'\npkg.doSomething();\n\n// Named imports MAY work (Node.js tries to detect them)\nimport { foo, doSomething } from 'old-package'; // Sometimes works!\n\n// But this is NOT guaranteed - depends on how CJS exports\n// When in doubt, use default import and destructure:\nimport pkg from 'old-package';\nconst { foo, doSomething } = pkg;\n\n// ============================================\n// USING createRequire() FOR ADVANCED CASES\n// ============================================\n\nimport { createRequire } from 'node:module';\nconst require = createRequire(import.meta.url);\n\n// Now you can use require() in ESM!\nconst cjsModule = require('./legacy-module.cjs');\nconst jsonData = require('./data.json'); // Before import attributes\n\n// Useful for:\n// - Loading JSON (before ES2025 Import Attributes)\n// - CJS modules with complex exports\n// - __dirname/__filename equivalents\n\n// ============================================\n// DYNAMIC IMPORT FOR CJS MODULES\n// ============================================\n\n// Dynamic import always works with CJS\nconst cjsModule = await import('cjs-package');\nconsole.log(cjsModule.default); // The module.exports value\n\n// Destructure if needed\nconst { default: pkg } = await import('cjs-package');\nconst { foo, bar } = pkg;\n\n// ============================================\n// COMMON INTEROP PATTERNS\n// ============================================\n\n// Pattern 1: Default import + destructure (safest)\nimport pkg from 'cjs-package';\nconst { methodA, methodB } = pkg;\n\n// Pattern 2: Try named imports first, fall back to default\ntry {\n  // This might work if Node.js detects named exports\n  const { specificMethod } = await import('cjs-package');\n} catch {\n  const pkg = await import('cjs-package');\n  const { specificMethod } = pkg.default;\n}\n\n// Pattern 3: Namespace import for exploration\nimport * as pkg from 'cjs-package';\nconsole.log(Object.keys(pkg)); // See what's available\nconsole.log(pkg.default);      // The actual CJS exports"
            },
            {
              "type": "CODE",
              "title": "Node.js 22+ require(esm) Support",
              "content": "Node.js 22 introduced a groundbreaking feature: the ability to require() ES Modules from CommonJS code! This makes migration easier and improves interoperability. However, there are important limitations to understand.",
              "language": "javascript",
              "code": "// ============================================\n// THE NEW require(esm) FEATURE (Node.js 22+)\n// ============================================\n\n// esm-module.mjs (or .js with \"type\": \"module\")\nexport function greet(name) {\n  return `Hello, ${name}!`;\n}\n\nexport default class User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// cjs-consumer.cjs - NOW YOU CAN require() ESM!\nconst esmModule = require('./esm-module.mjs');\n\nconsole.log(esmModule.greet('World')); // Hello, World!\n\nconst User = esmModule.default;\nconst user = new User('Alice');\n\n// ============================================\n// HOW IT WORKS\n// ============================================\n\n// Node.js 22 loads ESM synchronously when required\n// This is possible because the module is evaluated eagerly\n\n// Named exports become properties on the required object\nconst { greet, default: User } = require('./esm-module.mjs');\n\n// ============================================\n// LIMITATIONS: NO TOP-LEVEL AWAIT\n// ============================================\n\n// This ESM module CANNOT be required:\n// async-module.mjs\nconst data = await fetch('https://api.example.com/data');\nexport const config = await loadConfig();\nexport default data;\n\n// Trying to require it throws an error!\n// const mod = require('./async-module.mjs'); \n// Error: Cannot require() ES Module with top-level await\n\n// ============================================\n// DETECTION AND COMPATIBILITY\n// ============================================\n\n// Check if require(esm) is supported\nfunction canRequireESM() {\n  try {\n    // Node.js 22+ supports this\n    const [major] = process.versions.node.split('.');\n    return parseInt(major) >= 22;\n  } catch {\n    return false;\n  }\n}\n\n// Conditional loading pattern\nlet esmModule;\nif (canRequireESM()) {\n  esmModule = require('./module.mjs');\n} else {\n  // Fallback for older Node.js\n  esmModule = await import('./module.mjs');\n}\n\n// ============================================\n// PRACTICAL MIGRATION SCENARIO\n// ============================================\n\n// Before Node.js 22: Dynamic import required in CJS\n// old-way.cjs\nasync function loadESM() {\n  const { greet } = await import('./esm-module.mjs');\n  return greet('World');\n}\n\n// Node.js 22+: Direct require works!\n// new-way.cjs\nconst { greet } = require('./esm-module.mjs');\nconsole.log(greet('World')); // Synchronous, no async needed!"
            },
            {
              "type": "CODE",
              "title": "Dual Package Authoring",
              "content": "If you are publishing a library to npm, you may want to support both CommonJS and ES Module consumers. This is called dual package authoring. The package.json exports field with conditional exports makes this possible.",
              "language": "javascript",
              "code": "// ============================================\n// DUAL PACKAGE STRUCTURE\n// ============================================\n\n// my-library/\n// ├── package.json\n// ├── src/\n// │   └── index.js         (Source code)\n// ├── dist/\n// │   ├── index.mjs        (ES Module build)\n// │   ├── index.cjs        (CommonJS build)\n// │   └── index.d.ts       (TypeScript types)\n// └── README.md\n\n// ============================================\n// package.json WITH CONDITIONAL EXPORTS\n// ============================================\n\n{\n  \"name\": \"my-awesome-library\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.mjs\",\n      \"require\": \"./dist/index.cjs\",\n      \"default\": \"./dist/index.mjs\"\n    },\n    \"./utils\": {\n      \"types\": \"./dist/utils.d.ts\",\n      \"import\": \"./dist/utils.mjs\",\n      \"require\": \"./dist/utils.cjs\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \n  \"files\": [\"dist\"],\n  \n  \"scripts\": {\n    \"build\": \"tsup src/index.ts --format cjs,esm --dts\",\n    \"build:watch\": \"tsup src/index.ts --format cjs,esm --dts --watch\"\n  }\n}\n\n// ============================================\n// CONDITION ORDER MATTERS!\n// ============================================\n\n// Node.js checks conditions in order, uses first match\n\"exports\": {\n  \".\": {\n    // TypeScript should come first (for tooling)\n    \"types\": \"./dist/index.d.ts\",\n    \n    // Bun-specific (if needed)\n    \"bun\": \"./dist/index.bun.js\",\n    \n    // Deno-specific (if needed)  \n    \"deno\": \"./dist/index.deno.js\",\n    \n    // ES Module consumers (import)\n    \"import\": \"./dist/index.mjs\",\n    \n    // CommonJS consumers (require)\n    \"require\": \"./dist/index.cjs\",\n    \n    // Fallback (should be last)\n    \"default\": \"./dist/index.mjs\"\n  }\n}\n\n// ============================================\n// BUILD TOOLS FOR DUAL PACKAGES\n// ============================================\n\n// Using tsup (recommended, simple)\n// tsup.config.ts\nimport { defineConfig } from 'tsup';\n\nexport default defineConfig({\n  entry: ['src/index.ts'],\n  format: ['cjs', 'esm'],\n  dts: true,\n  clean: true,\n  splitting: false,\n  sourcemap: true\n});\n\n// Using esbuild\nimport * as esbuild from 'esbuild';\n\n// ESM build\nawait esbuild.build({\n  entryPoints: ['src/index.ts'],\n  bundle: true,\n  format: 'esm',\n  outfile: 'dist/index.mjs'\n});\n\n// CJS build\nawait esbuild.build({\n  entryPoints: ['src/index.ts'],\n  bundle: true,\n  format: 'cjs',\n  outfile: 'dist/index.cjs'\n});\n\n// ============================================\n// CONSUMERS USE IT SEAMLESSLY\n// ============================================\n\n// ESM consumer\nimport { myFunction } from 'my-awesome-library';\nimport { helper } from 'my-awesome-library/utils';\n\n// CJS consumer  \nconst { myFunction } = require('my-awesome-library');\nconst { helper } = require('my-awesome-library/utils');\n\n// TypeScript consumer (types just work!)\nimport { myFunction } from 'my-awesome-library';\n// Hover shows: function myFunction(arg: string): number"
            },
            {
              "type": "PITFALLS",
              "title": "Common Interop Issues",
              "content": "Module interoperability is one of the trickiest areas in JavaScript. Here are the most common issues developers encounter and how to solve them.\n\n**1. Default Export Confusion (CJS to ESM)**\nWhen importing a CommonJS module into ESM, the entire `module.exports` becomes the default export. If the CJS module exports an object with methods, you must access them through the default:\n```javascript\n// WRONG: Named import from CJS often fails\nimport { method } from 'cjs-package'; // May not work!\n\n// RIGHT: Default import, then destructure\nimport pkg from 'cjs-package';\nconst { method } = pkg;\n```\n\n**2. Top-Level Await Only Works in ESM**\nYou cannot use `await` at the top level of a CommonJS module. This is ESM-only:\n```javascript\n// ESM (works)\nconst data = await fetchData();\nexport { data };\n\n// CJS (ERROR!)\nconst data = await fetchData(); // SyntaxError!\nmodule.exports = { data };\n```\n\n**3. __dirname and __filename Not Available in ESM**\nESM does not have the CommonJS globals. Use `import.meta.url` instead:\n```javascript\n// CJS\nconsole.log(__dirname);  // /path/to/directory\nconsole.log(__filename); // /path/to/file.js\n\n// ESM - use import.meta\nimport { fileURLToPath } from 'node:url';\nimport { dirname } from 'node:path';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n// Or use import.meta.dirname (Node.js 20.11+)\nconsole.log(import.meta.dirname);  // /path/to/directory\nconsole.log(import.meta.filename); // /path/to/file.js\n```\n\n**4. Named Imports from CJS May Not Work**\nNode.js attempts to detect named exports from CJS, but it is not always possible:\n```javascript\n// If CJS does: module.exports = function() {}\nimport fn from 'pkg';     // Works (default)\nimport { fn } from 'pkg'; // FAILS!\n\n// If CJS does: exports.fn = function() {}\nimport { fn } from 'pkg'; // Usually works\n```\n\n**5. Circular Dependencies Behave Differently**\nCJS gives you a partially-initialized object during circular imports. ESM gives you a live binding that updates when the export is set. This can cause subtle bugs when migrating.\n\n**6. JSON Imports Differ Between Systems**\n```javascript\n// CJS - works directly\nconst pkg = require('./package.json');\n\n// ESM (pre-ES2025) - needs createRequire or flag\nimport { createRequire } from 'node:module';\nconst require = createRequire(import.meta.url);\nconst pkg = require('./package.json');\n\n// ESM (ES2025+) - use Import Attributes\nimport pkg from './package.json' with { type: 'json' };\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "cjs-esm-challenge-1",
              "title": "Module Migration",
              "description": "Convert this CommonJS module to ES Module syntax. The module exports a Calculator class with add and subtract methods.",
              "instructions": "Convert the following CommonJS module to ES Module syntax:\n\n```javascript\n// calculator.cjs (CommonJS)\nclass Calculator {\n  add(a, b) {\n    return a + b;\n  }\n  \n  subtract(a, b) {\n    return a - b;\n  }\n}\n\nfunction multiply(a, b) {\n  return a * b;\n}\n\nmodule.exports = Calculator;\nmodule.exports.multiply = multiply;\n```\n\nRewrite this as an ES Module with Calculator as the default export and multiply as a named export.",
              "starterCode": "// calculator.mjs (ES Module)\n// Convert the CommonJS module to ESM syntax\n// - Calculator should be the default export\n// - multiply should be a named export\n\nclass Calculator {\n  add(a, b) {\n    return a + b;\n  }\n  \n  subtract(a, b) {\n    return a - b;\n  }\n}\n\nfunction multiply(a, b) {\n  return a * b;\n}\n\n// YOUR EXPORTS HERE",
              "solution": "// calculator.mjs (ES Module)\nclass Calculator {\n  add(a, b) {\n    return a + b;\n  }\n  \n  subtract(a, b) {\n    return a - b;\n  }\n}\n\nexport function multiply(a, b) {\n  return a * b;\n}\n\nexport default Calculator;\n\n// Usage:\n// import Calculator, { multiply } from './calculator.mjs';\n// const calc = new Calculator();\n// console.log(calc.add(2, 3));    // 5\n// console.log(multiply(4, 5));    // 20",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Has default export for Calculator class",
                  "expectedOutput": "export default Calculator",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Has named export for multiply function",
                  "expectedOutput": "export function multiply",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'export default ClassName' for the main export and 'export function name()' for named exports"
                },
                {
                  "level": 2,
                  "text": "You can either add 'export' before the function definition or use 'export { multiply }' at the end"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using module.exports in ES Modules",
                  "consequence": "ES Modules use export/export default syntax, not module.exports",
                  "correction": "Replace 'module.exports = X' with 'export default X' and 'module.exports.y = y' with 'export { y }'"
                },
                {
                  "mistake": "Forgetting to add 'export' keyword",
                  "consequence": "Functions and classes are not accessible outside the module",
                  "correction": "Add 'export' before function/class or use 'export { name }' at the end"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "cjs-esm-challenge-2",
              "title": "Dual Package Setup",
              "description": "Create a package.json with conditional exports that supports both ESM and CommonJS consumers.",
              "instructions": "Create a package.json for a library called 'my-utils' that:\n1. Has type: 'module' (ESM by default)\n2. Uses the exports field with conditional exports\n3. Points ESM consumers (import) to './dist/index.mjs'\n4. Points CJS consumers (require) to './dist/index.cjs'\n5. Points TypeScript (types) to './dist/index.d.ts'\n6. Also exports a './helpers' subpath with the same pattern",
              "starterCode": "// Create the package.json content\nconst packageJson = {\n  \"name\": \"my-utils\",\n  \"version\": \"1.0.0\",\n  // Add your configuration here\n  \n};\n\nconsole.log(JSON.stringify(packageJson, null, 2));",
              "solution": "const packageJson = {\n  \"name\": \"my-utils\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.mjs\",\n      \"require\": \"./dist/index.cjs\"\n    },\n    \"./helpers\": {\n      \"types\": \"./dist/helpers.d.ts\",\n      \"import\": \"./dist/helpers.mjs\",\n      \"require\": \"./dist/helpers.cjs\"\n    }\n  }\n};\n\nconsole.log(JSON.stringify(packageJson, null, 2));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Has type: module",
                  "expectedOutput": "\"type\": \"module\"",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Has exports field with import condition",
                  "expectedOutput": "\"import\":",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Has exports field with require condition",
                  "expectedOutput": "\"require\":",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "The exports field uses \".\" for the main entry and \"./subpath\" for subpaths"
                },
                {
                  "level": 2,
                  "text": "Each export should have 'types', 'import', and 'require' conditions in that order"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Wrong condition order in exports",
                  "consequence": "TypeScript types may not be found or wrong module format used",
                  "correction": "Order should be: types, import, require (or types first, then more specific to less specific)"
                },
                {
                  "mistake": "Missing the dot in main export path",
                  "consequence": "Main entry point not properly defined",
                  "correction": "Use \".\" for the main entry, not \"\" or \"index\""
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "cjs-esm-challenge-3",
              "title": "CJS Interop",
              "description": "Import a CommonJS package correctly in ES Module code and handle the default export pattern.",
              "instructions": "You are in an ES Module file and need to import from a CommonJS package called 'legacy-utils'. The CJS package exports:\n```javascript\nmodule.exports = {\n  formatDate: function(date) { ... },\n  parseDate: function(str) { ... },\n  VERSION: '1.0.0'\n};\n```\n\nWrite code that:\n1. Imports the package correctly\n2. Extracts formatDate and VERSION\n3. Uses formatDate to format today's date\n4. Logs the VERSION",
              "starterCode": "// Import the CJS package 'legacy-utils' in ESM\n// Hint: CJS module.exports becomes the default export\n\n// YOUR IMPORT HERE\n\n// Extract formatDate and VERSION\n// YOUR DESTRUCTURING HERE\n\n// Use the imported functions\nconst today = new Date();\nconst formatted = formatDate(today);\nconsole.log('Formatted date:', formatted);\nconsole.log('Version:', VERSION);",
              "solution": "// Import the CJS package 'legacy-utils' in ESM\n// CJS module.exports becomes the default export\nimport legacyUtils from 'legacy-utils';\n\n// Extract formatDate and VERSION from the default export\nconst { formatDate, VERSION } = legacyUtils;\n\n// Use the imported functions\nconst today = new Date();\nconst formatted = formatDate(today);\nconsole.log('Formatted date:', formatted);\nconsole.log('Version:', VERSION);\n\n// Alternative: single line with default import + destructure\n// import pkg from 'legacy-utils';\n// const { formatDate, VERSION } = pkg;",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Uses default import for CJS package",
                  "expectedOutput": "import",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Destructures the needed exports",
                  "expectedOutput": "formatDate",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "When a CJS module uses module.exports = {...}, the whole object becomes the default export in ESM"
                },
                {
                  "level": 2,
                  "text": "Import with: import pkg from 'package'; then destructure: const { fn } = pkg;"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Trying to use named imports directly from CJS",
                  "consequence": "import { formatDate } from 'legacy-utils' may fail or return undefined",
                  "correction": "Use default import first, then destructure: import pkg from 'pkg'; const { fn } = pkg;"
                },
                {
                  "mistake": "Using require() in ES Module",
                  "consequence": "require is not defined in ES Modules",
                  "correction": "Use import syntax, or createRequire() from 'node:module' if require() is absolutely needed"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "8.5",
          "title": "The Modern, Clean Way (async and await)",
          "moduleId": "module-08",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Promises are like getting a tracking number for your package:\n\n**Promises (.then)**: You keep checking the tracking number and saying 'THEN when it arrives, THEN I'll open it, THEN I'll use it, THEN I'll write a review...'\n\n**async/await**: You just wait at the door for the package to arrive, open it when it comes, use it, write review - one step at a time, in order. More natural!\n\nasync/await is syntactic sugar over Promises. It makes asynchronous code LOOK and READ like synchronous code, while still being non-blocking. It's the modern, preferred way to handle async operations."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// OLD WAY: Promises with .then()\nfunction getUser() {\n  fetchUser(1)\n    .then(user => {\n      console.log('User:', user);\n      return fetchPosts(user.id);\n    })\n    .then(posts => {\n      console.log('Posts:', posts);\n    })\n    .catch(error => {\n      console.log('Error:', error);\n    });\n}\n\n// NEW WAY: async/await (same thing, cleaner!)\nasync function getUser() {\n  try {\n    let user = await fetchUser(1);\n    console.log('User:', user);\n    \n    let posts = await fetchPosts(user.id);\n    console.log('Posts:', posts);\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}\n\n// async function returns a Promise\nasync function getData() {\n  return 'Hello';  // Automatically wrapped in Promise.resolve()\n}\n\ngetData().then(result => console.log(result));  // Hello\n\n// await pauses until Promise resolves\nasync function example() {\n  console.log('Start');\n  \n  let result = await someAsyncOperation();  // Waits here\n  console.log('Result:', result);  // Runs after promise resolves\n  \n  console.log('End');\n}\n\n// Multiple awaits in sequence\nasync function sequential() {\n  let user = await fetchUser(1);  // Wait for this\n  let posts = await fetchPosts(user.id);  // Then wait for this\n  let comments = await fetchComments(posts[0].id);  // Then wait for this\n  return { user, posts, comments };\n}\n\n// Multiple awaits in parallel (faster!)\nasync function parallel() {\n  // Start all at once\n  let userPromise = fetchUser(1);\n  let postsPromise = fetchPosts(1);\n  let commentsPromise = fetchComments(1);\n  \n  // Wait for all to finish\n  let user = await userPromise;\n  let posts = await postsPromise;\n  let comments = await commentsPromise;\n  \n  return { user, posts, comments };\n}\n\n// Or use Promise.all\nasync function parallelAll() {\n  let [user, posts, comments] = await Promise.all([\n    fetchUser(1),\n    fetchPosts(1),\n    fetchComments(1)\n  ]);\n  return { user, posts, comments };\n}\n\n// Error handling\nasync function withErrorHandling() {\n  try {\n    let data = await riskyOperation();\n    return data;\n  } catch (error) {\n    console.log('Caught error:', error);\n    return null;\n  }\n}\n\n// Can only use await inside async function\n// This is WRONG:\nfunction normal() {\n  let result = await fetchData();  // ERROR!\n}\n\n// This is CORRECT:\nasync function async() {\n  let result = await fetchData();  // Works!\n}\n\n// Top-level await (ES2022 - in modules only)\nawait fetchData();  // Now works at module top level!"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "async/await syntax:\n\n**async function:**\n\nasync function functionName() {\n│     │\n│     └─ Makes function asynchronous\n└─────── async keyword required\n  // Can use 'await' inside\n}\n\n// async function automatically returns a Promise\nasync function getName() {\n  return 'Alice';  // Becomes Promise.resolve('Alice')\n}\n\n// These are equivalent:\nasync function a() { return 'Hi'; }\nfunction b() { return Promise.resolve('Hi'); }\n\n**await keyword:**\n\nlet result = await promise;\n│            │     │\n│            │     └─ A Promise\n│            └─────── await keyword (pauses until resolved)\n└──────────────────── Result of the promise\n\nRules for await:\n1. Can ONLY be used inside async functions (or module top-level)\n2. Pauses function execution until Promise resolves\n3. Returns the resolved value\n4. Throws if Promise rejects (use try/catch)\n\n**Error Handling:**\n\n// Promises:\npromise\n  .then(result => { })\n  .catch(error => { });\n\n// async/await:\ntry {\n  let result = await promise;\n} catch (error) {\n  // Handle error\n}\n\n**Sequential vs Parallel:**\n\n// Sequential (one after another - SLOW)\nasync function sequential() {\n  let a = await fetchA();  // Wait 1 second\n  let b = await fetchB();  // Wait 1 second\n  // Total: 2 seconds\n}\n\n// Parallel (at same time - FAST)\nasync function parallel() {\n  let [a, b] = await Promise.all([\n    fetchA(),  // Both start at same time\n    fetchB()\n  ]);\n  // Total: 1 second (whichever is slower)\n}\n\n**Common Patterns:**\n\n1. Simple fetch:\n   async function getData() {\n     let response = await fetch('/api/data');\n     let data = await response.json();\n     return data;\n   }\n\n2. With error handling:\n   async function getData() {\n     try {\n       let response = await fetch('/api/data');\n       if (!response.ok) throw new Error('Failed');\n       return await response.json();\n     } catch (error) {\n       console.log('Error:', error);\n       return null;\n     }\n   }\n\n3. Multiple parallel requests:\n   async function getAll() {\n     let [users, posts, comments] = await Promise.all([\n       fetch('/api/users').then(r => r.json()),\n       fetch('/api/posts').then(r => r.json()),\n       fetch('/api/comments').then(r => r.json())\n     ]);\n     return { users, posts, comments };\n   }"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Forgetting 'async' keyword:\n   function getData() {\n     let result = await fetch();  // ERROR!\n   }\n   \n   Must be:\n   async function getData() {\n     let result = await fetch();\n   }\n\n2. Not awaiting Promises:\n   async function getData() {\n     let data = fetchData();  // data is a Promise!\n     console.log(data.name);  // undefined!\n   }\n   \n   Must await:\n   async function getData() {\n     let data = await fetchData();\n     console.log(data.name);  // Works!\n   }\n\n3. Sequential when could be parallel:\n   // SLOW (3 seconds total):\n   async function slow() {\n     let a = await fetchA();  // 1s\n     let b = await fetchB();  // 1s\n     let c = await fetchC();  // 1s\n   }\n   \n   // FAST (1 second total):\n   async function fast() {\n     let [a, b, c] = await Promise.all([\n       fetchA(),\n       fetchB(),\n       fetchC()\n     ]);  // All at once!\n   }\n\n4. Not handling errors:\n   async function getData() {\n     let data = await fetch('/api/data');  // What if it fails?\n   }\n   \n   Always try/catch:\n   async function getData() {\n     try {\n       let data = await fetch('/api/data');\n     } catch (error) {\n       console.log('Error:', error);\n     }\n   }\n\n5. Mixing async/await with .then():\n   // Pick one style, don't mix:\n   async function mixed() {\n     let data = await fetchData();\n     data.then(result => { });  // Confusing!\n   }\n   \n   // Use async/await consistently:\n   async function clean() {\n     let data = await fetchData();\n     let result = await processData(data);\n   }"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "8.5-challenge",
              "title": "Practice Challenge",
              "description": "Convert this Promise code to async/await:\n\nfunction loadUserData() {\n  return fetchUser(1)\n    .then(user => {\n      console.log('User:', user.name);\n      return fetchPosts(user.id);\n    })\n    .then(posts => {\n      console.log('Posts:', posts.length);\n      return posts;\n    })\n    .catch(error => {\n      console.log('Error:', error);\n    });\n}\n\nRewrite as async/await with try/catch.",
              "instructions": "Convert this Promise code to async/await:\n\nfunction loadUserData() {\n  return fetchUser(1)\n    .then(user => {\n      console.log('User:', user.name);\n      return fetchPosts(user.id);\n    })\n    .then(posts => {\n      console.log('Posts:', posts.length);\n      return posts;\n    })\n    .catch(error => {\n      console.log('Error:', error);\n    });\n}\n\nRewrite as async/await with try/catch.",
              "starterCode": "async function loadUserData() {\n  // YOUR CODE HERE using async/await\n}",
              "solution": "async function loadUserData() {\n  try {\n    let user = await fetchUser(1);\n    console.log('User:', user.name);\n    \n    let posts = await fetchPosts(user.id);\n    console.log('Posts:', posts.length);\n    \n    return posts;\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays the user name from fetchUser",
                  "expectedOutput": "User:",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Displays the posts count from fetchPosts",
                  "expectedOutput": "Posts:",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Uses try/catch for error handling",
                  "expectedOutput": "Error:",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "async function with try/catch, await fetchUser, await fetchPosts"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Forgetting 'async' keyword:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting 'async' keyword:\n   function getData() {\n     let result = await fetch();  // ERROR!\n   }\n   \n   Must be:\n   async function getData() {\n     let result = await fetch();\n   }"
                },
                {
                  "mistake": "Not awaiting Promises:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Not awaiting Promises:\n   async function getData() {\n     let data = fetchData();  // data is a Promise!\n     console.log(data.name);  // undefined!\n   }\n   \n   Must await:\n   async function getData() {\n     let data = await fetchData();\n     console.log(data.name);  // Works!\n   }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "8.6",
          "title": "Ordering from the Menu (Using fetch() to Get API Data)",
          "moduleId": "module-08",
          "order": 6,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Using an API is like ordering from a restaurant:\n\n1. **You look at the menu** (API documentation) - What dishes (endpoints) are available?\n2. **You place an order** (fetch request) - 'I'll have the user data for ID 123, please'\n3. **Kitchen prepares it** (server processes) - Takes time, you wait\n4. **Server brings your food** (response) - Here's your data!\n5. **You eat it** (use the data) - Display on your webpage\n\nAPIs (Application Programming Interfaces) are how websites talk to servers. fetch() is JavaScript's built-in way to request data from APIs. It returns a Promise, so we use async/await!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Basic fetch - GET request\nasync function getUsers() {\n  try {\n    let response = await fetch('https://jsonplaceholder.typicode.com/users');\n    \n    // Check if request was successful\n    if (!response.ok) {\n      throw new Error('Request failed: ' + response.status);\n    }\n    \n    // Parse JSON response\n    let users = await response.json();\n    console.log(users);\n    \n    return users;\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}\n\n// Fetch with options - POST request\nasync function createUser(userData) {\n  try {\n    let response = await fetch('https://api.example.com/users', {\n      method: 'POST',  // HTTP method\n      headers: {\n        'Content-Type': 'application/json'  // Sending JSON\n      },\n      body: JSON.stringify(userData)  // Convert object to JSON string\n    });\n    \n    let newUser = await response.json();\n    console.log('Created:', newUser);\n    return newUser;\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}\n\n// Example: Create user\ncreateUser({\n  name: 'Alice',\n  email: 'alice@example.com',\n  age: 25\n});\n\n// UPDATE - PUT/PATCH request\nasync function updateUser(userId, updates) {\n  let response = await fetch(`https://api.example.com/users/${userId}`, {\n    method: 'PATCH',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(updates)\n  });\n  \n  return await response.json();\n}\n\n// DELETE request\nasync function deleteUser(userId) {\n  let response = await fetch(`https://api.example.com/users/${userId}`, {\n    method: 'DELETE'\n  });\n  \n  if (response.ok) {\n    console.log('User deleted');\n  }\n}\n\n// Practical example: Display users on page\nasync function displayUsers() {\n  try {\n    let response = await fetch('https://jsonplaceholder.typicode.com/users');\n    let users = await response.json();\n    \n    let userList = document.querySelector('#userList');\n    \n    users.forEach(user => {\n      let li = document.createElement('li');\n      li.textContent = user.name;\n      userList.appendChild(li);\n    });\n  } catch (error) {\n    console.log('Failed to load users:', error);\n  }\n}\n\n// With loading state\nasync function fetchWithLoading() {\n  let loadingEl = document.querySelector('#loading');\n  let contentEl = document.querySelector('#content');\n  \n  try {\n    loadingEl.style.display = 'block';  // Show loading\n    \n    let response = await fetch('/api/data');\n    let data = await response.json();\n    \n    contentEl.textContent = JSON.stringify(data);\n  } catch (error) {\n    contentEl.textContent = 'Error loading data';\n  } finally {\n    loadingEl.style.display = 'none';  // Hide loading\n  }\n}"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "fetch() syntax:\n\n**Basic GET request:**\n\nlet response = await fetch(url);\nlet data = await response.json();\n\n**With options:**\n\nlet response = await fetch(url, {\n  method: 'POST',  // GET, POST, PUT, PATCH, DELETE\n  headers: {       // Request headers\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer token123'\n  },\n  body: JSON.stringify(data)  // Request body (POST/PUT/PATCH)\n});\n\n**Response object properties:**\n\nresponse.ok          // true if status 200-299\nresponse.status      // HTTP status code (200, 404, 500, etc.)\nresponse.statusText  // Status message ('OK', 'Not Found', etc.)\nresponse.headers     // Response headers\nresponse.json()      // Parse as JSON (returns Promise)\nresponse.text()      // Get as text (returns Promise)\nresponse.blob()      // Get as binary (for images, files)\n\n**HTTP Methods (CRUD):**\n\nGET    - Read data (default)\nPOST   - Create new resource\nPUT    - Replace entire resource\nPATCH  - Update part of resource\nDELETE - Delete resource\n\n**Complete pattern:**\n\nasync function apiCall() {\n  try {\n    // 1. Make request\n    let response = await fetch(url, options);\n    \n    // 2. Check if successful\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    // 3. Parse response\n    let data = await response.json();\n    \n    // 4. Use data\n    return data;\n    \n  } catch (error) {\n    // 5. Handle errors\n    console.error('Fetch error:', error);\n    throw error;  // Re-throw or handle\n  }\n}\n\n**Common Headers:**\n\n'Content-Type': 'application/json'  // Sending JSON\n'Authorization': 'Bearer token'      // Authentication\n'Accept': 'application/json'         // Expecting JSON\n\n**Sending Data:**\n\n// Object to JSON string\nlet user = { name: 'Alice', age: 25 };\nlet jsonString = JSON.stringify(user);\n\n// Send in fetch\nbody: JSON.stringify(user)\n\n// Parsing response\nlet data = await response.json();  // JSON string to object\n\n**Error Handling:**\n\n// Network errors (no connection)\ntry {\n  let response = await fetch(url);\n} catch (error) {\n  console.log('Network error:', error);\n}\n\n// HTTP errors (404, 500, etc.)\nif (!response.ok) {\n  throw new Error('HTTP ' + response.status);\n}\n\n// JSON parsing errors\ntry {\n  let data = await response.json();\n} catch (error) {\n  console.log('Invalid JSON:', error);\n}"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes:\n\n1. Not awaiting response.json():\n   let response = await fetch(url);\n   let data = response.json();  // WRONG - data is a Promise!\n   \n   Must await:\n   let data = await response.json();\n\n2. Forgetting to check response.ok:\n   let response = await fetch(url);\n   let data = await response.json();  // Might fail!\n   \n   Always check:\n   if (!response.ok) {\n     throw new Error('HTTP error');\n   }\n\n3. Not stringifying request body:\n   fetch(url, {\n     body: {name: 'Alice'}  // WRONG - object!\n   });\n   \n   Must stringify:\n   fetch(url, {\n     body: JSON.stringify({name: 'Alice'})\n   });\n\n4. CORS errors (Cross-Origin Request Blocked):\n   // Can't fetch from different domain without server permission\n   fetch('https://other-site.com/api')  // Might be blocked\n   // Server must send CORS headers to allow\n\n5. Forgetting Content-Type header:\n   fetch(url, {\n     method: 'POST',\n     body: JSON.stringify(data)  // Server might not parse it!\n   });\n   \n   Need header:\n   fetch(url, {\n     method: 'POST',\n     headers: {\n       'Content-Type': 'application/json'\n     },\n     body: JSON.stringify(data)\n   });\n\n6. Not handling network errors:\n   // If internet is down, fetch throws\n   try {\n     await fetch(url);\n   } catch (error) {\n     // Handle network error\n   }"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "8.6-challenge",
              "title": "Practice Challenge",
              "description": "Create a function that:\n1. Fetches a random user from: https://randomuser.me/api/\n2. Extracts the name (results[0].name.first)\n3. Returns the name\n4. Handles errors appropriately\n\nHint: The API returns { results: [{name: {first: 'John', last: 'Doe'}}] }",
              "instructions": "Create a function that:\n1. Fetches a random user from: https://randomuser.me/api/\n2. Extracts the name (results[0].name.first)\n3. Returns the name\n4. Handles errors appropriately\n\nHint: The API returns { results: [{name: {first: 'John', last: 'Doe'}}] }",
              "starterCode": "async function getRandomUser() {\n  try {\n    // YOUR CODE HERE\n    // 1. fetch from URL\n    // 2. Check response.ok\n    // 3. Parse JSON\n    // 4. Extract and return name\n  } catch (error) {\n    console.log('Error:', error);\n    return null;\n  }\n}\n\n// Test it\ngetRandomUser().then(name => console.log('Random user:', name));",
              "solution": "async function getRandomUser() {\n  try {\n    let response = await fetch('https://randomuser.me/api/');\n    \n    if (!response.ok) {\n      throw new Error('Request failed');\n    }\n    \n    let data = await response.json();\n    let firstName = data.results[0].name.first;\n    \n    return firstName;\n  } catch (error) {\n    console.log('Error:', error);\n    return null;\n  }\n}\n\ngetRandomUser().then(name => console.log('Random user:', name));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Fetches and parses data",
                  "expectedOutput": "John",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "let response = await fetch(url); let data = await response.json(); return data.results[0].name.first;"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes:"
                },
                {
                  "mistake": "Not awaiting response.json():",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Not awaiting response.json():\n   let response = await fetch(url);\n   let data = response.json();  // WRONG - data is a Promise!\n   \n   Must await:\n   let data = await response.json();"
                },
                {
                  "mistake": "Forgetting to check response.ok:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Forgetting to check response.ok:\n   let response = await fetch(url);\n   let data = await response.json();  // Might fail!\n   \n   Always check:\n   if (!response.ok) {\n     throw new Error('HTTP error');\n   }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-error-handling",
      "title": "Module 9: Error Handling & Debugging",
      "description": "Master error handling to write robust, production-ready JavaScript that gracefully handles failures",
      "difficulty": "intermediate",
      "estimatedHours": 2.5,
      "lessons": [
        {
          "id": "9.1",
          "title": "The try-catch-finally Pattern",
          "moduleId": "module-error-handling",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're a trapeze artist performing high above the crowd. Even the most skilled acrobat knows that sometimes things go wrong - a grip slips, timing is off, or the unexpected happens. That's why there's always a safety net below.\n\nThe try-catch-finally pattern is your code's safety net. The 'try' block is where you perform your daring feats - the code that might fail. The 'catch' block is the safety net - it catches you when something goes wrong. And 'finally'? That's like the cleanup crew that always runs after the performance, whether you stuck the landing perfectly or tumbled into the net.\n\nWithout error handling, when your code encounters a problem, the entire program crashes - like falling without a net. With try-catch-finally, your program can gracefully recover, log what went wrong, and continue running. This is the difference between amateur and professional code: professionals always plan for what happens when things go wrong."
            },
            {
              "type": "EXAMPLE",
              "title": "Basic try-catch Structure",
              "content": "The fundamental pattern for catching errors in JavaScript. The try block contains code that might fail, and the catch block handles the error gracefully.",
              "language": "javascript",
              "code": "// Basic try-catch pattern\ntry {\n  // Code that might throw an error\n  let result = riskyOperation();\n  console.log('Success:', result);\n} catch (error) {\n  // Code that runs if an error occurs\n  console.log('Something went wrong:', error.message);\n}\n\n// Real-world example: Parsing JSON\nlet jsonString = '{\"name\": \"Alice\", \"age\": 25}';\nlet badJsonString = 'not valid json';\n\n// Parsing valid JSON\ntry {\n  let user = JSON.parse(jsonString);\n  console.log('User name:', user.name); // Output: User name: Alice\n} catch (error) {\n  console.log('Failed to parse JSON:', error.message);\n}\n\n// Parsing invalid JSON\ntry {\n  let data = JSON.parse(badJsonString);\n  console.log('Data:', data); // This line never runs\n} catch (error) {\n  console.log('Failed to parse JSON:', error.message);\n  // Output: Failed to parse JSON: Unexpected token 'o' at position 1\n}\n\nconsole.log('Program continues normally!'); // This still runs!"
            },
            {
              "type": "EXAMPLE",
              "title": "The finally Block - Runs No Matter What",
              "content": "The finally block executes regardless of whether an error occurred or not. It even runs after a return statement! This is perfect for cleanup operations.",
              "language": "javascript",
              "code": "// The finally block ALWAYS runs\nfunction fetchData() {\n  console.log('Starting fetch...');\n  \n  try {\n    // Simulating a risky operation\n    let data = JSON.parse('{\"status\": \"ok\"}');\n    console.log('Data fetched successfully');\n    return data; // Note: we're returning here!\n  } catch (error) {\n    console.log('Error occurred:', error.message);\n    return null;\n  } finally {\n    // This runs EVEN AFTER the return statement!\n    console.log('Cleanup: Closing connection...');\n  }\n}\n\nlet result = fetchData();\nconsole.log('Result:', result);\n// Output:\n// Starting fetch...\n// Data fetched successfully\n// Cleanup: Closing connection... (finally runs after return!)\n// Result: { status: 'ok' }\n\n// Practical example: File handling pattern\nfunction readConfigFile(filename) {\n  let file = null;\n  \n  try {\n    console.log('Opening file:', filename);\n    file = openFile(filename); // Imagine this opens a file\n    let content = file.read();\n    return JSON.parse(content);\n  } catch (error) {\n    console.log('Failed to read config:', error.message);\n    return getDefaultConfig();\n  } finally {\n    // ALWAYS close the file, even if reading failed\n    if (file) {\n      console.log('Closing file...');\n      file.close();\n    }\n  }\n}\n\n// The finally block is guaranteed to run for:\n// - Successful execution\n// - After catching an error\n// - Even after return statements\n// - Even after throw statements (before propagating)"
            },
            {
              "type": "EXAMPLE",
              "title": "Nested try-catch Patterns",
              "content": "Sometimes you need different error handling strategies for different parts of your code. Nested try-catch blocks let you handle errors at multiple levels.",
              "language": "javascript",
              "code": "// Nested try-catch for granular error handling\nfunction processUserData(userId) {\n  try {\n    console.log('Processing user:', userId);\n    \n    // Outer try handles general errors\n    let user = null;\n    \n    try {\n      // Inner try handles specifically the fetch\n      user = fetchUserFromDatabase(userId);\n    } catch (fetchError) {\n      console.log('Database unavailable, trying cache...');\n      user = fetchUserFromCache(userId);\n    }\n    \n    try {\n      // Another inner try handles email validation\n      validateEmail(user.email);\n    } catch (validationError) {\n      console.log('Invalid email, using default...');\n      user.email = 'default@example.com';\n    }\n    \n    return user;\n    \n  } catch (error) {\n    // Outer catch handles anything that wasn't caught inside\n    console.log('Complete failure:', error.message);\n    return null;\n  }\n}\n\n// Practical example: Multi-step process\nfunction createOrder(orderData) {\n  let orderId = null;\n  \n  try {\n    // Step 1: Validate order\n    try {\n      validateOrderData(orderData);\n      console.log('Order validated');\n    } catch (validationError) {\n      throw new Error('Invalid order: ' + validationError.message);\n    }\n    \n    // Step 2: Process payment\n    try {\n      processPayment(orderData.payment);\n      console.log('Payment processed');\n    } catch (paymentError) {\n      throw new Error('Payment failed: ' + paymentError.message);\n    }\n    \n    // Step 3: Create order record\n    try {\n      orderId = saveOrder(orderData);\n      console.log('Order saved:', orderId);\n    } catch (dbError) {\n      // Payment was processed, so we need to refund!\n      refundPayment(orderData.payment);\n      throw new Error('Order save failed, payment refunded');\n    }\n    \n    return orderId;\n    \n  } catch (error) {\n    console.log('Order creation failed:', error.message);\n    return null;\n  }\n}"
            },
            {
              "type": "EXAMPLE",
              "title": "Re-throwing Errors",
              "content": "Sometimes you want to catch an error, do something with it (like logging), and then throw it again so code higher up can also handle it.",
              "language": "javascript",
              "code": "// Re-throwing errors for logging then propagating\nfunction processOrder(orderId) {\n  try {\n    let order = fetchOrder(orderId);\n    calculateTotal(order);\n    return order;\n  } catch (error) {\n    // Log the error for debugging\n    console.error('Error processing order', orderId, ':', error.message);\n    \n    // Re-throw so the caller knows something went wrong\n    throw error;\n  }\n}\n\n// Selective re-throwing based on error type\nfunction handleRequest(request) {\n  try {\n    return processRequest(request);\n  } catch (error) {\n    if (error.message.includes('validation')) {\n      // Validation errors: handle locally, don't re-throw\n      console.log('Validation issue:', error.message);\n      return { success: false, error: 'Invalid input' };\n    } else {\n      // Other errors: log and re-throw for caller to handle\n      console.error('Unexpected error:', error.message);\n      throw error;\n    }\n  }\n}\n\n// Adding context when re-throwing\nfunction loadUserProfile(userId) {\n  try {\n    let profile = fetchProfile(userId);\n    return profile;\n  } catch (error) {\n    // Add context to the error before re-throwing\n    error.message = `Failed to load profile for user ${userId}: ${error.message}`;\n    throw error;\n  }\n}\n\n// Modern approach: Error cause chaining (ES2022)\nfunction loadUserWithCause(userId) {\n  try {\n    return fetchProfile(userId);\n  } catch (error) {\n    // Create a new error that links to the original\n    throw new Error(`Could not load user ${userId}`, { cause: error });\n  }\n}"
            },
            {
              "type": "THEORY",
              "title": "Control Flow with try-catch-finally",
              "content": "Understanding exactly how control flows through try-catch-finally blocks is crucial for writing robust error handling code. Here's the complete breakdown:\n\n**Execution Order:**\n\n1. **try block starts** - Code executes line by line\n2. **If NO error occurs:**\n   - try block completes fully\n   - catch block is SKIPPED entirely\n   - finally block runs\n   - Execution continues after the try-catch-finally\n\n3. **If an error DOES occur:**\n   - try block stops immediately at the error line\n   - Remaining try block code is SKIPPED\n   - catch block runs with the error object\n   - finally block runs\n   - Execution continues after the try-catch-finally\n\n**Key Rules:**\n\n```javascript\n// Rule 1: finally runs even after return\nfunction test() {\n  try {\n    return 'from try';\n  } finally {\n    console.log('finally still runs!');\n  }\n}\n\n// Rule 2: finally runs even after throw\nfunction test2() {\n  try {\n    throw new Error('oops');\n  } finally {\n    console.log('finally still runs!');\n  }\n}\n\n// Rule 3: return in finally overrides try/catch return\nfunction test3() {\n  try {\n    return 'try';\n  } finally {\n    return 'finally'; // This wins!\n  }\n}\nconsole.log(test3()); // Output: 'finally'\n\n// Rule 4: You can have try-finally without catch\ntry {\n  riskyOperation();\n} finally {\n  cleanup(); // Always runs, errors still propagate\n}\n```\n\n**Common Patterns:**\n- `try-catch`: Handle errors and continue\n- `try-finally`: Ensure cleanup, let errors propagate\n- `try-catch-finally`: Handle errors AND ensure cleanup"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "Avoid these common error handling anti-patterns that can make debugging harder and hide real problems:\n\n**1. Empty catch blocks (Error swallowing):**\n```javascript\n// BAD: Silently ignoring errors\ntry {\n  doSomethingRisky();\n} catch (error) {\n  // Error is completely lost!\n}\n\n// GOOD: At least log it\ntry {\n  doSomethingRisky();\n} catch (error) {\n  console.error('Operation failed:', error);\n}\n```\n\n**2. Catching too broadly:**\n```javascript\n// BAD: Catching all errors the same way\ntry {\n  validateInput();\n  processData();\n  saveToDatabase();\n} catch (error) {\n  console.log('Something failed'); // Which step? No idea!\n}\n\n// GOOD: Handle specific scenarios\ntry {\n  validateInput();\n} catch (error) {\n  console.log('Invalid input:', error.message);\n  return;\n}\n// Now we know validation passed...\n```\n\n**3. Using try-catch for control flow:**\n```javascript\n// BAD: Using exceptions for normal logic\nfunction isNumber(value) {\n  try {\n    parseInt(value);\n    return true;\n  } catch {\n    return false; // parseInt doesn't throw for invalid input!\n  }\n}\n\n// GOOD: Check conditions normally\nfunction isNumber(value) {\n  return !isNaN(parseFloat(value));\n}\n```\n\n**4. Forgetting async error handling:**\n```javascript\n// BAD: try-catch doesn't catch async errors this way!\ntry {\n  setTimeout(() => {\n    throw new Error('This escapes!');\n  }, 100);\n} catch (error) {\n  console.log('Never runs');\n}\n\n// We'll cover async error handling in Lesson 9.4\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "9.1-challenge",
              "title": "Handle Multiple Error Scenarios",
              "description": "Create a function called `safeParseConfig` that takes a JSON string and returns a parsed configuration object. The function should:\n\n1. Try to parse the JSON\n2. If parsing fails, log 'Invalid JSON format' and return a default config\n3. If parsing succeeds but the config is missing required fields (name, version), log 'Missing required fields' and return a default config\n4. Always log 'Parse attempt complete' in a finally block\n5. Return the default config: { name: 'Unknown', version: '0.0.0' }",
              "instructions": "Create a function called `safeParseConfig` that handles JSON parsing errors gracefully. The function should use try-catch-finally to handle both JSON parsing errors and missing required fields, always running cleanup code in finally.",
              "starterCode": "function safeParseConfig(jsonString) {\n  const defaultConfig = { name: 'Unknown', version: '0.0.0' };\n  \n  // YOUR CODE HERE\n  // Use try-catch-finally to:\n  // 1. Parse the JSON\n  // 2. Validate it has 'name' and 'version' properties\n  // 3. Return the parsed config or defaultConfig\n  // 4. Always log 'Parse attempt complete' in finally\n}\n\n// Test cases\nconsole.log(safeParseConfig('{\"name\": \"MyApp\", \"version\": \"1.0.0\"}'));\nconsole.log(safeParseConfig('not valid json'));\nconsole.log(safeParseConfig('{\"name\": \"MyApp\"}'));",
              "solution": "function safeParseConfig(jsonString) {\n  const defaultConfig = { name: 'Unknown', version: '0.0.0' };\n  \n  try {\n    const config = JSON.parse(jsonString);\n    \n    if (!config.name || !config.version) {\n      console.log('Missing required fields');\n      return defaultConfig;\n    }\n    \n    return config;\n  } catch (error) {\n    console.log('Invalid JSON format');\n    return defaultConfig;\n  } finally {\n    console.log('Parse attempt complete');\n  }\n}\n\n// Test cases\nconsole.log(safeParseConfig('{\"name\": \"MyApp\", \"version\": \"1.0.0\"}'));\n// Output: Parse attempt complete, { name: 'MyApp', version: '1.0.0' }\n\nconsole.log(safeParseConfig('not valid json'));\n// Output: Invalid JSON format, Parse attempt complete, { name: 'Unknown', version: '0.0.0' }\n\nconsole.log(safeParseConfig('{\"name\": \"MyApp\"}'));\n// Output: Missing required fields, Parse attempt complete, { name: 'Unknown', version: '0.0.0' }",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Parses valid JSON with all required fields",
                  "expectedOutput": "Parse attempt complete\n{ name: 'MyApp', version: '1.0.0' }",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Returns default config for invalid JSON",
                  "expectedOutput": "Invalid JSON format\nParse attempt complete\n{ name: 'Unknown', version: '0.0.0' }",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Returns default config when required fields are missing",
                  "expectedOutput": "Missing required fields\nParse attempt complete\n{ name: 'Unknown', version: '0.0.0' }",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use JSON.parse() inside the try block. This throws an error for invalid JSON."
                },
                {
                  "level": 2,
                  "text": "After parsing, check if config.name and config.version exist using an if statement."
                },
                {
                  "level": 3,
                  "text": "The finally block should just contain: console.log('Parse attempt complete');"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Putting the field validation in the catch block instead of the try block",
                  "consequence": "The catch block only runs when an exception is thrown, not for logical validation failures.",
                  "correction": "Check for missing fields inside the try block, after JSON.parse() succeeds."
                },
                {
                  "mistake": "Forgetting to return defaultConfig in both error scenarios",
                  "consequence": "The function might return undefined in some error cases.",
                  "correction": "Ensure you return defaultConfig both when JSON parsing fails and when required fields are missing."
                },
                {
                  "mistake": "Not using finally for the completion log",
                  "consequence": "If you put the log in try or catch, it won't run in all scenarios.",
                  "correction": "Use finally to ensure 'Parse attempt complete' always logs."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "9.2",
          "title": "Error Objects and Types",
          "moduleId": "module-error-handling",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "When you visit a doctor, they don't just say 'you're sick' - they give you a specific diagnosis. 'You have the flu' is much more useful than 'something's wrong.' The diagnosis tells you what's wrong, how serious it is, and what treatment you need.\n\nJavaScript errors work the same way. Instead of just saying 'error occurred,' JavaScript provides specific error types that act like medical diagnoses. A TypeError tells you that you tried to use a value in a way that doesn't match its type - like trying to call a number as if it were a function. A ReferenceError means you're trying to use a variable that doesn't exist - like asking for patient records that were never created.\n\nEach error type carries specific information: a name (the diagnosis), a message (what specifically went wrong), and a stack trace (the path that led to the problem, like a patient's medical history). Understanding these error types helps you diagnose problems faster and write more targeted error handling - just like how knowing the difference between a cold and the flu helps you choose the right treatment."
            },
            {
              "type": "EXAMPLE",
              "title": "Built-in Error Types",
              "content": "JavaScript has several built-in error types, each indicating a specific category of problem. Understanding these helps you diagnose issues quickly.",
              "language": "javascript",
              "code": "// 1. TypeError - Wrong type for an operation\ntry {\n  let num = 42;\n  num.toUpperCase(); // Numbers don't have toUpperCase!\n} catch (error) {\n  console.log(error.name);    // 'TypeError'\n  console.log(error.message); // 'num.toUpperCase is not a function'\n}\n\ntry {\n  null.toString(); // Can't call methods on null\n} catch (error) {\n  console.log('TypeError:', error.message);\n  // \"Cannot read properties of null (reading 'toString')\"\n}\n\n// 2. ReferenceError - Variable doesn't exist\ntry {\n  console.log(undefinedVariable); // Never declared!\n} catch (error) {\n  console.log(error.name);    // 'ReferenceError'\n  console.log(error.message); // 'undefinedVariable is not defined'\n}\n\n// 3. SyntaxError - Code structure is invalid (usually caught at parse time)\n// Note: SyntaxErrors are usually caught before code runs\ntry {\n  eval('let x = ;'); // Invalid syntax\n} catch (error) {\n  console.log(error.name);    // 'SyntaxError'\n  console.log(error.message); // 'Unexpected token ;'\n}\n\n// 4. RangeError - Value outside allowed range\ntry {\n  let arr = new Array(-1); // Can't have negative length\n} catch (error) {\n  console.log(error.name);    // 'RangeError'\n  console.log(error.message); // 'Invalid array length'\n}\n\ntry {\n  let num = 1;\n  num.toFixed(200); // Max precision is 100\n} catch (error) {\n  console.log('RangeError:', error.message);\n}\n\n// 5. URIError - Invalid URI handling\ntry {\n  decodeURIComponent('%'); // Invalid percent encoding\n} catch (error) {\n  console.log(error.name);    // 'URIError'\n  console.log(error.message); // 'URI malformed'\n}\n\n// 6. EvalError - Error in eval() (rarely used in modern JS)\n// EvalError is mostly historical; errors in eval() now throw other types\n\n// 7. AggregateError - Multiple errors (ES2021)\n// Used with Promise.any() when all promises reject\nlet errors = [\n  new Error('First error'),\n  new Error('Second error')\n];\nlet aggError = new AggregateError(errors, 'Multiple errors occurred');\nconsole.log(aggError.name);    // 'AggregateError'\nconsole.log(aggError.errors);  // Array of errors"
            },
            {
              "type": "EXAMPLE",
              "title": "Error Properties (message, name, stack, cause)",
              "content": "Every Error object has properties that help you understand what went wrong, where, and why.",
              "language": "javascript",
              "code": "// Creating an error to examine its properties\nfunction demonstrateErrorProperties() {\n  try {\n    throw new Error('Something went wrong!');\n  } catch (error) {\n    // 1. name - The type of error\n    console.log('Name:', error.name);\n    // Output: Name: Error\n    \n    // 2. message - Human-readable description\n    console.log('Message:', error.message);\n    // Output: Message: Something went wrong!\n    \n    // 3. stack - Full stack trace (where the error occurred)\n    console.log('Stack trace:');\n    console.log(error.stack);\n    // Output: Error: Something went wrong!\n    //     at demonstrateErrorProperties (file.js:3:11)\n    //     at main (file.js:20:5)\n    //     at file.js:25:1\n  }\n}\n\ndemonstrateErrorProperties();\n\n// Real example: parsing stack trace info\nfunction getUserData(userId) {\n  if (userId < 0) {\n    throw new Error('User ID must be positive');\n  }\n  return { id: userId, name: 'User' };\n}\n\nfunction displayUser(userId) {\n  let user = getUserData(userId);\n  console.log('User:', user.name);\n}\n\ntry {\n  displayUser(-1);\n} catch (error) {\n  console.log('Error name:', error.name);\n  console.log('Error message:', error.message);\n  console.log('\\nFull stack trace shows the call path:');\n  console.log(error.stack);\n  // Stack shows: getUserData -> displayUser -> (your code)\n}\n\n// 4. cause - The original error that caused this one (ES2022)\nfunction fetchData() {\n  throw new Error('Network timeout');\n}\n\nfunction loadUserProfile(userId) {\n  try {\n    return fetchData();\n  } catch (originalError) {\n    // Create a new error with 'cause' linking to the original\n    throw new Error(`Failed to load user ${userId}`, {\n      cause: originalError\n    });\n  }\n}\n\ntry {\n  loadUserProfile(123);\n} catch (error) {\n  console.log('Error:', error.message);\n  // Output: Error: Failed to load user 123\n  \n  console.log('Caused by:', error.cause?.message);\n  // Output: Caused by: Network timeout\n  \n  // You can chain causes for deep error tracking!\n}"
            },
            {
              "type": "EXAMPLE",
              "title": "Error Cause Chaining (ES2022)",
              "content": "The error cause feature lets you create a chain of errors, preserving the full history of what went wrong.",
              "language": "javascript",
              "code": "// Error cause chaining - ES2022 feature\n// This creates a traceable chain of errors\n\nfunction connectToDatabase() {\n  throw new Error('Connection refused: port 5432');\n}\n\nfunction initializeApp() {\n  try {\n    connectToDatabase();\n  } catch (dbError) {\n    throw new Error('Database initialization failed', {\n      cause: dbError\n    });\n  }\n}\n\nfunction startServer() {\n  try {\n    initializeApp();\n  } catch (initError) {\n    throw new Error('Server failed to start', {\n      cause: initError\n    });\n  }\n}\n\n// Now let's catch and trace the full error chain\ntry {\n  startServer();\n} catch (error) {\n  console.log('=== Error Chain ===');\n  \n  let currentError = error;\n  let depth = 0;\n  \n  while (currentError) {\n    console.log(`${'  '.repeat(depth)}${currentError.message}`);\n    currentError = currentError.cause;\n    depth++;\n  }\n}\n// Output:\n// === Error Chain ===\n// Server failed to start\n//   Database initialization failed\n//     Connection refused: port 5432\n\n// Utility function to get full error chain\nfunction getErrorChain(error) {\n  const chain = [];\n  let current = error;\n  \n  while (current) {\n    chain.push({\n      name: current.name,\n      message: current.message\n    });\n    current = current.cause;\n  }\n  \n  return chain;\n}\n\ntry {\n  startServer();\n} catch (error) {\n  const chain = getErrorChain(error);\n  console.log('Error chain:', JSON.stringify(chain, null, 2));\n}"
            },
            {
              "type": "EXAMPLE",
              "title": "Inspecting and Logging Error Stacks",
              "content": "Stack traces are invaluable for debugging. Here's how to effectively use and log them.",
              "language": "javascript",
              "code": "// Understanding and using stack traces\n\nfunction level3() {\n  throw new Error('Something broke in level 3');\n}\n\nfunction level2() {\n  level3();\n}\n\nfunction level1() {\n  level2();\n}\n\ntry {\n  level1();\n} catch (error) {\n  console.log('=== Full Stack Trace ===');\n  console.log(error.stack);\n  // Output shows the call path:\n  // Error: Something broke in level 3\n  //     at level3 (script.js:4:9)\n  //     at level2 (script.js:8:3)\n  //     at level1 (script.js:12:3)\n  //     at script.js:16:3\n}\n\n// Formatting error for logging\nfunction formatErrorForLogging(error) {\n  return {\n    timestamp: new Date().toISOString(),\n    name: error.name,\n    message: error.message,\n    stack: error.stack?.split('\\n').slice(0, 5), // First 5 lines\n    cause: error.cause ? formatErrorForLogging(error.cause) : undefined\n  };\n}\n\ntry {\n  level1();\n} catch (error) {\n  const logEntry = formatErrorForLogging(error);\n  console.log(JSON.stringify(logEntry, null, 2));\n}\n\n// Production-ready error logging\nfunction logError(error, context = {}) {\n  const errorInfo = {\n    timestamp: new Date().toISOString(),\n    error: {\n      name: error.name,\n      message: error.message,\n      stack: error.stack\n    },\n    context: context,\n    // Add environment info\n    environment: typeof process !== 'undefined' ? 'node' : 'browser'\n  };\n  \n  // In production, you'd send this to a logging service\n  console.error('[ERROR]', JSON.stringify(errorInfo));\n  \n  // Could also send to external service:\n  // sendToLogService(errorInfo);\n}\n\ntry {\n  level1();\n} catch (error) {\n  logError(error, {\n    userId: 123,\n    action: 'processing data',\n    inputSize: 1000\n  });\n}"
            },
            {
              "type": "THEORY",
              "title": "When Each Error Type is Thrown",
              "content": "Understanding when JavaScript throws each error type helps you anticipate and handle errors correctly:\n\n**TypeError** - Thrown when:\n- Calling a non-function: `(5)()`\n- Accessing properties on null/undefined: `null.x`\n- Using wrong type for built-in operations: `'hello' - 5`\n- Calling methods that don't exist on a type: `(42).toUpperCase()`\n\n**ReferenceError** - Thrown when:\n- Using an undeclared variable: `console.log(xyz)`\n- Accessing `let`/`const` before declaration (TDZ)\n- Assigning to an undeclared variable in strict mode\n\n**SyntaxError** - Thrown when:\n- Invalid syntax in eval() or Function()\n- Parsing JSON with JSON.parse() when JSON is malformed\n- Note: Static syntax errors prevent code from running at all\n\n**RangeError** - Thrown when:\n- Array with invalid length: `new Array(-1)`\n- Number methods with out-of-range arguments: `(1).toFixed(200)`\n- Stack overflow from too much recursion\n- Invalid date: `new Date('invalid').toISOString()`\n\n**URIError** - Thrown when:\n- decodeURI() or decodeURIComponent() with malformed sequences\n- encodeURI() or encodeURIComponent() with invalid characters\n\n**AggregateError** - Thrown when:\n- Promise.any() rejects (all promises rejected)\n- Multiple errors need to be grouped together\n\n**Summary Table:**\n```\n| Error Type      | Common Cause                          |\n|-----------------|---------------------------------------|\n| TypeError       | Wrong type, null access, bad method  |\n| ReferenceError  | Undefined variable                   |\n| SyntaxError     | Bad JSON, eval() syntax              |\n| RangeError      | Out of bounds, stack overflow        |\n| URIError        | Malformed URI                        |\n| AggregateError  | Multiple grouped errors              |\n```"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "**1. Don't rely on error messages for logic:**\n```javascript\n// BAD: Error messages can change!\ntry {\n  someOperation();\n} catch (error) {\n  if (error.message === 'Network request failed') {\n    // Fragile! Message wording might change\n  }\n}\n\n// GOOD: Check error type or use custom errors\ntry {\n  someOperation();\n} catch (error) {\n  if (error instanceof TypeError) {\n    // Reliable check based on error type\n  }\n}\n```\n\n**2. Don't ignore the error parameter:**\n```javascript\n// BAD: Not using the error object\ntry {\n  riskyOperation();\n} catch {\n  console.log('Something failed'); // What failed? No idea!\n}\n\n// GOOD: Always examine the error\ntry {\n  riskyOperation();\n} catch (error) {\n  console.log(`${error.name}: ${error.message}`);\n}\n```\n\n**3. Don't assume error structure from external sources:**\n```javascript\n// BAD: Assuming all errors have standard properties\ntry {\n  await fetch(url);\n} catch (error) {\n  console.log(error.message); // Might not exist!\n}\n\n// GOOD: Safely access error properties\ntry {\n  await fetch(url);\n} catch (error) {\n  const message = error?.message || 'Unknown error';\n  console.log(message);\n}\n```\n\n**4. Remember: not all thrown values are Error objects:**\n```javascript\n// JavaScript allows throwing anything!\nthrow 'just a string';\nthrow 42;\nthrow { code: 500 };\n\n// GOOD: Handle non-Error throws safely\ntry {\n  mightThrowAnything();\n} catch (error) {\n  if (error instanceof Error) {\n    console.log(error.message);\n  } else {\n    console.log('Non-error thrown:', error);\n  }\n}\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "9.2-challenge",
              "title": "Identify Error Types from Scenarios",
              "description": "Create a function called `diagnoseError` that takes an error object and returns a diagnosis object with:\n- `type`: The error name (TypeError, ReferenceError, etc.)\n- `severity`: 'critical' for ReferenceError/SyntaxError, 'warning' for others\n- `suggestion`: A helpful suggestion based on the error type\n\nTest it with different error types.",
              "instructions": "Create a function that examines an error object and provides a diagnosis including the error type, severity level, and a helpful suggestion for fixing it based on the error type.",
              "starterCode": "function diagnoseError(error) {\n  // YOUR CODE HERE\n  // Return an object with: type, severity, suggestion\n  // Severity:\n  //   - 'critical' for ReferenceError and SyntaxError\n  //   - 'warning' for everything else\n  // Suggestions:\n  //   - TypeError: 'Check that the value is the correct type'\n  //   - ReferenceError: 'Check that the variable is declared'\n  //   - SyntaxError: 'Check the code syntax'\n  //   - RangeError: 'Check that values are within valid ranges'\n  //   - Default: 'Review the error message for details'\n}\n\n// Test cases\ntry { null.toString(); } catch (e) { console.log(diagnoseError(e)); }\ntry { undefinedVar; } catch (e) { console.log(diagnoseError(e)); }\ntry { new Array(-1); } catch (e) { console.log(diagnoseError(e)); }",
              "solution": "function diagnoseError(error) {\n  const suggestions = {\n    'TypeError': 'Check that the value is the correct type',\n    'ReferenceError': 'Check that the variable is declared',\n    'SyntaxError': 'Check the code syntax',\n    'RangeError': 'Check that values are within valid ranges',\n    'URIError': 'Check the URI encoding/decoding',\n    'EvalError': 'Avoid using eval()'\n  };\n  \n  const criticalErrors = ['ReferenceError', 'SyntaxError'];\n  \n  return {\n    type: error.name,\n    severity: criticalErrors.includes(error.name) ? 'critical' : 'warning',\n    suggestion: suggestions[error.name] || 'Review the error message for details'\n  };\n}\n\n// Test cases\ntry { null.toString(); } catch (e) { console.log(diagnoseError(e)); }\n// { type: 'TypeError', severity: 'warning', suggestion: 'Check that the value is the correct type' }\n\ntry { undefinedVar; } catch (e) { console.log(diagnoseError(e)); }\n// { type: 'ReferenceError', severity: 'critical', suggestion: 'Check that the variable is declared' }\n\ntry { new Array(-1); } catch (e) { console.log(diagnoseError(e)); }\n// { type: 'RangeError', severity: 'warning', suggestion: 'Check that values are within valid ranges' }",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Correctly identifies TypeError",
                  "expectedOutput": "{ type: 'TypeError', severity: 'warning', suggestion: 'Check that the value is the correct type' }",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Correctly identifies ReferenceError as critical",
                  "expectedOutput": "{ type: 'ReferenceError', severity: 'critical', suggestion: 'Check that the variable is declared' }",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Correctly identifies RangeError",
                  "expectedOutput": "{ type: 'RangeError', severity: 'warning', suggestion: 'Check that values are within valid ranges' }",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use error.name to get the error type (TypeError, ReferenceError, etc.)."
                },
                {
                  "level": 2,
                  "text": "Create an object mapping error names to suggestions, then look up the suggestion."
                },
                {
                  "level": 3,
                  "text": "Use Array.includes() to check if the error type is in the critical errors list."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using error.message instead of error.name to determine error type",
                  "consequence": "The message is a description, not the error type. Types are consistent; messages vary.",
                  "correction": "Use error.name to get the error type (e.g., 'TypeError', 'ReferenceError')."
                },
                {
                  "mistake": "Using string comparison instead of checking the name property",
                  "consequence": "Comparing the whole error object to a string won't work.",
                  "correction": "Compare error.name to type strings like 'TypeError'."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "9.3",
          "title": "Creating Custom Error Classes",
          "moduleId": "module-error-handling",
          "order": 3,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of custom error classes like specialized doctors in a hospital. A general practitioner can tell you 'something is wrong with your heart,' but a cardiologist can give you a precise diagnosis: 'You have atrial fibrillation with a specific treatment plan.'\n\nBuilt-in JavaScript errors are like the general practitioner - they tell you something went wrong (TypeError, ReferenceError), but they're generic. Custom error classes are like specialized doctors. A ValidationError knows exactly what field failed validation. An AuthenticationError carries the user ID that failed to authenticate. A NotFoundError includes which resource wasn't found.\n\nCustom errors let you:\n1. Give precise, actionable information about what went wrong\n2. Include additional data (like HTTP status codes, error codes, or affected resources)\n3. Handle different error scenarios with instanceof checks\n4. Create a hierarchy of errors for your application\n\nProfessional applications always define custom error classes because they make debugging faster and error handling more precise."
            },
            {
              "type": "EXAMPLE",
              "title": "Extending the Error Class Properly",
              "content": "The correct way to create custom error classes in JavaScript, with all necessary setup for proper error behavior.",
              "language": "javascript",
              "code": "// Basic custom error class\nclass CustomError extends Error {\n  constructor(message) {\n    super(message); // Call parent constructor with message\n    this.name = 'CustomError'; // Set the error name\n    \n    // This line is needed for proper stack traces in some environments\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CustomError);\n    }\n  }\n}\n\n// Using the custom error\ntry {\n  throw new CustomError('Something custom went wrong');\n} catch (error) {\n  console.log(error.name);    // 'CustomError'\n  console.log(error.message); // 'Something custom went wrong'\n  console.log(error instanceof CustomError); // true\n  console.log(error instanceof Error);       // true (inherits from Error)\n}\n\n// More realistic example with application context\nclass ApplicationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ApplicationError';\n    this.timestamp = new Date().toISOString();\n  }\n}\n\ntry {\n  throw new ApplicationError('Application initialization failed');\n} catch (error) {\n  console.log(`[${error.timestamp}] ${error.name}: ${error.message}`);\n  // Output: [2024-01-15T10:30:00.000Z] ApplicationError: Application initialization failed\n}"
            },
            {
              "type": "EXAMPLE",
              "title": "Adding Custom Properties",
              "content": "Custom errors become powerful when you add properties like status codes, error codes, and contextual details.",
              "language": "javascript",
              "code": "// Custom error with additional properties\nclass APIError extends Error {\n  constructor(message, statusCode, errorCode = null) {\n    super(message);\n    this.name = 'APIError';\n    this.statusCode = statusCode;   // HTTP status code\n    this.errorCode = errorCode;      // Application-specific code\n    this.timestamp = new Date().toISOString();\n  }\n  \n  // Helper method to convert to JSON for API responses\n  toJSON() {\n    return {\n      error: {\n        name: this.name,\n        message: this.message,\n        statusCode: this.statusCode,\n        errorCode: this.errorCode,\n        timestamp: this.timestamp\n      }\n    };\n  }\n}\n\n// Using the APIError\nfunction fetchUserData(userId) {\n  if (userId < 0) {\n    throw new APIError(\n      'User ID must be positive',\n      400,           // Bad Request\n      'INVALID_USER_ID'\n    );\n  }\n  // ... fetch logic\n}\n\ntry {\n  fetchUserData(-1);\n} catch (error) {\n  if (error instanceof APIError) {\n    console.log('Status:', error.statusCode);   // 400\n    console.log('Code:', error.errorCode);       // INVALID_USER_ID\n    console.log('Response:', JSON.stringify(error.toJSON(), null, 2));\n  }\n}\n\n// Error with detailed context\nclass DatabaseError extends Error {\n  constructor(message, details = {}) {\n    super(message);\n    this.name = 'DatabaseError';\n    this.query = details.query || null;\n    this.table = details.table || null;\n    this.operation = details.operation || null;\n    this.originalError = details.originalError || null;\n  }\n}\n\ntry {\n  throw new DatabaseError('Failed to insert record', {\n    query: 'INSERT INTO users VALUES (...)',\n    table: 'users',\n    operation: 'INSERT',\n    originalError: new Error('Duplicate key violation')\n  });\n} catch (error) {\n  console.log('Database error on table:', error.table);\n  console.log('Failed query:', error.query);\n  console.log('Original cause:', error.originalError?.message);\n}"
            },
            {
              "type": "EXAMPLE",
              "title": "Common Error Classes: Validation, NotFound, Authentication",
              "content": "A set of practical custom error classes commonly used in web applications.",
              "language": "javascript",
              "code": "// ValidationError - for input validation failures\nclass ValidationError extends Error {\n  constructor(message, field = null, value = null) {\n    super(message);\n    this.name = 'ValidationError';\n    this.field = field;     // Which field failed\n    this.value = value;     // What value was provided\n    this.statusCode = 400;  // Bad Request\n  }\n}\n\n// NotFoundError - for missing resources\nclass NotFoundError extends Error {\n  constructor(resource, id) {\n    super(`${resource} with id '${id}' not found`);\n    this.name = 'NotFoundError';\n    this.resource = resource;\n    this.resourceId = id;\n    this.statusCode = 404;  // Not Found\n  }\n}\n\n// AuthenticationError - for auth failures\nclass AuthenticationError extends Error {\n  constructor(message = 'Authentication required') {\n    super(message);\n    this.name = 'AuthenticationError';\n    this.statusCode = 401;  // Unauthorized\n  }\n}\n\n// AuthorizationError - for permission failures\nclass AuthorizationError extends Error {\n  constructor(action, resource) {\n    super(`Not authorized to ${action} ${resource}`);\n    this.name = 'AuthorizationError';\n    this.action = action;\n    this.resource = resource;\n    this.statusCode = 403;  // Forbidden\n  }\n}\n\n// Using these in a real scenario\nfunction updateUserProfile(userId, profileData, currentUser) {\n  // Check authentication\n  if (!currentUser) {\n    throw new AuthenticationError('Please log in to update profile');\n  }\n  \n  // Check authorization\n  if (currentUser.id !== userId && !currentUser.isAdmin) {\n    throw new AuthorizationError('update', 'user profile');\n  }\n  \n  // Validate input\n  if (!profileData.email || !profileData.email.includes('@')) {\n    throw new ValidationError(\n      'Invalid email format',\n      'email',\n      profileData.email\n    );\n  }\n  \n  // Find user (might not exist)\n  const user = findUserById(userId);\n  if (!user) {\n    throw new NotFoundError('User', userId);\n  }\n  \n  // Update the profile...\n  return { success: true };\n}\n\n// Handling different error types\ntry {\n  updateUserProfile(123, { email: 'invalid' }, null);\n} catch (error) {\n  if (error instanceof AuthenticationError) {\n    console.log('Please log in:', error.message);\n  } else if (error instanceof AuthorizationError) {\n    console.log('Permission denied:', error.message);\n  } else if (error instanceof ValidationError) {\n    console.log(`Invalid ${error.field}:`, error.message);\n  } else if (error instanceof NotFoundError) {\n    console.log('Resource not found:', error.message);\n  } else {\n    console.log('Unexpected error:', error.message);\n  }\n}"
            },
            {
              "type": "EXAMPLE",
              "title": "Using instanceof to Check Error Types",
              "content": "The instanceof operator lets you handle different error types differently, enabling precise error handling.",
              "language": "javascript",
              "code": "// Define a hierarchy of errors\nclass AppError extends Error {\n  constructor(message, statusCode = 500) {\n    super(message);\n    this.name = 'AppError';\n    this.statusCode = statusCode;\n  }\n}\n\nclass ClientError extends AppError {\n  constructor(message, statusCode = 400) {\n    super(message, statusCode);\n    this.name = 'ClientError';\n  }\n}\n\nclass ServerError extends AppError {\n  constructor(message) {\n    super(message, 500);\n    this.name = 'ServerError';\n  }\n}\n\nclass ValidationError extends ClientError {\n  constructor(message, field) {\n    super(message, 400);\n    this.name = 'ValidationError';\n    this.field = field;\n  }\n}\n\nclass NotFoundError extends ClientError {\n  constructor(resource) {\n    super(`${resource} not found`, 404);\n    this.name = 'NotFoundError';\n    this.resource = resource;\n  }\n}\n\n// Using instanceof for type-specific handling\nfunction handleError(error) {\n  // Check most specific types first!\n  if (error instanceof ValidationError) {\n    return {\n      status: error.statusCode,\n      body: {\n        error: 'Validation failed',\n        field: error.field,\n        message: error.message\n      }\n    };\n  }\n  \n  if (error instanceof NotFoundError) {\n    return {\n      status: 404,\n      body: {\n        error: 'Not found',\n        resource: error.resource\n      }\n    };\n  }\n  \n  if (error instanceof ClientError) {\n    return {\n      status: error.statusCode,\n      body: { error: error.message }\n    };\n  }\n  \n  if (error instanceof ServerError) {\n    // Don't expose server error details to clients\n    console.error('Server error:', error.message);\n    return {\n      status: 500,\n      body: { error: 'Internal server error' }\n    };\n  }\n  \n  // Unknown error type\n  console.error('Unexpected error:', error);\n  return {\n    status: 500,\n    body: { error: 'Something went wrong' }\n  };\n}\n\n// Testing\nconsole.log(handleError(new ValidationError('Email is required', 'email')));\n// { status: 400, body: { error: 'Validation failed', field: 'email', message: 'Email is required' } }\n\nconsole.log(handleError(new NotFoundError('User')));\n// { status: 404, body: { error: 'Not found', resource: 'User' } }\n\n// Hierarchy check - ValidationError is also a ClientError and AppError!\nlet validationErr = new ValidationError('Bad input', 'name');\nconsole.log(validationErr instanceof ValidationError); // true\nconsole.log(validationErr instanceof ClientError);     // true\nconsole.log(validationErr instanceof AppError);        // true\nconsole.log(validationErr instanceof Error);           // true"
            },
            {
              "type": "THEORY",
              "title": "Error Class Hierarchy and Inheritance",
              "content": "Understanding error class inheritance is crucial for building a robust error handling system:\n\n**Inheritance Chain:**\n```\nError (built-in)\n  └─ AppError (your base error)\n       ├─ ClientError (4xx errors)\n       │    ├─ ValidationError (400)\n       │    ├─ AuthenticationError (401)\n       │    ├─ AuthorizationError (403)\n       │    └─ NotFoundError (404)\n       └─ ServerError (5xx errors)\n            ├─ DatabaseError (500)\n            └─ ExternalServiceError (502/503)\n```\n\n**Benefits of Hierarchy:**\n\n1. **Catch at any level:**\n```javascript\ncatch (error) {\n  if (error instanceof ClientError) {\n    // Catches ValidationError, NotFoundError, etc.\n  }\n}\n```\n\n2. **Share common behavior:**\n```javascript\nclass AppError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.statusCode = statusCode;\n    this.timestamp = Date.now();\n  }\n  \n  // All subclasses get this method\n  toJSON() {\n    return { message: this.message, status: this.statusCode };\n  }\n}\n```\n\n3. **Type-safe handling:**\n```javascript\n// Handle specific, then general\nif (error instanceof ValidationError) {\n  // Most specific\n} else if (error instanceof ClientError) {\n  // General client errors\n} else if (error instanceof AppError) {\n  // All app errors\n} else {\n  // Unknown errors\n}\n```\n\n**Design Principles:**\n- Always extend from Error or your base AppError\n- Keep the hierarchy shallow (2-3 levels max)\n- Group errors by who can fix them (client vs server)\n- Include HTTP status codes for API errors\n- Add context-specific properties (field, resource, etc.)"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "**1. Forgetting to call super():**\n```javascript\n// BAD: Missing super() call\nclass MyError extends Error {\n  constructor(message) {\n    this.name = 'MyError'; // ERROR: Must call super first!\n    this.message = message;\n  }\n}\n\n// GOOD: Always call super() first\nclass MyError extends Error {\n  constructor(message) {\n    super(message);         // MUST be first!\n    this.name = 'MyError';\n  }\n}\n```\n\n**2. Not setting the name property:**\n```javascript\n// BAD: Name defaults to 'Error'\nclass MyError extends Error {\n  constructor(message) {\n    super(message);\n    // Forgot to set this.name!\n  }\n}\nnew MyError('test').name; // 'Error' - not helpful!\n\n// GOOD: Always set the name\nclass MyError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'MyError';  // Now identifiable!\n  }\n}\n```\n\n**3. Checking instanceof in wrong order:**\n```javascript\n// BAD: Base class catches everything\nif (error instanceof AppError) {\n  // This catches ALL app errors!\n} else if (error instanceof ValidationError) {\n  // Never reached! ValidationError is an AppError\n}\n\n// GOOD: Check specific types first\nif (error instanceof ValidationError) {\n  // Most specific first\n} else if (error instanceof AppError) {\n  // General fallback\n}\n```\n\n**4. Throwing strings instead of Error objects:**\n```javascript\n// BAD: Throwing a string\nthrow 'Something went wrong';\n\n// GOOD: Always throw Error instances\nthrow new Error('Something went wrong');\nthrow new ValidationError('Invalid email', 'email');\n```\n\n**5. Not preserving the original error:**\n```javascript\n// BAD: Losing original error information\ntry {\n  someOperation();\n} catch (originalError) {\n  throw new AppError('Operation failed');\n  // Original error details are lost!\n}\n\n// GOOD: Preserve with cause\ntry {\n  someOperation();\n} catch (originalError) {\n  throw new AppError('Operation failed', {\n    cause: originalError\n  });\n}\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "9.3-challenge",
              "title": "Create an API Error System",
              "description": "Build a complete API error system with these classes:\n\n1. `APIError` (base class) - has message, statusCode, and errorCode\n2. `BadRequestError` (extends APIError) - statusCode 400\n3. `UnauthorizedError` (extends APIError) - statusCode 401\n4. `NotFoundError` (extends APIError) - statusCode 404\n\nEach should have a toResponse() method that returns { status, body } for API responses.",
              "instructions": "Create a hierarchy of API error classes. The base APIError should accept message, statusCode, and errorCode. Each specific error type should have a default statusCode. All classes should have a toResponse() method for generating API responses.",
              "starterCode": "// Base API error class\nclass APIError extends Error {\n  // YOUR CODE HERE\n}\n\n// Bad Request (400)\nclass BadRequestError extends APIError {\n  // YOUR CODE HERE\n}\n\n// Unauthorized (401)\nclass UnauthorizedError extends APIError {\n  // YOUR CODE HERE\n}\n\n// Not Found (404)\nclass NotFoundError extends APIError {\n  // YOUR CODE HERE\n}\n\n// Test your error classes\nlet badReq = new BadRequestError('Invalid input', 'INVALID_INPUT');\nconsole.log(badReq.toResponse());\n\nlet unauth = new UnauthorizedError('Token expired', 'TOKEN_EXPIRED');\nconsole.log(unauth.toResponse());\n\nlet notFound = new NotFoundError('User not found', 'USER_NOT_FOUND');\nconsole.log(notFound.toResponse());\n\n// Test instanceof\nconsole.log(badReq instanceof APIError); // should be true\nconsole.log(notFound instanceof Error);  // should be true",
              "solution": "// Base API error class\nclass APIError extends Error {\n  constructor(message, statusCode = 500, errorCode = 'INTERNAL_ERROR') {\n    super(message);\n    this.name = 'APIError';\n    this.statusCode = statusCode;\n    this.errorCode = errorCode;\n  }\n  \n  toResponse() {\n    return {\n      status: this.statusCode,\n      body: {\n        error: this.errorCode,\n        message: this.message\n      }\n    };\n  }\n}\n\n// Bad Request (400)\nclass BadRequestError extends APIError {\n  constructor(message, errorCode = 'BAD_REQUEST') {\n    super(message, 400, errorCode);\n    this.name = 'BadRequestError';\n  }\n}\n\n// Unauthorized (401)\nclass UnauthorizedError extends APIError {\n  constructor(message = 'Unauthorized', errorCode = 'UNAUTHORIZED') {\n    super(message, 401, errorCode);\n    this.name = 'UnauthorizedError';\n  }\n}\n\n// Not Found (404)\nclass NotFoundError extends APIError {\n  constructor(message = 'Resource not found', errorCode = 'NOT_FOUND') {\n    super(message, 404, errorCode);\n    this.name = 'NotFoundError';\n  }\n}\n\n// Test your error classes\nlet badReq = new BadRequestError('Invalid input', 'INVALID_INPUT');\nconsole.log(badReq.toResponse());\n// { status: 400, body: { error: 'INVALID_INPUT', message: 'Invalid input' } }\n\nlet unauth = new UnauthorizedError('Token expired', 'TOKEN_EXPIRED');\nconsole.log(unauth.toResponse());\n// { status: 401, body: { error: 'TOKEN_EXPIRED', message: 'Token expired' } }\n\nlet notFound = new NotFoundError('User not found', 'USER_NOT_FOUND');\nconsole.log(notFound.toResponse());\n// { status: 404, body: { error: 'USER_NOT_FOUND', message: 'User not found' } }\n\n// Test instanceof\nconsole.log(badReq instanceof APIError); // true\nconsole.log(notFound instanceof Error);  // true",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "BadRequestError returns correct status 400",
                  "expectedOutput": "{ status: 400, body: { error: 'INVALID_INPUT', message: 'Invalid input' } }",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "UnauthorizedError returns correct status 401",
                  "expectedOutput": "{ status: 401, body: { error: 'TOKEN_EXPIRED', message: 'Token expired' } }",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "All errors are instanceof APIError",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with APIError: constructor takes message, statusCode, errorCode. Call super(message) first, then set properties."
                },
                {
                  "level": 2,
                  "text": "For subclasses, call super(message, statusCode, errorCode) with the correct default statusCode for that error type."
                },
                {
                  "level": 3,
                  "text": "toResponse() should return { status: this.statusCode, body: { error: this.errorCode, message: this.message } }."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not calling super() in subclass constructors",
                  "consequence": "JavaScript requires super() to be called before accessing 'this' in derived classes.",
                  "correction": "Always call super() first in the constructor: super(message, 400, errorCode)"
                },
                {
                  "mistake": "Defining toResponse() separately in each subclass",
                  "consequence": "Code duplication. The base class method is inherited automatically.",
                  "correction": "Define toResponse() only in APIError. Subclasses inherit it automatically."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "9.4",
          "title": "Error Handling in Async Code",
          "moduleId": "module-error-handling",
          "order": 4,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you take a new medication and the doctor warns you about potential side effects. Some side effects happen immediately - you take the pill and feel dizzy right away. But other side effects are delayed - you might not have a reaction until hours or days later when the medication has had time to work through your system.\n\nSynchronous errors are like immediate side effects - they happen right when you run the code, and try-catch catches them instantly. But async errors are like delayed reactions. If you wrap an async operation in a regular try-catch and walk away, when the delayed error happens, there's no one there to catch it.\n\nThis is why async error handling requires special attention. You need to set up error handling that's still 'listening' when the async operation eventually fails. With async/await, you use try-catch that waits for the operation. With Promises, you use .catch() that stays attached to the promise. Either way, you need error handling that's patient enough to wait for delayed problems."
            },
            {
              "type": "EXAMPLE",
              "title": "The try/await/catch Pattern",
              "content": "The most important pattern for modern async error handling. This is what you'll use 90% of the time.",
              "language": "javascript",
              "code": "// The try/await/catch pattern - your go-to for async errors\nasync function fetchUserData(userId) {\n  try {\n    // await pauses until the promise resolves or rejects\n    const response = await fetch(`/api/users/${userId}`);\n    \n    // Check for HTTP errors (fetch doesn't throw on 404/500)\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    console.log('User data:', data);\n    return data;\n    \n  } catch (error) {\n    // This catches BOTH network errors AND HTTP errors\n    console.error('Failed to fetch user:', error.message);\n    return null;\n  }\n}\n\n// Calling async functions\nasync function main() {\n  const user = await fetchUserData(123);\n  if (user) {\n    console.log('Got user:', user.name);\n  } else {\n    console.log('Could not load user');\n  }\n}\n\nmain();\n\n// Multiple await calls in one try block\nasync function getFullProfile(userId) {\n  try {\n    const user = await fetchUser(userId);\n    const posts = await fetchUserPosts(userId);\n    const friends = await fetchUserFriends(userId);\n    \n    return { user, posts, friends };\n    \n  } catch (error) {\n    // Any of the three awaits can trigger this catch\n    console.error('Failed to load profile:', error.message);\n    return null;\n  }\n}\n\n// With finally for cleanup\nasync function loadDataWithLoading() {\n  showLoadingSpinner();\n  \n  try {\n    const data = await fetchData();\n    displayData(data);\n  } catch (error) {\n    showError(error.message);\n  } finally {\n    // Always hide spinner, success or failure\n    hideLoadingSpinner();\n  }\n}"
            },
            {
              "type": "EXAMPLE",
              "title": "Promise.catch() Method",
              "content": "When working with Promises directly (without async/await), use .catch() to handle rejections.",
              "language": "javascript",
              "code": "// Using .catch() with promises\nfetch('/api/data')\n  .then(response => response.json())\n  .then(data => {\n    console.log('Data:', data);\n  })\n  .catch(error => {\n    // Catches errors from fetch OR from .json() OR from data processing\n    console.error('Error:', error.message);\n  });\n\n// Catch at different points in the chain\nfetch('/api/data')\n  .then(response => {\n    if (!response.ok) {\n      throw new Error('Network response was not ok');\n    }\n    return response.json();\n  })\n  .then(data => processData(data))\n  .then(result => saveResult(result))\n  .catch(error => {\n    // Catches errors from ANY step above\n    console.error('Pipeline failed:', error.message);\n  })\n  .finally(() => {\n    // Runs after success OR failure\n    console.log('Request completed');\n  });\n\n// Multiple catch handlers for different stages\nfetch('/api/data')\n  .then(response => response.json())\n  .catch(error => {\n    // Handle network/parsing errors, provide fallback\n    console.log('Network error, using cache');\n    return getCachedData();\n  })\n  .then(data => processData(data))\n  .catch(error => {\n    // Handle processing errors\n    console.log('Processing error:', error.message);\n    return null;\n  });\n\n// Convert callback-based to promise\nfunction readFilePromise(path) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(path, 'utf8', (err, data) => {\n      if (err) reject(err);\n      else resolve(data);\n    });\n  });\n}\n\nreadFilePromise('/path/to/file')\n  .then(content => console.log('Content:', content))\n  .catch(error => console.error('Read failed:', error.message));"
            },
            {
              "type": "EXAMPLE",
              "title": "Promise.all() - Fails Fast on First Error",
              "content": "Promise.all() runs promises in parallel but fails immediately when any promise rejects.",
              "language": "javascript",
              "code": "// Promise.all - fails fast on first error\nasync function fetchAllUsers(userIds) {\n  try {\n    // Create an array of promises\n    const promises = userIds.map(id => fetchUser(id));\n    \n    // Wait for ALL to complete\n    const users = await Promise.all(promises);\n    console.log('All users loaded:', users.length);\n    return users;\n    \n  } catch (error) {\n    // If ANY promise rejects, we end up here immediately\n    // Other promises continue running but results are discarded\n    console.error('Failed to load users:', error.message);\n    return [];\n  }\n}\n\n// Demonstrating fail-fast behavior\nasync function demo() {\n  const slowSuccess = new Promise(resolve => {\n    setTimeout(() => {\n      console.log('Slow success completed');\n      resolve('slow');\n    }, 2000);\n  });\n  \n  const fastFailure = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('Fast failure happening');\n      reject(new Error('Fast failure'));\n    }, 500);\n  });\n  \n  try {\n    // This will fail after 500ms even though slowSuccess needs 2000ms\n    const results = await Promise.all([slowSuccess, fastFailure]);\n    console.log('Results:', results); // Never reached\n  } catch (error) {\n    console.log('Caught after ~500ms:', error.message);\n    // Output: Caught after ~500ms: Fast failure\n    // Note: 'Slow success completed' will still log after 2 seconds!\n  }\n}\n\ndemo();\n\n// Real-world example: Loading dashboard data\nasync function loadDashboard(userId) {\n  try {\n    const [user, stats, notifications] = await Promise.all([\n      fetchUser(userId),\n      fetchUserStats(userId),\n      fetchNotifications(userId)\n    ]);\n    \n    return { user, stats, notifications };\n  } catch (error) {\n    console.error('Dashboard load failed:', error.message);\n    // If any request fails, entire dashboard fails\n    throw error;\n  }\n}"
            },
            {
              "type": "EXAMPLE",
              "title": "Promise.allSettled() - Waits for All, Reports Each Status",
              "content": "Promise.allSettled() waits for all promises and tells you which succeeded and which failed.",
              "language": "javascript",
              "code": "// Promise.allSettled - wait for ALL, never rejects\nasync function fetchAllUsersSettled(userIds) {\n  const promises = userIds.map(id => fetchUser(id));\n  \n  // allSettled ALWAYS resolves, never rejects\n  const results = await Promise.allSettled(promises);\n  \n  // Each result has { status: 'fulfilled', value } or { status: 'rejected', reason }\n  \n  const successful = results\n    .filter(r => r.status === 'fulfilled')\n    .map(r => r.value);\n    \n  const failed = results\n    .filter(r => r.status === 'rejected')\n    .map(r => r.reason);\n  \n  console.log(`Loaded ${successful.length} users, ${failed.length} failed`);\n  \n  return { successful, failed };\n}\n\n// Example output:\n// {\n//   successful: [{ id: 1, name: 'Alice' }, { id: 3, name: 'Charlie' }],\n//   failed: [Error: User 2 not found]\n// }\n\n// Real-world example: Sending notifications\nasync function sendNotifications(users, message) {\n  const results = await Promise.allSettled(\n    users.map(user => sendNotification(user.id, message))\n  );\n  \n  const sent = [];\n  const failed = [];\n  \n  results.forEach((result, index) => {\n    if (result.status === 'fulfilled') {\n      sent.push(users[index]);\n    } else {\n      failed.push({\n        user: users[index],\n        error: result.reason.message\n      });\n    }\n  });\n  \n  console.log(`Notifications: ${sent.length} sent, ${failed.length} failed`);\n  \n  // Can retry failed ones\n  if (failed.length > 0) {\n    console.log('Failed users:', failed.map(f => f.user.name).join(', '));\n  }\n  \n  return { sent, failed };\n}\n\n// Comparing Promise.all vs Promise.allSettled\nasync function comparison() {\n  const promises = [\n    Promise.resolve('A'),\n    Promise.reject(new Error('B failed')),\n    Promise.resolve('C')\n  ];\n  \n  // Promise.all - fails fast, you only get the error\n  try {\n    const results = await Promise.all(promises);\n  } catch (error) {\n    console.log('Promise.all caught:', error.message);\n    // 'A' and 'C' results are lost!\n  }\n  \n  // Promise.allSettled - you get everything\n  const results = await Promise.allSettled(promises);\n  console.log('Promise.allSettled results:');\n  results.forEach((r, i) => {\n    if (r.status === 'fulfilled') {\n      console.log(`  ${i}: success - ${r.value}`);\n    } else {\n      console.log(`  ${i}: failed - ${r.reason.message}`);\n    }\n  });\n  // Output:\n  // 0: success - A\n  // 1: failed - B failed\n  // 2: success - C\n}"
            },
            {
              "type": "EXAMPLE",
              "title": "Error Propagation Through Async Chains",
              "content": "Understanding how errors flow through async/await chains helps you handle them at the right level.",
              "language": "javascript",
              "code": "// Errors propagate up the async chain automatically\nasync function level3() {\n  throw new Error('Error in level 3');\n}\n\nasync function level2() {\n  // If we don't catch, error propagates up\n  return await level3();\n}\n\nasync function level1() {\n  // If we don't catch, error propagates up\n  return await level2();\n}\n\nasync function main() {\n  try {\n    await level1();\n  } catch (error) {\n    // Catches error from level3, even though it bubbled through level2 and level1\n    console.log('Caught in main:', error.message);\n  }\n}\n\nmain();\n\n// Adding context as errors propagate\nasync function fetchData() {\n  throw new Error('Network timeout');\n}\n\nasync function processUserData(userId) {\n  try {\n    const data = await fetchData();\n    return transform(data);\n  } catch (error) {\n    // Add context and re-throw\n    throw new Error(`Failed to process user ${userId}`, { cause: error });\n  }\n}\n\nasync function generateReport(userIds) {\n  try {\n    const results = [];\n    for (const userId of userIds) {\n      results.push(await processUserData(userId));\n    }\n    return results;\n  } catch (error) {\n    // Add more context and re-throw\n    throw new Error('Report generation failed', { cause: error });\n  }\n}\n\nasync function main() {\n  try {\n    await generateReport([1, 2, 3]);\n  } catch (error) {\n    // Full error chain preserved\n    console.log('Main error:', error.message);\n    console.log('Caused by:', error.cause?.message);\n    console.log('Root cause:', error.cause?.cause?.message);\n  }\n}\n\nmain();\n// Output:\n// Main error: Report generation failed\n// Caused by: Failed to process user 1\n// Root cause: Network timeout"
            },
            {
              "type": "EXAMPLE",
              "title": "Always Handle Rejections",
              "content": "Unhandled promise rejections can crash Node.js or cause subtle bugs in browsers. Always catch them.",
              "language": "javascript",
              "code": "// BAD: Unhandled rejection\nasync function riskyFunction() {\n  throw new Error('Something went wrong');\n}\n\nriskyFunction(); // No await, no catch - unhandled rejection!\n\n// GOOD: Always handle rejections\nasync function riskyFunction() {\n  throw new Error('Something went wrong');\n}\n\n// Option 1: await in try-catch\nasync function main() {\n  try {\n    await riskyFunction();\n  } catch (error) {\n    console.error('Caught:', error.message);\n  }\n}\nmain();\n\n// Option 2: .catch() on the promise\nriskyFunction().catch(error => {\n  console.error('Caught:', error.message);\n});\n\n// Real scenario: Fire-and-forget with error handling\nfunction logUserAction(userId, action) {\n  // This is async but we don't need to wait for it\n  // STILL need to handle potential errors!\n  saveToAnalytics(userId, action)\n    .catch(error => {\n      console.error('Failed to log action:', error.message);\n      // Maybe queue for retry later\n    });\n}\n\n// Called without await - that's OK since we have .catch()\nlogUserAction(123, 'clicked_button');\n\n// Multiple independent async operations\nasync function processMultiple(items) {\n  // Don't do this - unhandled if any reject!\n  items.forEach(item => processItem(item));\n  \n  // Do this instead:\n  await Promise.all(\n    items.map(item => \n      processItem(item).catch(error => {\n        console.error(`Failed to process ${item.id}:`, error.message);\n        return null; // Return null for failed items\n      })\n    )\n  );\n}"
            },
            {
              "type": "THEORY",
              "title": "Unhandled Promise Rejection Behavior",
              "content": "Understanding what happens when promise rejections aren't handled:\n\n**In Node.js (v15+):**\n- Unhandled rejections crash the process by default\n- This is intentional - unhandled errors are bugs!\n- Can be configured with --unhandled-rejections flag\n\n**In Browsers:**\n- Logs a warning to console\n- Does NOT crash the page\n- Still a bug - should always be handled\n\n**Detecting Unhandled Rejections:**\n\n```javascript\n// Browser\nwindow.addEventListener('unhandledrejection', event => {\n  console.error('Unhandled rejection:', event.reason);\n  event.preventDefault(); // Prevent default logging\n});\n\n// Node.js\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled rejection at:', promise);\n  console.error('Reason:', reason);\n});\n```\n\n**Common Causes:**\n1. Forgetting to await: `asyncFunction();` instead of `await asyncFunction();`\n2. Missing .catch(): `promise.then(...)` without `.catch(...)`\n3. Errors in .then() without a .catch()\n4. Throwing in async function called without await\n\n**Best Practices:**\n1. Always await async functions in try-catch blocks\n2. Always add .catch() to promise chains\n3. Use linting rules to catch missing error handling\n4. Set up global rejection handlers as a safety net\n5. In production, log unhandled rejections to monitoring"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "**1. Forgetting await before async calls:**\n```javascript\n// BAD: No await - error escapes try-catch!\ntry {\n  fetchData(); // Returns promise, doesn't wait\n} catch (error) {\n  console.log('Never runs!'); // Promise rejection is unhandled\n}\n\n// GOOD: Always await\ntry {\n  await fetchData();\n} catch (error) {\n  console.log('Now it catches!');\n}\n```\n\n**2. Not catching in async functions:**\n```javascript\n// BAD: Async function without error handling\nasync function loadData() {\n  const data = await fetch('/api/data'); // Can throw!\n  return data.json();\n}\n\n// If fetch fails, the error propagates as an unhandled rejection\nloadData(); // Unhandled if called without catch!\n\n// GOOD: Handle internally OR make caller responsible\nasync function loadData() {\n  try {\n    const data = await fetch('/api/data');\n    return data.json();\n  } catch (error) {\n    console.error('Failed:', error);\n    return null;\n  }\n}\n```\n\n**3. Mixing async patterns incorrectly:**\n```javascript\n// BAD: try-catch doesn't catch .then() rejections\ntry {\n  fetch('/api').then(r => r.json()).then(data => {\n    throw new Error('Oops'); // Unhandled!\n  });\n} catch (e) {\n  console.log('Never catches the throw above');\n}\n\n// GOOD: Use either async/await OR promise chains, not both\nasync function correct() {\n  try {\n    const r = await fetch('/api');\n    const data = await r.json();\n    // Now throwing here IS caught\n    throw new Error('Oops');\n  } catch (e) {\n    console.log('Caught:', e.message);\n  }\n}\n```\n\n**4. Using Promise.all when allSettled is needed:**\n```javascript\n// BAD: One failure loses all results\nconst results = await Promise.all(urls.map(url => fetch(url)));\n// If ANY fails, you get NOTHING\n\n// GOOD: Use allSettled when you want partial results\nconst results = await Promise.allSettled(urls.map(url => fetch(url)));\nconst successful = results.filter(r => r.status === 'fulfilled');\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "9.4-challenge",
              "title": "Handle Errors in Parallel API Calls",
              "description": "Create a function `fetchMultipleUsers` that:\n\n1. Takes an array of user IDs\n2. Fetches each user in parallel (use Promise.allSettled)\n3. Returns an object with:\n   - `users`: array of successfully fetched users\n   - `errors`: array of { id, message } for failed fetches\n\nSimulate fetching with the provided `mockFetchUser` function.",
              "instructions": "Create a function that fetches multiple users in parallel, handles individual failures gracefully, and returns both successful results and error information.",
              "starterCode": "// Simulated fetch function - some users exist, some don't\nfunction mockFetchUser(userId) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId % 2 === 0) {\n        resolve({ id: userId, name: `User ${userId}` });\n      } else {\n        reject(new Error(`User ${userId} not found`));\n      }\n    }, 100);\n  });\n}\n\nasync function fetchMultipleUsers(userIds) {\n  // YOUR CODE HERE\n  // 1. Use Promise.allSettled to fetch all users in parallel\n  // 2. Separate successful results from failures\n  // 3. Return { users: [...], errors: [...] }\n}\n\n// Test it\nasync function main() {\n  const result = await fetchMultipleUsers([1, 2, 3, 4, 5]);\n  console.log('Users:', result.users);\n  console.log('Errors:', result.errors);\n}\n\nmain();",
              "solution": "// Simulated fetch function - some users exist, some don't\nfunction mockFetchUser(userId) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId % 2 === 0) {\n        resolve({ id: userId, name: `User ${userId}` });\n      } else {\n        reject(new Error(`User ${userId} not found`));\n      }\n    }, 100);\n  });\n}\n\nasync function fetchMultipleUsers(userIds) {\n  // Fetch all users in parallel\n  const results = await Promise.allSettled(\n    userIds.map(id => mockFetchUser(id))\n  );\n  \n  const users = [];\n  const errors = [];\n  \n  // Process each result\n  results.forEach((result, index) => {\n    if (result.status === 'fulfilled') {\n      users.push(result.value);\n    } else {\n      errors.push({\n        id: userIds[index],\n        message: result.reason.message\n      });\n    }\n  });\n  \n  return { users, errors };\n}\n\n// Test it\nasync function main() {\n  const result = await fetchMultipleUsers([1, 2, 3, 4, 5]);\n  console.log('Users:', result.users);\n  // Users: [{ id: 2, name: 'User 2' }, { id: 4, name: 'User 4' }]\n  console.log('Errors:', result.errors);\n  // Errors: [{ id: 1, message: 'User 1 not found' }, { id: 3, message: 'User 3 not found' }, { id: 5, message: 'User 5 not found' }]\n}\n\nmain();",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Returns users array with successful fetches",
                  "expectedOutput": "[{ id: 2, name: 'User 2' }, { id: 4, name: 'User 4' }]",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Returns errors array with failed fetches",
                  "expectedOutput": "[{ id: 1, message: 'User 1 not found' }, { id: 3, message: 'User 3 not found' }, { id: 5, message: 'User 5 not found' }]",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Handles all successful fetches",
                  "expectedOutput": "{ users: [{ id: 2 }, { id: 4 }], errors: [] }",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use Promise.allSettled(userIds.map(id => mockFetchUser(id))) to fetch all users in parallel."
                },
                {
                  "level": 2,
                  "text": "Each result from allSettled has { status: 'fulfilled', value } or { status: 'rejected', reason }."
                },
                {
                  "level": 3,
                  "text": "Use forEach with the index parameter to match results back to their original userIds."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using Promise.all instead of Promise.allSettled",
                  "consequence": "Promise.all fails fast - if any user fetch fails, you lose all successful results.",
                  "correction": "Use Promise.allSettled to get results for all promises, even if some reject."
                },
                {
                  "mistake": "Forgetting to use async/await",
                  "consequence": "The function returns before the promises resolve, giving incorrect results.",
                  "correction": "Mark the function as async and await Promise.allSettled."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "9.5",
          "title": "Global Error Handlers & Monitoring",
          "moduleId": "module-error-handling",
          "order": 5,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of global error handlers like security cameras in a building. Throughout the building, you have individual locks on doors (local try-catch blocks) - these are your first line of defense. But security cameras at every exit capture anyone who slips past the individual locks. They don't replace the door locks, but they're essential for catching what gets through.\n\nGlobal error handlers work the same way. Your local try-catch blocks are the door locks - they should handle most errors right where they occur. But sometimes errors escape: maybe you forgot a try-catch, maybe an error happened in code you don't control, or maybe a third-party library threw unexpectedly.\n\nGlobal handlers are your security cameras - they catch these escaped errors at the 'exits' of your application. In browsers, the exits are unhandled exceptions and unhandled promise rejections. In Node.js, they're uncaught exceptions and unhandled rejections.\n\nRemember: global handlers are your LAST line of defense, not your first. Good code catches errors locally. Global handlers are for logging, monitoring, and graceful shutdown - not for your primary error handling strategy."
            },
            {
              "type": "EXAMPLE",
              "title": "window.onerror (Browser)",
              "content": "The classic browser global error handler for synchronous errors.",
              "language": "javascript",
              "code": "// window.onerror - catches uncaught synchronous errors\nwindow.onerror = function(message, source, lineno, colno, error) {\n  console.log('=== Global Error Handler ===');\n  console.log('Message:', message);\n  console.log('Source:', source);    // Script URL\n  console.log('Line:', lineno);       // Line number\n  console.log('Column:', colno);      // Column number\n  console.log('Error object:', error); // Full error object\n  \n  // Send to your error tracking service\n  sendToErrorService({\n    type: 'uncaught_error',\n    message: message,\n    source: source,\n    line: lineno,\n    column: colno,\n    stack: error?.stack\n  });\n  \n  // Return true to prevent default browser error logging\n  // Return false (or nothing) to still log to console\n  return false;\n};\n\n// Using addEventListener (modern approach)\nwindow.addEventListener('error', function(event) {\n  console.log('Error event:', event.error);\n  console.log('Error message:', event.message);\n  console.log('Filename:', event.filename);\n  console.log('Line:', event.lineno);\n  \n  // Can prevent default error logging\n  // event.preventDefault();\n});\n\n// Testing it\nfunction causeError() {\n  // This error will be caught by window.onerror\n  throw new Error('Uncaught error in function');\n}\n\n// causeError(); // Uncomment to test\n\n// Note: window.onerror does NOT catch:\n// - Promise rejections (use onunhandledrejection)\n// - Errors in async code without await\n// - Syntax errors (script won't run at all)"
            },
            {
              "type": "EXAMPLE",
              "title": "window.onunhandledrejection (Browser)",
              "content": "Catches unhandled promise rejections in the browser - essential for async error monitoring.",
              "language": "javascript",
              "code": "// window.onunhandledrejection - catches unhandled promise rejections\nwindow.onunhandledrejection = function(event) {\n  console.log('=== Unhandled Promise Rejection ===');\n  console.log('Reason:', event.reason);  // The rejection value\n  console.log('Promise:', event.promise); // The promise that rejected\n  \n  // If reason is an Error, we can get the stack\n  if (event.reason instanceof Error) {\n    console.log('Stack:', event.reason.stack);\n  }\n  \n  // Send to error tracking\n  sendToErrorService({\n    type: 'unhandled_rejection',\n    message: event.reason?.message || String(event.reason),\n    stack: event.reason?.stack\n  });\n  \n  // Prevent default browser warning\n  event.preventDefault();\n};\n\n// Using addEventListener (preferred modern approach)\nwindow.addEventListener('unhandledrejection', function(event) {\n  console.error('Unhandled rejection:', event.reason);\n  \n  // Log it, send to monitoring, etc.\n  logToMonitoringService(event.reason);\n});\n\n// Also useful: rejectionhandled event\n// Fires if a previously unhandled rejection is later handled\nwindow.addEventListener('rejectionhandled', function(event) {\n  console.log('Rejection was handled later:', event.promise);\n});\n\n// Test cases that trigger unhandledrejection:\n\n// 1. Promise rejection without catch\n// Promise.reject(new Error('Rejected!')); // Triggers handler\n\n// 2. Error in async function without try-catch\n// async function test() { throw new Error('Async error'); }\n// test(); // Triggers handler\n\n// 3. Error in .then() without .catch()\n// Promise.resolve().then(() => { throw new Error('In then'); }); // Triggers handler"
            },
            {
              "type": "EXAMPLE",
              "title": "process.on('uncaughtException') (Node.js)",
              "content": "Node.js global handler for synchronous errors that escape all try-catch blocks.",
              "language": "javascript",
              "code": "// process.on('uncaughtException') - Node.js sync error handler\nprocess.on('uncaughtException', (error, origin) => {\n  console.error('=== Uncaught Exception ===');\n  console.error('Error:', error.message);\n  console.error('Stack:', error.stack);\n  console.error('Origin:', origin);\n  \n  // CRITICAL: Log the error\n  logToFile('uncaught-exception', {\n    message: error.message,\n    stack: error.stack,\n    origin: origin,\n    timestamp: new Date().toISOString()\n  });\n  \n  // Send to external monitoring\n  sendToMonitoring(error);\n  \n  // IMPORTANT: After an uncaught exception, the process is in an\n  // undefined state. You should exit after cleanup!\n  \n  // Give time for async logging to complete\n  setTimeout(() => {\n    process.exit(1); // Exit with error code\n  }, 1000);\n});\n\n// Example of what triggers this:\nfunction causeSyncError() {\n  JSON.parse('invalid json'); // Throws SyntaxError\n}\n\n// If this runs without try-catch around it:\n// causeSyncError(); // Would trigger uncaughtException handler\n\n// WARNING: The Node.js docs say:\n// \"Note that 'uncaughtException' is a crude mechanism for exception handling\n// intended to be used only as a last resort.\"\n//\n// After an uncaught exception, your app may be in an inconsistent state.\n// The recommended approach is:\n// 1. Log the error\n// 2. Attempt graceful shutdown\n// 3. Exit the process\n// 4. Let a process manager (PM2, Docker, etc.) restart the app"
            },
            {
              "type": "EXAMPLE",
              "title": "process.on('unhandledRejection') (Node.js)",
              "content": "Node.js global handler for promise rejections that aren't caught.",
              "language": "javascript",
              "code": "// process.on('unhandledRejection') - Node.js async error handler\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('=== Unhandled Rejection ===');\n  console.error('Reason:', reason);\n  console.error('Promise:', promise);\n  \n  // If reason is an Error, log the stack\n  if (reason instanceof Error) {\n    console.error('Stack:', reason.stack);\n  }\n  \n  // Log to file and monitoring\n  logToFile('unhandled-rejection', {\n    message: reason?.message || String(reason),\n    stack: reason?.stack,\n    timestamp: new Date().toISOString()\n  });\n  \n  // In Node.js 15+, unhandled rejections crash the process by default\n  // In earlier versions, they just warn\n  // You can throw to convert to uncaughtException:\n  // throw reason;\n});\n\n// Also track when rejections are later handled\nprocess.on('rejectionHandled', (promise) => {\n  console.log('A rejection was handled late:', promise);\n});\n\n// Setting up both handlers together (common pattern)\nfunction setupGlobalErrorHandlers() {\n  process.on('uncaughtException', (error, origin) => {\n    console.error('Uncaught exception:', error.message);\n    logError('uncaughtException', error);\n    gracefulShutdown(1);\n  });\n  \n  process.on('unhandledRejection', (reason, promise) => {\n    console.error('Unhandled rejection:', reason);\n    logError('unhandledRejection', reason);\n    // In Node 15+, this will crash. Handle or let it crash.\n  });\n  \n  // Optional: Handle warning events\n  process.on('warning', (warning) => {\n    console.warn('Warning:', warning.name, warning.message);\n  });\n}\n\nsetupGlobalErrorHandlers();"
            },
            {
              "type": "EXAMPLE",
              "title": "Graceful Shutdown Patterns",
              "content": "When a fatal error occurs, gracefully shutting down prevents data loss and corruption.",
              "language": "javascript",
              "code": "// Graceful shutdown pattern for Node.js servers\nlet isShuttingDown = false;\n\nasync function gracefulShutdown(code = 0) {\n  if (isShuttingDown) {\n    console.log('Shutdown already in progress...');\n    return;\n  }\n  \n  isShuttingDown = true;\n  console.log('Starting graceful shutdown...');\n  \n  try {\n    // 1. Stop accepting new requests\n    console.log('Closing HTTP server...');\n    await new Promise((resolve) => {\n      server.close(resolve);\n    });\n    \n    // 2. Wait for existing requests to complete (with timeout)\n    console.log('Waiting for requests to complete...');\n    await waitForRequests(10000); // 10 second timeout\n    \n    // 3. Close database connections\n    console.log('Closing database connections...');\n    await database.close();\n    \n    // 4. Close other resources (queues, caches, etc.)\n    console.log('Closing message queue...');\n    await messageQueue.close();\n    \n    // 5. Flush any buffered logs\n    console.log('Flushing logs...');\n    await flushLogs();\n    \n    console.log('Graceful shutdown complete');\n    process.exit(code);\n    \n  } catch (error) {\n    console.error('Error during shutdown:', error);\n    process.exit(1);\n  }\n}\n\n// Set up signal handlers for controlled shutdown\nprocess.on('SIGTERM', () => {\n  console.log('Received SIGTERM');\n  gracefulShutdown(0);\n});\n\nprocess.on('SIGINT', () => {\n  console.log('Received SIGINT (Ctrl+C)');\n  gracefulShutdown(0);\n});\n\n// Handle uncaught errors with graceful shutdown\nprocess.on('uncaughtException', async (error) => {\n  console.error('Uncaught exception:', error);\n  await logError(error);\n  await gracefulShutdown(1);\n});\n\nprocess.on('unhandledRejection', async (reason) => {\n  console.error('Unhandled rejection:', reason);\n  await logError(reason);\n  await gracefulShutdown(1);\n});\n\n// Timeout safety - force exit if graceful shutdown takes too long\nfunction forceExitTimeout(ms = 30000) {\n  setTimeout(() => {\n    console.error('Graceful shutdown timeout, forcing exit');\n    process.exit(1);\n  }, ms).unref(); // unref() prevents this timer from keeping the process alive\n}"
            },
            {
              "type": "EXAMPLE",
              "title": "Error Logging and Monitoring Patterns",
              "content": "Professional error logging patterns for production applications.",
              "language": "javascript",
              "code": "// Error logging utility for production\nclass ErrorLogger {\n  constructor(config = {}) {\n    this.serviceName = config.serviceName || 'app';\n    this.environment = config.environment || 'development';\n    this.externalService = config.externalService || null;\n  }\n  \n  formatError(error, context = {}) {\n    return {\n      timestamp: new Date().toISOString(),\n      service: this.serviceName,\n      environment: this.environment,\n      error: {\n        name: error.name,\n        message: error.message,\n        stack: error.stack,\n        cause: error.cause ? this.formatError(error.cause) : undefined\n      },\n      context: context,\n      // Add useful debugging info\n      process: {\n        pid: process.pid,\n        uptime: process.uptime(),\n        memoryUsage: process.memoryUsage()\n      }\n    };\n  }\n  \n  log(error, context = {}) {\n    const formatted = this.formatError(error, context);\n    \n    // Always log to console in development\n    if (this.environment === 'development') {\n      console.error('\\n=== ERROR ===');\n      console.error(JSON.stringify(formatted, null, 2));\n    } else {\n      // In production, log as single JSON line for log aggregators\n      console.error(JSON.stringify(formatted));\n    }\n    \n    // Send to external service (Sentry, DataDog, etc.)\n    if (this.externalService) {\n      this.sendToExternalService(formatted);\n    }\n    \n    return formatted;\n  }\n  \n  async sendToExternalService(errorData) {\n    // Example: Send to error tracking API\n    try {\n      await fetch('https://errors.example.com/api/log', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(errorData)\n      });\n    } catch (sendError) {\n      // Don't let logging errors crash the app!\n      console.error('Failed to send error to external service:', sendError);\n    }\n  }\n}\n\n// Usage\nconst logger = new ErrorLogger({\n  serviceName: 'user-api',\n  environment: process.env.NODE_ENV || 'development'\n});\n\n// In your error handlers\ntry {\n  await processOrder(order);\n} catch (error) {\n  logger.log(error, {\n    orderId: order.id,\n    userId: order.userId,\n    action: 'processOrder'\n  });\n  throw error; // Re-throw if needed\n}"
            },
            {
              "type": "THEORY",
              "title": "When to Use Global Handlers vs Local try-catch",
              "content": "Understanding when to use each type of error handling:\n\n**Use Local try-catch when:**\n- You can meaningfully recover from the error\n- You need to handle the error differently based on context\n- You want to provide fallback behavior\n- You're calling code that you know might throw\n\n```javascript\ntry {\n  const user = await fetchUser(id);\n  return user;\n} catch (error) {\n  // Recover by returning cached user\n  return getCachedUser(id);\n}\n```\n\n**Use Global Handlers when:**\n- As a safety net for errors that escape local handling\n- For logging and monitoring all unhandled errors\n- For graceful shutdown on fatal errors\n- For sending errors to external monitoring services\n\n```javascript\nprocess.on('unhandledRejection', (reason) => {\n  // Log it - this shouldn't happen in well-written code\n  logger.error('Unhandled rejection', { reason });\n  // Maybe alert on-call engineer\n  alertOnCall('Unhandled rejection detected');\n});\n```\n\n**The Error Handling Hierarchy:**\n\n1. **First Line: Local try-catch**\n   - Handle errors where they occur\n   - Recover or transform errors\n   - Most errors should be caught here\n\n2. **Second Line: Function-level handlers**\n   - Catch errors from called functions\n   - Add context before re-throwing\n   - Convert errors to API responses\n\n3. **Third Line: Framework/middleware handlers**\n   - Express error middleware\n   - React error boundaries\n   - Centralized API error formatting\n\n4. **Last Line: Global handlers**\n   - Safety net for escaped errors\n   - Logging and monitoring\n   - Graceful shutdown"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "**1. Using global handlers as primary error handling:**\n```javascript\n// BAD: Relying on global handler instead of local try-catch\nprocess.on('uncaughtException', (error) => {\n  if (error.message.includes('validation')) {\n    // Trying to do business logic in global handler!\n  }\n});\n\n// GOOD: Handle validation locally\ntry {\n  validateInput(data);\n} catch (validationError) {\n  return { error: validationError.message };\n}\n```\n\n**2. Not exiting after uncaughtException:**\n```javascript\n// BAD: Continuing after uncaught exception\nprocess.on('uncaughtException', (error) => {\n  console.log('Error:', error);\n  // App continues in potentially corrupted state!\n});\n\n// GOOD: Log and exit\nprocess.on('uncaughtException', (error) => {\n  console.error('Fatal error:', error);\n  logSync(error); // Use sync logging\n  process.exit(1); // Exit!\n});\n```\n\n**3. Swallowing errors in global handlers:**\n```javascript\n// BAD: Hiding all errors\nwindow.onerror = function() {\n  return true; // Suppresses all error output\n};\n\n// GOOD: Log then optionally suppress\nwindow.onerror = function(msg, url, line, col, error) {\n  sendToMonitoring({ msg, url, line, error });\n  return false; // Still show in console\n};\n```\n\n**4. Async operations in sync error handlers:**\n```javascript\n// BAD: Async logging might not complete\nprocess.on('uncaughtException', async (error) => {\n  await sendToServer(error); // Might not complete!\n  process.exit(1);\n});\n\n// GOOD: Use sync logging or wait properly\nprocess.on('uncaughtException', (error) => {\n  // Sync logging for critical errors\n  fs.writeFileSync('error.log', error.stack);\n  \n  // Or give async time to complete\n  sendToServer(error).finally(() => {\n    process.exit(1);\n  });\n});\n```\n\n**5. Forgetting to set up handlers early:**\n```javascript\n// BAD: Handler registered after app starts\nstartServer();\n// Error happens here before handler is set up!\nprocess.on('uncaughtException', handler);\n\n// GOOD: Set up handlers first\nprocess.on('uncaughtException', handler);\nprocess.on('unhandledRejection', handler);\nstartServer(); // Now handlers catch startup errors too\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "9.5-challenge",
              "title": "Set Up Error Monitoring",
              "description": "Create a complete error monitoring setup with:\n\n1. A `setupErrorHandlers()` function that registers global handlers\n2. An `errorLog` array to store all caught errors\n3. Handlers for both sync errors (window.onerror) and async errors (unhandledrejection)\n4. Each logged error should include: timestamp, type, message, and stack\n\nSimulate testing by calling the provided test functions.",
              "instructions": "Create a browser-compatible error monitoring system that catches both synchronous and asynchronous errors globally, logging them to an array for later analysis or sending to a monitoring service.",
              "starterCode": "const errorLog = [];\n\nfunction setupErrorHandlers() {\n  // YOUR CODE HERE\n  // 1. Set up window.onerror for sync errors\n  // 2. Set up window.onunhandledrejection for async errors\n  // 3. Log errors to errorLog array with: timestamp, type, message, stack\n}\n\n// Helper to view logged errors\nfunction getErrorSummary() {\n  return errorLog.map(e => `[${e.type}] ${e.message}`);\n}\n\n// Set up the handlers\nsetupErrorHandlers();\n\n// Test functions (uncomment to test)\n// function testSyncError() {\n//   throw new Error('Sync test error');\n// }\n\n// function testAsyncError() {\n//   Promise.reject(new Error('Async test error'));\n// }\n\n// After triggering errors:\n// console.log('Logged errors:', getErrorSummary());",
              "solution": "const errorLog = [];\n\nfunction setupErrorHandlers() {\n  // Handle synchronous errors\n  window.onerror = function(message, source, lineno, colno, error) {\n    errorLog.push({\n      timestamp: new Date().toISOString(),\n      type: 'uncaught_exception',\n      message: message,\n      stack: error?.stack || `at ${source}:${lineno}:${colno}`,\n      source: source,\n      line: lineno,\n      column: colno\n    });\n    \n    console.error('[Error Monitor] Sync error caught:', message);\n    return false; // Still show in console\n  };\n  \n  // Handle asynchronous (promise) errors\n  window.onunhandledrejection = function(event) {\n    const reason = event.reason;\n    \n    errorLog.push({\n      timestamp: new Date().toISOString(),\n      type: 'unhandled_rejection',\n      message: reason?.message || String(reason),\n      stack: reason?.stack || 'No stack available'\n    });\n    \n    console.error('[Error Monitor] Async error caught:', reason?.message || reason);\n  };\n  \n  console.log('[Error Monitor] Global error handlers installed');\n}\n\n// Helper to view logged errors\nfunction getErrorSummary() {\n  return errorLog.map(e => `[${e.type}] ${e.message}`);\n}\n\n// Set up the handlers\nsetupErrorHandlers();\n\n// Test functions (uncomment to test)\n// function testSyncError() {\n//   throw new Error('Sync test error');\n// }\n\n// function testAsyncError() {\n//   Promise.reject(new Error('Async test error'));\n// }\n\n// After triggering errors:\n// console.log('Logged errors:', getErrorSummary());\n// Output: ['[uncaught_exception] Sync test error', '[unhandled_rejection] Async test error']",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Captures sync errors with window.onerror",
                  "expectedOutput": "[uncaught_exception] Sync test error",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Captures async errors with onunhandledrejection",
                  "expectedOutput": "[unhandled_rejection] Async test error",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Error entries include timestamp and stack",
                  "expectedOutput": "timestamp and stack properties exist",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "window.onerror receives (message, source, lineno, colno, error) parameters."
                },
                {
                  "level": 2,
                  "text": "window.onunhandledrejection receives an event with a 'reason' property containing the rejection value."
                },
                {
                  "level": 3,
                  "text": "Use new Date().toISOString() for the timestamp. Access error.stack for the stack trace."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using addEventListener instead of direct assignment",
                  "consequence": "Both work, but direct assignment (window.onerror =) is simpler for this exercise.",
                  "correction": "You can use either approach. addEventListener allows multiple handlers."
                },
                {
                  "mistake": "Forgetting to handle the case where reason is not an Error object",
                  "consequence": "If someone does Promise.reject('string'), accessing .message will return undefined.",
                  "correction": "Use: reason?.message || String(reason) to handle both Error objects and primitives."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-10",
      "title": "Module 10: TypeScript Fundamentals",
      "description": "Learn why TypeScript exists and how it makes your code safer and more predictable through type checking",
      "difficulty": "intermediate",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "10.1",
          "title": "Why TypeScript? (The LEGO Instructions Analogy)",
          "moduleId": "module-10",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine building a complex LEGO set without instructions versus with a detailed manual.\n\nWithout instructions (plain JavaScript):\n- You might try to put the wrong pieces together\n- You won't know if you're missing pieces until the end\n- You can build it any way you want (freedom but risky)\n- Mistakes are discovered when the model doesn't work\n\nWith instructions (TypeScript):\n- The manual tells you exactly which pieces go where\n- You know immediately if you're using the wrong piece\n- You still have freedom within the design\n- Mistakes are caught BEFORE you finish building\n\nTypeScript is like having LEGO instructions for your code. It doesn't stop you from building creative things—it just helps you catch mistakes earlier!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// JavaScript: No type checking (risky)\nfunction addNumbers(a, b) {\n  return a + b;\n}\n\nconsole.log(addNumbers(5, 3));        // 8 ✓\nconsole.log(addNumbers('5', '3'));    // '53' (string concatenation - oops!)\nconsole.log(addNumbers(5, 'hello')); // '5hello' (probably not what you wanted)\n\n// TypeScript: Type checking (safer)\nfunction addNumbersTyped(a: number, b: number): number {\n  return a + b;\n}\n\nconsole.log(addNumbersTyped(5, 3));        // 8 ✓\n// console.log(addNumbersTyped('5', '3'));    // ERROR: Type 'string' is not assignable to type 'number'\n// console.log(addNumbersTyped(5, 'hello')); // ERROR: Argument of type 'string' is not assignable to parameter of type 'number'\n\n// TypeScript catches mistakes BEFORE you run the code!"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down the TypeScript syntax:\n\n1. **Parameter Types**: `a: number`\n   - The colon `:` means \"this variable should be\"\n   - `number` is the type we're expecting\n   - Think of it as a label on a LEGO piece\n\n2. **Return Type**: `: number` after the parentheses\n   - Tells TypeScript what type of value the function returns\n   - Optional but recommended for clarity\n\n3. **Type Checking**: TypeScript analyzes your code\n   - Happens BEFORE you run the code (compile-time)\n   - Catches type mismatches and shows red squiggly lines in your editor\n   - Your code won't compile if types don't match\n\n4. **Benefits**:\n   - Catch bugs early (before runtime)\n   - Better autocomplete in your editor\n   - Self-documenting code (types show intent)\n   - Safer refactoring (TypeScript tells you what breaks)"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes when starting with TypeScript:\n\n1. **Forgetting the colon**: `width number` won't work - you need `width: number`\n2. **Using the wrong type**: `width: string` when you mean numbers\n3. **Thinking TypeScript runs in the browser**: TypeScript must be compiled to JavaScript first\n4. **Over-typing everything**: Start simple, add types gradually\n5. **Confusing TypeScript with JavaScript**: TypeScript is a superset - all valid JavaScript is valid TypeScript, but not all TypeScript features work in plain JavaScript\n\nRemember: TypeScript is JavaScript with type safety training wheels. The training wheels help you learn to avoid crashes!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.1-challenge",
              "title": "Practice Challenge",
              "description": "Create a TypeScript function called `calculateArea` that:\n1. Takes two parameters: `width` and `height` (both should be numbers)\n2. Returns the area (width * height)\n3. Add type annotations to ensure only numbers can be passed\n\nTest your function with: calculateArea(10, 5)",
              "instructions": "Create a TypeScript function called `calculateArea` that:\n1. Takes two parameters: `width` and `height` (both should be numbers)\n2. Returns the area (width * height)\n3. Add type annotations to ensure only numbers can be passed\n\nTest your function with: calculateArea(10, 5)",
              "starterCode": "// Write your calculateArea function here\nfunction calculateArea(width, height) {\n  return width * height;\n}\n\nconsole.log(calculateArea(10, 5));",
              "solution": "function calculateArea(width: number, height: number): number {\n  return width * height;\n}\n\nconsole.log(calculateArea(10, 5));  // 50\nconsole.log(calculateArea(7.5, 4)); // 30",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should calculate area correctly",
                  "expectedOutput": "50",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should work with decimal numbers",
                  "expectedOutput": "30",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Add `: number` after each parameter name, and `: number` after the closing parenthesis to specify the return type."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes when starting with TypeScript:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes when starting with TypeScript:"
                },
                {
                  "mistake": "**Forgetting the colon**: `width number` won't work - you need `width: number`",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting the colon**: `width number` won't work - you need `width: number`"
                },
                {
                  "mistake": "**Using the wrong type**: `width: string` when you mean numbers",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Using the wrong type**: `width: string` when you mean numbers"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "10.2",
          "title": "Your First Types (The Label Maker Analogy)",
          "moduleId": "module-10",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine organizing a kitchen with a label maker:\n\nWithout labels (JavaScript):\n- You can put anything in any container\n- Sugar in the salt jar? Sure!\n- Flour in the coffee can? Why not!\n- You discover mistakes when you taste your food\n\nWith labels (TypeScript):\n- Each container has a clear label\n- You know immediately if you're putting the wrong thing in\n- The label maker prevents you from mislabeling\n- Mistakes are caught BEFORE cooking\n\nTypeScript's basic types are like labels for your variables. They tell you (and the computer) what kind of data should go in each container."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// TypeScript 5.7 Basic Types (2024-2025)\n\n// 1. STRING - Text data\nlet playerName: string = 'Alice';\nlet greeting: string = \"Hello, world!\";\nlet message: string = `Welcome, ${playerName}!`; // Template literal\n\nconsole.log(message); // 'Welcome, Alice!'\n\n// 2. NUMBER - Numeric data (integers and decimals)\nlet score: number = 100;\nlet health: number = 95.5;\nlet temperature: number = -5;\n\nconsole.log('Score:', score); // 100\n\n// 3. BOOLEAN - True or false\nlet isGameOver: boolean = false;\nlet hasWon: boolean = true;\nlet isLoggedIn: boolean = score > 50;\n\nconsole.log('Game over?', isGameOver); // false\n\n// 4. ARRAYS - Lists of the same type\nlet scores: number[] = [100, 95, 87, 92];\nlet names: string[] = ['Alice', 'Bob', 'Charlie'];\nlet flags: boolean[] = [true, false, true];\n\nconsole.log('First score:', scores[0]);   // 100\nconsole.log('All names:', names);         // ['Alice', 'Bob', 'Charlie']\n\n// Alternative array syntax (both work the same)\nlet moreScores: Array<number> = [88, 92, 76];\n\n// 5. TYPE INFERENCE - TypeScript guesses the type\nlet autoString = 'TypeScript is smart!'; // TypeScript knows this is a string\nlet autoNumber = 42;                      // TypeScript knows this is a number\nlet autoBool = true;                      // TypeScript knows this is a boolean\n\n// autoString = 123; // ERROR: Can't assign number to string variable\n\n// 6. ANY - Escape hatch (use sparingly!)\nlet anything: any = 'I can be anything';\nanything = 42;        // OK\nanything = true;      // OK\nanything = [1, 2, 3]; // OK\n// Using 'any' turns off type checking - avoid it when possible!\n\nconsole.log('Anything:', anything);"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down TypeScript's basic types:\n\n1. **String Type**: `let name: string = 'Alice'`\n   - For text data\n   - Use single quotes, double quotes, or backticks\n   - Can't assign numbers or booleans to string variables\n\n2. **Number Type**: `let age: number = 25`\n   - For all numeric data (integers and decimals)\n   - JavaScript/TypeScript doesn't distinguish between int and float\n   - Can't assign strings or booleans to number variables\n\n3. **Boolean Type**: `let isActive: boolean = true`\n   - Only two values: `true` or `false`\n   - Used for yes/no, on/off logic\n   - Can't assign strings or numbers (even 0 and 1)\n\n4. **Array Types**: `let numbers: number[] = [1, 2, 3]`\n   - Square brackets `[]` after the type\n   - All elements must be the same type\n   - Alternative syntax: `Array<number>`\n\n5. **Type Inference**: TypeScript is smart!\n   - If you assign a value immediately, TypeScript guesses the type\n   - `let x = 5` → TypeScript knows x is a number\n   - Still type-safe, just less typing!\n\n6. **The 'any' Type**: Last resort!\n   - Turns off type checking for that variable\n   - Defeats the purpose of TypeScript\n   - Use only when absolutely necessary (like external APIs)"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common beginner mistakes:\n\n1. **Mixing up type names**: `String` vs `string`\n   - Use lowercase: `string`, `number`, `boolean`\n   - Uppercase versions (String, Number, Boolean) are JavaScript wrapper objects - avoid them!\n\n2. **Forgetting array brackets**: `let nums: number` vs `let nums: number[]`\n   - `number` is a single number\n   - `number[]` is an array of numbers\n\n3. **Type mismatch errors**: `let age: number = '25'`\n   - '25' is a string, not a number\n   - Remove quotes: `let age: number = 25`\n\n4. **Overusing 'any'**: Using `any` everywhere defeats TypeScript's purpose\n   - Only use 'any' as a last resort\n   - Better to learn the correct type\n\n5. **Type inference confusion**: \"Do I always need type annotations?\"\n   - No! If you assign immediately, TypeScript infers the type\n   - `let x = 5` is the same as `let x: number = 5`\n   - Explicit types are good for function parameters and return values"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.2-challenge",
              "title": "Practice Challenge",
              "description": "Create variables with proper TypeScript types:\n1. A string variable `username` with your name\n2. A number variable `age` with your age\n3. A boolean variable `isStudent` set to true\n4. An array of numbers called `grades` with at least 3 grade values\n5. Calculate and log the average grade\n\nLog all variables to see their values.",
              "instructions": "Create variables with proper TypeScript types:\n1. A string variable `username` with your name\n2. A number variable `age` with your age\n3. A boolean variable `isStudent` set to true\n4. An array of numbers called `grades` with at least 3 grade values\n5. Calculate and log the average grade\n\nLog all variables to see their values.",
              "starterCode": "// Add type annotations to these variables\nlet username = 'YourName';\nlet age = 0;\nlet isStudent = true;\nlet grades = [85, 92, 78];\n\n// Calculate average\nlet sum = 0;\nfor (let grade of grades) {\n  sum = sum + grade;\n}\nlet average = sum / grades.length;\n\nconsole.log('Username:', username);\nconsole.log('Age:', age);\nconsole.log('Student?', isStudent);\nconsole.log('Grades:', grades);\nconsole.log('Average:', average);",
              "solution": "// Properly typed variables\nlet username: string = 'Alice';\nlet age: number = 20;\nlet isStudent: boolean = true;\nlet grades: number[] = [85, 92, 78];\n\n// Calculate average\nlet sum: number = 0;\nfor (let grade of grades) {\n  sum = sum + grade;\n}\nlet average: number = sum / grades.length;\n\nconsole.log('Username:', username);  // Alice\nconsole.log('Age:', age);            // 20\nconsole.log('Student?', isStudent);  // true\nconsole.log('Grades:', grades);      // [85, 92, 78]\nconsole.log('Average:', average);    // 85",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should create typed variables",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should calculate average correctly",
                  "expectedOutput": "85",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Add `: string`, `: number`, `: boolean`, and `: number[]` after each variable name."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common beginner mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common beginner mistakes:"
                },
                {
                  "mistake": "**Mixing up type names**: `String` vs `string`",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Mixing up type names**: `String` vs `string`\n   - Use lowercase: `string`, `number`, `boolean`\n   - Uppercase versions (String, Number, Boolean) are JavaScript wrapper objects - avoid them!"
                },
                {
                  "mistake": "**Forgetting array brackets**: `let nums: number` vs `let nums: number[]`",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting array brackets**: `let nums: number` vs `let nums: number[]`\n   - `number` is a single number\n   - `number[]` is an array of numbers"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "10.3",
          "title": "Creating Custom Blueprints (Interfaces and Types)",
          "moduleId": "module-10",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're running a car dealership:\n\nWithout blueprints (plain JavaScript):\n- Every car is just an object with random properties\n- One car has 'color', another has 'colour'\n- No one knows what properties a car should have\n- Lots of inconsistency and confusion\n\nWith blueprints (TypeScript Interfaces):\n- You create a 'Car Blueprint' that says every car must have:\n  * make (string)\n  * model (string)\n  * year (number)\n  * color (string)\n- Now every car follows the same structure\n- If someone forgets a property, the blueprint catches it\n- Everyone knows exactly what a car object should look like\n\nInterfaces are blueprints for objects. They define the exact shape your data should have."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// TypeScript 5.7 Interfaces and Type Aliases (2024-2025)\n\n// INTERFACE - Blueprint for an object\ninterface User {\n  id: number;\n  username: string;\n  email: string;\n  isActive: boolean;\n}\n\n// Using the interface\nlet alice: User = {\n  id: 1,\n  username: 'alice',\n  email: 'alice@example.com',\n  isActive: true\n};\n\nconsole.log('User:', alice.username); // 'alice'\n\n// This will cause an error (missing properties):\n// let bob: User = {\n//   id: 2,\n//   username: 'bob'\n//   // ERROR: Missing email and isActive!\n// };\n\n// OPTIONAL PROPERTIES - Sometimes a property might not exist\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  description?: string;  // ? means optional\n  inStock?: boolean;\n}\n\nlet laptop: Product = {\n  id: 101,\n  name: 'Gaming Laptop',\n  price: 1299.99\n  // description and inStock are optional - no error!\n};\n\nlet phone: Product = {\n  id: 102,\n  name: 'Smartphone',\n  price: 799.99,\n  description: 'Latest model with amazing camera',\n  inStock: true\n};\n\nconsole.log('Laptop:', laptop.name);      // 'Gaming Laptop'\nconsole.log('Phone stock:', phone.inStock); // true\n\n// TYPE ALIASES - Alternative way to create custom types\ntype Point = {\n  x: number;\n  y: number;\n};\n\nlet origin: Point = { x: 0, y: 0 };\nlet cursor: Point = { x: 150, y: 200 };\n\nconsole.log('Cursor position:', cursor.x, cursor.y); // 150 200\n\n// UNION TYPES - A value can be one of several types\ntype Status = 'pending' | 'approved' | 'rejected';\n\nlet orderStatus: Status = 'pending';\nconsole.log('Order status:', orderStatus); // 'pending'\n\norderStatus = 'approved';  // OK\n// orderStatus = 'cancelled'; // ERROR: Not one of the allowed values!\n\n// INTERFACES WITH METHODS - Objects can have functions\ninterface Calculator {\n  add(a: number, b: number): number;\n  subtract(a: number, b: number): number;\n}\n\nlet calc: Calculator = {\n  add(a, b) {\n    return a + b;\n  },\n  subtract(a, b) {\n    return a - b;\n  }\n};\n\nconsole.log('5 + 3 =', calc.add(5, 3));      // 8\nconsole.log('10 - 4 =', calc.subtract(10, 4)); // 6"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down custom types in TypeScript:\n\n1. **Interface Definition**: `interface User { ... }`\n   - Starts with the `interface` keyword\n   - Name should be PascalCase (capitalized)\n   - Properties inside curly braces\n   - Each property has a type\n\n2. **Using an Interface**: `let user: User = { ... }`\n   - Use the interface name as a type annotation\n   - Object must have ALL required properties\n   - Properties must match the specified types\n\n3. **Optional Properties**: `description?: string`\n   - Question mark `?` after property name\n   - Means this property might not exist\n   - Still type-safe when it does exist\n\n4. **Type Aliases**: `type Point = { x: number; y: number }`\n   - Alternative to interfaces\n   - Use the `type` keyword\n   - Can create complex types\n\n5. **Union Types**: `type Status = 'pending' | 'approved' | 'rejected'`\n   - Pipe `|` means \"OR\"\n   - Value must be one of the listed options\n   - Great for status codes, modes, etc.\n\n6. **Method Signatures**: `add(a: number, b: number): number`\n   - Functions inside interfaces\n   - Parameters have types\n   - Return type after the closing parenthesis\n\nWhen to use Interface vs Type:\n- Use `interface` for object shapes (most common)\n- Use `type` for unions, primitives, or complex combinations\n- Both work for objects, choose based on preference"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes with interfaces:\n\n1. **Forgetting required properties**:\n   ```typescript\n   let user: User = { id: 1 }; // ERROR: Missing username, email, isActive\n   ```\n   Solution: Include ALL required properties\n\n2. **Wrong property names**:\n   ```typescript\n   let user: User = { \n     id: 1, \n     userName: 'alice' // ERROR: Should be 'username' not 'userName'\n   };\n   ```\n   Solution: Match property names exactly (case-sensitive!)\n\n3. **Extra properties**:\n   ```typescript\n   let user: User = {\n     id: 1,\n     username: 'alice',\n     email: 'alice@example.com',\n     isActive: true,\n     age: 25 // ERROR: 'age' doesn't exist in User interface\n   };\n   ```\n   Solution: Only include properties defined in the interface\n\n4. **Confusing `?` placement**: `string?` is wrong, `property?: string` is correct\n\n5. **Interface vs Type confusion**:\n   - Both can define object shapes\n   - Interfaces can be extended and merged\n   - Types can do unions and complex types\n   - For simple object shapes, use either one - they're interchangeable!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.3-challenge",
              "title": "Practice Challenge",
              "description": "Create a TypeScript interface called `Book` with the following properties:\n1. `title` (string, required)\n2. `author` (string, required)\n3. `pages` (number, required)\n4. `isbn` (string, optional)\n5. `isRead` (boolean, required)\n\nThen create two book objects using this interface:\n- A book you've read (with all properties including isbn)\n- A book you haven't read yet (without isbn)\n\nLog both books to verify they work.",
              "instructions": "Create a TypeScript interface called `Book` with the following properties:\n1. `title` (string, required)\n2. `author` (string, required)\n3. `pages` (number, required)\n4. `isbn` (string, optional)\n5. `isRead` (boolean, required)\n\nThen create two book objects using this interface:\n- A book you've read (with all properties including isbn)\n- A book you haven't read yet (without isbn)\n\nLog both books to verify they work.",
              "starterCode": "// Define your Book interface here\ninterface Book {\n  // Add properties here\n}\n\n// Create two book objects\nlet book1: Book = {\n  title: 'The Great Gatsby',\n  author: 'F. Scott Fitzgerald',\n  pages: 180,\n  isbn: '978-0743273565',\n  isRead: true\n};\n\nlet book2: Book = {\n  title: '1984',\n  author: 'George Orwell',\n  pages: 328,\n  isRead: false\n};\n\nconsole.log('Book 1:', book1.title);\nconsole.log('Book 2:', book2.title);",
              "solution": "// Book interface with optional isbn\ninterface Book {\n  title: string;\n  author: string;\n  pages: number;\n  isbn?: string;  // Optional property\n  isRead: boolean;\n}\n\n// Book with all properties\nlet book1: Book = {\n  title: 'The Great Gatsby',\n  author: 'F. Scott Fitzgerald',\n  pages: 180,\n  isbn: '978-0743273565',\n  isRead: true\n};\n\n// Book without optional isbn\nlet book2: Book = {\n  title: '1984',\n  author: 'George Orwell',\n  pages: 328,\n  isRead: false\n};\n\nconsole.log('Book 1:', book1.title);  // 'The Great Gatsby'\nconsole.log('Book 2:', book2.title);  // '1984'\nconsole.log('Book 1 ISBN:', book1.isbn); // '978-0743273565'\nconsole.log('Book 2 ISBN:', book2.isbn); // undefined",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should create book objects with interface",
                  "expectedOutput": "Test",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should handle optional isbn",
                  "expectedOutput": "200",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use `?` to make isbn optional. The syntax is: `propertyName?: type`"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common mistakes with interfaces:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common mistakes with interfaces:"
                },
                {
                  "mistake": "**Forgetting required properties**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting required properties**:\n   ```typescript\n   let user: User = { id: 1 }; // ERROR: Missing username, email, isActive\n   ```\n   Solution: Include ALL required properties"
                },
                {
                  "mistake": "**Wrong property names**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong property names**:\n   ```typescript\n   let user: User = { \n     id: 1, \n     userName: 'alice' // ERROR: Should be 'username' not 'userName'\n   };\n   ```\n   Solution: Match property names exactly (case-sensitive!)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "10.4",
          "title": "TypeScript Project Setup (The Toolbox Assembly)",
          "moduleId": "module-10",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're setting up a woodworking shop:\n\nWoodworking setup:\n- You need tools (saw, hammer, drill)\n- You need a workspace (workshop with proper layout)\n- You need safety equipment (goggles, gloves)\n- You need instructions on how to use everything\n\nTypeScript project setup:\n- You need TypeScript installed (the compiler)\n- You need a configuration file (tsconfig.json)\n- You need a folder structure (organized workspace)\n- You need to know how to compile TS → JS\n\nJust like you can't start woodworking without setting up your shop, you can't start a TypeScript project without proper configuration!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// TypeScript 5.7 Project Setup (2024-2025)\n\n// STEP 1: Initialize a Node.js project (run in terminal)\n// npm init -y\n\n// STEP 2: Install TypeScript (run in terminal)\n// npm install -D typescript\n\n// STEP 3: Create tsconfig.json configuration file\n// Content of tsconfig.json:\n/*\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2024\",           // Use ES2024 features\n    \"module\": \"ESNext\",           // Modern module system\n    \"outDir\": \"./dist\",           // Compiled JS goes here\n    \"rootDir\": \"./src\",           // TypeScript source files here\n    \"strict\": true,               // Enable all strict type checks\n    \"esModuleInterop\": true,      // Better import compatibility\n    \"skipLibCheck\": true,         // Skip type checking of declaration files\n    \"forceConsistentCasingInFileNames\": true  // Case-sensitive imports\n  },\n  \"include\": [\"src/**/*\"],       // Include all files in src folder\n  \"exclude\": [\"node_modules\"]    // Exclude dependencies\n}\n*/\n\n// STEP 4: Create folder structure\n// project/\n//   ├── src/           (TypeScript source files)\n//   │   └── index.ts\n//   ├── dist/          (Compiled JavaScript - auto-generated)\n//   ├── node_modules/  (Dependencies)\n//   ├── package.json\n//   └── tsconfig.json\n\n// STEP 5: Write TypeScript code in src/index.ts\ninterface Greeting {\n  message: string;\n  name: string;\n}\n\nfunction greet(greeting: Greeting): string {\n  return `${greeting.message}, ${greeting.name}!`;\n}\n\nconst welcome: Greeting = {\n  message: 'Hello',\n  name: 'TypeScript Developer'\n};\n\nconsole.log(greet(welcome));\n\n// STEP 6: Compile TypeScript to JavaScript (run in terminal)\n// npx tsc\n// This creates dist/index.js\n\n// STEP 7: Run the compiled JavaScript (run in terminal)\n// node dist/index.js\n\n// STEP 8: (Optional) Watch mode - auto-compile on file changes\n// npx tsc --watch\n\n// MODERN WORKFLOW: Use ts-node for development\n// npm install -D ts-node\n// npx ts-node src/index.ts  (runs TypeScript directly!)\n\nconsole.log('TypeScript project setup complete!');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down TypeScript project configuration:\n\n1. **tsconfig.json**: The command center\n   - Tells TypeScript how to compile your code\n   - Lives in the project root directory\n   - JSON format (strict syntax)\n\n2. **Key Configuration Options**:\n   - `target`: Which JavaScript version to output (ES2024 is latest)\n   - `module`: How to handle imports/exports (ESNext for modern)\n   - `outDir`: Where compiled JavaScript goes (usually 'dist' or 'build')\n   - `rootDir`: Where TypeScript source files are (usually 'src')\n   - `strict`: Turn on all strict type checking (HIGHLY recommended)\n\n3. **Compilation Process**:\n   - Write `.ts` files (TypeScript)\n   - Run `npx tsc` command\n   - TypeScript compiler reads tsconfig.json\n   - Generates `.js` files in outDir\n   - Run the `.js` files with Node.js\n\n4. **Development Tools**:\n   - `tsc`: TypeScript compiler\n   - `ts-node`: Run TypeScript directly without manual compilation\n   - `--watch`: Auto-recompile when files change\n   - `npm install -D`: Install as development dependency\n\n5. **Folder Structure Best Practices**:\n   - `/src`: All TypeScript source code\n   - `/dist`: Compiled JavaScript (gitignored)\n   - `/node_modules`: Dependencies (gitignored)\n   - Root: Config files (tsconfig.json, package.json)\n\n6. **Why We Need Compilation**:\n   - Browsers and Node.js don't understand TypeScript\n   - TypeScript must be converted (transpiled) to JavaScript\n   - The type checking happens during compilation\n   - Runtime uses the generated JavaScript"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common setup mistakes:\n\n1. **Wrong tsconfig.json location**:\n   - Must be in project root (not inside src/)\n   - Must be named exactly 'tsconfig.json' (case-sensitive)\n\n2. **JSON syntax errors**:\n   ```json\n   {\n     \"target\": \"ES2024\",  // ERROR: No trailing comma on last item!\n   }\n   ```\n   Solution: Remove trailing commas in JSON files\n\n3. **Running .ts files directly**: `node src/index.ts`\n   - Node.js can't run TypeScript!\n   - Either compile first: `npx tsc` then `node dist/index.js`\n   - Or use ts-node: `npx ts-node src/index.ts`\n\n4. **Forgetting to install TypeScript**:\n   - Must run `npm install -D typescript` first\n   - Check with `npx tsc --version`\n\n5. **Wrong folder structure**:\n   - TypeScript files should be in src/\n   - If you put them elsewhere, update `rootDir` in tsconfig.json\n\n6. **Confusion about compilation**:\n   - TypeScript → JavaScript (compilation/transpilation)\n   - Types are removed during compilation\n   - The .js output has no type information\n   - Type checking happens at compile-time only\n\n7. **Not using strict mode**:\n   - `\"strict\": false` allows many unsafe patterns\n   - Always use `\"strict\": true` for maximum safety\n   - You're learning TypeScript to catch bugs - use all its power!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.4-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a TypeScript project setup by creating the necessary configuration:\n\n1. Create a simple TypeScript configuration object with these properties:\n   - `target`: 'ES2024'\n   - `strict`: true\n   - `outDir`: './dist'\n\n2. Create an interface `ProjectConfig` that matches this structure\n\n3. Create a function `validateConfig` that takes a ProjectConfig and returns true if strict is enabled\n\n4. Test your function with a config object\n\nLog the validation result.",
              "instructions": "Simulate a TypeScript project setup by creating the necessary configuration:\n\n1. Create a simple TypeScript configuration object with these properties:\n   - `target`: 'ES2024'\n   - `strict`: true\n   - `outDir`: './dist'\n\n2. Create an interface `ProjectConfig` that matches this structure\n\n3. Create a function `validateConfig` that takes a ProjectConfig and returns true if strict is enabled\n\n4. Test your function with a config object\n\nLog the validation result.",
              "starterCode": "// Define ProjectConfig interface\ninterface ProjectConfig {\n  // Add properties here\n}\n\n// Create validation function\nfunction validateConfig(config) {\n  return config.strict === true;\n}\n\n// Create a config object\nlet myConfig = {\n  target: 'ES2024',\n  strict: true,\n  outDir: './dist'\n};\n\nconsole.log('Strict mode enabled?', validateConfig(myConfig));",
              "solution": "// ProjectConfig interface\ninterface ProjectConfig {\n  target: string;\n  strict: boolean;\n  outDir: string;\n}\n\n// Typed validation function\nfunction validateConfig(config: ProjectConfig): boolean {\n  return config.strict === true;\n}\n\n// Create typed config object\nlet myConfig: ProjectConfig = {\n  target: 'ES2024',\n  strict: true,\n  outDir: './dist'\n};\n\nconsole.log('Strict mode enabled?', validateConfig(myConfig)); // true\n\n// Test with strict mode disabled\nlet loosConfig: ProjectConfig = {\n  target: 'ES2024',\n  strict: false,\n  outDir: './dist'\n};\n\nconsole.log('Loose mode:', validateConfig(loosConfig)); // false",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should validate strict mode is enabled",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should detect when strict mode is disabled",
                  "expectedOutput": "false",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Add type annotations to the interface properties and function parameter."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common setup mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common setup mistakes:"
                },
                {
                  "mistake": "**Wrong tsconfig.json location**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong tsconfig.json location**:\n   - Must be in project root (not inside src/)\n   - Must be named exactly 'tsconfig.json' (case-sensitive)"
                },
                {
                  "mistake": "**JSON syntax errors**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**JSON syntax errors**:\n   ```json\n   {\n     \"target\": \"ES2024\",  // ERROR: No trailing comma on last item!\n   }\n   ```\n   Solution: Remove trailing commas in JSON files"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "10.5",
          "title": "Converting JavaScript to TypeScript (The Upgrade Path)",
          "moduleId": "module-10",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you have a bicycle and you want to upgrade it to an electric bike:\n\nBicycle (JavaScript):\n- Works perfectly fine as-is\n- You can ride it anywhere\n- No extra features\n\nE-bike (TypeScript):\n- Same bicycle underneath\n- Added motor, battery, controls\n- More features and safety\n- Still works as a regular bike if battery dies\n\nConverting JavaScript to TypeScript is the same:\n- Start with working JavaScript code\n- Add type annotations (the electric components)\n- Get extra safety and features\n- The underlying logic stays the same!\n\nYou don't have to convert everything at once - you can gradually upgrade piece by piece."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// BEFORE: Plain JavaScript (works but no type safety)\nfunction calculateDiscount(price, discountPercent) {\n  if (discountPercent < 0 || discountPercent > 100) {\n    return 'Invalid discount';\n  }\n  let discount = price * (discountPercent / 100);\n  return price - discount;\n}\n\nlet product = {\n  name: 'Laptop',\n  price: 1000,\n  category: 'Electronics'\n};\n\nlet discountedPrice = calculateDiscount(product.price, 20);\nconsole.log('Original JavaScript:', discountedPrice); // 800\n\n// Problems with the JavaScript version:\n// calculateDiscount('abc', 'xyz')  // No error until runtime!\n// calculateDiscount(1000, 150)     // Accepts invalid discount percent\n\n// AFTER: TypeScript (type-safe)\ninterface Product {\n  name: string;\n  price: number;\n  category: string;\n}\n\nfunction calculateDiscountTyped(\n  price: number, \n  discountPercent: number\n): number | string {\n  if (discountPercent < 0 || discountPercent > 100) {\n    return 'Invalid discount';\n  }\n  let discount: number = price * (discountPercent / 100);\n  return price - discount;\n}\n\nlet typedProduct: Product = {\n  name: 'Laptop',\n  price: 1000,\n  category: 'Electronics'\n};\n\nlet typedDiscountedPrice = calculateDiscountTyped(typedProduct.price, 20);\nconsole.log('TypeScript version:', typedDiscountedPrice); // 800\n\n// These will now cause COMPILE-TIME errors:\n// calculateDiscountTyped('abc', 'xyz')  // ERROR: string is not assignable to number\n// calculateDiscountTyped(1000, 150)     // Still runs, but you can add validation\n\n// MIGRATION STRATEGY: Step-by-step conversion\n\n// Step 1: Rename .js files to .ts (start simple)\n// app.js → app.ts\n\n// Step 2: Add return types to functions\nfunction greet(name: string): string {\n  return `Hello, ${name}!`;\n}\n\n// Step 3: Add parameter types\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// Step 4: Create interfaces for complex objects\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// Step 5: Update variable declarations\nlet users: User[] = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' }\n];\n\n// Step 6: Enable strict mode in tsconfig.json (gradually)\n// Start with \"strict\": false, then enable incrementally\n\nconsole.log('Migration complete!');\nconsole.log('User count:', users.length); // 2"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Converting JavaScript to TypeScript step-by-step:\n\n1. **File Renaming** (easiest step):\n   - `.js` → `.ts` (JavaScript → TypeScript)\n   - `.jsx` → `.tsx` (React files)\n   - All valid JavaScript is valid TypeScript!\n\n2. **Add Function Return Types**:\n   ```typescript\n   // Before\n   function getName() {\n     return 'Alice';\n   }\n   \n   // After\n   function getName(): string {\n     return 'Alice';\n   }\n   ```\n\n3. **Add Parameter Types**:\n   ```typescript\n   // Before\n   function greet(name) {\n     return `Hello, ${name}`;\n   }\n   \n   // After  \n   function greet(name: string): string {\n     return `Hello, ${name}`;\n   }\n   ```\n\n4. **Create Interfaces for Objects**:\n   ```typescript\n   // Before\n   let user = {\n     id: 1,\n     name: 'Alice'\n   };\n   \n   // After\n   interface User {\n     id: number;\n     name: string;\n   }\n   \n   let user: User = {\n     id: 1,\n     name: 'Alice'\n   };\n   ```\n\n5. **Type Arrays**:\n   ```typescript\n   // Before\n   let numbers = [1, 2, 3];\n   \n   // After\n   let numbers: number[] = [1, 2, 3];\n   ```\n\n6. **Union Types for Multiple Return Types**:\n   ```typescript\n   function getValue(): number | string {\n     // Can return either number or string\n   }\n   ```\n\n7. **Migration Strategy**:\n   - Start with strict: false in tsconfig.json\n   - Convert one file at a time\n   - Focus on functions and interfaces first\n   - Gradually enable strict checks\n   - Don't try to convert everything at once!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common migration mistakes:\n\n1. **Trying to convert everything at once**:\n   - This is overwhelming and error-prone\n   - Convert one file or module at a time\n   - Start with core utilities, then work outward\n\n2. **Using 'any' everywhere**:\n   ```typescript\n   function process(data: any): any {  // Bad!\n     // ...\n   }\n   ```\n   - This defeats the purpose of TypeScript\n   - Take time to figure out the correct types\n   - Use 'any' only as a temporary placeholder\n\n3. **Ignoring type errors**:\n   - TypeScript errors are there to help!\n   - Don't use `@ts-ignore` to suppress them\n   - Fix the underlying issue instead\n\n4. **Not updating tests**:\n   - If you have .test.js files, convert them to .test.ts\n   - Add types to test data and assertions\n\n5. **Forgetting about third-party types**:\n   - Many libraries need type definitions\n   - Install them: `npm install -D @types/lodash`\n   - Check DefinitelyTyped for available types\n\n6. **Over-typing simple code**:\n   ```typescript\n   // Over-typed (unnecessary)\n   let name: string = 'Alice';\n   \n   // Better (type inference)\n   let name = 'Alice';  // TypeScript knows it's a string\n   ```\n   - Let TypeScript infer obvious types\n   - Add explicit types for function parameters and returns\n\n7. **Not communicating with team**:\n   - Migration affects everyone\n   - Set coding standards together\n   - Pair program on tricky conversions\n   - Document your migration strategy\n\nRemember: Migration is a gradual process. It's okay to have both .js and .ts files in your project during the transition!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.5-challenge",
              "title": "Practice Challenge",
              "description": "Convert this JavaScript code to TypeScript:\n\nYou have a function `getFullName` that takes a user object with firstName and lastName properties and returns the full name.\n\nTasks:\n1. Create a `User` interface with firstName and lastName (both strings)\n2. Add type annotations to the function parameter and return type\n3. Create a typed user object\n4. Test the function\n\nOriginal JavaScript:\n```javascript\nfunction getFullName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nlet user = {\n  firstName: 'Jane',\n  lastName: 'Doe'\n};\n```",
              "instructions": "Convert this JavaScript code to TypeScript:\n\nYou have a function `getFullName` that takes a user object with firstName and lastName properties and returns the full name.\n\nTasks:\n1. Create a `User` interface with firstName and lastName (both strings)\n2. Add type annotations to the function parameter and return type\n3. Create a typed user object\n4. Test the function\n\nOriginal JavaScript:\n```javascript\nfunction getFullName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nlet user = {\n  firstName: 'Jane',\n  lastName: 'Doe'\n};\n```",
              "starterCode": "// Step 1: Create User interface\ninterface User {\n  // Add properties\n}\n\n// Step 2: Add types to function\nfunction getFullName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\n// Step 3: Create typed user\nlet user = {\n  firstName: 'Jane',\n  lastName: 'Doe'\n};\n\nconsole.log(getFullName(user));",
              "solution": "// Step 1: Create User interface\ninterface User {\n  firstName: string;\n  lastName: string;\n}\n\n// Step 2: Add types to function\nfunction getFullName(user: User): string {\n  return user.firstName + ' ' + user.lastName;\n}\n\n// Step 3: Create typed user\nlet user: User = {\n  firstName: 'Jane',\n  lastName: 'Doe'\n};\n\nconsole.log(getFullName(user)); // 'Jane Doe'\n\n// Bonus: Array of users\nlet users: User[] = [\n  { firstName: 'Jane', lastName: 'Doe' },\n  { firstName: 'John', lastName: 'Smith' }\n];\n\nfor (let u of users) {\n  console.log(getFullName(u));\n}\n// Output:\n// 'Jane Doe'\n// 'John Smith'",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should return full name",
                  "expectedOutput": "Jane Doe",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should work with different names",
                  "expectedOutput": "John Smith",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Add `: string` to both interface properties, `: User` to the function parameter, and `: string` for the return type."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common migration mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common migration mistakes:"
                },
                {
                  "mistake": "**Trying to convert everything at once**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Trying to convert everything at once**:\n   - This is overwhelming and error-prone\n   - Convert one file or module at a time\n   - Start with core utilities, then work outward"
                },
                {
                  "mistake": "**Using 'any' everywhere**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Using 'any' everywhere**:\n   ```typescript\n   function process(data: any): any {  // Bad!\n     // ...\n   }\n   ```\n   - This defeats the purpose of TypeScript\n   - Take time to figure out the correct types\n   - Use 'any' only as a temporary placeholder"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "10.6",
          "title": "Generics (The Swiss Army Knife Analogy)",
          "moduleId": "module-10",
          "order": 6,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a Swiss Army knife:\n\nWithout versatility (specific tools):\n- You need a separate knife for cutting bread\n- A different knife for cutting rope\n- Another knife for cutting paper\n- Each tool only works with one material\n\nWith versatility (Swiss Army knife):\n- One tool that adapts to many uses\n- Same cutting motion, different materials\n- The knife works with whatever you give it\n- Still sharp and effective for each use\n\nGenerics in TypeScript work the same way. Instead of writing separate functions for numbers, strings, and objects, you write ONE function that works with ANY type you give it. The function adapts to the type, just like a Swiss Army knife adapts to the material."
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// TypeScript Generics - Flexible, Reusable Types\n\n// PROBLEM: Writing the same function for different types\nfunction getFirstNumber(arr: number[]): number | undefined {\n  return arr[0];\n}\n\nfunction getFirstString(arr: string[]): string | undefined {\n  return arr[0];\n}\n\n// We need a new function for every type! That's a lot of repetition.\n\n// SOLUTION: Generics - One function that works with ANY type\nfunction getFirst<T>(arr: T[]): T | undefined {\n  return arr[0];\n}\n\n// Now it works with any type!\nconsole.log(getFirst<number>([1, 2, 3]));           // 1\nconsole.log(getFirst<string>(['a', 'b', 'c']));    // 'a'\nconsole.log(getFirst<boolean>([true, false]));     // true\n\n// TypeScript can also INFER the type automatically!\nconsole.log(getFirst([10, 20, 30]));               // 10 (infers number)\nconsole.log(getFirst(['hello', 'world']));         // 'hello' (infers string)\n\n// GENERIC INTERFACES - Create flexible data structures\ninterface Box<T> {\n  contents: T;\n  label: string;\n}\n\nlet numberBox: Box<number> = { contents: 42, label: 'Answer' };\nlet stringBox: Box<string> = { contents: 'Hello', label: 'Greeting' };\n\nconsole.log('Number box:', numberBox.contents);    // 42\nconsole.log('String box:', stringBox.contents);    // 'Hello'\n\n// MULTIPLE TYPE PARAMETERS - Use more than one generic type\nfunction makePair<K, V>(key: K, value: V): { key: K; value: V } {\n  return { key, value };\n}\n\nlet pair1 = makePair<string, number>('age', 25);\nlet pair2 = makePair<number, boolean>(1, true);\nlet pair3 = makePair('name', 'Alice');  // Types inferred automatically\n\nconsole.log('Pair 1:', pair1);  // { key: 'age', value: 25 }\nconsole.log('Pair 2:', pair2);  // { key: 1, value: true }\nconsole.log('Pair 3:', pair3);  // { key: 'name', value: 'Alice' }\n\n// GENERIC CONSTRAINTS - Limit what types are allowed\ninterface Lengthable {\n  length: number;\n}\n\nfunction logLength<T extends Lengthable>(item: T): void {\n  console.log('Length:', item.length);\n}\n\nlogLength('Hello');           // 5 (strings have length)\nlogLength([1, 2, 3, 4]);      // 4 (arrays have length)\nlogLength({ length: 10 });    // 10 (object with length property)\n// logLength(42);             // ERROR: number doesn't have length!\n\n// GENERIC CLASSES - Reusable data structures\nclass Stack<T> {\n  private items: T[] = [];\n  \n  push(item: T): void {\n    this.items.push(item);\n  }\n  \n  pop(): T | undefined {\n    return this.items.pop();\n  }\n  \n  peek(): T | undefined {\n    return this.items[this.items.length - 1];\n  }\n}\n\nlet numberStack = new Stack<number>();\nnumberStack.push(1);\nnumberStack.push(2);\nnumberStack.push(3);\nconsole.log('Top of stack:', numberStack.peek());  // 3\nconsole.log('Popped:', numberStack.pop());         // 3\n\nlet stringStack = new Stack<string>();\nstringStack.push('first');\nstringStack.push('second');\nconsole.log('String stack top:', stringStack.peek());  // 'second'\n\n// REAL-WORLD EXAMPLE: API Response wrapper\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message: string;\n}\n\ninterface User {\n  id: number;\n  name: string;\n}\n\ninterface Product {\n  sku: string;\n  price: number;\n}\n\nlet userResponse: ApiResponse<User> = {\n  data: { id: 1, name: 'Alice' },\n  status: 200,\n  message: 'Success'\n};\n\nlet productResponse: ApiResponse<Product> = {\n  data: { sku: 'ABC123', price: 29.99 },\n  status: 200,\n  message: 'Success'\n};\n\nconsole.log('User:', userResponse.data.name);       // 'Alice'\nconsole.log('Product:', productResponse.data.sku);  // 'ABC123'"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down generics in TypeScript:\n\n1. **Basic Generic Syntax**: `function name<T>(param: T): T`\n   - `<T>` declares a type parameter (T is just a convention)\n   - `T` is a placeholder for any type\n   - Common names: T (Type), K (Key), V (Value), E (Element)\n\n2. **Using Generic Functions**:\n   ```typescript\n   // Explicit type argument\n   getFirst<string>(['a', 'b']);\n   \n   // Type inference (TypeScript figures it out)\n   getFirst(['a', 'b']);  // Infers string\n   ```\n\n3. **Generic Interfaces**: `interface Box<T> { contents: T }`\n   - Create reusable shapes that work with any type\n   - Specify the type when using: `Box<number>`\n\n4. **Multiple Type Parameters**: `<K, V>`\n   - Use multiple placeholders for complex types\n   - Each can be different types\n\n5. **Generic Constraints**: `<T extends SomeType>`\n   - Limit which types can be used\n   - `extends` means \"must have these properties\"\n   - Ensures the generic type has required features\n\n6. **Generic Classes**: `class Container<T> { ... }`\n   - Create reusable data structures\n   - Type is specified when creating instances\n   - Methods work with the specified type\n\n7. **When to Use Generics**:\n   - Functions that work with multiple types\n   - Data structures (lists, stacks, maps)\n   - API wrappers and response types\n   - Utility functions (getFirst, filter, map)\n\n8. **Benefits of Generics**:\n   - Write once, use with many types\n   - Full type safety maintained\n   - Better code reuse\n   - Self-documenting code"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes with generics:\n\n1. **Using `any` instead of generics**:\n   ```typescript\n   // Bad - loses type safety\n   function getFirst(arr: any[]): any {\n     return arr[0];\n   }\n   \n   // Good - preserves type safety\n   function getFirst<T>(arr: T[]): T | undefined {\n     return arr[0];\n   }\n   ```\n\n2. **Forgetting type constraints**:\n   ```typescript\n   // Error - T might not have 'length'\n   function logLength<T>(item: T): void {\n     console.log(item.length);  // ERROR!\n   }\n   \n   // Fixed - constrain T to have length\n   function logLength<T extends { length: number }>(item: T): void {\n     console.log(item.length);  // OK\n   }\n   ```\n\n3. **Over-complicating with generics**:\n   - Don't use generics when a simple union type works\n   - `string | number` might be clearer than `T`\n   - Use generics when you need type relationships\n\n4. **Confusing generic syntax**:\n   - `<T>` goes after function name: `function name<T>(...)`\n   - `<T>` goes after interface name: `interface Name<T> {...}`\n   - Arrow functions: `const fn = <T>(x: T): T => x;`\n\n5. **Not specifying return types**:\n   ```typescript\n   // TypeScript infers, but explicit is clearer\n   function getFirst<T>(arr: T[]): T | undefined {\n     return arr[0];\n   }\n   ```\n\n6. **Naming conventions**:\n   - T, U, V for general types\n   - K for keys, V for values\n   - E for elements in collections\n   - More descriptive names also work: `TItem`, `TResponse`"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.6-challenge",
              "title": "Practice Challenge",
              "description": "Create a generic function and interface:\n\n1. Create a generic function `wrapInArray<T>` that:\n   - Takes a single value of type T\n   - Returns an array containing just that value: [value]\n\n2. Create a generic interface `Result<T>` with:\n   - `success`: boolean\n   - `data`: T (the generic type)\n   - `error`: string | null\n\n3. Create a function `createSuccess<T>` that:\n   - Takes a data parameter of type T\n   - Returns a Result<T> with success: true, the data, and error: null\n\n4. Test with different types (string, number, object)",
              "instructions": "Create a generic function and interface:\n\n1. Create a generic function `wrapInArray<T>` that:\n   - Takes a single value of type T\n   - Returns an array containing just that value: [value]\n\n2. Create a generic interface `Result<T>` with:\n   - `success`: boolean\n   - `data`: T (the generic type)\n   - `error`: string | null\n\n3. Create a function `createSuccess<T>` that:\n   - Takes a data parameter of type T\n   - Returns a Result<T> with success: true, the data, and error: null\n\n4. Test with different types (string, number, object)",
              "starterCode": "// 1. Create the wrapInArray function\nfunction wrapInArray(value) {\n  return [value];\n}\n\n// 2. Create the Result interface\ninterface Result {\n  success: boolean;\n  data: any;\n  error: string | null;\n}\n\n// 3. Create the createSuccess function\nfunction createSuccess(data) {\n  return {\n    success: true,\n    data: data,\n    error: null\n  };\n}\n\n// 4. Test your code\nconsole.log(wrapInArray(42));\nconsole.log(wrapInArray('hello'));\nconsole.log(createSuccess({ id: 1, name: 'Alice' }));",
              "solution": "// 1. Generic wrapInArray function\nfunction wrapInArray<T>(value: T): T[] {\n  return [value];\n}\n\n// 2. Generic Result interface\ninterface Result<T> {\n  success: boolean;\n  data: T;\n  error: string | null;\n}\n\n// 3. Generic createSuccess function\nfunction createSuccess<T>(data: T): Result<T> {\n  return {\n    success: true,\n    data: data,\n    error: null\n  };\n}\n\n// 4. Test with different types\nconsole.log(wrapInArray<number>(42));        // [42]\nconsole.log(wrapInArray<string>('hello'));   // ['hello']\nconsole.log(wrapInArray([1, 2, 3]));         // [[1, 2, 3]]\n\nlet userResult = createSuccess<{ id: number; name: string }>({ id: 1, name: 'Alice' });\nconsole.log('User result:', userResult);\n// { success: true, data: { id: 1, name: 'Alice' }, error: null }\n\nlet numberResult = createSuccess<number>(42);\nconsole.log('Number result:', numberResult);\n// { success: true, data: 42, error: null }",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "wrapInArray should wrap value in array",
                  "expectedOutput": "[42]",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "createSuccess should create proper Result",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For wrapInArray, add <T> after the function name, then use T for the parameter type and T[] for the return type."
                },
                {
                  "level": 2,
                  "text": "For the Result interface, add <T> after the interface name: interface Result<T>. Then use T for the data property type."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to add <T> to the function or interface",
                  "consequence": "TypeScript won't recognize it as a generic type.",
                  "correction": "Add <T> immediately after the function/interface name: function name<T>(...) or interface Name<T> {...}"
                },
                {
                  "mistake": "Using 'any' instead of the generic type parameter",
                  "consequence": "Loses type safety - the whole point of generics.",
                  "correction": "Replace 'any' with 'T' (or your type parameter name) to maintain type relationships."
                },
                {
                  "mistake": "Forgetting the return type annotation",
                  "consequence": "While TypeScript can infer, explicit types make code clearer.",
                  "correction": "Add return type: function wrapInArray<T>(value: T): T[] { ... }"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "10.7",
          "title": "Type Guards and Discriminated Unions (The Security Checkpoint Analogy)",
          "moduleId": "module-10",
          "order": 7,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine airport security checkpoints:\n\nWithout proper checks:\n- Anyone could go anywhere\n- Passengers and crew mixed together\n- No way to know who has what access\n- Chaos and security risks\n\nWith security checkpoints (Type Guards):\n- Check ID: 'Are you a passenger or crew member?'\n- Once verified as crew, you can access crew areas\n- Once verified as passenger, you go through different process\n- Each check NARROWS DOWN who you are\n\nType guards work the same way in TypeScript. When you have a value that could be multiple types (like `string | number`), a type guard checks which type it actually is. Once checked, TypeScript KNOWS the specific type and gives you the right autocomplete and safety!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Type Guards and Type Narrowing in TypeScript\n\n// BASIC TYPE GUARDS - Using typeof\nfunction formatValue(value: string | number): string {\n  // TypeScript doesn't know if value is string or number here\n  \n  if (typeof value === 'string') {\n    // Inside this block, TypeScript KNOWS value is a string!\n    return value.toUpperCase();  // String methods available\n  } else {\n    // Here, TypeScript KNOWS value is a number!\n    return value.toFixed(2);  // Number methods available\n  }\n}\n\nconsole.log(formatValue('hello'));  // 'HELLO'\nconsole.log(formatValue(42.567));   // '42.57'\n\n// TYPE GUARDS WITH ARRAYS - Using Array.isArray\nfunction processData(data: string | string[]): void {\n  if (Array.isArray(data)) {\n    // TypeScript knows: data is string[]\n    console.log('Array with', data.length, 'items');\n    data.forEach(item => console.log('  -', item));\n  } else {\n    // TypeScript knows: data is string\n    console.log('Single string:', data);\n  }\n}\n\nprocessData('hello');                    // Single string: hello\nprocessData(['apple', 'banana', 'cherry']); // Array with 3 items\n\n// DISCRIMINATED UNIONS - The 'kind' pattern\ninterface Circle {\n  kind: 'circle';  // Literal type - always exactly 'circle'\n  radius: number;\n}\n\ninterface Rectangle {\n  kind: 'rectangle';  // Literal type - always exactly 'rectangle'\n  width: number;\n  height: number;\n}\n\ninterface Triangle {\n  kind: 'triangle';  // Literal type\n  base: number;\n  height: number;\n}\n\n// Union of all shapes - the 'kind' property discriminates between them\ntype Shape = Circle | Rectangle | Triangle;\n\nfunction calculateArea(shape: Shape): number {\n  // Switch on the discriminant property 'kind'\n  switch (shape.kind) {\n    case 'circle':\n      // TypeScript knows: shape is Circle\n      return Math.PI * shape.radius ** 2;\n      \n    case 'rectangle':\n      // TypeScript knows: shape is Rectangle\n      return shape.width * shape.height;\n      \n    case 'triangle':\n      // TypeScript knows: shape is Triangle\n      return 0.5 * shape.base * shape.height;\n  }\n}\n\nlet circle: Circle = { kind: 'circle', radius: 5 };\nlet rect: Rectangle = { kind: 'rectangle', width: 10, height: 4 };\nlet tri: Triangle = { kind: 'triangle', base: 6, height: 8 };\n\nconsole.log('Circle area:', calculateArea(circle).toFixed(2));   // 78.54\nconsole.log('Rectangle area:', calculateArea(rect));              // 40\nconsole.log('Triangle area:', calculateArea(tri));                // 24\n\n// CUSTOM TYPE GUARDS - Using 'is' keyword\ninterface Dog {\n  breed: string;\n  bark(): void;\n}\n\ninterface Cat {\n  breed: string;\n  meow(): void;\n}\n\ntype Pet = Dog | Cat;\n\n// Custom type guard function - returns 'pet is Dog'\nfunction isDog(pet: Pet): pet is Dog {\n  return 'bark' in pet;  // Dogs have a bark method\n}\n\nfunction isCat(pet: Pet): pet is Cat {\n  return 'meow' in pet;  // Cats have a meow method\n}\n\nfunction makeNoise(pet: Pet): void {\n  if (isDog(pet)) {\n    // TypeScript knows: pet is Dog\n    pet.bark();\n  } else {\n    // TypeScript knows: pet is Cat\n    pet.meow();\n  }\n}\n\nlet myDog: Dog = {\n  breed: 'Golden Retriever',\n  bark() { console.log('Woof!'); }\n};\n\nlet myCat: Cat = {\n  breed: 'Siamese',\n  meow() { console.log('Meow!'); }\n};\n\nmakeNoise(myDog);  // Woof!\nmakeNoise(myCat);  // Meow!\n\n// 'IN' OPERATOR TYPE GUARD\ninterface Admin {\n  name: string;\n  privileges: string[];\n}\n\ninterface Employee {\n  name: string;\n  startDate: Date;\n}\n\ntype Staff = Admin | Employee;\n\nfunction printStaffInfo(staff: Staff): void {\n  console.log('Name:', staff.name);  // Both types have 'name'\n  \n  if ('privileges' in staff) {\n    // TypeScript knows: staff is Admin\n    console.log('Privileges:', staff.privileges.join(', '));\n  }\n  \n  if ('startDate' in staff) {\n    // TypeScript knows: staff is Employee\n    console.log('Start date:', staff.startDate.toDateString());\n  }\n}\n\nlet admin: Admin = { name: 'Alice', privileges: ['create', 'delete'] };\nlet employee: Employee = { name: 'Bob', startDate: new Date('2024-01-15') };\n\nprintStaffInfo(admin);     // Name: Alice, Privileges: create, delete\nprintStaffInfo(employee);  // Name: Bob, Start date: Mon Jan 15 2024\n\n// NULLISH TYPE GUARDS - Handling null and undefined\nfunction greet(name: string | null | undefined): string {\n  if (name === null || name === undefined) {\n    return 'Hello, stranger!';\n  }\n  // TypeScript knows: name is string\n  return `Hello, ${name.toUpperCase()}!`;\n}\n\nconsole.log(greet('alice'));     // Hello, ALICE!\nconsole.log(greet(null));        // Hello, stranger!\nconsole.log(greet(undefined));   // Hello, stranger!\n\n// EXHAUSTIVENESS CHECKING - Catch missing cases\ntype Color = 'red' | 'green' | 'blue';\n\nfunction getColorHex(color: Color): string {\n  switch (color) {\n    case 'red':\n      return '#FF0000';\n    case 'green':\n      return '#00FF00';\n    case 'blue':\n      return '#0000FF';\n    default:\n      // This should never happen if all cases are handled\n      const _exhaustiveCheck: never = color;\n      return _exhaustiveCheck;\n  }\n}\n\nconsole.log('Red hex:', getColorHex('red'));    // #FF0000\nconsole.log('Blue hex:', getColorHex('blue'));  // #0000FF"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Let's break down type guards and discriminated unions:\n\n1. **typeof Type Guards**:\n   ```typescript\n   if (typeof value === 'string') {\n     // value is string here\n   }\n   ```\n   - Works for: string, number, boolean, function, object, undefined\n   - Most common type guard\n\n2. **Array.isArray Type Guard**:\n   ```typescript\n   if (Array.isArray(data)) {\n     // data is an array here\n   }\n   ```\n   - Specifically checks for arrays\n   - typeof returns 'object' for arrays!\n\n3. **Discriminated Unions**:\n   - Add a common property with literal types\n   - Usually called 'kind', 'type', or 'tag'\n   - Switch on this property to narrow types\n   ```typescript\n   interface A { kind: 'a'; propA: string }\n   interface B { kind: 'b'; propB: number }\n   type AB = A | B;\n   ```\n\n4. **Custom Type Guards** (type predicates):\n   ```typescript\n   function isDog(pet: Pet): pet is Dog {\n     return 'bark' in pet;\n   }\n   ```\n   - Return type: `paramName is Type`\n   - Returns boolean, but narrows type when true\n\n5. **'in' Operator**:\n   ```typescript\n   if ('propertyName' in object) {\n     // object has propertyName here\n   }\n   ```\n   - Checks if property exists\n   - Narrows type to those with that property\n\n6. **Nullish Checks**:\n   ```typescript\n   if (value !== null && value !== undefined) {\n     // value is non-nullable here\n   }\n   ```\n   - Removes null/undefined from type\n   - Also works: `if (value) { ... }` (for truthy check)\n\n7. **Exhaustiveness Checking**:\n   - Use `never` type in default case\n   - TypeScript errors if you forget a case\n   - Great for switch statements on unions"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common mistakes with type guards:\n\n1. **typeof null === 'object'**:\n   ```typescript\n   let value: object | null = null;\n   \n   // Wrong - null passes this check!\n   if (typeof value === 'object') {\n     // value could still be null here\n   }\n   \n   // Correct - check for null first\n   if (value !== null && typeof value === 'object') {\n     // value is definitely an object\n   }\n   ```\n\n2. **Forgetting to handle all union members**:\n   ```typescript\n   type Status = 'pending' | 'approved' | 'rejected';\n   \n   function handleStatus(status: Status): void {\n     if (status === 'pending') { ... }\n     if (status === 'approved') { ... }\n     // Forgot 'rejected'!\n   }\n   ```\n   Use exhaustiveness checking with `never`.\n\n3. **Wrong discriminant property type**:\n   ```typescript\n   // Wrong - 'type' is just string, not specific\n   interface Circle { type: string; radius: number }\n   \n   // Correct - literal type\n   interface Circle { type: 'circle'; radius: number }\n   ```\n\n4. **Type guard returns wrong thing**:\n   ```typescript\n   // Wrong - returns boolean, but no narrowing\n   function isDog(pet: Pet): boolean {\n     return 'bark' in pet;\n   }\n   \n   // Correct - 'pet is Dog' enables narrowing\n   function isDog(pet: Pet): pet is Dog {\n     return 'bark' in pet;\n   }\n   ```\n\n5. **Not understanding narrowing scope**:\n   - Type narrowing only works within the if block\n   - After the block, type reverts to original union\n   - Use early returns for cleaner code\n\n6. **Overcomplicating simple checks**:\n   ```typescript\n   // Overcomplicated\n   function isDefined<T>(value: T | undefined): value is T {\n     return value !== undefined;\n   }\n   \n   // Often simpler inline\n   if (value !== undefined) { ... }\n   ```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "Key points about type guards and discriminated unions:\n\n1. **Type guards narrow types** - They tell TypeScript which specific type a value is within a code block.\n\n2. **Use the right guard for the job**:\n   - `typeof` for primitives\n   - `Array.isArray()` for arrays\n   - `in` operator for property existence\n   - Custom guards for complex logic\n   - Discriminated unions for related types\n\n3. **Discriminated unions are powerful** - Add a `kind` property with literal types for type-safe switches.\n\n4. **Custom type guards use `is`** - Return type `param is Type` enables TypeScript narrowing.\n\n5. **Exhaustiveness checking** - Use `never` in default case to catch missing union members at compile time.\n\n6. **Narrowing is block-scoped** - Type is narrowed only within the if/else/switch block.\n\n7. **Combine with utility types** - Works great with `Exclude`, `Extract`, and other utility types."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.7-challenge",
              "title": "Practice Challenge",
              "description": "Create a payment processing system using discriminated unions:\n\n1. Create three interfaces for payment methods:\n   - `CreditCard` with: kind: 'credit', cardNumber: string, cvv: string\n   - `PayPal` with: kind: 'paypal', email: string\n   - `BankTransfer` with: kind: 'bank', accountNumber: string, routingNumber: string\n\n2. Create a union type `PaymentMethod` that includes all three\n\n3. Create a function `processPayment` that:\n   - Takes a PaymentMethod and amount: number\n   - Uses a switch statement on the 'kind' property\n   - Logs a different message for each payment type\n   - For credit: 'Processing credit card ending in XXXX'\n   - For PayPal: 'Processing PayPal payment for EMAIL'\n   - For bank: 'Processing bank transfer from account XXXX'\n\n4. Test with all three payment types",
              "instructions": "Create a payment processing system using discriminated unions:\n\n1. Create three interfaces for payment methods:\n   - `CreditCard` with: kind: 'credit', cardNumber: string, cvv: string\n   - `PayPal` with: kind: 'paypal', email: string\n   - `BankTransfer` with: kind: 'bank', accountNumber: string, routingNumber: string\n\n2. Create a union type `PaymentMethod` that includes all three\n\n3. Create a function `processPayment` that:\n   - Takes a PaymentMethod and amount: number\n   - Uses a switch statement on the 'kind' property\n   - Logs a different message for each payment type\n   - For credit: 'Processing credit card ending in XXXX'\n   - For PayPal: 'Processing PayPal payment for EMAIL'\n   - For bank: 'Processing bank transfer from account XXXX'\n\n4. Test with all three payment types",
              "starterCode": "// 1. Create the payment method interfaces\ninterface CreditCard {\n  // Add properties\n}\n\ninterface PayPal {\n  // Add properties\n}\n\ninterface BankTransfer {\n  // Add properties\n}\n\n// 2. Create the union type\ntype PaymentMethod = any;  // Fix this\n\n// 3. Create the processPayment function\nfunction processPayment(payment, amount) {\n  // Use switch statement on payment.kind\n  console.log('Processing payment of $' + amount);\n}\n\n// 4. Test with all payment types\nlet creditPayment = { kind: 'credit', cardNumber: '4111111111111234', cvv: '123' };\nlet paypalPayment = { kind: 'paypal', email: 'user@example.com' };\nlet bankPayment = { kind: 'bank', accountNumber: '12345678', routingNumber: '987654321' };\n\nprocessPayment(creditPayment, 100);\nprocessPayment(paypalPayment, 50);\nprocessPayment(bankPayment, 200);",
              "solution": "// 1. Payment method interfaces with discriminant 'kind'\ninterface CreditCard {\n  kind: 'credit';\n  cardNumber: string;\n  cvv: string;\n}\n\ninterface PayPal {\n  kind: 'paypal';\n  email: string;\n}\n\ninterface BankTransfer {\n  kind: 'bank';\n  accountNumber: string;\n  routingNumber: string;\n}\n\n// 2. Union type of all payment methods\ntype PaymentMethod = CreditCard | PayPal | BankTransfer;\n\n// 3. Process payment with type-safe switch\nfunction processPayment(payment: PaymentMethod, amount: number): void {\n  console.log(`Processing payment of $${amount}`);\n  \n  switch (payment.kind) {\n    case 'credit':\n      // TypeScript knows: payment is CreditCard\n      let lastFour = payment.cardNumber.slice(-4);\n      console.log(`Processing credit card ending in ${lastFour}`);\n      break;\n      \n    case 'paypal':\n      // TypeScript knows: payment is PayPal\n      console.log(`Processing PayPal payment for ${payment.email}`);\n      break;\n      \n    case 'bank':\n      // TypeScript knows: payment is BankTransfer\n      let maskedAccount = payment.accountNumber.slice(-4);\n      console.log(`Processing bank transfer from account ${maskedAccount}`);\n      break;\n  }\n}\n\n// 4. Test with all payment types\nlet creditPayment: CreditCard = {\n  kind: 'credit',\n  cardNumber: '4111111111111234',\n  cvv: '123'\n};\n\nlet paypalPayment: PayPal = {\n  kind: 'paypal',\n  email: 'user@example.com'\n};\n\nlet bankPayment: BankTransfer = {\n  kind: 'bank',\n  accountNumber: '12345678',\n  routingNumber: '987654321'\n};\n\nprocessPayment(creditPayment, 100);\n// Processing payment of $100\n// Processing credit card ending in 1234\n\nprocessPayment(paypalPayment, 50);\n// Processing payment of $50\n// Processing PayPal payment for user@example.com\n\nprocessPayment(bankPayment, 200);\n// Processing payment of $200\n// Processing bank transfer from account 5678",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should process credit card payment",
                  "expectedOutput": "credit card ending in",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should process PayPal payment",
                  "expectedOutput": "PayPal payment for",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Should process bank transfer",
                  "expectedOutput": "bank transfer from account",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Each interface needs a 'kind' property with a literal type (in quotes): kind: 'credit', kind: 'paypal', kind: 'bank'"
                },
                {
                  "level": 2,
                  "text": "In the switch statement, after 'case \"credit\":', TypeScript knows payment is CreditCard, so you can access payment.cardNumber safely."
                },
                {
                  "level": 3,
                  "text": "Use payment.cardNumber.slice(-4) to get the last 4 digits of the card number for display."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using string type instead of literal types for 'kind'",
                  "consequence": "TypeScript can't narrow the type in switch cases - 'kind: string' could be anything.",
                  "correction": "Use literal types: kind: 'credit' (with quotes), not kind: string."
                },
                {
                  "mistake": "Forgetting to handle all cases in the switch",
                  "consequence": "Some payment types won't be processed correctly.",
                  "correction": "Add a case for each payment kind: 'credit', 'paypal', and 'bank'."
                },
                {
                  "mistake": "Trying to access payment.cardNumber before narrowing",
                  "consequence": "TypeScript error - not all PaymentMethods have cardNumber.",
                  "correction": "Access type-specific properties only inside the appropriate case block."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "10.8",
          "title": "Union, Intersection, and Literal Types",
          "moduleId": "module-10",
          "order": 8,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Beyond Basic Types - The Power of Combination",
              "content": "Imagine a restaurant menu. Basic types are like single ingredients: chicken, rice, vegetables. But real dishes are combinations. A 'stir-fry' is chicken AND vegetables AND sauce (intersection - must have all). A 'protein option' could be chicken OR beef OR tofu (union - pick one). And 'spice level: mild | medium | hot' are literal choices - exactly those three options, nothing else.\n\nTypeScript's type system works the same way. You're not limited to primitive types like string or number. You can combine types in powerful ways: unions let a value be one of several types, intersections merge multiple types into one, and literal types restrict values to specific options. This is where TypeScript's type system becomes truly expressive - you can model exactly what your data looks like, not just 'it's an object' but 'it's an object with these specific fields that can only have these specific values.'"
            },
            {
              "type": "EXAMPLE",
              "title": "Union Types (A | B) - One or the Other",
              "content": "Union types let a value be one of several possible types. Use the pipe | operator to combine types:",
              "language": "typescript",
              "code": "// Basic union with primitives\nlet id: string | number;\nid = 'user-123';  // Valid: string\nid = 42;          // Valid: number\nid = true;        // Error: boolean not in union\n\n// Union with object types\ninterface Dog {\n  kind: 'dog';\n  bark: () => void;\n}\n\ninterface Cat {\n  kind: 'cat';\n  meow: () => void;\n}\n\ntype Pet = Dog | Cat;\n\nfunction interact(pet: Pet) {\n  // TypeScript knows pet is Dog OR Cat\n  // We can only access shared properties safely:\n  console.log(pet.kind);  // OK: both have 'kind'\n  \n  // pet.bark();  // Error: Cat doesn't have bark\n  // pet.meow();  // Error: Dog doesn't have meow\n  \n  // Narrowing: check which type we have\n  if (pet.kind === 'dog') {\n    pet.bark();  // Now TypeScript knows it's a Dog\n  } else {\n    pet.meow();  // Now TypeScript knows it's a Cat\n  }\n}\n\n// Function returning union type\nfunction parseInput(input: string): number | null {\n  const parsed = parseInt(input);\n  return isNaN(parsed) ? null : parsed;\n}\n\nconst result = parseInput('42');\nif (result !== null) {\n  // TypeScript knows result is number here\n  console.log(result * 2);  // 84\n}"
            },
            {
              "type": "EXAMPLE",
              "title": "Intersection Types (A & B) - All Combined",
              "content": "Intersection types combine multiple types into one that has ALL properties from each:",
              "language": "typescript",
              "code": "// Combining object types\ninterface HasName {\n  name: string;\n}\n\ninterface HasAge {\n  age: number;\n}\n\ninterface HasEmail {\n  email: string;\n}\n\n// Intersection: must have ALL properties\ntype Person = HasName & HasAge;\n\nconst alice: Person = {\n  name: 'Alice',\n  age: 30\n  // Both required!\n};\n\n// Extending with intersection\ntype ContactablePerson = Person & HasEmail;\n\nconst bob: ContactablePerson = {\n  name: 'Bob',\n  age: 25,\n  email: 'bob@example.com'\n  // All three required!\n};\n\n// Adding properties to existing types\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n}\n\n// Add timestamp to any response\ntype TimestampedResponse<T> = ApiResponse<T> & {\n  timestamp: Date;\n  requestId: string;\n};\n\nconst response: TimestampedResponse<{ users: string[] }> = {\n  data: { users: ['Alice', 'Bob'] },\n  status: 200,\n  timestamp: new Date(),\n  requestId: 'req-123'\n};\n\n// Practical example: Mixins\ninterface Serializable {\n  serialize(): string;\n}\n\ninterface Loggable {\n  log(): void;\n}\n\ntype LoggableAndSerializable = Serializable & Loggable;\n\nconst item: LoggableAndSerializable = {\n  serialize() { return JSON.stringify(this); },\n  log() { console.log(this.serialize()); }\n};"
            },
            {
              "type": "EXAMPLE",
              "title": "Literal Types - Specific Values Only",
              "content": "Literal types restrict variables to specific exact values, not just any value of that type:",
              "language": "typescript",
              "code": "// String literal types\ntype Direction = 'north' | 'south' | 'east' | 'west';\n\nlet heading: Direction = 'north';  // Valid\nheading = 'up';  // Error: 'up' not in union\n\n// Number literal types\ntype DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;\n\nfunction rollDice(): DiceRoll {\n  return Math.ceil(Math.random() * 6) as DiceRoll;\n}\n\n// Boolean literal (useful for discriminated unions)\ntype Success = { ok: true; value: string };\ntype Failure = { ok: false; error: string };\ntype Result = Success | Failure;\n\nfunction processResult(result: Result) {\n  if (result.ok) {\n    console.log(result.value);  // TypeScript knows it's Success\n  } else {\n    console.log(result.error);  // TypeScript knows it's Failure\n  }\n}\n\n// Creating enums without the enum keyword\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\ntype StatusCode = 200 | 201 | 400 | 401 | 403 | 404 | 500;\n\ninterface Request {\n  method: HttpMethod;\n  url: string;\n  expectedStatus: StatusCode;\n}\n\n// const assertions for literal inference\nconst config = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000\n} as const;\n// config.apiUrl is type 'https://api.example.com', not string\n// config.timeout is type 5000, not number\n\n// Array as const for tuple literal types\nconst colors = ['red', 'green', 'blue'] as const;\ntype Color = typeof colors[number];  // 'red' | 'green' | 'blue'"
            },
            {
              "type": "EXAMPLE",
              "title": "Type Aliases vs Interfaces",
              "content": "Both define custom types, but with key differences. Here's when to use each:",
              "language": "typescript",
              "code": "// INTERFACES - Best for object shapes and extension\ninterface User {\n  id: number;\n  name: string;\n}\n\n// Interfaces can be extended\ninterface Admin extends User {\n  permissions: string[];\n}\n\n// Declaration merging - interfaces can be reopened!\ninterface User {\n  email: string;  // Added to original User interface\n}\n\nconst user: User = {\n  id: 1,\n  name: 'Alice',\n  email: 'alice@example.com'  // Required due to merge\n};\n\n// TYPE ALIASES - Best for unions, primitives, tuples\ntype ID = string | number;  // Can't do this with interface\n\ntype Point = [number, number];  // Tuple - interface can't do this\n\ntype Callback = (data: string) => void;  // Function type\n\ntype Status = 'pending' | 'active' | 'closed';  // Literal union\n\n// Type aliases can use intersection (similar to extends)\ntype AdminUser = User & {\n  permissions: string[];\n};\n\n// WHEN TO USE WHICH:\n\n// Use INTERFACE when:\n// - Defining object shapes (classes, objects)\n// - You want declaration merging (library types)\n// - Extending other types with 'extends'\ninterface Component {\n  render(): void;\n}\n\n// Use TYPE when:\n// - Creating union types\n// - Creating tuple types\n// - Creating mapped or conditional types\n// - Aliasing primitives or functions\ntype EventHandler = (event: Event) => void;\ntype Nullable<T> = T | null;\ntype Keys = keyof User;  // 'id' | 'name' | 'email'\n\n// Both work for most object types - pick one and be consistent!\ntype ConfigType = { debug: boolean; port: number };\ninterface ConfigInterface { debug: boolean; port: number }\n// These are functionally equivalent for basic object shapes"
            },
            {
              "type": "THEORY",
              "title": "Complete Syntax Reference",
              "content": "**Union Types (`|`):**\n```typescript\ntype A = string | number | boolean;     // Primitives\ntype B = Dog | Cat | Bird;              // Object types\ntype C = 'on' | 'off';                  // Literal types\ntype D = string | null | undefined;     // Nullable\n```\n\n**Intersection Types (`&`):**\n```typescript\ntype A = TypeA & TypeB;                 // Combine types\ntype B = Base & { extra: string };      // Add properties\ntype C = A & B & C;                     // Multiple\n```\n\n**Literal Types:**\n```typescript\ntype Direction = 'up' | 'down' | 'left' | 'right';\ntype Digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\ntype Bool = true | false;\n```\n\n**Type Narrowing (working with unions):**\n```typescript\n// typeof guard\nif (typeof x === 'string') { /* x is string */ }\n\n// in operator\nif ('bark' in pet) { /* pet has bark property */ }\n\n// Discriminated union (tagged union)\nif (result.type === 'success') { /* result is SuccessType */ }\n\n// instanceof\nif (err instanceof Error) { /* err is Error */ }\n```\n\n**Interface vs Type Quick Reference:**\n| Feature | Interface | Type Alias |\n|---------|-----------|------------|\n| Object shapes | Yes | Yes |\n| Extends/inheritance | `extends` | `&` |\n| Declaration merging | Yes | No |\n| Union types | No | Yes |\n| Tuple types | No | Yes |\n| Primitive aliases | No | Yes |\n| Mapped types | No | Yes |"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes to Avoid",
              "content": "**1. Confusing Union and Intersection for Objects:**\n```typescript\ntype A = { a: string };\ntype B = { b: number };\n\ntype Union = A | B;        // Has 'a' OR 'b' (or both)\ntype Intersection = A & B;  // Has BOTH 'a' AND 'b'\n\n// Union: only shared properties accessible without narrowing\nfunction process(x: Union) {\n  x.a;  // Error! Not all union members have 'a'\n  if ('a' in x) x.a;  // OK after narrowing\n}\n```\n\n**2. Forgetting `as const` for Literal Inference:**\n```typescript\nconst status = 'active';        // Type: string (widened)\nconst status2 = 'active' as const;  // Type: 'active' (literal)\n\nconst arr = ['a', 'b'];         // Type: string[]\nconst arr2 = ['a', 'b'] as const;   // Type: readonly ['a', 'b']\n```\n\n**3. Accidental Type Widening:**\n```typescript\nfunction getStatus() {\n  return 'success';  // Returns string, not 'success'\n}\n\nfunction getStatus2(): 'success' | 'error' {\n  return 'success';  // Returns literal type\n}\n```\n\n**4. Impossible Intersections:**\n```typescript\ntype Never = string & number;  // Type: never (impossible)\ntype Also = { a: string } & { a: number };  // a is never\n```\n\n**5. Over-using Type Assertions:**\n```typescript\n// Avoid: as Type hides errors\nconst data = JSON.parse(input) as User;  // Dangerous!\n\n// Better: validate at runtime\nfunction isUser(data: unknown): data is User {\n  return typeof data === 'object' && data !== null\n    && 'name' in data && typeof data.name === 'string';\n}\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.9-challenge-1",
              "title": "State Machine with Literal Types",
              "description": "Model a traffic light state machine using literal types. The light can only be 'red', 'yellow', or 'green', and transitions should be type-safe.",
              "instructions": "Create a TrafficLight type using literal types. Then create a transition function that takes the current state and returns the next valid state. Red -> Green -> Yellow -> Red.",
              "starterCode": "// Define TrafficLight type with literal values\ntype TrafficLight = // your code here\n\n// Transition function: returns the next state\nfunction nextLight(current: TrafficLight): TrafficLight {\n  // Implement the state transitions\n}\n\n// Test it\nlet light: TrafficLight = 'red';\nconsole.log(`Current: ${light}`);\n\nlight = nextLight(light);\nconsole.log(`Next: ${light}`);\n\nlight = nextLight(light);\nconsole.log(`Next: ${light}`);\n\nlight = nextLight(light);\nconsole.log(`Next: ${light}`);\n\n// This should cause a TypeScript error (uncomment to test):\n// light = 'purple';",
              "solution": "// Define TrafficLight type with literal values\ntype TrafficLight = 'red' | 'yellow' | 'green';\n\n// Transition function: returns the next state\nfunction nextLight(current: TrafficLight): TrafficLight {\n  switch (current) {\n    case 'red':\n      return 'green';\n    case 'green':\n      return 'yellow';\n    case 'yellow':\n      return 'red';\n  }\n}\n\n// Test it\nlet light: TrafficLight = 'red';\nconsole.log(`Current: ${light}`);\n\nlight = nextLight(light);\nconsole.log(`Next: ${light}`);\n\nlight = nextLight(light);\nconsole.log(`Next: ${light}`);\n\nlight = nextLight(light);\nconsole.log(`Next: ${light}`);\n\n// This should cause a TypeScript error:\n// light = 'purple';  // Error: Type '\"purple\"' is not assignable to type 'TrafficLight'",
              "language": "typescript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Traffic light cycles correctly",
                  "expectedOutput": "Current: red\\nNext: green\\nNext: yellow\\nNext: red",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the pipe operator to create a union of literal strings: 'a' | 'b' | 'c'"
                },
                {
                  "level": 2,
                  "text": "A switch statement with exhaustive cases is perfect for state machines"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using string type instead of literal union",
                  "consequence": "Allows any string value, defeating the purpose of type safety",
                  "correction": "Use 'red' | 'yellow' | 'green' instead of string"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "10.9-challenge-2",
              "title": "API Response with Union and Intersection",
              "description": "Create types for API responses that can be either successful with data or failed with an error, using discriminated unions. Then add request metadata using intersection types.",
              "instructions": "Create Success and Error response types with an 'ok' discriminant. Combine them into ApiResponse union. Then use intersection to add metadata (timestamp, requestId) to create TimestampedApiResponse.",
              "starterCode": "// 1. Define Success type: { ok: true, data: T }\ninterface Success<T> {\n  // your code\n}\n\n// 2. Define Error type: { ok: false, error: string, code: number }\ninterface ApiError {\n  // your code\n}\n\n// 3. Create union type for ApiResponse\ntype ApiResponse<T> = // your code\n\n// 4. Add metadata using intersection\ntype Metadata = {\n  timestamp: Date;\n  requestId: string;\n};\n\ntype TimestampedApiResponse<T> = // your code\n\n// 5. Create a handler function\nfunction handleResponse<T>(response: TimestampedApiResponse<T>): void {\n  console.log(`Request ${response.requestId} at ${response.timestamp.toISOString()}`);\n  \n  // Use type narrowing to handle success/error\n  // your code\n}\n\n// Test with success\nconst successResponse: TimestampedApiResponse<{ name: string }> = {\n  ok: true,\n  data: { name: 'Alice' },\n  timestamp: new Date(),\n  requestId: 'req-001'\n};\n\n// Test with error\nconst errorResponse: TimestampedApiResponse<never> = {\n  ok: false,\n  error: 'Not found',\n  code: 404,\n  timestamp: new Date(),\n  requestId: 'req-002'\n};\n\nhandleResponse(successResponse);\nhandleResponse(errorResponse);",
              "solution": "// 1. Define Success type: { ok: true, data: T }\ninterface Success<T> {\n  ok: true;\n  data: T;\n}\n\n// 2. Define Error type: { ok: false, error: string, code: number }\ninterface ApiError {\n  ok: false;\n  error: string;\n  code: number;\n}\n\n// 3. Create union type for ApiResponse\ntype ApiResponse<T> = Success<T> | ApiError;\n\n// 4. Add metadata using intersection\ntype Metadata = {\n  timestamp: Date;\n  requestId: string;\n};\n\ntype TimestampedApiResponse<T> = ApiResponse<T> & Metadata;\n\n// 5. Create a handler function\nfunction handleResponse<T>(response: TimestampedApiResponse<T>): void {\n  console.log(`Request ${response.requestId} at ${response.timestamp.toISOString()}`);\n  \n  // Use type narrowing to handle success/error\n  if (response.ok) {\n    console.log('Success:', response.data);\n  } else {\n    console.log(`Error ${response.code}: ${response.error}`);\n  }\n}\n\n// Test with success\nconst successResponse: TimestampedApiResponse<{ name: string }> = {\n  ok: true,\n  data: { name: 'Alice' },\n  timestamp: new Date(),\n  requestId: 'req-001'\n};\n\n// Test with error\nconst errorResponse: TimestampedApiResponse<never> = {\n  ok: false,\n  error: 'Not found',\n  code: 404,\n  timestamp: new Date(),\n  requestId: 'req-002'\n};\n\nhandleResponse(successResponse);\nhandleResponse(errorResponse);",
              "language": "typescript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Handles success response",
                  "expectedOutput": "Success:",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Handles error response",
                  "expectedOutput": "Error 404:",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "The 'ok' property with literal true or false acts as a discriminant for type narrowing"
                },
                {
                  "level": 2,
                  "text": "Use & to combine ApiResponse<T> with Metadata"
                },
                {
                  "level": 3,
                  "text": "Inside the if (response.ok) block, TypeScript knows it's a Success type"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using boolean instead of literal true/false for ok property",
                  "consequence": "TypeScript can't narrow the type based on if (response.ok)",
                  "correction": "Use 'ok: true' in Success and 'ok: false' in ApiError for discriminated union"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "10.9-challenge-3",
              "title": "Type vs Interface Decision Making",
              "description": "Practice choosing between type aliases and interfaces. Create a config system where interfaces are used for extendable objects and types for unions and utility types.",
              "instructions": "Create: 1) DatabaseConfig interface (host, port, database), 2) Extend it to PostgresConfig and MySQLConfig interfaces, 3) Create ConnectionString type alias for string, 4) Create ConfigSource literal union type for 'env' | 'file' | 'remote', 5) Create a final Config type that combines a database config with source metadata.",
              "starterCode": "// 1. Base interface for database config\ninterface DatabaseConfig {\n  // your code: host, port, database\n}\n\n// 2. Extended interfaces for specific databases\ninterface PostgresConfig extends DatabaseConfig {\n  // your code: add ssl: boolean\n}\n\ninterface MySQLConfig extends DatabaseConfig {\n  // your code: add charset: string\n}\n\n// 3. Type alias for connection string\ntype ConnectionString = // your code\n\n// 4. Literal union for config source\ntype ConfigSource = // your code\n\n// 5. Combined config with source metadata\ntype Config<T extends DatabaseConfig> = // your code\n// Should have: config: T, source: ConfigSource, loadedAt: Date\n\n// Test your types\nconst postgresConfig: Config<PostgresConfig> = {\n  config: {\n    host: 'localhost',\n    port: 5432,\n    database: 'myapp',\n    ssl: true\n  },\n  source: 'env',\n  loadedAt: new Date()\n};\n\nconsole.log(`Connecting to ${postgresConfig.config.host}:${postgresConfig.config.port}`);\nconsole.log(`SSL enabled: ${postgresConfig.config.ssl}`);\nconsole.log(`Loaded from: ${postgresConfig.source}`);",
              "solution": "// 1. Base interface for database config\ninterface DatabaseConfig {\n  host: string;\n  port: number;\n  database: string;\n}\n\n// 2. Extended interfaces for specific databases\ninterface PostgresConfig extends DatabaseConfig {\n  ssl: boolean;\n}\n\ninterface MySQLConfig extends DatabaseConfig {\n  charset: string;\n}\n\n// 3. Type alias for connection string\ntype ConnectionString = string;\n\n// 4. Literal union for config source\ntype ConfigSource = 'env' | 'file' | 'remote';\n\n// 5. Combined config with source metadata\ntype Config<T extends DatabaseConfig> = {\n  config: T;\n  source: ConfigSource;\n  loadedAt: Date;\n};\n\n// Test your types\nconst postgresConfig: Config<PostgresConfig> = {\n  config: {\n    host: 'localhost',\n    port: 5432,\n    database: 'myapp',\n    ssl: true\n  },\n  source: 'env',\n  loadedAt: new Date()\n};\n\nconsole.log(`Connecting to ${postgresConfig.config.host}:${postgresConfig.config.port}`);\nconsole.log(`SSL enabled: ${postgresConfig.config.ssl}`);\nconsole.log(`Loaded from: ${postgresConfig.source}`);",
              "language": "typescript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Config structure is correct",
                  "expectedOutput": "Connecting to localhost:5432",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Extended properties work",
                  "expectedOutput": "SSL enabled: true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use interface with extends for the database configs since they form an inheritance hierarchy"
                },
                {
                  "level": 2,
                  "text": "Use type for ConfigSource since it's a literal union"
                },
                {
                  "level": 3,
                  "text": "The Config<T> type uses a generic constraint: T extends DatabaseConfig"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using type alias with & instead of interface extends",
                  "consequence": "Works but doesn't follow the convention: interfaces for object extension hierarchies",
                  "correction": "Use 'interface PostgresConfig extends DatabaseConfig' for clear inheritance"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "10.9",
          "title": "Advanced Type Narrowing and Type Guards (The Detective Analogy)",
          "moduleId": "module-10",
          "order": 9,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Type Narrowing: The Detective's Investigation",
              "content": "Imagine you're a detective investigating a case. A witness describes the suspect: 'It was either a tall man in a blue jacket OR a short woman in a red coat.' This is like a union type - you know it's ONE of two possibilities, but not which one.\n\nAs a detective, you gather evidence to NARROW DOWN who it was:\n- 'The suspect was wearing heels' -> Now you KNOW it's the woman (narrowing!)\n- 'The suspect was over 6 feet tall' -> Now you KNOW it's the man\n- 'The suspect had a badge' -> Only one of them is a police officer (property check)\n\nType narrowing works exactly the same way in TypeScript. When you have a union type like `string | number | null`, TypeScript doesn't know which type you actually have. But when you check evidence (using typeof, instanceof, property checks, or custom guards), TypeScript NARROWS the type within that code block. The detective's job is to eliminate possibilities until only one remains. TypeScript's job is to track what types are possible at each point in your code, eliminating options as you add checks."
            },
            {
              "type": "EXAMPLE",
              "title": "typeof Guards - Narrowing Primitive Types",
              "content": "The typeof operator is your first tool for narrowing primitives. TypeScript understands control flow and narrows types automatically after typeof checks:",
              "language": "typescript",
              "code": "// TYPEOF RETURNS THESE VALUES:\n// 'string', 'number', 'bigint', 'boolean', 'symbol', 'undefined', 'object', 'function'\n\n// Basic typeof narrowing\nfunction processValue(value: string | number | boolean): string {\n  // Here, value could be any of the three types\n  console.log('Type at start:', typeof value);\n  \n  if (typeof value === 'string') {\n    // TypeScript KNOWS value is string here!\n    // All string methods available\n    return value.toUpperCase().trim();\n  }\n  \n  if (typeof value === 'number') {\n    // TypeScript KNOWS value is number here!\n    // All number methods available\n    return value.toFixed(2);\n  }\n  \n  // Only boolean remains - TypeScript knows this!\n  return value ? 'true' : 'false';\n}\n\nconsole.log(processValue('hello'));  // 'HELLO'\nconsole.log(processValue(3.14159));  // '3.14'\nconsole.log(processValue(true));     // 'true'\n\n// typeof with early returns (preferred pattern)\nfunction formatInput(input: string | number | null | undefined): string {\n  // Handle null and undefined first\n  if (typeof input === 'undefined') {\n    return 'No input provided';\n  }\n  \n  if (input === null) {\n    return 'Input was null';\n  }\n  \n  // Now TypeScript knows: input is string | number\n  if (typeof input === 'string') {\n    return `String: ${input.length} characters`;\n  }\n  \n  // Only number remains\n  return `Number: ${input.toFixed(1)}`;\n}\n\nconsole.log(formatInput('hello'));    // 'String: 5 characters'\nconsole.log(formatInput(42));         // 'Number: 42.0'\nconsole.log(formatInput(null));       // 'Input was null'\nconsole.log(formatInput(undefined));  // 'No input provided'\n\n// CRITICAL: typeof null returns 'object' (JavaScript quirk!)\nfunction handleObject(value: object | null): void {\n  // WRONG - null passes this check!\n  if (typeof value === 'object') {\n    // value could STILL be null here because typeof null === 'object'\n    console.log('Could be object or null');\n  }\n  \n  // CORRECT - check for null explicitly first\n  if (value === null) {\n    console.log('Value is null');\n    return;\n  }\n  \n  // Now TypeScript knows value is object (not null)\n  console.log('Value is definitely an object');\n}\n\nhandleObject({ name: 'Alice' });  // 'Value is definitely an object'\nhandleObject(null);                // 'Value is null'"
            },
            {
              "type": "EXAMPLE",
              "title": "instanceof Guards - Class and Constructor Checking",
              "content": "The instanceof operator checks if an object was created from a specific constructor. It's perfect for class hierarchies and built-in types:",
              "language": "typescript",
              "code": "// instanceof with built-in types\nfunction handleError(error: Error | string): string {\n  if (error instanceof Error) {\n    // TypeScript knows: error is Error\n    // Access Error properties: message, name, stack\n    return `Error [${error.name}]: ${error.message}`;\n  }\n  \n  // TypeScript knows: error is string\n  return `String error: ${error}`;\n}\n\nconsole.log(handleError(new Error('Something failed')));\n// 'Error [Error]: Something failed'\n\nconsole.log(handleError('Connection timeout'));\n// 'String error: Connection timeout'\n\n// instanceof with custom classes\nclass Dog {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  bark(): void {\n    console.log(`${this.name} says: Woof!`);\n  }\n}\n\nclass Cat {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  meow(): void {\n    console.log(`${this.name} says: Meow!`);\n  }\n}\n\nclass Bird {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  chirp(): void {\n    console.log(`${this.name} says: Chirp!`);\n  }\n}\n\ntype Pet = Dog | Cat | Bird;\n\nfunction makeSound(pet: Pet): void {\n  if (pet instanceof Dog) {\n    // TypeScript knows: pet is Dog\n    pet.bark();\n  } else if (pet instanceof Cat) {\n    // TypeScript knows: pet is Cat\n    pet.meow();\n  } else {\n    // TypeScript knows: pet is Bird\n    pet.chirp();\n  }\n}\n\nmakeSound(new Dog('Buddy'));   // 'Buddy says: Woof!'\nmakeSound(new Cat('Whiskers')); // 'Whiskers says: Meow!'\nmakeSound(new Bird('Tweety'));  // 'Tweety says: Chirp!'\n\n// instanceof with Error subclasses\nclass ValidationError extends Error {\n  field: string;\n  constructor(message: string, field: string) {\n    super(message);\n    this.name = 'ValidationError';\n    this.field = field;\n  }\n}\n\nclass NetworkError extends Error {\n  statusCode: number;\n  constructor(message: string, statusCode: number) {\n    super(message);\n    this.name = 'NetworkError';\n    this.statusCode = statusCode;\n  }\n}\n\nfunction handleAppError(error: Error): void {\n  if (error instanceof ValidationError) {\n    // TypeScript knows: error is ValidationError\n    console.log(`Validation failed on field '${error.field}': ${error.message}`);\n  } else if (error instanceof NetworkError) {\n    // TypeScript knows: error is NetworkError\n    console.log(`Network error (${error.statusCode}): ${error.message}`);\n  } else {\n    // Generic Error\n    console.log(`Unknown error: ${error.message}`);\n  }\n}\n\nhandleAppError(new ValidationError('Required', 'email'));\n// 'Validation failed on field 'email': Required'\n\nhandleAppError(new NetworkError('Server unavailable', 503));\n// 'Network error (503): Server unavailable'\n\n// LIMITATION: instanceof doesn't work with plain objects or interfaces!\ninterface User {\n  name: string;\n  email: string;\n}\n\nlet user: User = { name: 'Alice', email: 'alice@test.com' };\n// user instanceof User; // ERROR! User is not a runtime value\n// Interfaces don't exist at runtime - use 'in' operator or custom guards instead"
            },
            {
              "type": "EXAMPLE",
              "title": "The 'in' Operator - Property Existence Checks",
              "content": "The 'in' operator checks if a property exists in an object. It's essential for narrowing between object types with different shapes:",
              "language": "typescript",
              "code": "// Basic 'in' operator usage\ninterface Admin {\n  name: string;\n  role: 'admin';\n  permissions: string[];\n}\n\ninterface RegularUser {\n  name: string;\n  role: 'user';\n  subscription: 'free' | 'premium';\n}\n\ntype User = Admin | RegularUser;\n\nfunction displayUserInfo(user: User): void {\n  // Both types have 'name' and 'role'\n  console.log(`Name: ${user.name}`);\n  console.log(`Role: ${user.role}`);\n  \n  // Use 'in' to check for type-specific properties\n  if ('permissions' in user) {\n    // TypeScript knows: user is Admin\n    console.log(`Permissions: ${user.permissions.join(', ')}`);\n  }\n  \n  if ('subscription' in user) {\n    // TypeScript knows: user is RegularUser\n    console.log(`Subscription: ${user.subscription}`);\n  }\n}\n\nlet admin: Admin = {\n  name: 'Alice',\n  role: 'admin',\n  permissions: ['create', 'read', 'update', 'delete']\n};\n\nlet regularUser: RegularUser = {\n  name: 'Bob',\n  role: 'user',\n  subscription: 'premium'\n};\n\ndisplayUserInfo(admin);\n// Name: Alice\n// Role: admin\n// Permissions: create, read, update, delete\n\ndisplayUserInfo(regularUser);\n// Name: Bob\n// Role: user\n// Subscription: premium\n\n// 'in' with optional properties\ninterface BasicProfile {\n  username: string;\n}\n\ninterface DetailedProfile {\n  username: string;\n  avatar?: string;  // Optional in DetailedProfile\n  bio?: string;\n}\n\ntype Profile = BasicProfile | DetailedProfile;\n\nfunction renderProfile(profile: Profile): void {\n  console.log(`Username: ${profile.username}`);\n  \n  // Check for optional properties\n  if ('bio' in profile && profile.bio) {\n    console.log(`Bio: ${profile.bio}`);\n  }\n  \n  if ('avatar' in profile && profile.avatar) {\n    console.log(`Avatar: ${profile.avatar}`);\n  }\n}\n\nrenderProfile({ username: 'alice' });\n// Username: alice\n\nrenderProfile({ username: 'bob', bio: 'Developer', avatar: 'bob.png' });\n// Username: bob\n// Bio: Developer\n// Avatar: bob.png\n\n// 'in' with discriminated unions (even better!)\ninterface SuccessResponse {\n  status: 'success';\n  data: { id: number; name: string };\n}\n\ninterface ErrorResponse {\n  status: 'error';\n  error: { code: number; message: string };\n}\n\ntype ApiResponse = SuccessResponse | ErrorResponse;\n\nfunction handleResponse(response: ApiResponse): void {\n  // Using 'in' to narrow\n  if ('data' in response) {\n    // TypeScript knows: response is SuccessResponse\n    console.log(`Success! User: ${response.data.name}`);\n  } else {\n    // TypeScript knows: response is ErrorResponse\n    console.log(`Error ${response.error.code}: ${response.error.message}`);\n  }\n  \n  // OR use the discriminant (even better for this pattern!)\n  if (response.status === 'success') {\n    console.log(`Got user ID: ${response.data.id}`);\n  }\n}\n\nhandleResponse({ status: 'success', data: { id: 1, name: 'Alice' } });\n// Success! User: Alice\n// Got user ID: 1\n\nhandleResponse({ status: 'error', error: { code: 404, message: 'Not found' } });\n// Error 404: Not found"
            },
            {
              "type": "EXAMPLE",
              "title": "Custom Type Guards with 'is' Keyword",
              "content": "When built-in checks aren't enough, create custom type guard functions. The magic is in the return type: `param is Type`. This tells TypeScript that when the function returns true, the parameter IS that type:",
              "language": "typescript",
              "code": "// Basic custom type guard\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nfunction isNumber(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value);\n}\n\n// Using the custom guards\nfunction processUnknown(value: unknown): string {\n  if (isString(value)) {\n    // TypeScript knows: value is string\n    return value.toUpperCase();\n  }\n  \n  if (isNumber(value)) {\n    // TypeScript knows: value is number\n    return value.toFixed(2);\n  }\n  \n  return 'Unknown type';\n}\n\nconsole.log(processUnknown('hello'));  // 'HELLO'\nconsole.log(processUnknown(42.567));   // '42.57'\nconsole.log(processUnknown(null));     // 'Unknown type'\n\n// Type guard for interface validation\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// REUSABLE type guard - validates unknown data is User\nfunction isUser(value: unknown): value is User {\n  // Check if it's an object\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n  \n  // Cast to access properties (we're validating them)\n  const obj = value as Record<string, unknown>;\n  \n  // Check required properties exist and have correct types\n  return (\n    typeof obj.id === 'number' &&\n    typeof obj.name === 'string' &&\n    typeof obj.email === 'string'\n  );\n}\n\n// Safe API response handling\nfunction handleApiData(data: unknown): void {\n  if (isUser(data)) {\n    // TypeScript knows: data is User - full autocomplete!\n    console.log(`User: ${data.name} (${data.email})`);\n    console.log(`ID: ${data.id}`);\n  } else {\n    console.log('Invalid user data received');\n  }\n}\n\nhandleApiData({ id: 1, name: 'Alice', email: 'alice@test.com' });\n// User: Alice (alice@test.com)\n// ID: 1\n\nhandleApiData({ name: 'Bob' });  // Missing id and email\n// Invalid user data received\n\nhandleApiData('not an object');\n// Invalid user data received\n\n// Type guard for arrays\nfunction isStringArray(value: unknown): value is string[] {\n  return Array.isArray(value) && value.every(item => typeof item === 'string');\n}\n\nfunction processData(data: unknown): void {\n  if (isStringArray(data)) {\n    // TypeScript knows: data is string[]\n    console.log('String array:', data.join(', '));\n    console.log('Total length:', data.reduce((sum, s) => sum + s.length, 0));\n  }\n}\n\nprocessData(['apple', 'banana', 'cherry']);\n// String array: apple, banana, cherry\n// Total length: 17\n\n// Advanced: Type guard for nested objects\ninterface Address {\n  street: string;\n  city: string;\n  zip: string;\n}\n\ninterface Person {\n  name: string;\n  age: number;\n  address: Address;\n}\n\nfunction isAddress(value: unknown): value is Address {\n  if (typeof value !== 'object' || value === null) return false;\n  const obj = value as Record<string, unknown>;\n  return (\n    typeof obj.street === 'string' &&\n    typeof obj.city === 'string' &&\n    typeof obj.zip === 'string'\n  );\n}\n\nfunction isPerson(value: unknown): value is Person {\n  if (typeof value !== 'object' || value === null) return false;\n  const obj = value as Record<string, unknown>;\n  return (\n    typeof obj.name === 'string' &&\n    typeof obj.age === 'number' &&\n    isAddress(obj.address)  // Reuse the address guard!\n  );\n}\n\nlet personData = {\n  name: 'Alice',\n  age: 30,\n  address: { street: '123 Main St', city: 'Boston', zip: '02101' }\n};\n\nif (isPerson(personData)) {\n  console.log(`${personData.name} lives in ${personData.address.city}`);\n}\n// Alice lives in Boston"
            },
            {
              "type": "EXAMPLE",
              "title": "Discriminated Unions - The Power Pattern",
              "content": "Discriminated unions use a common 'tag' property with literal types to distinguish between union members. Combined with exhaustiveness checking, they're TypeScript's most powerful pattern:",
              "language": "typescript",
              "code": "// THE DISCRIMINATED UNION PATTERN\n// 1. Common property (discriminant/tag) with literal types\n// 2. Each variant has unique literal value\n// 3. TypeScript narrows automatically based on the discriminant\n\n// Example: State machine for async operations\ninterface LoadingState {\n  status: 'loading';  // Discriminant\n}\n\ninterface SuccessState<T> {\n  status: 'success';  // Discriminant\n  data: T;\n}\n\ninterface ErrorState {\n  status: 'error';  // Discriminant\n  error: string;\n  code: number;\n}\n\ntype AsyncState<T> = LoadingState | SuccessState<T> | ErrorState;\n\nfunction renderState<T>(state: AsyncState<T>): string {\n  switch (state.status) {\n    case 'loading':\n      // TypeScript knows: state is LoadingState\n      return 'Loading...';\n      \n    case 'success':\n      // TypeScript knows: state is SuccessState<T>\n      // state.data is available!\n      return `Data: ${JSON.stringify(state.data)}`;\n      \n    case 'error':\n      // TypeScript knows: state is ErrorState\n      // state.error and state.code are available!\n      return `Error ${state.code}: ${state.error}`;\n  }\n}\n\nlet loading: AsyncState<string[]> = { status: 'loading' };\nlet success: AsyncState<string[]> = { status: 'success', data: ['a', 'b', 'c'] };\nlet error: AsyncState<string[]> = { status: 'error', error: 'Network failed', code: 500 };\n\nconsole.log(renderState(loading));  // 'Loading...'\nconsole.log(renderState(success));  // 'Data: [\"a\",\"b\",\"c\"]'\nconsole.log(renderState(error));    // 'Error 500: Network failed'\n\n// EXHAUSTIVENESS CHECKING with never\n// If you add a new state and forget to handle it, TypeScript catches it!\n\ninterface IdleState {\n  status: 'idle';\n}\n\ntype FullAsyncState<T> = IdleState | LoadingState | SuccessState<T> | ErrorState;\n\nfunction assertNever(x: never): never {\n  throw new Error(`Unexpected value: ${x}`);\n}\n\nfunction handleFullState<T>(state: FullAsyncState<T>): string {\n  switch (state.status) {\n    case 'idle':\n      return 'Ready to start';\n    case 'loading':\n      return 'Loading...';\n    case 'success':\n      return `Got: ${JSON.stringify(state.data)}`;\n    case 'error':\n      return `Failed: ${state.error}`;\n    default:\n      // If all cases are handled, state is 'never' here\n      // If you add a new status and forget it, TypeScript errors!\n      return assertNever(state);\n  }\n}\n\n// Real-world: Redux-style actions\ninterface AddTodoAction {\n  type: 'ADD_TODO';\n  payload: { text: string; id: number };\n}\n\ninterface ToggleTodoAction {\n  type: 'TOGGLE_TODO';\n  payload: { id: number };\n}\n\ninterface DeleteTodoAction {\n  type: 'DELETE_TODO';\n  payload: { id: number };\n}\n\ninterface ClearCompletedAction {\n  type: 'CLEAR_COMPLETED';\n  // No payload needed\n}\n\ntype TodoAction = AddTodoAction | ToggleTodoAction | DeleteTodoAction | ClearCompletedAction;\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nfunction todoReducer(todos: Todo[], action: TodoAction): Todo[] {\n  switch (action.type) {\n    case 'ADD_TODO':\n      // action.payload has text and id\n      return [...todos, { \n        id: action.payload.id, \n        text: action.payload.text, \n        completed: false \n      }];\n      \n    case 'TOGGLE_TODO':\n      // action.payload has id\n      return todos.map(todo =>\n        todo.id === action.payload.id\n          ? { ...todo, completed: !todo.completed }\n          : todo\n      );\n      \n    case 'DELETE_TODO':\n      // action.payload has id\n      return todos.filter(todo => todo.id !== action.payload.id);\n      \n    case 'CLEAR_COMPLETED':\n      // No payload to access\n      return todos.filter(todo => !todo.completed);\n      \n    default:\n      return assertNever(action);\n  }\n}\n\nlet initialTodos: Todo[] = [];\n\nlet afterAdd = todoReducer(initialTodos, { \n  type: 'ADD_TODO', \n  payload: { id: 1, text: 'Learn TypeScript' } \n});\nconsole.log('After add:', afterAdd);\n// After add: [{ id: 1, text: 'Learn TypeScript', completed: false }]\n\nlet afterToggle = todoReducer(afterAdd, { \n  type: 'TOGGLE_TODO', \n  payload: { id: 1 } \n});\nconsole.log('After toggle:', afterToggle);\n// After toggle: [{ id: 1, text: 'Learn TypeScript', completed: true }]"
            },
            {
              "type": "EXAMPLE",
              "title": "Truthiness Narrowing and Optional Chaining",
              "content": "JavaScript's truthiness rules can narrow types. Combined with optional chaining, you get powerful null-safe code:",
              "language": "typescript",
              "code": "// TRUTHINESS NARROWING\n// If a value is truthy, TypeScript knows it's not null/undefined\n\nfunction greetUser(name: string | null | undefined): string {\n  if (name) {\n    // TypeScript knows: name is string (truthy check excludes null/undefined)\n    return `Hello, ${name.toUpperCase()}!`;\n  }\n  return 'Hello, Guest!';\n}\n\nconsole.log(greetUser('Alice'));     // 'Hello, ALICE!'\nconsole.log(greetUser(null));        // 'Hello, Guest!'\nconsole.log(greetUser(undefined));   // 'Hello, Guest!'\n\n// WARNING: Truthiness is tricky with 0, '', and false!\nfunction processCount(count: number | null): string {\n  // WRONG - 0 is falsy, but it's a valid number!\n  if (count) {\n    return `Count: ${count}`;\n  }\n  return 'No count';  // This triggers for count = 0!\n}\n\nconsole.log(processCount(5));    // 'Count: 5'\nconsole.log(processCount(0));    // 'No count' (WRONG! 0 is valid)\nconsole.log(processCount(null)); // 'No count'\n\n// CORRECT - use explicit null check\nfunction processCountFixed(count: number | null): string {\n  if (count !== null) {\n    // TypeScript knows: count is number\n    return `Count: ${count}`;\n  }\n  return 'No count';\n}\n\nconsole.log(processCountFixed(0));  // 'Count: 0' (Correct!)\n\n// Double-bang (!!) for boolean conversion\nfunction hasContent(text: string | null | undefined): boolean {\n  return !!text;  // Converts to boolean: true if truthy, false if falsy\n}\n\nconsole.log(hasContent('hello'));    // true\nconsole.log(hasContent(''));         // false (empty string is falsy)\nconsole.log(hasContent(null));       // false\n\n// OPTIONAL CHAINING (?.) with narrowing\ninterface Company {\n  name: string;\n  address?: {\n    street: string;\n    city: string;\n    country?: string;\n  };\n}\n\nfunction getCompanyLocation(company: Company): string {\n  // Optional chaining - returns undefined if address is missing\n  const city = company.address?.city;\n  const country = company.address?.country;\n  \n  if (city && country) {\n    // Both are defined (narrowed to string)\n    return `${city}, ${country}`;\n  } else if (city) {\n    // Only city is defined\n    return city;\n  }\n  return 'Location unknown';\n}\n\nlet company1: Company = { name: 'TechCorp' };\nlet company2: Company = { name: 'GlobalInc', address: { street: '123 Main', city: 'Boston' } };\nlet company3: Company = { name: 'WorldWide', address: { street: '456 Oak', city: 'London', country: 'UK' } };\n\nconsole.log(getCompanyLocation(company1));  // 'Location unknown'\nconsole.log(getCompanyLocation(company2));  // 'Boston'\nconsole.log(getCompanyLocation(company3));  // 'London, UK'\n\n// NULLISH COALESCING (??) with narrowing\n// ?? returns right side only for null/undefined (not 0 or '')\n\nfunction getDisplayName(user: { name?: string; username: string }): string {\n  // ?? only uses fallback for null/undefined, not empty string\n  const displayName = user.name ?? user.username;\n  return displayName.toUpperCase();  // TypeScript knows it's string\n}\n\nconsole.log(getDisplayName({ username: 'alice123' }));\n// 'ALICE123'\n\nconsole.log(getDisplayName({ name: 'Alice', username: 'alice123' }));\n// 'ALICE'\n\nconsole.log(getDisplayName({ name: '', username: 'alice123' }));\n// '' (empty string is NOT nullish, so it's used)\n\n// Combined patterns\ninterface UserProfile {\n  id: number;\n  name?: string;\n  settings?: {\n    theme?: 'light' | 'dark';\n    notifications?: boolean;\n  };\n}\n\nfunction getUserTheme(profile: UserProfile | null): string {\n  // Chain optional access with nullish coalescing\n  return profile?.settings?.theme ?? 'light';\n}\n\nconsole.log(getUserTheme(null));                                    // 'light'\nconsole.log(getUserTheme({ id: 1 }));                              // 'light'\nconsole.log(getUserTheme({ id: 1, settings: {} }));                // 'light'\nconsole.log(getUserTheme({ id: 1, settings: { theme: 'dark' } })); // 'dark'"
            },
            {
              "type": "THEORY",
              "title": "Complete Type Narrowing Reference",
              "content": "**All Narrowing Techniques in One Place:**\n\n**1. typeof Guards (primitives):**\n```typescript\nif (typeof x === 'string') { /* x is string */ }\nif (typeof x === 'number') { /* x is number */ }\nif (typeof x === 'boolean') { /* x is boolean */ }\nif (typeof x === 'function') { /* x is callable */ }\nif (typeof x === 'undefined') { /* x is undefined */ }\n```\n\n**2. instanceof Guards (classes):**\n```typescript\nif (x instanceof Date) { /* x is Date */ }\nif (x instanceof Error) { /* x is Error */ }\nif (x instanceof MyClass) { /* x is MyClass */ }\n```\n\n**3. in Operator (property check):**\n```typescript\nif ('property' in obj) { /* obj has property */ }\nif ('bark' in animal) { /* animal is Dog-like */ }\n```\n\n**4. Custom Type Guards (is keyword):**\n```typescript\nfunction isUser(x: unknown): x is User {\n  return typeof x === 'object' && x !== null\n    && 'name' in x && 'email' in x;\n}\n```\n\n**5. Equality Narrowing:**\n```typescript\nif (x === 'specific') { /* x is 'specific' literal */ }\nif (x === null) { /* x is null */ }\nif (x !== undefined) { /* x is not undefined */ }\n```\n\n**6. Truthiness Narrowing:**\n```typescript\nif (x) { /* x is truthy (not null, undefined, 0, '', false) */ }\nif (!x) { /* x is falsy */ }\n```\n\n**7. Discriminated Unions:**\n```typescript\ntype Shape = { kind: 'circle'; r: number } | { kind: 'rect'; w: number; h: number };\nif (shape.kind === 'circle') { /* shape is circle */ }\n```\n\n**8. Array Checks:**\n```typescript\nif (Array.isArray(x)) { /* x is an array */ }\n```\n\n**9. Assertion Functions (TypeScript 3.7+):**\n```typescript\nfunction assertIsString(x: unknown): asserts x is string {\n  if (typeof x !== 'string') throw new Error('Not a string');\n}\n```\n\n**Narrowing Scope Rules:**\n- Narrowing applies within the block where the check happens\n- After the block, type reverts to original\n- Use early returns to keep narrowed type for rest of function\n- Reassignment resets the narrowed type"
            },
            {
              "type": "WARNING",
              "title": "Common Narrowing Mistakes",
              "content": "**1. typeof null === 'object' (JavaScript quirk)**:\n```typescript\nfunction process(val: object | null) {\n  if (typeof val === 'object') {\n    // val could STILL be null! typeof null === 'object'\n  }\n  \n  // Fix: check null explicitly first\n  if (val !== null && typeof val === 'object') {\n    // Now val is definitely object\n  }\n}\n```\n\n**2. Truthiness issues with 0 and ''**:\n```typescript\nfunction count(n: number | null) {\n  if (n) {  // WRONG: 0 is falsy but valid!\n    return n * 2;\n  }\n}\n\n// Fix: use explicit null check\nfunction countFixed(n: number | null) {\n  if (n !== null) {  // 0 passes this correctly\n    return n * 2;\n  }\n}\n```\n\n**3. Type predicate that doesn't actually validate**:\n```typescript\n// DANGEROUS: Always returns true, doesn't validate!\nfunction isUser(x: unknown): x is User {\n  return true;  // Lies to TypeScript!\n}\n\n// Fix: Actually validate the structure\nfunction isUserSafe(x: unknown): x is User {\n  return typeof x === 'object' && x !== null\n    && 'name' in x && typeof (x as any).name === 'string';\n}\n```\n\n**4. Forgetting exhaustiveness checks**:\n```typescript\ntype Status = 'pending' | 'active' | 'done';\n\nfunction handle(s: Status) {\n  if (s === 'pending') return;\n  if (s === 'active') return;\n  // Forgot 'done'! No error by default\n}\n\n// Fix: add exhaustiveness check\nfunction handleFixed(s: Status) {\n  switch (s) {\n    case 'pending': return;\n    case 'active': return;\n    case 'done': return;\n    default:\n      const _never: never = s;  // Error if case missing!\n  }\n}\n```\n\n**5. instanceof doesn't work with interfaces**:\n```typescript\ninterface User { name: string; }\nconst user: User = { name: 'Alice' };\n\n// ERROR: User only exists at compile-time!\nif (user instanceof User) { }  // 'User' only refers to a type\n\n// Fix: use 'in' or custom type guard\nif ('name' in user) { }\n```\n\n**6. Narrowing doesn't persist after function calls**:\n```typescript\nlet value: string | null = 'hello';\n\nif (value !== null) {\n  console.log(value.length);  // OK: value is string\n  someFunction();  // TypeScript might assume this could change value\n  // value is still string | null here in some cases\n}\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "**Type Narrowing Mastery:**\n\n1. **Narrowing is control-flow analysis** - TypeScript tracks types through if/else, switch, and early returns\n\n2. **Match the guard to the type:**\n   - Primitives: typeof\n   - Classes: instanceof\n   - Object shapes: 'in' operator\n   - Complex validation: custom type guards\n   - Tagged objects: discriminated unions\n\n3. **Discriminated unions are the power pattern:**\n   - Add a 'type', 'kind', or 'status' property\n   - Use literal types for the discriminant\n   - Combine with exhaustiveness checking (never)\n\n4. **Custom type guards are reusable safety:**\n   - Return type: `param is Type`\n   - Actually validate the structure inside\n   - Compose guards for nested objects\n\n5. **Watch out for JavaScript quirks:**\n   - typeof null === 'object'\n   - 0, '', and false are falsy\n   - Interfaces don't exist at runtime\n\n6. **Use exhaustiveness checking:**\n   - `const _never: never = value` in default case\n   - TypeScript errors if you forget a union member\n\n7. **Early returns keep code clean:**\n   - Handle invalid cases first and return\n   - Remaining code has the narrowed type"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.10-challenge-1",
              "title": "Shape Calculator with Discriminated Unions",
              "description": "Build a type-safe shape calculator using discriminated unions. Create shapes (circle, rectangle, triangle), calculate areas, and use exhaustiveness checking to ensure all shapes are handled.",
              "instructions": "1. Create interfaces for Circle (kind: 'circle', radius), Rectangle (kind: 'rectangle', width, height), and Triangle (kind: 'triangle', base, height)\n2. Create a Shape union type\n3. Create calculateArea function with exhaustiveness checking\n4. Create a describe function that returns a description string for each shape\n5. Test with all three shapes",
              "starterCode": "// 1. Define shape interfaces with discriminant 'kind'\ninterface Circle {\n  // kind: 'circle' and radius\n}\n\ninterface Rectangle {\n  // kind: 'rectangle', width, and height\n}\n\ninterface Triangle {\n  // kind: 'triangle', base, and height\n}\n\n// 2. Union type\ntype Shape = Circle | Rectangle | Triangle;\n\n// Helper for exhaustiveness checking\nfunction assertNever(x: never): never {\n  throw new Error(`Unexpected shape: ${JSON.stringify(x)}`);\n}\n\n// 3. Calculate area with exhaustiveness checking\nfunction calculateArea(shape: Shape): number {\n  // Use switch on shape.kind\n  // Circle: Math.PI * r^2\n  // Rectangle: width * height\n  // Triangle: 0.5 * base * height\n}\n\n// 4. Describe the shape\nfunction describeShape(shape: Shape): string {\n  // Return descriptions like:\n  // 'A circle with radius 5'\n  // 'A 10x4 rectangle'\n  // 'A triangle with base 6 and height 8'\n}\n\n// 5. Test all shapes\nlet circle: Circle = { kind: 'circle', radius: 5 };\nlet rect: Rectangle = { kind: 'rectangle', width: 10, height: 4 };\nlet tri: Triangle = { kind: 'triangle', base: 6, height: 8 };\n\nconsole.log(describeShape(circle), '- Area:', calculateArea(circle).toFixed(2));\nconsole.log(describeShape(rect), '- Area:', calculateArea(rect));\nconsole.log(describeShape(tri), '- Area:', calculateArea(tri));",
              "solution": "// 1. Define shape interfaces with discriminant 'kind'\ninterface Circle {\n  kind: 'circle';\n  radius: number;\n}\n\ninterface Rectangle {\n  kind: 'rectangle';\n  width: number;\n  height: number;\n}\n\ninterface Triangle {\n  kind: 'triangle';\n  base: number;\n  height: number;\n}\n\n// 2. Union type\ntype Shape = Circle | Rectangle | Triangle;\n\n// Helper for exhaustiveness checking\nfunction assertNever(x: never): never {\n  throw new Error(`Unexpected shape: ${JSON.stringify(x)}`);\n}\n\n// 3. Calculate area with exhaustiveness checking\nfunction calculateArea(shape: Shape): number {\n  switch (shape.kind) {\n    case 'circle':\n      return Math.PI * shape.radius ** 2;\n    case 'rectangle':\n      return shape.width * shape.height;\n    case 'triangle':\n      return 0.5 * shape.base * shape.height;\n    default:\n      return assertNever(shape);\n  }\n}\n\n// 4. Describe the shape\nfunction describeShape(shape: Shape): string {\n  switch (shape.kind) {\n    case 'circle':\n      return `A circle with radius ${shape.radius}`;\n    case 'rectangle':\n      return `A ${shape.width}x${shape.height} rectangle`;\n    case 'triangle':\n      return `A triangle with base ${shape.base} and height ${shape.height}`;\n    default:\n      return assertNever(shape);\n  }\n}\n\n// 5. Test all shapes\nlet circle: Circle = { kind: 'circle', radius: 5 };\nlet rect: Rectangle = { kind: 'rectangle', width: 10, height: 4 };\nlet tri: Triangle = { kind: 'triangle', base: 6, height: 8 };\n\nconsole.log(describeShape(circle), '- Area:', calculateArea(circle).toFixed(2));\n// A circle with radius 5 - Area: 78.54\n\nconsole.log(describeShape(rect), '- Area:', calculateArea(rect));\n// A 10x4 rectangle - Area: 40\n\nconsole.log(describeShape(tri), '- Area:', calculateArea(tri));\n// A triangle with base 6 and height 8 - Area: 24",
              "language": "typescript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Circle area calculated correctly",
                  "expectedOutput": "78.54",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Rectangle area calculated correctly",
                  "expectedOutput": "40",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Triangle area calculated correctly",
                  "expectedOutput": "24",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Each interface needs a 'kind' property with a literal type in quotes: kind: 'circle'"
                },
                {
                  "level": 2,
                  "text": "In switch cases, TypeScript narrows the type. After 'case \"circle\":', shape is Circle."
                },
                {
                  "level": 3,
                  "text": "The assertNever function in default ensures TypeScript errors if you forget a shape type."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using string instead of literal types for kind",
                  "consequence": "TypeScript can't narrow the type in switch cases",
                  "correction": "Use literal types: kind: 'circle' (with quotes)"
                },
                {
                  "mistake": "Forgetting the default case with assertNever",
                  "consequence": "No compile-time error if you add a new shape and forget to handle it",
                  "correction": "Always include default: return assertNever(shape);"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "10.10-challenge-2",
              "title": "API Response Validator with Custom Type Guards",
              "description": "Create custom type guards to validate unknown API response data. Build reusable validation functions that safely narrow types and provide type safety for API responses.",
              "instructions": "1. Create a User interface (id: number, name: string, email: string, role: 'admin' | 'user')\n2. Create an ApiResponse type with success and error variants\n3. Write isUser type guard that validates unknown data\n4. Write isApiResponse type guard that validates the full response\n5. Process mock API data safely with proper narrowing",
              "starterCode": "// 1. User interface\ninterface User {\n  // Define: id, name, email, role ('admin' | 'user')\n}\n\n// 2. API Response types (discriminated union)\ninterface SuccessResponse {\n  success: true;\n  data: User;\n}\n\ninterface ErrorResponse {\n  success: false;\n  error: string;\n  code: number;\n}\n\ntype ApiResponse = SuccessResponse | ErrorResponse;\n\n// 3. Type guard for User\nfunction isUser(value: unknown): value is User {\n  // Check all properties exist and have correct types\n  // Don't forget to validate role is 'admin' or 'user'\n}\n\n// 4. Type guard for ApiResponse\nfunction isApiResponse(value: unknown): value is ApiResponse {\n  // Check success property and validate accordingly\n}\n\n// 5. Safe processor function\nfunction processApiResponse(data: unknown): void {\n  if (!isApiResponse(data)) {\n    console.log('Invalid API response format');\n    return;\n  }\n  \n  // Now data is ApiResponse - handle success and error cases\n}\n\n// Test with various data\nlet validSuccess = {\n  success: true,\n  data: { id: 1, name: 'Alice', email: 'alice@test.com', role: 'admin' }\n};\n\nlet validError = {\n  success: false,\n  error: 'User not found',\n  code: 404\n};\n\nlet invalidData = { message: 'wrong format' };\n\nprocessApiResponse(validSuccess);\nprocessApiResponse(validError);\nprocessApiResponse(invalidData);",
              "solution": "// 1. User interface\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  role: 'admin' | 'user';\n}\n\n// 2. API Response types (discriminated union)\ninterface SuccessResponse {\n  success: true;\n  data: User;\n}\n\ninterface ErrorResponse {\n  success: false;\n  error: string;\n  code: number;\n}\n\ntype ApiResponse = SuccessResponse | ErrorResponse;\n\n// 3. Type guard for User\nfunction isUser(value: unknown): value is User {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n  \n  const obj = value as Record<string, unknown>;\n  \n  return (\n    typeof obj.id === 'number' &&\n    typeof obj.name === 'string' &&\n    typeof obj.email === 'string' &&\n    (obj.role === 'admin' || obj.role === 'user')\n  );\n}\n\n// 4. Type guard for ApiResponse\nfunction isApiResponse(value: unknown): value is ApiResponse {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n  \n  const obj = value as Record<string, unknown>;\n  \n  if (obj.success === true) {\n    // Validate SuccessResponse\n    return isUser(obj.data);\n  } else if (obj.success === false) {\n    // Validate ErrorResponse\n    return (\n      typeof obj.error === 'string' &&\n      typeof obj.code === 'number'\n    );\n  }\n  \n  return false;\n}\n\n// 5. Safe processor function\nfunction processApiResponse(data: unknown): void {\n  if (!isApiResponse(data)) {\n    console.log('Invalid API response format');\n    return;\n  }\n  \n  // Now data is ApiResponse\n  if (data.success) {\n    // TypeScript knows: data is SuccessResponse\n    console.log(`Success! User: ${data.data.name} (${data.data.email})`);\n    console.log(`Role: ${data.data.role}`);\n  } else {\n    // TypeScript knows: data is ErrorResponse\n    console.log(`Error ${data.code}: ${data.error}`);\n  }\n}\n\n// Test with various data\nlet validSuccess = {\n  success: true,\n  data: { id: 1, name: 'Alice', email: 'alice@test.com', role: 'admin' }\n};\n\nlet validError = {\n  success: false,\n  error: 'User not found',\n  code: 404\n};\n\nlet invalidData = { message: 'wrong format' };\n\nprocessApiResponse(validSuccess);\n// Success! User: Alice (alice@test.com)\n// Role: admin\n\nprocessApiResponse(validError);\n// Error 404: User not found\n\nprocessApiResponse(invalidData);\n// Invalid API response format",
              "language": "typescript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Processes valid success response",
                  "expectedOutput": "Alice",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Processes valid error response",
                  "expectedOutput": "Error 404",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Rejects invalid data",
                  "expectedOutput": "Invalid API response",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start type guards by checking typeof value === 'object' && value !== null"
                },
                {
                  "level": 2,
                  "text": "Use (value as Record<string, unknown>) to access properties safely during validation"
                },
                {
                  "level": 3,
                  "text": "For role validation, check obj.role === 'admin' || obj.role === 'user'"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not checking for null when typeof returns 'object'",
                  "consequence": "typeof null === 'object', so null passes the object check",
                  "correction": "Always check: typeof value === 'object' && value !== null"
                },
                {
                  "mistake": "Type guard returns true without validating all properties",
                  "consequence": "Lies to TypeScript - code crashes when accessing missing properties",
                  "correction": "Validate EVERY required property exists and has the correct type"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "10.10-challenge-3",
              "title": "Form Validation with Type Narrowing",
              "description": "Build a type-safe form validation system using multiple narrowing techniques. Handle different input types, validate data, and return typed results.",
              "instructions": "1. Create FormField union type for text, email, and number fields\n2. Create ValidationResult discriminated union (valid/invalid)\n3. Implement validateField function using typeof, in operator, and custom logic\n4. Implement validateForm that processes an array of fields\n5. Test with various valid and invalid inputs",
              "starterCode": "// 1. Form field types (discriminated union)\ninterface TextField {\n  type: 'text';\n  name: string;\n  value: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\ninterface EmailField {\n  type: 'email';\n  name: string;\n  value: string;\n}\n\ninterface NumberField {\n  type: 'number';\n  name: string;\n  value: number;\n  min?: number;\n  max?: number;\n}\n\ntype FormField = TextField | EmailField | NumberField;\n\n// 2. Validation result (discriminated union)\ninterface ValidResult {\n  valid: true;\n  fieldName: string;\n}\n\ninterface InvalidResult {\n  valid: false;\n  fieldName: string;\n  error: string;\n}\n\ntype ValidationResult = ValidResult | InvalidResult;\n\n// Helper: Email validation\nfunction isValidEmail(email: string): boolean {\n  return email.includes('@') && email.includes('.');\n}\n\n// 3. Validate single field\nfunction validateField(field: FormField): ValidationResult {\n  // Use switch on field.type\n  // text: check minLength/maxLength if specified\n  // email: check valid email format\n  // number: check min/max if specified\n}\n\n// 4. Validate entire form\nfunction validateForm(fields: FormField[]): { isValid: boolean; errors: string[] } {\n  // Process each field and collect errors\n}\n\n// 5. Test the validation\nlet formFields: FormField[] = [\n  { type: 'text', name: 'username', value: 'alice', minLength: 3 },\n  { type: 'email', name: 'email', value: 'alice@test.com' },\n  { type: 'number', name: 'age', value: 25, min: 18, max: 120 },\n  { type: 'text', name: 'bio', value: 'Hi', minLength: 10 },  // Too short!\n  { type: 'email', name: 'backup', value: 'invalid-email' },  // Invalid!\n  { type: 'number', name: 'score', value: 150, max: 100 }     // Too high!\n];\n\nlet result = validateForm(formFields);\nconsole.log('Form valid:', result.isValid);\nconsole.log('Errors:', result.errors);",
              "solution": "// 1. Form field types (discriminated union)\ninterface TextField {\n  type: 'text';\n  name: string;\n  value: string;\n  minLength?: number;\n  maxLength?: number;\n}\n\ninterface EmailField {\n  type: 'email';\n  name: string;\n  value: string;\n}\n\ninterface NumberField {\n  type: 'number';\n  name: string;\n  value: number;\n  min?: number;\n  max?: number;\n}\n\ntype FormField = TextField | EmailField | NumberField;\n\n// 2. Validation result (discriminated union)\ninterface ValidResult {\n  valid: true;\n  fieldName: string;\n}\n\ninterface InvalidResult {\n  valid: false;\n  fieldName: string;\n  error: string;\n}\n\ntype ValidationResult = ValidResult | InvalidResult;\n\n// Helper: Email validation\nfunction isValidEmail(email: string): boolean {\n  return email.includes('@') && email.includes('.');\n}\n\n// 3. Validate single field\nfunction validateField(field: FormField): ValidationResult {\n  switch (field.type) {\n    case 'text': {\n      // TypeScript knows: field is TextField\n      if (field.minLength !== undefined && field.value.length < field.minLength) {\n        return {\n          valid: false,\n          fieldName: field.name,\n          error: `${field.name} must be at least ${field.minLength} characters`\n        };\n      }\n      if (field.maxLength !== undefined && field.value.length > field.maxLength) {\n        return {\n          valid: false,\n          fieldName: field.name,\n          error: `${field.name} must be at most ${field.maxLength} characters`\n        };\n      }\n      return { valid: true, fieldName: field.name };\n    }\n    \n    case 'email': {\n      // TypeScript knows: field is EmailField\n      if (!isValidEmail(field.value)) {\n        return {\n          valid: false,\n          fieldName: field.name,\n          error: `${field.name} must be a valid email address`\n        };\n      }\n      return { valid: true, fieldName: field.name };\n    }\n    \n    case 'number': {\n      // TypeScript knows: field is NumberField\n      if (field.min !== undefined && field.value < field.min) {\n        return {\n          valid: false,\n          fieldName: field.name,\n          error: `${field.name} must be at least ${field.min}`\n        };\n      }\n      if (field.max !== undefined && field.value > field.max) {\n        return {\n          valid: false,\n          fieldName: field.name,\n          error: `${field.name} must be at most ${field.max}`\n        };\n      }\n      return { valid: true, fieldName: field.name };\n    }\n  }\n}\n\n// 4. Validate entire form\nfunction validateForm(fields: FormField[]): { isValid: boolean; errors: string[] } {\n  let errors: string[] = [];\n  \n  for (let field of fields) {\n    let result = validateField(field);\n    \n    if (!result.valid) {\n      // TypeScript knows: result is InvalidResult\n      errors.push(result.error);\n    }\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}\n\n// 5. Test the validation\nlet formFields: FormField[] = [\n  { type: 'text', name: 'username', value: 'alice', minLength: 3 },\n  { type: 'email', name: 'email', value: 'alice@test.com' },\n  { type: 'number', name: 'age', value: 25, min: 18, max: 120 },\n  { type: 'text', name: 'bio', value: 'Hi', minLength: 10 },  // Too short!\n  { type: 'email', name: 'backup', value: 'invalid-email' },  // Invalid!\n  { type: 'number', name: 'score', value: 150, max: 100 }     // Too high!\n];\n\nlet result = validateForm(formFields);\nconsole.log('Form valid:', result.isValid);\n// Form valid: false\n\nconsole.log('Errors:', result.errors);\n// Errors: [\n//   'bio must be at least 10 characters',\n//   'backup must be a valid email address',\n//   'score must be at most 100'\n// ]",
              "language": "typescript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Detects invalid form",
                  "expectedOutput": "Form valid: false",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Finds text length error",
                  "expectedOutput": "at least 10 characters",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Finds email format error",
                  "expectedOutput": "valid email address",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use switch (field.type) to narrow the field type automatically"
                },
                {
                  "level": 2,
                  "text": "Check optional properties with !== undefined before using them"
                },
                {
                  "level": 3,
                  "text": "Use !result.valid to narrow to InvalidResult and access result.error"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Checking field.minLength without undefined check",
                  "consequence": "Comparing undefined < number gives false, but 0 is a valid minLength",
                  "correction": "Use field.minLength !== undefined before the comparison"
                },
                {
                  "mistake": "Not using block scope {} in switch cases",
                  "consequence": "Variable declarations can conflict between cases",
                  "correction": "Wrap each case in braces: case 'text': { ... }"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "utility-types",
          "title": "TypeScript Utility Types (The Workshop Tools Analogy)",
          "moduleId": "module-10",
          "order": 10,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "CONCEPT",
              "title": "Built-in Type Transformers",
              "content": "Imagine you're in a workshop with specialized tools. Instead of building every tool from scratch, you have power tools that transform raw materials into exactly what you need. TypeScript's utility types work the same way - they're built-in type transformers that take an existing type and produce a new, modified version.\n\nWhy does TypeScript provide these utility types? Because developers kept writing the same type transformations over and over: making properties optional, picking certain fields, making things readonly. Rather than having everyone reinvent these wheels, TypeScript includes them as standard tools.\n\nThe pattern is consistent: each utility type takes one or more type parameters (like function arguments) and returns a transformed type. For example, `Partial<User>` takes your User type and returns a new type where every property is optional. This reduces boilerplate dramatically - what would take 10 lines of manual type definition becomes a single word.\n\nThese utilities also increase type safety. When you use `Readonly<Config>`, TypeScript enforces immutability at compile time. When you use `Pick<User, 'id' | 'name'>`, you get exactly those fields and nothing else. The compiler catches mistakes that would otherwise slip through.\n\nThink of utility types as the 'verbs' of the type system - they DO something to your types. `Partial` makes optional, `Required` makes required, `Pick` selects, `Omit` excludes, `Readonly` freezes. Master these verbs and you can express complex type relationships concisely."
            },
            {
              "type": "CODE",
              "title": "Partial<T> and Required<T>",
              "content": "Partial<T> transforms all properties of T into optional properties. This is incredibly useful for update operations where you might only change some fields. Required<T> does the opposite - it makes all properties required, even those marked with '?'. These two utilities are mirrors of each other.",
              "language": "typescript",
              "code": "// Original type with mix of required and optional\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  avatar?: string;    // Optional\n  bio?: string;       // Optional\n}\n\n// PARTIAL<T> - Makes ALL properties optional\ntype PartialUser = Partial<User>;\n// Equivalent to:\n// {\n//   id?: number;\n//   name?: string;\n//   email?: string;\n//   avatar?: string;\n//   bio?: string;\n// }\n\n// Real use case: Update operations\nfunction updateUser(userId: number, updates: Partial<User>): User {\n  // Fetch existing user (simulated)\n  let existingUser: User = {\n    id: userId,\n    name: 'Alice',\n    email: 'alice@example.com'\n  };\n  \n  // Merge updates - only provided fields are changed\n  return { ...existingUser, ...updates };\n}\n\n// You can update just one field\nlet updated1 = updateUser(1, { name: 'Alicia' });\nconsole.log(updated1);\n// { id: 1, name: 'Alicia', email: 'alice@example.com' }\n\n// Or multiple fields\nlet updated2 = updateUser(1, { email: 'new@email.com', bio: 'Developer' });\nconsole.log(updated2);\n// { id: 1, name: 'Alice', email: 'new@email.com', bio: 'Developer' }\n\n// REQUIRED<T> - Makes ALL properties required\ntype RequiredUser = Required<User>;\n// Equivalent to:\n// {\n//   id: number;\n//   name: string;\n//   email: string;\n//   avatar: string;   // No longer optional!\n//   bio: string;      // No longer optional!\n// }\n\n// Real use case: Form validation - ensure all fields filled before submit\ninterface RegistrationForm {\n  username?: string;\n  email?: string;\n  password?: string;\n  confirmPassword?: string;\n}\n\n// After validation, we know all fields are present\ntype ValidatedForm = Required<RegistrationForm>;\n\nfunction submitRegistration(form: ValidatedForm): void {\n  // TypeScript knows all fields are present\n  console.log(`Registering ${form.username} with email ${form.email}`);\n  // No need for optional chaining or null checks!\n}\n\n// Validate and submit\nlet formData: RegistrationForm = {\n  username: 'alice',\n  email: 'alice@test.com',\n  password: 'secure123',\n  confirmPassword: 'secure123'\n};\n\n// Check all required fields before calling submitRegistration\nif (formData.username && formData.email && formData.password && formData.confirmPassword) {\n  submitRegistration(formData as ValidatedForm);\n}\n// Output: Registering alice with email alice@test.com\n\n// Combining Partial with intersection for patch operations\ninterface Article {\n  id: number;\n  title: string;\n  content: string;\n  published: boolean;\n}\n\n// Patch = some fields from Article, plus metadata\ntype ArticlePatch = Partial<Article> & { updatedAt: Date };\n\nfunction patchArticle(id: number, patch: ArticlePatch): void {\n  console.log(`Patching article ${id} at ${patch.updatedAt}`);\n  if (patch.title) console.log(`New title: ${patch.title}`);\n  if (patch.published !== undefined) console.log(`Published: ${patch.published}`);\n}\n\npatchArticle(42, { title: 'New Title', updatedAt: new Date() });\n// Patching article 42 at [current date]\n// New title: New Title"
            },
            {
              "type": "CODE",
              "title": "Pick<T, K> and Omit<T, K>",
              "content": "Pick<T, K> creates a type by selecting specific properties from T. Omit<T, K> creates a type by excluding specific properties from T. These are complementary - Pick says 'I want only these', Omit says 'I want everything except these'. They're essential for creating API response types and hiding internal fields.",
              "language": "typescript",
              "code": "// Full user type with many properties\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  passwordHash: string;     // Sensitive!\n  createdAt: Date;\n  updatedAt: Date;\n  lastLoginIp: string;      // Sensitive!\n  role: 'admin' | 'user';\n  preferences: {\n    theme: 'light' | 'dark';\n    notifications: boolean;\n  };\n}\n\n// PICK<T, K> - Select only specific properties\n// Great for API responses - only expose what's needed\n\n// Public profile - only non-sensitive fields\ntype PublicProfile = Pick<User, 'id' | 'name' | 'role'>;\n// Equivalent to:\n// {\n//   id: number;\n//   name: string;\n//   role: 'admin' | 'user';\n// }\n\nfunction getPublicProfile(user: User): PublicProfile {\n  // TypeScript ensures we only return picked fields\n  return {\n    id: user.id,\n    name: user.name,\n    role: user.role\n  };\n}\n\nlet fullUser: User = {\n  id: 1,\n  name: 'Alice',\n  email: 'alice@test.com',\n  passwordHash: 'hashed_password_here',\n  createdAt: new Date('2024-01-01'),\n  updatedAt: new Date('2024-06-15'),\n  lastLoginIp: '192.168.1.1',\n  role: 'admin',\n  preferences: { theme: 'dark', notifications: true }\n};\n\nlet publicData = getPublicProfile(fullUser);\nconsole.log(publicData);\n// { id: 1, name: 'Alice', role: 'admin' }\n// passwordHash, email, IP - all excluded!\n\n// OMIT<T, K> - Exclude specific properties\n// Great for hiding sensitive fields\n\n// Remove sensitive fields for logging\ntype SafeUserLog = Omit<User, 'passwordHash' | 'lastLoginIp'>;\n// Has everything EXCEPT passwordHash and lastLoginIp\n\nfunction logUserActivity(user: User): void {\n  // Create safe version for logging\n  let safeUser: SafeUserLog = {\n    id: user.id,\n    name: user.name,\n    email: user.email,\n    createdAt: user.createdAt,\n    updatedAt: user.updatedAt,\n    role: user.role,\n    preferences: user.preferences\n  };\n  console.log('User activity:', JSON.stringify(safeUser, null, 2));\n}\n\n// API endpoint types\ninterface BlogPost {\n  id: number;\n  title: string;\n  content: string;\n  authorId: number;\n  createdAt: Date;\n  updatedAt: Date;\n  views: number;\n  internalNotes: string;  // Admin only!\n}\n\n// What authors can create (no id, timestamps, or views)\ntype CreatePostInput = Omit<BlogPost, 'id' | 'createdAt' | 'updatedAt' | 'views' | 'internalNotes'>;\n// { title: string; content: string; authorId: number; }\n\n// What public API returns (no internal notes)\ntype PublicPost = Omit<BlogPost, 'internalNotes'>;\n\n// Combining Pick and Omit for complex transformations\n// Summary = only these fields from full post\ntype PostSummary = Pick<BlogPost, 'id' | 'title' | 'authorId' | 'createdAt'>;\n\nfunction getPostSummaries(posts: BlogPost[]): PostSummary[] {\n  return posts.map(post => ({\n    id: post.id,\n    title: post.title,\n    authorId: post.authorId,\n    createdAt: post.createdAt\n  }));\n}\n\nlet posts: BlogPost[] = [\n  { id: 1, title: 'Hello World', content: 'First post...', authorId: 1, \n    createdAt: new Date(), updatedAt: new Date(), views: 100, internalNotes: 'Review needed' }\n];\n\nconsole.log(getPostSummaries(posts));\n// [{ id: 1, title: 'Hello World', authorId: 1, createdAt: [Date] }]"
            },
            {
              "type": "CODE",
              "title": "Record<K, V>",
              "content": "Record<K, V> creates an object type where every key of type K maps to a value of type V. It's perfect for lookup tables, dictionaries, and mapping enum values to data. Think of it as a type-safe way to say 'an object where all keys are X and all values are Y'.",
              "language": "typescript",
              "code": "// RECORD<K, V> - Create an object type with specific key-value pairs\n\n// Simple lookup table: string keys, number values\ntype PriceList = Record<string, number>;\n\nlet prices: PriceList = {\n  apple: 1.50,\n  banana: 0.75,\n  orange: 2.00\n};\n\nconsole.log(prices['apple']);  // 1.5\n\n// Type-safe enum-to-value mapping\ntype Status = 'pending' | 'active' | 'completed' | 'cancelled';\ntype StatusInfo = { label: string; color: string };\n\n// Record ensures EVERY status has info defined\nconst statusConfig: Record<Status, StatusInfo> = {\n  pending: { label: 'Pending', color: 'yellow' },\n  active: { label: 'Active', color: 'green' },\n  completed: { label: 'Completed', color: 'blue' },\n  cancelled: { label: 'Cancelled', color: 'red' }\n  // If you forget one, TypeScript errors!\n};\n\nfunction getStatusBadge(status: Status): string {\n  const info = statusConfig[status];\n  return `<span style=\"color: ${info.color}\">${info.label}</span>`;\n}\n\nconsole.log(getStatusBadge('active'));\n// <span style=\"color: green\">Active</span>\n\n// Permission system with Record\ntype Role = 'admin' | 'editor' | 'viewer';\ntype Permission = 'create' | 'read' | 'update' | 'delete';\n\n// Each role has a set of permissions\nconst rolePermissions: Record<Role, Permission[]> = {\n  admin: ['create', 'read', 'update', 'delete'],\n  editor: ['create', 'read', 'update'],\n  viewer: ['read']\n};\n\nfunction canPerform(role: Role, action: Permission): boolean {\n  return rolePermissions[role].includes(action);\n}\n\nconsole.log(canPerform('editor', 'read'));   // true\nconsole.log(canPerform('viewer', 'delete')); // false\n\n// Caching with Record\ntype CacheEntry<T> = {\n  data: T;\n  timestamp: number;\n  ttl: number;\n};\n\ntype Cache<T> = Record<string, CacheEntry<T>>;\n\nlet userCache: Cache<{ name: string; email: string }> = {};\n\nfunction cacheUser(id: string, user: { name: string; email: string }): void {\n  userCache[id] = {\n    data: user,\n    timestamp: Date.now(),\n    ttl: 60000  // 1 minute\n  };\n}\n\nfunction getCachedUser(id: string): { name: string; email: string } | null {\n  const entry = userCache[id];\n  if (!entry) return null;\n  if (Date.now() - entry.timestamp > entry.ttl) {\n    delete userCache[id];\n    return null;\n  }\n  return entry.data;\n}\n\ncacheUser('user-1', { name: 'Alice', email: 'alice@test.com' });\nconsole.log(getCachedUser('user-1'));\n// { name: 'Alice', email: 'alice@test.com' }\n\n// Record with index for counting\nfunction countWords(text: string): Record<string, number> {\n  const words = text.toLowerCase().split(/\\s+/);\n  const counts: Record<string, number> = {};\n  \n  for (const word of words) {\n    counts[word] = (counts[word] || 0) + 1;\n  }\n  \n  return counts;\n}\n\nconsole.log(countWords('the quick brown fox jumps over the lazy dog'));\n// { the: 2, quick: 1, brown: 1, fox: 1, jumps: 1, over: 1, lazy: 1, dog: 1 }\n\n// Nested Record for complex mappings\ntype Language = 'en' | 'es' | 'fr';\ntype TranslationKey = 'greeting' | 'farewell' | 'thanks';\n\nconst translations: Record<Language, Record<TranslationKey, string>> = {\n  en: { greeting: 'Hello', farewell: 'Goodbye', thanks: 'Thank you' },\n  es: { greeting: 'Hola', farewell: 'Adios', thanks: 'Gracias' },\n  fr: { greeting: 'Bonjour', farewell: 'Au revoir', thanks: 'Merci' }\n};\n\nfunction translate(key: TranslationKey, lang: Language): string {\n  return translations[lang][key];\n}\n\nconsole.log(translate('greeting', 'fr'));  // 'Bonjour'"
            },
            {
              "type": "CODE",
              "title": "Readonly<T> and ReadonlyArray<T>",
              "content": "Readonly<T> makes all properties of T read-only, preventing reassignment after creation. ReadonlyArray<T> creates an array type that prevents modifications (push, pop, splice, etc.). These enforce immutability at the type level, catching accidental mutations at compile time rather than runtime.",
              "language": "typescript",
              "code": "// READONLY<T> - Make all properties read-only\n\ninterface Config {\n  apiUrl: string;\n  timeout: number;\n  retries: number;\n  debug: boolean;\n}\n\n// Mutable config - can be changed anytime\nlet mutableConfig: Config = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n  retries: 3,\n  debug: false\n};\n\nmutableConfig.timeout = 10000;  // OK - config can be mutated\n\n// Readonly config - frozen after creation\nconst frozenConfig: Readonly<Config> = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n  retries: 3,\n  debug: false\n};\n\n// frozenConfig.timeout = 10000;\n// ERROR: Cannot assign to 'timeout' because it is a read-only property\n\nconsole.log(frozenConfig.timeout);  // 5000 - reading is fine\n\n// Real use case: Application settings that shouldn't change\nfunction createAppConfig(env: 'dev' | 'prod'): Readonly<Config> {\n  const baseConfig: Config = {\n    apiUrl: env === 'prod' ? 'https://api.prod.com' : 'https://api.dev.com',\n    timeout: env === 'prod' ? 10000 : 5000,\n    retries: 3,\n    debug: env === 'dev'\n  };\n  \n  // Return as Readonly - callers can't modify\n  return baseConfig;\n}\n\nconst appConfig = createAppConfig('prod');\n// appConfig.debug = true;  // ERROR: read-only\n\n// READONLYARRAY<T> - Immutable arrays\n\nconst numbers: ReadonlyArray<number> = [1, 2, 3, 4, 5];\n\nconsole.log(numbers[0]);  // 1 - reading OK\nconsole.log(numbers.length);  // 5 - length OK\n\n// numbers.push(6);      // ERROR: Property 'push' does not exist\n// numbers[0] = 10;      // ERROR: Index signature in type 'readonly number[]' only permits reading\n// numbers.pop();        // ERROR: Property 'pop' does not exist\n// numbers.splice(0, 1); // ERROR: Property 'splice' does not exist\n\n// Alternative syntax using readonly modifier\nconst moreNumbers: readonly number[] = [10, 20, 30];\n// Same as ReadonlyArray<number>\n\n// Functions that don't modify their input should use readonly\nfunction sum(values: readonly number[]): number {\n  // values.push(0);  // ERROR - can't modify\n  return values.reduce((a, b) => a + b, 0);\n}\n\nconsole.log(sum([1, 2, 3, 4]));  // 10\n\n// Readonly doesn't make nested objects immutable (shallow!)\ninterface Team {\n  name: string;\n  members: string[];\n}\n\nconst team: Readonly<Team> = {\n  name: 'Engineering',\n  members: ['Alice', 'Bob']\n};\n\n// team.name = 'Product';  // ERROR: read-only\nteam.members.push('Charlie');  // ALLOWED! Only the reference is readonly\nconsole.log(team.members);  // ['Alice', 'Bob', 'Charlie']\n\n// For deep immutability, create a DeepReadonly type\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n\ninterface NestedConfig {\n  server: {\n    host: string;\n    port: number;\n  };\n  features: string[];\n}\n\nconst deepConfig: DeepReadonly<NestedConfig> = {\n  server: { host: 'localhost', port: 3000 },\n  features: ['auth', 'api']\n};\n\n// deepConfig.server.port = 8080;     // ERROR: read-only\n// deepConfig.features.push('logs');  // ERROR: read-only array\n\n// Readonly for function parameters - prevent accidental mutation\nfunction processUsers(users: readonly { name: string; score: number }[]): void {\n  // Safe operations\n  users.forEach(u => console.log(u.name));\n  const sorted = [...users].sort((a, b) => b.score - a.score);  // Copy first!\n  console.log('Top scorer:', sorted[0].name);\n}\n\nprocessUsers([{ name: 'Alice', score: 95 }, { name: 'Bob', score: 88 }]);\n// Alice\n// Bob\n// Top scorer: Alice"
            },
            {
              "type": "CODE",
              "title": "ReturnType<T> and Parameters<T>",
              "content": "ReturnType<T> extracts the return type from a function type. Parameters<T> extracts the parameter types as a tuple. These are invaluable when you don't control the function definition - like when working with third-party libraries or dynamically generating wrapper functions.",
              "language": "typescript",
              "code": "// RETURNTYPE<T> - Extract the return type of a function\n\nfunction createUser(name: string, email: string) {\n  return {\n    id: Math.random(),\n    name,\n    email,\n    createdAt: new Date()\n  };\n}\n\n// Extract the return type without manually defining it\ntype User = ReturnType<typeof createUser>;\n// User is: { id: number; name: string; email: string; createdAt: Date }\n\n// Now you can use this type elsewhere\nfunction displayUser(user: User): void {\n  console.log(`${user.name} (${user.email}) - ID: ${user.id}`);\n}\n\nconst newUser = createUser('Alice', 'alice@test.com');\ndisplayUser(newUser);\n// Alice (alice@test.com) - ID: 0.123456789\n\n// Why is this useful? Working with third-party libraries!\n// Imagine this function comes from a library you don't control:\nfunction fetchFromApi<T>(endpoint: string): Promise<{ data: T; status: number }> {\n  // Simulated API response\n  return Promise.resolve({ data: {} as T, status: 200 });\n}\n\n// Extract the response type\ntype ApiResponse<T> = ReturnType<typeof fetchFromApi<T>>;\n// ApiResponse<T> is Promise<{ data: T; status: number }>\n\n// Extracting type from async functions\nasync function loadUserData(id: string) {\n  // Simulated async operation\n  return {\n    profile: { name: 'Alice', avatar: 'alice.png' },\n    settings: { theme: 'dark', notifications: true }\n  };\n}\n\ntype UserData = Awaited<ReturnType<typeof loadUserData>>;\n// UserData is: { profile: {...}; settings: {...} }\n\n// PARAMETERS<T> - Extract function parameters as a tuple\n\nfunction sendEmail(to: string, subject: string, body: string, priority?: number): boolean {\n  console.log(`Sending to ${to}: ${subject}`);\n  return true;\n}\n\ntype EmailParams = Parameters<typeof sendEmail>;\n// EmailParams is: [to: string, subject: string, body: string, priority?: number]\n\n// Use cases: Creating wrapper functions\nfunction loggedSendEmail(...args: EmailParams): boolean {\n  console.log('Email params:', args);\n  return sendEmail(...args);\n}\n\nloggedSendEmail('test@test.com', 'Hello', 'Message body');\n// Email params: ['test@test.com', 'Hello', 'Message body']\n// Sending to test@test.com: Hello\n\n// Extract individual parameter types\ntype FirstParam = Parameters<typeof sendEmail>[0];  // string (to)\ntype SecondParam = Parameters<typeof sendEmail>[1]; // string (subject)\n\n// Combining ReturnType and Parameters for decorators\nfunction withRetry<T extends (...args: any[]) => any>(\n  fn: T,\n  maxRetries: number = 3\n): (...args: Parameters<T>) => ReturnType<T> {\n  return (...args: Parameters<T>): ReturnType<T> => {\n    let lastError: Error | undefined;\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        return fn(...args);\n      } catch (e) {\n        lastError = e as Error;\n        console.log(`Retry ${i + 1}/${maxRetries}`);\n      }\n    }\n    throw lastError;\n  };\n}\n\nfunction riskyOperation(value: number): string {\n  if (Math.random() > 0.7) {\n    return `Success: ${value}`;\n  }\n  throw new Error('Random failure');\n}\n\nconst safeOperation = withRetry(riskyOperation, 5);\n// safeOperation has same type signature as riskyOperation\nconsole.log(safeOperation(42));\n// May output: Retry 1/5, Retry 2/5, then Success: 42\n\n// Extract constructor parameters with ConstructorParameters\nclass DatabaseConnection {\n  constructor(\n    public host: string,\n    public port: number,\n    public database: string\n  ) {}\n}\n\ntype DBParams = ConstructorParameters<typeof DatabaseConnection>;\n// DBParams is: [host: string, port: number, database: string]\n\nfunction createConnection(...args: DBParams): DatabaseConnection {\n  return new DatabaseConnection(...args);\n}\n\nconst db = createConnection('localhost', 5432, 'myapp');\nconsole.log(db);  // DatabaseConnection { host: 'localhost', port: 5432, database: 'myapp' }"
            },
            {
              "type": "CODE",
              "title": "Awaited<T>",
              "content": "Awaited<T> unwraps Promise types to get the resolved value type. It handles nested promises too - Awaited<Promise<Promise<string>>> gives you string. This utility is essential for async/await typing, especially when you need to work with the resolved value type of an async function.",
              "language": "typescript",
              "code": "// AWAITED<T> - Unwrap Promise types\n\n// Basic Promise unwrapping\ntype PromiseString = Promise<string>;\ntype UnwrappedString = Awaited<PromiseString>;  // string\n\ntype PromiseNumber = Promise<number>;\ntype UnwrappedNumber = Awaited<PromiseNumber>;  // number\n\n// Nested Promise handling - Awaited unwraps ALL layers\ntype NestedPromise = Promise<Promise<Promise<boolean>>>;\ntype DeeplyUnwrapped = Awaited<NestedPromise>;  // boolean\n\n// Non-Promise types pass through unchanged\ntype NotAPromise = Awaited<string>;  // string\ntype AlsoNotPromise = Awaited<number | null>;  // number | null\n\n// Real use case: Working with async function return types\nasync function fetchUser(id: number) {\n  // Simulated API call\n  return {\n    id,\n    name: 'Alice',\n    email: 'alice@example.com',\n    role: 'admin' as const\n  };\n}\n\n// ReturnType gives Promise<{...}>\ntype FetchUserReturn = ReturnType<typeof fetchUser>;\n// Promise<{ id: number; name: string; email: string; role: 'admin' }>\n\n// Awaited unwraps it\ntype User = Awaited<ReturnType<typeof fetchUser>>;\n// { id: number; name: string; email: string; role: 'admin' }\n\n// Now you can use the unwrapped type\nfunction processUser(user: User): void {\n  console.log(`Processing ${user.name} (${user.role})`);\n}\n\n// Awaited with Promise.all\nasync function loadDashboard() {\n  const [user, posts, settings] = await Promise.all([\n    fetchUser(1),\n    fetchPosts(1),\n    fetchSettings(1)\n  ]);\n  return { user, posts, settings };\n}\n\nasync function fetchPosts(userId: number) {\n  return [{ id: 1, title: 'First Post' }, { id: 2, title: 'Second Post' }];\n}\n\nasync function fetchSettings(userId: number) {\n  return { theme: 'dark', notifications: true };\n}\n\ntype DashboardData = Awaited<ReturnType<typeof loadDashboard>>;\n// { user: {...}; posts: {...}[]; settings: {...} }\n\n// Awaited in generic functions\ntype UnwrapPromise<T> = T extends Promise<infer U> ? U : T;\n// This is essentially what Awaited does (simplified)\n\nasync function fetchAndTransform<T>(\n  fetcher: () => Promise<T>,\n  transformer: (data: Awaited<Promise<T>>) => string\n): Promise<string> {\n  const data = await fetcher();\n  return transformer(data);\n}\n\nconst result = await fetchAndTransform(\n  () => fetchUser(1),\n  (user) => `User: ${user.name}`  // TypeScript knows 'user' type!\n);\n\nconsole.log(result);  // 'User: Alice'\n\n// Handling union types with Promise\ntype MaybePromise<T> = T | Promise<T>;\n\nasync function handleMaybeAsync<T>(value: MaybePromise<T>): Promise<T> {\n  return await value;  // Works for both Promise<T> and T\n}\n\ntype ResultType = Awaited<MaybePromise<string>>;  // string\n\n// Practical example: Caching async results\ntype AsyncCache<T extends (...args: any[]) => Promise<any>> = {\n  get: (key: string) => Awaited<ReturnType<T>> | undefined;\n  set: (key: string, value: Awaited<ReturnType<T>>) => void;\n};\n\nfunction createAsyncCache<T extends (...args: any[]) => Promise<any>>(): AsyncCache<T> {\n  const cache = new Map<string, Awaited<ReturnType<T>>>();\n  return {\n    get: (key: string) => cache.get(key),\n    set: (key: string, value: Awaited<ReturnType<T>>) => cache.set(key, value)\n  };\n}\n\nconst userCache = createAsyncCache<typeof fetchUser>();\nuserCache.set('user-1', { id: 1, name: 'Alice', email: 'alice@test.com', role: 'admin' });\nconsole.log(userCache.get('user-1'));\n// { id: 1, name: 'Alice', email: 'alice@test.com', role: 'admin' }"
            },
            {
              "type": "CODE",
              "title": "NoInfer<T> (TypeScript 5.4+)",
              "content": "NoInfer<T> is a newer utility type that prevents TypeScript from inferring a type from a specific position. It's an advanced pattern primarily useful for library authors who need precise control over which arguments drive type inference and which should follow along. Without NoInfer, TypeScript might infer an overly-wide type from the wrong argument.",
              "language": "typescript",
              "code": "// NOINFER<T> - Control type inference in generics (TypeScript 5.4+)\n// Prevents a type from being used in inference\n\n// The problem NoInfer solves:\nfunction createState<T>(initial: T, defaultValue: T): { value: T; default: T } {\n  return { value: initial, default: defaultValue };\n}\n\n// Without NoInfer, TypeScript infers from BOTH arguments:\nconst state1 = createState('hello', 'default');\n// T is inferred as string - OK!\n\nconst state2 = createState('specific', 'fallback' as string);\n// T might be inferred as string instead of the literal\n\n// WITH NoInfer - control which argument drives inference:\nfunction createStateFixed<T>(initial: T, defaultValue: NoInfer<T>): { value: T; default: T } {\n  return { value: initial, default: defaultValue };\n}\n\n// Now ONLY 'initial' drives inference, 'defaultValue' must match:\nconst state3 = createStateFixed('hello', 'fallback');\n// T inferred from 'initial' only -> 'hello' literal type!\n// 'fallback' must be assignable to T\n\n// Real use case: Default values in generic functions\nfunction getOrDefault<T>(value: T | null, defaultValue: NoInfer<T>): T {\n  return value ?? defaultValue;\n}\n\n// The type of 'colors' is inferred from the first argument\nconst colors = ['red', 'green', 'blue'] as const;\nconst color = getOrDefault(colors[0] ?? null, 'unknown');\n// Without NoInfer: T might widen to string\n// With NoInfer: T is 'red' | 'green' | 'blue', and 'unknown' must match\n\n// Use case: Event handlers with specific event types\ntype EventHandler<T extends string> = {\n  type: T;\n  handler: (event: { type: NoInfer<T>; data: any }) => void;\n};\n\nfunction on<T extends string>(config: EventHandler<T>): void {\n  console.log(`Registered handler for: ${config.type}`);\n}\n\n// T is inferred from 'type' property only\non({\n  type: 'click',\n  handler: (event) => {\n    // event.type is 'click' (literal), not just string\n    console.log(`Handling ${event.type}`);\n  }\n});\n\n// Use case: Validators with inferred output types\ntype Validator<T> = {\n  validate: (input: unknown) => input is T;\n  defaultValue: NoInfer<T>;\n};\n\nfunction createValidator<T>(validator: Validator<T>): (input: unknown) => T {\n  return (input: unknown): T => {\n    if (validator.validate(input)) {\n      return input;\n    }\n    return validator.defaultValue;\n  };\n}\n\nconst stringValidator = createValidator({\n  validate: (x): x is string => typeof x === 'string',\n  defaultValue: ''  // Must match the validated type\n});\n\nconsole.log(stringValidator('hello'));  // 'hello'\nconsole.log(stringValidator(123));      // ''\n\n// Use case: Preventing unwanted type widening in options\ninterface Options<T extends string> {\n  mode: T;\n  fallbackMode: NoInfer<T>;\n}\n\nfunction configure<T extends string>(options: Options<T>): void {\n  console.log(`Mode: ${options.mode}, Fallback: ${options.fallbackMode}`);\n}\n\n// T is inferred from 'mode' only\nconfigure({\n  mode: 'strict',\n  fallbackMode: 'strict'  // Must be same as mode\n});\n\n// configure({\n//   mode: 'strict',\n//   fallbackMode: 'lenient'  // ERROR: 'lenient' not assignable to 'strict'\n// });\n\n// Note: NoInfer is most useful for library authors\n// In application code, explicit type annotations usually suffice\n// But when you need precise inference control, NoInfer is invaluable"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "10.11-challenge-1",
              "title": "API Response Transformer",
              "description": "Use Pick, Omit, and Partial to create different views of a User type for various API endpoints. Create types for public profiles, update operations, and admin views while keeping sensitive data protected.",
              "instructions": "1. Start with the full User interface (id, name, email, passwordHash, role, createdAt, lastLogin, preferences)\n2. Create PublicUser using Pick (only id, name, role)\n3. Create UpdateUserInput using Partial and Omit (no id, passwordHash, createdAt)\n4. Create AdminUserView using Omit (hide only passwordHash)\n5. Create a function that transforms a full User to PublicUser\n6. Test with sample user data",
              "starterCode": "// 1. Full User interface with all fields\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  passwordHash: string;\n  role: 'admin' | 'user' | 'guest';\n  createdAt: Date;\n  lastLogin: Date | null;\n  preferences: {\n    theme: 'light' | 'dark';\n    emailNotifications: boolean;\n  };\n}\n\n// 2. PublicUser - only safe fields for public API\n// Use Pick to select: id, name, role\ntype PublicUser = /* Your code here */;\n\n// 3. UpdateUserInput - fields that can be updated\n// Use Partial + Omit: can't update id, passwordHash, createdAt\ntype UpdateUserInput = /* Your code here */;\n\n// 4. AdminUserView - everything except passwordHash\n// Use Omit to exclude passwordHash\ntype AdminUserView = /* Your code here */;\n\n// 5. Transform function\nfunction toPublicUser(user: User): PublicUser {\n  // Return only the public fields\n}\n\n// 6. Test with sample data\nconst fullUser: User = {\n  id: 1,\n  name: 'Alice Johnson',\n  email: 'alice@company.com',\n  passwordHash: 'hashed_password_12345',\n  role: 'admin',\n  createdAt: new Date('2024-01-15'),\n  lastLogin: new Date('2024-06-20'),\n  preferences: {\n    theme: 'dark',\n    emailNotifications: true\n  }\n};\n\nconst publicProfile = toPublicUser(fullUser);\nconsole.log('Public profile:', publicProfile);\n\n// Test update input type\nconst updateData: UpdateUserInput = {\n  name: 'Alice Smith',\n  preferences: { theme: 'light', emailNotifications: false }\n};\nconsole.log('Update data:', updateData);",
              "solution": "// 1. Full User interface with all fields\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  passwordHash: string;\n  role: 'admin' | 'user' | 'guest';\n  createdAt: Date;\n  lastLogin: Date | null;\n  preferences: {\n    theme: 'light' | 'dark';\n    emailNotifications: boolean;\n  };\n}\n\n// 2. PublicUser - only safe fields for public API\n// Use Pick to select: id, name, role\ntype PublicUser = Pick<User, 'id' | 'name' | 'role'>;\n\n// 3. UpdateUserInput - fields that can be updated\n// Use Partial + Omit: can't update id, passwordHash, createdAt\ntype UpdateUserInput = Partial<Omit<User, 'id' | 'passwordHash' | 'createdAt'>>;\n\n// 4. AdminUserView - everything except passwordHash\n// Use Omit to exclude passwordHash\ntype AdminUserView = Omit<User, 'passwordHash'>;\n\n// 5. Transform function\nfunction toPublicUser(user: User): PublicUser {\n  return {\n    id: user.id,\n    name: user.name,\n    role: user.role\n  };\n}\n\n// 6. Test with sample data\nconst fullUser: User = {\n  id: 1,\n  name: 'Alice Johnson',\n  email: 'alice@company.com',\n  passwordHash: 'hashed_password_12345',\n  role: 'admin',\n  createdAt: new Date('2024-01-15'),\n  lastLogin: new Date('2024-06-20'),\n  preferences: {\n    theme: 'dark',\n    emailNotifications: true\n  }\n};\n\nconst publicProfile = toPublicUser(fullUser);\nconsole.log('Public profile:', publicProfile);\n// Public profile: { id: 1, name: 'Alice Johnson', role: 'admin' }\n\n// Test update input type\nconst updateData: UpdateUserInput = {\n  name: 'Alice Smith',\n  preferences: { theme: 'light', emailNotifications: false }\n};\nconsole.log('Update data:', updateData);\n// Update data: { name: 'Alice Smith', preferences: { theme: 'light', emailNotifications: false } }",
              "language": "typescript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "PublicUser has only id, name, role",
                  "expectedOutput": "id: 1, name: 'Alice Johnson', role: 'admin'",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "UpdateUserInput allows partial updates",
                  "expectedOutput": "name and preferences updated",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "AdminUserView excludes passwordHash",
                  "expectedOutput": "no passwordHash in admin view",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Pick syntax: Pick<Type, 'prop1' | 'prop2'> creates a type with only those properties"
                },
                {
                  "level": 2,
                  "text": "You can combine utilities: Partial<Omit<User, 'id'>> first removes id, then makes remaining optional"
                },
                {
                  "level": 3,
                  "text": "The order matters: Omit removes properties, Partial makes remaining ones optional"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using Pick when Omit is more efficient",
                  "consequence": "When you want most properties except a few, Omit is cleaner than Pick",
                  "correction": "Use Pick for 'I want only these few', Omit for 'I want all except these few'"
                },
                {
                  "mistake": "Forgetting to combine Partial with Omit for update types",
                  "consequence": "Update inputs require all fields, but updates are usually partial",
                  "correction": "Wrap with Partial: Partial<Omit<User, 'id'>>"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "10.11-challenge-2",
              "title": "Configuration Builder",
              "description": "Use Record, Readonly, and Required to build a type-safe configuration system. Create environment-specific configs, status mappings, and frozen settings that prevent accidental mutations.",
              "instructions": "1. Create Environment type ('development' | 'staging' | 'production')\n2. Create EnvironmentConfig interface with optional properties (apiUrl, debug, logLevel)\n3. Use Record to map each Environment to its EnvironmentConfig\n4. Create a Required version for validated configs\n5. Create a Readonly frozen config type\n6. Implement getConfig function that returns frozen, fully-populated config\n7. Test with all three environments",
              "starterCode": "// 1. Environment type\ntype Environment = 'development' | 'staging' | 'production';\n\n// 2. Environment config with optional properties\ninterface EnvironmentConfig {\n  apiUrl?: string;\n  debug?: boolean;\n  logLevel?: 'error' | 'warn' | 'info' | 'debug';\n  timeout?: number;\n  maxRetries?: number;\n}\n\n// 3. Use Record to map Environment to EnvironmentConfig\ntype EnvironmentConfigs = /* Your code here */;\n\n// 4. Required version - all properties must be set\ntype ValidatedConfig = /* Your code here */;\n\n// 5. Readonly frozen config\ntype FrozenConfig = /* Your code here */;\n\n// Base configs (some properties missing - will use defaults)\nconst configs: EnvironmentConfigs = {\n  development: {\n    apiUrl: 'http://localhost:3000',\n    debug: true,\n    logLevel: 'debug'\n    // timeout and maxRetries will use defaults\n  },\n  staging: {\n    apiUrl: 'https://staging.api.com',\n    debug: true,\n    logLevel: 'info'\n  },\n  production: {\n    apiUrl: 'https://api.production.com',\n    debug: false,\n    logLevel: 'error'\n  }\n};\n\n// Defaults for missing values\nconst defaults: Required<EnvironmentConfig> = {\n  apiUrl: 'http://localhost:3000',\n  debug: false,\n  logLevel: 'info',\n  timeout: 5000,\n  maxRetries: 3\n};\n\n// 6. Get fully populated, frozen config\nfunction getConfig(env: Environment): FrozenConfig {\n  // Merge environment config with defaults\n  // Return as frozen (readonly) config\n}\n\n// 7. Test all environments\nconst devConfig = getConfig('development');\nconsole.log('Dev config:', devConfig);\n\nconst prodConfig = getConfig('production');\nconsole.log('Prod config:', prodConfig);\n\n// This should cause TypeScript error:\n// prodConfig.debug = true;  // Uncomment to test - should error!",
              "solution": "// 1. Environment type\ntype Environment = 'development' | 'staging' | 'production';\n\n// 2. Environment config with optional properties\ninterface EnvironmentConfig {\n  apiUrl?: string;\n  debug?: boolean;\n  logLevel?: 'error' | 'warn' | 'info' | 'debug';\n  timeout?: number;\n  maxRetries?: number;\n}\n\n// 3. Use Record to map Environment to EnvironmentConfig\ntype EnvironmentConfigs = Record<Environment, EnvironmentConfig>;\n\n// 4. Required version - all properties must be set\ntype ValidatedConfig = Required<EnvironmentConfig>;\n\n// 5. Readonly frozen config\ntype FrozenConfig = Readonly<Required<EnvironmentConfig>>;\n\n// Base configs (some properties missing - will use defaults)\nconst configs: EnvironmentConfigs = {\n  development: {\n    apiUrl: 'http://localhost:3000',\n    debug: true,\n    logLevel: 'debug'\n    // timeout and maxRetries will use defaults\n  },\n  staging: {\n    apiUrl: 'https://staging.api.com',\n    debug: true,\n    logLevel: 'info'\n  },\n  production: {\n    apiUrl: 'https://api.production.com',\n    debug: false,\n    logLevel: 'error'\n  }\n};\n\n// Defaults for missing values\nconst defaults: Required<EnvironmentConfig> = {\n  apiUrl: 'http://localhost:3000',\n  debug: false,\n  logLevel: 'info',\n  timeout: 5000,\n  maxRetries: 3\n};\n\n// 6. Get fully populated, frozen config\nfunction getConfig(env: Environment): FrozenConfig {\n  const envConfig = configs[env];\n  \n  // Merge defaults with environment config\n  const merged: ValidatedConfig = {\n    apiUrl: envConfig.apiUrl ?? defaults.apiUrl,\n    debug: envConfig.debug ?? defaults.debug,\n    logLevel: envConfig.logLevel ?? defaults.logLevel,\n    timeout: envConfig.timeout ?? defaults.timeout,\n    maxRetries: envConfig.maxRetries ?? defaults.maxRetries\n  };\n  \n  // Return as frozen - caller cannot modify\n  return merged;\n}\n\n// 7. Test all environments\nconst devConfig = getConfig('development');\nconsole.log('Dev config:', devConfig);\n// Dev config: { apiUrl: 'http://localhost:3000', debug: true, logLevel: 'debug', timeout: 5000, maxRetries: 3 }\n\nconst prodConfig = getConfig('production');\nconsole.log('Prod config:', prodConfig);\n// Prod config: { apiUrl: 'https://api.production.com', debug: false, logLevel: 'error', timeout: 5000, maxRetries: 3 }\n\n// This causes TypeScript error:\n// prodConfig.debug = true;  // ERROR: Cannot assign to 'debug' because it is a read-only property",
              "language": "typescript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Record type covers all environments",
                  "expectedOutput": "development, staging, production all defined",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Missing properties filled with defaults",
                  "expectedOutput": "timeout: 5000, maxRetries: 3",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Returned config is readonly",
                  "expectedOutput": "assignment to readonly property fails",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Record<Environment, EnvironmentConfig> ensures every environment has a config entry"
                },
                {
                  "level": 2,
                  "text": "Use nullish coalescing (??) to fill missing values: envConfig.timeout ?? defaults.timeout"
                },
                {
                  "level": 3,
                  "text": "Readonly<Required<T>> first makes all properties required, then makes them readonly"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using || instead of ?? for defaults",
                  "consequence": "false and 0 are falsy, so debug: false would be replaced with default",
                  "correction": "Use ?? which only falls back for null/undefined"
                },
                {
                  "mistake": "Applying Readonly before Required",
                  "consequence": "Both work, but Readonly<Required<T>> is more common pattern",
                  "correction": "Order doesn't matter here, but Required first is conventional"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "10.11-challenge-3",
              "title": "Function Type Extraction",
              "description": "Use ReturnType, Parameters, and Awaited to work with external functions whose types you don't control. Create wrapper functions that preserve type information and build a type-safe cache around async operations.",
              "instructions": "1. Given three 'external' async functions (fetchUser, fetchPosts, fetchComments)\n2. Extract the return types using ReturnType and Awaited\n3. Create a CacheEntry type that stores the resolved data\n4. Create a cached wrapper function using Parameters to preserve signatures\n5. Implement a type-safe cache that knows what each function returns\n6. Test caching and retrieval",
              "starterCode": "// External functions (imagine these come from a library)\nasync function fetchUser(id: number) {\n  console.log(`Fetching user ${id}...`);\n  return { id, name: 'Alice', email: 'alice@test.com' };\n}\n\nasync function fetchPosts(userId: number, limit: number) {\n  console.log(`Fetching ${limit} posts for user ${userId}...`);\n  return [\n    { id: 1, title: 'First Post', authorId: userId },\n    { id: 2, title: 'Second Post', authorId: userId }\n  ].slice(0, limit);\n}\n\nasync function fetchComments(postId: number) {\n  console.log(`Fetching comments for post ${postId}...`);\n  return [\n    { id: 1, postId, text: 'Great post!' },\n    { id: 2, postId, text: 'Thanks for sharing' }\n  ];\n}\n\n// 2. Extract types from the functions\ntype User = /* Use Awaited<ReturnType<...>> */;\ntype Post = /* Get single post type from array */;\ntype Comment = /* Get single comment type from array */;\n\n// 3. Cache entry stores data with timestamp\ninterface CacheEntry<T> {\n  data: T;\n  cachedAt: number;\n  ttlMs: number;\n}\n\n// 4. Create a generic cached version of any async function\nfunction createCached<T extends (...args: any[]) => Promise<any>>(\n  fn: T,\n  keyGenerator: (...args: Parameters<T>) => string,\n  ttlMs: number = 60000\n): /* What should return type be? */ {\n  const cache = new Map<string, CacheEntry<Awaited<ReturnType<T>>>>();\n  \n  return async (...args: Parameters<T>): Promise<Awaited<ReturnType<T>>> => {\n    const key = keyGenerator(...args);\n    const cached = cache.get(key);\n    \n    // Check if valid cache entry exists\n    // If not, call original function and cache result\n    // Return the data\n  };\n}\n\n// 5. Create cached versions\nconst cachedFetchUser = createCached(\n  fetchUser,\n  (id) => `user:${id}`,\n  30000\n);\n\nconst cachedFetchPosts = createCached(\n  fetchPosts,\n  (userId, limit) => `posts:${userId}:${limit}`,\n  30000\n);\n\n// 6. Test the cache\nasync function testCache() {\n  // First call - should fetch\n  const user1 = await cachedFetchUser(1);\n  console.log('User:', user1);\n  \n  // Second call - should use cache\n  const user2 = await cachedFetchUser(1);\n  console.log('User (cached):', user2);\n  \n  // Different ID - should fetch\n  const user3 = await cachedFetchUser(2);\n  console.log('User 2:', user3);\n  \n  // Posts test\n  const posts = await cachedFetchPosts(1, 2);\n  console.log('Posts:', posts);\n}\n\ntestCache();",
              "solution": "// External functions (imagine these come from a library)\nasync function fetchUser(id: number) {\n  console.log(`Fetching user ${id}...`);\n  return { id, name: 'Alice', email: 'alice@test.com' };\n}\n\nasync function fetchPosts(userId: number, limit: number) {\n  console.log(`Fetching ${limit} posts for user ${userId}...`);\n  return [\n    { id: 1, title: 'First Post', authorId: userId },\n    { id: 2, title: 'Second Post', authorId: userId }\n  ].slice(0, limit);\n}\n\nasync function fetchComments(postId: number) {\n  console.log(`Fetching comments for post ${postId}...`);\n  return [\n    { id: 1, postId, text: 'Great post!' },\n    { id: 2, postId, text: 'Thanks for sharing' }\n  ];\n}\n\n// 2. Extract types from the functions\ntype User = Awaited<ReturnType<typeof fetchUser>>;\ntype Post = Awaited<ReturnType<typeof fetchPosts>>[number];\ntype Comment = Awaited<ReturnType<typeof fetchComments>>[number];\n\n// 3. Cache entry stores data with timestamp\ninterface CacheEntry<T> {\n  data: T;\n  cachedAt: number;\n  ttlMs: number;\n}\n\n// 4. Create a generic cached version of any async function\nfunction createCached<T extends (...args: any[]) => Promise<any>>(\n  fn: T,\n  keyGenerator: (...args: Parameters<T>) => string,\n  ttlMs: number = 60000\n): (...args: Parameters<T>) => Promise<Awaited<ReturnType<T>>> {\n  const cache = new Map<string, CacheEntry<Awaited<ReturnType<T>>>>();\n  \n  return async (...args: Parameters<T>): Promise<Awaited<ReturnType<T>>> => {\n    const key = keyGenerator(...args);\n    const cached = cache.get(key);\n    \n    // Check if valid cache entry exists\n    if (cached && Date.now() - cached.cachedAt < cached.ttlMs) {\n      console.log(`Cache hit for ${key}`);\n      return cached.data;\n    }\n    \n    // Call original function and cache result\n    const result = await fn(...args);\n    cache.set(key, {\n      data: result,\n      cachedAt: Date.now(),\n      ttlMs\n    });\n    \n    return result;\n  };\n}\n\n// 5. Create cached versions\nconst cachedFetchUser = createCached(\n  fetchUser,\n  (id) => `user:${id}`,\n  30000\n);\n\nconst cachedFetchPosts = createCached(\n  fetchPosts,\n  (userId, limit) => `posts:${userId}:${limit}`,\n  30000\n);\n\n// 6. Test the cache\nasync function testCache() {\n  // First call - should fetch\n  const user1 = await cachedFetchUser(1);\n  console.log('User:', user1);\n  // Fetching user 1...\n  // User: { id: 1, name: 'Alice', email: 'alice@test.com' }\n  \n  // Second call - should use cache\n  const user2 = await cachedFetchUser(1);\n  console.log('User (cached):', user2);\n  // Cache hit for user:1\n  // User (cached): { id: 1, name: 'Alice', email: 'alice@test.com' }\n  \n  // Different ID - should fetch\n  const user3 = await cachedFetchUser(2);\n  console.log('User 2:', user3);\n  // Fetching user 2...\n  // User 2: { id: 2, name: 'Alice', email: 'alice@test.com' }\n  \n  // Posts test\n  const posts = await cachedFetchPosts(1, 2);\n  console.log('Posts:', posts);\n  // Fetching 2 posts for user 1...\n  // Posts: [{ id: 1, title: 'First Post', authorId: 1 }, { id: 2, title: 'Second Post', authorId: 1 }]\n}\n\ntestCache();",
              "language": "typescript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "User type correctly extracted",
                  "expectedOutput": "User has id, name, email properties",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Cache returns stored data on second call",
                  "expectedOutput": "Cache hit for user:1",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Cached function preserves parameter types",
                  "expectedOutput": "cachedFetchPosts(1, 2) compiles correctly",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "To get array element type, use ArrayType[number] - e.g., Post[] becomes Post via Posts[number]"
                },
                {
                  "level": 2,
                  "text": "The return type of createCached is a function with same params but Promise of unwrapped return"
                },
                {
                  "level": 3,
                  "text": "Use Date.now() - cached.cachedAt < cached.ttlMs to check if cache is still valid"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting Awaited when extracting async return types",
                  "consequence": "You get Promise<User> instead of User",
                  "correction": "Always wrap with Awaited: Awaited<ReturnType<typeof fn>>"
                },
                {
                  "mistake": "Not using [number] to get array element type",
                  "consequence": "Post[] is the full array type, not a single Post",
                  "correction": "Use Type[number] to extract element type from arrays"
                }
              ],
              "difficulty": "advanced"
            }
          ]
        }
      ]
    },
    {
      "id": "module-11",
      "title": "Module 11: Building for the Server with Bun & Hono",
      "description": "Learn to build server-side applications with Bun and Hono, the modern high-performance stack for 2025",
      "difficulty": "intermediate",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "11.1",
          "title": "What Is Bun? (The Supercharged Kitchen Analogy)",
          "moduleId": "module-11",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine the difference between a food truck and a supercharged restaurant kitchen:\n\nFood Truck (Browser JavaScript):\n- Serves food directly to customers on the street\n- Limited space and equipment\n- Can't do heavy-duty cooking\n- Works in one location at a time\n\nSupercharged Kitchen (Bun):\n- Behind the scenes, ULTRA-FAST equipment\n- Can handle many orders simultaneously at blazing speed\n- Access to storage, databases, file systems\n- Built-in tools: no need to buy separate appliances!\n- TypeScript menu cards work without translation\n- Sends finished dishes out to customers\n\nBun is like Node.js, but reimagined for 2025. It's a JavaScript runtime that runs your code OUTSIDE the browser, but it's significantly faster and comes with batteries included: built-in TypeScript support, a package manager, bundler, and test runner. No extra tools needed!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Bun - The All-in-One JavaScript Runtime (2025)\n\n// KEY ADVANTAGES OF BUN\n// 1. SPEED - Up to 4x faster than Node.js\n// 2. TypeScript works out of the box (no compilation!)\n// 3. Built-in package manager (bun install)\n// 4. Built-in bundler (bun build)\n// 5. Built-in test runner (bun test)\n\n// BUILT-IN APIs - Bun comes with powerful tools\n// (Note: These won't work in browser JavaScript!)\n\n// 1. FILE SYSTEM - Read and write files (simulated for demo)\nlet simulatedFileContent = 'Hello from Bun!';\nconsole.log('File content:', simulatedFileContent);\n\n// In real Bun, file operations are super simple:\n// const file = Bun.file('data.txt');\n// const content = await file.text();\n// console.log(content);\n\n// 2. PATH - Handle file paths\nfunction joinPath(...parts) {\n  return parts.join('/');\n}\n\nlet filePath = joinPath('users', 'documents', 'notes.txt');\nconsole.log('File path:', filePath);\n\n// 3. HTTP SERVER - Built-in with Bun.serve()\n// In real Bun:\n// Bun.serve({\n//   port: 3000,\n//   fetch(request) {\n//     return new Response('Hello from Bun!');\n//   }\n// });\n\nconsole.log('Bun can create web servers with Bun.serve()!');\n\n// 4. RUNTIME INFO\nlet bunVersion = '1.2.0'; // Bun version\nlet platform = 'linux'; // Could be 'win32', 'darwin' (macOS), etc.\n\nconsole.log('Bun version:', bunVersion);\nconsole.log('Platform:', platform);\n\n// 5. NATIVE TYPESCRIPT SUPPORT\n// In Bun, you can run .ts files directly!\n// bun run app.ts   <- No compilation needed!\n// interface User { name: string; age: number; }\n// const user: User = { name: 'Alice', age: 30 };\n\nconsole.log('Bun runs TypeScript natively!');\n\n// 6. ASYNC OPERATIONS - Same as Node.js\nfunction simulateFileRead(filename) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`Contents of ${filename}`);\n    }, 100);\n  });\n}\n\nsimulateFileRead('data.txt').then(data => {\n  console.log('File data:', data);\n});\n\n// 7. NPM COMPATIBILITY - Use any npm package!\n// Bun is compatible with npm packages\n// bun install express  <- Works!\n// bun install hono     <- Even better!\n\nconsole.log('Bun works with npm packages!');\n\n// 8. ES MODULES - Modern imports by default\n// import { Hono } from 'hono';\n// import express from 'express';\n\n// 9. BUN-SPECIFIC FEATURES\nlet bunFeatures = [\n  'Native TypeScript/JSX support',\n  'Fastest JavaScript runtime',\n  'Built-in SQLite database',\n  'Built-in password hashing',\n  'Built-in HTML rewriter',\n  'Web-standard APIs (fetch, Response, Request)'\n];\n\nconsole.log('\\nBun-specific features:');\nbunFeatures.forEach(f => console.log('  -', f));\n\n// 10. RUNNING BUN CODE\n// Save file as app.ts or app.js\n// Run with: bun run app.ts\n// Or simply: bun app.ts\n\nconsole.log('\\nRun Bun code with: bun run app.ts');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding Bun fundamentals:\n\n1. **What Makes Bun Special**:\n   - Written in Zig for maximum performance\n   - Up to 4x faster than Node.js\n   - Built-in TypeScript support (no tsconfig needed!)\n   - Same code runs on Bun, Node, Deno, and Edge\n   - Drop-in replacement for Node.js in most cases\n\n2. **Built-in Tools**:\n   - `bun install`: Package manager (faster than npm)\n   - `bun run`: Script runner (runs .ts files directly!)\n   - `bun test`: Test runner (Jest-compatible)\n   - `bun build`: Bundler for production\n\n3. **Bun APIs**:\n   - `Bun.file()`: Read/write files\n   - `Bun.serve()`: Create HTTP servers\n   - `Bun.password`: Hash passwords\n   - `Bun.sql()`: SQLite database\n   - Standard Web APIs: `fetch`, `Response`, `Request`\n\n4. **TypeScript Just Works**:\n   ```typescript\n   // app.ts - Run directly with: bun app.ts\n   interface User {\n     name: string;\n     email: string;\n   }\n   \n   const user: User = {\n     name: 'Alice',\n     email: 'alice@example.com'\n   };\n   \n   console.log(user.name); // No compilation step!\n   ```\n\n5. **File Operations**:\n   ```javascript\n   // Reading files in Bun\n   const file = Bun.file('config.json');\n   const content = await file.text();  // or .json()\n   \n   // Writing files\n   await Bun.write('output.txt', 'Hello World!');\n   ```\n\n6. **Creating Servers**:\n   ```javascript\n   Bun.serve({\n     port: 3000,\n     fetch(request) {\n       return new Response('Hello from Bun!');\n     }\n   });\n   ```\n\n7. **Running Bun Code**:\n   - Save file as `app.ts` or `app.js`\n   - Run with: `bun run app.ts`\n   - Or simply: `bun app.ts`\n   - No browser needed, no compilation needed!"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Node.js Equivalent",
              "legacy": "nodejs",
              "content": "If you've used Node.js before, here's how Bun compares:\n\n**Node.js** requires separate tools:\n- `npm` or `yarn` for packages\n- `tsc` for TypeScript compilation\n- `jest` or `vitest` for testing\n- `webpack` or `esbuild` for bundling\n\n**Bun** has everything built-in!\n\nThe code patterns are similar, but Bun is faster and simpler.",
              "code": "// Node.js way (requires setup):\n// 1. npm init\n// 2. npm install typescript ts-node\n// 3. Create tsconfig.json\n// 4. npx ts-node app.ts\n\n// Node.js file reading:\nconst fs = require('fs');\nfs.readFile('data.txt', 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n\n// Node.js HTTP server:\nconst http = require('http');\nconst server = http.createServer((req, res) => {\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('Hello from Node.js!');\n});\nserver.listen(3000);",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Bun beginner mistakes:\n\n1. **Trying to use browser APIs**:\n   ```javascript\n   // ERROR in Bun - no DOM!\n   document.getElementById('app'); // ReferenceError: document is not defined\n   window.location.href;           // ReferenceError: window is not defined\n   ```\n   Solution: Bun is for servers, not browsers\n\n2. **Forgetting Bun uses Web APIs**:\n   ```javascript\n   // Bun uses standard Web APIs\n   // Use fetch() instead of axios for HTTP requests\n   const response = await fetch('https://api.example.com/data');\n   const data = await response.json();\n   ```\n\n3. **Using Node.js-specific patterns unnecessarily**:\n   ```javascript\n   // Old Node.js way (still works but not needed)\n   import { fileURLToPath } from 'url';\n   import { dirname } from 'path';\n   const __filename = fileURLToPath(import.meta.url);\n   const __dirname = dirname(__filename);\n   \n   // Bun way - import.meta has more built-in!\n   console.log(import.meta.dir);  // Current directory\n   console.log(import.meta.file); // Current filename\n   ```\n\n4. **Not leveraging Bun.file()**:\n   ```javascript\n   // Instead of fs.readFile callbacks:\n   const file = Bun.file('data.txt');\n   const text = await file.text();  // Simple!\n   ```\n\n5. **Installing TypeScript separately**:\n   - Bun runs .ts files directly!\n   - No need for `npm install typescript`\n   - No need for tsconfig.json (unless you want custom settings)\n\n6. **Using npm when bun is faster**:\n   - Use `bun install` instead of `npm install`\n   - Use `bun add package` instead of `npm install package`\n   - Up to 25x faster package installation!\n\n7. **Assuming all Node.js APIs work**:\n   - Most do, but some edge cases differ\n   - Check Bun docs for compatibility\n   - When in doubt, use Web Standard APIs"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.1-challenge",
              "title": "Practice Challenge",
              "description": "Create a simple Bun utility module:\n\n1. Create a function `getSystemInfo()` that returns an object with:\n   - `runtime`: 'bun'\n   - `bunVersion`: '1.2.0'\n   - `uptime`: any number (simulate uptime)\n\n2. Create a function `readConfig(filename)` that:\n   - Takes a filename as a parameter\n   - Returns a Promise that resolves with simulated file content\n   - Use setTimeout to simulate async file reading\n\n3. Test both functions and log the results",
              "instructions": "Create a simple Bun utility module:\n\n1. Create a function `getSystemInfo()` that returns an object with:\n   - `runtime`: 'bun'\n   - `bunVersion`: '1.2.0'\n   - `uptime`: any number (simulate uptime)\n\n2. Create a function `readConfig(filename)` that:\n   - Takes a filename as a parameter\n   - Returns a Promise that resolves with simulated file content\n   - Use setTimeout to simulate async file reading\n\n3. Test both functions and log the results",
              "starterCode": "// System info function (simulating Bun environment)\nfunction getSystemInfo() {\n  return {\n    runtime: 'bun',\n    bunVersion: '1.2.0',\n    uptime: 12345\n  };\n}\n\n// Async file reading simulation\n// In real Bun: const file = Bun.file(filename); return file.text();\nfunction readConfig(filename) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(`Config from ${filename}`);\n    }, 100);\n  });\n}\n\n// Test the functions\nlet info = getSystemInfo();\nconsole.log('System:', info);\n\nreadConfig('app.config').then(data => {\n  console.log('Config:', data);\n});",
              "solution": "// Complete Bun utility module\n\n// System info function (simulating Bun environment)\nfunction getSystemInfo() {\n  return {\n    runtime: 'bun',\n    bunVersion: '1.2.0',\n    uptime: 12345,\n    features: ['typescript', 'bundler', 'test-runner']\n  };\n}\n\n// Async file reading simulation\n// In real Bun: const file = Bun.file(filename); return file.text();\nfunction readConfig(filename) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (!filename) {\n        reject(new Error('Filename is required'));\n      } else {\n        resolve(`Config from ${filename}`);\n      }\n    }, 100);\n  });\n}\n\n// Test the functions\nlet info = getSystemInfo();\nconsole.log('System info:', info);\nconsole.log('Runtime:', info.runtime);       // bun\nconsole.log('Bun version:', info.bunVersion); // 1.2.0\n\n// Test async config reading\nreadConfig('app.config').then(data => {\n  console.log('Config loaded:', data); // Config from app.config\n}).catch(error => {\n  console.log('Error:', error.message);\n});\n\n// Using async/await (modern pattern)\nasync function loadSystemConfig() {\n  try {\n    let config = await readConfig('database.config');\n    console.log('Database config:', config);\n  } catch (error) {\n    console.log('Failed to load config:', error.message);\n  }\n}\n\nloadSystemConfig();",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should return system info with bun runtime",
                  "expectedOutput": "bun",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should read config asynchronously",
                  "expectedOutput": "Config from test.config",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use new Promise((resolve, reject) => {...}) and setTimeout to simulate async operations."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using Node.js-specific APIs when Bun has simpler alternatives",
                  "consequence": "Code works but misses Bun's simpler patterns.",
                  "correction": "Use Bun.file() for file reading instead of fs.readFile(). Use import.meta.dir instead of __dirname workarounds."
                },
                {
                  "mistake": "Trying to use browser APIs in Bun",
                  "consequence": "ReferenceError: document/window is not defined",
                  "correction": "Bun runs on the server. Use server-side APIs like Bun.file(), Bun.serve(), and fetch()."
                },
                {
                  "mistake": "Installing TypeScript separately",
                  "consequence": "Unnecessary dependency and complexity.",
                  "correction": "Bun runs .ts files directly! Just use: bun run app.ts"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "11.2",
          "title": "Your First Hono Server (The Super-Efficient Manager Analogy)",
          "moduleId": "module-11",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine running a restaurant:\n\nWithout a manager (plain Bun.serve()):\n- You handle every customer request manually\n- You write the same instructions over and over\n- You manage reservations, orders, payments all yourself\n- Lots of repetitive work\n\nWith a super-efficient manager (Hono framework):\n- The manager handles common tasks LIGHTNING FAST\n- Organized system for taking orders (routes)\n- Standardized way to serve dishes (responses)\n- Easy to add new menu items (endpoints)\n- Works anywhere: kitchen, food truck, catering (multi-platform!)\n- Less work, more organized, and portable!\n\nHono is like an ultra-efficient, portable restaurant manager. It works with Bun, Node.js, Deno, and even in the cloud (Cloudflare Workers). It's the modern choice for building APIs in 2025!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Hono - The Ultra-Fast Web Framework (2025)\n// Note: This is simulated Hono code for learning\n\n// BASIC HONO SERVER STRUCTURE\n\n// In real Bun:\n// import { Hono } from 'hono';\n// const app = new Hono();\n\n// For this demo, we'll simulate Hono behavior:\nclass HonoApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n    console.log(`Route registered: GET ${path}`);\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n    console.log(`Route registered: POST ${path}`);\n  }\n  \n  simulateRequest(method, path, body = null) {\n    let route = this.routes.find(r => r.method === method && r.path === path);\n    if (route) {\n      // Hono uses a Context object (c) instead of req/res\n      let c = {\n        req: {\n          method,\n          path,\n          query: (key) => null,\n          param: (key) => null,\n          json: async () => body || {}\n        },\n        text: function(data, status = 200) {\n          console.log(`Response [${status}]:`, data);\n          return { status, body: data };\n        },\n        json: function(data, status = 200) {\n          console.log(`Response [${status}]:`, JSON.stringify(data));\n          return { status, body: data };\n        }\n      };\n      route.handler(c);\n    } else {\n      console.log(`404 Not Found: ${method} ${path}`);\n    }\n  }\n}\n\nlet app = new HonoApp();\n\n// ROUTE DEFINITIONS - Notice the simpler 'c' context pattern!\n\n// 1. Simple GET route - Homepage\napp.get('/', (c) => {\n  return c.text('Welcome to Hono!');\n});\n\n// 2. GET route returning JSON\napp.get('/api/status', (c) => {\n  return c.json({\n    status: 'online',\n    version: '1.0.0',\n    framework: 'Hono',\n    timestamp: Date.now()\n  });\n});\n\n// 3. GET route - List of users\napp.get('/api/users', (c) => {\n  let users = [\n    { id: 1, name: 'Alice', email: 'alice@example.com' },\n    { id: 2, name: 'Bob', email: 'bob@example.com' }\n  ];\n  return c.json(users);\n});\n\n// 4. POST route - Create new user\napp.post('/api/users', async (c) => {\n  // In real Hono: const body = await c.req.json();\n  let newUser = { id: 3, name: 'Charlie', email: 'charlie@example.com' };\n  \n  return c.json({\n    message: 'User created successfully',\n    user: newUser\n  }, 201);  // Status code as second argument!\n});\n\n// 5. Error response\napp.get('/api/error', (c) => {\n  return c.json({\n    error: 'Something went wrong!',\n    message: 'Internal server error'\n  }, 500);\n});\n\n// In real Bun, export the app:\n// export default app;\n// Then run: bun run app.ts\n\nconsole.log('\\nHono server routes registered!');\nconsole.log('In real Bun, export default app and run with: bun run app.ts');\n\n// SIMULATE REQUESTS\nconsole.log('\\n--- Simulating HTTP Requests ---\\n');\n\napp.simulateRequest('GET', '/');\napp.simulateRequest('GET', '/api/status');\napp.simulateRequest('GET', '/api/users');\napp.simulateRequest('POST', '/api/users');\napp.simulateRequest('GET', '/api/error');\napp.simulateRequest('GET', '/api/notfound');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding Hono fundamentals:\n\n1. **Creating a Hono App**:\n   ```javascript\n   import { Hono } from 'hono';\n   const app = new Hono();\n   ```\n   - `new Hono()` creates a new application\n   - `app` is your main server object\n\n2. **Route Methods** (HTTP verbs):\n   - `app.get()` - Read data\n   - `app.post()` - Create data\n   - `app.put()` - Update data (replace)\n   - `app.patch()` - Update data (partial)\n   - `app.delete()` - Delete data\n\n3. **The Context Object (c)**:\n   Unlike Express with separate req/res, Hono uses ONE context object:\n   ```javascript\n   app.get('/hello', (c) => {\n     // c has everything!\n     return c.text('Hello!');\n   });\n   ```\n\n4. **Accessing Request Data**:\n   - `c.req.param('id')` - URL parameters (`/users/:id`)\n   - `c.req.query('search')` - Query strings (`?search=hello`)\n   - `await c.req.json()` - POST/PUT body (async!)\n   - `c.req.header('Authorization')` - HTTP headers\n\n5. **Response Helpers**:\n   - `c.text('Hello')` - Send text\n   - `c.json({ data })` - Send JSON\n   - `c.json(data, 201)` - JSON with status code\n   - `c.html('<h1>Hi</h1>')` - Send HTML\n   - `c.redirect('/other')` - Redirect\n\n6. **Status Codes**:\n   - Pass as second argument: `c.json(data, 201)`\n   - 200: OK (success)\n   - 201: Created (new resource)\n   - 400: Bad Request (client error)\n   - 404: Not Found\n   - 500: Internal Server Error\n\n7. **Running the Server (Bun)**:\n   ```javascript\n   // app.ts\n   import { Hono } from 'hono';\n   const app = new Hono();\n   \n   app.get('/', (c) => c.text('Hello!'));\n   \n   export default app;  // Bun auto-serves!\n   ```\n   Run with: `bun run app.ts`"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Node.js/Express Equivalent",
              "legacy": "express",
              "content": "Hono and Express are similar, but Hono is simpler and more modern. The main difference is Hono's unified context object (c) vs Express's separate req/res.",
              "code": "// Express way (Node.js)\nimport express from 'express';\nconst app = express();\n\napp.use(express.json()); // Need middleware for JSON!\n\n// Two separate objects: req and res\napp.get('/api/users', (req, res) => {\n  res.json([{ id: 1, name: 'Alice' }]);\n});\n\napp.post('/api/users', (req, res) => {\n  const body = req.body;  // Already parsed\n  res.status(201).json({ message: 'Created', user: body });\n});\n\napp.listen(3000, () => {\n  console.log('Server on port 3000');\n});\n\n// vs Hono way (cleaner!)\n// import { Hono } from 'hono';\n// const app = new Hono();\n// \n// app.get('/api/users', (c) => c.json([...]));\n// app.post('/api/users', async (c) => {\n//   const body = await c.req.json();\n//   return c.json({ message: 'Created' }, 201);\n// });\n// \n// export default app;  // That's it!",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Hono mistakes:\n\n1. **Forgetting to return the response**:\n   ```javascript\n   app.get('/api/users', (c) => {\n     c.json({ data: 'hello' });  // Missing return!\n   });\n   \n   // Correct:\n   app.get('/api/users', (c) => {\n     return c.json({ data: 'hello' });  // Always return!\n   });\n   ```\n\n2. **Forgetting async for body parsing**:\n   ```javascript\n   // Wrong - req.json() is async!\n   app.post('/api/users', (c) => {\n     const body = c.req.json();  // This is a Promise!\n   });\n   \n   // Correct:\n   app.post('/api/users', async (c) => {\n     const body = await c.req.json();  // Await it!\n   });\n   ```\n\n3. **Using Express patterns by mistake**:\n   ```javascript\n   // Express style (won't work in Hono!):\n   app.get('/users', (req, res) => {\n     res.json({ data });\n   });\n   \n   // Hono style:\n   app.get('/users', (c) => {\n     return c.json({ data });\n   });\n   ```\n\n4. **Route order still matters**:\n   ```javascript\n   app.get('/api/users/active', ...);  // Specific first\n   app.get('/api/users/:id', ...);     // Generic after\n   ```\n\n5. **Not exporting for Bun**:\n   ```javascript\n   // For Bun to serve your app:\n   export default app;  // Don't forget this!\n   \n   // Or with custom port:\n   export default {\n     port: 3000,\n     fetch: app.fetch\n   };\n   ```\n\n6. **Status code position**:\n   ```javascript\n   // Hono: status is SECOND argument\n   return c.json({ error: 'Not found' }, 404);\n   \n   // NOT like Express: res.status(404).json(...)\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.2-challenge",
              "title": "Practice Challenge",
              "description": "Create a simple API for a todo list using Hono patterns:\n\n1. Create a GET route `/api/todos` that returns an array of todo objects\n   - Each todo should have: id, task, completed\n   - Use c.json() to return the data\n\n2. Create a POST route `/api/todos` that:\n   - Simulates creating a new todo\n   - Returns status 201 and the new todo using c.json(data, 201)\n\n3. Create a GET route `/api/todos/completed` that:\n   - Returns only completed todos\n\nUse the HonoApp class from the example. Simulate requests to test your routes.",
              "instructions": "Create a simple API for a todo list using Hono patterns:\n\n1. Create a GET route `/api/todos` that returns an array of todo objects\n   - Each todo should have: id, task, completed\n   - Use c.json() to return the data\n\n2. Create a POST route `/api/todos` that:\n   - Simulates creating a new todo\n   - Returns status 201 and the new todo using c.json(data, 201)\n\n3. Create a GET route `/api/todos/completed` that:\n   - Returns only completed todos\n\nUse the HonoApp class from the example. Simulate requests to test your routes.",
              "starterCode": "// Hono app simulation\nclass HonoApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n  }\n  \n  simulateRequest(method, path) {\n    let route = this.routes.find(r => r.method === method && r.path === path);\n    if (route) {\n      let c = {\n        req: { method, path },\n        json: function(data, status = 200) {\n          console.log(`[${status}]`, JSON.stringify(data));\n          return { status, body: data };\n        }\n      };\n      route.handler(c);\n    }\n  }\n}\n\nlet app = new HonoApp();\n\n// Sample todo data\nlet todos = [\n  { id: 1, task: 'Learn Hono', completed: false },\n  { id: 2, task: 'Build an API', completed: true }\n];\n\n// TODO: Add your routes here using the Hono pattern\n// Remember: (c) => { return c.json(data); }\n\n// Test your routes\napp.simulateRequest('GET', '/api/todos');\napp.simulateRequest('POST', '/api/todos');\napp.simulateRequest('GET', '/api/todos/completed');",
              "solution": "// Hono app simulation\nclass HonoApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n  }\n  \n  simulateRequest(method, path) {\n    let route = this.routes.find(r => r.method === method && r.path === path);\n    if (route) {\n      let c = {\n        req: { method, path },\n        json: function(data, status = 200) {\n          console.log(`[${status}]`, JSON.stringify(data));\n          return { status, body: data };\n        }\n      };\n      route.handler(c);\n    }\n  }\n}\n\nlet app = new HonoApp();\n\n// Sample todo data\nlet todos = [\n  { id: 1, task: 'Learn Hono', completed: false },\n  { id: 2, task: 'Build an API', completed: true },\n  { id: 3, task: 'Deploy app', completed: true }\n];\n\n// Route 1: Get all todos (Hono pattern)\napp.get('/api/todos', (c) => {\n  return c.json(todos);\n});\n\n// Route 2: Create new todo (with 201 status)\napp.post('/api/todos', (c) => {\n  let newTodo = {\n    id: todos.length + 1,\n    task: 'New task',\n    completed: false\n  };\n  todos.push(newTodo);\n  \n  return c.json({\n    message: 'Todo created',\n    todo: newTodo\n  }, 201);  // Status as second argument!\n});\n\n// Route 3: Get completed todos only\napp.get('/api/todos/completed', (c) => {\n  let completedTodos = todos.filter(t => t.completed);\n  return c.json(completedTodos);\n});\n\n// Test the routes\nconsole.log('All todos:');\napp.simulateRequest('GET', '/api/todos');\n\nconsole.log('\\nCreate todo:');\napp.simulateRequest('POST', '/api/todos');\n\nconsole.log('\\nCompleted todos:');\napp.simulateRequest('GET', '/api/todos/completed');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should return all todos using c.json()",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should filter completed todos",
                  "expectedOutput": "1",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "In Hono, use (c) => { return c.json(data); } pattern. For status codes, pass as second argument: c.json(data, 201)"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to return the response in Hono",
                  "consequence": "The route handler returns undefined and no response is sent.",
                  "correction": "Always return c.json(), c.text(), etc. Example: return c.json({ data });"
                },
                {
                  "mistake": "Using Express (req, res) pattern instead of Hono (c) pattern",
                  "consequence": "Code will not work correctly with Hono's context object.",
                  "correction": "Use (c) => { return c.json(data); } instead of (req, res) => { res.json(data); }"
                },
                {
                  "mistake": "Putting status code in wrong place",
                  "consequence": "Status code may not be set correctly.",
                  "correction": "In Hono, status is the second argument: c.json(data, 201)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "11.3",
          "title": "Advanced Routing in Hono (The Address System Analogy)",
          "moduleId": "module-11",
          "order": 3,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine delivering packages in a city:\n\nSimple addresses (static routes):\n- 123 Main Street (exact address)\n- City Hall (exact location)\n- Central Park (exact destination)\n\nDynamic addresses (parameterized routes):\n- \"Apartment {number} on Floor {floor}\" -> Many apartments, one pattern\n- \"House number {X} on {Street Name}\" -> Any house, flexible pattern\n- \"Locker {number} at Gym\" -> Dynamic, but follows a pattern\n\nHono routing works the same way:\n- Static routes: `/about`, `/contact` (exact paths)\n- Dynamic routes: `/users/:id`, `/products/:category/:item` (pattern-based)\n\nParameters let you create one route that handles many similar requests!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Hono - Advanced Routing (2025)\n\n// Simulated Hono with routing features\nclass HonoApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  simulateRequest(method, url) {\n    console.log(`\\n${method} ${url}`);\n    \n    for (let route of this.routes) {\n      if (route.method !== method) continue;\n      \n      let params = this.matchRoute(route.path, url);\n      if (params !== null) {\n        let [path, queryString] = url.split('?');\n        let queryObj = this.parseQuery(queryString);\n        \n        // Hono uses context object (c) with methods\n        let c = {\n          req: {\n            param: (key) => params[key],\n            query: (key) => queryObj[key],\n            url: url\n          },\n          json: function(data, status = 200) {\n            console.log(`Response [${status}]:`, JSON.stringify(data));\n            return { status, body: data };\n          }\n        };\n        \n        route.handler(c);\n        return;\n      }\n    }\n    \n    console.log('404 Not Found');\n  }\n  \n  matchRoute(pattern, url) {\n    let [urlPath] = url.split('?');\n    let patternParts = pattern.split('/');\n    let urlParts = urlPath.split('/');\n    \n    if (patternParts.length !== urlParts.length) return null;\n    \n    let params = {};\n    for (let i = 0; i < patternParts.length; i++) {\n      if (patternParts[i].startsWith(':')) {\n        let paramName = patternParts[i].slice(1);\n        params[paramName] = urlParts[i];\n      } else if (patternParts[i] !== urlParts[i]) {\n        return null;\n      }\n    }\n    return params;\n  }\n  \n  parseQuery(queryString) {\n    if (!queryString) return {};\n    let query = {};\n    queryString.split('&').forEach(pair => {\n      let [key, value] = pair.split('=');\n      query[key] = value;\n    });\n    return query;\n  }\n}\n\nlet app = new HonoApp();\n\n// ROUTE PARAMETERS (Dynamic segments in URL)\n\n// 1. Single parameter - Get user by ID\n// In Hono: use c.req.param('id') to get the parameter\napp.get('/api/users/:id', (c) => {\n  let userId = c.req.param('id');\n  \n  // Simulate database lookup\n  let user = {\n    id: userId,\n    name: 'Alice',\n    email: 'alice@example.com'\n  };\n  \n  return c.json(user);\n});\n\n// 2. Multiple parameters - Get specific product\napp.get('/api/products/:category/:productId', (c) => {\n  let category = c.req.param('category');\n  let productId = c.req.param('productId');\n  \n  return c.json({\n    category: category,\n    productId: productId,\n    name: 'Sample Product',\n    price: 29.99\n  });\n});\n\n// 3. Query parameters - Search and filter\n// In Hono: use c.req.query('key') to get query params\napp.get('/api/search', (c) => {\n  let q = c.req.query('q');\n  let category = c.req.query('category');\n  let minPrice = c.req.query('minPrice');\n  let maxPrice = c.req.query('maxPrice');\n  \n  return c.json({\n    searchTerm: q || 'none',\n    category: category || 'all',\n    priceRange: {\n      min: minPrice || 0,\n      max: maxPrice || 'unlimited'\n    },\n    results: [\n      { id: 1, name: 'Product A' },\n      { id: 2, name: 'Product B' }\n    ]\n  });\n});\n\n// 4. Combining params and query\napp.get('/api/categories/:category/products', (c) => {\n  let category = c.req.param('category');\n  let sort = c.req.query('sort');\n  let limit = c.req.query('limit');\n  \n  return c.json({\n    category: category,\n    sortBy: sort || 'name',\n    limit: limit || 10,\n    products: ['Product 1', 'Product 2']\n  });\n});\n\n// TEST THE ROUTES\n\n// Parameter examples\napp.simulateRequest('GET', '/api/users/42');\napp.simulateRequest('GET', '/api/users/999');\n\napp.simulateRequest('GET', '/api/products/electronics/laptop-123');\napp.simulateRequest('GET', '/api/products/books/novel-456');\n\n// Query parameter examples  \napp.simulateRequest('GET', '/api/search?q=laptop&category=electronics&minPrice=500&maxPrice=2000');\napp.simulateRequest('GET', '/api/search?q=headphones');\n\n// Combined params and query\napp.simulateRequest('GET', '/api/categories/electronics/products?sort=price&limit=20');\napp.simulateRequest('GET', '/api/categories/books/products');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding Hono routing:\n\n1. **Route Parameters** (`:paramName`):\n   ```javascript\n   app.get('/users/:id', (c) => {\n     const id = c.req.param('id');  // Extract from URL\n     return c.json({ id });\n   });\n   ```\n   - Colon `:` marks a parameter\n   - Use `c.req.param('name')` to get the value\n   - `/users/42` -> `c.req.param('id')` returns `'42'`\n\n2. **Multiple Parameters**:\n   ```javascript\n   app.get('/posts/:year/:month/:day', (c) => {\n     const year = c.req.param('year');\n     const month = c.req.param('month');\n     const day = c.req.param('day');\n     return c.json({ year, month, day });\n   });\n   ```\n\n3. **Query Parameters** (after `?`):\n   ```javascript\n   // URL: /search?q=hono&page=2\n   app.get('/search', (c) => {\n     const searchTerm = c.req.query('q');     // 'hono'\n     const page = c.req.query('page');        // '2'\n     return c.json({ searchTerm, page });\n   });\n   ```\n   - Not part of the route pattern\n   - Optional by default\n   - Use `c.req.query('key')` to access\n\n4. **Parameter vs Query - When to Use**:\n   - **Route parameters** (`:id`):\n     * Required parts of the URL\n     * Identifying resources\n     * `/users/:userId/posts/:postId`\n   \n   - **Query parameters** (`?key=value`):\n     * Optional filters\n     * Search terms\n     * Pagination, sorting\n     * `/products?category=books&sort=price&page=2`\n\n5. **Accessing Data in Hono**:\n   - `c.req.param('key')` -> Single URL parameter\n   - `c.req.query('key')` -> Single query parameter\n   - `await c.req.json()` -> POST/PUT body (async!)\n   - `c.req.header('key')` -> Request headers\n\n6. **Type Conversion**:\n   ```javascript\n   app.get('/api/users/:id', (c) => {\n     // c.req.param() always returns STRING\n     const userId = parseInt(c.req.param('id'));\n     const page = parseInt(c.req.query('page')) || 1;\n     return c.json({ userId, page });\n   });\n   ```\n   All parameters come as strings - convert as needed!"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Node.js/Express Equivalent",
              "legacy": "express",
              "content": "Hono uses method calls instead of object properties for accessing parameters. This is slightly different from Express but provides a cleaner API.",
              "code": "// Express way - object properties\napp.get('/users/:id', (req, res) => {\n  const id = req.params.id;         // Object property\n  const search = req.query.search;  // Object property\n  res.json({ id, search });\n});\n\n// Hono way - method calls\napp.get('/users/:id', (c) => {\n  const id = c.req.param('id');     // Method call\n  const search = c.req.query('search'); // Method call\n  return c.json({ id, search });\n});\n\n// Key differences:\n// Express: req.params.id, req.query.search, req.body\n// Hono: c.req.param('id'), c.req.query('search'), await c.req.json()",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Hono routing mistakes:\n\n1. **Using Express object syntax**:\n   ```javascript\n   // Wrong - Express style!\n   app.get('/users/:id', (c) => {\n     const id = c.req.params.id;  // undefined!\n   });\n   \n   // Correct - Hono method style!\n   app.get('/users/:id', (c) => {\n     const id = c.req.param('id');  // Works!\n   });\n   ```\n\n2. **Parameter type confusion**:\n   ```javascript\n   app.get('/users/:id', (c) => {\n     const id = c.req.param('id');\n     if (id > 100) {  // String comparison! '9' > '100' is true!\n       // Wrong!\n     }\n     \n     // Correct:\n     if (parseInt(id) > 100) {\n       // Right!\n     }\n   });\n   ```\n\n3. **Route order conflicts**:\n   ```javascript\n   // Wrong order!\n   app.get('/users/:id', ...);        // Matches EVERYTHING\n   app.get('/users/active', ...);     // Never reached!\n   \n   // Correct order:\n   app.get('/users/active', ...);     // Specific first\n   app.get('/users/:id', ...);        // Generic last\n   ```\n\n4. **Forgetting to return response**:\n   ```javascript\n   app.get('/search', (c) => {\n     const q = c.req.query('q');\n     c.json({ query: q });  // Missing return!\n   });\n   \n   // Correct:\n   app.get('/search', (c) => {\n     const q = c.req.query('q');\n     return c.json({ query: q });  // Always return!\n   });\n   ```\n\n5. **Missing query parameters**:\n   ```javascript\n   app.get('/search', (c) => {\n     const limit = c.req.query('limit');  // undefined if not provided!\n     \n     // Better:\n     const limit = c.req.query('limit') || '10';\n     const limitNum = parseInt(c.req.query('limit')) || 10;\n   });\n   ```"
            },
            {
              "type": "EXAMPLE",
              "title": "Route Groups and Prefixes",
              "content": "Hono provides a powerful way to organize routes using route groups and prefixes. Instead of repeating the same path prefix for every route, you can group related routes together using app.route(). This is essential for building modular, maintainable APIs where different features are organized into separate route files or modules.",
              "language": "javascript",
              "code": "// Hono Route Groups and Prefixes (2025)\n// Organize routes into modular, reusable groups\n\nimport { Hono } from 'hono';\n\n// MAIN APPLICATION\nconst app = new Hono();\n\n// CREATE SEPARATE ROUTE GROUPS\n// Each group is its own mini Hono app!\n\n// Users API group\nconst usersApi = new Hono();\n\nusersApi.get('/', (c) => {\n  // This handles GET /api/users\n  return c.json({ users: ['Alice', 'Bob', 'Charlie'] });\n});\n\nusersApi.get('/:id', (c) => {\n  // This handles GET /api/users/:id\n  const id = c.req.param('id');\n  return c.json({ id, name: 'Alice', email: 'alice@example.com' });\n});\n\nusersApi.post('/', async (c) => {\n  // This handles POST /api/users\n  const body = await c.req.json();\n  return c.json({ message: 'User created', user: body }, 201);\n});\n\n// Products API group\nconst productsApi = new Hono();\n\nproductsApi.get('/', (c) => {\n  // This handles GET /api/products\n  return c.json({ products: ['Laptop', 'Phone', 'Tablet'] });\n});\n\nproductsApi.get('/:id', (c) => {\n  // This handles GET /api/products/:id\n  const id = c.req.param('id');\n  return c.json({ id, name: 'Laptop', price: 999 });\n});\n\n// Admin routes group (can have its own middleware!)\nconst adminApi = new Hono();\n\n// Admin-specific middleware\nadminApi.use('*', async (c, next) => {\n  const isAdmin = c.req.header('X-Admin-Key') === 'secret';\n  if (!isAdmin) {\n    return c.json({ error: 'Admin access required' }, 403);\n  }\n  await next();\n});\n\nadminApi.get('/stats', (c) => {\n  return c.json({ totalUsers: 1000, totalOrders: 5000 });\n});\n\nadminApi.delete('/users/:id', (c) => {\n  const id = c.req.param('id');\n  return c.json({ message: `User ${id} deleted by admin` });\n});\n\n// MOUNT ROUTE GROUPS WITH PREFIXES\napp.route('/api/users', usersApi);     // All usersApi routes prefixed with /api/users\napp.route('/api/products', productsApi); // All productsApi routes prefixed with /api/products\napp.route('/admin', adminApi);           // All adminApi routes prefixed with /admin\n\n// Root routes (not grouped)\napp.get('/', (c) => c.text('Welcome to the API!'));\napp.get('/health', (c) => c.json({ status: 'ok' }));\n\n// RESULT:\n// GET /                    -> 'Welcome to the API!'\n// GET /health              -> { status: 'ok' }\n// GET /api/users           -> { users: [...] }\n// GET /api/users/42        -> { id: '42', name: 'Alice', ... }\n// POST /api/users          -> { message: 'User created', ... }\n// GET /api/products        -> { products: [...] }\n// GET /api/products/1      -> { id: '1', name: 'Laptop', ... }\n// GET /admin/stats         -> { totalUsers: 1000, ... } (requires X-Admin-Key)\n// DELETE /admin/users/5    -> { message: 'User 5 deleted...' } (requires X-Admin-Key)\n\nexport default app;\n\n// In a real project, you'd organize like this:\n// src/\n//   index.ts        <- main app, mounts route groups\n//   routes/\n//     users.ts      <- export usersApi\n//     products.ts   <- export productsApi\n//     admin.ts      <- export adminApi"
            },
            {
              "type": "EXAMPLE",
              "title": "Wildcards and Catch-All Routes",
              "content": "Wildcards in Hono allow you to match any path segment or capture the remainder of a URL. The asterisk (*) acts as a catch-all pattern that matches everything after a certain point. This is incredibly useful for handling 404 pages, serving static files, or creating proxy routes that forward requests to other services.",
              "language": "javascript",
              "code": "// Hono Wildcards and Catch-All Routes (2025)\n\nimport { Hono } from 'hono';\n\nconst app = new Hono();\n\n// WILDCARD PATTERNS\n\n// 1. Catch-all at the end of a path\n// Matches: /files/docs/report.pdf, /files/images/photo.jpg, etc.\napp.get('/files/*', (c) => {\n  // c.req.path gives you the full matched path\n  const fullPath = c.req.path;\n  \n  // Extract the wildcard portion (everything after /files/)\n  const filePath = fullPath.replace('/files/', '');\n  \n  return c.json({\n    message: 'File requested',\n    path: filePath,\n    fullPath: fullPath\n  });\n});\n\n// 2. API versioning with wildcards\n// Forward all v1 API requests\napp.all('/api/v1/*', async (c) => {\n  const path = c.req.path;\n  const method = c.req.method;\n  \n  return c.json({\n    version: 'v1',\n    method: method,\n    path: path,\n    message: 'V1 API - Consider upgrading to V2!'\n  });\n});\n\n// 3. Proxy pattern - forward requests to another service\napp.all('/proxy/*', async (c) => {\n  const targetPath = c.req.path.replace('/proxy', '');\n  const targetUrl = `https://api.example.com${targetPath}`;\n  \n  // In real code, you'd forward the request:\n  // const response = await fetch(targetUrl, {\n  //   method: c.req.method,\n  //   headers: c.req.header(),\n  //   body: c.req.method !== 'GET' ? await c.req.text() : undefined\n  // });\n  // return response;\n  \n  return c.json({\n    message: 'Would proxy to:',\n    targetUrl: targetUrl\n  });\n});\n\n// 4. Static file serving pattern\napp.get('/static/*', async (c) => {\n  const filePath = c.req.path.replace('/static/', '');\n  \n  // In real Bun, you'd serve the file:\n  // const file = Bun.file(`./public/${filePath}`);\n  // return new Response(file);\n  \n  return c.json({\n    serving: filePath,\n    from: './public/' + filePath\n  });\n});\n\n// 5. Namespace isolation - different apps under one roof\nconst blogApp = new Hono();\nblogApp.get('/', (c) => c.text('Blog Home'));\nblogApp.get('/posts', (c) => c.json({ posts: [] }));\nblogApp.get('/posts/:id', (c) => c.json({ id: c.req.param('id') }));\n\nconst shopApp = new Hono();\nshopApp.get('/', (c) => c.text('Shop Home'));\nshopApp.get('/products', (c) => c.json({ products: [] }));\n\n// Mount sub-applications\napp.route('/blog', blogApp);\napp.route('/shop', shopApp);\n\n// 6. 404 Handler - MUST be last!\n// This catches any route not matched above\napp.all('*', (c) => {\n  return c.json({\n    error: 'Not Found',\n    message: `Route ${c.req.method} ${c.req.path} does not exist`,\n    availableRoutes: [\n      'GET /files/*',\n      'ALL /api/v1/*',\n      'ALL /proxy/*',\n      'GET /static/*',\n      '/blog/*',\n      '/shop/*'\n    ]\n  }, 404);\n});\n\nexport default app;\n\n// IMPORTANT: Route order matters!\n// 1. Specific routes first: /api/users/active\n// 2. Parameterized routes: /api/users/:id\n// 3. Wildcard routes: /api/*\n// 4. Catch-all 404: * (always last!)"
            },
            {
              "type": "EXAMPLE",
              "title": "Request Body Parsing (JSON and FormData)",
              "content": "Hono provides simple methods to parse different types of request bodies. While c.req.json() handles JSON data, you will also need c.req.formData() for HTML form submissions and file uploads. Understanding both is essential for building real-world APIs that accept data from web forms, mobile apps, and other services.",
              "language": "javascript",
              "code": "// Hono Request Body Parsing (2025)\n// Handle JSON, Form Data, and other body types\n\nimport { Hono } from 'hono';\n\nconst app = new Hono();\n\n// 1. JSON BODY PARSING\n// Most common for APIs - data sent as application/json\napp.post('/api/users', async (c) => {\n  // c.req.json() parses JSON body (async!)\n  const body = await c.req.json();\n  \n  // Validate required fields\n  if (!body.name || !body.email) {\n    return c.json({ \n      error: 'Validation failed',\n      required: ['name', 'email'] \n    }, 400);\n  }\n  \n  return c.json({\n    message: 'User created',\n    user: {\n      id: crypto.randomUUID(),\n      name: body.name,\n      email: body.email,\n      role: body.role || 'user'\n    }\n  }, 201);\n});\n\n// 2. FORM DATA PARSING\n// HTML forms send data as application/x-www-form-urlencoded or multipart/form-data\napp.post('/contact', async (c) => {\n  // c.req.formData() parses form submissions\n  const formData = await c.req.formData();\n  \n  // Get individual fields\n  const name = formData.get('name');\n  const email = formData.get('email');\n  const message = formData.get('message');\n  \n  // Validate\n  if (!name || !email || !message) {\n    return c.json({ error: 'All fields are required' }, 400);\n  }\n  \n  return c.json({\n    success: true,\n    message: 'Contact form submitted',\n    data: { name, email, message }\n  });\n});\n\n// 3. FILE UPLOADS with FormData\napp.post('/upload', async (c) => {\n  const formData = await c.req.formData();\n  \n  // Get the uploaded file\n  const file = formData.get('file');\n  const description = formData.get('description');\n  \n  if (!file || !(file instanceof File)) {\n    return c.json({ error: 'No file uploaded' }, 400);\n  }\n  \n  // File properties\n  const fileInfo = {\n    name: file.name,\n    size: file.size,\n    type: file.type,\n    description: description || 'No description'\n  };\n  \n  // In real code, save the file:\n  // const buffer = await file.arrayBuffer();\n  // await Bun.write(`./uploads/${file.name}`, buffer);\n  \n  return c.json({\n    message: 'File uploaded successfully',\n    file: fileInfo\n  }, 201);\n});\n\n// 4. RAW TEXT BODY\napp.post('/webhook', async (c) => {\n  // c.req.text() gets raw body as string\n  const rawBody = await c.req.text();\n  \n  // Useful for webhooks that send raw data\n  // or when you need to verify signatures\n  console.log('Raw webhook payload:', rawBody);\n  \n  return c.json({ received: true, length: rawBody.length });\n});\n\n// 5. BLOB/BINARY DATA\napp.post('/binary', async (c) => {\n  // c.req.blob() gets body as Blob\n  const blob = await c.req.blob();\n  \n  return c.json({\n    type: blob.type,\n    size: blob.size\n  });\n});\n\n// 6. ARRAY BUFFER (for binary processing)\napp.post('/process-binary', async (c) => {\n  // c.req.arrayBuffer() for low-level binary data\n  const buffer = await c.req.arrayBuffer();\n  const bytes = new Uint8Array(buffer);\n  \n  return c.json({\n    byteLength: buffer.byteLength,\n    firstBytes: Array.from(bytes.slice(0, 10))\n  });\n});\n\n// 7. MULTIPLE FILES\napp.post('/upload-multiple', async (c) => {\n  const formData = await c.req.formData();\n  \n  // getAll() returns all files with the same field name\n  const files = formData.getAll('files');\n  \n  const fileInfos = files\n    .filter(f => f instanceof File)\n    .map(file => ({\n      name: file.name,\n      size: file.size,\n      type: file.type\n    }));\n  \n  return c.json({\n    message: `${fileInfos.length} files uploaded`,\n    files: fileInfos\n  });\n});\n\n// CONTENT-TYPE DETECTION HELPER\napp.post('/smart-parse', async (c) => {\n  const contentType = c.req.header('Content-Type') || '';\n  \n  if (contentType.includes('application/json')) {\n    const data = await c.req.json();\n    return c.json({ type: 'json', data });\n  }\n  \n  if (contentType.includes('form-data') || contentType.includes('x-www-form-urlencoded')) {\n    const formData = await c.req.formData();\n    const data = Object.fromEntries(formData.entries());\n    return c.json({ type: 'form', data });\n  }\n  \n  const text = await c.req.text();\n  return c.json({ type: 'text', data: text });\n});\n\nexport default app;"
            },
            {
              "type": "EXAMPLE",
              "title": "Multiple Handlers Per Route",
              "content": "Hono allows you to chain multiple handler functions for a single route. Each handler runs in sequence and can perform validation, authentication, logging, or data transformation before passing control to the next handler using await next(). This pattern is perfect for separating concerns like validation middleware from business logic.",
              "language": "javascript",
              "code": "// Hono Multiple Handlers Per Route (2025)\n// Chain handlers for validation, auth, and processing\n\nimport { Hono } from 'hono';\n\nconst app = new Hono();\n\n// INLINE MIDDLEWARE PATTERN\n// Multiple handlers passed directly to the route\n\n// Handler 1: Validate request body\nconst validateUser = async (c, next) => {\n  if (c.req.method === 'POST' || c.req.method === 'PUT') {\n    const body = await c.req.json();\n    \n    if (!body.name || body.name.length < 2) {\n      return c.json({ error: 'Name must be at least 2 characters' }, 400);\n    }\n    if (!body.email || !body.email.includes('@')) {\n      return c.json({ error: 'Valid email is required' }, 400);\n    }\n    \n    // Store validated body for next handler\n    c.set('validatedBody', body);\n  }\n  await next();\n};\n\n// Handler 2: Check authentication\nconst requireAuth = async (c, next) => {\n  const token = c.req.header('Authorization');\n  \n  if (!token || !token.startsWith('Bearer ')) {\n    return c.json({ error: 'Authentication required' }, 401);\n  }\n  \n  // Simulate token validation\n  const tokenValue = token.replace('Bearer ', '');\n  if (tokenValue !== 'valid-token') {\n    return c.json({ error: 'Invalid token' }, 401);\n  }\n  \n  // Store user info for next handler\n  c.set('user', { id: 1, name: 'Alice', role: 'admin' });\n  await next();\n};\n\n// Handler 3: Check admin role\nconst requireAdmin = async (c, next) => {\n  const user = c.get('user');\n  \n  if (!user || user.role !== 'admin') {\n    return c.json({ error: 'Admin access required' }, 403);\n  }\n  \n  await next();\n};\n\n// Handler 4: Log the request\nconst logRequest = async (c, next) => {\n  const start = Date.now();\n  console.log(`[${c.req.method}] ${c.req.path} - Started`);\n  \n  await next();\n  \n  const duration = Date.now() - start;\n  console.log(`[${c.req.method}] ${c.req.path} - Completed in ${duration}ms`);\n};\n\n// USING MULTIPLE HANDLERS\n\n// Public route - just logging\napp.get('/public', \n  logRequest,\n  (c) => c.json({ message: 'Public data' })\n);\n\n// Protected route - auth required\napp.get('/profile',\n  logRequest,\n  requireAuth,\n  (c) => {\n    const user = c.get('user');\n    return c.json({ profile: user });\n  }\n);\n\n// Admin route - multiple checks\napp.get('/admin/users',\n  logRequest,\n  requireAuth,\n  requireAdmin,\n  (c) => {\n    return c.json({ \n      users: [\n        { id: 1, name: 'Alice' },\n        { id: 2, name: 'Bob' }\n      ]\n    });\n  }\n);\n\n// Create user - validation + auth\napp.post('/api/users',\n  logRequest,\n  requireAuth,\n  validateUser,\n  (c) => {\n    const body = c.get('validatedBody');\n    const user = c.get('user');\n    \n    return c.json({\n      message: 'User created',\n      createdBy: user.name,\n      newUser: {\n        id: crypto.randomUUID(),\n        ...body\n      }\n    }, 201);\n  }\n);\n\n// Delete user - full protection\napp.delete('/api/users/:id',\n  logRequest,\n  requireAuth,\n  requireAdmin,\n  (c) => {\n    const id = c.req.param('id');\n    const admin = c.get('user');\n    \n    return c.json({\n      message: `User ${id} deleted`,\n      deletedBy: admin.name\n    });\n  }\n);\n\n// FACTORY PATTERN for reusable handler chains\nconst protectedRoute = (...handlers) => [\n  logRequest,\n  requireAuth,\n  ...handlers\n];\n\nconst adminRoute = (...handlers) => [\n  logRequest,\n  requireAuth,\n  requireAdmin,\n  ...handlers\n];\n\n// Usage with factory\napp.get('/api/orders', ...protectedRoute(\n  (c) => c.json({ orders: [] })\n));\n\napp.delete('/api/orders/:id', ...adminRoute(\n  (c) => c.json({ deleted: c.req.param('id') })\n));\n\nexport default app;\n\n// EXECUTION ORDER:\n// Request -> logRequest -> requireAuth -> requireAdmin -> handler -> Response\n//                |              |              |             |\n//                v              v              v             v\n//          (can stop)     (can stop)     (can stop)    (final response)"
            },
            {
              "type": "THEORY",
              "title": "Advanced Routing Concepts Summary",
              "content": "Here is a comprehensive summary of Hono's advanced routing capabilities that help you build scalable, well-organized APIs:\n\n1. **Route Groups with app.route(prefix, subApp)**:\n   - Create modular route collections as separate Hono instances\n   - Mount them with a prefix: `app.route('/api/users', usersRoutes)`\n   - Each group can have its own middleware\n   - Great for organizing large applications into feature modules\n   - Example file structure: `routes/users.ts`, `routes/products.ts`\n\n2. **Wildcard Routes (*)**:\n   - Match any path segment: `/files/*` matches `/files/a/b/c`\n   - Use `c.req.path` to get the full matched path\n   - Perfect for: static files, proxies, catch-all 404 handlers\n   - Order matters: wildcards should come after specific routes\n   - `app.all('*', handler)` as the last route catches unmatched requests\n\n3. **Request Body Parsing Methods**:\n   - `await c.req.json()` - Parse JSON (application/json)\n   - `await c.req.formData()` - Parse form data (multipart/form-data, x-www-form-urlencoded)\n   - `await c.req.text()` - Get raw text body\n   - `await c.req.blob()` - Get body as Blob\n   - `await c.req.arrayBuffer()` - Get raw binary data\n   - FormData.get('field') for single values, getAll('field') for arrays/multiple files\n\n4. **Multiple Handlers Per Route**:\n   - Chain handlers: `app.get('/path', handler1, handler2, handler3)`\n   - Each handler receives (c, next) and must call `await next()` to continue\n   - Stop the chain by returning a response without calling next()\n   - Use c.set('key', value) to pass data between handlers\n   - Great for: validation, auth checks, logging, rate limiting\n\n5. **Handler Execution Order**:\n   - Handlers run left-to-right in the order specified\n   - Each handler can: continue (await next()), stop (return response), or throw\n   - Code after `await next()` runs in reverse order (like middleware)\n\n6. **Best Practices**:\n   - Define specific routes before parameterized routes\n   - Define parameterized routes before wildcards\n   - Put catch-all 404 handler last\n   - Use route groups to organize related endpoints\n   - Extract common handler chains into reusable arrays"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.3-challenge",
              "title": "Practice Challenge",
              "description": "Create a blog API with Hono routing patterns:\n\n1. GET `/api/posts/:postId` - Get a specific post by ID\n   - Use c.req.param('postId') to get the ID\n   - Return object with: postId, title, content\n\n2. GET `/api/authors/:authorId/posts` - Get all posts by an author\n   - Use c.req.param('authorId')\n   - Return array of posts with authorId in each\n\n3. GET `/api/posts` with query parameters - Search posts\n   - Use c.req.query() for: search, category, limit\n   - Return search parameters and mock results\n\nUse the HonoApp class. Remember to use return c.json()!",
              "instructions": "Create a blog API with Hono routing patterns:\n\n1. GET `/api/posts/:postId` - Get a specific post by ID\n   - Use c.req.param('postId') to get the ID\n   - Return object with: postId, title, content\n\n2. GET `/api/authors/:authorId/posts` - Get all posts by an author\n   - Use c.req.param('authorId')\n   - Return array of posts with authorId in each\n\n3. GET `/api/posts` with query parameters - Search posts\n   - Use c.req.query() for: search, category, limit\n   - Return search parameters and mock results\n\nUse the HonoApp class. Remember to use return c.json()!",
              "starterCode": "class HonoApp {\n  constructor() { this.routes = []; }\n  get(path, handler) { this.routes.push({ method: 'GET', path, handler }); }\n  simulateRequest(method, url) {\n    console.log(`\\n${method} ${url}`);\n    for (let route of this.routes) {\n      if (route.method !== method) continue;\n      let params = this.matchRoute(route.path, url);\n      if (params !== null) {\n        let [path, queryString] = url.split('?');\n        let queryObj = this.parseQuery(queryString);\n        let c = {\n          req: {\n            param: (key) => params[key],\n            query: (key) => queryObj[key]\n          },\n          json: function(d, status = 200) {\n            console.log(`[${status}]`, JSON.stringify(d));\n            return { status, body: d };\n          }\n        };\n        route.handler(c);\n        return;\n      }\n    }\n  }\n  matchRoute(pattern, url) {\n    let [urlPath] = url.split('?');\n    let patternParts = pattern.split('/');\n    let urlParts = urlPath.split('/');\n    if (patternParts.length !== urlParts.length) return null;\n    let params = {};\n    for (let i = 0; i < patternParts.length; i++) {\n      if (patternParts[i].startsWith(':')) {\n        params[patternParts[i].slice(1)] = urlParts[i];\n      } else if (patternParts[i] !== urlParts[i]) return null;\n    }\n    return params;\n  }\n  parseQuery(qs) {\n    if (!qs) return {};\n    let q = {};\n    qs.split('&').forEach(p => { let [k,v] = p.split('='); q[k] = v; });\n    return q;\n  }\n}\n\nlet app = new HonoApp();\n\n// TODO: Add your routes here using Hono patterns\n// Remember: c.req.param('key') and c.req.query('key')\n\n// Test routes\napp.simulateRequest('GET', '/api/posts/123');\napp.simulateRequest('GET', '/api/authors/42/posts');\napp.simulateRequest('GET', '/api/posts?search=hono&category=tech&limit=5');",
              "solution": "class HonoApp {\n  constructor() { this.routes = []; }\n  get(path, handler) { this.routes.push({ method: 'GET', path, handler }); }\n  simulateRequest(method, url) {\n    console.log(`\\n${method} ${url}`);\n    for (let route of this.routes) {\n      if (route.method !== method) continue;\n      let params = this.matchRoute(route.path, url);\n      if (params !== null) {\n        let [path, queryString] = url.split('?');\n        let queryObj = this.parseQuery(queryString);\n        let c = {\n          req: {\n            param: (key) => params[key],\n            query: (key) => queryObj[key]\n          },\n          json: function(d, status = 200) {\n            console.log(`[${status}]`, JSON.stringify(d, null, 2));\n            return { status, body: d };\n          }\n        };\n        route.handler(c);\n        return;\n      }\n    }\n    console.log('404 Not Found');\n  }\n  matchRoute(pattern, url) {\n    let [urlPath] = url.split('?');\n    let patternParts = pattern.split('/');\n    let urlParts = urlPath.split('/');\n    if (patternParts.length !== urlParts.length) return null;\n    let params = {};\n    for (let i = 0; i < patternParts.length; i++) {\n      if (patternParts[i].startsWith(':')) {\n        params[patternParts[i].slice(1)] = urlParts[i];\n      } else if (patternParts[i] !== urlParts[i]) return null;\n    }\n    return params;\n  }\n  parseQuery(qs) {\n    if (!qs) return {};\n    let q = {};\n    qs.split('&').forEach(p => { let [k,v] = p.split('='); q[k] = v; });\n    return q;\n  }\n}\n\nlet app = new HonoApp();\n\n// Route 1: Get specific post using c.req.param()\napp.get('/api/posts/:postId', (c) => {\n  const postId = c.req.param('postId');\n  \n  return c.json({\n    postId: postId,\n    title: `Post ${postId} Title`,\n    content: 'This is the post content...',\n    author: 'Alice'\n  });\n});\n\n// Route 2: Get posts by author\napp.get('/api/authors/:authorId/posts', (c) => {\n  const authorId = c.req.param('authorId');\n  \n  return c.json({\n    authorId: authorId,\n    posts: [\n      { id: 1, title: 'First Post', content: 'Content 1' },\n      { id: 2, title: 'Second Post', content: 'Content 2' }\n    ]\n  });\n});\n\n// Route 3: Search posts with c.req.query()\napp.get('/api/posts', (c) => {\n  const search = c.req.query('search');\n  const category = c.req.query('category');\n  const limit = c.req.query('limit');\n  \n  return c.json({\n    search: search || 'all',\n    category: category || 'all',\n    limit: limit || '10',\n    results: [\n      { id: 1, title: 'Hono Tutorial', category: 'tech' },\n      { id: 2, title: 'Bun Guide', category: 'tech' }\n    ]\n  });\n});\n\n// Test all routes\napp.simulateRequest('GET', '/api/posts/123');\napp.simulateRequest('GET', '/api/authors/42/posts');\napp.simulateRequest('GET', '/api/posts?search=hono&category=tech&limit=5');\napp.simulateRequest('GET', '/api/posts');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should extract post ID using c.req.param()",
                  "expectedOutput": "123",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should parse query parameters using c.req.query()",
                  "expectedOutput": "10",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "In Hono, use c.req.param('postId') for URL parameters and c.req.query('search') for query strings. Always return c.json()!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using Express req.params.id instead of Hono c.req.param('id')",
                  "consequence": "Returns undefined because Hono uses method calls, not object properties.",
                  "correction": "Use c.req.param('id') for URL parameters and c.req.query('key') for query strings."
                },
                {
                  "mistake": "Forgetting to return the response in route handlers",
                  "consequence": "No response is sent to the client.",
                  "correction": "Always use return c.json(...) or return c.text(...)"
                },
                {
                  "mistake": "Route order conflicts with dynamic segments",
                  "consequence": "Specific routes like /users/active get matched by /users/:id first.",
                  "correction": "Place specific routes before parameterized routes: /users/active before /users/:id"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "11.4",
          "title": "Hono Middleware Patterns (The Assembly Line Analogy)",
          "moduleId": "module-11",
          "order": 4,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a factory assembly line:\n\nWithout assembly line (no middleware):\n- One worker does EVERYTHING for each product\n- Unwrap materials, assemble, test, package, label\n- Repetitive, inefficient, error-prone\n\nWith assembly line (middleware):\n- Station 1: Unwrap and inspect materials (authentication)\n- Station 2: Assemble parts (body parsing)\n- Station 3: Quality check (validation)\n- Station 4: Package product (route handler)\n- Station 5: Add label (response formatting)\n\nEach station does one job, passes to the next!\n\nHono middleware works the same way:\n- Request comes in\n- Passes through middleware functions in order\n- Each middleware does one specific task\n- Calls await next() to continue\n- Finally reaches your route handler\n- Response goes back to client\n\nMiddleware = functions that process requests before they reach your routes!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Hono - Middleware (2025)\n\n// Simulated Hono with middleware support\nclass HonoApp {\n  constructor() {\n    this.routes = [];\n    this.middleware = [];\n  }\n  \n  use(pattern, handler) {\n    // Hono middleware signature: app.use('*', handler)\n    // or app.use('/api/*', handler) for path-specific\n    if (typeof pattern === 'function') {\n      handler = pattern;\n      pattern = '*';\n    }\n    this.middleware.push({ pattern, handler });\n    console.log(`Middleware registered for: ${pattern}`);\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n  }\n  \n  async simulateRequest(method, path, body = null) {\n    console.log(`\\n--- ${method} ${path} ---`);\n    \n    // Create Hono-style context\n    let c = {\n      req: {\n        method,\n        path,\n        header: (key) => key === 'Authorization' ? 'Bearer valid-token' : null,\n        json: async () => body || {}\n      },\n      // Context can store data via c.set() and c.get()\n      _store: {},\n      set: function(key, value) { this._store[key] = value; },\n      get: function(key) { return this._store[key]; },\n      json: function(data, status = 200) {\n        console.log(`Response [${status}]:`, JSON.stringify(data));\n        return { status, body: data };\n      },\n      text: function(data, status = 200) {\n        console.log(`Response [${status}]:`, data);\n        return { status, body: data };\n      }\n    };\n    \n    // Run middleware chain with async/await\n    let middlewareIndex = 0;\n    \n    let next = async () => {\n      if (middlewareIndex < this.middleware.length) {\n        let currentMiddleware = this.middleware[middlewareIndex++];\n        await currentMiddleware.handler(c, next);\n      } else {\n        // Middleware done, find and run route handler\n        let route = this.routes.find(r => r.method === method && r.path === path);\n        if (route) {\n          return route.handler(c);\n        } else {\n          return c.json({ error: 'Not found' }, 404);\n        }\n      }\n    };\n    \n    await next();\n  }\n}\n\nlet app = new HonoApp();\n\n// HONO MIDDLEWARE EXAMPLES\n// Note: Hono middleware uses (c, next) pattern with async/await\n\n// 1. Logging Middleware - Runs on EVERY request\napp.use('*', async (c, next) => {\n  console.log(`[LOG] ${c.req.method} ${c.req.path}`);\n  const start = Date.now();\n  \n  await next();  // MUST await next() to continue!\n  \n  // Code AFTER next() runs after route handler\n  const duration = Date.now() - start;\n  console.log(`[TIMING] Request took ${duration}ms`);\n});\n\n// 2. Authentication Middleware\napp.use('*', async (c, next) => {\n  const token = c.req.header('Authorization');\n  \n  if (token === 'Bearer valid-token') {\n    // Store user in context using c.set()\n    c.set('user', { id: 1, name: 'Alice', role: 'admin' });\n    console.log('[AUTH] User authenticated:', c.get('user').name);\n    await next();\n  } else {\n    console.log('[AUTH] Invalid token!');\n    return c.json({ error: 'Unauthorized' }, 401);\n    // Note: No next() call - request stops here!\n  }\n});\n\n// 3. Request Validator Middleware (for POST)\napp.use('*', async (c, next) => {\n  if (c.req.method === 'POST') {\n    const body = await c.req.json();\n    c.set('body', body);  // Store parsed body for route\n    console.log('[PARSER] Parsed JSON body');\n  }\n  await next();\n});\n\n// ROUTES (run AFTER middleware)\n\napp.get('/api/public', (c) => {\n  const user = c.get('user');\n  return c.json({ \n    message: 'Public endpoint',\n    user: user ? user.name : 'anonymous'\n  });\n});\n\napp.get('/api/protected', (c) => {\n  // Get user from context (set by auth middleware)\n  const user = c.get('user');\n  return c.json({ \n    message: 'Protected data',\n    user: user.name,\n    role: user.role\n  });\n});\n\napp.post('/api/data', (c) => {\n  const body = c.get('body');  // Get parsed body from middleware\n  const user = c.get('user');\n  return c.json({ \n    message: 'Data received',\n    data: body,\n    processedBy: user.name\n  });\n});\n\n// TEST MIDDLEWARE CHAIN\n\napp.simulateRequest('GET', '/api/public');\napp.simulateRequest('GET', '/api/protected');\napp.simulateRequest('POST', '/api/data', { title: 'Test', value: 42 });"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding Hono middleware:\n\n1. **Middleware Signature**: `async (c, next) => { ... }`\n   - `c`: Context object (has req, response helpers, storage)\n   - `next`: Async function to call the next middleware\n   - MUST await `next()` to continue the chain!\n\n2. **Registering Middleware**: `app.use('*', middlewareFunction)`\n   - `'*'` means run on ALL routes\n   - `'/api/*'` runs only on /api routes\n   - Order matters - middleware runs in order you add it\n\n3. **Middleware Flow**:\n   ```\n   Request -> Middleware 1 -> Middleware 2 -> Route Handler\n                   |                |              |\n                   v                v              v\n             (before next)    (before next)   (handler)\n                   |                |              |\n                   v                v              v\n             (after next)     (after next)    Response\n   ```\n\n4. **Context Storage** (c.set/c.get):\n   ```javascript\n   // In middleware\n   app.use('*', async (c, next) => {\n     c.set('user', { id: 1, name: 'Alice' });\n     await next();\n   });\n   \n   // In route handler\n   app.get('/profile', (c) => {\n     const user = c.get('user');  // Access stored data!\n     return c.json(user);\n   });\n   ```\n\n5. **Before and After next()**:\n   ```javascript\n   app.use('*', async (c, next) => {\n     console.log('Before route handler');  // Runs first\n     const start = Date.now();\n     \n     await next();  // Route handler runs here\n     \n     const ms = Date.now() - start;  // Runs after\n     console.log(`Request took ${ms}ms`);\n   });\n   ```\n\n6. **Stopping the Chain**:\n   ```javascript\n   app.use('*', async (c, next) => {\n     if (!isAuthorized(c)) {\n       return c.json({ error: 'Unauthorized' }, 401);\n       // No next() - request stops here!\n     }\n     await next();\n   });\n   ```\n\n7. **Built-in Hono Middleware**:\n   ```javascript\n   import { cors } from 'hono/cors';\n   import { logger } from 'hono/logger';\n   import { prettyJSON } from 'hono/pretty-json';\n   \n   app.use('*', logger());\n   app.use('*', cors());\n   app.use('*', prettyJSON());\n   ```"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Node.js/Express Equivalent",
              "legacy": "express",
              "content": "Hono middleware is simpler than Express. The key differences are: unified context object, async/await by default, and c.set()/c.get() for data storage instead of mutating req.",
              "code": "// Express middleware (older pattern)\napp.use((req, res, next) => {\n  req.user = { id: 1, name: 'Alice' };  // Mutate req object\n  next();  // Not async by default\n});\n\napp.get('/profile', (req, res) => {\n  res.json(req.user);  // Access from req\n});\n\n// Hono middleware (modern pattern)\napp.use('*', async (c, next) => {\n  c.set('user', { id: 1, name: 'Alice' });  // Use context storage\n  await next();  // Async by default\n});\n\napp.get('/profile', (c) => {\n  const user = c.get('user');  // Access from context\n  return c.json(user);\n});\n\n// Key differences:\n// Express: (req, res, next) with next() callback\n// Hono: async (c, next) with await next()\n// Express: req.user = data (mutation)\n// Hono: c.set('user', data) (storage)",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Hono middleware mistakes:\n\n1. **Forgetting to await next()**:\n   ```javascript\n   app.use('*', async (c, next) => {\n     console.log('Request received');\n     next();  // Missing await! Middleware continues before route finishes\n   });\n   \n   // Correct:\n   app.use('*', async (c, next) => {\n     console.log('Request received');\n     await next();  // Properly waits for chain to complete\n   });\n   ```\n\n2. **Returning after next()**:\n   ```javascript\n   app.use('*', async (c, next) => {\n     await next();\n     return c.json({ data: 'oops' });  // This overwrites route response!\n   });\n   \n   // Correct - don't return after next() unless intentional:\n   app.use('*', async (c, next) => {\n     await next();\n     // Just add logging, don't return a response\n     console.log('Request completed');\n   });\n   ```\n\n3. **Using Express patterns**:\n   ```javascript\n   // Wrong - Express style!\n   app.use((req, res, next) => {\n     req.user = { name: 'Alice' };\n     next();\n   });\n   \n   // Correct - Hono style!\n   app.use('*', async (c, next) => {\n     c.set('user', { name: 'Alice' });\n     await next();\n   });\n   ```\n\n4. **Forgetting the path pattern**:\n   ```javascript\n   // Hono requires a pattern (usually '*')\n   app.use('*', async (c, next) => { ... });\n   \n   // For specific paths:\n   app.use('/api/*', async (c, next) => { ... });\n   ```\n\n5. **Not handling errors in async middleware**:\n   ```javascript\n   app.use('*', async (c, next) => {\n     try {\n       await someAsyncOperation();\n       await next();\n     } catch (error) {\n       return c.json({ error: error.message }, 500);\n     }\n   });\n   ```\n\n6. **Wrong middleware order**:\n   - Authentication should come before route handlers\n   - Logging should come first (to catch all requests)\n   - Error handlers should come last"
            },
            {
              "type": "EXAMPLE",
              "title": "Error Handling Middleware",
              "content": "Hono provides a built-in error handling mechanism using app.onError() that catches any errors thrown in your routes or middleware. This centralized error handling pattern ensures consistent error responses across your entire API and prevents sensitive error details from leaking to clients in production.",
              "language": "javascript",
              "code": "// Hono Error Handling Middleware (2025)\n// Centralized error handling for robust APIs\n\nimport { Hono } from 'hono';\nimport { HTTPException } from 'hono/http-exception';\n\nconst app = new Hono();\n\n// CUSTOM ERROR CLASSES\nclass ValidationError extends Error {\n  constructor(message, field) {\n    super(message);\n    this.name = 'ValidationError';\n    this.field = field;\n    this.statusCode = 400;\n  }\n}\n\nclass NotFoundError extends Error {\n  constructor(resource) {\n    super(`${resource} not found`);\n    this.name = 'NotFoundError';\n    this.statusCode = 404;\n  }\n}\n\nclass UnauthorizedError extends Error {\n  constructor(message = 'Authentication required') {\n    super(message);\n    this.name = 'UnauthorizedError';\n    this.statusCode = 401;\n  }\n}\n\n// GLOBAL ERROR HANDLER\n// Catches ALL errors thrown in routes and middleware\napp.onError((err, c) => {\n  console.error(`[ERROR] ${err.name}: ${err.message}`);\n  \n  // Handle HTTPException (Hono's built-in)\n  if (err instanceof HTTPException) {\n    return c.json({\n      error: err.message,\n      status: err.status\n    }, err.status);\n  }\n  \n  // Handle custom errors\n  if (err instanceof ValidationError) {\n    return c.json({\n      error: 'Validation Error',\n      message: err.message,\n      field: err.field\n    }, 400);\n  }\n  \n  if (err instanceof NotFoundError) {\n    return c.json({\n      error: 'Not Found',\n      message: err.message\n    }, 404);\n  }\n  \n  if (err instanceof UnauthorizedError) {\n    return c.json({\n      error: 'Unauthorized',\n      message: err.message\n    }, 401);\n  }\n  \n  // Handle unknown errors (don't leak details in production!)\n  const isDev = process.env.NODE_ENV !== 'production';\n  \n  return c.json({\n    error: 'Internal Server Error',\n    message: isDev ? err.message : 'Something went wrong',\n    ...(isDev && { stack: err.stack })\n  }, 500);\n});\n\n// NOT FOUND HANDLER\n// Catches requests that don't match any route\napp.notFound((c) => {\n  return c.json({\n    error: 'Not Found',\n    message: `Route ${c.req.method} ${c.req.path} not found`,\n    hint: 'Check the API documentation for available endpoints'\n  }, 404);\n});\n\n// ERROR-THROWING MIDDLEWARE\n// Wrap async operations with try/catch\nconst asyncHandler = (fn) => async (c, next) => {\n  try {\n    await fn(c, next);\n  } catch (error) {\n    throw error; // Let onError handle it\n  }\n};\n\n// ROUTES THAT THROW ERRORS\n\n// Validation error example\napp.post('/api/users', async (c) => {\n  const body = await c.req.json();\n  \n  if (!body.email) {\n    throw new ValidationError('Email is required', 'email');\n  }\n  \n  if (!body.email.includes('@')) {\n    throw new ValidationError('Invalid email format', 'email');\n  }\n  \n  return c.json({ message: 'User created', email: body.email }, 201);\n});\n\n// Not found error example\napp.get('/api/users/:id', (c) => {\n  const id = c.req.param('id');\n  const users = { '1': { name: 'Alice' }, '2': { name: 'Bob' } };\n  \n  if (!users[id]) {\n    throw new NotFoundError('User');\n  }\n  \n  return c.json(users[id]);\n});\n\n// Using HTTPException (Hono's built-in)\napp.get('/api/admin', (c) => {\n  const isAdmin = false;\n  \n  if (!isAdmin) {\n    throw new HTTPException(403, { message: 'Admin access required' });\n  }\n  \n  return c.json({ secret: 'admin data' });\n});\n\n// Simulating unexpected error\napp.get('/api/crash', (c) => {\n  // This will be caught by onError\n  throw new Error('Unexpected database connection failed!');\n});\n\n// TRY-CATCH IN MIDDLEWARE\napp.use('/api/risky/*', async (c, next) => {\n  try {\n    // Some risky operation\n    const result = await someRiskyOperation();\n    c.set('riskyData', result);\n    await next();\n  } catch (error) {\n    // Handle or transform the error\n    console.error('Risky operation failed:', error.message);\n    throw new Error('Failed to process request: ' + error.message);\n  }\n});\n\nexport default app;\n\n// ERROR HANDLING BEST PRACTICES:\n// 1. Use custom error classes for different error types\n// 2. Always use onError() for centralized handling\n// 3. Don't leak stack traces in production\n// 4. Log errors for debugging\n// 5. Return consistent error response format\n// 6. Use notFound() for 404 handling"
            },
            {
              "type": "EXAMPLE",
              "title": "JWT Authentication Middleware",
              "content": "JSON Web Tokens (JWT) are the industry standard for stateless authentication in modern APIs. This middleware pattern verifies JWT tokens, extracts user information, and makes it available to your route handlers. The pattern includes token extraction, verification, and proper error handling for expired or invalid tokens.",
              "language": "javascript",
              "code": "// Hono JWT Authentication Middleware (2025)\n// Stateless authentication for APIs\n\nimport { Hono } from 'hono';\nimport { jwt } from 'hono/jwt';\nimport { sign, verify } from 'hono/jwt';\n\nconst app = new Hono();\n\n// SECRET KEY (in production, use environment variable!)\nconst JWT_SECRET = 'your-super-secret-key-change-in-production';\n\n// CUSTOM JWT MIDDLEWARE (manual implementation for learning)\nconst jwtAuth = async (c, next) => {\n  // 1. Extract token from Authorization header\n  const authHeader = c.req.header('Authorization');\n  \n  if (!authHeader) {\n    return c.json({ \n      error: 'Unauthorized',\n      message: 'No authorization header provided'\n    }, 401);\n  }\n  \n  // 2. Check Bearer format\n  if (!authHeader.startsWith('Bearer ')) {\n    return c.json({\n      error: 'Unauthorized', \n      message: 'Invalid authorization format. Use: Bearer <token>'\n    }, 401);\n  }\n  \n  const token = authHeader.replace('Bearer ', '');\n  \n  try {\n    // 3. Verify and decode token\n    const payload = await verify(token, JWT_SECRET);\n    \n    // 4. Check expiration\n    if (payload.exp && payload.exp < Date.now() / 1000) {\n      return c.json({\n        error: 'Unauthorized',\n        message: 'Token has expired'\n      }, 401);\n    }\n    \n    // 5. Store user in context for route handlers\n    c.set('jwtPayload', payload);\n    c.set('user', {\n      id: payload.sub,\n      email: payload.email,\n      role: payload.role\n    });\n    \n    await next();\n    \n  } catch (error) {\n    return c.json({\n      error: 'Unauthorized',\n      message: 'Invalid token'\n    }, 401);\n  }\n};\n\n// ROLE-BASED ACCESS CONTROL MIDDLEWARE\nconst requireRole = (...allowedRoles) => {\n  return async (c, next) => {\n    const user = c.get('user');\n    \n    if (!user) {\n      return c.json({ error: 'Unauthorized' }, 401);\n    }\n    \n    if (!allowedRoles.includes(user.role)) {\n      return c.json({\n        error: 'Forbidden',\n        message: `Required role: ${allowedRoles.join(' or ')}`\n      }, 403);\n    }\n    \n    await next();\n  };\n};\n\n// PUBLIC ROUTES (no auth required)\n\napp.get('/', (c) => c.text('Welcome to the API!'));\n\napp.get('/api/health', (c) => c.json({ status: 'ok' }));\n\n// LOGIN ROUTE - Generate JWT\napp.post('/api/login', async (c) => {\n  const body = await c.req.json();\n  const { email, password } = body;\n  \n  // Simulate user lookup (in real app, check database)\n  const users = {\n    'admin@example.com': { id: 1, password: 'admin123', role: 'admin' },\n    'user@example.com': { id: 2, password: 'user123', role: 'user' }\n  };\n  \n  const user = users[email];\n  \n  if (!user || user.password !== password) {\n    return c.json({ error: 'Invalid credentials' }, 401);\n  }\n  \n  // Create JWT token\n  const payload = {\n    sub: user.id,           // Subject (user ID)\n    email: email,\n    role: user.role,\n    iat: Math.floor(Date.now() / 1000),  // Issued at\n    exp: Math.floor(Date.now() / 1000) + (60 * 60 * 24)  // Expires in 24h\n  };\n  \n  const token = await sign(payload, JWT_SECRET);\n  \n  return c.json({\n    message: 'Login successful',\n    token: token,\n    expiresIn: '24h'\n  });\n});\n\n// PROTECTED ROUTES (require JWT)\n\n// Apply JWT middleware to all /api/protected routes\napp.use('/api/protected/*', jwtAuth);\n\napp.get('/api/protected/profile', (c) => {\n  const user = c.get('user');\n  return c.json({\n    message: 'Protected profile data',\n    user: user\n  });\n});\n\napp.get('/api/protected/dashboard', (c) => {\n  const user = c.get('user');\n  return c.json({\n    message: `Welcome back, ${user.email}!`,\n    userId: user.id,\n    role: user.role\n  });\n});\n\n// ADMIN ONLY ROUTES (require JWT + admin role)\n\napp.use('/api/admin/*', jwtAuth);\napp.use('/api/admin/*', requireRole('admin'));\n\napp.get('/api/admin/users', (c) => {\n  return c.json({\n    message: 'Admin area - all users',\n    users: [\n      { id: 1, email: 'admin@example.com', role: 'admin' },\n      { id: 2, email: 'user@example.com', role: 'user' }\n    ]\n  });\n});\n\napp.delete('/api/admin/users/:id', (c) => {\n  const id = c.req.param('id');\n  const admin = c.get('user');\n  \n  return c.json({\n    message: `User ${id} deleted by admin ${admin.email}`\n  });\n});\n\n// USING HONO'S BUILT-IN JWT MIDDLEWARE\n// Simpler alternative to custom implementation\n\n// import { jwt } from 'hono/jwt';\n// app.use('/api/v2/*', jwt({ secret: JWT_SECRET }));\n// Then access payload via c.get('jwtPayload')\n\nexport default app;\n\n// USAGE EXAMPLE:\n// 1. Login: POST /api/login { email, password } -> get token\n// 2. Access protected: GET /api/protected/profile\n//    Header: Authorization: Bearer <token>\n// 3. Admin access: GET /api/admin/users (requires admin role)"
            },
            {
              "type": "EXAMPLE",
              "title": "CORS Middleware",
              "content": "Cross-Origin Resource Sharing (CORS) is essential when your API is accessed from web browsers on different domains. Hono provides a built-in cors() middleware that handles preflight requests, allowed origins, methods, and headers. Proper CORS configuration is critical for security while enabling legitimate cross-origin requests from your frontend applications.",
              "language": "javascript",
              "code": "// Hono CORS Middleware (2025)\n// Enable cross-origin requests safely\n\nimport { Hono } from 'hono';\nimport { cors } from 'hono/cors';\n\nconst app = new Hono();\n\n// BASIC CORS - Allow all origins (development only!)\n// app.use('*', cors());\n\n// PRODUCTION CORS CONFIGURATION\napp.use('*', cors({\n  // Allowed origins (your frontend domains)\n  origin: [\n    'https://myapp.com',\n    'https://www.myapp.com',\n    'http://localhost:3000',  // Local development\n    'http://localhost:5173'   // Vite dev server\n  ],\n  \n  // Or use a function for dynamic origin checking\n  // origin: (origin) => {\n  //   return origin.endsWith('.myapp.com') \n  //     ? origin \n  //     : 'https://myapp.com';\n  // },\n  \n  // Allowed HTTP methods\n  allowMethods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],\n  \n  // Allowed headers in requests\n  allowHeaders: [\n    'Content-Type',\n    'Authorization',\n    'X-Requested-With',\n    'X-Custom-Header'\n  ],\n  \n  // Headers exposed to the browser\n  exposeHeaders: [\n    'Content-Length',\n    'X-Request-Id'\n  ],\n  \n  // Max age for preflight cache (in seconds)\n  maxAge: 86400,  // 24 hours\n  \n  // Allow credentials (cookies, authorization headers)\n  credentials: true\n}));\n\n// DIFFERENT CORS FOR DIFFERENT ROUTES\n\n// Public API - more permissive\napp.use('/api/public/*', cors({\n  origin: '*',  // Allow any origin\n  allowMethods: ['GET'],  // Read-only\n  maxAge: 3600\n}));\n\n// Private API - restrictive\napp.use('/api/private/*', cors({\n  origin: ['https://myapp.com'],\n  allowMethods: ['GET', 'POST', 'PUT', 'DELETE'],\n  credentials: true\n}));\n\n// Webhook endpoints - specific origins\napp.use('/webhooks/*', cors({\n  origin: [\n    'https://stripe.com',\n    'https://github.com'\n  ],\n  allowMethods: ['POST']\n}));\n\n// ROUTES\n\napp.get('/api/public/data', (c) => {\n  return c.json({\n    message: 'Public data - accessible from any origin',\n    data: ['item1', 'item2', 'item3']\n  });\n});\n\napp.get('/api/private/profile', (c) => {\n  return c.json({\n    message: 'Private data - only from allowed origins',\n    user: { id: 1, name: 'Alice' }\n  });\n});\n\napp.post('/api/private/update', async (c) => {\n  const body = await c.req.json();\n  return c.json({\n    message: 'Data updated',\n    received: body\n  });\n});\n\n// MANUAL CORS HANDLING (for custom logic)\nconst customCors = async (c, next) => {\n  const origin = c.req.header('Origin');\n  const allowedOrigins = ['https://myapp.com', 'http://localhost:3000'];\n  \n  // Check if origin is allowed\n  if (origin && allowedOrigins.includes(origin)) {\n    c.header('Access-Control-Allow-Origin', origin);\n    c.header('Access-Control-Allow-Credentials', 'true');\n  }\n  \n  // Handle preflight requests\n  if (c.req.method === 'OPTIONS') {\n    c.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n    c.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n    c.header('Access-Control-Max-Age', '86400');\n    return c.text('', 204);  // No content\n  }\n  \n  await next();\n};\n\n// Apply custom CORS to specific route\napp.use('/api/custom/*', customCors);\n\napp.get('/api/custom/data', (c) => {\n  return c.json({ message: 'Custom CORS applied' });\n});\n\nexport default app;\n\n// CORS CONCEPTS:\n// - Preflight: Browser sends OPTIONS request first for non-simple requests\n// - Simple requests: GET/POST with standard headers (no preflight needed)\n// - Credentials: Cookies/auth headers require credentials: true\n// - Origin: The domain making the request (sent by browser)\n\n// SECURITY TIPS:\n// 1. Never use origin: '*' with credentials: true\n// 2. Whitelist specific origins in production\n// 3. Limit allowed methods to what you need\n// 4. Use short maxAge during development"
            },
            {
              "type": "EXAMPLE",
              "title": "Rate Limiting Middleware",
              "content": "Rate limiting protects your API from abuse by limiting how many requests a client can make in a given time period. This middleware pattern tracks request counts per client (using IP address or API key) and returns appropriate error responses when limits are exceeded. Rate limiting is essential for preventing DDoS attacks and ensuring fair resource usage.",
              "language": "javascript",
              "code": "// Hono Rate Limiting Middleware (2025)\n// Protect your API from abuse\n\nimport { Hono } from 'hono';\n\nconst app = new Hono();\n\n// IN-MEMORY RATE LIMITER (for demonstration)\n// In production, use Redis or a distributed cache!\n\nclass RateLimiter {\n  constructor(options = {}) {\n    this.windowMs = options.windowMs || 60000;  // 1 minute default\n    this.maxRequests = options.max || 100;       // 100 requests default\n    this.message = options.message || 'Too many requests, please try again later';\n    this.store = new Map();  // IP -> { count, resetTime }\n    \n    // Clean up expired entries periodically\n    setInterval(() => this.cleanup(), this.windowMs);\n  }\n  \n  cleanup() {\n    const now = Date.now();\n    for (const [key, value] of this.store) {\n      if (now > value.resetTime) {\n        this.store.delete(key);\n      }\n    }\n  }\n  \n  // Get client identifier (IP address)\n  getClientId(c) {\n    // Try various headers for real IP behind proxies\n    return c.req.header('X-Forwarded-For')?.split(',')[0]?.trim() ||\n           c.req.header('X-Real-IP') ||\n           c.req.header('CF-Connecting-IP') ||  // Cloudflare\n           'unknown';\n  }\n  \n  // Create middleware function\n  middleware() {\n    return async (c, next) => {\n      const clientId = this.getClientId(c);\n      const now = Date.now();\n      \n      // Get or create rate limit entry\n      let entry = this.store.get(clientId);\n      \n      if (!entry || now > entry.resetTime) {\n        entry = {\n          count: 0,\n          resetTime: now + this.windowMs\n        };\n        this.store.set(clientId, entry);\n      }\n      \n      // Increment request count\n      entry.count++;\n      \n      // Calculate remaining requests and reset time\n      const remaining = Math.max(0, this.maxRequests - entry.count);\n      const resetSeconds = Math.ceil((entry.resetTime - now) / 1000);\n      \n      // Set rate limit headers\n      c.header('X-RateLimit-Limit', String(this.maxRequests));\n      c.header('X-RateLimit-Remaining', String(remaining));\n      c.header('X-RateLimit-Reset', String(Math.ceil(entry.resetTime / 1000)));\n      \n      // Check if limit exceeded\n      if (entry.count > this.maxRequests) {\n        c.header('Retry-After', String(resetSeconds));\n        \n        return c.json({\n          error: 'Too Many Requests',\n          message: this.message,\n          retryAfter: resetSeconds\n        }, 429);\n      }\n      \n      await next();\n    };\n  }\n}\n\n// CREATE RATE LIMITERS WITH DIFFERENT CONFIGS\n\n// General API limit: 100 requests per minute\nconst generalLimiter = new RateLimiter({\n  windowMs: 60 * 1000,  // 1 minute\n  max: 100,\n  message: 'Rate limit exceeded. Please wait before making more requests.'\n});\n\n// Strict limit for auth endpoints: 5 per minute\nconst authLimiter = new RateLimiter({\n  windowMs: 60 * 1000,\n  max: 5,\n  message: 'Too many login attempts. Please try again in a minute.'\n});\n\n// Very strict for sensitive operations: 3 per hour\nconst sensitiveLimit = new RateLimiter({\n  windowMs: 60 * 60 * 1000,  // 1 hour\n  max: 3,\n  message: 'This action is rate limited. Please try again later.'\n});\n\n// API key based rate limiter\nconst apiKeyLimiter = new RateLimiter({\n  windowMs: 60 * 1000,\n  max: 1000  // Higher limit for API key users\n});\n\n// Override getClientId to use API key\napiKeyLimiter.getClientId = (c) => {\n  return c.req.header('X-API-Key') || 'anonymous';\n};\n\n// APPLY RATE LIMITERS\n\n// General rate limit for all routes\napp.use('*', generalLimiter.middleware());\n\n// Stricter limit for auth routes\napp.use('/api/auth/*', authLimiter.middleware());\n\n// Very strict for password reset\napp.use('/api/auth/reset-password', sensitiveLimit.middleware());\n\n// ROUTES\n\napp.get('/api/data', (c) => {\n  return c.json({\n    message: 'API data',\n    timestamp: new Date().toISOString()\n  });\n});\n\napp.post('/api/auth/login', async (c) => {\n  const body = await c.req.json();\n  return c.json({\n    message: 'Login processed',\n    email: body.email\n  });\n});\n\napp.post('/api/auth/reset-password', async (c) => {\n  const body = await c.req.json();\n  return c.json({\n    message: 'Password reset email sent',\n    email: body.email\n  });\n});\n\n// SLIDING WINDOW RATE LIMITER (more accurate)\nclass SlidingWindowLimiter {\n  constructor(options = {}) {\n    this.windowMs = options.windowMs || 60000;\n    this.maxRequests = options.max || 100;\n    this.store = new Map();  // IP -> [timestamps]\n  }\n  \n  middleware() {\n    return async (c, next) => {\n      const clientId = c.req.header('X-Forwarded-For') || 'unknown';\n      const now = Date.now();\n      const windowStart = now - this.windowMs;\n      \n      // Get request timestamps for this client\n      let timestamps = this.store.get(clientId) || [];\n      \n      // Remove expired timestamps\n      timestamps = timestamps.filter(ts => ts > windowStart);\n      \n      // Check limit\n      if (timestamps.length >= this.maxRequests) {\n        const oldestTimestamp = timestamps[0];\n        const retryAfter = Math.ceil((oldestTimestamp + this.windowMs - now) / 1000);\n        \n        return c.json({\n          error: 'Rate limit exceeded',\n          retryAfter: retryAfter\n        }, 429);\n      }\n      \n      // Add current request\n      timestamps.push(now);\n      this.store.set(clientId, timestamps);\n      \n      await next();\n    };\n  }\n}\n\nexport default app;\n\n// PRODUCTION RECOMMENDATIONS:\n// 1. Use Redis for distributed rate limiting\n// 2. Consider using 'hono-rate-limiter' package\n// 3. Set appropriate limits based on endpoint sensitivity\n// 4. Always include Retry-After header in 429 responses\n// 5. Log rate limit violations for security monitoring"
            },
            {
              "type": "EXAMPLE",
              "title": "Enhanced Logging Middleware with Timing",
              "content": "Production-ready logging middleware captures request details, timing information, and response status. This middleware demonstrates the power of running code both before and after next() to measure request duration. Proper logging is essential for debugging, performance monitoring, and security auditing of your API.",
              "language": "javascript",
              "code": "// Hono Enhanced Logging Middleware (2025)\n// Production-ready request logging\n\nimport { Hono } from 'hono';\nimport { logger } from 'hono/logger';\n\nconst app = new Hono();\n\n// USING HONO'S BUILT-IN LOGGER\n// Simple one-liner for development\n// app.use('*', logger());\n\n// CUSTOM PRODUCTION LOGGER\nconst productionLogger = async (c, next) => {\n  const start = Date.now();\n  const requestId = crypto.randomUUID();\n  \n  // Store request ID for tracing\n  c.set('requestId', requestId);\n  \n  // Extract request info\n  const method = c.req.method;\n  const path = c.req.path;\n  const query = c.req.query();\n  const userAgent = c.req.header('User-Agent') || 'unknown';\n  const ip = c.req.header('X-Forwarded-For')?.split(',')[0] || \n             c.req.header('X-Real-IP') || \n             'unknown';\n  \n  // Log request start\n  console.log(JSON.stringify({\n    type: 'request',\n    requestId,\n    timestamp: new Date().toISOString(),\n    method,\n    path,\n    query: Object.keys(query).length > 0 ? query : undefined,\n    ip,\n    userAgent\n  }));\n  \n  try {\n    // Process request\n    await next();\n    \n    // Log successful response\n    const duration = Date.now() - start;\n    const status = c.res.status;\n    \n    console.log(JSON.stringify({\n      type: 'response',\n      requestId,\n      timestamp: new Date().toISOString(),\n      method,\n      path,\n      status,\n      duration: `${duration}ms`,\n      success: status < 400\n    }));\n    \n    // Add timing header for clients\n    c.header('X-Response-Time', `${duration}ms`);\n    c.header('X-Request-Id', requestId);\n    \n  } catch (error) {\n    // Log error\n    const duration = Date.now() - start;\n    \n    console.error(JSON.stringify({\n      type: 'error',\n      requestId,\n      timestamp: new Date().toISOString(),\n      method,\n      path,\n      duration: `${duration}ms`,\n      error: error.message,\n      stack: process.env.NODE_ENV !== 'production' ? error.stack : undefined\n    }));\n    \n    throw error;  // Re-throw for error handler\n  }\n};\n\n// COLORIZED CONSOLE LOGGER (development)\nconst colorLogger = async (c, next) => {\n  const start = Date.now();\n  const method = c.req.method;\n  const path = c.req.path;\n  \n  // Color codes for terminal\n  const colors = {\n    reset: '\\x1b[0m',\n    green: '\\x1b[32m',\n    yellow: '\\x1b[33m',\n    red: '\\x1b[31m',\n    cyan: '\\x1b[36m',\n    gray: '\\x1b[90m'\n  };\n  \n  const methodColors = {\n    GET: colors.green,\n    POST: colors.yellow,\n    PUT: colors.cyan,\n    DELETE: colors.red,\n    PATCH: colors.yellow\n  };\n  \n  await next();\n  \n  const duration = Date.now() - start;\n  const status = c.res.status;\n  \n  // Color based on status\n  let statusColor = colors.green;\n  if (status >= 400) statusColor = colors.yellow;\n  if (status >= 500) statusColor = colors.red;\n  \n  const methodColor = methodColors[method] || colors.gray;\n  \n  console.log(\n    `${methodColor}${method.padEnd(7)}${colors.reset}` +\n    `${path} ` +\n    `${statusColor}${status}${colors.reset} ` +\n    `${colors.gray}${duration}ms${colors.reset}`\n  );\n};\n\n// REQUEST BODY LOGGER (for debugging)\nconst bodyLogger = async (c, next) => {\n  if (['POST', 'PUT', 'PATCH'].includes(c.req.method)) {\n    try {\n      // Clone the request to read body without consuming it\n      const body = await c.req.json();\n      \n      // Redact sensitive fields\n      const sanitized = { ...body };\n      const sensitiveFields = ['password', 'token', 'secret', 'apiKey', 'creditCard'];\n      \n      for (const field of sensitiveFields) {\n        if (sanitized[field]) {\n          sanitized[field] = '[REDACTED]';\n        }\n      }\n      \n      console.log('Request Body:', JSON.stringify(sanitized, null, 2));\n      \n      // Store for route handler\n      c.set('body', body);\n    } catch (e) {\n      // Not JSON body, skip\n    }\n  }\n  \n  await next();\n};\n\n// SLOW REQUEST DETECTOR\nconst slowRequestLogger = (threshold = 1000) => {\n  return async (c, next) => {\n    const start = Date.now();\n    \n    await next();\n    \n    const duration = Date.now() - start;\n    \n    if (duration > threshold) {\n      console.warn(JSON.stringify({\n        type: 'slow_request',\n        method: c.req.method,\n        path: c.req.path,\n        duration: `${duration}ms`,\n        threshold: `${threshold}ms`,\n        timestamp: new Date().toISOString()\n      }));\n    }\n  };\n};\n\n// APPLY LOGGERS\n\n// Use colorful logger in development\nif (process.env.NODE_ENV !== 'production') {\n  app.use('*', colorLogger);\n} else {\n  app.use('*', productionLogger);\n}\n\n// Log slow requests (> 500ms)\napp.use('*', slowRequestLogger(500));\n\n// ROUTES\n\napp.get('/api/fast', (c) => {\n  return c.json({ message: 'Fast response' });\n});\n\napp.get('/api/slow', async (c) => {\n  // Simulate slow operation\n  await new Promise(r => setTimeout(r, 600));\n  return c.json({ message: 'Slow response' });\n});\n\napp.post('/api/data', async (c) => {\n  const body = c.get('body') || await c.req.json();\n  return c.json({ received: body });\n});\n\nexport default app;\n\n// LOGGING BEST PRACTICES:\n// 1. Use structured JSON logs in production (for log aggregators)\n// 2. Include request IDs for distributed tracing\n// 3. Redact sensitive data (passwords, tokens, etc.)\n// 4. Log both request and response details\n// 5. Track timing for performance monitoring\n// 6. Use different log levels (info, warn, error)"
            },
            {
              "type": "THEORY",
              "title": "Middleware Patterns Summary",
              "content": "Here is a comprehensive summary of essential Hono middleware patterns for building production-ready APIs:\n\n1. **Error Handling Middleware**:\n   - Use `app.onError((err, c) => {...})` for centralized error handling\n   - Use `app.notFound((c) => {...})` for 404 responses\n   - Create custom error classes with statusCode property\n   - Never leak stack traces in production\n   - Log all errors for debugging and security monitoring\n\n2. **JWT Authentication Middleware**:\n   - Extract token from Authorization header (Bearer scheme)\n   - Verify token signature and check expiration\n   - Store decoded payload in context with `c.set('user', payload)`\n   - Chain with role-based access control middleware\n   - Use Hono's built-in `jwt()` middleware for simpler setup\n\n3. **CORS Middleware**:\n   - Use `cors()` from 'hono/cors' for easy setup\n   - Whitelist specific origins in production (never use '*' with credentials)\n   - Configure allowed methods, headers, and max age\n   - Handle preflight OPTIONS requests automatically\n   - Use different CORS configs for public vs private endpoints\n\n4. **Rate Limiting Middleware**:\n   - Track requests per client (IP or API key) in a time window\n   - Return 429 Too Many Requests with Retry-After header\n   - Set X-RateLimit-* headers for client visibility\n   - Use different limits for different endpoints (stricter for auth)\n   - Use Redis for distributed rate limiting in production\n\n5. **Logging Middleware**:\n   - Log requests at start and responses at end\n   - Measure duration between `await next()` calls\n   - Include request ID for distributed tracing\n   - Redact sensitive data from logs\n   - Use structured JSON logs in production\n   - Detect and alert on slow requests\n\n6. **Middleware Ordering Best Practices**:\n   ```\n   1. Logger (first - catches everything)\n   2. Error handler (app.onError)\n   3. CORS (before auth to handle preflight)\n   4. Rate limiter (before expensive operations)\n   5. Authentication (verify identity)\n   6. Authorization (check permissions)\n   7. Validation (check input)\n   8. Route handlers (business logic)\n   ```\n\n7. **Factory Pattern for Reusable Middleware**:\n   ```javascript\n   const requireRole = (...roles) => async (c, next) => {\n     const user = c.get('user');\n     if (!roles.includes(user.role)) {\n       return c.json({ error: 'Forbidden' }, 403);\n     }\n     await next();\n   };\n   \n   app.use('/admin/*', requireRole('admin'));\n   app.use('/api/*', requireRole('user', 'admin'));\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.4-challenge",
              "title": "Practice Challenge",
              "description": "Create a middleware system for a blog API using Hono patterns:\n\n1. Create a logging middleware that logs the method and path\n2. Create a validation middleware that:\n   - For POST requests, parses the body and checks for 'title'\n   - If missing, return 400 error using c.json(error, 400)\n   - If present, store body using c.set('body', body) and await next()\n3. Create a route POST `/api/posts` that:\n   - Gets the body using c.get('body')\n   - Returns the post data with a generated ID\n4. Test with valid and invalid requests\n\nUse the HonoApp class. Remember: async (c, next) and await next()!",
              "instructions": "Create a middleware system for a blog API using Hono patterns:\n\n1. Create a logging middleware that logs the method and path\n2. Create a validation middleware that:\n   - For POST requests, parses the body and checks for 'title'\n   - If missing, return 400 error using c.json(error, 400)\n   - If present, store body using c.set('body', body) and await next()\n3. Create a route POST `/api/posts` that:\n   - Gets the body using c.get('body')\n   - Returns the post data with a generated ID\n4. Test with valid and invalid requests\n\nUse the HonoApp class. Remember: async (c, next) and await next()!",
              "starterCode": "class HonoApp {\n  constructor() { this.routes = []; this.middleware = []; }\n  use(pattern, handler) {\n    if (typeof pattern === 'function') { handler = pattern; pattern = '*'; }\n    this.middleware.push({ pattern, handler });\n  }\n  post(path, handler) { this.routes.push({ method: 'POST', path, handler }); }\n  async simulateRequest(method, path, body) {\n    console.log(`\\n${method} ${path}`);\n    let c = {\n      req: { method, path, json: async () => body || {} },\n      _store: {},\n      set: function(k, v) { this._store[k] = v; },\n      get: function(k) { return this._store[k]; },\n      json: function(d, s = 200) {\n        console.log(`[${s}]`, JSON.stringify(d));\n        return { status: s, body: d };\n      }\n    };\n    let i = 0;\n    let next = async () => {\n      if (i < this.middleware.length) {\n        await this.middleware[i++].handler(c, next);\n      } else {\n        let route = this.routes.find(r => r.method === method && r.path === path);\n        if (route) return route.handler(c);\n      }\n    };\n    await next();\n  }\n}\n\nlet app = new HonoApp();\n\n// TODO: Add logging middleware\n// app.use('*', async (c, next) => { ... await next(); });\n\n// TODO: Add validation middleware\n\n// TODO: Add POST route\n\n// Test\napp.simulateRequest('POST', '/api/posts', { title: 'My Post', content: 'Hello' });\napp.simulateRequest('POST', '/api/posts', { content: 'No title!' });",
              "solution": "class HonoApp {\n  constructor() { this.routes = []; this.middleware = []; }\n  use(pattern, handler) {\n    if (typeof pattern === 'function') { handler = pattern; pattern = '*'; }\n    this.middleware.push({ pattern, handler });\n  }\n  post(path, handler) { this.routes.push({ method: 'POST', path, handler }); }\n  async simulateRequest(method, path, body) {\n    console.log(`\\n${method} ${path}`);\n    let c = {\n      req: { method, path, json: async () => body || {} },\n      _store: {},\n      set: function(k, v) { this._store[k] = v; },\n      get: function(k) { return this._store[k]; },\n      json: function(d, s = 200) {\n        console.log(`[${s}]`, JSON.stringify(d));\n        return { status: s, body: d };\n      }\n    };\n    let i = 0;\n    let next = async () => {\n      if (i < this.middleware.length) {\n        await this.middleware[i++].handler(c, next);\n      } else {\n        let route = this.routes.find(r => r.method === method && r.path === path);\n        if (route) return route.handler(c);\n      }\n    };\n    await next();\n  }\n}\n\nlet app = new HonoApp();\n\n// Middleware 1: Logging\napp.use('*', async (c, next) => {\n  console.log(`[LOG] ${c.req.method} ${c.req.path}`);\n  await next();\n});\n\n// Middleware 2: Validation for POST requests\napp.use('*', async (c, next) => {\n  if (c.req.method === 'POST') {\n    const body = await c.req.json();\n    \n    if (!body || !body.title) {\n      console.log('[VALIDATION] Missing title!');\n      return c.json({ \n        error: 'Validation failed',\n        message: 'Title is required'\n      }, 400);\n      // No next() - stop here!\n    }\n    \n    console.log('[VALIDATION] Title found:', body.title);\n    c.set('body', body);  // Store for route handler\n  }\n  await next();\n});\n\n// Route: Create post\napp.post('/api/posts', (c) => {\n  const body = c.get('body');  // Get from middleware\n  \n  const post = {\n    id: Math.floor(Math.random() * 1000),\n    title: body.title,\n    content: body.content || '',\n    createdAt: new Date().toISOString()\n  };\n  \n  return c.json({\n    message: 'Post created successfully',\n    post: post\n  }, 201);\n});\n\n// Test with valid request\napp.simulateRequest('POST', '/api/posts', { \n  title: 'My First Post', \n  content: 'Hello World!' \n});\n\n// Test with invalid request (missing title)\napp.simulateRequest('POST', '/api/posts', { \n  content: 'No title here!' \n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should validate title exists using Hono patterns",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should detect missing title and return 400",
                  "expectedOutput": "false",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "In Hono middleware, use async (c, next) => { await next(); }. Store data with c.set('key', value) and access with c.get('key')."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to await next() in Hono middleware",
                  "consequence": "Middleware continues before the route handler completes, causing timing issues.",
                  "correction": "Always use: await next(); The await is essential in Hono's async middleware pattern."
                },
                {
                  "mistake": "Using Express (req, res, next) pattern instead of Hono (c, next)",
                  "consequence": "Code will not work with Hono's unified context object.",
                  "correction": "Use async (c, next) => { ... await next(); } pattern. Access request via c.req and respond via c.json()."
                },
                {
                  "mistake": "Mutating context like Express mutates req",
                  "consequence": "Data may be lost or cause unexpected behavior.",
                  "correction": "Use c.set('key', value) to store data and c.get('key') to retrieve it in route handlers."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "11.5",
          "title": "Building a RESTful API with Hono (The Library Catalog Analogy)",
          "moduleId": "module-11",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine managing a library catalog system:\n\nLibrary Operations (RESTful API):\n- GET /books - View all books (like browsing shelves)\n- GET /books/:id - View one specific book (like requesting a book by card number)\n- POST /books - Add a new book (like cataloging a new arrival)\n- PUT /books/:id - Update book info completely (like replacing a catalog card)\n- PATCH /books/:id - Update part of book info (like correcting a typo)\n- DELETE /books/:id - Remove a book (like removing from catalog)\n\nEach operation uses a specific method (GET, POST, etc.) and follows a pattern!\n\nREST = Representational State Transfer\n- A standard way to design APIs\n- Uses HTTP methods correctly\n- Predictable URL patterns\n- Stateless (each request is independent)\n\nHono makes building RESTful APIs simple and fast. The same REST principles apply whether you use Express or Hono!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Hono - RESTful API Example (2025)\n\n// Simulated Hono app\nclass HonoApp {\n  constructor() { this.routes = []; }\n  get(path, handler) { this.routes.push({ method: 'GET', path, handler }); }\n  post(path, handler) { this.routes.push({ method: 'POST', path, handler }); }\n  put(path, handler) { this.routes.push({ method: 'PUT', path, handler }); }\n  delete(path, handler) { this.routes.push({ method: 'DELETE', path, handler }); }\n  \n  async simulateRequest(method, path, body = null) {\n    console.log(`\\n=== ${method} ${path} ===`);\n    if (body) console.log('Body:', JSON.stringify(body));\n    \n    let route = this.routes.find(r => {\n      if (r.method !== method) return false;\n      let routePattern = r.path.replace(':id', '([^/]+)');\n      return new RegExp('^' + routePattern + '$').test(path);\n    });\n    \n    if (route) {\n      let id = path.match(/\\d+$/)?.[0];\n      // Hono context object\n      let c = {\n        req: {\n          param: (key) => key === 'id' ? id : null,\n          json: async () => body || {}\n        },\n        json: function(data, status = 200) {\n          console.log(`Status: ${status}`);\n          console.log('Response:', JSON.stringify(data, null, 2));\n          return { status, body: data };\n        }\n      };\n      await route.handler(c);\n    } else {\n      console.log('Status: 404');\n      console.log('Response: Not Found');\n    }\n  }\n}\n\nlet app = new HonoApp();\n\n// IN-MEMORY DATABASE (simulated)\nlet books = [\n  { id: 1, title: '1984', author: 'George Orwell', year: 1949, available: true },\n  { id: 2, title: 'To Kill a Mockingbird', author: 'Harper Lee', year: 1960, available: true },\n  { id: 3, title: 'The Great Gatsby', author: 'F. Scott Fitzgerald', year: 1925, available: false }\n];\n\nlet nextId = 4;\n\n// RESTful API ROUTES with Hono\n\n// 1. GET /api/books - List all books\napp.get('/api/books', (c) => {\n  return c.json({\n    count: books.length,\n    books: books\n  });\n});\n\n// 2. GET /api/books/:id - Get one book\napp.get('/api/books/:id', (c) => {\n  const id = parseInt(c.req.param('id'));\n  const book = books.find(b => b.id === id);\n  \n  if (!book) {\n    return c.json({ \n      error: 'Book not found',\n      id: id \n    }, 404);\n  }\n  \n  return c.json(book);\n});\n\n// 3. POST /api/books - Create new book\napp.post('/api/books', async (c) => {\n  const body = await c.req.json();\n  \n  // Validation\n  if (!body.title || !body.author) {\n    return c.json({\n      error: 'Validation failed',\n      message: 'Title and author are required'\n    }, 400);\n  }\n  \n  const newBook = {\n    id: nextId++,\n    title: body.title,\n    author: body.author,\n    year: body.year,\n    available: true\n  };\n  \n  books.push(newBook);\n  \n  return c.json({\n    message: 'Book created successfully',\n    book: newBook\n  }, 201);\n});\n\n// 4. PUT /api/books/:id - Update entire book (replace)\napp.put('/api/books/:id', async (c) => {\n  const id = parseInt(c.req.param('id'));\n  const body = await c.req.json();\n  const index = books.findIndex(b => b.id === id);\n  \n  if (index === -1) {\n    return c.json({ error: 'Book not found' }, 404);\n  }\n  \n  // Replace entire book (keeping the ID)\n  books[index] = {\n    id: id,\n    title: body.title,\n    author: body.author,\n    year: body.year,\n    available: body.available\n  };\n  \n  return c.json({\n    message: 'Book updated successfully',\n    book: books[index]\n  });\n});\n\n// 5. DELETE /api/books/:id - Delete a book\napp.delete('/api/books/:id', (c) => {\n  const id = parseInt(c.req.param('id'));\n  const index = books.findIndex(b => b.id === id);\n  \n  if (index === -1) {\n    return c.json({ error: 'Book not found' }, 404);\n  }\n  \n  const deletedBook = books.splice(index, 1)[0];\n  \n  return c.json({\n    message: 'Book deleted successfully',\n    book: deletedBook\n  });\n});\n\n// TEST THE API\n\nconsole.log('\\nRESTful API Demo - Book Library System (Hono)\\n');\n\n// List all books\napp.simulateRequest('GET', '/api/books');\n\n// Get specific book\napp.simulateRequest('GET', '/api/books/1');\n\n// Get non-existent book\napp.simulateRequest('GET', '/api/books/999');\n\n// Create new book\napp.simulateRequest('POST', '/api/books', {\n  title: 'The Hobbit',\n  author: 'J.R.R. Tolkien',\n  year: 1937\n});\n\n// Update book\napp.simulateRequest('PUT', '/api/books/1', {\n  title: '1984',\n  author: 'George Orwell',\n  year: 1949,\n  available: false\n});\n\n// Delete book\napp.simulateRequest('DELETE', '/api/books/2');\n\n// List all books after changes\napp.simulateRequest('GET', '/api/books');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "RESTful API design principles (same for Hono and Express):\n\n1. **HTTP Methods Map to CRUD**:\n   - CREATE -> POST\n   - READ -> GET\n   - UPDATE -> PUT (complete) or PATCH (partial)\n   - DELETE -> DELETE\n\n2. **RESTful URL Patterns**:\n   ```\n   GET    /api/resources      -> List all\n   GET    /api/resources/:id  -> Get one\n   POST   /api/resources      -> Create new\n   PUT    /api/resources/:id  -> Update (replace)\n   PATCH  /api/resources/:id  -> Update (partial)\n   DELETE /api/resources/:id  -> Delete\n   ```\n\n3. **Hono Response Patterns**:\n   ```javascript\n   // Success with default 200\n   return c.json({ data: books });\n   \n   // Created - 201\n   return c.json({ message: 'Created' }, 201);\n   \n   // Error - 404\n   return c.json({ error: 'Not found' }, 404);\n   \n   // Validation error - 400\n   return c.json({ error: 'Invalid input' }, 400);\n   ```\n\n4. **Status Codes**:\n   - 200 OK - Successful GET, PUT, PATCH\n   - 201 Created - Successful POST\n   - 204 No Content - Successful DELETE (no body)\n   - 400 Bad Request - Validation error\n   - 404 Not Found - Resource doesn't exist\n   - 500 Internal Server Error - Server problem\n\n5. **Accessing Data in Hono**:\n   ```javascript\n   // URL parameter\n   const id = c.req.param('id');\n   \n   // Request body (async!)\n   const body = await c.req.json();\n   \n   // Query parameter\n   const search = c.req.query('search');\n   ```\n\n6. **Validation**:\n   ```javascript\n   app.post('/api/books', async (c) => {\n     const body = await c.req.json();\n     \n     if (!body.title) {\n       return c.json({ error: 'Title is required' }, 400);\n     }\n     // ... create book\n   });\n   ```\n\n7. **Real Hono + Bun Server**:\n   ```javascript\n   import { Hono } from 'hono';\n   const app = new Hono();\n   \n   app.get('/api/books', (c) => c.json(books));\n   \n   export default app;  // Bun serves this!\n   ```"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Node.js/Express Equivalent",
              "legacy": "express",
              "content": "The REST principles are identical between Express and Hono. The main differences are in syntax: Hono uses a unified context object and passes status as a second argument.",
              "code": "// Express way\nimport express from 'express';\nconst app = express();\napp.use(express.json());  // Need middleware!\n\napp.get('/api/books/:id', (req, res) => {\n  const id = req.params.id;              // Object property\n  const book = books.find(b => b.id === id);\n  if (!book) {\n    return res.status(404).json({ error: 'Not found' });\n  }\n  res.json(book);\n});\n\napp.post('/api/books', (req, res) => {\n  const body = req.body;                 // Already parsed\n  res.status(201).json({ book: body });\n});\n\napp.listen(3000);\n\n// Hono way (cleaner!)\nimport { Hono } from 'hono';\nconst app = new Hono();\n// No body parsing middleware needed!\n\napp.get('/api/books/:id', (c) => {\n  const id = c.req.param('id');          // Method call\n  const book = books.find(b => b.id === id);\n  if (!book) {\n    return c.json({ error: 'Not found' }, 404);\n  }\n  return c.json(book);\n});\n\napp.post('/api/books', async (c) => {\n  const body = await c.req.json();       // Async!\n  return c.json({ book: body }, 201);\n});\n\nexport default app;  // That's it!",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common RESTful API mistakes (applies to both Hono and Express):\n\n1. **Using verbs in URLs**:\n   ```javascript\n   // Wrong!\n   app.get('/api/getUsers', ...);\n   app.post('/api/createUser', ...);\n   \n   // Correct!\n   app.get('/api/users', ...);\n   app.post('/api/users', ...);\n   ```\n   The HTTP method IS the verb!\n\n2. **Forgetting async for body parsing in Hono**:\n   ```javascript\n   // Wrong!\n   app.post('/api/books', (c) => {\n     const body = c.req.json();  // This is a Promise!\n   });\n   \n   // Correct!\n   app.post('/api/books', async (c) => {\n     const body = await c.req.json();  // Await it!\n   });\n   ```\n\n3. **Wrong status codes**:\n   ```javascript\n   // Wrong in Hono\n   return c.json({ error: 'Not found' });  // Still 200!\n   \n   // Correct\n   return c.json({ error: 'Not found' }, 404);\n   ```\n\n4. **Forgetting to return in Hono**:\n   ```javascript\n   // Wrong - missing return!\n   app.get('/api/books', (c) => {\n     c.json(books);\n   });\n   \n   // Correct\n   app.get('/api/books', (c) => {\n     return c.json(books);\n   });\n   ```\n\n5. **Not validating input**:\n   ```javascript\n   // Always validate!\n   app.post('/api/books', async (c) => {\n     const body = await c.req.json();\n     \n     if (!body.title || !body.author) {\n       return c.json({ error: 'Invalid input' }, 400);\n     }\n     // ... safe to create book\n   });\n   ```\n\n6. **Forgetting to handle not found**:\n   ```javascript\n   app.get('/api/books/:id', (c) => {\n     const book = books.find(...);\n     if (!book) {\n       return c.json({ error: 'Book not found' }, 404);\n     }\n     return c.json(book);\n   });\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.5-challenge",
              "title": "Practice Challenge",
              "description": "Build a RESTful API for managing tasks using Hono patterns:\n\n1. Create an array to store tasks (each has: id, title, completed)\n2. Implement these endpoints using Hono's (c) context:\n   - GET /api/tasks - Return all tasks using c.json()\n   - GET /api/tasks/:id - Return one task (404 if not found)\n   - POST /api/tasks - Create new task (validate title exists)\n   - PUT /api/tasks/:id - Update task completely\n   - DELETE /api/tasks/:id - Delete task\n\n3. Use proper status codes with c.json(data, status):\n   - 200 for successful GET/PUT\n   - 201 for successful POST\n   - 404 for not found\n   - 400 for validation errors\n\n4. Remember: return c.json() and use async for POST/PUT body parsing!",
              "instructions": "Build a RESTful API for managing tasks using Hono patterns:\n\n1. Create an array to store tasks (each has: id, title, completed)\n2. Implement these endpoints using Hono's (c) context:\n   - GET /api/tasks - Return all tasks using c.json()\n   - GET /api/tasks/:id - Return one task (404 if not found)\n   - POST /api/tasks - Create new task (validate title exists)\n   - PUT /api/tasks/:id - Update task completely\n   - DELETE /api/tasks/:id - Delete task\n\n3. Use proper status codes with c.json(data, status):\n   - 200 for successful GET/PUT\n   - 201 for successful POST\n   - 404 for not found\n   - 400 for validation errors\n\n4. Remember: return c.json() and use async for POST/PUT body parsing!",
              "starterCode": "class HonoApp {\n  constructor() { this.routes = []; }\n  get(p, h) { this.routes.push({ method: 'GET', path: p, handler: h }); }\n  post(p, h) { this.routes.push({ method: 'POST', path: p, handler: h }); }\n  put(p, h) { this.routes.push({ method: 'PUT', path: p, handler: h }); }\n  delete(p, h) { this.routes.push({ method: 'DELETE', path: p, handler: h }); }\n  async simulateRequest(method, path, body = null) {\n    console.log(`\\n${method} ${path}`);\n    let id = path.match(/\\d+$/)?.[0];\n    let route = this.routes.find(r => {\n      if (r.method !== method) return false;\n      let pattern = r.path.replace(':id', '([^/]+)');\n      return new RegExp('^' + pattern + '$').test(path);\n    });\n    if (route) {\n      let c = {\n        req: {\n          param: (key) => key === 'id' ? id : null,\n          json: async () => body || {}\n        },\n        json: function(d, s = 200) {\n          console.log(`[${s}]`, JSON.stringify(d));\n          return { status: s, body: d };\n        }\n      };\n      await route.handler(c);\n    }\n  }\n}\n\nlet app = new HonoApp();\n\n// Task storage\nlet tasks = [\n  { id: 1, title: 'Learn Hono', completed: false }\n];\nlet nextId = 2;\n\n// TODO: Implement your routes here using Hono patterns\n// Remember: (c) => { return c.json(data); }\n// For POST/PUT: async (c) => { const body = await c.req.json(); }\n\n// Test\napp.simulateRequest('GET', '/api/tasks');\napp.simulateRequest('POST', '/api/tasks', { title: 'Build API' });\napp.simulateRequest('GET', '/api/tasks/1');\napp.simulateRequest('DELETE', '/api/tasks/1');",
              "solution": "class HonoApp {\n  constructor() { this.routes = []; }\n  get(p, h) { this.routes.push({ method: 'GET', path: p, handler: h }); }\n  post(p, h) { this.routes.push({ method: 'POST', path: p, handler: h }); }\n  put(p, h) { this.routes.push({ method: 'PUT', path: p, handler: h }); }\n  delete(p, h) { this.routes.push({ method: 'DELETE', path: p, handler: h }); }\n  async simulateRequest(method, path, body = null) {\n    console.log(`\\n${method} ${path}`);\n    let id = path.match(/\\d+$/)?.[0];\n    let route = this.routes.find(r => {\n      if (r.method !== method) return false;\n      let pattern = r.path.replace(':id', '([^/]+)');\n      return new RegExp('^' + pattern + '$').test(path);\n    });\n    if (route) {\n      let c = {\n        req: {\n          param: (key) => key === 'id' ? id : null,\n          json: async () => body || {}\n        },\n        json: function(d, s = 200) {\n          console.log(`[${s}]`, JSON.stringify(d, null, 2));\n          return { status: s, body: d };\n        }\n      };\n      await route.handler(c);\n    }\n  }\n}\n\nlet app = new HonoApp();\n\n// Task storage\nlet tasks = [\n  { id: 1, title: 'Learn Hono', completed: false },\n  { id: 2, title: 'Build API', completed: true }\n];\nlet nextId = 3;\n\n// GET /api/tasks - List all\napp.get('/api/tasks', (c) => {\n  return c.json({ count: tasks.length, tasks });\n});\n\n// GET /api/tasks/:id - Get one\napp.get('/api/tasks/:id', (c) => {\n  const task = tasks.find(t => t.id === parseInt(c.req.param('id')));\n  if (!task) {\n    return c.json({ error: 'Task not found' }, 404);\n  }\n  return c.json(task);\n});\n\n// POST /api/tasks - Create\napp.post('/api/tasks', async (c) => {\n  const body = await c.req.json();\n  \n  if (!body.title) {\n    return c.json({ error: 'Title is required' }, 400);\n  }\n  \n  const newTask = {\n    id: nextId++,\n    title: body.title,\n    completed: false\n  };\n  tasks.push(newTask);\n  \n  return c.json({ message: 'Task created', task: newTask }, 201);\n});\n\n// PUT /api/tasks/:id - Update\napp.put('/api/tasks/:id', async (c) => {\n  const id = parseInt(c.req.param('id'));\n  const body = await c.req.json();\n  const index = tasks.findIndex(t => t.id === id);\n  \n  if (index === -1) {\n    return c.json({ error: 'Task not found' }, 404);\n  }\n  \n  tasks[index] = {\n    id: id,\n    title: body.title,\n    completed: body.completed\n  };\n  \n  return c.json({ message: 'Task updated', task: tasks[index] });\n});\n\n// DELETE /api/tasks/:id - Delete\napp.delete('/api/tasks/:id', (c) => {\n  const id = parseInt(c.req.param('id'));\n  const index = tasks.findIndex(t => t.id === id);\n  \n  if (index === -1) {\n    return c.json({ error: 'Task not found' }, 404);\n  }\n  \n  const deleted = tasks.splice(index, 1)[0];\n  return c.json({ message: 'Task deleted', task: deleted });\n});\n\n// Tests\nconsole.log('=== Task API Demo (Hono) ===');\napp.simulateRequest('GET', '/api/tasks');\napp.simulateRequest('GET', '/api/tasks/1');\napp.simulateRequest('POST', '/api/tasks', { title: 'Deploy app' });\napp.simulateRequest('PUT', '/api/tasks/1', { title: 'Learn Hono', completed: true });\napp.simulateRequest('DELETE', '/api/tasks/2');\napp.simulateRequest('GET', '/api/tasks');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should find task by id using Hono patterns",
                  "expectedOutput": "Test",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should validate task has title",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use c.req.param('id') to get the ID. For POST/PUT, use async and await c.req.json() to parse body. Always return c.json()!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to return c.json() in Hono route handlers",
                  "consequence": "No response is sent to the client.",
                  "correction": "Always use return c.json(data) or return c.json(data, statusCode)."
                },
                {
                  "mistake": "Not using async/await for c.req.json() in POST/PUT handlers",
                  "consequence": "You get a Promise object instead of the parsed body.",
                  "correction": "Use async (c) => { const body = await c.req.json(); ... }"
                },
                {
                  "mistake": "Using Express syntax res.status(404).json() instead of Hono's c.json(data, 404)",
                  "consequence": "Code will not work with Hono's API.",
                  "correction": "In Hono, pass status as second argument: return c.json({ error: 'Not found' }, 404)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "11.6",
          "title": "Request Validation with Zod (The Border Security Analogy)",
          "moduleId": "module-11",
          "order": 6,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "CONCEPT",
              "title": "Why Validate API Input?",
              "content": "Imagine you are building a border checkpoint for a country. Anyone can approach your border, but you must verify their documents before letting them through. You check passports, visas, and declarations. Without this checkpoint, anyone could enter with forged papers, dangerous items, or false identities.\n\nYour API endpoints are exactly like border checkpoints. Data arrives from the outside world - users, mobile apps, third-party services - and you have no control over what they send. They might send malformed JSON, wrong data types, missing fields, or even malicious payloads designed to exploit your system.\n\nValidation at the API boundary is your first line of defense. It catches problems early, before bad data reaches your business logic or database. Here is why this matters:\n\n**Security**: Without validation, attackers can send SQL injection strings, oversized payloads that crash your server, or specially crafted data that exploits vulnerabilities. Proper validation sanitizes and rejects malicious input before it causes damage.\n\n**Data Integrity**: Your database schema expects specific types and formats. If someone sends a string where you expect a number, your application crashes or corrupts data. Validation ensures only clean, correctly-typed data enters your system.\n\n**TypeScript Integration**: JavaScript is dynamically typed at runtime. Even if TypeScript compiles your code correctly, incoming JSON has type 'any'. Zod bridges this gap by validating runtime data and inferring TypeScript types from schemas, giving you end-to-end type safety.\n\n**Developer Experience**: Good validation provides clear error messages that help API consumers fix their requests. Instead of cryptic database errors, users get helpful feedback like 'email must be a valid email address'.\n\n**Why Zod?**: Zod is a TypeScript-first schema validation library. Unlike older libraries like Joi or Yup, Zod was built for TypeScript from the ground up. It infers types automatically, has zero dependencies, and integrates seamlessly with modern frameworks like Hono."
            },
            {
              "type": "CODE",
              "title": "Zod Schema Basics",
              "content": "Zod provides primitive validators for all JavaScript types, plus powerful combinators for complex structures. The key insight is that a Zod schema serves two purposes: runtime validation and compile-time type inference. When you define a schema, you get both validation logic and a TypeScript type for free.",
              "language": "typescript",
              "code": "// Zod Schema Basics - Foundation of API Validation\nimport { z } from 'zod';\n\n// PRIMITIVE TYPES\n// Zod has validators for all JavaScript primitives\n\nconst stringSchema = z.string();\nconst numberSchema = z.number();\nconst booleanSchema = z.boolean();\nconst dateSchema = z.date();\nconst bigintSchema = z.bigint();\nconst symbolSchema = z.symbol();\nconst undefinedSchema = z.undefined();\nconst nullSchema = z.null();\n\n// STRING VALIDATORS WITH BUILT-IN REFINEMENTS\nconst emailSchema = z.string().email();           // Must be valid email\nconst urlSchema = z.string().url();               // Must be valid URL\nconst uuidSchema = z.string().uuid();             // Must be valid UUID\nconst minLengthSchema = z.string().min(3);        // At least 3 characters\nconst maxLengthSchema = z.string().max(100);      // At most 100 characters\nconst lengthSchema = z.string().length(10);       // Exactly 10 characters\nconst regexSchema = z.string().regex(/^[A-Z]+$/); // Must match pattern\nconst trimmedSchema = z.string().trim();          // Trims whitespace\nconst lowercaseSchema = z.string().toLowerCase(); // Converts to lowercase\n\n// NUMBER VALIDATORS\nconst positiveSchema = z.number().positive();     // > 0\nconst negativeSchema = z.number().negative();     // < 0\nconst intSchema = z.number().int();               // Must be integer\nconst minSchema = z.number().min(0);              // >= 0\nconst maxSchema = z.number().max(100);            // <= 100\nconst multipleOfSchema = z.number().multipleOf(5); // Must be divisible by 5\n\n// OBJECT SCHEMAS - The Foundation of API Validation\nconst userSchema = z.object({\n  id: z.number().int().positive(),\n  name: z.string().min(1).max(100),\n  email: z.string().email(),\n  age: z.number().int().min(0).max(150).optional(),\n  isActive: z.boolean().default(true)\n});\n\n// TWO WAYS TO VALIDATE: parse() vs safeParse()\n\n// 1. parse() - Throws ZodError if validation fails\ntry {\n  const validUser = userSchema.parse({\n    id: 1,\n    name: 'Alice',\n    email: 'alice@example.com'\n  });\n  console.log('Valid user:', validUser);\n  // validUser has type { id: number; name: string; email: string; age?: number; isActive: boolean }\n} catch (error) {\n  if (error instanceof z.ZodError) {\n    console.error('Validation failed:', error.errors);\n  }\n}\n\n// 2. safeParse() - Returns result object, never throws\nconst result = userSchema.safeParse({\n  id: 'not-a-number',  // Wrong type!\n  name: '',            // Too short!\n  email: 'invalid'     // Not an email!\n});\n\nif (result.success) {\n  console.log('Valid:', result.data);\n} else {\n  console.log('Invalid:', result.error.errors);\n  // [\n  //   { path: ['id'], message: 'Expected number, received string' },\n  //   { path: ['name'], message: 'String must contain at least 1 character(s)' },\n  //   { path: ['email'], message: 'Invalid email' }\n  // ]\n}\n\n// TYPE INFERENCE - Get TypeScript types from schemas\ntype User = z.infer<typeof userSchema>;\n// Equivalent to:\n// type User = {\n//   id: number;\n//   name: string;\n//   email: string;\n//   age?: number | undefined;\n//   isActive: boolean;\n// }\n\n// Now you can use the inferred type throughout your codebase\nfunction createUser(userData: User): void {\n  console.log(`Creating user: ${userData.name}`);\n}\n\n// PRACTICAL EXAMPLE: API Request Body Validation\nconst createPostSchema = z.object({\n  title: z.string().min(1, 'Title is required').max(200, 'Title too long'),\n  content: z.string().min(10, 'Content must be at least 10 characters'),\n  tags: z.array(z.string()).min(1, 'At least one tag required').max(5, 'Maximum 5 tags'),\n  publishedAt: z.string().datetime().optional()\n});\n\ntype CreatePostInput = z.infer<typeof createPostSchema>;\n\n// Simulating incoming API request\nconst requestBody = {\n  title: 'Learning Zod',\n  content: 'Zod is a powerful validation library for TypeScript...',\n  tags: ['typescript', 'validation']\n};\n\nconst validatedPost = createPostSchema.safeParse(requestBody);\nif (validatedPost.success) {\n  console.log('Post is valid:', validatedPost.data);\n} else {\n  console.log('Validation errors:', validatedPost.error.flatten());\n}"
            },
            {
              "type": "CODE",
              "title": "Schema Composition",
              "content": "Real-world APIs deal with complex nested structures, arrays of objects, optional fields with defaults, and data that needs transformation. Zod provides powerful composition tools to build these complex schemas from simpler parts. Think of it like LEGO blocks - you build complex structures by combining simple pieces.",
              "language": "typescript",
              "code": "// Zod Schema Composition - Building Complex Structures\nimport { z } from 'zod';\n\n// NESTED OBJECTS - Objects inside objects\nconst addressSchema = z.object({\n  street: z.string().min(1),\n  city: z.string().min(1),\n  zipCode: z.string().regex(/^\\d{5}(-\\d{4})?$/, 'Invalid ZIP code'),\n  country: z.string().length(2)  // ISO country code\n});\n\nconst companySchema = z.object({\n  name: z.string(),\n  address: addressSchema,  // Nested object!\n  founded: z.number().int().min(1800).max(new Date().getFullYear())\n});\n\n// ARRAYS - Lists of items\nconst tagsSchema = z.array(z.string());\nconst numbersSchema = z.array(z.number()).min(1).max(10);  // 1-10 items\n\n// Array of objects - very common in APIs\nconst orderItemSchema = z.object({\n  productId: z.string().uuid(),\n  quantity: z.number().int().positive(),\n  price: z.number().positive()\n});\n\nconst orderSchema = z.object({\n  orderId: z.string().uuid(),\n  customerId: z.string().uuid(),\n  items: z.array(orderItemSchema).min(1, 'Order must have at least one item'),\n  total: z.number().positive()\n});\n\n// OPTIONAL FIELDS - Field may or may not exist\nconst profileSchema = z.object({\n  username: z.string(),\n  bio: z.string().optional(),           // string | undefined\n  website: z.string().url().optional(),\n  avatarUrl: z.string().url().nullable() // string | null (different from optional!)\n});\n\n// DEFAULT VALUES - Provide value if missing\nconst settingsSchema = z.object({\n  theme: z.enum(['light', 'dark']).default('light'),\n  notifications: z.boolean().default(true),\n  language: z.string().default('en'),\n  itemsPerPage: z.number().int().min(10).max(100).default(25)\n});\n\nconst inputSettings = {};  // Empty input\nconst settings = settingsSchema.parse(inputSettings);\nconsole.log(settings);\n// { theme: 'light', notifications: true, language: 'en', itemsPerPage: 25 }\n\n// TRANSFORMS - Convert data during validation\nconst dateStringSchema = z.string()\n  .transform((str) => new Date(str));  // string -> Date\n\nconst lowercaseEmailSchema = z.string()\n  .email()\n  .transform((email) => email.toLowerCase());  // Normalize email\n\nconst trimmedStringSchema = z.string()\n  .transform((s) => s.trim())  // Remove whitespace\n  .pipe(z.string().min(1));    // Then validate non-empty\n\n// Parse comma-separated string into array\nconst csvToArraySchema = z.string()\n  .transform((str) => str.split(',').map(s => s.trim()))\n  .pipe(z.array(z.string()));\n\nconst tags = csvToArraySchema.parse('javascript, typescript, zod');\nconsole.log(tags);  // ['javascript', 'typescript', 'zod']\n\n// COERCION - Convert types automatically\nconst coercedNumber = z.coerce.number();  // '42' -> 42\nconst coercedBoolean = z.coerce.boolean(); // 'true' -> true\nconst coercedDate = z.coerce.date();       // '2024-01-01' -> Date\n\nconsole.log(coercedNumber.parse('123'));     // 123 (number)\nconsole.log(coercedBoolean.parse('false'));  // false (boolean)\n\n// UNIONS - Value can be one of several types\nconst stringOrNumber = z.union([z.string(), z.number()]);\nconsole.log(stringOrNumber.parse('hello'));  // 'hello'\nconsole.log(stringOrNumber.parse(42));       // 42\n\n// DISCRIMINATED UNIONS - Powerful pattern for API responses\nconst apiResponseSchema = z.discriminatedUnion('status', [\n  z.object({\n    status: z.literal('success'),\n    data: z.object({\n      id: z.number(),\n      name: z.string()\n    })\n  }),\n  z.object({\n    status: z.literal('error'),\n    error: z.object({\n      code: z.string(),\n      message: z.string()\n    })\n  })\n]);\n\ntype ApiResponse = z.infer<typeof apiResponseSchema>;\n\n// TypeScript knows the shape based on 'status'\nfunction handleResponse(response: ApiResponse) {\n  if (response.status === 'success') {\n    console.log(response.data.name);  // TypeScript knows data exists\n  } else {\n    console.log(response.error.message);  // TypeScript knows error exists\n  }\n}\n\n// EXTENDING AND MERGING SCHEMAS\nconst baseUserSchema = z.object({\n  id: z.string().uuid(),\n  email: z.string().email(),\n  createdAt: z.string().datetime()\n});\n\n// Extend adds new fields\nconst adminUserSchema = baseUserSchema.extend({\n  role: z.literal('admin'),\n  permissions: z.array(z.string())\n});\n\n// Merge combines two schemas\nconst profileInfoSchema = z.object({\n  displayName: z.string(),\n  avatarUrl: z.string().url().optional()\n});\n\nconst fullUserSchema = baseUserSchema.merge(profileInfoSchema);\n\n// PICK AND OMIT - Select specific fields\nconst createUserInput = baseUserSchema.omit({ id: true, createdAt: true });\n// Only { email: string }\n\nconst publicUserInfo = baseUserSchema.pick({ id: true, email: true });\n// Only { id: string; email: string }\n\n// PARTIAL - Make all fields optional\nconst updateUserSchema = baseUserSchema.partial();\n// All fields are now optional for PATCH requests\n\n// REQUIRED - Make all fields required\nconst strictUserSchema = baseUserSchema.partial().required();\n// Undo partial - all fields required again\n\ntype CreateUser = z.infer<typeof createUserInput>;\ntype UpdateUser = z.infer<typeof updateUserSchema>;"
            },
            {
              "type": "CODE",
              "title": "Custom Validations",
              "content": "Sometimes built-in validators are not enough. You need custom business logic - password confirmation must match, dates must be in the future, or a field depends on another field value. Zod provides refine() for simple validations and superRefine() for complex scenarios with multiple error paths.",
              "language": "typescript",
              "code": "// Zod Custom Validations - Beyond Built-in Rules\nimport { z } from 'zod';\n\n// REFINE - Add custom validation logic\n// Returns true if valid, false if invalid\n\nconst passwordSchema = z.string()\n  .min(8, 'Password must be at least 8 characters')\n  .refine(\n    (password) => /[A-Z]/.test(password),\n    { message: 'Password must contain at least one uppercase letter' }\n  )\n  .refine(\n    (password) => /[a-z]/.test(password),\n    { message: 'Password must contain at least one lowercase letter' }\n  )\n  .refine(\n    (password) => /[0-9]/.test(password),\n    { message: 'Password must contain at least one number' }\n  )\n  .refine(\n    (password) => /[!@#$%^&*]/.test(password),\n    { message: 'Password must contain at least one special character (!@#$%^&*)' }\n  );\n\n// Test password validation\nconst weakPassword = passwordSchema.safeParse('weak');\nconsole.log(weakPassword.success);  // false\nif (!weakPassword.success) {\n  console.log(weakPassword.error.errors[0].message);\n  // 'Password must be at least 8 characters'\n}\n\nconst strongPassword = passwordSchema.safeParse('SecurePass123!');\nconsole.log(strongPassword.success);  // true\n\n// REFINE ON OBJECTS - Cross-field validation\nconst registrationSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8),\n  confirmPassword: z.string()\n}).refine(\n  (data) => data.password === data.confirmPassword,\n  {\n    message: 'Passwords do not match',\n    path: ['confirmPassword']  // Error appears on this field\n  }\n);\n\nconst badRegistration = registrationSchema.safeParse({\n  email: 'user@example.com',\n  password: 'SecurePass123',\n  confirmPassword: 'DifferentPass456'\n});\n\nif (!badRegistration.success) {\n  console.log(badRegistration.error.errors);\n  // [{ path: ['confirmPassword'], message: 'Passwords do not match' }]\n}\n\n// DATE RANGE VALIDATION\nconst dateRangeSchema = z.object({\n  startDate: z.coerce.date(),\n  endDate: z.coerce.date()\n}).refine(\n  (data) => data.endDate > data.startDate,\n  {\n    message: 'End date must be after start date',\n    path: ['endDate']\n  }\n);\n\n// FUTURE DATE VALIDATION\nconst futureDateSchema = z.coerce.date().refine(\n  (date) => date > new Date(),\n  { message: 'Date must be in the future' }\n);\n\n// SUPERREFINE - For complex multi-error validations\nconst advancedPasswordSchema = z.string().superRefine((password, ctx) => {\n  // ctx.addIssue() allows adding multiple errors\n  \n  if (password.length < 8) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: 'Password must be at least 8 characters',\n      fatal: true  // Stop further checks if this fails\n    });\n    return;  // Early return on fatal error\n  }\n  \n  const checks = [\n    { test: /[A-Z]/, message: 'Missing uppercase letter' },\n    { test: /[a-z]/, message: 'Missing lowercase letter' },\n    { test: /[0-9]/, message: 'Missing number' },\n    { test: /[!@#$%^&*]/, message: 'Missing special character' }\n  ];\n  \n  // Add ALL failing checks as separate errors\n  for (const check of checks) {\n    if (!check.test.test(password)) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: check.message\n      });\n    }\n  }\n});\n\n// Test - will show ALL errors at once\nconst weakResult = advancedPasswordSchema.safeParse('abc');\nif (!weakResult.success) {\n  console.log('All password errors:');\n  weakResult.error.errors.forEach(err => console.log(`  - ${err.message}`));\n  // - Password must be at least 8 characters\n}\n\n// CONDITIONAL VALIDATION WITH SUPERREFINE\nconst paymentSchema = z.object({\n  method: z.enum(['credit_card', 'paypal', 'bank_transfer']),\n  cardNumber: z.string().optional(),\n  paypalEmail: z.string().email().optional(),\n  bankAccount: z.string().optional()\n}).superRefine((data, ctx) => {\n  if (data.method === 'credit_card' && !data.cardNumber) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: 'Card number is required for credit card payments',\n      path: ['cardNumber']\n    });\n  }\n  \n  if (data.method === 'paypal' && !data.paypalEmail) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: 'PayPal email is required for PayPal payments',\n      path: ['paypalEmail']\n    });\n  }\n  \n  if (data.method === 'bank_transfer' && !data.bankAccount) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: 'Bank account is required for bank transfers',\n      path: ['bankAccount']\n    });\n  }\n});\n\n// CUSTOM ERROR MESSAGES - Various approaches\nconst userSchema = z.object({\n  // Inline message as second argument\n  name: z.string().min(1, 'Name cannot be empty'),\n  \n  // Object with message property\n  email: z.string().email({ message: 'Please enter a valid email address' }),\n  \n  // Multiple messages for different validations\n  age: z.number({\n    required_error: 'Age is required',\n    invalid_type_error: 'Age must be a number'\n  }).int('Age must be a whole number')\n    .min(18, 'Must be at least 18 years old')\n    .max(120, 'Age seems unrealistic')\n});\n\n// REUSABLE CUSTOM VALIDATORS\nconst isValidPhoneNumber = (phone: string) => {\n  const phoneRegex = /^\\+?[1-9]\\d{1,14}$/;  // E.164 format\n  return phoneRegex.test(phone.replace(/[\\s-]/g, ''));\n};\n\nconst phoneSchema = z.string()\n  .transform(phone => phone.replace(/[\\s-]/g, ''))  // Remove spaces and dashes\n  .refine(isValidPhoneNumber, {\n    message: 'Invalid phone number. Use format: +1234567890'\n  });\n\n// ASYNC VALIDATION - For database lookups, API calls, etc.\nconst uniqueEmailSchema = z.string().email().refine(\n  async (email) => {\n    // Simulate database check\n    const existingEmails = ['taken@example.com', 'used@example.com'];\n    await new Promise(resolve => setTimeout(resolve, 100));  // Simulate delay\n    return !existingEmails.includes(email);\n  },\n  { message: 'This email is already registered' }\n);\n\n// Must use parseAsync for async refinements\nasync function validateEmail(email: string) {\n  const result = await uniqueEmailSchema.safeParseAsync(email);\n  console.log(result.success ? 'Email available' : 'Email taken');\n}\n\nvalidateEmail('new@example.com');  // Email available\nvalidateEmail('taken@example.com'); // Email taken"
            },
            {
              "type": "CODE",
              "title": "Integrating with Hono",
              "content": "The @hono/zod-validator package provides seamless integration between Zod schemas and Hono route handlers. It validates request body, query parameters, URL parameters, and headers automatically. When validation fails, it returns a 400 error with detailed messages. When validation succeeds, your handler receives fully typed data.",
              "language": "typescript",
              "code": "// Zod Integration with Hono - Type-Safe API Validation\nimport { Hono } from 'hono';\nimport { zValidator } from '@hono/zod-validator';\nimport { z } from 'zod';\n\nconst app = new Hono();\n\n// DEFINE YOUR SCHEMAS\nconst createUserSchema = z.object({\n  name: z.string().min(1).max(100),\n  email: z.string().email(),\n  password: z.string().min(8),\n  age: z.number().int().min(18).optional()\n});\n\nconst updateUserSchema = createUserSchema.partial();  // All fields optional\n\nconst userIdParamSchema = z.object({\n  id: z.string().uuid()\n});\n\nconst paginationQuerySchema = z.object({\n  page: z.coerce.number().int().min(1).default(1),\n  limit: z.coerce.number().int().min(1).max(100).default(20),\n  sortBy: z.enum(['name', 'email', 'createdAt']).default('createdAt'),\n  order: z.enum(['asc', 'desc']).default('desc')\n});\n\nconst searchQuerySchema = z.object({\n  q: z.string().min(1).optional(),\n  category: z.string().optional(),\n  minPrice: z.coerce.number().min(0).optional(),\n  maxPrice: z.coerce.number().min(0).optional()\n}).refine(\n  (data) => !data.minPrice || !data.maxPrice || data.minPrice <= data.maxPrice,\n  { message: 'minPrice must be less than or equal to maxPrice', path: ['minPrice'] }\n);\n\n// VALIDATE REQUEST BODY\napp.post(\n  '/api/users',\n  zValidator('json', createUserSchema),  // Validates body\n  async (c) => {\n    // c.req.valid('json') returns typed, validated data\n    const userData = c.req.valid('json');\n    // userData has type: { name: string; email: string; password: string; age?: number }\n    \n    // Safe to use - already validated!\n    console.log(`Creating user: ${userData.name} <${userData.email}>`);\n    \n    return c.json({\n      message: 'User created',\n      user: {\n        id: crypto.randomUUID(),\n        name: userData.name,\n        email: userData.email\n        // Note: Don't return password!\n      }\n    }, 201);\n  }\n);\n\n// VALIDATE URL PARAMETERS\napp.get(\n  '/api/users/:id',\n  zValidator('param', userIdParamSchema),  // Validates :id param\n  async (c) => {\n    const { id } = c.req.valid('param');\n    // id is guaranteed to be a valid UUID string\n    \n    // Simulate database lookup\n    const user = { id, name: 'Alice', email: 'alice@example.com' };\n    \n    return c.json(user);\n  }\n);\n\n// VALIDATE QUERY PARAMETERS\napp.get(\n  '/api/users',\n  zValidator('query', paginationQuerySchema),  // Validates query string\n  async (c) => {\n    const { page, limit, sortBy, order } = c.req.valid('query');\n    // All values are typed and have defaults applied\n    \n    console.log(`Fetching page ${page}, ${limit} items, sorted by ${sortBy} ${order}`);\n    \n    return c.json({\n      page,\n      limit,\n      total: 100,\n      users: []\n    });\n  }\n);\n\n// COMBINE MULTIPLE VALIDATORS\napp.put(\n  '/api/users/:id',\n  zValidator('param', userIdParamSchema),\n  zValidator('json', updateUserSchema),\n  async (c) => {\n    const { id } = c.req.valid('param');\n    const updates = c.req.valid('json');\n    \n    console.log(`Updating user ${id} with:`, updates);\n    \n    return c.json({\n      message: 'User updated',\n      userId: id,\n      updates\n    });\n  }\n);\n\n// VALIDATE HEADERS\nconst authHeaderSchema = z.object({\n  authorization: z.string().regex(/^Bearer .+$/, 'Invalid authorization header')\n});\n\napp.get(\n  '/api/protected',\n  zValidator('header', authHeaderSchema),\n  async (c) => {\n    const headers = c.req.valid('header');\n    const token = headers.authorization.replace('Bearer ', '');\n    \n    return c.json({ message: 'Access granted', token: token.substring(0, 10) + '...' });\n  }\n);\n\n// CUSTOM ERROR HANDLING\n// By default, zValidator returns 400 with error details\n// You can customize this behavior:\n\nconst customErrorHandler = (result: { success: boolean; error?: z.ZodError }, c: any) => {\n  if (!result.success) {\n    return c.json({\n      success: false,\n      error: 'Validation failed',\n      details: result.error?.errors.map(err => ({\n        field: err.path.join('.'),\n        message: err.message\n      }))\n    }, 400);\n  }\n};\n\napp.post(\n  '/api/products',\n  zValidator('json', z.object({\n    name: z.string().min(1),\n    price: z.number().positive(),\n    quantity: z.number().int().min(0)\n  }), customErrorHandler),  // Third argument is error handler\n  async (c) => {\n    const product = c.req.valid('json');\n    return c.json({ created: product }, 201);\n  }\n);\n\n// COMBINING WITH OTHER MIDDLEWARE\nimport { jwt } from 'hono/jwt';\nimport { cors } from 'hono/cors';\n\napp.use('/api/*', cors());\napp.use('/api/protected/*', jwt({ secret: 'your-secret' }));\n\napp.post(\n  '/api/protected/posts',\n  zValidator('json', z.object({\n    title: z.string().min(1).max(200),\n    content: z.string().min(10)\n  })),\n  async (c) => {\n    const post = c.req.valid('json');\n    const jwtPayload = c.get('jwtPayload');  // From JWT middleware\n    \n    return c.json({\n      post,\n      author: jwtPayload.sub\n    }, 201);\n  }\n);\n\n// TYPE INFERENCE FROM SCHEMAS TO HANDLERS\n// Extract types for use elsewhere in your app\n\ntype CreateUserInput = z.infer<typeof createUserSchema>;\ntype UpdateUserInput = z.infer<typeof updateUserSchema>;\ntype PaginationQuery = z.infer<typeof paginationQuerySchema>;\n\n// Use in service layer\nfunction createUserInDatabase(userData: CreateUserInput) {\n  // Type-safe function signature\n  console.log(`Inserting ${userData.email} into database`);\n}\n\nexport default app;"
            },
            {
              "type": "CODE",
              "title": "Error Response Formatting",
              "content": "When validation fails, raw Zod errors contain detailed information but are not user-friendly. A good API formats these errors into consistent, helpful responses that frontend developers and API consumers can easily understand and display to users. Here is how to transform ZodErrors into clean API responses.",
              "language": "typescript",
              "code": "// Zod Error Response Formatting - User-Friendly API Errors\nimport { z } from 'zod';\nimport { Hono } from 'hono';\nimport { zValidator } from '@hono/zod-validator';\n\n// UNDERSTANDING ZODERROR STRUCTURE\n// When validation fails, ZodError contains an 'errors' array\n// Each error has: code, message, path, and possibly other fields\n\nconst exampleSchema = z.object({\n  name: z.string().min(1),\n  email: z.string().email(),\n  age: z.number().int().min(18)\n});\n\nconst badData = { name: '', email: 'invalid', age: 15 };\nconst result = exampleSchema.safeParse(badData);\n\nif (!result.success) {\n  console.log('Raw ZodError:', JSON.stringify(result.error.errors, null, 2));\n  // [\n  //   { code: 'too_small', path: ['name'], message: 'String must contain at least 1 character(s)' },\n  //   { code: 'invalid_string', path: ['email'], message: 'Invalid email' },\n  //   { code: 'too_small', path: ['age'], message: 'Number must be greater than or equal to 18' }\n  // ]\n}\n\n// FORMATTING HELPER FUNCTIONS\n\n// 1. Simple flat format - good for most cases\nfunction formatZodErrors(error: z.ZodError): Record<string, string> {\n  const formatted: Record<string, string> = {};\n  \n  for (const issue of error.errors) {\n    const path = issue.path.join('.');\n    // Only keep first error per field\n    if (!formatted[path]) {\n      formatted[path] = issue.message;\n    }\n  }\n  \n  return formatted;\n}\n\n// Usage\nif (!result.success) {\n  console.log('Formatted errors:', formatZodErrors(result.error));\n  // { name: 'String must contain at least 1 character(s)', email: 'Invalid email', age: '...' }\n}\n\n// 2. Array format with field paths - for frontend forms\nfunction formatZodErrorsArray(error: z.ZodError) {\n  return error.errors.map(issue => ({\n    field: issue.path.join('.'),\n    message: issue.message,\n    code: issue.code\n  }));\n}\n\n// 3. Zod's built-in flatten() - very useful!\nif (!result.success) {\n  const flattened = result.error.flatten();\n  console.log('Flattened:', flattened);\n  // {\n  //   formErrors: [],  // Top-level errors\n  //   fieldErrors: {   // Per-field errors\n  //     name: ['String must contain at least 1 character(s)'],\n  //     email: ['Invalid email'],\n  //     age: ['Number must be greater than or equal to 18']\n  //   }\n  // }\n}\n\n// HONO ERROR RESPONSE FACTORY\nconst app = new Hono();\n\n// Standard API error response structure\ninterface ApiError {\n  success: false;\n  error: {\n    type: string;\n    message: string;\n    details?: Array<{\n      field: string;\n      message: string;\n    }>;\n  };\n}\n\n// Create a reusable validation error handler\nfunction createValidationErrorHandler(target: string) {\n  return (result: { success: boolean; error?: z.ZodError }, c: any) => {\n    if (!result.success && result.error) {\n      const response: ApiError = {\n        success: false,\n        error: {\n          type: 'VALIDATION_ERROR',\n          message: `Invalid ${target} data`,\n          details: result.error.errors.map(err => ({\n            field: err.path.join('.'),\n            message: err.message\n          }))\n        }\n      };\n      \n      return c.json(response, 400);\n    }\n  };\n}\n\n// Use in routes\nconst userSchema = z.object({\n  name: z.string().min(1, 'Name is required'),\n  email: z.string().email('Please provide a valid email'),\n  password: z.string().min(8, 'Password must be at least 8 characters')\n});\n\napp.post(\n  '/api/users',\n  zValidator('json', userSchema, createValidationErrorHandler('user')),\n  async (c) => {\n    const user = c.req.valid('json');\n    return c.json({ success: true, user }, 201);\n  }\n);\n\n// I18N CONSIDERATIONS - Internationalized error messages\n// Store messages separately for translation\n\nconst errorMessages = {\n  en: {\n    required: (field: string) => `${field} is required`,\n    email: 'Please enter a valid email address',\n    minLength: (field: string, min: number) => `${field} must be at least ${min} characters`,\n    maxLength: (field: string, max: number) => `${field} must be at most ${max} characters`,\n    positive: (field: string) => `${field} must be a positive number`,\n    integer: (field: string) => `${field} must be a whole number`\n  },\n  es: {\n    required: (field: string) => `${field} es obligatorio`,\n    email: 'Por favor ingrese un correo valido',\n    minLength: (field: string, min: number) => `${field} debe tener al menos ${min} caracteres`,\n    maxLength: (field: string, max: number) => `${field} debe tener como maximo ${max} caracteres`,\n    positive: (field: string) => `${field} debe ser un numero positivo`,\n    integer: (field: string) => `${field} debe ser un numero entero`\n  }\n};\n\ntype Locale = keyof typeof errorMessages;\n\n// Schema factory with locale support\nfunction createUserSchemaForLocale(locale: Locale) {\n  const t = errorMessages[locale];\n  \n  return z.object({\n    name: z.string()\n      .min(1, t.required('Name'))\n      .max(100, t.maxLength('Name', 100)),\n    email: z.string()\n      .email(t.email),\n    age: z.number()\n      .int(t.integer('Age'))\n      .positive(t.positive('Age'))\n  });\n}\n\n// Middleware to set locale from Accept-Language header\napp.use('/api/*', async (c, next) => {\n  const acceptLanguage = c.req.header('Accept-Language') || 'en';\n  const locale = acceptLanguage.startsWith('es') ? 'es' : 'en';\n  c.set('locale', locale);\n  await next();\n});\n\n// Route with i18n validation\napp.post('/api/i18n/users', async (c) => {\n  const locale = c.get('locale') as Locale;\n  const schema = createUserSchemaForLocale(locale);\n  \n  const body = await c.req.json();\n  const result = schema.safeParse(body);\n  \n  if (!result.success) {\n    return c.json({\n      success: false,\n      errors: formatZodErrorsArray(result.error)\n    }, 400);\n  }\n  \n  return c.json({ success: true, user: result.data }, 201);\n});\n\n// CONSISTENT ERROR RESPONSE STRUCTURE\n// Define a standard format for all API errors\n\napp.onError((err, c) => {\n  console.error('Unhandled error:', err);\n  \n  // Handle Zod errors that slip through\n  if (err instanceof z.ZodError) {\n    return c.json({\n      success: false,\n      error: {\n        type: 'VALIDATION_ERROR',\n        message: 'Request validation failed',\n        details: err.errors.map(e => ({\n          field: e.path.join('.'),\n          message: e.message\n        }))\n      }\n    }, 400);\n  }\n  \n  // Generic error response\n  return c.json({\n    success: false,\n    error: {\n      type: 'INTERNAL_ERROR',\n      message: process.env.NODE_ENV === 'production' \n        ? 'An unexpected error occurred' \n        : err.message\n    }\n  }, 500);\n});\n\nexport default app;"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Zod validation mistakes:\n\n1. **Forgetting async for refine with promises**:\n   ```typescript\n   // Wrong - async refinement but using parse()\n   const schema = z.string().refine(async (val) => {\n     return await checkDatabase(val);\n   });\n   schema.parse(data);  // Won't work with async!\n   \n   // Correct - use parseAsync for async refinements\n   await schema.parseAsync(data);\n   await schema.safeParseAsync(data);\n   ```\n\n2. **Not using coerce for query parameters**:\n   ```typescript\n   // Wrong - query params are always strings!\n   const query = z.object({ page: z.number() });\n   // ?page=1 will fail because '1' is a string\n   \n   // Correct - coerce string to number\n   const query = z.object({ page: z.coerce.number() });\n   ```\n\n3. **Confusing optional() and nullable()**:\n   ```typescript\n   z.string().optional()   // string | undefined\n   z.string().nullable()   // string | null\n   z.string().nullish()    // string | null | undefined\n   ```\n\n4. **Not handling ZodError properly**:\n   ```typescript\n   // Wrong - silent failure\n   const result = schema.safeParse(data);\n   doSomething(result.data);  // data might be undefined!\n   \n   // Correct - check success first\n   if (result.success) {\n     doSomething(result.data);\n   } else {\n     handleErrors(result.error);\n   }\n   ```\n\n5. **Transform vs Refine order matters**:\n   ```typescript\n   // Wrong order - refine runs before transform\n   z.string().refine(s => s.length > 0).transform(s => s.trim());\n   // '   ' passes refine but becomes '' after transform\n   \n   // Correct - transform first, then validate\n   z.string().transform(s => s.trim()).pipe(z.string().min(1));\n   ```\n\n6. **Forgetting to export schema types**:\n   ```typescript\n   // Define schema once, export both schema and type\n   export const userSchema = z.object({...});\n   export type User = z.infer<typeof userSchema>;\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.6-challenge-1",
              "title": "User Registration Schema",
              "description": "Create a complete user registration schema with Zod:\n\n1. Define a `registrationSchema` with these fields:\n   - `email`: Valid email, required\n   - `password`: Minimum 8 characters, must contain uppercase, lowercase, and number\n   - `confirmPassword`: Must match password\n   - `username`: 3-20 characters, alphanumeric only\n   - `age`: Optional, but if provided must be 13 or older\n\n2. Use `.refine()` to validate that passwords match\n3. Test with valid and invalid data\n4. Print formatted error messages for invalid input",
              "instructions": "Create a complete user registration schema with Zod:\n\n1. Define a `registrationSchema` with these fields:\n   - `email`: Valid email, required\n   - `password`: Minimum 8 characters, must contain uppercase, lowercase, and number\n   - `confirmPassword`: Must match password\n   - `username`: 3-20 characters, alphanumeric only\n   - `age`: Optional, but if provided must be 13 or older\n\n2. Use `.refine()` to validate that passwords match\n3. Test with valid and invalid data\n4. Print formatted error messages for invalid input",
              "starterCode": "// Simulated Zod-like validation library\nconst z = {\n  string: () => ({\n    _type: 'string', _checks: [], _optional: false,\n    email: function() { this._checks.push({type:'email'}); return this; },\n    min: function(n,m) { this._checks.push({type:'min',val:n,msg:m}); return this; },\n    max: function(n,m) { this._checks.push({type:'max',val:n,msg:m}); return this; },\n    regex: function(r,m) { this._checks.push({type:'regex',val:r,msg:m}); return this; },\n    optional: function() { this._optional = true; return this; }\n  }),\n  number: () => ({\n    _type: 'number', _checks: [], _optional: false,\n    int: function() { this._checks.push({type:'int'}); return this; },\n    min: function(n,m) { this._checks.push({type:'min',val:n,msg:m}); return this; },\n    optional: function() { this._optional = true; return this; }\n  }),\n  object: (shape) => ({\n    _shape: shape, _refinements: [],\n    refine: function(fn, opts) { this._refinements.push({fn,opts}); return this; },\n    safeParse: function(data) {\n      const errors = [];\n      for (const [key, schema] of Object.entries(this._shape)) {\n        const val = data[key];\n        if (val === undefined && schema._optional) continue;\n        if (val === undefined) { errors.push({path:[key],message:`${key} is required`}); continue; }\n        for (const check of schema._checks || []) {\n          if (check.type === 'email' && !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(val))\n            errors.push({path:[key],message:'Invalid email'});\n          if (check.type === 'min' && (typeof val === 'string' ? val.length < check.val : val < check.val))\n            errors.push({path:[key],message:check.msg||`Must be at least ${check.val}`});\n          if (check.type === 'max' && (typeof val === 'string' ? val.length > check.val : val > check.val))\n            errors.push({path:[key],message:check.msg||`Must be at most ${check.val}`});\n          if (check.type === 'regex' && !check.val.test(val))\n            errors.push({path:[key],message:check.msg||'Invalid format'});\n          if (check.type === 'int' && !Number.isInteger(val))\n            errors.push({path:[key],message:'Must be an integer'});\n        }\n        if (schema._type === 'number' && typeof val !== 'number')\n          errors.push({path:[key],message:'Must be a number'});\n      }\n      for (const ref of this._refinements) {\n        if (!ref.fn(data)) errors.push({path:ref.opts.path||[],message:ref.opts.message});\n      }\n      return errors.length ? {success:false,error:{errors}} : {success:true,data};\n    }\n  })\n};\n\n// TODO: Create registration schema\nconst registrationSchema = z.object({\n  // Define your fields here\n});\n\n// Test data\nconst validUser = {\n  email: 'user@example.com',\n  password: 'SecurePass123',\n  confirmPassword: 'SecurePass123',\n  username: 'johndoe',\n  age: 25\n};\n\nconst invalidUser = {\n  email: 'invalid-email',\n  password: 'weak',\n  confirmPassword: 'different',\n  username: 'ab',  // too short\n  age: 10  // too young\n};\n\n// TODO: Test both and print results\n",
              "solution": "// Simulated Zod-like validation library\nconst z = {\n  string: () => ({\n    _type: 'string', _checks: [], _optional: false,\n    email: function() { this._checks.push({type:'email'}); return this; },\n    min: function(n,m) { this._checks.push({type:'min',val:n,msg:m}); return this; },\n    max: function(n,m) { this._checks.push({type:'max',val:n,msg:m}); return this; },\n    regex: function(r,m) { this._checks.push({type:'regex',val:r,msg:m}); return this; },\n    optional: function() { this._optional = true; return this; }\n  }),\n  number: () => ({\n    _type: 'number', _checks: [], _optional: false,\n    int: function() { this._checks.push({type:'int'}); return this; },\n    min: function(n,m) { this._checks.push({type:'min',val:n,msg:m}); return this; },\n    optional: function() { this._optional = true; return this; }\n  }),\n  object: (shape) => ({\n    _shape: shape, _refinements: [],\n    refine: function(fn, opts) { this._refinements.push({fn,opts}); return this; },\n    safeParse: function(data) {\n      const errors = [];\n      for (const [key, schema] of Object.entries(this._shape)) {\n        const val = data[key];\n        if (val === undefined && schema._optional) continue;\n        if (val === undefined) { errors.push({path:[key],message:`${key} is required`}); continue; }\n        for (const check of schema._checks || []) {\n          if (check.type === 'email' && !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(val))\n            errors.push({path:[key],message:'Invalid email'});\n          if (check.type === 'min' && (typeof val === 'string' ? val.length < check.val : val < check.val))\n            errors.push({path:[key],message:check.msg||`Must be at least ${check.val}`});\n          if (check.type === 'max' && (typeof val === 'string' ? val.length > check.val : val > check.val))\n            errors.push({path:[key],message:check.msg||`Must be at most ${check.val}`});\n          if (check.type === 'regex' && !check.val.test(val))\n            errors.push({path:[key],message:check.msg||'Invalid format'});\n          if (check.type === 'int' && !Number.isInteger(val))\n            errors.push({path:[key],message:'Must be an integer'});\n        }\n        if (schema._type === 'number' && typeof val !== 'number')\n          errors.push({path:[key],message:'Must be a number'});\n      }\n      for (const ref of this._refinements) {\n        if (!ref.fn(data)) errors.push({path:ref.opts.path||[],message:ref.opts.message});\n      }\n      return errors.length ? {success:false,error:{errors}} : {success:true,data};\n    }\n  })\n};\n\n// Registration schema with all validations\nconst registrationSchema = z.object({\n  email: z.string().email(),\n  password: z.string()\n    .min(8, 'Password must be at least 8 characters')\n    .regex(/[A-Z]/, 'Password must contain uppercase letter')\n    .regex(/[a-z]/, 'Password must contain lowercase letter')\n    .regex(/[0-9]/, 'Password must contain a number'),\n  confirmPassword: z.string(),\n  username: z.string()\n    .min(3, 'Username must be at least 3 characters')\n    .max(20, 'Username must be at most 20 characters')\n    .regex(/^[a-zA-Z0-9]+$/, 'Username must be alphanumeric'),\n  age: z.number().int().min(13, 'Must be at least 13 years old').optional()\n}).refine(\n  (data) => data.password === data.confirmPassword,\n  { message: 'Passwords do not match', path: ['confirmPassword'] }\n);\n\n// Helper to format errors nicely\nfunction formatErrors(errors) {\n  return errors.map(e => `  ${e.path.join('.')}: ${e.message}`).join('\\n');\n}\n\n// Test valid user\nconst validUser = {\n  email: 'user@example.com',\n  password: 'SecurePass123',\n  confirmPassword: 'SecurePass123',\n  username: 'johndoe',\n  age: 25\n};\n\nconsole.log('=== Testing Valid User ===');\nconst validResult = registrationSchema.safeParse(validUser);\nif (validResult.success) {\n  console.log('Validation passed!');\n  console.log('User data:', validResult.data);\n} else {\n  console.log('Validation failed!');\n}\n\n// Test invalid user\nconst invalidUser = {\n  email: 'invalid-email',\n  password: 'weak',\n  confirmPassword: 'different',\n  username: 'ab',\n  age: 10\n};\n\nconsole.log('\\n=== Testing Invalid User ===');\nconst invalidResult = registrationSchema.safeParse(invalidUser);\nif (invalidResult.success) {\n  console.log('Validation passed!');\n} else {\n  console.log('Validation failed! Errors:');\n  console.log(formatErrors(invalidResult.error.errors));\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Valid user should pass validation",
                  "expectedOutput": "Validation passed!",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Invalid user should fail with errors",
                  "expectedOutput": "Validation failed!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use .regex() for password complexity checks. Chain multiple .regex() calls for each requirement (uppercase, lowercase, number)."
                },
                {
                  "level": 2,
                  "text": "The .refine() method takes a function and options. Use { path: ['confirmPassword'] } to show the error on the right field."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to make age optional before adding min constraint",
                  "consequence": "Age becomes required instead of optional with a minimum",
                  "correction": "Chain .optional() after all other constraints: z.number().int().min(13).optional()"
                },
                {
                  "mistake": "Not specifying the error path in refine",
                  "consequence": "Password mismatch error appears as a form-level error, not on confirmPassword field",
                  "correction": "Add path option: .refine(fn, { message: '...', path: ['confirmPassword'] })"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "11.6-challenge-2",
              "title": "Product API Validation",
              "description": "Build validated endpoints for a product API:\n\n1. Create a `productSchema` with:\n   - `name`: 1-100 characters\n   - `price`: Positive number with max 2 decimal places\n   - `quantity`: Non-negative integer\n   - `categories`: Array of 1-5 category strings\n   - `metadata`: Optional object with any properties\n\n2. Create a `searchQuerySchema` for GET /products:\n   - `minPrice`: Optional positive number\n   - `maxPrice`: Optional positive number (must be >= minPrice if both provided)\n   - `category`: Optional string\n   - `inStock`: Optional boolean (coerced from string)\n\n3. Simulate validating a POST and GET request",
              "instructions": "Build validated endpoints for a product API:\n\n1. Create a `productSchema` with:\n   - `name`: 1-100 characters\n   - `price`: Positive number with max 2 decimal places\n   - `quantity`: Non-negative integer\n   - `categories`: Array of 1-5 category strings\n   - `metadata`: Optional object with any properties\n\n2. Create a `searchQuerySchema` for GET /products:\n   - `minPrice`: Optional positive number\n   - `maxPrice`: Optional positive number (must be >= minPrice if both provided)\n   - `category`: Optional string\n   - `inStock`: Optional boolean (coerced from string)\n\n3. Simulate validating a POST and GET request",
              "starterCode": "// Enhanced Zod simulation with arrays and coercion\nconst z = {\n  string: () => ({ _type:'string', _checks:[], _optional:false,\n    min: function(n,m) { this._checks.push({type:'min',val:n,msg:m}); return this; },\n    max: function(n,m) { this._checks.push({type:'max',val:n,msg:m}); return this; },\n    optional: function() { this._optional = true; return this; }\n  }),\n  number: () => ({ _type:'number', _checks:[], _optional:false,\n    positive: function(m) { this._checks.push({type:'positive',msg:m}); return this; },\n    int: function() { this._checks.push({type:'int'}); return this; },\n    min: function(n,m) { this._checks.push({type:'min',val:n,msg:m}); return this; },\n    multipleOf: function(n) { this._checks.push({type:'multipleOf',val:n}); return this; },\n    optional: function() { this._optional = true; return this; }\n  }),\n  boolean: () => ({ _type:'boolean', _checks:[], _optional:false,\n    optional: function() { this._optional = true; return this; }\n  }),\n  array: (item) => ({ _type:'array', _itemSchema:item, _checks:[], _optional:false,\n    min: function(n,m) { this._checks.push({type:'min',val:n,msg:m}); return this; },\n    max: function(n,m) { this._checks.push({type:'max',val:n,msg:m}); return this; },\n    optional: function() { this._optional = true; return this; }\n  }),\n  record: (val) => ({ _type:'record', _valSchema:val, _optional:false,\n    optional: function() { this._optional = true; return this; }\n  }),\n  coerce: {\n    number: () => ({ _type:'coerce_number', _checks:[], _optional:false,\n      positive: function() { this._checks.push({type:'positive'}); return this; },\n      optional: function() { this._optional = true; return this; }\n    }),\n    boolean: () => ({ _type:'coerce_boolean', _checks:[], _optional:false,\n      optional: function() { this._optional = true; return this; }\n    })\n  },\n  object: (shape) => ({\n    _shape: shape, _refinements: [],\n    refine: function(fn, opts) { this._refinements.push({fn,opts}); return this; },\n    safeParse: function(data) {\n      const errors = [];\n      const output = {};\n      for (const [key, schema] of Object.entries(this._shape)) {\n        let val = data[key];\n        // Handle coercion\n        if (schema._type === 'coerce_number' && val !== undefined) val = Number(val);\n        if (schema._type === 'coerce_boolean' && val !== undefined) val = val === 'true' || val === true;\n        if (val === undefined && schema._optional) continue;\n        if (val === undefined) { errors.push({path:[key],message:`${key} is required`}); continue; }\n        output[key] = val;\n        // Type checks\n        if ((schema._type === 'number' || schema._type === 'coerce_number') && typeof val !== 'number')\n          errors.push({path:[key],message:'Must be a number'});\n        if (schema._type === 'array' && !Array.isArray(val))\n          errors.push({path:[key],message:'Must be an array'});\n        // Constraint checks\n        for (const check of schema._checks || []) {\n          if (check.type === 'min') {\n            const len = Array.isArray(val) ? val.length : (typeof val === 'string' ? val.length : val);\n            if (len < check.val) errors.push({path:[key],message:check.msg||`Min ${check.val}`});\n          }\n          if (check.type === 'max') {\n            const len = Array.isArray(val) ? val.length : (typeof val === 'string' ? val.length : val);\n            if (len > check.val) errors.push({path:[key],message:check.msg||`Max ${check.val}`});\n          }\n          if (check.type === 'positive' && val <= 0) errors.push({path:[key],message:'Must be positive'});\n          if (check.type === 'int' && !Number.isInteger(val)) errors.push({path:[key],message:'Must be integer'});\n          if (check.type === 'multipleOf' && (val * 100) % (check.val * 100) !== 0)\n            errors.push({path:[key],message:`Must have max ${Math.log10(1/check.val)} decimal places`});\n        }\n      }\n      for (const ref of this._refinements) {\n        if (!ref.fn(output)) errors.push({path:ref.opts?.path||[],message:ref.opts?.message||'Invalid'});\n      }\n      return errors.length ? {success:false,error:{errors}} : {success:true,data:output};\n    }\n  })\n};\n\n// TODO: Create product schema\nconst productSchema = z.object({\n  // Define fields here\n});\n\n// TODO: Create search query schema with price range validation\nconst searchQuerySchema = z.object({\n  // Define fields here\n});\n\n// Test POST /products\nconst newProduct = {\n  name: 'Wireless Mouse',\n  price: 29.99,\n  quantity: 100,\n  categories: ['electronics', 'accessories']\n};\n\nconsole.log('=== POST /products ===');\n// TODO: Validate and print result\n\n// Test GET /products?minPrice=10&maxPrice=50&inStock=true\nconst queryParams = {\n  minPrice: '10',\n  maxPrice: '50',\n  inStock: 'true'\n};\n\nconsole.log('\\n=== GET /products ===');\n// TODO: Validate and print result\n",
              "solution": "// Enhanced Zod simulation with arrays and coercion\nconst z = {\n  string: () => ({ _type:'string', _checks:[], _optional:false,\n    min: function(n,m) { this._checks.push({type:'min',val:n,msg:m}); return this; },\n    max: function(n,m) { this._checks.push({type:'max',val:n,msg:m}); return this; },\n    optional: function() { this._optional = true; return this; }\n  }),\n  number: () => ({ _type:'number', _checks:[], _optional:false,\n    positive: function(m) { this._checks.push({type:'positive',msg:m}); return this; },\n    int: function() { this._checks.push({type:'int'}); return this; },\n    min: function(n,m) { this._checks.push({type:'min',val:n,msg:m}); return this; },\n    multipleOf: function(n) { this._checks.push({type:'multipleOf',val:n}); return this; },\n    optional: function() { this._optional = true; return this; }\n  }),\n  boolean: () => ({ _type:'boolean', _checks:[], _optional:false,\n    optional: function() { this._optional = true; return this; }\n  }),\n  array: (item) => ({ _type:'array', _itemSchema:item, _checks:[], _optional:false,\n    min: function(n,m) { this._checks.push({type:'min',val:n,msg:m}); return this; },\n    max: function(n,m) { this._checks.push({type:'max',val:n,msg:m}); return this; },\n    optional: function() { this._optional = true; return this; }\n  }),\n  record: (val) => ({ _type:'record', _valSchema:val, _optional:false,\n    optional: function() { this._optional = true; return this; }\n  }),\n  coerce: {\n    number: () => ({ _type:'coerce_number', _checks:[], _optional:false,\n      positive: function() { this._checks.push({type:'positive'}); return this; },\n      optional: function() { this._optional = true; return this; }\n    }),\n    boolean: () => ({ _type:'coerce_boolean', _checks:[], _optional:false,\n      optional: function() { this._optional = true; return this; }\n    })\n  },\n  object: (shape) => ({\n    _shape: shape, _refinements: [],\n    refine: function(fn, opts) { this._refinements.push({fn,opts}); return this; },\n    safeParse: function(data) {\n      const errors = [];\n      const output = {};\n      for (const [key, schema] of Object.entries(this._shape)) {\n        let val = data[key];\n        if (schema._type === 'coerce_number' && val !== undefined) val = Number(val);\n        if (schema._type === 'coerce_boolean' && val !== undefined) val = val === 'true' || val === true;\n        if (val === undefined && schema._optional) continue;\n        if (val === undefined) { errors.push({path:[key],message:`${key} is required`}); continue; }\n        output[key] = val;\n        if ((schema._type === 'number' || schema._type === 'coerce_number') && typeof val !== 'number')\n          errors.push({path:[key],message:'Must be a number'});\n        if (schema._type === 'array' && !Array.isArray(val))\n          errors.push({path:[key],message:'Must be an array'});\n        for (const check of schema._checks || []) {\n          if (check.type === 'min') {\n            const len = Array.isArray(val) ? val.length : (typeof val === 'string' ? val.length : val);\n            if (len < check.val) errors.push({path:[key],message:check.msg||`Min ${check.val}`});\n          }\n          if (check.type === 'max') {\n            const len = Array.isArray(val) ? val.length : (typeof val === 'string' ? val.length : val);\n            if (len > check.val) errors.push({path:[key],message:check.msg||`Max ${check.val}`});\n          }\n          if (check.type === 'positive' && val <= 0) errors.push({path:[key],message:'Must be positive'});\n          if (check.type === 'int' && !Number.isInteger(val)) errors.push({path:[key],message:'Must be integer'});\n          if (check.type === 'multipleOf' && (val * 100) % (check.val * 100) !== 0)\n            errors.push({path:[key],message:`Must have max ${Math.log10(1/check.val)} decimal places`});\n        }\n      }\n      for (const ref of this._refinements) {\n        if (!ref.fn(output)) errors.push({path:ref.opts?.path||[],message:ref.opts?.message||'Invalid'});\n      }\n      return errors.length ? {success:false,error:{errors}} : {success:true,data:output};\n    }\n  })\n};\n\n// Product schema\nconst productSchema = z.object({\n  name: z.string().min(1, 'Name is required').max(100, 'Name too long'),\n  price: z.number().positive('Price must be positive').multipleOf(0.01),\n  quantity: z.number().int().min(0, 'Quantity cannot be negative'),\n  categories: z.array(z.string()).min(1, 'At least 1 category').max(5, 'Maximum 5 categories'),\n  metadata: z.record(z.string()).optional()\n});\n\n// Search query schema with price range validation\nconst searchQuerySchema = z.object({\n  minPrice: z.coerce.number().positive().optional(),\n  maxPrice: z.coerce.number().positive().optional(),\n  category: z.string().optional(),\n  inStock: z.coerce.boolean().optional()\n}).refine(\n  (data) => {\n    if (data.minPrice !== undefined && data.maxPrice !== undefined) {\n      return data.maxPrice >= data.minPrice;\n    }\n    return true;\n  },\n  { message: 'maxPrice must be >= minPrice', path: ['maxPrice'] }\n);\n\n// Helper to format errors\nfunction formatErrors(errors) {\n  return errors.map(e => `  ${e.path.join('.')}: ${e.message}`).join('\\n');\n}\n\n// Test POST /products\nconst newProduct = {\n  name: 'Wireless Mouse',\n  price: 29.99,\n  quantity: 100,\n  categories: ['electronics', 'accessories']\n};\n\nconsole.log('=== POST /products ===');\nconst productResult = productSchema.safeParse(newProduct);\nif (productResult.success) {\n  console.log('Product valid:', productResult.data);\n} else {\n  console.log('Product invalid:\\n' + formatErrors(productResult.error.errors));\n}\n\n// Test GET /products?minPrice=10&maxPrice=50&inStock=true\nconst queryParams = {\n  minPrice: '10',\n  maxPrice: '50',\n  inStock: 'true'\n};\n\nconsole.log('\\n=== GET /products ===');\nconst queryResult = searchQuerySchema.safeParse(queryParams);\nif (queryResult.success) {\n  console.log('Query params valid:', queryResult.data);\n  console.log('Types coerced: minPrice is', typeof queryResult.data.minPrice);\n} else {\n  console.log('Query params invalid:\\n' + formatErrors(queryResult.error.errors));\n}\n\n// Test invalid price range\nconsole.log('\\n=== GET /products (invalid range) ===');\nconst badQuery = { minPrice: '100', maxPrice: '50' };\nconst badResult = searchQuerySchema.safeParse(badQuery);\nif (!badResult.success) {\n  console.log('Correctly rejected:\\n' + formatErrors(badResult.error.errors));\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Valid product passes validation",
                  "expectedOutput": "Product valid:",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Query params are coerced to correct types",
                  "expectedOutput": "number",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use z.coerce.number() for query parameters since they come as strings from the URL."
                },
                {
                  "level": 2,
                  "text": "For the price range check, use .refine() and only validate when BOTH minPrice and maxPrice are provided."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using z.number() instead of z.coerce.number() for query params",
                  "consequence": "Validation fails because query params are strings, not numbers",
                  "correction": "Use z.coerce.number() to automatically convert string to number"
                },
                {
                  "mistake": "Validating price range when only one price is provided",
                  "consequence": "Error thrown when user only filters by minPrice or maxPrice",
                  "correction": "Check if both values exist before comparing: if (minPrice && maxPrice) return max >= min"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "11.6-challenge-3",
              "title": "Custom Error Messages",
              "description": "Implement user-friendly error formatting:\n\n1. Create a `formatZodErrors` function that:\n   - Takes a Zod error object\n   - Returns a clean object mapping field names to error messages\n   - Handles nested paths (e.g., 'address.city')\n   - Only shows first error per field\n\n2. Create an `ApiErrorResponse` class that:\n   - Has fields: success, error.type, error.message, error.details\n   - Has a static `fromZodError(error)` factory method\n   - Formats errors for clean API responses\n\n3. Test with a complex schema that has nested objects",
              "instructions": "Implement user-friendly error formatting:\n\n1. Create a `formatZodErrors` function that:\n   - Takes a Zod error object\n   - Returns a clean object mapping field names to error messages\n   - Handles nested paths (e.g., 'address.city')\n   - Only shows first error per field\n\n2. Create an `ApiErrorResponse` class that:\n   - Has fields: success, error.type, error.message, error.details\n   - Has a static `fromZodError(error)` factory method\n   - Formats errors for clean API responses\n\n3. Test with a complex schema that has nested objects",
              "starterCode": "// Simulated Zod error object structure\nconst mockZodError = {\n  errors: [\n    { path: ['name'], message: 'Name is required', code: 'too_small' },\n    { path: ['name'], message: 'Name must be string', code: 'invalid_type' },\n    { path: ['email'], message: 'Invalid email format', code: 'invalid_string' },\n    { path: ['address', 'city'], message: 'City is required', code: 'too_small' },\n    { path: ['address', 'zipCode'], message: 'Invalid ZIP code', code: 'invalid_string' },\n    { path: ['tags', 0], message: 'Tag must be string', code: 'invalid_type' }\n  ]\n};\n\n// TODO: Create formatZodErrors function\nfunction formatZodErrors(zodError) {\n  // Return object like: { 'name': 'Name is required', 'address.city': 'City is required' }\n}\n\n// TODO: Create ApiErrorResponse class\nclass ApiErrorResponse {\n  constructor(type, message, details) {\n    // Initialize fields\n  }\n  \n  static fromZodError(zodError) {\n    // Create ApiErrorResponse from Zod error\n  }\n  \n  toJSON() {\n    // Return clean JSON structure\n  }\n}\n\n// Test your implementation\nconsole.log('=== formatZodErrors ===');\nconst formatted = formatZodErrors(mockZodError);\nconsole.log(formatted);\n\nconsole.log('\\n=== ApiErrorResponse ===');\nconst apiError = ApiErrorResponse.fromZodError(mockZodError);\nconsole.log(JSON.stringify(apiError.toJSON(), null, 2));\n",
              "solution": "// Simulated Zod error object structure\nconst mockZodError = {\n  errors: [\n    { path: ['name'], message: 'Name is required', code: 'too_small' },\n    { path: ['name'], message: 'Name must be string', code: 'invalid_type' },\n    { path: ['email'], message: 'Invalid email format', code: 'invalid_string' },\n    { path: ['address', 'city'], message: 'City is required', code: 'too_small' },\n    { path: ['address', 'zipCode'], message: 'Invalid ZIP code', code: 'invalid_string' },\n    { path: ['tags', 0], message: 'Tag must be string', code: 'invalid_type' }\n  ]\n};\n\n// Format Zod errors into clean field -> message mapping\nfunction formatZodErrors(zodError) {\n  const formatted = {};\n  \n  for (const error of zodError.errors) {\n    // Convert path array to dot notation string\n    const fieldPath = error.path.join('.');\n    \n    // Only keep first error per field\n    if (!formatted[fieldPath]) {\n      formatted[fieldPath] = error.message;\n    }\n  }\n  \n  return formatted;\n}\n\n// API Error Response class for consistent error structure\nclass ApiErrorResponse {\n  constructor(type, message, details = []) {\n    this.success = false;\n    this.error = {\n      type: type,\n      message: message,\n      details: details\n    };\n  }\n  \n  static fromZodError(zodError) {\n    // Group errors by field, keeping only first error per field\n    const seenPaths = new Set();\n    const details = [];\n    \n    for (const err of zodError.errors) {\n      const fieldPath = err.path.join('.');\n      \n      if (!seenPaths.has(fieldPath)) {\n        seenPaths.add(fieldPath);\n        details.push({\n          field: fieldPath,\n          message: err.message,\n          code: err.code\n        });\n      }\n    }\n    \n    // Create descriptive message\n    const fieldCount = details.length;\n    const message = fieldCount === 1 \n      ? `Validation failed for field: ${details[0].field}`\n      : `Validation failed for ${fieldCount} fields`;\n    \n    return new ApiErrorResponse('VALIDATION_ERROR', message, details);\n  }\n  \n  toJSON() {\n    return {\n      success: this.success,\n      error: this.error\n    };\n  }\n}\n\n// Test formatZodErrors\nconsole.log('=== formatZodErrors ===');\nconst formatted = formatZodErrors(mockZodError);\nconsole.log(formatted);\n// Expected: { name: 'Name is required', email: 'Invalid email format', ... }\n\nconsole.log('\\n=== ApiErrorResponse ===');\nconst apiError = ApiErrorResponse.fromZodError(mockZodError);\nconsole.log(JSON.stringify(apiError.toJSON(), null, 2));\n\n// Verify it works correctly\nconsole.log('\\n=== Verification ===');\nconsole.log('Number of unique fields:', Object.keys(formatted).length);\nconsole.log('Has nested path (address.city):', 'address.city' in formatted);\nconsole.log('First name error only:', formatted.name === 'Name is required');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "formatZodErrors returns first error per field",
                  "expectedOutput": "Name is required",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Handles nested paths correctly",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use error.path.join('.') to convert ['address', 'city'] to 'address.city'"
                },
                {
                  "level": 2,
                  "text": "To keep only the first error per field, check if the path already exists in your result object before adding it."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Including all errors for each field instead of just the first",
                  "consequence": "API response becomes bloated with redundant error messages",
                  "correction": "Check if field path already exists in output before adding: if (!formatted[path]) { formatted[path] = message; }"
                },
                {
                  "mistake": "Forgetting to handle array indices in paths",
                  "consequence": "Path ['tags', 0] becomes 'tags0' instead of 'tags.0'",
                  "correction": "Use path.join('.') which correctly handles both string and number elements"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "11.7",
          "title": "Organizing a Backend Project",
          "moduleId": "module-11",
          "order": 7,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "CONCEPT",
              "title": "Why Structure Matters",
              "content": "When you start a new backend project, it is tempting to put everything in a single file. Your server starts, handles a few routes, connects to a database, and works perfectly. But as your application grows, this approach becomes a nightmare. Finding code becomes difficult, making changes introduces bugs in unrelated features, and new team members struggle to understand where anything lives.\n\nMaintainability over time is the primary reason to structure your project thoughtfully from the beginning. A well-organized codebase allows you to make changes confidently because related code lives together and unrelated code stays separate. When you need to fix a bug in user authentication, you know exactly which directory to look in. When you add a new feature, you know where each piece belongs.\n\nTestability improves dramatically with proper structure. When your business logic lives in isolated service classes rather than tangled inside route handlers, you can test that logic independently. You can mock database calls, simulate error conditions, and verify behavior without spinning up an entire server. Unit tests become possible and even enjoyable.\n\nTeam collaboration benefits enormously from consistent project structure. When everyone follows the same conventions, developers can jump into any part of the codebase and immediately understand the organization. Code reviews become easier because reviewers know where to look for potential issues. Onboarding new team members takes days instead of weeks.\n\nThe everything in one file anti-pattern is seductive because it works initially. But technical debt accumulates quickly. You end up with functions that do too many things, global state scattered throughout, and circular dependencies that make refactoring terrifying. Breaking out of this pattern later costs far more than starting organized.\n\nSeparation of concerns is the guiding principle behind good project structure. Each module should have a single responsibility. Routes handle HTTP concerns like parsing requests and formatting responses. Services contain business logic. Database layers manage persistence. This separation means changes to one concern rarely affect others. Switching from PostgreSQL to MongoDB affects only your database layer, not your entire application."
            },
            {
              "type": "CODE",
              "title": "Recommended Directory Structure",
              "content": "A well-organized backend project follows a consistent directory structure that makes it immediately clear where any piece of code belongs. This structure scales from small APIs to large applications with dozens of developers. Each directory has a specific purpose, and files within follow predictable naming conventions. The key insight is that the structure reflects the architecture: routes separate from logic, logic separate from data access.",
              "language": "plaintext",
              "code": "my-api/\n├── src/\n│   ├── index.ts              # Application entry point\n│   │\n│   ├── routes/               # Route definitions (thin layer)\n│   │   ├── index.ts          # Main router combining all routes\n│   │   ├── users.routes.ts   # User-related routes\n│   │   ├── posts.routes.ts   # Post-related routes\n│   │   └── auth.routes.ts    # Authentication routes\n│   │\n│   ├── handlers/             # Request handlers (controllers)\n│   │   ├── users.handler.ts  # Handles user requests\n│   │   ├── posts.handler.ts  # Handles post requests\n│   │   └── auth.handler.ts   # Handles auth requests\n│   │\n│   ├── services/             # Business logic layer\n│   │   ├── user.service.ts   # User business logic\n│   │   ├── post.service.ts   # Post business logic\n│   │   ├── auth.service.ts   # Authentication logic\n│   │   └── email.service.ts  # Email sending logic\n│   │\n│   ├── db/                   # Database access layer\n│   │   ├── index.ts          # Database connection setup\n│   │   ├── users.db.ts       # User database operations\n│   │   ├── posts.db.ts       # Post database operations\n│   │   └── migrations/       # Database migrations\n│   │\n│   ├── middleware/           # Custom middleware\n│   │   ├── auth.ts           # Authentication middleware\n│   │   ├── validate.ts       # Validation middleware\n│   │   ├── rateLimit.ts      # Rate limiting middleware\n│   │   └── errorHandler.ts   # Global error handler\n│   │\n│   ├── utils/                # Helper functions\n│   │   ├── logger.ts         # Logging utilities\n│   │   ├── hash.ts           # Password hashing\n│   │   ├── jwt.ts            # JWT utilities\n│   │   └── dates.ts          # Date formatting\n│   │\n│   ├── types/                # TypeScript types/interfaces\n│   │   ├── user.types.ts     # User-related types\n│   │   ├── post.types.ts     # Post-related types\n│   │   ├── api.types.ts      # API request/response types\n│   │   └── env.d.ts          # Environment variable types\n│   │\n│   └── config/               # Configuration\n│       ├── index.ts          # Main config export\n│       ├── database.ts       # Database config\n│       └── cors.ts           # CORS config\n│\n├── tests/                    # Test files (mirrors src/ structure)\n│   ├── services/\n│   ├── handlers/\n│   └── integration/\n│\n├── .env                      # Environment variables (never commit!)\n├── .env.example              # Example env file (commit this)\n├── package.json\n├── tsconfig.json\n└── README.md\n\n# What goes where:\n#\n# routes/      - Define URL patterns and HTTP methods. Connect paths to handlers.\n#                Keep these thin - no business logic here!\n#\n# handlers/    - Process HTTP requests. Extract data from requests, call services,\n#                format responses. Also called \"controllers\" in some frameworks.\n#\n# services/    - Core business logic. Database-agnostic rules and operations.\n#                This is where most of your application logic lives.\n#\n# db/          - Database operations. SQL queries, ORM calls, connection pooling.\n#                Isolates data access so you can swap databases later.\n#\n# middleware/  - Request/response processing. Authentication, logging, validation.\n#                Runs before or after handlers.\n#\n# utils/       - Pure helper functions. No side effects, highly reusable.\n#                Things like formatting, hashing, date manipulation.\n#\n# types/       - TypeScript interfaces and type definitions.\n#                Shared across the codebase for type safety.\n#\n# config/      - Application configuration. Environment-based settings.\n#                Centralizes all config in one place."
            },
            {
              "type": "CODE",
              "title": "Separating Routes from Handlers",
              "content": "The route layer should be thin and declarative. It defines what URLs your API responds to and which handlers process those requests. The route file is like a table of contents for your API - you can scan it quickly to see all available endpoints. By keeping routes separate from handlers, you gain the ability to test handlers in isolation, reuse handlers across multiple routes, and understand your API structure at a glance. The handler files contain the actual logic for processing requests, but even handlers should remain focused on HTTP concerns and delegate business logic to services.",
              "language": "typescript",
              "code": "// src/routes/users.routes.ts\n// Routes are THIN - they just connect URLs to handlers\n\nimport { Hono } from 'hono';\nimport { zValidator } from '@hono/zod-validator';\nimport { usersHandler } from '../handlers/users.handler';\nimport { createUserSchema, updateUserSchema, userIdSchema } from '../types/user.types';\nimport { authMiddleware } from '../middleware/auth';\n\nconst usersRouter = new Hono();\n\n// List all users - GET /users\nusersRouter.get('/', usersHandler.list);\n\n// Get single user - GET /users/:id\nusersRouter.get(\n  '/:id',\n  zValidator('param', userIdSchema),\n  usersHandler.getById\n);\n\n// Create user - POST /users\nusersRouter.post(\n  '/',\n  zValidator('json', createUserSchema),\n  usersHandler.create\n);\n\n// Update user - PUT /users/:id (requires auth)\nusersRouter.put(\n  '/:id',\n  authMiddleware,\n  zValidator('param', userIdSchema),\n  zValidator('json', updateUserSchema),\n  usersHandler.update\n);\n\n// Delete user - DELETE /users/:id (requires auth)\nusersRouter.delete(\n  '/:id',\n  authMiddleware,\n  zValidator('param', userIdSchema),\n  usersHandler.delete\n);\n\nexport { usersRouter };\n\n// ============================================================\n// src/handlers/users.handler.ts\n// Handlers process requests and call services\n// ============================================================\n\nimport { Context } from 'hono';\nimport { UserService } from '../services/user.service';\nimport { CreateUserInput, UpdateUserInput } from '../types/user.types';\n\nconst userService = new UserService();\n\nexport const usersHandler = {\n  // GET /users - List all users\n  async list(c: Context) {\n    const page = Number(c.req.query('page')) || 1;\n    const limit = Number(c.req.query('limit')) || 20;\n    \n    const result = await userService.listUsers(page, limit);\n    \n    return c.json({\n      success: true,\n      data: result.users,\n      pagination: {\n        page,\n        limit,\n        total: result.total,\n        totalPages: Math.ceil(result.total / limit)\n      }\n    });\n  },\n\n  // GET /users/:id - Get single user\n  async getById(c: Context) {\n    const { id } = c.req.valid('param');\n    \n    const user = await userService.getUserById(id);\n    \n    if (!user) {\n      return c.json(\n        { success: false, error: 'User not found' },\n        404\n      );\n    }\n    \n    return c.json({ success: true, data: user });\n  },\n\n  // POST /users - Create new user\n  async create(c: Context) {\n    const input: CreateUserInput = c.req.valid('json');\n    \n    // Check if email already exists (business rule)\n    const existing = await userService.getUserByEmail(input.email);\n    if (existing) {\n      return c.json(\n        { success: false, error: 'Email already registered' },\n        409 // Conflict\n      );\n    }\n    \n    const user = await userService.createUser(input);\n    \n    return c.json(\n      { success: true, data: user, message: 'User created successfully' },\n      201\n    );\n  },\n\n  // PUT /users/:id - Update user\n  async update(c: Context) {\n    const { id } = c.req.valid('param');\n    const input: UpdateUserInput = c.req.valid('json');\n    \n    // Check ownership or admin status\n    const currentUser = c.get('user');\n    if (currentUser.id !== id && !currentUser.isAdmin) {\n      return c.json(\n        { success: false, error: 'Not authorized to update this user' },\n        403\n      );\n    }\n    \n    const user = await userService.updateUser(id, input);\n    \n    if (!user) {\n      return c.json(\n        { success: false, error: 'User not found' },\n        404\n      );\n    }\n    \n    return c.json({ success: true, data: user });\n  },\n\n  // DELETE /users/:id - Delete user\n  async delete(c: Context) {\n    const { id } = c.req.valid('param');\n    const currentUser = c.get('user');\n    \n    // Only admins can delete users\n    if (!currentUser.isAdmin) {\n      return c.json(\n        { success: false, error: 'Admin access required' },\n        403\n      );\n    }\n    \n    const deleted = await userService.deleteUser(id);\n    \n    if (!deleted) {\n      return c.json(\n        { success: false, error: 'User not found' },\n        404\n      );\n    }\n    \n    return c.json(\n      { success: true, message: 'User deleted successfully' },\n      200\n    );\n  }\n};\n\n// ============================================================\n// src/routes/index.ts\n// Main router that combines all route modules\n// ============================================================\n\nimport { Hono } from 'hono';\nimport { usersRouter } from './users.routes';\nimport { postsRouter } from './posts.routes';\nimport { authRouter } from './auth.routes';\n\nconst apiRouter = new Hono();\n\n// Mount all route modules under /api\napiRouter.route('/users', usersRouter);\napiRouter.route('/posts', postsRouter);\napiRouter.route('/auth', authRouter);\n\n// Health check endpoint\napiRouter.get('/health', (c) => c.json({ status: 'ok', timestamp: Date.now() }));\n\nexport { apiRouter };\n\n// ============================================================\n// src/index.ts\n// Application entry point\n// ============================================================\n\nimport { Hono } from 'hono';\nimport { cors } from 'hono/cors';\nimport { logger } from 'hono/logger';\nimport { apiRouter } from './routes';\nimport { errorHandler } from './middleware/errorHandler';\nimport { config } from './config';\n\nconst app = new Hono();\n\n// Global middleware\napp.use('*', logger());\napp.use('*', cors(config.cors));\n\n// Mount API routes\napp.route('/api', apiRouter);\n\n// Global error handler\napp.onError(errorHandler);\n\n// 404 handler\napp.notFound((c) => c.json({ error: 'Not Found' }, 404));\n\nexport default {\n  port: config.port,\n  fetch: app.fetch\n};"
            },
            {
              "type": "CODE",
              "title": "Service Layer Pattern",
              "content": "The service layer is where your core business logic lives. Services are classes or modules that encapsulate operations related to a specific domain concept like users, orders, or payments. Services are independent of HTTP concerns - they do not know about requests, responses, or status codes. This independence makes services highly testable and reusable. A handler calls a service method, and the service returns data or throws an error. The handler then decides how to format the response. Services typically call the database layer for persistence and may call other services for complex operations. This layered approach creates clean boundaries between concerns.",
              "language": "typescript",
              "code": "// src/services/user.service.ts\n// Service layer contains business logic - no HTTP concerns!\n\nimport { UsersDB } from '../db/users.db';\nimport { EmailService } from './email.service';\nimport { hashPassword, verifyPassword } from '../utils/hash';\nimport { CreateUserInput, UpdateUserInput, User } from '../types/user.types';\n\nexport class UserService {\n  private db: UsersDB;\n  private emailService: EmailService;\n\n  constructor() {\n    this.db = new UsersDB();\n    this.emailService = new EmailService();\n  }\n\n  // List users with pagination\n  async listUsers(page: number, limit: number): Promise<{ users: User[]; total: number }> {\n    const offset = (page - 1) * limit;\n    \n    const [users, total] = await Promise.all([\n      this.db.findMany({ offset, limit }),\n      this.db.count()\n    ]);\n    \n    // Remove sensitive fields before returning\n    const sanitized = users.map(this.sanitizeUser);\n    \n    return { users: sanitized, total };\n  }\n\n  // Get single user by ID\n  async getUserById(id: string): Promise<User | null> {\n    const user = await this.db.findById(id);\n    return user ? this.sanitizeUser(user) : null;\n  }\n\n  // Get user by email (for auth and uniqueness checks)\n  async getUserByEmail(email: string): Promise<User | null> {\n    return this.db.findByEmail(email.toLowerCase());\n  }\n\n  // Create new user with business rules\n  async createUser(input: CreateUserInput): Promise<User> {\n    // Business rule: normalize email\n    const normalizedEmail = input.email.toLowerCase().trim();\n    \n    // Business rule: hash password before storage\n    const hashedPassword = await hashPassword(input.password);\n    \n    // Create user in database\n    const user = await this.db.create({\n      ...input,\n      email: normalizedEmail,\n      password: hashedPassword,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    });\n    \n    // Business rule: send welcome email\n    await this.emailService.sendWelcomeEmail(user.email, user.name);\n    \n    return this.sanitizeUser(user);\n  }\n\n  // Update user with partial data\n  async updateUser(id: string, input: UpdateUserInput): Promise<User | null> {\n    const existing = await this.db.findById(id);\n    if (!existing) {\n      return null;\n    }\n    \n    // Build update object with only provided fields\n    const updates: Partial<User> = {\n      ...input,\n      updatedAt: new Date()\n    };\n    \n    // If password is being changed, hash it\n    if (input.password) {\n      updates.password = await hashPassword(input.password);\n    }\n    \n    // If email is being changed, normalize it\n    if (input.email) {\n      updates.email = input.email.toLowerCase().trim();\n    }\n    \n    const updated = await this.db.update(id, updates);\n    return updated ? this.sanitizeUser(updated) : null;\n  }\n\n  // Delete user\n  async deleteUser(id: string): Promise<boolean> {\n    const existing = await this.db.findById(id);\n    if (!existing) {\n      return false;\n    }\n    \n    // Business rule: soft delete or hard delete based on requirements\n    await this.db.delete(id);\n    \n    // Business rule: send account deletion confirmation\n    await this.emailService.sendAccountDeletedEmail(existing.email);\n    \n    return true;\n  }\n\n  // Authenticate user (called by auth service)\n  async authenticateUser(email: string, password: string): Promise<User | null> {\n    const user = await this.db.findByEmail(email.toLowerCase());\n    \n    if (!user) {\n      return null;\n    }\n    \n    const isValid = await verifyPassword(password, user.password);\n    \n    if (!isValid) {\n      // Business rule: track failed login attempts\n      await this.db.incrementFailedLogins(user.id);\n      return null;\n    }\n    \n    // Reset failed login counter on success\n    await this.db.resetFailedLogins(user.id);\n    \n    return this.sanitizeUser(user);\n  }\n\n  // Private helper to remove sensitive fields\n  private sanitizeUser(user: User): User {\n    const { password, failedLoginAttempts, ...safe } = user as any;\n    return safe;\n  }\n}\n\n// ============================================================\n// src/db/users.db.ts\n// Database layer - only handles data persistence\n// ============================================================\n\nimport { db } from './index';\nimport { User } from '../types/user.types';\n\nexport class UsersDB {\n  async findMany(options: { offset: number; limit: number }): Promise<User[]> {\n    // Using Drizzle ORM as an example\n    return db.select()\n      .from(users)\n      .limit(options.limit)\n      .offset(options.offset);\n  }\n\n  async findById(id: string): Promise<User | null> {\n    const result = await db.select()\n      .from(users)\n      .where(eq(users.id, id))\n      .limit(1);\n    return result[0] || null;\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    const result = await db.select()\n      .from(users)\n      .where(eq(users.email, email))\n      .limit(1);\n    return result[0] || null;\n  }\n\n  async create(data: Omit<User, 'id'>): Promise<User> {\n    const id = crypto.randomUUID();\n    await db.insert(users).values({ id, ...data });\n    return { id, ...data } as User;\n  }\n\n  async update(id: string, data: Partial<User>): Promise<User | null> {\n    await db.update(users).set(data).where(eq(users.id, id));\n    return this.findById(id);\n  }\n\n  async delete(id: string): Promise<void> {\n    await db.delete(users).where(eq(users.id, id));\n  }\n\n  async count(): Promise<number> {\n    const result = await db.select({ count: sql`count(*)` }).from(users);\n    return Number(result[0].count);\n  }\n\n  async incrementFailedLogins(id: string): Promise<void> {\n    await db.update(users)\n      .set({ failedLoginAttempts: sql`failed_login_attempts + 1` })\n      .where(eq(users.id, id));\n  }\n\n  async resetFailedLogins(id: string): Promise<void> {\n    await db.update(users)\n      .set({ failedLoginAttempts: 0 })\n      .where(eq(users.id, id));\n  }\n}\n\n// ============================================================\n// Why this layering matters:\n// ============================================================\n//\n// 1. TESTABILITY: You can test UserService without HTTP or database\n//    - Mock UsersDB to test business logic in isolation\n//    - Mock EmailService to test without sending real emails\n//    - Test handlers with mocked services\n//\n// 2. REUSABILITY: Services can be called from anywhere\n//    - REST API handlers\n//    - GraphQL resolvers\n//    - CLI scripts\n//    - Background jobs\n//\n// 3. MAINTAINABILITY: Changes are localized\n//    - Switch from PostgreSQL to MongoDB? Only change db/ files\n//    - Change email provider? Only change EmailService\n//    - Add caching? Add it in the service layer\n//\n// 4. CLARITY: Each layer has one job\n//    - Routes: URL mapping\n//    - Handlers: HTTP request/response\n//    - Services: Business logic\n//    - DB: Data persistence"
            },
            {
              "type": "CODE",
              "title": "Environment Configuration",
              "content": "Environment configuration is how you manage settings that change between development, staging, and production environments. Database connection strings, API keys, and feature flags all vary by environment. A type-safe configuration module centralizes these settings, validates them at startup, and provides autocomplete in your IDE. Never commit sensitive values to version control. Use environment variables and .env files for local development. In production, use your platform secrets manager or environment variable injection.",
              "language": "typescript",
              "code": "// src/config/index.ts\n// Type-safe environment configuration\n\nimport { z } from 'zod';\n\n// Define the shape of your environment variables with validation\nconst envSchema = z.object({\n  // Server configuration\n  NODE_ENV: z.enum(['development', 'staging', 'production']).default('development'),\n  PORT: z.coerce.number().int().min(1).max(65535).default(3000),\n  HOST: z.string().default('0.0.0.0'),\n  \n  // Database configuration\n  DATABASE_URL: z.string().url(),\n  DATABASE_POOL_SIZE: z.coerce.number().int().min(1).max(100).default(10),\n  \n  // Authentication\n  JWT_SECRET: z.string().min(32, 'JWT secret must be at least 32 characters'),\n  JWT_EXPIRES_IN: z.string().default('7d'),\n  \n  // External services\n  SMTP_HOST: z.string().optional(),\n  SMTP_PORT: z.coerce.number().optional(),\n  SMTP_USER: z.string().optional(),\n  SMTP_PASS: z.string().optional(),\n  \n  // Feature flags\n  ENABLE_SIGNUP: z.coerce.boolean().default(true),\n  ENABLE_RATE_LIMITING: z.coerce.boolean().default(true),\n  \n  // API keys (optional in development)\n  STRIPE_SECRET_KEY: z.string().optional(),\n  SENDGRID_API_KEY: z.string().optional(),\n  \n  // Logging\n  LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info')\n});\n\n// Parse and validate environment variables at startup\nfunction loadConfig() {\n  const result = envSchema.safeParse(process.env);\n  \n  if (!result.success) {\n    console.error('Invalid environment configuration:');\n    console.error(result.error.flatten().fieldErrors);\n    process.exit(1);  // Fail fast on invalid config\n  }\n  \n  return result.data;\n}\n\n// Export validated and typed configuration\nexport const env = loadConfig();\n\n// Derived configuration with computed values\nexport const config = {\n  // Environment\n  isDev: env.NODE_ENV === 'development',\n  isProd: env.NODE_ENV === 'production',\n  isStaging: env.NODE_ENV === 'staging',\n  \n  // Server\n  port: env.PORT,\n  host: env.HOST,\n  \n  // Database\n  database: {\n    url: env.DATABASE_URL,\n    poolSize: env.DATABASE_POOL_SIZE\n  },\n  \n  // JWT\n  jwt: {\n    secret: env.JWT_SECRET,\n    expiresIn: env.JWT_EXPIRES_IN\n  },\n  \n  // CORS (different for each environment)\n  cors: {\n    origin: env.NODE_ENV === 'production'\n      ? ['https://myapp.com', 'https://www.myapp.com']\n      : ['http://localhost:3000', 'http://localhost:5173'],\n    credentials: true\n  },\n  \n  // Email\n  email: env.SMTP_HOST ? {\n    host: env.SMTP_HOST,\n    port: env.SMTP_PORT || 587,\n    auth: {\n      user: env.SMTP_USER,\n      pass: env.SMTP_PASS\n    }\n  } : null,\n  \n  // Feature flags\n  features: {\n    signup: env.ENABLE_SIGNUP,\n    rateLimiting: env.ENABLE_RATE_LIMITING\n  },\n  \n  // Logging\n  logLevel: env.LOG_LEVEL\n};\n\n// Type export for use in other files\nexport type Config = typeof config;\n\n// ============================================================\n// .env.example (commit this to version control)\n// ============================================================\n/*\n# Server\nNODE_ENV=development\nPORT=3000\nHOST=0.0.0.0\n\n# Database\nDATABASE_URL=postgresql://user:password@localhost:5432/mydb\nDATABASE_POOL_SIZE=10\n\n# Authentication (generate with: openssl rand -base64 32)\nJWT_SECRET=your-super-secret-jwt-key-at-least-32-chars\nJWT_EXPIRES_IN=7d\n\n# Email (optional in development)\nSMTP_HOST=smtp.mailtrap.io\nSMTP_PORT=587\nSMTP_USER=\nSMTP_PASS=\n\n# Feature Flags\nENABLE_SIGNUP=true\nENABLE_RATE_LIMITING=true\n\n# External Services (optional in development)\nSTRIPE_SECRET_KEY=\nSENDGRID_API_KEY=\n\n# Logging\nLOG_LEVEL=debug\n*/\n\n// ============================================================\n// .env (DO NOT COMMIT - add to .gitignore)\n// ============================================================\n/*\nNODE_ENV=development\nPORT=3000\nDATABASE_URL=postgresql://dev:devpass@localhost:5432/myapp_dev\nJWT_SECRET=dev-secret-key-only-for-local-development-32chars\n*/\n\n// ============================================================\n// .gitignore entries for secrets\n// ============================================================\n/*\n# Environment files with secrets\n.env\n.env.local\n.env.*.local\n\n# Keep example file\n!.env.example\n*/\n\n// ============================================================\n// Usage in other files\n// ============================================================\n\nimport { config } from './config';\n\n// Type-safe access with autocomplete!\nif (config.features.signup) {\n  console.log('Signup is enabled');\n}\n\nif (config.isDev) {\n  console.log('Running in development mode');\n}\n\n// Database connection\nconst db = createConnection(config.database.url, {\n  poolSize: config.database.poolSize\n});\n\n// JWT signing\nconst token = signJwt(payload, config.jwt.secret, {\n  expiresIn: config.jwt.expiresIn\n});\n\n// ============================================================\n// Secrets Management Best Practices\n// ============================================================\n//\n// 1. NEVER commit secrets to version control\n//    - Use .env.example for documentation\n//    - Add .env to .gitignore immediately\n//\n// 2. Use different secrets per environment\n//    - Development: local secrets, can be simple\n//    - Staging: real secrets, rotated regularly\n//    - Production: strongest secrets, strict access\n//\n// 3. Production secrets management:\n//    - AWS: Secrets Manager or Parameter Store\n//    - GCP: Secret Manager\n//    - Azure: Key Vault\n//    - Kubernetes: Secrets or external-secrets\n//    - Fly.io/Railway/Render: Built-in secrets\n//\n// 4. Validate at startup\n//    - Fail fast if required config is missing\n//    - Log which optional config is missing\n//    - Never log actual secret values!\n//\n// 5. Rotate secrets regularly\n//    - API keys: every 90 days\n//    - JWT secrets: every 30 days (with grace period)\n//    - Database passwords: per security policy"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common project structure mistakes:\n\n1. **Circular dependencies**:\n   ```typescript\n   // userService.ts imports orderService\n   // orderService.ts imports userService\n   // This creates a circular dependency!\n   ```\n   Solution: Extract shared logic into a separate module, or use dependency injection.\n\n2. **Business logic in route handlers**:\n   ```typescript\n   // BAD: Logic mixed with HTTP handling\n   app.post('/users', async (c) => {\n     const hashedPassword = await bcrypt.hash(password, 10);\n     const user = await db.insert(users).values({...});\n     await sendEmail(user.email, 'Welcome!');\n     return c.json(user);\n   });\n   ```\n   Solution: Move all logic to services. Handlers should only handle HTTP.\n\n3. **Hardcoded configuration**:\n   ```typescript\n   // BAD: Hardcoded values\n   const db = connect('postgresql://localhost:5432/mydb');\n   ```\n   Solution: Always use environment variables for anything that varies by environment.\n\n4. **Giant service files**:\n   Services should be focused. If UserService has 2000 lines, consider splitting into UserAuthService, UserProfileService, and UserPreferencesService.\n\n5. **Skipping the database layer**:\n   ```typescript\n   // BAD: Direct DB calls in service\n   class UserService {\n     async getUser(id) {\n       return db.select().from(users).where(...);\n     }\n   }\n   ```\n   Solution: Create a separate DB layer. This makes it easier to add caching, switch databases, or mock for tests.\n\n6. **Committing .env files**:\n   Even once is dangerous - secrets remain in git history forever. Use pre-commit hooks to prevent this.\n\n7. **Not validating environment at startup**:\n   Missing config causes runtime errors. Validate everything when the application starts and fail fast with clear error messages."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.7-challenge-1",
              "title": "Refactor Monolith",
              "description": "You have been given a single-file API that handles users and posts. Your task is to refactor it into a proper project structure.\n\n1. Identify the different concerns in the monolith code\n2. Create route, handler, and service layers\n3. Separate user operations from post operations\n4. Move shared utilities to a utils module\n\nStart by analyzing the monolith and then create the separated structure.",
              "instructions": "Refactor the monolith code into proper layers:\n\n1. Create a UsersHandler object with methods: list, getById, create\n2. Create a PostsHandler object with methods: list, getByUserId, create\n3. Create a UserService class with business logic\n4. Create a PostService class with business logic\n5. Create utility functions for common operations\n\nThe goal is separation of concerns - routes should be thin, handlers handle HTTP, services contain logic.",
              "starterCode": "// MONOLITH: Everything in one file - needs refactoring!\n\nconst users = [\n  { id: '1', name: 'Alice', email: 'alice@example.com', createdAt: '2024-01-01' },\n  { id: '2', name: 'Bob', email: 'bob@example.com', createdAt: '2024-01-02' }\n];\n\nconst posts = [\n  { id: '1', userId: '1', title: 'Hello World', content: 'My first post', createdAt: '2024-01-01' },\n  { id: '2', userId: '1', title: 'Learning Bun', content: 'Bun is fast!', createdAt: '2024-01-02' },\n  { id: '3', userId: '2', title: 'TypeScript Tips', content: 'Use strict mode!', createdAt: '2024-01-03' }\n];\n\n// Simulated Hono-like router\nclass Router {\n  constructor() { this.routes = []; }\n  get(path, handler) { this.routes.push({ method: 'GET', path, handler }); }\n  post(path, handler) { this.routes.push({ method: 'POST', path, handler }); }\n  handle(method, path, body = null) {\n    const route = this.routes.find(r => r.method === method && this.matchPath(r.path, path));\n    if (!route) return { status: 404, body: { error: 'Not found' } };\n    const params = this.extractParams(route.path, path);\n    const c = {\n      req: { param: (k) => params[k], json: async () => body, query: () => ({}) },\n      json: (data, status = 200) => ({ status, body: data })\n    };\n    return route.handler(c);\n  }\n  matchPath(pattern, path) {\n    const patternParts = pattern.split('/');\n    const pathParts = path.split('/');\n    if (patternParts.length !== pathParts.length) return false;\n    return patternParts.every((p, i) => p.startsWith(':') || p === pathParts[i]);\n  }\n  extractParams(pattern, path) {\n    const params = {};\n    const patternParts = pattern.split('/');\n    const pathParts = path.split('/');\n    patternParts.forEach((p, i) => { if (p.startsWith(':')) params[p.slice(1)] = pathParts[i]; });\n    return params;\n  }\n}\n\nconst app = new Router();\n\n// MESSY: All routes and logic mixed together!\n\napp.get('/users', (c) => {\n  return c.json({ success: true, data: users });\n});\n\napp.get('/users/:id', (c) => {\n  const id = c.req.param('id');\n  const user = users.find(u => u.id === id);\n  if (!user) return c.json({ success: false, error: 'User not found' }, 404);\n  return c.json({ success: true, data: user });\n});\n\napp.post('/users', async (c) => {\n  const body = await c.req.json();\n  if (!body.name || !body.email) {\n    return c.json({ success: false, error: 'Name and email required' }, 400);\n  }\n  // Logic mixed with HTTP handling!\n  const newUser = {\n    id: String(users.length + 1),\n    name: body.name,\n    email: body.email.toLowerCase(),\n    createdAt: new Date().toISOString().split('T')[0]\n  };\n  users.push(newUser);\n  return c.json({ success: true, data: newUser }, 201);\n});\n\napp.get('/posts', (c) => {\n  return c.json({ success: true, data: posts });\n});\n\napp.get('/users/:userId/posts', (c) => {\n  const userId = c.req.param('userId');\n  const userPosts = posts.filter(p => p.userId === userId);\n  return c.json({ success: true, data: userPosts });\n});\n\napp.post('/posts', async (c) => {\n  const body = await c.req.json();\n  if (!body.userId || !body.title || !body.content) {\n    return c.json({ success: false, error: 'userId, title, and content required' }, 400);\n  }\n  const newPost = {\n    id: String(posts.length + 1),\n    userId: body.userId,\n    title: body.title,\n    content: body.content,\n    createdAt: new Date().toISOString().split('T')[0]\n  };\n  posts.push(newPost);\n  return c.json({ success: true, data: newPost }, 201);\n});\n\n// TODO: Refactor into proper structure below\n// Create: UserService, PostService, usersHandler, postsHandler\n\n// Test the refactored code\nconsole.log('=== Testing API ===');\nconsole.log('GET /users:', app.handle('GET', '/users'));\nconsole.log('GET /users/1:', app.handle('GET', '/users/1'));\nconsole.log('GET /posts:', app.handle('GET', '/posts'));\nconsole.log('GET /users/1/posts:', app.handle('GET', '/users/1/posts'));\n",
              "solution": "// REFACTORED: Proper separation of concerns\n\n// ============================================================\n// DATA LAYER (simulated database)\n// ============================================================\nconst usersDb = [\n  { id: '1', name: 'Alice', email: 'alice@example.com', createdAt: '2024-01-01' },\n  { id: '2', name: 'Bob', email: 'bob@example.com', createdAt: '2024-01-02' }\n];\n\nconst postsDb = [\n  { id: '1', userId: '1', title: 'Hello World', content: 'My first post', createdAt: '2024-01-01' },\n  { id: '2', userId: '1', title: 'Learning Bun', content: 'Bun is fast!', createdAt: '2024-01-02' },\n  { id: '3', userId: '2', title: 'TypeScript Tips', content: 'Use strict mode!', createdAt: '2024-01-03' }\n];\n\n// ============================================================\n// UTILS LAYER\n// ============================================================\nconst utils = {\n  generateId: (collection) => String(collection.length + 1),\n  getCurrentDate: () => new Date().toISOString().split('T')[0],\n  normalizeEmail: (email) => email.toLowerCase().trim()\n};\n\n// ============================================================\n// SERVICE LAYER (Business Logic)\n// ============================================================\nclass UserService {\n  getAllUsers() {\n    return usersDb;\n  }\n  \n  getUserById(id) {\n    return usersDb.find(u => u.id === id) || null;\n  }\n  \n  createUser(data) {\n    const newUser = {\n      id: utils.generateId(usersDb),\n      name: data.name,\n      email: utils.normalizeEmail(data.email),\n      createdAt: utils.getCurrentDate()\n    };\n    usersDb.push(newUser);\n    return newUser;\n  }\n}\n\nclass PostService {\n  getAllPosts() {\n    return postsDb;\n  }\n  \n  getPostsByUserId(userId) {\n    return postsDb.filter(p => p.userId === userId);\n  }\n  \n  createPost(data) {\n    const newPost = {\n      id: utils.generateId(postsDb),\n      userId: data.userId,\n      title: data.title,\n      content: data.content,\n      createdAt: utils.getCurrentDate()\n    };\n    postsDb.push(newPost);\n    return newPost;\n  }\n}\n\n// ============================================================\n// HANDLER LAYER (HTTP Request/Response)\n// ============================================================\nconst userService = new UserService();\nconst postService = new PostService();\n\nconst usersHandler = {\n  list(c) {\n    const users = userService.getAllUsers();\n    return c.json({ success: true, data: users });\n  },\n  \n  getById(c) {\n    const id = c.req.param('id');\n    const user = userService.getUserById(id);\n    \n    if (!user) {\n      return c.json({ success: false, error: 'User not found' }, 404);\n    }\n    \n    return c.json({ success: true, data: user });\n  },\n  \n  async create(c) {\n    const body = await c.req.json();\n    \n    // Validation (could move to middleware)\n    if (!body.name || !body.email) {\n      return c.json({ success: false, error: 'Name and email required' }, 400);\n    }\n    \n    const user = userService.createUser(body);\n    return c.json({ success: true, data: user }, 201);\n  }\n};\n\nconst postsHandler = {\n  list(c) {\n    const posts = postService.getAllPosts();\n    return c.json({ success: true, data: posts });\n  },\n  \n  getByUserId(c) {\n    const userId = c.req.param('userId');\n    const posts = postService.getPostsByUserId(userId);\n    return c.json({ success: true, data: posts });\n  },\n  \n  async create(c) {\n    const body = await c.req.json();\n    \n    if (!body.userId || !body.title || !body.content) {\n      return c.json({ success: false, error: 'userId, title, and content required' }, 400);\n    }\n    \n    const post = postService.createPost(body);\n    return c.json({ success: true, data: post }, 201);\n  }\n};\n\n// ============================================================\n// ROUTES LAYER (Thin - just connects URLs to handlers)\n// ============================================================\nclass Router {\n  constructor() { this.routes = []; }\n  get(path, handler) { this.routes.push({ method: 'GET', path, handler }); }\n  post(path, handler) { this.routes.push({ method: 'POST', path, handler }); }\n  handle(method, path, body = null) {\n    const route = this.routes.find(r => r.method === method && this.matchPath(r.path, path));\n    if (!route) return { status: 404, body: { error: 'Not found' } };\n    const params = this.extractParams(route.path, path);\n    const c = {\n      req: { param: (k) => params[k], json: async () => body, query: () => ({}) },\n      json: (data, status = 200) => ({ status, body: data })\n    };\n    return route.handler(c);\n  }\n  matchPath(pattern, path) {\n    const patternParts = pattern.split('/');\n    const pathParts = path.split('/');\n    if (patternParts.length !== pathParts.length) return false;\n    return patternParts.every((p, i) => p.startsWith(':') || p === pathParts[i]);\n  }\n  extractParams(pattern, path) {\n    const params = {};\n    const patternParts = pattern.split('/');\n    const pathParts = path.split('/');\n    patternParts.forEach((p, i) => { if (p.startsWith(':')) params[p.slice(1)] = pathParts[i]; });\n    return params;\n  }\n}\n\nconst app = new Router();\n\n// User routes - thin, just connecting paths to handlers\napp.get('/users', usersHandler.list);\napp.get('/users/:id', usersHandler.getById);\napp.post('/users', usersHandler.create);\n\n// Post routes\napp.get('/posts', postsHandler.list);\napp.get('/users/:userId/posts', postsHandler.getByUserId);\napp.post('/posts', postsHandler.create);\n\n// ============================================================\n// TEST\n// ============================================================\nconsole.log('=== Testing Refactored API ===');\nconsole.log('GET /users:', JSON.stringify(app.handle('GET', '/users').body));\nconsole.log('GET /users/1:', JSON.stringify(app.handle('GET', '/users/1').body));\nconsole.log('GET /users/999:', JSON.stringify(app.handle('GET', '/users/999').body));\nconsole.log('GET /posts:', JSON.stringify(app.handle('GET', '/posts').body));\nconsole.log('GET /users/1/posts:', JSON.stringify(app.handle('GET', '/users/1/posts').body));\n\nconsole.log('\\n=== Structure Summary ===');\nconsole.log('Routes: Thin layer connecting URLs to handlers');\nconsole.log('Handlers: HTTP request/response processing');\nconsole.log('Services: Business logic (UserService, PostService)');\nconsole.log('Utils: Shared helper functions');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "UserService should return all users",
                  "expectedOutput": "Alice",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "PostService should filter posts by user",
                  "expectedOutput": "Hello World",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start by creating service classes with methods like getAllUsers(), getUserById(), createUser(). These handle business logic without knowing about HTTP."
                },
                {
                  "level": 2,
                  "text": "Handlers should create response objects using c.json(). They call service methods and format the results for HTTP responses."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Putting database queries directly in handlers",
                  "consequence": "Handlers become tightly coupled to data layer, making testing difficult",
                  "correction": "Create a service layer that handlers call. Services contain the queries and business logic."
                },
                {
                  "mistake": "Having services know about HTTP concepts like status codes",
                  "consequence": "Services become coupled to HTTP transport, can't be reused for CLI or other interfaces",
                  "correction": "Services should return data or throw errors. Handlers decide how to format HTTP responses."
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "11.7-challenge-2",
              "title": "Add Service Layer",
              "description": "Create a ProductService class that encapsulates all product-related business logic.\n\n1. Implement methods: getAllProducts, getProductById, createProduct, updateProduct, deleteProduct\n2. Add business rules: price cannot be negative, quantity cannot be negative, name is required\n3. Add a method to check if a product is in stock\n4. Add a method to apply a discount to a product\n\nThe service should be completely independent of HTTP concerns.",
              "instructions": "Create a ProductService class with:\n\n1. getAllProducts() - returns all products\n2. getProductById(id) - returns product or null\n3. createProduct(data) - validates and creates product\n4. updateProduct(id, data) - validates and updates product\n5. deleteProduct(id) - removes product, returns success boolean\n6. isInStock(id) - checks if quantity > 0\n7. applyDiscount(id, percentage) - reduces price by percentage\n\nAll business rules should be enforced in the service layer.",
              "starterCode": "// Simulated product database\nconst productsDb = [\n  { id: '1', name: 'Laptop', price: 999.99, quantity: 10, category: 'electronics' },\n  { id: '2', name: 'Mouse', price: 29.99, quantity: 50, category: 'electronics' },\n  { id: '3', name: 'Keyboard', price: 79.99, quantity: 0, category: 'electronics' }\n];\n\n// TODO: Create ProductService class\nclass ProductService {\n  // Implement methods here\n  \n  getAllProducts() {\n    // Return all products\n  }\n  \n  getProductById(id) {\n    // Return product or null\n  }\n  \n  createProduct(data) {\n    // Validate and create product\n    // Throw error if validation fails\n  }\n  \n  updateProduct(id, data) {\n    // Update product if exists\n    // Return updated product or null\n  }\n  \n  deleteProduct(id) {\n    // Delete product, return true/false\n  }\n  \n  isInStock(id) {\n    // Return true if quantity > 0\n  }\n  \n  applyDiscount(id, percentage) {\n    // Reduce price by percentage (e.g., 10 = 10% off)\n    // Return updated product or null\n  }\n}\n\n// Test your service\nconst productService = new ProductService();\n\nconsole.log('=== Testing ProductService ===');\nconsole.log('All products:', productService.getAllProducts());\nconsole.log('Product 1:', productService.getProductById('1'));\nconsole.log('Product 999:', productService.getProductById('999'));\nconsole.log('Laptop in stock?', productService.isInStock('1'));\nconsole.log('Keyboard in stock?', productService.isInStock('3'));\n",
              "solution": "// Simulated product database\nconst productsDb = [\n  { id: '1', name: 'Laptop', price: 999.99, quantity: 10, category: 'electronics' },\n  { id: '2', name: 'Mouse', price: 29.99, quantity: 50, category: 'electronics' },\n  { id: '3', name: 'Keyboard', price: 79.99, quantity: 0, category: 'electronics' }\n];\n\n// Custom error for validation failures\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\n// ProductService - All business logic lives here\nclass ProductService {\n  // Get all products\n  getAllProducts() {\n    return [...productsDb];  // Return copy to prevent mutation\n  }\n  \n  // Get single product by ID\n  getProductById(id) {\n    const product = productsDb.find(p => p.id === id);\n    return product ? { ...product } : null;  // Return copy\n  }\n  \n  // Create new product with validation\n  createProduct(data) {\n    // Business rule: name is required\n    if (!data.name || data.name.trim() === '') {\n      throw new ValidationError('Product name is required');\n    }\n    \n    // Business rule: price cannot be negative\n    if (typeof data.price !== 'number' || data.price < 0) {\n      throw new ValidationError('Price must be a non-negative number');\n    }\n    \n    // Business rule: quantity cannot be negative\n    if (typeof data.quantity !== 'number' || data.quantity < 0) {\n      throw new ValidationError('Quantity must be a non-negative number');\n    }\n    \n    const newProduct = {\n      id: String(productsDb.length + 1),\n      name: data.name.trim(),\n      price: Math.round(data.price * 100) / 100,  // Round to 2 decimals\n      quantity: Math.floor(data.quantity),  // Ensure integer\n      category: data.category || 'uncategorized'\n    };\n    \n    productsDb.push(newProduct);\n    return { ...newProduct };\n  }\n  \n  // Update existing product\n  updateProduct(id, data) {\n    const index = productsDb.findIndex(p => p.id === id);\n    if (index === -1) {\n      return null;\n    }\n    \n    const existing = productsDb[index];\n    const updates = {};\n    \n    // Validate each field if provided\n    if (data.name !== undefined) {\n      if (data.name.trim() === '') {\n        throw new ValidationError('Product name cannot be empty');\n      }\n      updates.name = data.name.trim();\n    }\n    \n    if (data.price !== undefined) {\n      if (typeof data.price !== 'number' || data.price < 0) {\n        throw new ValidationError('Price must be a non-negative number');\n      }\n      updates.price = Math.round(data.price * 100) / 100;\n    }\n    \n    if (data.quantity !== undefined) {\n      if (typeof data.quantity !== 'number' || data.quantity < 0) {\n        throw new ValidationError('Quantity must be a non-negative number');\n      }\n      updates.quantity = Math.floor(data.quantity);\n    }\n    \n    if (data.category !== undefined) {\n      updates.category = data.category;\n    }\n    \n    // Apply updates\n    productsDb[index] = { ...existing, ...updates };\n    return { ...productsDb[index] };\n  }\n  \n  // Delete product\n  deleteProduct(id) {\n    const index = productsDb.findIndex(p => p.id === id);\n    if (index === -1) {\n      return false;\n    }\n    \n    productsDb.splice(index, 1);\n    return true;\n  }\n  \n  // Check if product is in stock\n  isInStock(id) {\n    const product = productsDb.find(p => p.id === id);\n    return product ? product.quantity > 0 : false;\n  }\n  \n  // Apply discount to product\n  applyDiscount(id, percentage) {\n    if (percentage < 0 || percentage > 100) {\n      throw new ValidationError('Discount percentage must be between 0 and 100');\n    }\n    \n    const index = productsDb.findIndex(p => p.id === id);\n    if (index === -1) {\n      return null;\n    }\n    \n    const product = productsDb[index];\n    const discountMultiplier = 1 - (percentage / 100);\n    const newPrice = Math.round(product.price * discountMultiplier * 100) / 100;\n    \n    productsDb[index] = { ...product, price: newPrice };\n    return { ...productsDb[index] };\n  }\n}\n\n// Test the service\nconst productService = new ProductService();\n\nconsole.log('=== Testing ProductService ===');\n\n// Test getAllProducts\nconsole.log('\\n1. All products:');\nconsole.log(productService.getAllProducts());\n\n// Test getProductById\nconsole.log('\\n2. Get product by ID:');\nconsole.log('Product 1:', productService.getProductById('1'));\nconsole.log('Product 999:', productService.getProductById('999'));\n\n// Test isInStock\nconsole.log('\\n3. Stock check:');\nconsole.log('Laptop in stock?', productService.isInStock('1'));  // true\nconsole.log('Keyboard in stock?', productService.isInStock('3'));  // false\n\n// Test createProduct\nconsole.log('\\n4. Create product:');\ntry {\n  const newProduct = productService.createProduct({\n    name: 'Webcam',\n    price: 49.99,\n    quantity: 25,\n    category: 'electronics'\n  });\n  console.log('Created:', newProduct);\n} catch (e) {\n  console.log('Error:', e.message);\n}\n\n// Test validation\nconsole.log('\\n5. Validation test:');\ntry {\n  productService.createProduct({ name: '', price: -10, quantity: 5 });\n} catch (e) {\n  console.log('Caught validation error:', e.message);\n}\n\n// Test applyDiscount\nconsole.log('\\n6. Apply 20% discount to Laptop:');\nconst discounted = productService.applyDiscount('1', 20);\nconsole.log('After discount:', discounted);\n\n// Test updateProduct\nconsole.log('\\n7. Update product:');\nconst updated = productService.updateProduct('2', { quantity: 100 });\nconsole.log('Updated Mouse:', updated);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Service should return all products",
                  "expectedOutput": "Laptop",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Service should validate product data",
                  "expectedOutput": "ValidationError",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Services should throw errors for invalid data, not return HTTP status codes. The calling handler decides how to format the error response."
                },
                {
                  "level": 2,
                  "text": "Return copies of objects (using spread operator) to prevent external code from mutating your database directly."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Returning HTTP status codes from services",
                  "consequence": "Services become coupled to HTTP, cannot be reused in CLI or other contexts",
                  "correction": "Throw errors or return null/false. Let handlers decide HTTP status codes."
                },
                {
                  "mistake": "Not validating input in service layer",
                  "consequence": "Invalid data can reach the database, causing corruption or crashes",
                  "correction": "Validate all input in the service layer before any database operations."
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "11.7-challenge-3",
              "title": "Environment Config",
              "description": "Build a type-safe configuration module that:\n\n1. Defines expected environment variables with types\n2. Validates all required variables at startup\n3. Provides typed access to configuration\n4. Has different defaults for different environments\n5. Fails fast with clear error messages for missing config\n\nThis is how professional applications manage configuration.",
              "instructions": "Create a configuration system:\n\n1. Define a schema for expected environment variables\n2. Create a loadConfig function that validates env vars\n3. Provide typed access to config values\n4. Support default values\n5. Fail with clear errors for missing required values\n6. Create derived configuration (isDev, isProd, etc.)\n\nSimulate different environments and test the validation.",
              "starterCode": "// Simulated environment (in real code, use process.env)\nlet mockEnv = {\n  NODE_ENV: 'development',\n  PORT: '3000',\n  DATABASE_URL: 'postgresql://localhost:5432/mydb',\n  JWT_SECRET: 'my-super-secret-key-for-jwt-tokens',\n  // SMTP_HOST is intentionally missing to test optional values\n};\n\n// TODO: Create configuration schema and loader\n\n// Define expected environment variables\nconst configSchema = {\n  // Define each expected variable with:\n  // - type ('string', 'number', 'boolean')\n  // - required (true/false)\n  // - default (optional default value)\n};\n\n// Validate and load configuration\nfunction loadConfig(env) {\n  // 1. Validate all required variables exist\n  // 2. Coerce types (string to number, etc.)\n  // 3. Apply defaults\n  // 4. Return typed config object\n  // 5. Throw error with details if validation fails\n}\n\n// Create the configuration object\nfunction createConfig(env) {\n  const rawConfig = loadConfig(env);\n  \n  // Return config with derived values\n  return {\n    // ... base config values\n    // ... derived values (isDev, isProd, etc.)\n  };\n}\n\n// Test with valid config\nconsole.log('=== Testing Valid Config ===');\ntry {\n  const config = createConfig(mockEnv);\n  console.log('Config loaded successfully!');\n  console.log('Port:', config.port);\n  console.log('Is Dev:', config.isDev);\n} catch (e) {\n  console.log('Error:', e.message);\n}\n\n// Test with missing required config\nconsole.log('\\n=== Testing Missing Config ===');\ntry {\n  const badEnv = { NODE_ENV: 'production' };  // Missing DATABASE_URL\n  const config = createConfig(badEnv);\n} catch (e) {\n  console.log('Caught error:', e.message);\n}\n",
              "solution": "// Simulated environment (in real code, use process.env)\nlet mockEnv = {\n  NODE_ENV: 'development',\n  PORT: '3000',\n  DATABASE_URL: 'postgresql://localhost:5432/mydb',\n  JWT_SECRET: 'my-super-secret-key-for-jwt-tokens',\n  ENABLE_SIGNUP: 'true',\n  LOG_LEVEL: 'debug'\n};\n\n// Configuration Error\nclass ConfigError extends Error {\n  constructor(message, missingVars = []) {\n    super(message);\n    this.name = 'ConfigError';\n    this.missingVars = missingVars;\n  }\n}\n\n// Define expected environment variables with types and defaults\nconst configSchema = {\n  NODE_ENV: {\n    type: 'string',\n    required: false,\n    default: 'development',\n    enum: ['development', 'staging', 'production']\n  },\n  PORT: {\n    type: 'number',\n    required: false,\n    default: 3000\n  },\n  DATABASE_URL: {\n    type: 'string',\n    required: true\n  },\n  JWT_SECRET: {\n    type: 'string',\n    required: true,\n    minLength: 20\n  },\n  JWT_EXPIRES_IN: {\n    type: 'string',\n    required: false,\n    default: '7d'\n  },\n  SMTP_HOST: {\n    type: 'string',\n    required: false\n  },\n  SMTP_PORT: {\n    type: 'number',\n    required: false,\n    default: 587\n  },\n  ENABLE_SIGNUP: {\n    type: 'boolean',\n    required: false,\n    default: true\n  },\n  LOG_LEVEL: {\n    type: 'string',\n    required: false,\n    default: 'info',\n    enum: ['debug', 'info', 'warn', 'error']\n  }\n};\n\n// Coerce value to expected type\nfunction coerceValue(value, type) {\n  if (value === undefined) return undefined;\n  \n  switch (type) {\n    case 'number':\n      const num = Number(value);\n      if (isNaN(num)) throw new Error(`Cannot convert \"${value}\" to number`);\n      return num;\n    case 'boolean':\n      if (value === 'true' || value === '1') return true;\n      if (value === 'false' || value === '0') return false;\n      throw new Error(`Cannot convert \"${value}\" to boolean`);\n    case 'string':\n    default:\n      return String(value);\n  }\n}\n\n// Validate and load configuration\nfunction loadConfig(env) {\n  const errors = [];\n  const result = {};\n  \n  for (const [key, schema] of Object.entries(configSchema)) {\n    const rawValue = env[key];\n    \n    // Check if required and missing\n    if (rawValue === undefined) {\n      if (schema.required) {\n        errors.push(`${key} is required but not set`);\n        continue;\n      }\n      // Apply default if available\n      if (schema.default !== undefined) {\n        result[key] = schema.default;\n      }\n      continue;\n    }\n    \n    // Coerce to correct type\n    try {\n      const value = coerceValue(rawValue, schema.type);\n      \n      // Validate enum\n      if (schema.enum && !schema.enum.includes(value)) {\n        errors.push(`${key} must be one of: ${schema.enum.join(', ')}`);\n        continue;\n      }\n      \n      // Validate minLength\n      if (schema.minLength && typeof value === 'string' && value.length < schema.minLength) {\n        errors.push(`${key} must be at least ${schema.minLength} characters`);\n        continue;\n      }\n      \n      result[key] = value;\n    } catch (e) {\n      errors.push(`${key}: ${e.message}`);\n    }\n  }\n  \n  // Fail fast with all errors\n  if (errors.length > 0) {\n    const message = `Configuration validation failed:\\n  - ${errors.join('\\n  - ')}`;\n    throw new ConfigError(message, errors);\n  }\n  \n  return result;\n}\n\n// Create the typed configuration object\nfunction createConfig(env) {\n  const raw = loadConfig(env);\n  \n  return {\n    // Environment\n    nodeEnv: raw.NODE_ENV,\n    isDev: raw.NODE_ENV === 'development',\n    isProd: raw.NODE_ENV === 'production',\n    isStaging: raw.NODE_ENV === 'staging',\n    \n    // Server\n    port: raw.PORT,\n    \n    // Database\n    database: {\n      url: raw.DATABASE_URL\n    },\n    \n    // JWT\n    jwt: {\n      secret: raw.JWT_SECRET,\n      expiresIn: raw.JWT_EXPIRES_IN\n    },\n    \n    // Email (might be undefined)\n    email: raw.SMTP_HOST ? {\n      host: raw.SMTP_HOST,\n      port: raw.SMTP_PORT\n    } : null,\n    \n    // Feature flags\n    features: {\n      signup: raw.ENABLE_SIGNUP\n    },\n    \n    // Logging\n    logLevel: raw.LOG_LEVEL\n  };\n}\n\n// ============================================================\n// TEST\n// ============================================================\n\nconsole.log('=== Testing Valid Config ===');\ntry {\n  const config = createConfig(mockEnv);\n  console.log('Config loaded successfully!');\n  console.log('Environment:', config.nodeEnv);\n  console.log('Is Dev:', config.isDev);\n  console.log('Port:', config.port);\n  console.log('Database URL:', config.database.url);\n  console.log('JWT Expires:', config.jwt.expiresIn);\n  console.log('Email configured:', config.email !== null);\n  console.log('Signup enabled:', config.features.signup);\n  console.log('Log level:', config.logLevel);\n} catch (e) {\n  console.log('Error:', e.message);\n}\n\nconsole.log('\\n=== Testing Missing Required Config ===');\ntry {\n  const badEnv = { NODE_ENV: 'production' };  // Missing DATABASE_URL and JWT_SECRET\n  const config = createConfig(badEnv);\n} catch (e) {\n  console.log('Caught ConfigError!');\n  console.log(e.message);\n}\n\nconsole.log('\\n=== Testing Invalid Values ===');\ntry {\n  const invalidEnv = {\n    ...mockEnv,\n    PORT: 'not-a-number',\n    NODE_ENV: 'invalid-env'\n  };\n  const config = createConfig(invalidEnv);\n} catch (e) {\n  console.log('Caught validation error!');\n  console.log(e.message);\n}\n\nconsole.log('\\n=== Testing Production Config ===');\nconst prodEnv = {\n  NODE_ENV: 'production',\n  PORT: '8080',\n  DATABASE_URL: 'postgresql://prod-server:5432/mydb',\n  JWT_SECRET: 'production-secret-key-minimum-20-chars',\n  LOG_LEVEL: 'warn'\n};\n\ntry {\n  const config = createConfig(prodEnv);\n  console.log('Production config loaded!');\n  console.log('Is Prod:', config.isProd);\n  console.log('Port:', config.port);\n  console.log('Log Level:', config.logLevel);\n} catch (e) {\n  console.log('Error:', e.message);\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Valid config should load successfully",
                  "expectedOutput": "Config loaded successfully!",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Missing required config should throw error",
                  "expectedOutput": "ConfigError",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Environment variables are always strings. Use coercion to convert them to the correct types (number, boolean)."
                },
                {
                  "level": 2,
                  "text": "Collect all validation errors before throwing, so developers see all problems at once instead of fixing them one by one."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not validating configuration at startup",
                  "consequence": "Missing config causes runtime errors that are hard to debug",
                  "correction": "Validate all required config when the app starts and fail fast with clear messages."
                },
                {
                  "mistake": "Using process.env directly throughout the codebase",
                  "consequence": "No type safety, easy to misspell variable names, hard to mock in tests",
                  "correction": "Create a centralized config module that validates and exports typed values."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-12",
      "title": "Module 12: Storing Data - Databases & Prisma ORM",
      "description": "Learn how to persist data using databases, SQL basics, and Prisma ORM for type-safe database access",
      "difficulty": "advanced",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "12.1",
          "title": "What Are Databases? (The Filing Cabinet Analogy)",
          "moduleId": "module-12",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine storing customer information for a business:\n\nWithout a database (variables in memory):\n- Write customer data on sticky notes\n- Keep them on your desk\n- When you close the office (restart server), all notes are thrown away\n- No way to search through thousands of notes efficiently\n- Notes get lost, damaged, or mixed up\n\nWith a database (persistent storage):\n- Organized filing cabinet with labeled drawers\n- Customer files stay there even when office closes\n- Can quickly find any customer using the index\n- Multiple people can access files simultaneously\n- Backup copies exist for safety\n\nDatabases are like permanent, organized filing systems for your application's data. They persist information even when your server restarts!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Understanding Databases - Concept Demo\n\n// PROBLEM: In-memory storage (data is temporary)\nlet users = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' }\n];\n\nconsole.log('Users in memory:', users.length); // 2\n\n// When server restarts... POOF! Data is gone!\n// users = [];  // Lost forever!\n\n// DATABASE CONCEPTS\n\n// 1. PERSISTENCE - Data survives server restarts\nconsole.log('Database benefit: Data persists across restarts');\n\n// 2. STRUCTURED DATA - Tables with columns\n/*\n  Users Table:\n  ┌────┬────────┬──────────────────────┐\n  │ id │ name   │ email                │\n  ├────┼────────┼──────────────────────┤\n  │ 1  │ Alice  │ alice@example.com    │\n  │ 2  │ Bob    │ bob@example.com      │\n  └────┴────────┴──────────────────────┘\n*/\n\n// 3. RELATIONSHIPS - Tables can connect to each other\n/*\n  Posts Table:\n  ┌────┬────────────────┬───────────┐\n  │ id │ title          │ userId    │\n  ├────┼────────────────┼───────────┤\n  │ 1  │ First Post     │ 1 (Alice) │\n  │ 2  │ Hello World    │ 2 (Bob)   │\n  └────┴────────────────┴───────────┘\n*/\n\nconsole.log('Database benefit: Relationships between data');\n\n// 4. QUERIES - Ask questions about your data\nlet sqlExamples = [\n  'SELECT * FROM users WHERE name = \"Alice\"',\n  'SELECT * FROM posts WHERE userId = 1',\n  'SELECT users.name, posts.title FROM users JOIN posts ON users.id = posts.userId'\n];\n\nconsole.log('SQL queries let you ask complex questions:');\nsqlExamples.forEach(sql => console.log('  -', sql));\n\n// 5. TRANSACTIONS - All-or-nothing operations\nconsole.log('Database benefit: Transactions ensure data integrity');\n/*\n  Example: Transferring money\n  - Subtract $100 from Account A\n  - Add $100 to Account B\n  \n  Either BOTH happen, or NEITHER happens!\n  No lost money!\n*/\n\n// TYPES OF DATABASES\n\nlet databaseTypes = {\n  'Relational (SQL)': {\n    examples: ['PostgreSQL', 'MySQL', 'SQLite'],\n    structure: 'Tables with rows and columns',\n    uses: 'Most applications, e-commerce, banking'\n  },\n  'NoSQL (Document)': {\n    examples: ['MongoDB', 'Firestore'],\n    structure: 'JSON-like documents',\n    uses: 'Flexible schemas, real-time apps'\n  },\n  'Key-Value': {\n    examples: ['Redis', 'DynamoDB'],\n    structure: 'Simple key-value pairs',\n    uses: 'Caching, sessions, real-time'\n  }\n};\n\nconsole.log('\\nTypes of databases:');\nfor (let [type, info] of Object.entries(databaseTypes)) {\n  console.log(`${type}: ${info.examples.join(', ')}`);\n}\n\n// WHY USE A DATABASE?\nlet benefits = [\n  'Persistence: Data survives restarts',\n  'Scalability: Handle millions of records',\n  'Concurrency: Multiple users at once',\n  'Query power: Complex data searches',\n  'Data integrity: Constraints and validation',\n  'Security: Access control and encryption',\n  'Backup: Restore data if something breaks'\n];\n\nconsole.log('\\nDatabase benefits:');\nbenefits.forEach(b => console.log(`  ✓ ${b}`));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Database fundamentals:\n\n1. **Database Types**:\n   - **SQL (Relational)**: Structured tables, relationships, strict schema\n     * PostgreSQL (powerful, feature-rich)\n     * MySQL (popular, web apps)\n     * SQLite (simple, file-based)\n   \n   - **NoSQL**: Flexible structure, JSON-like\n     * MongoDB (document-based)\n     * Redis (key-value, caching)\n\n2. **Key Database Concepts**:\n   - **Table**: Collection of similar data (like a spreadsheet)\n   - **Row**: Individual record (one user, one post)\n   - **Column**: Property/field (name, email, age)\n   - **Primary Key**: Unique identifier (usually `id`)\n   - **Foreign Key**: Reference to another table (userId references users table)\n\n3. **SQL Basics** (Structured Query Language):\n   ```sql\n   -- Create table\n   CREATE TABLE users (\n     id INTEGER PRIMARY KEY,\n     name TEXT NOT NULL,\n     email TEXT UNIQUE\n   );\n   \n   -- Insert data\n   INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');\n   \n   -- Read data\n   SELECT * FROM users WHERE name = 'Alice';\n   \n   -- Update data\n   UPDATE users SET email = 'newemail@example.com' WHERE id = 1;\n   \n   -- Delete data\n   DELETE FROM users WHERE id = 1;\n   ```\n\n4. **CRUD Operations**:\n   - **C**reate: INSERT\n   - **R**ead: SELECT\n   - **U**pdate: UPDATE\n   - **D**elete: DELETE\n\n5. **Relationships**:\n   - **One-to-Many**: One user has many posts\n   - **Many-to-Many**: Users can follow many users, users have many followers\n   - **One-to-One**: User has one profile\n\n6. **Choosing a Database**:\n   - **PostgreSQL**: Production apps, complex queries, reliability\n   - **SQLite**: Development, simple apps, mobile apps\n   - **MongoDB**: Flexible schemas, rapid prototyping\n   - **Redis**: Caching, sessions, real-time features"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common database misconceptions:\n\n1. **\"Databases are too complex for beginners\"**:\n   - Start simple with SQLite or Prisma\n   - You don't need to be a DBA to use databases\n   - ORMs (like Prisma) make it much easier\n\n2. **\"I can just use variables/files instead\"**:\n   ```javascript\n   // This seems easier but...\n   let users = [];  // Lost on restart!\n   \n   // Or\n   fs.writeFileSync('users.json', JSON.stringify(users));\n   // File corruption? Race conditions? Concurrent access?\n   ```\n   Databases solve these problems professionally\n\n3. **\"All databases are the same\"**:\n   - SQL databases: Structured, relations, ACID guarantees\n   - NoSQL databases: Flexible, scalable, eventual consistency\n   - Choose based on your needs!\n\n4. **\"I need to learn raw SQL first\"**:\n   - Modern ORMs (Prisma, TypeORM) abstract SQL\n   - You can learn SQL gradually\n   - Start with ORM, understand SQL over time\n\n5. **\"Databases are slow\"**:\n   - Modern databases are EXTREMELY fast\n   - Proper indexes make queries lightning quick\n   - Can handle millions of queries per second\n\n6. **\"I don't need relationships\"**:\n   - Even simple apps benefit from relationships\n   - User → Posts → Comments (natural hierarchy)\n   - Avoids data duplication\n\n7. **\"Development database vs Production database\"**:\n   - Use SQLite for development (simple, file-based)\n   - Use PostgreSQL for production (robust, scalable)\n   - Prisma makes switching databases easy!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.1-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a simple database system:\n\n1. Create an array called `database` to store user objects\n2. Create a function `insertUser(name, email)` that:\n   - Generates a unique ID\n   - Adds user to database\n   - Returns the new user\n3. Create a function `findUserByEmail(email)` that:\n   - Searches the database\n   - Returns the user or null\n4. Create a function `updateUserEmail(id, newEmail)` that:\n   - Finds user by ID\n   - Updates their email\n   - Returns true/false for success\n\nTest all functions.",
              "instructions": "Simulate a simple database system:\n\n1. Create an array called `database` to store user objects\n2. Create a function `insertUser(name, email)` that:\n   - Generates a unique ID\n   - Adds user to database\n   - Returns the new user\n3. Create a function `findUserByEmail(email)` that:\n   - Searches the database\n   - Returns the user or null\n4. Create a function `updateUserEmail(id, newEmail)` that:\n   - Finds user by ID\n   - Updates their email\n   - Returns true/false for success\n\nTest all functions.",
              "starterCode": "// Simulated database (array of objects)\nlet database = [];\nlet nextId = 1;\n\n// Function to insert a user\nfunction insertUser(name, email) {\n  let user = {\n    id: nextId++,\n    name: name,\n    email: email\n  };\n  database.push(user);\n  return user;\n}\n\n// Function to find user by email\nfunction findUserByEmail(email) {\n  return database.find(user => user.email === email) || null;\n}\n\n// Function to update user email\nfunction updateUserEmail(id, newEmail) {\n  let user = database.find(u => u.id === id);\n  if (user) {\n    user.email = newEmail;\n    return true;\n  }\n  return false;\n}\n\n// Test the functions\nlet user1 = insertUser('Alice', 'alice@example.com');\nconsole.log('Inserted:', user1);\n\nlet found = findUserByEmail('alice@example.com');\nconsole.log('Found:', found);\n\nlet updated = updateUserEmail(1, 'alice.new@example.com');\nconsole.log('Updated:', updated);\nconsole.log('Database:', database);",
              "solution": "// Complete database simulation\nlet database = [];\nlet nextId = 1;\n\n// Insert user\nfunction insertUser(name, email) {\n  let user = {\n    id: nextId++,\n    name: name,\n    email: email,\n    createdAt: new Date().toISOString()\n  };\n  database.push(user);\n  console.log(`✓ Inserted user ID ${user.id}`);\n  return user;\n}\n\n// Find user by email\nfunction findUserByEmail(email) {\n  let user = database.find(u => u.email === email);\n  return user || null;\n}\n\n// Update user email\nfunction updateUserEmail(id, newEmail) {\n  let user = database.find(u => u.id === id);\n  if (user) {\n    let oldEmail = user.email;\n    user.email = newEmail;\n    console.log(`✓ Updated user ${id}: ${oldEmail} → ${newEmail}`);\n    return true;\n  }\n  console.log(`✗ User ${id} not found`);\n  return false;\n}\n\n// Delete user\nfunction deleteUser(id) {\n  let index = database.findIndex(u => u.id === id);\n  if (index !== -1) {\n    let deleted = database.splice(index, 1)[0];\n    console.log(`✓ Deleted user ${id}`);\n    return deleted;\n  }\n  return null;\n}\n\n// List all users\nfunction getAllUsers() {\n  return database;\n}\n\n// Test the database\nconsole.log('=== Database Simulation ===\\n');\n\nlet alice = insertUser('Alice', 'alice@example.com');\nlet bob = insertUser('Bob', 'bob@example.com');\nlet charlie = insertUser('Charlie', 'charlie@example.com');\n\nconsole.log('\\nAll users:', getAllUsers().length);\n\nlet found = findUserByEmail('bob@example.com');\nconsole.log('\\nFound Bob:', found ? found.name : 'Not found');\n\nupdateUserEmail(1, 'alice.new@example.com');\n\ndeleteUser(2);\n\nconsole.log('\\nFinal database:', database);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should insert user with ID",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should find user by email",
                  "expectedOutput": "Alice",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use array methods: push() to add, find() to search, and direct property assignment to update."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common database misconceptions:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common database misconceptions:"
                },
                {
                  "mistake": "**\"Databases are too complex for beginners\"**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**\"Databases are too complex for beginners\"**:\n   - Start simple with SQLite or Prisma\n   - You don't need to be a DBA to use databases\n   - ORMs (like Prisma) make it much easier"
                },
                {
                  "mistake": "**\"I can just use variables/files instead\"**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**\"I can just use variables/files instead\"**:\n   ```javascript\n   // This seems easier but...\n   let users = [];  // Lost on restart!\n   \n   // Or\n   fs.writeFileSync('users.json', JSON.stringify(users));\n   // File corruption? Race conditions? Concurrent access?\n   ```\n   Databases solve these problems professionally"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12.2",
          "title": "Introduction to Prisma ORM (The Translator Analogy)",
          "moduleId": "module-12",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're traveling in a foreign country:\n\nWithout a translator (raw SQL):\n- You need to learn the local language fluently\n- Every conversation requires you to form sentences carefully\n- Easy to make grammar mistakes\n- Different regions have different dialects (MySQL vs PostgreSQL)\n- Stressful and error-prone\n\nWith a translator (Prisma ORM):\n- You speak in your native language (TypeScript/JavaScript)\n- Translator converts to local language (SQL)\n- Translator knows all the dialects\n- Type-safe: Translator stops you from saying nonsense\n- Confident communication!\n\nPrisma ORM (Object-Relational Mapping) is a translator between your JavaScript code and your database. You write TypeScript, Prisma generates the SQL!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Prisma ORM Demonstration (Conceptual)\n// In real projects, Prisma generates TypeScript types automatically!\n\n// TRADITIONAL WAY: Raw SQL (error-prone)\nlet rawSQL = `\n  SELECT users.name, posts.title \n  FROM users \n  JOIN posts ON users.id = posts.userId \n  WHERE users.email = 'alice@example.com'\n`;\n\nconsole.log('Raw SQL (requires SQL knowledge):', rawSQL);\nconsole.log('Problems: SQL injection, typos, no type safety\\n');\n\n// PRISMA WAY: Type-safe JavaScript/TypeScript\n// (Simulated - real Prisma connects to actual database)\n\nclass PrismaClient {\n  constructor() {\n    this.user = {\n      create: async (data) => {\n        console.log('[Prisma] Creating user:', data.data);\n        return { id: 1, ...data.data, createdAt: new Date() };\n      },\n      findUnique: async (query) => {\n        console.log('[Prisma] Finding user where:', query.where);\n        return {\n          id: 1,\n          name: 'Alice',\n          email: 'alice@example.com',\n          posts: [\n            { id: 1, title: 'First Post', content: 'Hello!' }\n          ]\n        };\n      },\n      findMany: async (query) => {\n        console.log('[Prisma] Finding many users');\n        return [\n          { id: 1, name: 'Alice', email: 'alice@example.com' },\n          { id: 2, name: 'Bob', email: 'bob@example.com' }\n        ];\n      },\n      update: async (query) => {\n        console.log('[Prisma] Updating user:', query.where, 'with:', query.data);\n        return { id: 1, ...query.data };\n      },\n      delete: async (query) => {\n        console.log('[Prisma] Deleting user:', query.where);\n        return { id: 1, name: 'Alice' };\n      }\n    };\n    \n    this.post = {\n      create: async (data) => {\n        console.log('[Prisma] Creating post:', data.data);\n        return { id: 1, ...data.data };\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// PRISMA EXAMPLES (async/await pattern)\n\n// 1. CREATE a user\nasync function createUser() {\n  let user = await prisma.user.create({\n    data: {\n      name: 'Alice',\n      email: 'alice@example.com'\n    }\n  });\n  console.log('Created user:', user);\n  return user;\n}\n\n// 2. FIND a user by email\nasync function findUser() {\n  let user = await prisma.user.findUnique({\n    where: {\n      email: 'alice@example.com'\n    },\n    include: {\n      posts: true  // Include related posts!\n    }\n  });\n  console.log('Found user with posts:', user);\n  return user;\n}\n\n// 3. UPDATE a user\nasync function updateUser() {\n  let user = await prisma.user.update({\n    where: { id: 1 },\n    data: {\n      name: 'Alice Smith'\n    }\n  });\n  console.log('Updated user:', user);\n  return user;\n}\n\n// 4. DELETE a user\nasync function deleteUser() {\n  let user = await prisma.user.delete({\n    where: { id: 1 }\n  });\n  console.log('Deleted user:', user);\n  return user;\n}\n\n// 5. LIST all users\nasync function listUsers() {\n  let users = await prisma.user.findMany();\n  console.log('All users:', users);\n  return users;\n}\n\n// Run examples\nconsole.log('=== Prisma ORM Examples ===\\n');\n\ncreateUser();\nsetTimeout(() => findUser(), 100);\nsetTimeout(() => updateUser(), 200);\nsetTimeout(() => listUsers(), 300);\n\n// PRISMA BENEFITS\nconsole.log('\\n=== Prisma Benefits ===');\nlet benefits = [\n  '✓ Type-safe database queries (TypeScript)',\n  '✓ Auto-generated types from schema',\n  '✓ Database agnostic (PostgreSQL, MySQL, SQLite, etc.)',\n  '✓ Intuitive API (JavaScript objects, not SQL strings)',\n  '✓ Migrations built-in',\n  '✓ Prisma Studio (database GUI)',\n  '✓ Query builder prevents SQL injection',\n  '✓ Excellent autocomplete in IDE'\n];\n\nbenefits.forEach(b => console.log(b));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding Prisma ORM:\n\n1. **What is Prisma?**\n   - Modern ORM (Object-Relational Mapping)\n   - Translates TypeScript ↔ SQL\n   - Type-safe database client\n   - Works with PostgreSQL, MySQL, SQLite, MongoDB, etc.\n\n2. **Prisma Setup** (typical workflow):\n   ```bash\n   # Install Prisma\n   npm install prisma --save-dev\n   npm install @prisma/client\n   \n   # Initialize Prisma\n   npx prisma init\n   \n   # This creates:\n   # - prisma/schema.prisma (database schema)\n   # - .env (database connection string)\n   ```\n\n3. **Prisma Schema** (schema.prisma):\n   ```prisma\n   model User {\n     id        Int      @id @default(autoincrement())\n     email     String   @unique\n     name      String\n     posts     Post[]\n     createdAt DateTime @default(now())\n   }\n   \n   model Post {\n     id        Int      @id @default(autoincrement())\n     title     String\n     content   String?\n     published Boolean  @default(false)\n     userId    Int\n     user      User     @relation(fields: [userId], references: [id])\n   }\n   ```\n\n4. **Prisma Client Usage**:\n   ```typescript\n   import { PrismaClient } from '@prisma/client';\n   const prisma = new PrismaClient();\n   \n   // All your database operations...\n   ```\n\n5. **CRUD Operations**:\n   - **Create**: `prisma.user.create({ data: {...} })`\n   - **Read**: `prisma.user.findUnique({ where: {...} })`\n   - **Update**: `prisma.user.update({ where: {...}, data: {...} })`\n   - **Delete**: `prisma.user.delete({ where: {...} })`\n\n6. **Relationships**:\n   ```typescript\n   // Get user with all their posts\n   const userWithPosts = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: { posts: true }\n   });\n   ```\n\n7. **Migrations** (database schema changes):\n   ```bash\n   # Create migration\n   npx prisma migrate dev --name add_users_table\n   \n   # Apply migrations to production\n   npx prisma migrate deploy\n   ```\n\n8. **Prisma Studio** (database GUI):\n   ```bash\n   npx prisma studio\n   # Opens visual database editor in browser\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Prisma mistakes:\n\n1. **Forgetting async/await**:\n   ```typescript\n   // Wrong!\n   let user = prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.name); // ERROR: user is a Promise!\n   \n   // Correct!\n   let user = await prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.name); // Works!\n   ```\n\n2. **Not running migrations**:\n   - After changing schema.prisma, run: `npx prisma migrate dev`\n   - Then: `npx prisma generate` to update TypeScript types\n   - Without this, your code won't match the database!\n\n3. **Prisma Client not initialized**:\n   ```typescript\n   // Create once, reuse everywhere\n   // prisma/client.ts\n   import { PrismaClient } from '@prisma/client';\n   export const prisma = new PrismaClient();\n   \n   // other files\n   import { prisma } from './prisma/client';\n   ```\n\n4. **Not handling null results**:\n   ```typescript\n   let user = await prisma.user.findUnique({ where: { id: 999 } });\n   console.log(user.name); // ERROR if user is null!\n   \n   // Better:\n   if (!user) {\n     throw new Error('User not found');\n   }\n   console.log(user.name);\n   ```\n\n5. **Forgetting to connect/disconnect**:\n   ```typescript\n   // Usually not needed in serverless\n   // But for long-running servers:\n   await prisma.$connect();\n   // ... use prisma ...\n   await prisma.$disconnect();\n   ```\n\n6. **Schema syntax errors**:\n   ```prisma\n   // Wrong!\n   model User {\n     id Int @id\n     name String\n     // Missing newline before }\n   }\n   \n   // Correct!\n   model User {\n     id   Int    @id @default(autoincrement())\n     name String\n   }\n   ```\n\n7. **Not using Prisma Studio**:\n   - Run `npx prisma studio` to see your data visually\n   - Great for debugging and understanding your database\n   - Much easier than writing SELECT queries!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.2-challenge",
              "title": "Practice Challenge",
              "description": "Simulate Prisma-style database operations:\n\n1. Create a mock Prisma client class with a `book` property\n2. Implement these methods on the `book` object:\n   - `create(data)` - Returns new book with generated ID\n   - `findMany()` - Returns all books array\n   - `findUnique(where)` - Finds book by ID\n   - `update(where, data)` - Updates book and returns it\n\n3. Create a books array to store data\n4. Test all CRUD operations\n\nMake it feel like Prisma's API!",
              "instructions": "Simulate Prisma-style database operations:\n\n1. Create a mock Prisma client class with a `book` property\n2. Implement these methods on the `book` object:\n   - `create(data)` - Returns new book with generated ID\n   - `findMany()` - Returns all books array\n   - `findUnique(where)` - Finds book by ID\n   - `update(where, data)` - Updates book and returns it\n\n3. Create a books array to store data\n4. Test all CRUD operations\n\nMake it feel like Prisma's API!",
              "starterCode": "// Mock Prisma client\nclass PrismaClient {\n  constructor() {\n    this.booksData = [];\n    this.nextId = 1;\n    \n    this.book = {\n      create: async (options) => {\n        let book = {\n          id: this.nextId++,\n          ...options.data\n        };\n        this.booksData.push(book);\n        return book;\n      },\n      \n      findMany: async () => {\n        return this.booksData;\n      },\n      \n      findUnique: async (options) => {\n        return this.booksData.find(b => b.id === options.where.id) || null;\n      },\n      \n      update: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        if (book) {\n          Object.assign(book, options.data);\n          return book;\n        }\n        return null;\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// Test CRUD operations\nasync function testPrisma() {\n  // Create\n  let book1 = await prisma.book.create({\n    data: { title: '1984', author: 'George Orwell', pages: 328 }\n  });\n  console.log('Created:', book1);\n  \n  // Find all\n  let books = await prisma.book.findMany();\n  console.log('All books:', books);\n  \n  // Find one\n  let found = await prisma.book.findUnique({ where: { id: 1 } });\n  console.log('Found:', found);\n  \n  // Update\n  let updated = await prisma.book.update({\n    where: { id: 1 },\n    data: { pages: 330 }\n  });\n  console.log('Updated:', updated);\n}\n\ntestPrisma();",
              "solution": "// Complete Prisma-style mock client\nclass PrismaClient {\n  constructor() {\n    this.booksData = [];\n    this.nextId = 1;\n    \n    this.book = {\n      create: async (options) => {\n        let book = {\n          id: this.nextId++,\n          ...options.data,\n          createdAt: new Date()\n        };\n        this.booksData.push(book);\n        console.log(`✓ Created book ID ${book.id}`);\n        return book;\n      },\n      \n      findMany: async (options = {}) => {\n        let books = this.booksData;\n        \n        // Filter if where clause provided\n        if (options.where) {\n          books = books.filter(book => {\n            return Object.entries(options.where).every(([key, value]) => {\n              return book[key] === value;\n            });\n          });\n        }\n        \n        return books;\n      },\n      \n      findUnique: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        return book || null;\n      },\n      \n      update: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        if (book) {\n          Object.assign(book, options.data);\n          book.updatedAt = new Date();\n          console.log(`✓ Updated book ID ${book.id}`);\n          return book;\n        }\n        throw new Error(`Book with ID ${options.where.id} not found`);\n      },\n      \n      delete: async (options) => {\n        let index = this.booksData.findIndex(b => b.id === options.where.id);\n        if (index !== -1) {\n          let deleted = this.booksData.splice(index, 1)[0];\n          console.log(`✓ Deleted book ID ${deleted.id}`);\n          return deleted;\n        }\n        throw new Error(`Book with ID ${options.where.id} not found`);\n      },\n      \n      count: async () => {\n        return this.booksData.length;\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// Comprehensive test\nasync function testPrisma() {\n  console.log('=== Prisma-Style ORM Demo ===\\n');\n  \n  // Create books\n  await prisma.book.create({\n    data: { title: '1984', author: 'George Orwell', pages: 328 }\n  });\n  \n  await prisma.book.create({\n    data: { title: 'The Great Gatsby', author: 'F. Scott Fitzgerald', pages: 180 }\n  });\n  \n  // Find all\n  let allBooks = await prisma.book.findMany();\n  console.log('\\nAll books:', allBooks.length);\n  \n  // Find specific\n  let book = await prisma.book.findUnique({ where: { id: 1 } });\n  console.log('\\nFound book:', book.title);\n  \n  // Update\n  await prisma.book.update({\n    where: { id: 1 },\n    data: { pages: 330 }\n  });\n  \n  // Count\n  let count = await prisma.book.count();\n  console.log('\\nTotal books:', count);\n  \n  // Delete\n  await prisma.book.delete({ where: { id: 2 } });\n  \n  // Final state\n  let remaining = await prisma.book.findMany();\n  console.log('\\nRemaining books:', remaining);\n}\n\ntestPrisma();",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should create book with generated ID",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should find book by id",
                  "expectedOutput": "Test",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use async functions and make methods return promises. Store books in an array."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common Prisma mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common Prisma mistakes:"
                },
                {
                  "mistake": "**Forgetting async/await**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting async/await**:\n   ```typescript\n   // Wrong!\n   let user = prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.name); // ERROR: user is a Promise!\n   \n   // Correct!\n   let user = await prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.name); // Works!\n   ```"
                },
                {
                  "mistake": "**Not running migrations**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Not running migrations**:\n   - After changing schema.prisma, run: `npx prisma migrate dev`\n   - Then: `npx prisma generate` to update TypeScript types\n   - Without this, your code won't match the database!"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12.3",
          "title": "Writing the Prisma Schema (The Blueprint Analogy)",
          "moduleId": "module-12",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're an architect designing a house:\n\nWithout a blueprint:\n- Builders have no clear plan\n- Everyone interprets requirements differently\n- Walls might not line up\n- No standard for room sizes\n- Chaos!\n\nWith a blueprint (Prisma schema):\n- Clear specification for every room\n- Exact measurements and connections\n- Everyone follows the same plan\n- Changes update the whole design\n- Professional and organized!\n\nThe Prisma schema file (schema.prisma) is your database blueprint. It defines your data models, their fields, types, and relationships. Prisma reads this file and:\n1. Creates the database tables for you\n2. Generates TypeScript types automatically\n3. Ensures your code and database always match!\n\nNo more writing SQL CREATE TABLE statements by hand!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Understanding Prisma Schema (schema.prisma file)\n// This is NOT JavaScript - it's Prisma's special language!\n\n// CONCEPTUAL DEMO - showing schema structure in JavaScript comments\n\n/*\nPrisma Schema Structure:\n\n// 1. DATABASE CONNECTION\ndatasource db {\n  provider = \"postgresql\"  // or \"mysql\", \"sqlite\", \"mongodb\"\n  url      = env(\"DATABASE_URL\")  // Connection string from .env\n}\n\n// 2. PRISMA CLIENT GENERATOR\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\n// 3. DATA MODELS (Tables)\n\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  name      String\n  password  String\n  role      String   @default(\"user\")\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  \n  posts     Post[]   // Relationship: User has many Posts\n  profile   Profile? // Relationship: User has one optional Profile\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  viewCount Int      @default(0)\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  \n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n  \n  categories Category[]\n}\n\nmodel Profile {\n  id       Int    @id @default(autoincrement())\n  bio      String?\n  avatar   String?\n  \n  userId   Int    @unique\n  user     User   @relation(fields: [userId], references: [id])\n}\n\nmodel Category {\n  id    Int    @id @default(autoincrement())\n  name  String @unique\n  \n  posts Post[]\n}\n*/\n\n// SCHEMA CONCEPTS EXPLAINED\n\nlet schemaExplanation = {\n  'Field Types': {\n    'String': 'Text data (\"hello\", \"user@example.com\")',\n    'Int': 'Whole numbers (1, 42, 1000)',\n    'Float': 'Decimal numbers (3.14, 99.99)',\n    'Boolean': 'true or false',\n    'DateTime': 'Dates and times',\n    'Json': 'JSON objects (flexible data)'\n  },\n  \n  'Attributes': {\n    '@id': 'Primary key (unique identifier)',\n    '@unique': 'Value must be unique across all records',\n    '@default(value)': 'Default value if not provided',\n    '@updatedAt': 'Auto-updates to current time on changes',\n    '@relation': 'Defines relationships between models'\n  },\n  \n  'Type Modifiers': {\n    'field String': 'Required field (cannot be null)',\n    'field String?': 'Optional field (can be null)',\n    'field String[]': 'Array of strings'\n  },\n  \n  'Default Functions': {\n    'autoincrement()': 'Auto-increment integers (1, 2, 3...)',\n    'now()': 'Current timestamp',\n    'uuid()': 'Generate random UUID',\n    'cuid()': 'Generate random CUID (shorter than UUID)'\n  }\n};\n\nconsole.log('=== Prisma Schema Concepts ===\\n');\n\nfor (let [category, details] of Object.entries(schemaExplanation)) {\n  console.log(category + ':');\n  for (let [key, desc] of Object.entries(details)) {\n    console.log(`  ${key}: ${desc}`);\n  }\n  console.log('');\n}\n\n// EXAMPLE: What this schema creates\n\nlet exampleData = {\n  users: [\n    {\n      id: 1,\n      email: 'alice@example.com',\n      name: 'Alice',\n      password: 'hashed_password',\n      role: 'user',\n      createdAt: new Date('2025-01-01'),\n      updatedAt: new Date('2025-01-15')\n    }\n  ],\n  posts: [\n    {\n      id: 1,\n      title: 'My First Post',\n      content: 'Hello world!',\n      published: true,\n      viewCount: 42,\n      authorId: 1,  // References user with id 1\n      createdAt: new Date('2025-01-10')\n    }\n  ],\n  profiles: [\n    {\n      id: 1,\n      bio: 'Software developer',\n      avatar: 'https://example.com/avatar.jpg',\n      userId: 1  // References user with id 1\n    }\n  ]\n};\n\nconsole.log('Example database structure:');\nconsole.log(JSON.stringify(exampleData, null, 2));\n\n// WORKFLOW\nconsole.log('\\n=== Prisma Schema Workflow ===');\n\nlet workflow = [\n  '1. Write schema.prisma file (define your models)',\n  '2. Run: npx prisma migrate dev --name init',\n  '   → Creates database tables',\n  '   → Creates migration files',\n  '3. Run: npx prisma generate',\n  '   → Generates TypeScript types',\n  '   → Updates Prisma Client',\n  '4. Use in your code with full type safety!'\n];\n\nworkflow.forEach(step => console.log(step));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Prisma Schema Syntax Guide:\n\n1. **File Structure** (schema.prisma):\n   ```prisma\n   // Database connection\n   datasource db {\n     provider = \"postgresql\"\n     url      = env(\"DATABASE_URL\")\n   }\n   \n   // TypeScript client generator\n   generator client {\n     provider = \"prisma-client-js\"\n   }\n   \n   // Your data models\n   model ModelName {\n     // fields here\n   }\n   ```\n\n2. **Field Syntax**:\n   ```prisma\n   model User {\n     fieldName  FieldType  @attribute\n   }\n   ```\n\n3. **Common Field Types**:\n   - `String` - Text (VARCHAR)\n   - `Int` - Integer\n   - `Float` - Decimal number\n   - `Boolean` - true/false\n   - `DateTime` - Timestamp\n   - `Json` - JSON object\n   - `Bytes` - Binary data\n\n4. **Field Attributes**:\n   ```prisma\n   id        Int      @id @default(autoincrement())\n   email     String   @unique\n   name      String   @default(\"Anonymous\")\n   createdAt DateTime @default(now())\n   updatedAt DateTime @updatedAt\n   bio       String?  // ? makes it optional\n   tags      String[] // [] makes it an array\n   ```\n\n5. **Primary Key Options**:\n   ```prisma\n   // Auto-incrementing integer\n   id Int @id @default(autoincrement())\n   \n   // UUID (random unique string)\n   id String @id @default(uuid())\n   \n   // CUID (shorter unique string)\n   id String @id @default(cuid())\n   ```\n\n6. **Unique Constraints**:\n   ```prisma\n   email String @unique  // Single unique field\n   \n   // Compound unique (combination must be unique)\n   @@unique([email, username])\n   ```\n\n7. **Indexes for Performance**:\n   ```prisma\n   email String @unique  // Automatically indexed\n   \n   // Manual index\n   @@index([email])\n   \n   // Compound index\n   @@index([lastName, firstName])\n   ```\n\n8. **Database Providers**:\n   ```prisma\n   provider = \"postgresql\"  // Recommended for production\n   provider = \"mysql\"\n   provider = \"sqlite\"      // Good for development\n   provider = \"sqlserver\"\n   provider = \"mongodb\"\n   provider = \"cockroachdb\"\n   ```\n\n9. **Environment Variables**:\n   ```prisma\n   url = env(\"DATABASE_URL\")\n   ```\n   \n   In your .env file:\n   ```\n   DATABASE_URL=\"postgresql://user:password@localhost:5432/mydb\"\n   ```\n\n10. **Complete Example**:\n    ```prisma\n    datasource db {\n      provider = \"postgresql\"\n      url      = env(\"DATABASE_URL\")\n    }\n    \n    generator client {\n      provider = \"prisma-client-js\"\n    }\n    \n    model User {\n      id        Int      @id @default(autoincrement())\n      email     String   @unique\n      name      String\n      age       Int?\n      isActive  Boolean  @default(true)\n      createdAt DateTime @default(now())\n      updatedAt DateTime @updatedAt\n    }\n    ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Prisma schema mistakes:\n\n1. **Forgetting semicolons or using wrong syntax**:\n   ```prisma\n   // Wrong! Prisma doesn't use semicolons\n   model User {\n     id Int @id;\n   }\n   \n   // Correct!\n   model User {\n     id Int @id\n   }\n   ```\n\n2. **Wrong field type capitalization**:\n   ```prisma\n   // Wrong!\n   name string  // lowercase\n   \n   // Correct!\n   name String  // Pascal case\n   ```\n\n3. **Forgetting @id attribute**:\n   ```prisma\n   // Wrong! Every model needs an @id\n   model User {\n     email String @unique\n     name  String\n   }\n   \n   // Correct!\n   model User {\n     id    Int    @id @default(autoincrement())\n     email String @unique\n     name  String\n   }\n   ```\n\n4. **Using JavaScript syntax in schema**:\n   ```prisma\n   // Wrong! This is not JavaScript\n   model User {\n     isActive: Boolean = true\n   }\n   \n   // Correct! This is Prisma schema language\n   model User {\n     isActive Boolean @default(true)\n   }\n   ```\n\n5. **Wrong default value syntax**:\n   ```prisma\n   // Wrong!\n   createdAt DateTime default(now())\n   \n   // Correct!\n   createdAt DateTime @default(now())\n   ```\n\n6. **Not running migrate after schema changes**:\n   - Changed schema.prisma?\n   - Run: `npx prisma migrate dev`\n   - Otherwise database won't match your schema!\n\n7. **Incorrect optional syntax**:\n   ```prisma\n   // Wrong!\n   bio String | null\n   \n   // Correct!\n   bio String?  // Question mark makes it optional\n   ```\n\n8. **Forgetting environment variables**:\n   - Schema uses: `url = env(\"DATABASE_URL\")`\n   - Must create .env file:\n   ```\n   DATABASE_URL=\"postgresql://user:pass@localhost:5432/db\"\n   ```\n\n9. **Using relations without foreign keys**:\n   ```prisma\n   // Incomplete! Missing authorId field\n   model Post {\n     id     Int  @id @default(autoincrement())\n     author User @relation(fields: [authorId], references: [id])\n   }\n   \n   // Correct!\n   model Post {\n     id       Int  @id @default(autoincrement())\n     authorId Int  // Foreign key field\n     author   User @relation(fields: [authorId], references: [id])\n   }\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.3-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a Prisma schema structure in JavaScript:\n\n1. Create an object called `schema` with a `models` property\n2. Add a 'Product' model with these fields:\n   - id (integer, auto-increment)\n   - name (string, required)\n   - price (number, required)\n   - inStock (boolean, default true)\n   - description (string, optional)\n   - createdAt (date, default now)\n\n3. Create a function `generateModelSQL(model)` that simulates generating SQL\n4. Display the schema structure\n\nYou're simulating what Prisma does internally!",
              "instructions": "Simulate a Prisma schema structure in JavaScript:\n\n1. Create an object called `schema` with a `models` property\n2. Add a 'Product' model with these fields:\n   - id (integer, auto-increment)\n   - name (string, required)\n   - price (number, required)\n   - inStock (boolean, default true)\n   - description (string, optional)\n   - createdAt (date, default now)\n\n3. Create a function `generateModelSQL(model)` that simulates generating SQL\n4. Display the schema structure\n\nYou're simulating what Prisma does internally!",
              "starterCode": "// Simulated Prisma schema structure\nlet schema = {\n  models: {\n    Product: {\n      fields: {\n        id: { type: 'Int', primaryKey: true, autoIncrement: true },\n        name: { type: 'String', required: true },\n        price: { type: 'Float', required: true },\n        inStock: { type: 'Boolean', default: true },\n        description: { type: 'String', required: false },\n        createdAt: { type: 'DateTime', default: 'now()' }\n      }\n    }\n  }\n};\n\n// Function to generate SQL from model\nfunction generateModelSQL(modelName, model) {\n  let sql = `CREATE TABLE ${modelName} (\\n`;\n  \n  let fields = [];\n  for (let [fieldName, field] of Object.entries(model.fields)) {\n    let line = `  ${fieldName} `;\n    \n    // Type mapping\n    if (field.type === 'Int') line += 'INTEGER';\n    else if (field.type === 'String') line += 'TEXT';\n    else if (field.type === 'Float') line += 'REAL';\n    else if (field.type === 'Boolean') line += 'BOOLEAN';\n    else if (field.type === 'DateTime') line += 'TIMESTAMP';\n    \n    // Constraints\n    if (field.primaryKey) line += ' PRIMARY KEY';\n    if (field.autoIncrement) line += ' AUTOINCREMENT';\n    if (field.required) line += ' NOT NULL';\n    if (field.default !== undefined) {\n      if (field.default === 'now()') line += ' DEFAULT CURRENT_TIMESTAMP';\n      else if (typeof field.default === 'boolean') line += ` DEFAULT ${field.default ? 1 : 0}`;\n      else line += ` DEFAULT ${field.default}`;\n    }\n    \n    fields.push(line);\n  }\n  \n  sql += fields.join(',\\n');\n  sql += '\\n);';\n  \n  return sql;\n}\n\n// Generate SQL\nlet sql = generateModelSQL('Product', schema.models.Product);\nconsole.log('Generated SQL:\\n');\nconsole.log(sql);\n\n// Display schema\nconsole.log('\\nPrisma Schema Structure:');\nconsole.log(JSON.stringify(schema, null, 2));",
              "solution": "// Complete Prisma schema simulator\nlet schema = {\n  datasource: {\n    provider: 'postgresql',\n    url: 'env(\"DATABASE_URL\")'\n  },\n  generator: {\n    provider: 'prisma-client-js'\n  },\n  models: {\n    Product: {\n      fields: {\n        id: {\n          type: 'Int',\n          primaryKey: true,\n          autoIncrement: true\n        },\n        name: {\n          type: 'String',\n          required: true\n        },\n        price: {\n          type: 'Float',\n          required: true\n        },\n        inStock: {\n          type: 'Boolean',\n          default: true\n        },\n        description: {\n          type: 'String',\n          required: false\n        },\n        category: {\n          type: 'String',\n          default: 'General'\n        },\n        createdAt: {\n          type: 'DateTime',\n          default: 'now()'\n        },\n        updatedAt: {\n          type: 'DateTime',\n          updatedAt: true\n        }\n      }\n    },\n    Order: {\n      fields: {\n        id: {\n          type: 'Int',\n          primaryKey: true,\n          autoIncrement: true\n        },\n        productId: {\n          type: 'Int',\n          required: true\n        },\n        quantity: {\n          type: 'Int',\n          required: true,\n          default: 1\n        },\n        total: {\n          type: 'Float',\n          required: true\n        },\n        createdAt: {\n          type: 'DateTime',\n          default: 'now()'\n        }\n      }\n    }\n  }\n};\n\nfunction generateModelSQL(modelName, model) {\n  let sql = `CREATE TABLE ${modelName} (\\n`;\n  let fields = [];\n  \n  for (let [fieldName, field] of Object.entries(model.fields)) {\n    let line = `  ${fieldName} `;\n    \n    // Map Prisma types to SQL types\n    let typeMap = {\n      'Int': 'INTEGER',\n      'String': 'TEXT',\n      'Float': 'REAL',\n      'Boolean': 'BOOLEAN',\n      'DateTime': 'TIMESTAMP'\n    };\n    \n    line += typeMap[field.type] || 'TEXT';\n    \n    if (field.primaryKey) line += ' PRIMARY KEY';\n    if (field.autoIncrement) line += ' AUTOINCREMENT';\n    if (field.required) line += ' NOT NULL';\n    \n    if (field.default !== undefined) {\n      if (field.default === 'now()') {\n        line += ' DEFAULT CURRENT_TIMESTAMP';\n      } else if (typeof field.default === 'boolean') {\n        line += ` DEFAULT ${field.default ? 1 : 0}`;\n      } else if (typeof field.default === 'string') {\n        line += ` DEFAULT '${field.default}'`;\n      } else {\n        line += ` DEFAULT ${field.default}`;\n      }\n    }\n    \n    fields.push(line);\n  }\n  \n  sql += fields.join(',\\n');\n  sql += '\\n);';\n  return sql;\n}\n\nconsole.log('=== Prisma Schema Simulator ===\\n');\n\n// Generate SQL for all models\nfor (let [modelName, model] of Object.entries(schema.models)) {\n  console.log(`${modelName} Model SQL:\\n`);\n  console.log(generateModelSQL(modelName, model));\n  console.log('');\n}\n\n// Display schema structure\nconsole.log('Complete Prisma Schema:');\nconsole.log(`datasource: ${schema.datasource.provider}`);\nconsole.log(`generator: ${schema.generator.provider}`);\nconsole.log(`models: ${Object.keys(schema.models).join(', ')}`);\nconsole.log('\\nDetailed Schema:');\nconsole.log(JSON.stringify(schema, null, 2));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Schema has Product model",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Product has required name field",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Create nested objects: schema → models → Product → fields → {id, name, price...}"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common Prisma schema mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common Prisma schema mistakes:"
                },
                {
                  "mistake": "**Forgetting semicolons or using wrong syntax**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting semicolons or using wrong syntax**:\n   ```prisma\n   // Wrong! Prisma doesn't use semicolons\n   model User {\n     id Int @id;\n   }\n   \n   // Correct!\n   model User {\n     id Int @id\n   }\n   ```"
                },
                {
                  "mistake": "**Wrong field type capitalization**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong field type capitalization**:\n   ```prisma\n   // Wrong!\n   name string  // lowercase\n   \n   // Correct!\n   name String  // Pascal case\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12.4",
          "title": "Running Migrations (The Construction Log Analogy)",
          "moduleId": "module-12",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're building a house over several months:\n\nWithout a construction log:\n- Workers forget what was done yesterday\n- No record of foundation changes\n- Can't rebuild if something breaks\n- No way to share changes with other teams\n- Every site does things differently\n\nWith a construction log (Prisma migrations):\n- Detailed record of every change\n- Day 1: Poured foundation\n- Day 5: Built first floor walls\n- Day 10: Added plumbing\n- Any worker can see the full history\n- Can replay changes to build identical houses\n\nPrisma migrations are a construction log for your database. Each migration file records ONE specific change (like adding a table or field). These files:\n1. Track database evolution over time\n2. Can be replayed on other computers\n3. Make it easy to update production databases\n4. Keep your team synchronized\n\nInstead of manually writing SQL to update your database, Prisma generates migration files automatically from your schema changes!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Understanding Prisma Migrations\n// Migrations are SQL files that modify your database structure\n\n// SCENARIO: Building a blog app\n\n// Step 1: Initial schema (schema.prisma)\n/*\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String\n}\n*/\n\n// Run migration command:\n// npx prisma migrate dev --name init\n\n// Prisma generates:\n// migrations/20250114_init/migration.sql\n/*\nCREATE TABLE \"User\" (\n  \"id\" INTEGER PRIMARY KEY AUTOINCREMENT,\n  \"email\" TEXT UNIQUE NOT NULL,\n  \"name\" TEXT NOT NULL\n);\n*/\n\nconsole.log('Migration 1: Created User table');\n\n// Step 2: Add posts table\n// Update schema.prisma:\n/*\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String\n  posts Post[]  // NEW: Added relationship\n}\n\nmodel Post {  // NEW: Added entire model\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n}\n*/\n\n// Run migration:\n// npx prisma migrate dev --name add_posts\n\n// Prisma generates:\n// migrations/20250114_add_posts/migration.sql\n/*\nCREATE TABLE \"Post\" (\n  \"id\" INTEGER PRIMARY KEY AUTOINCREMENT,\n  \"title\" TEXT NOT NULL,\n  \"content\" TEXT,\n  \"published\" BOOLEAN NOT NULL DEFAULT 0,\n  \"authorId\" INTEGER NOT NULL,\n  FOREIGN KEY (\"authorId\") REFERENCES \"User\"(\"id\")\n);\n*/\n\nconsole.log('Migration 2: Created Post table with relationship to User');\n\n// Step 3: Add createdAt timestamps\n// Update schema.prisma:\n/*\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  name      String\n  createdAt DateTime @default(now())  // NEW\n  posts     Post[]\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  createdAt DateTime @default(now())  // NEW\n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n}\n*/\n\n// Run migration:\n// npx prisma migrate dev --name add_timestamps\n\n// Prisma generates:\n// migrations/20250114_add_timestamps/migration.sql\n/*\nALTER TABLE \"User\" ADD COLUMN \"createdAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;\nALTER TABLE \"Post\" ADD COLUMN \"createdAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;\n*/\n\nconsole.log('Migration 3: Added createdAt to User and Post tables');\n\n// MIGRATION COMMANDS EXPLAINED\n\nlet migrationCommands = {\n  'Development': {\n    'npx prisma migrate dev': 'Create and apply migrations in development',\n    'npx prisma migrate dev --name <name>': 'Create migration with descriptive name',\n    'npx prisma migrate reset': 'Reset database and replay all migrations',\n    'npx prisma db push': 'Quick prototype without creating migration file'\n  },\n  \n  'Production': {\n    'npx prisma migrate deploy': 'Apply pending migrations to production',\n    'npx prisma migrate resolve': 'Mark migration as applied/rolled back',\n    'npx prisma migrate status': 'Check which migrations are pending'\n  },\n  \n  'Inspection': {\n    'npx prisma migrate diff': 'Compare database to schema',\n    'npx prisma db pull': 'Introspect existing database to generate schema',\n    'npx prisma studio': 'Visual database browser'\n  }\n};\n\nconsole.log('\\n=== Prisma Migration Commands ===\\n');\n\nfor (let [category, commands] of Object.entries(migrationCommands)) {\n  console.log(category + ' Commands:');\n  for (let [cmd, desc] of Object.entries(commands)) {\n    console.log(`  ${cmd}`);\n    console.log(`    → ${desc}`);\n  }\n  console.log('');\n}\n\n// MIGRATION WORKFLOW SIMULATION\n\nlet migrationHistory = [\n  {\n    name: '20250114_init',\n    description: 'Initial database setup',\n    changes: ['Created User table']\n  },\n  {\n    name: '20250114_add_posts',\n    description: 'Add blog posts',\n    changes: ['Created Post table', 'Added User.posts relation']\n  },\n  {\n    name: '20250114_add_timestamps',\n    description: 'Add audit timestamps',\n    changes: ['Added User.createdAt', 'Added Post.createdAt']\n  }\n];\n\nconsole.log('Migration History:');\nmigrationHistory.forEach((migration, index) => {\n  console.log(`\\n${index + 1}. ${migration.name}`);\n  console.log(`   Description: ${migration.description}`);\n  console.log('   Changes:');\n  migration.changes.forEach(change => {\n    console.log(`     - ${change}`);\n  });\n});\n\n// BENEFITS OF MIGRATIONS\n\nlet benefits = [\n  'Version control: Track database changes like code',\n  'Reproducible: Same migrations = identical databases',\n  'Team sync: Everyone applies same changes',\n  'Rollback: Can undo changes if needed',\n  'Production safety: Test migrations before deploying',\n  'Documentation: Clear history of schema evolution',\n  'CI/CD: Automated database updates in pipelines'\n];\n\nconsole.log('\\nBenefits of Migrations:');\nbenefits.forEach(benefit => console.log(`  ✓ ${benefit}`));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Prisma Migration Commands Guide:\n\n1. **Creating Migrations** (Development):\n   ```bash\n   # Standard workflow\n   npx prisma migrate dev --name add_user_table\n   \n   # What this does:\n   # 1. Compares schema.prisma to current database\n   # 2. Generates SQL migration file\n   # 3. Applies migration to database\n   # 4. Runs prisma generate (updates Prisma Client)\n   ```\n\n2. **Migration File Structure**:\n   ```\n   prisma/\n   ├── schema.prisma\n   └── migrations/\n       ├── 20250114120000_init/\n       │   └── migration.sql\n       ├── 20250114130000_add_posts/\n       │   └── migration.sql\n       └── migration_lock.toml\n   ```\n\n3. **Example Migration File**:\n   ```sql\n   -- CreateTable\n   CREATE TABLE \"User\" (\n       \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n       \"email\" TEXT NOT NULL,\n       \"name\" TEXT NOT NULL\n   );\n   \n   -- CreateIndex\n   CREATE UNIQUE INDEX \"User_email_key\" ON \"User\"(\"email\");\n   ```\n\n4. **Common Migration Workflows**:\n\n   **First Migration**:\n   ```bash\n   # 1. Write schema.prisma\n   # 2. Create initial migration\n   npx prisma migrate dev --name init\n   ```\n\n   **Add New Table**:\n   ```bash\n   # 1. Add model to schema.prisma\n   # 2. Create migration\n   npx prisma migrate dev --name add_posts\n   ```\n\n   **Modify Existing Table**:\n   ```bash\n   # 1. Update model in schema.prisma\n   # 2. Create migration\n   npx prisma migrate dev --name add_user_bio\n   ```\n\n5. **Development vs Production**:\n\n   **Development** (migrate dev):\n   - Creates migration files\n   - Applies to local database\n   - Updates Prisma Client\n   - Can reset database easily\n   \n   ```bash\n   npx prisma migrate dev\n   ```\n\n   **Production** (migrate deploy):\n   - Only applies existing migrations\n   - Never creates new migrations\n   - Safe for production\n   - No schema changes\n   \n   ```bash\n   npx prisma migrate deploy\n   ```\n\n6. **Reset Database** (Development Only!):\n   ```bash\n   npx prisma migrate reset\n   \n   # This:\n   # 1. Drops entire database\n   # 2. Creates new database\n   # 3. Applies all migrations\n   # 4. Runs seed script (if exists)\n   ```\n\n7. **Prototyping Without Migrations**:\n   ```bash\n   npx prisma db push\n   \n   # Use when:\n   # - Early prototyping\n   # - Don't want migration files yet\n   # - Quick schema tests\n   \n   # DON'T use in production!\n   ```\n\n8. **Check Migration Status**:\n   ```bash\n   npx prisma migrate status\n   \n   # Shows:\n   # - Applied migrations\n   # - Pending migrations\n   # - Database drift (manual changes)\n   ```\n\n9. **Naming Conventions**:\n   ```bash\n   # Good names (descriptive):\n   npx prisma migrate dev --name init\n   npx prisma migrate dev --name add_user_profile\n   npx prisma migrate dev --name make_email_unique\n   npx prisma migrate dev --name add_post_comments\n   \n   # Bad names (not descriptive):\n   npx prisma migrate dev --name update\n   npx prisma migrate dev --name fix\n   npx prisma migrate dev --name changes\n   ```\n\n10. **Full Deployment Workflow**:\n    ```bash\n    # Development:\n    git checkout -b feature/add-comments\n    # Update schema.prisma\n    npx prisma migrate dev --name add_comments\n    git add prisma/\n    git commit -m \"Add comments table\"\n    git push\n    \n    # Production (CI/CD or manual):\n    git pull\n    npx prisma migrate deploy  # Apply pending migrations\n    npm run build\n    npm run start\n    ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common migration mistakes:\n\n1. **Forgetting to run migrations**:\n   ```bash\n   # Changed schema.prisma but database not updated!\n   \n   # Must run:\n   npx prisma migrate dev\n   ```\n\n2. **Using db push in production**:\n   ```bash\n   # NEVER do this in production:\n   npx prisma db push  # No migration history!\n   \n   # Use migrate deploy instead:\n   npx prisma migrate deploy\n   ```\n\n3. **Editing migration files manually**:\n   - Don't edit generated migrations unless absolutely necessary\n   - Prisma tracks checksums - manual edits can cause errors\n   - Better: create new migration to fix issues\n\n4. **Not committing migration files**:\n   ```bash\n   # WRONG: Ignoring migrations in .gitignore\n   prisma/migrations/  # Don't do this!\n   \n   # CORRECT: Commit migrations to git\n   git add prisma/migrations/\n   git commit -m \"Add user table migration\"\n   ```\n\n5. **Running migrate dev in production**:\n   ```bash\n   # Development:\n   npx prisma migrate dev  # Creates migrations\n   \n   # Production:\n   npx prisma migrate deploy  # Only applies existing migrations\n   ```\n\n6. **Schema drift (manual database changes)**:\n   ```bash\n   # Problem: Someone manually altered database\n   # Solution: Check drift\n   npx prisma migrate diff\n   \n   # Then either:\n   # - Revert manual changes\n   # - Create migration to match changes\n   ```\n\n7. **Migration conflicts in teams**:\n   ```bash\n   # Two developers create migrations at same time\n   # Git merge conflict in migrations folder\n   \n   # Resolution:\n   # 1. Pull latest changes\n   # 2. Reset local database\n   npx prisma migrate reset\n   # 3. Migrations will replay in correct order\n   ```\n\n8. **Forgetting to generate Prisma Client**:\n   ```bash\n   # After migration, types might be outdated\n   npx prisma generate\n   \n   # Or use migrate dev which does it automatically\n   npx prisma migrate dev\n   ```\n\n9. **Not testing migrations**:\n   ```bash\n   # Best practice:\n   # 1. Create migration in development\n   npx prisma migrate dev --name add_feature\n   \n   # 2. Test thoroughly\n   npm run test\n   \n   # 3. Deploy to staging\n   npx prisma migrate deploy\n   \n   # 4. Test staging\n   \n   # 5. Deploy to production\n   npx prisma migrate deploy\n   ```\n\n10. **Breaking changes without data migration**:\n    ```prisma\n    // Dangerous: Deleting field loses data!\n    model User {\n      id    Int    @id\n      email String\n      // name String  ← Deleted! Data lost!\n    }\n    \n    // Better: Make optional first, then remove later\n    model User {\n      id    Int     @id\n      email String\n      name  String? ← Made optional, can migrate data\n    }\n    ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.4-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a migration system:\n\n1. Create a `migrations` array to store migration records\n2. Create a function `createMigration(name, sql)` that:\n   - Generates a timestamp\n   - Creates migration object\n   - Adds to migrations array\n   - Returns the migration\n3. Create a function `applyMigrations()` that:\n   - Loops through all migrations\n   - Simulates executing SQL\n   - Tracks which are applied\n4. Simulate creating 3 migrations:\n   - 'init' (create users table)\n   - 'add_posts' (create posts table)\n   - 'add_timestamps' (add createdAt fields)\n5. Display migration history\n\nYou're simulating what Prisma does!",
              "instructions": "Simulate a migration system:\n\n1. Create a `migrations` array to store migration records\n2. Create a function `createMigration(name, sql)` that:\n   - Generates a timestamp\n   - Creates migration object\n   - Adds to migrations array\n   - Returns the migration\n3. Create a function `applyMigrations()` that:\n   - Loops through all migrations\n   - Simulates executing SQL\n   - Tracks which are applied\n4. Simulate creating 3 migrations:\n   - 'init' (create users table)\n   - 'add_posts' (create posts table)\n   - 'add_timestamps' (add createdAt fields)\n5. Display migration history\n\nYou're simulating what Prisma does!",
              "starterCode": "// Migration system simulator\nlet migrations = [];\nlet appliedMigrations = new Set();\n\n// Create migration\nfunction createMigration(name, sql) {\n  let timestamp = Date.now();\n  let migration = {\n    id: `${timestamp}_${name}`,\n    name: name,\n    sql: sql,\n    createdAt: new Date().toISOString()\n  };\n  \n  migrations.push(migration);\n  console.log(`✓ Created migration: ${migration.id}`);\n  return migration;\n}\n\n// Apply migrations\nfunction applyMigrations() {\n  console.log('\\nApplying migrations...');\n  \n  for (let migration of migrations) {\n    if (!appliedMigrations.has(migration.id)) {\n      console.log(`  Running: ${migration.name}`);\n      console.log(`  SQL: ${migration.sql}`);\n      appliedMigrations.add(migration.id);\n      console.log(`  ✓ Applied: ${migration.id}\\n`);\n    } else {\n      console.log(`  ⊘ Skipped (already applied): ${migration.name}`);\n    }\n  }\n}\n\n// Get migration status\nfunction getMigrationStatus() {\n  console.log('=== Migration Status ===');\n  console.log(`Total migrations: ${migrations.length}`);\n  console.log(`Applied: ${appliedMigrations.size}`);\n  console.log(`Pending: ${migrations.length - appliedMigrations.size}`);\n}\n\n// Create migrations\nconsole.log('=== Creating Migrations ===\\n');\n\ncreateMigration('init', 'CREATE TABLE users (id INT, email TEXT, name TEXT);');\n\nsetTimeout(() => {\n  createMigration('add_posts', 'CREATE TABLE posts (id INT, title TEXT, author_id INT);');\n}, 100);\n\nsetTimeout(() => {\n  createMigration('add_timestamps', 'ALTER TABLE users ADD COLUMN created_at TIMESTAMP;');\n}, 200);\n\nsetTimeout(() => {\n  applyMigrations();\n  getMigrationStatus();\n  \n  console.log('\\n=== Migration History ===');\n  migrations.forEach((m, i) => {\n    let status = appliedMigrations.has(m.id) ? '✓ Applied' : '⏳ Pending';\n    console.log(`${i + 1}. ${m.name} - ${status}`);\n  });\n}, 400);",
              "solution": "// Complete migration system simulator\nlet migrations = [];\nlet appliedMigrations = new Set();\nlet database = {\n  tables: {},\n  indexes: []\n};\n\nfunction createMigration(name, description, sql) {\n  let timestamp = Date.now();\n  let migration = {\n    id: `${timestamp}_${name}`,\n    name: name,\n    description: description,\n    sql: sql,\n    createdAt: new Date().toISOString(),\n    applied: false\n  };\n  \n  migrations.push(migration);\n  console.log(`✓ Created migration: ${migration.id}`);\n  console.log(`  Description: ${description}`);\n  return migration;\n}\n\nfunction applyMigrations() {\n  console.log('\\n=== Applying Migrations ===\\n');\n  \n  let applied = 0;\n  for (let migration of migrations) {\n    if (!appliedMigrations.has(migration.id)) {\n      console.log(`Running: ${migration.name}`);\n      console.log(`SQL: ${migration.sql}`);\n      \n      // Simulate executing SQL\n      executeSQLSimulation(migration.sql);\n      \n      appliedMigrations.add(migration.id);\n      migration.applied = true;\n      applied++;\n      \n      console.log(`✓ Applied: ${migration.id}\\n`);\n    } else {\n      console.log(`⊘ Skipped (already applied): ${migration.name}\\n`);\n    }\n  }\n  \n  console.log(`Completed: ${applied} migration(s) applied`);\n}\n\nfunction executeSQLSimulation(sql) {\n  // Simulate SQL execution\n  if (sql.includes('CREATE TABLE')) {\n    let match = sql.match(/CREATE TABLE (\\w+)/);\n    if (match) {\n      let tableName = match[1];\n      database.tables[tableName] = { created: true };\n      console.log(`  → Created table: ${tableName}`);\n    }\n  } else if (sql.includes('ALTER TABLE')) {\n    console.log('  → Altered table structure');\n  }\n}\n\nfunction getMigrationStatus() {\n  console.log('\\n=== Migration Status ===');\n  console.log(`Total migrations: ${migrations.length}`);\n  console.log(`Applied: ${appliedMigrations.size}`);\n  console.log(`Pending: ${migrations.length - appliedMigrations.size}`);\n  console.log(`Database tables: ${Object.keys(database.tables).join(', ') || 'none'}`);\n}\n\nfunction rollbackLastMigration() {\n  let lastApplied = migrations.filter(m => m.applied).pop();\n  if (lastApplied) {\n    appliedMigrations.delete(lastApplied.id);\n    lastApplied.applied = false;\n    console.log(`\\n✓ Rolled back: ${lastApplied.name}`);\n  } else {\n    console.log('\\nNo migrations to roll back');\n  }\n}\n\nfunction listMigrations() {\n  console.log('\\n=== Migration History ===');\n  migrations.forEach((m, i) => {\n    let status = m.applied ? '✓ Applied' : '⏳ Pending';\n    console.log(`${i + 1}. ${m.name}`);\n    console.log(`   ID: ${m.id}`);\n    console.log(`   Status: ${status}`);\n    console.log(`   Created: ${m.createdAt}`);\n    console.log(`   Description: ${m.description}`);\n    console.log('');\n  });\n}\n\n// Create migrations\nconsole.log('=== Migration System Simulator ===\\n');\n\ncreateMigration(\n  'init',\n  'Initial database setup',\n  'CREATE TABLE users (id INT PRIMARY KEY, email TEXT UNIQUE, name TEXT);'\n);\n\nsetTimeout(() => {\n  createMigration(\n    'add_posts',\n    'Add blog posts table',\n    'CREATE TABLE posts (id INT PRIMARY KEY, title TEXT, content TEXT, author_id INT);'\n  );\n}, 100);\n\nsetTimeout(() => {\n  createMigration(\n    'add_timestamps',\n    'Add audit timestamps',\n    'ALTER TABLE users ADD COLUMN created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;'\n  );\n}, 200);\n\nsetTimeout(() => {\n  applyMigrations();\n  getMigrationStatus();\n  listMigrations();\n}, 400);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Creates migration with timestamp",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Tracks applied migrations",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use timestamps for unique IDs, Set to track applied migrations, loops to apply each one"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common migration mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common migration mistakes:"
                },
                {
                  "mistake": "**Forgetting to run migrations**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting to run migrations**:\n   ```bash\n   # Changed schema.prisma but database not updated!\n   \n   # Must run:\n   npx prisma migrate dev\n   ```"
                },
                {
                  "mistake": "**Using db push in production**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Using db push in production**:\n   ```bash\n   # NEVER do this in production:\n   npx prisma db push  # No migration history!\n   \n   # Use migrate deploy instead:\n   npx prisma migrate deploy\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12.5",
          "title": "Handling Relations (The Social Network Analogy)",
          "moduleId": "module-12",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine designing a social network:\n\nWithout relationships:\n- Each user's posts stored separately\n- No way to find who wrote which post\n- Comments disconnected from posts\n- Can't see friends list\n- Data duplication everywhere!\n\nWith relationships (Prisma relations):\n- Users ← many → Posts (one user has many posts)\n- Posts ← many → Comments (one post has many comments)\n- Users ← many ↔ many → Users (users can follow each other)\n- Data connected logically\n- No duplication!\n\nDatabase relations are like links between different entities. They mirror real-world connections:\n- A customer has many orders\n- A blog post has many comments\n- A student enrolls in many courses\n\nPrisma makes defining these relationships incredibly simple with its intuitive syntax!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Understanding Prisma Relations\n\n// THREE TYPES OF RELATIONSHIPS:\n\n// 1. ONE-TO-MANY (Most common)\n// Example: One user has many posts\n/*\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String\n  \n  posts Post[]  // Array: User has many posts\n}\n\nmodel Post {\n  id       Int    @id @default(autoincrement())\n  title    String\n  content  String?\n  \n  authorId Int    // Foreign key\n  author   User   @relation(fields: [authorId], references: [id])\n}\n*/\n\nconsole.log('=== ONE-TO-MANY Relationship ===');\nconsole.log('One User → Many Posts');\nconsole.log('Schema: User.posts (array), Post.author (single)');\nconsole.log('');\n\n// Example data structure:\nlet oneToManyExample = {\n  user: {\n    id: 1,\n    email: 'alice@example.com',\n    name: 'Alice',\n    posts: [  // Array of posts\n      { id: 1, title: 'First Post', authorId: 1 },\n      { id: 2, title: 'Second Post', authorId: 1 },\n      { id: 3, title: 'Third Post', authorId: 1 }\n    ]\n  }\n};\n\nconsole.log('Example data:');\nconsole.log(JSON.stringify(oneToManyExample, null, 2));\nconsole.log('');\n\n// 2. ONE-TO-ONE (Less common)\n// Example: One user has one profile\n/*\nmodel User {\n  id      Int      @id @default(autoincrement())\n  email   String   @unique\n  name    String\n  \n  profile Profile? // Optional: User might not have profile yet\n}\n\nmodel Profile {\n  id     Int    @id @default(autoincrement())\n  bio    String?\n  avatar String?\n  \n  userId Int     @unique  // UNIQUE makes it one-to-one!\n  user   User    @relation(fields: [userId], references: [id])\n}\n*/\n\nconsole.log('=== ONE-TO-ONE Relationship ===');\nconsole.log('One User → One Profile');\nconsole.log('Schema: Profile.userId must be @unique');\nconsole.log('');\n\nlet oneToOneExample = {\n  user: {\n    id: 1,\n    email: 'alice@example.com',\n    name: 'Alice',\n    profile: {  // Single profile object\n      id: 1,\n      bio: 'Software developer',\n      avatar: 'https://example.com/alice.jpg',\n      userId: 1\n    }\n  }\n};\n\nconsole.log('Example data:');\nconsole.log(JSON.stringify(oneToOneExample, null, 2));\nconsole.log('');\n\n// 3. MANY-TO-MANY (Complex but powerful)\n// Example: Users can like many posts, posts can be liked by many users\n/*\nmodel User {\n  id        Int    @id @default(autoincrement())\n  email     String @unique\n  name      String\n  \n  likedPosts Post[] @relation(\"PostLikes\")\n}\n\nmodel Post {\n  id       Int      @id @default(autoincrement())\n  title    String\n  content  String?\n  \n  likedBy  User[]   @relation(\"PostLikes\")\n}\n\n// Prisma creates a join table automatically:\n// _PostLikes (userId, postId)\n*/\n\nconsole.log('=== MANY-TO-MANY Relationship ===');\nconsole.log('Many Users ↔ Many Posts (likes)');\nconsole.log('Schema: Both sides have arrays, named relation');\nconsole.log('Prisma auto-creates join table: _PostLikes');\nconsole.log('');\n\nlet manyToManyExample = {\n  user: {\n    id: 1,\n    name: 'Alice',\n    likedPosts: [  // Array of posts Alice liked\n      { id: 5, title: 'Cool Post' },\n      { id: 7, title: 'Amazing Article' }\n    ]\n  },\n  post: {\n    id: 5,\n    title: 'Cool Post',\n    likedBy: [  // Array of users who liked this post\n      { id: 1, name: 'Alice' },\n      { id: 2, name: 'Bob' },\n      { id: 3, name: 'Charlie' }\n    ]\n  }\n};\n\nconsole.log('Example data:');\nconsole.log(JSON.stringify(manyToManyExample, null, 2));\nconsole.log('');\n\n// EXPLICIT MANY-TO-MANY (when you need extra fields)\n// Example: User enrollments in courses (with enrollment date)\n/*\nmodel User {\n  id          Int          @id @default(autoincrement())\n  name        String\n  enrollments Enrollment[]\n}\n\nmodel Course {\n  id          Int          @id @default(autoincrement())\n  title       String\n  enrollments Enrollment[]\n}\n\nmodel Enrollment {\n  id         Int      @id @default(autoincrement())\n  enrolledAt DateTime @default(now())\n  grade      String?\n  \n  userId     Int\n  user       User     @relation(fields: [userId], references: [id])\n  \n  courseId   Int\n  course     Course   @relation(fields: [courseId], references: [id])\n  \n  @@unique([userId, courseId])  // Can't enroll in same course twice\n}\n*/\n\nconsole.log('=== EXPLICIT MANY-TO-MANY ===');\nconsole.log('When you need extra fields on the relationship');\nconsole.log('Example: Enrollment date, grade, status');\nconsole.log('');\n\n// QUERYING RELATIONS WITH PRISMA CLIENT\n\nlet queryExamples = [\n  '// Get user with all their posts',\n  'let user = await prisma.user.findUnique({',\n  '  where: { id: 1 },',\n  '  include: { posts: true }  // Include related posts',\n  '});',\n  '',\n  '// Get post with author info',\n  'let post = await prisma.post.findUnique({',\n  '  where: { id: 1 },',\n  '  include: { author: true }  // Include related user',\n  '});',\n  '',\n  '// Create post with author connection',\n  'let post = await prisma.post.create({',\n  '  data: {',\n  '    title: \"New Post\",',\n  '    content: \"Hello!\",',\n  '    author: {',\n  '      connect: { id: 1 }  // Connect to existing user',\n  '    }',\n  '  }',\n  '});',\n  '',\n  '// Create user with posts in one go',\n  'let user = await prisma.user.create({',\n  '  data: {',\n  '    email: \"bob@example.com\",',\n  '    name: \"Bob\",',\n  '    posts: {',\n  '      create: [  // Create posts at same time',\n  '        { title: \"First\", content: \"Content 1\" },',\n  '        { title: \"Second\", content: \"Content 2\" }',\n  '      ]',\n  '    }',\n  '  }',\n  '});'\n];\n\nconsole.log('Querying Relations:');\nqueryExamples.forEach(line => console.log(line));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Prisma Relations Syntax Guide:\n\n1. **ONE-TO-MANY Relationship**:\n   ```prisma\n   model User {\n     id    Int    @id @default(autoincrement())\n     posts Post[] // Relation field (no column in database)\n   }\n   \n   model Post {\n     id       Int  @id @default(autoincrement())\n     authorId Int  // Foreign key (actual column)\n     author   User @relation(fields: [authorId], references: [id])\n   }\n   ```\n   \n   Key points:\n   - \"Many\" side: array type (Post[])\n   - \"One\" side: singular type + @relation\n   - Foreign key: actual database column\n   - Relation field: virtual, not in database\n\n2. **ONE-TO-ONE Relationship**:\n   ```prisma\n   model User {\n     id      Int      @id\n     profile Profile? // Optional (user might not have profile)\n   }\n   \n   model Profile {\n     id     Int  @id\n     userId Int  @unique // UNIQUE makes it one-to-one!\n     user   User @relation(fields: [userId], references: [id])\n   }\n   ```\n   \n   Key points:\n   - Foreign key must be @unique\n   - One side usually optional (?)\n\n3. **MANY-TO-MANY (Implicit)**:\n   ```prisma\n   model User {\n     id    Int    @id\n     posts Post[] @relation(\"UserLikes\")\n   }\n   \n   model Post {\n     id     Int    @id\n     likedBy User[] @relation(\"UserLikes\")\n   }\n   ```\n   \n   Key points:\n   - Both sides are arrays\n   - Named relation (\"UserLikes\")\n   - Prisma auto-creates join table (_UserLikes)\n   - No foreign keys needed!\n\n4. **MANY-TO-MANY (Explicit)**:\n   ```prisma\n   model User {\n     id          Int          @id\n     enrollments Enrollment[]\n   }\n   \n   model Course {\n     id          Int          @id\n     enrollments Enrollment[]\n   }\n   \n   model Enrollment {\n     id       Int      @id\n     userId   Int\n     user     User     @relation(fields: [userId], references: [id])\n     courseId Int\n     course   Course   @relation(fields: [courseId], references: [id])\n     \n     enrolledAt DateTime @default(now())\n     grade      String?\n     \n     @@unique([userId, courseId])\n   }\n   ```\n   \n   Use when you need:\n   - Extra fields (enrolledAt, grade)\n   - Composite unique constraints\n   - More control over join table\n\n5. **Relation Attributes**:\n   ```prisma\n   @relation(fields: [authorId], references: [id])\n   ```\n   \n   - `fields`: Foreign key in this model\n   - `references`: Primary key in related model\n   - Both are arrays (can be composite keys)\n\n6. **Cascade Delete** (be careful!):\n   ```prisma\n   model User {\n     id    Int    @id\n     posts Post[]\n   }\n   \n   model Post {\n     id       Int  @id\n     authorId Int\n     author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)\n   }\n   ```\n   \n   Options:\n   - `Cascade`: Delete posts when user deleted\n   - `SetNull`: Set authorId to null\n   - `Restrict`: Prevent deletion if posts exist\n   - `NoAction`: Database default\n\n7. **Self-Relations** (like followers):\n   ```prisma\n   model User {\n     id         Int    @id\n     followers  User[] @relation(\"UserFollows\")\n     following  User[] @relation(\"UserFollows\")\n   }\n   ```\n\n8. **Querying Relations**:\n   ```typescript\n   // Include related data\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: {\n       posts: true,\n       profile: true\n     }\n   });\n   \n   // Select specific fields\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     select: {\n       name: true,\n       posts: {\n         select: {\n           title: true,\n           createdAt: true\n         }\n       }\n     }\n   });\n   \n   // Filter relations\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: {\n       posts: {\n         where: { published: true },\n         orderBy: { createdAt: 'desc' },\n         take: 5\n       }\n     }\n   });\n   ```\n\n9. **Creating with Relations**:\n   ```typescript\n   // Connect to existing\n   await prisma.post.create({\n     data: {\n       title: 'New Post',\n       author: { connect: { id: 1 } }\n     }\n   });\n   \n   // Create related\n   await prisma.user.create({\n     data: {\n       email: 'bob@example.com',\n       posts: {\n         create: [\n           { title: 'First Post' },\n           { title: 'Second Post' }\n         ]\n       }\n     }\n   });\n   \n   // Nested writes\n   await prisma.user.update({\n     where: { id: 1 },\n     data: {\n       posts: {\n         create: { title: 'Another Post' },\n         delete: { id: 5 },\n         update: {\n           where: { id: 3 },\n           data: { title: 'Updated Title' }\n         }\n       }\n     }\n   });\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common relation mistakes:\n\n1. **Forgetting foreign key field**:\n   ```prisma\n   // WRONG! Missing authorId\n   model Post {\n     id     Int  @id\n     author User @relation(fields: [authorId], references: [id])\n   }\n   \n   // CORRECT!\n   model Post {\n     id       Int  @id\n     authorId Int  // Foreign key field\n     author   User @relation(fields: [authorId], references: [id])\n   }\n   ```\n\n2. **Wrong array syntax**:\n   ```prisma\n   // WRONG!\n   model User {\n     posts Post  // Missing brackets!\n   }\n   \n   // CORRECT!\n   model User {\n     posts Post[]  // Array of posts\n   }\n   ```\n\n3. **Missing @relation name for many-to-many**:\n   ```prisma\n   // WRONG! Ambiguous relation\n   model User {\n     posts Post[]\n   }\n   model Post {\n     users User[]\n   }\n   \n   // CORRECT!\n   model User {\n     posts Post[] @relation(\"UserPosts\")\n   }\n   model Post {\n     users User[] @relation(\"UserPosts\")\n   }\n   ```\n\n4. **Not using @unique for one-to-one**:\n   ```prisma\n   // WRONG! This is one-to-many without @unique\n   model Profile {\n     userId Int\n     user   User @relation(fields: [userId], references: [id])\n   }\n   \n   // CORRECT! @unique makes it one-to-one\n   model Profile {\n     userId Int  @unique\n     user   User @relation(fields: [userId], references: [id])\n   }\n   ```\n\n5. **Forgetting include in queries**:\n   ```typescript\n   // WRONG! This doesn't include posts\n   const user = await prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.posts);  // undefined!\n   \n   // CORRECT!\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: { posts: true }\n   });\n   console.log(user.posts);  // Array of posts\n   ```\n\n6. **Cascade delete pitfalls**:\n   ```prisma\n   // DANGEROUS! Deleting user deletes all posts\n   model Post {\n     authorId Int\n     author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)\n   }\n   \n   // Better: Prevent deletion if posts exist\n   model Post {\n     authorId Int\n     author   User @relation(fields: [authorId], references: [id], onDelete: Restrict)\n   }\n   ```\n\n7. **Creating without connecting**:\n   ```typescript\n   // WRONG! Post needs an author\n   await prisma.post.create({\n     data: {\n       title: 'New Post'\n       // Missing author connection!\n     }\n   });\n   \n   // CORRECT!\n   await prisma.post.create({\n     data: {\n       title: 'New Post',\n       author: { connect: { id: 1 } }\n     }\n   });\n   ```\n\n8. **Self-relation confusion**:\n   ```prisma\n   // WRONG! Ambiguous self-relation\n   model User {\n     followers User[]\n     following User[]\n   }\n   \n   // CORRECT! Named relation\n   model User {\n     followers User[] @relation(\"UserFollows\")\n     following User[] @relation(\"UserFollows\")\n   }\n   ```\n\n9. **Not understanding implicit vs explicit many-to-many**:\n   ```prisma\n   // Implicit: Prisma manages join table\n   model User {\n     posts Post[] @relation(\"Likes\")\n   }\n   model Post {\n     likedBy User[] @relation(\"Likes\")\n   }\n   \n   // Explicit: You control join table (when you need extra fields)\n   model User {\n     likes Like[]\n   }\n   model Post {\n     likes Like[]\n   }\n   model Like {\n     userId Int\n     user   User @relation(fields: [userId], references: [id])\n     postId Int\n     post   Post @relation(fields: [postId], references: [id])\n     likedAt DateTime @default(now())  // Extra field!\n   }\n   ```\n\n10. **Relation filtering mistakes**:\n    ```typescript\n    // WRONG! Can't filter like this\n    const users = await prisma.user.findMany({\n      where: { posts.published: true }  // Error!\n    });\n    \n    // CORRECT! Use relation filters\n    const users = await prisma.user.findMany({\n      where: {\n        posts: {\n          some: { published: true }  // Users with at least one published post\n        }\n      }\n    });\n    ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "11.5-challenge",
              "title": "Practice Challenge",
              "description": "Simulate Prisma relations:\n\n1. Create a schema object with three models:\n   - Author (id, name, books array)\n   - Book (id, title, authorId, author)\n   - Category (id, name, books array)\n2. Set up a one-to-many relation: Author → Books\n3. Set up a many-to-many relation: Books ↔ Categories\n4. Create sample data showing:\n   - One author with multiple books\n   - Books connected to multiple categories\n5. Create a function `getAuthorWithBooks(authorId)` that returns author with their books\n6. Display the relational data\n\nYou're simulating Prisma's relation system!",
              "instructions": "Simulate Prisma relations:\n\n1. Create a schema object with three models:\n   - Author (id, name, books array)\n   - Book (id, title, authorId, author)\n   - Category (id, name, books array)\n2. Set up a one-to-many relation: Author → Books\n3. Set up a many-to-many relation: Books ↔ Categories\n4. Create sample data showing:\n   - One author with multiple books\n   - Books connected to multiple categories\n5. Create a function `getAuthorWithBooks(authorId)` that returns author with their books\n6. Display the relational data\n\nYou're simulating Prisma's relation system!",
              "starterCode": "// Simulated Prisma relations\nlet database = {\n  authors: [\n    {\n      id: 1,\n      name: 'J.K. Rowling',\n      books: []  // Will populate\n    }\n  ],\n  books: [\n    {\n      id: 1,\n      title: 'Harry Potter',\n      authorId: 1,\n      categories: []  // Will populate\n    },\n    {\n      id: 2,\n      title: 'Fantastic Beasts',\n      authorId: 1,\n      categories: []\n    }\n  ],\n  categories: [\n    { id: 1, name: 'Fantasy', books: [] },\n    { id: 2, name: 'Adventure', books: [] }\n  ]\n};\n\n// Function to get author with books\nfunction getAuthorWithBooks(authorId) {\n  let author = database.authors.find(a => a.id === authorId);\n  if (!author) return null;\n  \n  // Find books by this author (one-to-many)\n  let books = database.books.filter(b => b.authorId === authorId);\n  \n  return {\n    ...author,\n    books: books\n  };\n}\n\n// Function to get book with categories\nfunction getBookWithCategories(bookId) {\n  let book = database.books.find(b => b.id === bookId);\n  if (!book) return null;\n  \n  // Many-to-many: find categories for this book\n  let categories = database.categories.filter(c => \n    c.books.includes(bookId)\n  );\n  \n  return {\n    ...book,\n    categories: categories\n  };\n}\n\n// Set up many-to-many relations\ndatabase.categories[0].books = [1, 2];  // Fantasy has both books\ndatabase.categories[1].books = [1];     // Adventure has HP only\n\ndatabase.books[0].categories = [1, 2];  // HP is Fantasy + Adventure\ndatabase.books[1].categories = [1];     // FB is Fantasy only\n\n// Test relations\nconsole.log('=== One-to-Many: Author → Books ===');\nlet authorWithBooks = getAuthorWithBooks(1);\nconsole.log(JSON.stringify(authorWithBooks, null, 2));\n\nconsole.log('\\n=== Many-to-Many: Book ↔ Categories ===');\nlet bookWithCategories = getBookWithCategories(1);\nconsole.log(JSON.stringify(bookWithCategories, null, 2));",
              "solution": "// Complete Prisma relations simulator\nlet database = {\n  authors: [\n    { id: 1, name: 'J.K. Rowling', bio: 'British author' },\n    { id: 2, name: 'George R.R. Martin', bio: 'American novelist' }\n  ],\n  books: [\n    { id: 1, title: 'Harry Potter and the Philosopher\\'s Stone', authorId: 1, published: true },\n    { id: 2, title: 'Harry Potter and the Chamber of Secrets', authorId: 1, published: true },\n    { id: 3, title: 'Fantastic Beasts', authorId: 1, published: true },\n    { id: 4, title: 'A Game of Thrones', authorId: 2, published: true },\n    { id: 5, title: 'A Clash of Kings', authorId: 2, published: true }\n  ],\n  categories: [\n    { id: 1, name: 'Fantasy' },\n    { id: 2, name: 'Adventure' },\n    { id: 3, name: 'Young Adult' },\n    { id: 4, name: 'Epic Fantasy' }\n  ],\n  // Many-to-many join table\n  bookCategories: [\n    { bookId: 1, categoryId: 1 },  // HP1 → Fantasy\n    { bookId: 1, categoryId: 2 },  // HP1 → Adventure\n    { bookId: 1, categoryId: 3 },  // HP1 → YA\n    { bookId: 2, categoryId: 1 },  // HP2 → Fantasy\n    { bookId: 2, categoryId: 3 },  // HP2 → YA\n    { bookId: 3, categoryId: 1 },  // FB → Fantasy\n    { bookId: 4, categoryId: 1 },  // GoT → Fantasy\n    { bookId: 4, categoryId: 4 },  // GoT → Epic Fantasy\n    { bookId: 5, categoryId: 1 },  // Clash → Fantasy\n    { bookId: 5, categoryId: 4 }   // Clash → Epic Fantasy\n  ]\n};\n\n// Prisma-style queries\n\nfunction findAuthorWithBooks(authorId) {\n  let author = database.authors.find(a => a.id === authorId);\n  if (!author) return null;\n  \n  // One-to-many: get all books by this author\n  let books = database.books.filter(b => b.authorId === authorId);\n  \n  // Include categories for each book\n  books = books.map(book => {\n    let categoryIds = database.bookCategories\n      .filter(bc => bc.bookId === book.id)\n      .map(bc => bc.categoryId);\n    \n    let categories = database.categories.filter(c => \n      categoryIds.includes(c.id)\n    );\n    \n    return { ...book, categories };\n  });\n  \n  return { ...author, books };\n}\n\nfunction findBookWithRelations(bookId) {\n  let book = database.books.find(b => b.id === bookId);\n  if (!book) return null;\n  \n  // Get author (many-to-one)\n  let author = database.authors.find(a => a.id === book.authorId);\n  \n  // Get categories (many-to-many)\n  let categoryIds = database.bookCategories\n    .filter(bc => bc.bookId === bookId)\n    .map(bc => bc.categoryId);\n  \n  let categories = database.categories.filter(c => \n    categoryIds.includes(c.id)\n  );\n  \n  return { ...book, author, categories };\n}\n\nfunction findCategoryWithBooks(categoryId) {\n  let category = database.categories.find(c => c.id === categoryId);\n  if (!category) return null;\n  \n  // Many-to-many: get all books in this category\n  let bookIds = database.bookCategories\n    .filter(bc => bc.categoryId === categoryId)\n    .map(bc => bc.bookId);\n  \n  let books = database.books.filter(b => bookIds.includes(b.id));\n  \n  // Include authors\n  books = books.map(book => {\n    let author = database.authors.find(a => a.id === book.authorId);\n    return { ...book, author };\n  });\n  \n  return { ...category, books };\n}\n\nfunction getStats() {\n  return {\n    totalAuthors: database.authors.length,\n    totalBooks: database.books.length,\n    totalCategories: database.categories.length,\n    averageBooksPerAuthor: (database.books.length / database.authors.length).toFixed(1)\n  };\n}\n\n// Test the relations\nconsole.log('=== Prisma Relations Simulator ===\\n');\n\nconsole.log('1. ONE-TO-MANY: Author with Books');\nconsole.log('Query: prisma.author.findUnique({ where: { id: 1 }, include: { books: true } })\\n');\nlet jkRowling = findAuthorWithBooks(1);\nconsole.log(JSON.stringify(jkRowling, null, 2));\n\nconsole.log('\\n2. MANY-TO-MANY: Book with Categories');\nconsole.log('Query: prisma.book.findUnique({ where: { id: 1 }, include: { categories: true } })\\n');\nlet hp1 = findBookWithRelations(1);\nconsole.log(JSON.stringify(hp1, null, 2));\n\nconsole.log('\\n3. MANY-TO-MANY REVERSE: Category with Books');\nconsole.log('Query: prisma.category.findUnique({ where: { id: 1 }, include: { books: true } })\\n');\nlet fantasy = findCategoryWithBooks(1);\nconsole.log(JSON.stringify(fantasy, null, 2));\n\nconsole.log('\\n4. Database Statistics');\nconsole.log(getStats());",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Author has multiple books",
                  "expectedOutput": "2",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Many-to-many with arrays",
                  "expectedOutput": "2",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use filter() for one-to-many, arrays for many-to-many relationships"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common relation mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common relation mistakes:"
                },
                {
                  "mistake": "**Forgetting foreign key field**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting foreign key field**:\n   ```prisma\n   // WRONG! Missing authorId\n   model Post {\n     id     Int  @id\n     author User @relation(fields: [authorId], references: [id])\n   }\n   \n   // CORRECT!\n   model Post {\n     id       Int  @id\n     authorId Int  // Foreign key field\n     author   User @relation(fields: [authorId], references: [id])\n   }\n   ```"
                },
                {
                  "mistake": "**Wrong array syntax**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong array syntax**:\n   ```prisma\n   // WRONG!\n   model User {\n     posts Post  // Missing brackets!\n   }\n   \n   // CORRECT!\n   model User {\n     posts Post[]  // Array of posts\n   }\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "12.6",
          "title": "Prisma Transactions (The Bank Transfer Analogy)",
          "moduleId": "module-12",
          "order": 6,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine transferring money between bank accounts:\n\nWithout transactions:\n- Step 1: Subtract $100 from Account A\n- Step 2: Add $100 to Account B\n- If Step 2 fails... the money vanishes!\n- Account A lost $100, Account B didn't get it\n- Disaster!\n\nWith transactions (all-or-nothing):\n- START TRANSACTION\n- Step 1: Subtract $100 from Account A\n- Step 2: Add $100 to Account B\n- If BOTH succeed: COMMIT (make it permanent)\n- If EITHER fails: ROLLBACK (undo everything)\n- Money is NEVER lost!\n\nPrisma transactions ensure that multiple database operations either ALL succeed together, or ALL fail together. This is called atomicity - one of the most important database concepts. Use transactions whenever you need multiple related operations to be treated as a single unit of work!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Prisma transactions.",
              "language": "javascript",
              "code": "// Prisma Transactions - Complete Guide\n\n// Simulating Prisma transaction concepts\nconsole.log('=== Prisma Transactions ===\\n');\n\n// 1. SEQUENTIAL TRANSACTIONS (Array Syntax)\n// All operations run in sequence, all succeed or all fail\n\nlet sequentialExample = `\n// Array syntax: Pass array of operations\nconst [user, post] = await prisma.$transaction([\n  prisma.user.create({\n    data: { email: 'alice@example.com', name: 'Alice' }\n  }),\n  prisma.post.create({\n    data: { title: 'Hello World', authorId: 1 }\n  })\n]);\n\n// Both operations are guaranteed to succeed or fail together\nconsole.log(user, post);\n`;\n\nconsole.log('1. SEQUENTIAL TRANSACTIONS (Array Syntax):');\nconsole.log(sequentialExample);\n\n// 2. INTERACTIVE TRANSACTIONS (Callback Syntax)\n// More control: read data, make decisions, then write\n\nlet interactiveExample = `\n// Callback syntax: Full control over transaction\nconst result = await prisma.$transaction(async (tx) => {\n  // Step 1: Read current balance\n  const fromAccount = await tx.account.findUnique({\n    where: { id: 1 }\n  });\n  \n  // Step 2: Check if sufficient funds\n  if (fromAccount.balance < 100) {\n    throw new Error('Insufficient funds');\n    // Transaction will automatically rollback!\n  }\n  \n  // Step 3: Subtract from sender\n  const sender = await tx.account.update({\n    where: { id: 1 },\n    data: { balance: { decrement: 100 } }\n  });\n  \n  // Step 4: Add to receiver\n  const receiver = await tx.account.update({\n    where: { id: 2 },\n    data: { balance: { increment: 100 } }\n  });\n  \n  // Return result\n  return { sender, receiver };\n});\n\n// If any step throws an error, ALL changes are rolled back\n`;\n\nconsole.log('\\n2. INTERACTIVE TRANSACTIONS (Callback Syntax):');\nconsole.log(interactiveExample);\n\n// 3. NESTED WRITES (Automatic Transactions)\n// Prisma automatically wraps nested creates/updates in a transaction\n\nlet nestedWriteExample = `\n// Nested writes are automatically transactional!\nconst user = await prisma.user.create({\n  data: {\n    email: 'bob@example.com',\n    name: 'Bob',\n    profile: {\n      create: { bio: 'Hello!' }  // Created in same transaction\n    },\n    posts: {\n      create: [                   // All created in same transaction\n        { title: 'Post 1' },\n        { title: 'Post 2' }\n      ]\n    }\n  },\n  include: {\n    profile: true,\n    posts: true\n  }\n});\n\n// If ANY nested create fails, the entire operation rolls back\n// User, profile, and posts are either ALL created or NONE\n`;\n\nconsole.log('\\n3. NESTED WRITES (Automatic Transactions):');\nconsole.log(nestedWriteExample);\n\n// 4. TRANSACTION OPTIONS\n\nlet optionsExample = `\n// Configure transaction behavior\nconst result = await prisma.$transaction(\n  async (tx) => {\n    // Your transaction logic here\n    const user = await tx.user.create({ ... });\n    return user;\n  },\n  {\n    maxWait: 5000,      // Max time to wait for transaction slot (ms)\n    timeout: 10000,     // Max time for transaction to complete (ms)\n    isolationLevel: 'Serializable'  // Transaction isolation level\n  }\n);\n\n// Isolation levels:\n// - ReadUncommitted: Lowest isolation, fastest\n// - ReadCommitted: See only committed data (default in PostgreSQL)\n// - RepeatableRead: Consistent reads within transaction\n// - Serializable: Highest isolation, slowest\n`;\n\nconsole.log('\\n4. TRANSACTION OPTIONS:');\nconsole.log(optionsExample);\n\n// 5. ERROR HANDLING IN TRANSACTIONS\n\nlet errorHandlingExample = `\n// Proper error handling\ntry {\n  const result = await prisma.$transaction(async (tx) => {\n    // Operations that might fail\n    const user = await tx.user.create({ ... });\n    const order = await tx.order.create({ ... });\n    \n    // Simulate a business logic check\n    if (order.total > 10000) {\n      throw new Error('Order exceeds maximum limit');\n    }\n    \n    return { user, order };\n  });\n  \n  console.log('Transaction succeeded:', result);\n} catch (error) {\n  // Transaction automatically rolled back\n  console.error('Transaction failed:', error.message);\n  \n  // Handle specific errors\n  if (error.code === 'P2002') {\n    console.error('Unique constraint violation');\n  }\n}\n`;\n\nconsole.log('\\n5. ERROR HANDLING:');\nconsole.log(errorHandlingExample);\n\n// 6. WHEN TO USE TRANSACTIONS\n\nconsole.log('\\n6. WHEN TO USE TRANSACTIONS:');\n\nlet useCases = {\n  'Money Transfers': 'Debit one account, credit another',\n  'Order Processing': 'Create order + update inventory + charge payment',\n  'User Registration': 'Create user + create profile + send welcome email record',\n  'Bulk Updates': 'Update multiple related records together',\n  'Data Migration': 'Transform and move data safely',\n  'Booking Systems': 'Reserve seat + create ticket + charge customer'\n};\n\nfor (let [useCase, description] of Object.entries(useCases)) {\n  console.log(`  - ${useCase}: ${description}`);\n}\n\n// SIMULATION: Bank Transfer\n\nconsole.log('\\n=== SIMULATION: Bank Transfer ===\\n');\n\nclass MockPrisma {\n  constructor() {\n    this.accounts = [\n      { id: 1, name: 'Alice', balance: 1000 },\n      { id: 2, name: 'Bob', balance: 500 }\n    ];\n    this.transactionLog = [];\n  }\n  \n  async $transaction(callback) {\n    // Create a snapshot for rollback\n    const snapshot = JSON.parse(JSON.stringify(this.accounts));\n    \n    try {\n      // Create transaction context\n      const tx = {\n        account: {\n          findUnique: async ({ where }) => {\n            return this.accounts.find(a => a.id === where.id);\n          },\n          update: async ({ where, data }) => {\n            const account = this.accounts.find(a => a.id === where.id);\n            if (!account) throw new Error('Account not found');\n            \n            if (data.balance?.decrement) {\n              account.balance -= data.balance.decrement;\n            }\n            if (data.balance?.increment) {\n              account.balance += data.balance.increment;\n            }\n            \n            return account;\n          }\n        }\n      };\n      \n      // Execute transaction\n      const result = await callback(tx);\n      \n      // Commit: log success\n      this.transactionLog.push({ status: 'COMMITTED', timestamp: new Date() });\n      console.log('Transaction COMMITTED');\n      \n      return result;\n    } catch (error) {\n      // Rollback: restore snapshot\n      this.accounts = snapshot;\n      this.transactionLog.push({ status: 'ROLLED_BACK', error: error.message, timestamp: new Date() });\n      console.log('Transaction ROLLED BACK:', error.message);\n      \n      throw error;\n    }\n  }\n}\n\nconst mockPrisma = new MockPrisma();\n\nasync function transferMoney(fromId, toId, amount) {\n  return mockPrisma.$transaction(async (tx) => {\n    // Get sender account\n    const from = await tx.account.findUnique({ where: { id: fromId } });\n    console.log(`Sender ${from.name} has $${from.balance}`);\n    \n    // Check balance\n    if (from.balance < amount) {\n      throw new Error(`Insufficient funds: ${from.name} only has $${from.balance}`);\n    }\n    \n    // Debit sender\n    const sender = await tx.account.update({\n      where: { id: fromId },\n      data: { balance: { decrement: amount } }\n    });\n    console.log(`Debited $${amount} from ${sender.name}`);\n    \n    // Credit receiver\n    const receiver = await tx.account.update({\n      where: { id: toId },\n      data: { balance: { increment: amount } }\n    });\n    console.log(`Credited $${amount} to ${receiver.name}`);\n    \n    return { sender, receiver };\n  });\n}\n\n// Test successful transfer\nconsole.log('Test 1: Transfer $200 from Alice to Bob');\ntransferMoney(1, 2, 200).then(result => {\n  console.log(`Alice: $${result.sender.balance}, Bob: $${result.receiver.balance}`);\n});\n\n// Test failed transfer (insufficient funds)\nsetTimeout(() => {\n  console.log('\\nTest 2: Transfer $5000 from Alice to Bob (should fail)');\n  transferMoney(1, 2, 5000).catch(e => {\n    console.log('Final balances:', mockPrisma.accounts);\n  });\n}, 100);"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Prisma Transaction Types and Usage:\n\n1. **Sequential Transactions (Array Syntax)**:\n   ```typescript\n   // Pass an array of Prisma operations\n   const [user, post, comment] = await prisma.$transaction([\n     prisma.user.create({ data: { name: 'Alice' } }),\n     prisma.post.create({ data: { title: 'Hello' } }),\n     prisma.comment.create({ data: { text: 'Nice!' } })\n   ]);\n   \n   // Best for:\n   // - Independent operations that must all succeed\n   // - Simple create/update operations\n   // - When you don't need to read before writing\n   ```\n\n2. **Interactive Transactions (Callback Syntax)**:\n   ```typescript\n   const result = await prisma.$transaction(async (tx) => {\n     // tx is a transactional Prisma client\n     // Use tx instead of prisma inside the callback\n     \n     const user = await tx.user.findUnique({ where: { id: 1 } });\n     \n     if (!user) {\n       throw new Error('User not found');\n     }\n     \n     const updatedUser = await tx.user.update({\n       where: { id: 1 },\n       data: { credits: { decrement: 10 } }\n     });\n     \n     return updatedUser;\n   });\n   \n   // Best for:\n   // - Read-then-write operations\n   // - Business logic validation\n   // - Conditional operations\n   ```\n\n3. **Nested Writes (Automatic Transactions)**:\n   ```typescript\n   // Prisma automatically wraps nested operations\n   const user = await prisma.user.create({\n     data: {\n       email: 'alice@example.com',\n       profile: { create: { bio: 'Hello' } },\n       posts: {\n         create: [\n           { title: 'Post 1' },\n           { title: 'Post 2' }\n         ]\n       }\n     }\n   });\n   \n   // No explicit transaction needed!\n   // Prisma ensures atomic creation\n   ```\n\n4. **Transaction Configuration Options**:\n   ```typescript\n   await prisma.$transaction(\n     async (tx) => { /* ... */ },\n     {\n       maxWait: 5000,   // Wait for transaction slot (ms)\n       timeout: 10000,  // Max execution time (ms)\n       isolationLevel: 'Serializable'\n     }\n   );\n   ```\n   \n   **Isolation Levels**:\n   - `ReadUncommitted`: Can see uncommitted changes (dirty reads)\n   - `ReadCommitted`: Only see committed changes (PostgreSQL default)\n   - `RepeatableRead`: Consistent snapshot for entire transaction\n   - `Serializable`: Highest isolation, prevents all anomalies\n\n5. **Error Handling Patterns**:\n   ```typescript\n   try {\n     await prisma.$transaction(async (tx) => {\n       // If any operation fails or throws...\n       throw new Error('Something went wrong');\n     });\n   } catch (error) {\n     // ...the entire transaction is rolled back\n     console.error('Transaction failed:', error.message);\n   }\n   ```\n\n6. **Common Transaction Patterns**:\n\n   **Transfer Pattern**:\n   ```typescript\n   await prisma.$transaction(async (tx) => {\n     await tx.account.update({\n       where: { id: senderId },\n       data: { balance: { decrement: amount } }\n     });\n     await tx.account.update({\n       where: { id: receiverId },\n       data: { balance: { increment: amount } }\n     });\n   });\n   ```\n\n   **Create-and-Connect Pattern**:\n   ```typescript\n   await prisma.$transaction(async (tx) => {\n     const order = await tx.order.create({\n       data: { userId: 1, total: 100 }\n     });\n     await tx.inventory.update({\n       where: { productId: 1 },\n       data: { quantity: { decrement: 1 } }\n     });\n     return order;\n   });\n   ```\n\n   **Validate-then-Write Pattern**:\n   ```typescript\n   await prisma.$transaction(async (tx) => {\n     const user = await tx.user.findUnique({ where: { id: 1 } });\n     \n     if (user.credits < 10) {\n       throw new Error('Insufficient credits');\n     }\n     \n     return tx.user.update({\n       where: { id: 1 },\n       data: { credits: { decrement: 10 } }\n     });\n   });\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common transaction mistakes:\n\n1. **Using prisma instead of tx inside callback**:\n   ```typescript\n   // WRONG! Uses global prisma, not transactional\n   await prisma.$transaction(async (tx) => {\n     await prisma.user.create({ ... });  // NOT transactional!\n   });\n   \n   // CORRECT! Uses tx parameter\n   await prisma.$transaction(async (tx) => {\n     await tx.user.create({ ... });  // Transactional!\n   });\n   ```\n\n2. **Not catching transaction errors**:\n   ```typescript\n   // WRONG! Unhandled rejection\n   prisma.$transaction(async (tx) => {\n     throw new Error('Failed');\n   });\n   \n   // CORRECT! Proper error handling\n   try {\n     await prisma.$transaction(async (tx) => {\n       throw new Error('Failed');\n     });\n   } catch (error) {\n     console.error('Transaction rolled back:', error.message);\n   }\n   ```\n\n3. **Long-running transactions**:\n   ```typescript\n   // WRONG! Transaction holds locks too long\n   await prisma.$transaction(async (tx) => {\n     await tx.user.update({ ... });\n     await sendEmail();           // Slow external call!\n     await processPayment();      // Another slow call!\n   });\n   \n   // CORRECT! Minimize transaction scope\n   const user = await prisma.$transaction(async (tx) => {\n     return tx.user.update({ ... });\n   });\n   await sendEmail();           // Outside transaction\n   await processPayment();      // Outside transaction\n   ```\n\n4. **Forgetting transactions for related updates**:\n   ```typescript\n   // WRONG! Not atomic - partial failure possible\n   await prisma.account.update({ where: { id: 1 }, data: { balance: { decrement: 100 } } });\n   await prisma.account.update({ where: { id: 2 }, data: { balance: { increment: 100 } } });\n   \n   // CORRECT! Atomic transaction\n   await prisma.$transaction([\n     prisma.account.update({ where: { id: 1 }, data: { balance: { decrement: 100 } } }),\n     prisma.account.update({ where: { id: 2 }, data: { balance: { increment: 100 } } })\n   ]);\n   ```\n\n5. **Mixing array and callback syntax incorrectly**:\n   ```typescript\n   // WRONG! Can't mix syntaxes\n   await prisma.$transaction([\n     async (tx) => { ... }  // This won't work!\n   ]);\n   \n   // CORRECT! Choose one syntax\n   // Array syntax:\n   await prisma.$transaction([prisma.user.create({ ... })]);\n   \n   // OR Callback syntax:\n   await prisma.$transaction(async (tx) => {\n     await tx.user.create({ ... });\n   });\n   ```\n\n6. **Not setting appropriate timeouts**:\n   ```typescript\n   // WRONG! Default timeout may be too short for complex operations\n   await prisma.$transaction(async (tx) => {\n     // Complex, multi-step operation\n   });\n   \n   // CORRECT! Set appropriate timeout\n   await prisma.$transaction(\n     async (tx) => { /* ... */ },\n     { timeout: 30000 }  // 30 seconds\n   );\n   ```\n\n7. **Returning non-serializable values**:\n   ```typescript\n   // WRONG! Functions can't be serialized\n   await prisma.$transaction(async (tx) => {\n     return () => console.log('Hi');  // Error!\n   });\n   \n   // CORRECT! Return plain data\n   await prisma.$transaction(async (tx) => {\n     const user = await tx.user.create({ ... });\n     return { id: user.id, name: user.name };\n   });\n   ```\n\n8. **Ignoring isolation level for critical operations**:\n   ```typescript\n   // For financial operations, consider Serializable\n   await prisma.$transaction(\n     async (tx) => {\n       // Critical financial operation\n     },\n     { isolationLevel: 'Serializable' }\n   );\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.6-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a transaction system:\n\n1. Create a MockDatabase class with:\n   - accounts array with id, name, and balance\n   - transactionHistory array\n\n2. Implement a $transaction method that:\n   - Takes a callback function\n   - Creates a snapshot of data before execution\n   - Executes the callback\n   - If callback throws, restores the snapshot (rollback)\n   - If callback succeeds, commits the changes\n\n3. Create a transfer function that:\n   - Uses $transaction\n   - Checks for sufficient balance\n   - Transfers money between accounts\n\n4. Test with:\n   - A successful transfer\n   - A failed transfer (insufficient funds)\n\nShow that failed transfers don't change balances!",
              "instructions": "Simulate a transaction system:\n\n1. Create a MockDatabase class with:\n   - accounts array with id, name, and balance\n   - transactionHistory array\n\n2. Implement a $transaction method that:\n   - Takes a callback function\n   - Creates a snapshot of data before execution\n   - Executes the callback\n   - If callback throws, restores the snapshot (rollback)\n   - If callback succeeds, commits the changes\n\n3. Create a transfer function that:\n   - Uses $transaction\n   - Checks for sufficient balance\n   - Transfers money between accounts\n\n4. Test with:\n   - A successful transfer\n   - A failed transfer (insufficient funds)\n\nShow that failed transfers don't change balances!",
              "starterCode": "// Transaction System Simulator\n\nclass MockDatabase {\n  constructor() {\n    this.accounts = [\n      { id: 1, name: 'Alice', balance: 1000 },\n      { id: 2, name: 'Bob', balance: 500 }\n    ];\n    this.transactionHistory = [];\n  }\n  \n  // Snapshot current state\n  snapshot() {\n    return JSON.parse(JSON.stringify(this.accounts));\n  }\n  \n  // Restore from snapshot\n  restore(snapshot) {\n    this.accounts = snapshot;\n  }\n  \n  // Transaction method\n  async $transaction(callback) {\n    const snap = this.snapshot();\n    \n    try {\n      const result = await callback(this);\n      this.transactionHistory.push({ status: 'COMMITTED', time: new Date() });\n      console.log('COMMITTED');\n      return result;\n    } catch (error) {\n      this.restore(snap);\n      this.transactionHistory.push({ status: 'ROLLED_BACK', error: error.message, time: new Date() });\n      console.log('ROLLED BACK:', error.message);\n      throw error;\n    }\n  }\n  \n  // Find account\n  findAccount(id) {\n    return this.accounts.find(a => a.id === id);\n  }\n  \n  // Update balance\n  updateBalance(id, amount) {\n    const account = this.findAccount(id);\n    if (!account) throw new Error('Account not found');\n    account.balance += amount;\n    return account;\n  }\n}\n\nconst db = new MockDatabase();\n\n// Transfer function using transaction\nasync function transfer(fromId, toId, amount) {\n  return db.$transaction(async (database) => {\n    const from = database.findAccount(fromId);\n    \n    if (from.balance < amount) {\n      throw new Error('Insufficient funds');\n    }\n    \n    database.updateBalance(fromId, -amount);\n    database.updateBalance(toId, amount);\n    \n    return { from: database.findAccount(fromId), to: database.findAccount(toId) };\n  });\n}\n\n// Test\nconsole.log('Initial balances:', db.accounts);\n\nconsole.log('\\nTest 1: Transfer $200 from Alice to Bob');\ntransfer(1, 2, 200).then(result => {\n  console.log('After transfer:', db.accounts);\n  \n  console.log('\\nTest 2: Transfer $2000 (should fail)');\n  return transfer(1, 2, 2000);\n}).catch(e => {\n  console.log('Balances after failed transfer:', db.accounts);\n});",
              "solution": "// Complete Transaction System Simulator\n\nclass MockDatabase {\n  constructor() {\n    this.accounts = [\n      { id: 1, name: 'Alice', balance: 1000 },\n      { id: 2, name: 'Bob', balance: 500 },\n      { id: 3, name: 'Charlie', balance: 750 }\n    ];\n    this.transactionHistory = [];\n    this.transactionCount = 0;\n  }\n  \n  snapshot() {\n    return JSON.parse(JSON.stringify(this.accounts));\n  }\n  \n  restore(snapshot) {\n    this.accounts = snapshot;\n  }\n  \n  async $transaction(callback, options = {}) {\n    const transactionId = ++this.transactionCount;\n    const startTime = Date.now();\n    const snap = this.snapshot();\n    const timeout = options.timeout || 5000;\n    \n    console.log(`[TX-${transactionId}] Starting transaction...`);\n    \n    try {\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('Transaction timeout')), timeout);\n      });\n      \n      const result = await Promise.race([\n        callback(this),\n        timeoutPromise\n      ]);\n      \n      const duration = Date.now() - startTime;\n      this.transactionHistory.push({\n        id: transactionId,\n        status: 'COMMITTED',\n        duration: `${duration}ms`,\n        time: new Date().toISOString()\n      });\n      \n      console.log(`[TX-${transactionId}] COMMITTED (${duration}ms)`);\n      return result;\n    } catch (error) {\n      this.restore(snap);\n      const duration = Date.now() - startTime;\n      \n      this.transactionHistory.push({\n        id: transactionId,\n        status: 'ROLLED_BACK',\n        error: error.message,\n        duration: `${duration}ms`,\n        time: new Date().toISOString()\n      });\n      \n      console.log(`[TX-${transactionId}] ROLLED BACK: ${error.message} (${duration}ms)`);\n      throw error;\n    }\n  }\n  \n  findAccount(id) {\n    return this.accounts.find(a => a.id === id);\n  }\n  \n  updateBalance(id, amount) {\n    const account = this.findAccount(id);\n    if (!account) throw new Error(`Account ${id} not found`);\n    account.balance += amount;\n    return { ...account };\n  }\n  \n  getBalance(id) {\n    const account = this.findAccount(id);\n    return account ? account.balance : null;\n  }\n  \n  printBalances() {\n    console.log('Balances:');\n    this.accounts.forEach(a => {\n      console.log(`  ${a.name}: $${a.balance}`);\n    });\n  }\n  \n  printHistory() {\n    console.log('\\nTransaction History:');\n    this.transactionHistory.forEach(tx => {\n      const status = tx.status === 'COMMITTED' ? '✓' : '✗';\n      const error = tx.error ? ` (${tx.error})` : '';\n      console.log(`  ${status} TX-${tx.id}: ${tx.status}${error} - ${tx.duration}`);\n    });\n  }\n}\n\nconst db = new MockDatabase();\n\nasync function transfer(fromId, toId, amount) {\n  return db.$transaction(async (database) => {\n    const from = database.findAccount(fromId);\n    const to = database.findAccount(toId);\n    \n    if (!from) throw new Error(`Sender account ${fromId} not found`);\n    if (!to) throw new Error(`Receiver account ${toId} not found`);\n    \n    console.log(`  Transferring $${amount} from ${from.name} to ${to.name}`);\n    console.log(`  ${from.name}'s balance: $${from.balance}`);\n    \n    if (from.balance < amount) {\n      throw new Error(`Insufficient funds: ${from.name} has $${from.balance}, needs $${amount}`);\n    }\n    \n    const sender = database.updateBalance(fromId, -amount);\n    console.log(`  Debited $${amount} from ${from.name}`);\n    \n    const receiver = database.updateBalance(toId, amount);\n    console.log(`  Credited $${amount} to ${to.name}`);\n    \n    return {\n      success: true,\n      from: sender,\n      to: receiver,\n      amount\n    };\n  });\n}\n\nasync function batchTransfer(transfers) {\n  return db.$transaction(async (database) => {\n    const results = [];\n    \n    for (const { fromId, toId, amount } of transfers) {\n      const from = database.findAccount(fromId);\n      if (from.balance < amount) {\n        throw new Error(`Batch failed: ${from.name} has insufficient funds`);\n      }\n      database.updateBalance(fromId, -amount);\n      database.updateBalance(toId, amount);\n      results.push({ fromId, toId, amount, status: 'OK' });\n    }\n    \n    return results;\n  });\n}\n\nconsole.log('=== Transaction Simulator ===\\n');\ndb.printBalances();\n\nconsole.log('\\n--- Test 1: Successful Transfer ($200) ---');\ntransfer(1, 2, 200)\n  .then(() => {\n    db.printBalances();\n    \n    console.log('\\n--- Test 2: Failed Transfer ($2000 - insufficient) ---');\n    return transfer(1, 2, 2000);\n  })\n  .catch(() => {\n    console.log('Balances unchanged after rollback:');\n    db.printBalances();\n    \n    console.log('\\n--- Test 3: Batch Transfer (all or nothing) ---');\n    return batchTransfer([\n      { fromId: 1, toId: 3, amount: 100 },\n      { fromId: 2, toId: 3, amount: 5000 }  // This will fail\n    ]);\n  })\n  .catch(() => {\n    console.log('Batch rolled back - balances unchanged:');\n    db.printBalances();\n    db.printHistory();\n  });",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Transaction commits on success",
                  "expectedOutput": "COMMITTED",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Transaction rolls back on failure",
                  "expectedOutput": "ROLLED_BACK",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use JSON.parse(JSON.stringify()) to create a deep copy snapshot of the data before the transaction."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not creating a deep copy for snapshot",
                  "consequence": "The snapshot will reference the same objects, so rollback won't restore original values.",
                  "correction": "Use JSON.parse(JSON.stringify(data)) or structuredClone(data) to create a true deep copy."
                },
                {
                  "mistake": "Forgetting to await the callback",
                  "consequence": "Errors in async operations won't trigger rollback.",
                  "correction": "Always await the callback: const result = await callback(this);"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "12.7",
          "title": "Prisma Query Optimization (The Library Search Analogy)",
          "moduleId": "module-12",
          "order": 7,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine searching for books in a giant library:\n\nWithout optimization:\n- Librarian brings you ALL 10,000 books\n- You look through each one yourself\n- Takes hours, exhausting!\n- Most books you didn't even need\n\nWith optimization:\n- Tell librarian exactly what you want\n- Only bring books from specific shelf (filtering)\n- Only bring first 10 results (pagination)\n- Only tell me title and author, not full content (selecting fields)\n- Count how many exist without bringing them (aggregations)\n\nPrisma query optimization is like being a smart library visitor. Instead of fetching everything and filtering in your code, you tell the database exactly what you need. The database can do this WAY faster than your JavaScript code!\n\nKey optimization techniques:\n- Select only fields you need\n- Use pagination (skip/take or cursor)\n- Use aggregations (count, sum, avg)\n- Use raw SQL for complex queries"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Prisma query optimization.",
              "language": "javascript",
              "code": "// Prisma Query Optimization - Complete Guide\n\nconsole.log('=== Prisma Query Optimization ===\\n');\n\n// 1. SELECTING SPECIFIC FIELDS\n// Don't fetch data you don't need!\n\nlet selectExample = `\n// BAD: Fetches ALL fields\nconst users = await prisma.user.findMany();\n// Returns: { id, email, password, name, bio, avatar, createdAt, updatedAt, ... }\n\n// GOOD: Only fetch what you need\nconst users = await prisma.user.findMany({\n  select: {\n    id: true,\n    name: true,\n    email: true\n    // password, bio, avatar NOT fetched = faster!\n  }\n});\n// Returns: { id, name, email }\n`;\n\nconsole.log('1. SELECTING SPECIFIC FIELDS:');\nconsole.log(selectExample);\n\n// 2. PAGINATION - OFFSET-BASED (skip/take)\n// For simple pagination with page numbers\n\nlet offsetPaginationExample = `\n// Page-based pagination\nconst page = 2;\nconst pageSize = 10;\n\nconst users = await prisma.user.findMany({\n  skip: (page - 1) * pageSize,  // Skip first 10 (page 1)\n  take: pageSize,                // Take next 10\n  orderBy: { createdAt: 'desc' }\n});\n\n// Page 1: skip 0, take 10 (items 1-10)\n// Page 2: skip 10, take 10 (items 11-20)\n// Page 3: skip 20, take 10 (items 21-30)\n\n// Get total count for pagination UI\nconst totalCount = await prisma.user.count();\nconst totalPages = Math.ceil(totalCount / pageSize);\n`;\n\nconsole.log('\\n2. OFFSET-BASED PAGINATION (skip/take):');\nconsole.log(offsetPaginationExample);\n\n// 3. PAGINATION - CURSOR-BASED\n// More efficient for large datasets\n\nlet cursorPaginationExample = `\n// Cursor-based pagination (more efficient)\nconst firstPage = await prisma.user.findMany({\n  take: 10,\n  orderBy: { id: 'asc' }\n});\n\n// Get the last item's ID as cursor\nconst lastUser = firstPage[firstPage.length - 1];\n\n// Next page: start after the cursor\nconst secondPage = await prisma.user.findMany({\n  take: 10,\n  skip: 1,                    // Skip the cursor itself\n  cursor: { id: lastUser.id }, // Start from this ID\n  orderBy: { id: 'asc' }\n});\n\n// Why cursor is better for large data:\n// - Offset: \"Skip 10000 rows\" = DB scans 10000 rows\n// - Cursor: \"Start at ID 10001\" = DB jumps directly\n`;\n\nconsole.log('\\n3. CURSOR-BASED PAGINATION:');\nconsole.log(cursorPaginationExample);\n\n// 4. AGGREGATIONS\n// Let the database do the math!\n\nlet aggregationExample = `\n// COUNT - How many records?\nconst userCount = await prisma.user.count();\nconst activeUsers = await prisma.user.count({\n  where: { isActive: true }\n});\n\n// AGGREGATE - Sum, average, min, max\nconst stats = await prisma.order.aggregate({\n  _sum: { total: true },\n  _avg: { total: true },\n  _min: { total: true },\n  _max: { total: true },\n  _count: true\n});\n// Returns: { _sum: { total: 50000 }, _avg: { total: 125 }, ... }\n\n// GROUP BY - Statistics per category\nconst salesByCategory = await prisma.order.groupBy({\n  by: ['category'],\n  _sum: { total: true },\n  _count: true,\n  orderBy: { _sum: { total: 'desc' } }\n});\n// Returns: [{ category: 'Electronics', _sum: { total: 25000 }, _count: 100 }, ...]\n`;\n\nconsole.log('\\n4. AGGREGATIONS (count, sum, avg, min, max):');\nconsole.log(aggregationExample);\n\n// 5. GROUPBY\n// Get statistics grouped by field\n\nlet groupByExample = `\n// Group by single field\nconst postsByAuthor = await prisma.post.groupBy({\n  by: ['authorId'],\n  _count: { id: true },\n  orderBy: { _count: { id: 'desc' } }\n});\n\n// Group by multiple fields\nconst orderStats = await prisma.order.groupBy({\n  by: ['status', 'paymentMethod'],\n  _sum: { total: true },\n  _count: true,\n  having: {\n    total: { _sum: { gt: 1000 } }  // Only groups with sum > 1000\n  }\n});\n\n// Group by date (using raw for date functions)\nconst dailySales = await prisma.$queryRaw\\`\n  SELECT DATE(created_at) as date, SUM(total) as daily_total\n  FROM orders\n  GROUP BY DATE(created_at)\n  ORDER BY date DESC\n\\`;\n`;\n\nconsole.log('\\n5. GROUP BY:');\nconsole.log(groupByExample);\n\n// 6. RAW SQL\n// When Prisma's API isn't enough\n\nlet rawSqlExample = `\n// Raw query with tagged template (safe from injection)\nconst users = await prisma.$queryRaw\\`\n  SELECT * FROM users \n  WHERE email LIKE \\${searchPattern}\n  ORDER BY created_at DESC\n  LIMIT 10\n\\`;\n\n// Raw query with Prisma.sql helper\nimport { Prisma } from '@prisma/client';\n\nconst search = '%john%';\nconst users = await prisma.$queryRaw(\n  Prisma.sql\\`SELECT * FROM users WHERE name ILIKE \\${search}\\`\n);\n\n// Execute raw (for INSERT, UPDATE, DELETE)\nconst result = await prisma.$executeRaw\\`\n  UPDATE users SET last_seen = NOW() WHERE id = \\${userId}\n\\`;\n// Returns number of affected rows\n\n// DANGER: Never use string interpolation!\n// WRONG: prisma.$queryRaw(\\`SELECT * FROM users WHERE id = \\${id}\\`)\n// This is vulnerable to SQL injection!\n`;\n\nconsole.log('\\n6. RAW SQL (when needed):');\nconsole.log(rawSqlExample);\n\n// 7. INCLUDE VS SELECT\n// Two ways to control what's fetched\n\nlet includeVsSelectExample = `\n// INCLUDE: Add relations to default fields\nconst user = await prisma.user.findUnique({\n  where: { id: 1 },\n  include: {\n    posts: true,    // Includes ALL post fields\n    profile: true   // Includes ALL profile fields\n  }\n});\n// Returns: { id, email, name, ..., posts: [...], profile: {...} }\n\n// SELECT: Choose exactly what to fetch (more control)\nconst user = await prisma.user.findUnique({\n  where: { id: 1 },\n  select: {\n    id: true,\n    name: true,\n    posts: {\n      select: {\n        id: true,\n        title: true\n        // content NOT fetched\n      },\n      take: 5  // Only first 5 posts\n    }\n  }\n});\n// Returns: { id, name, posts: [{ id, title }, ...] }\n\n// CAN'T mix include and select at the same level!\n// WRONG: { select: { id: true }, include: { posts: true } }\n`;\n\nconsole.log('\\n7. INCLUDE vs SELECT:');\nconsole.log(includeVsSelectExample);\n\n// SIMULATION: Query Optimization Demo\n\nconsole.log('\\n=== SIMULATION: Query Optimization ===\\n');\n\nclass MockDatabase {\n  constructor() {\n    // Generate sample data\n    this.users = Array.from({ length: 100 }, (_, i) => ({\n      id: i + 1,\n      name: `User ${i + 1}`,\n      email: `user${i + 1}@example.com`,\n      age: 20 + (i % 50),\n      department: ['Engineering', 'Sales', 'Marketing', 'Support'][i % 4],\n      salary: 50000 + (i * 100),\n      createdAt: new Date(2024, 0, 1 + i)\n    }));\n  }\n  \n  // Simulated Prisma methods\n  findMany(options = {}) {\n    let result = [...this.users];\n    \n    // Where filtering\n    if (options.where) {\n      result = result.filter(u => {\n        for (let [key, value] of Object.entries(options.where)) {\n          if (typeof value === 'object') {\n            if (value.gte && u[key] < value.gte) return false;\n            if (value.lte && u[key] > value.lte) return false;\n            if (value.gt && u[key] <= value.gt) return false;\n            if (value.lt && u[key] >= value.lt) return false;\n          } else if (u[key] !== value) {\n            return false;\n          }\n        }\n        return true;\n      });\n    }\n    \n    // Ordering\n    if (options.orderBy) {\n      const [field, order] = Object.entries(options.orderBy)[0];\n      result.sort((a, b) => {\n        if (order === 'desc') return b[field] > a[field] ? 1 : -1;\n        return a[field] > b[field] ? 1 : -1;\n      });\n    }\n    \n    // Pagination\n    if (options.skip) result = result.slice(options.skip);\n    if (options.take) result = result.slice(0, options.take);\n    \n    // Select specific fields\n    if (options.select) {\n      result = result.map(item => {\n        const selected = {};\n        for (let key of Object.keys(options.select)) {\n          if (options.select[key]) selected[key] = item[key];\n        }\n        return selected;\n      });\n    }\n    \n    return result;\n  }\n  \n  count(options = {}) {\n    let result = this.users;\n    if (options.where) {\n      result = result.filter(u => {\n        for (let [key, value] of Object.entries(options.where)) {\n          if (u[key] !== value) return false;\n        }\n        return true;\n      });\n    }\n    return result.length;\n  }\n  \n  aggregate(options = {}) {\n    let data = this.users;\n    if (options.where) {\n      data = data.filter(u => {\n        for (let [key, value] of Object.entries(options.where)) {\n          if (u[key] !== value) return false;\n        }\n        return true;\n      });\n    }\n    \n    const result = {};\n    \n    if (options._count) result._count = data.length;\n    \n    if (options._sum) {\n      result._sum = {};\n      for (let field of Object.keys(options._sum)) {\n        result._sum[field] = data.reduce((sum, u) => sum + (u[field] || 0), 0);\n      }\n    }\n    \n    if (options._avg) {\n      result._avg = {};\n      for (let field of Object.keys(options._avg)) {\n        const values = data.map(u => u[field]).filter(v => v != null);\n        result._avg[field] = values.reduce((a, b) => a + b, 0) / values.length;\n      }\n    }\n    \n    if (options._min) {\n      result._min = {};\n      for (let field of Object.keys(options._min)) {\n        result._min[field] = Math.min(...data.map(u => u[field]));\n      }\n    }\n    \n    if (options._max) {\n      result._max = {};\n      for (let field of Object.keys(options._max)) {\n        result._max[field] = Math.max(...data.map(u => u[field]));\n      }\n    }\n    \n    return result;\n  }\n  \n  groupBy(options = {}) {\n    const groups = {};\n    \n    for (let item of this.users) {\n      const key = options.by.map(f => item[f]).join('|');\n      if (!groups[key]) {\n        groups[key] = {\n          ...Object.fromEntries(options.by.map(f => [f, item[f]])),\n          _items: []\n        };\n      }\n      groups[key]._items.push(item);\n    }\n    \n    return Object.values(groups).map(group => {\n      const result = { ...group };\n      delete result._items;\n      \n      if (options._count) result._count = group._items.length;\n      \n      if (options._sum) {\n        result._sum = {};\n        for (let field of Object.keys(options._sum)) {\n          result._sum[field] = group._items.reduce((sum, i) => sum + (i[field] || 0), 0);\n        }\n      }\n      \n      if (options._avg) {\n        result._avg = {};\n        for (let field of Object.keys(options._avg)) {\n          result._avg[field] = group._items.reduce((sum, i) => sum + i[field], 0) / group._items.length;\n        }\n      }\n      \n      return result;\n    });\n  }\n}\n\nconst db = new MockDatabase();\n\n// Demo: Select specific fields\nconsole.log('1. Select specific fields (saves bandwidth):');\nconst selectedUsers = db.findMany({\n  select: { id: true, name: true },\n  take: 3\n});\nconsole.log(selectedUsers);\n\n// Demo: Pagination\nconsole.log('\\n2. Pagination (page 2, 5 per page):');\nconst page2 = db.findMany({\n  skip: 5,\n  take: 5,\n  orderBy: { id: 'asc' },\n  select: { id: true, name: true }\n});\nconsole.log(page2);\n\n// Demo: Aggregations\nconsole.log('\\n3. Aggregations (salary stats):');\nconst stats = db.aggregate({\n  _count: true,\n  _sum: { salary: true },\n  _avg: { salary: true },\n  _min: { salary: true },\n  _max: { salary: true }\n});\nconsole.log(stats);\n\n// Demo: Group by\nconsole.log('\\n4. Group by department:');\nconst byDept = db.groupBy({\n  by: ['department'],\n  _count: true,\n  _avg: { salary: true }\n});\nconsole.log(byDept);\n\n// Demo: Combined query\nconsole.log('\\n5. Combined: Filter + Order + Paginate + Select:');\nconst combined = db.findMany({\n  where: { department: 'Engineering' },\n  orderBy: { salary: 'desc' },\n  take: 3,\n  select: { id: true, name: true, salary: true }\n});\nconsole.log(combined);"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Prisma Query Optimization Techniques:\n\n1. **Select Specific Fields**:\n   ```typescript\n   // Only fetch what you need\n   const users = await prisma.user.findMany({\n     select: {\n       id: true,\n       name: true,\n       email: true\n       // Excludes: password, bio, avatar, etc.\n     }\n   });\n   \n   // Select with relations\n   const users = await prisma.user.findMany({\n     select: {\n       name: true,\n       posts: {\n         select: { title: true },\n         take: 5\n       }\n     }\n   });\n   ```\n\n2. **Offset-Based Pagination** (skip/take):\n   ```typescript\n   // Simple page-based pagination\n   const pageSize = 10;\n   const page = 3;\n   \n   const users = await prisma.user.findMany({\n     skip: (page - 1) * pageSize,\n     take: pageSize,\n     orderBy: { createdAt: 'desc' }\n   });\n   \n   // Get total for pagination UI\n   const total = await prisma.user.count();\n   const totalPages = Math.ceil(total / pageSize);\n   ```\n\n3. **Cursor-Based Pagination** (more efficient):\n   ```typescript\n   // First page\n   const firstPage = await prisma.user.findMany({\n     take: 10,\n     orderBy: { id: 'asc' }\n   });\n   \n   // Next page using cursor\n   const lastId = firstPage[firstPage.length - 1].id;\n   const nextPage = await prisma.user.findMany({\n     take: 10,\n     skip: 1,  // Skip the cursor\n     cursor: { id: lastId },\n     orderBy: { id: 'asc' }\n   });\n   ```\n\n4. **Counting Records**:\n   ```typescript\n   // Total count\n   const total = await prisma.user.count();\n   \n   // Conditional count\n   const activeUsers = await prisma.user.count({\n     where: { isActive: true }\n   });\n   \n   // Count with relation\n   const usersWithPosts = await prisma.user.count({\n     where: {\n       posts: { some: {} }\n     }\n   });\n   ```\n\n5. **Aggregations**:\n   ```typescript\n   const stats = await prisma.order.aggregate({\n     _count: true,             // Count rows\n     _sum: { total: true },    // Sum of totals\n     _avg: { total: true },    // Average\n     _min: { total: true },    // Minimum\n     _max: { total: true },    // Maximum\n     where: { status: 'completed' }  // Optional filter\n   });\n   \n   // Result: { _count: 150, _sum: { total: 15000 }, ... }\n   ```\n\n6. **Group By**:\n   ```typescript\n   // Group by single field\n   const byCategory = await prisma.product.groupBy({\n     by: ['category'],\n     _count: true,\n     _sum: { price: true },\n     orderBy: { _count: { id: 'desc' } }\n   });\n   \n   // Group by multiple fields\n   const stats = await prisma.order.groupBy({\n     by: ['status', 'paymentMethod'],\n     _sum: { total: true },\n     _count: true,\n     having: {\n       total: { _sum: { gt: 1000 } }  // Filter groups\n     }\n   });\n   ```\n\n7. **Raw SQL Queries**:\n   ```typescript\n   // Tagged template (safe, parameterized)\n   const users = await prisma.$queryRaw`\n     SELECT * FROM users \n     WHERE name ILIKE ${pattern}\n     LIMIT ${limit}\n   `;\n   \n   // Execute raw (returns affected row count)\n   const affected = await prisma.$executeRaw`\n     UPDATE products SET price = price * 1.1\n     WHERE category = ${category}\n   `;\n   \n   // With Prisma.sql helper\n   import { Prisma } from '@prisma/client';\n   const sql = Prisma.sql`SELECT * FROM users WHERE age > ${age}`;\n   const result = await prisma.$queryRaw(sql);\n   ```\n\n8. **Performance Tips**:\n   - Use `select` to limit fields (reduces data transfer)\n   - Use cursor pagination for large datasets\n   - Use aggregations instead of fetching + calculating\n   - Add database indexes for frequently queried fields\n   - Use `findFirst` instead of `findMany()[0]`\n   - Batch operations with `createMany`, `updateMany`, `deleteMany`"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common query optimization mistakes:\n\n1. **Fetching all fields when you need few**:\n   ```typescript\n   // BAD: Fetches password, bio, avatar, etc.\n   const users = await prisma.user.findMany();\n   const names = users.map(u => u.name);\n   \n   // GOOD: Only fetches what you need\n   const users = await prisma.user.findMany({\n     select: { name: true }\n   });\n   ```\n\n2. **Using offset pagination for large datasets**:\n   ```typescript\n   // BAD: Slow for page 1000\n   const users = await prisma.user.findMany({\n     skip: 9990,  // DB must scan 9990 rows first!\n     take: 10\n   });\n   \n   // GOOD: Cursor pagination is O(1)\n   const users = await prisma.user.findMany({\n     cursor: { id: lastSeenId },\n     take: 10\n   });\n   ```\n\n3. **Counting in JavaScript instead of database**:\n   ```typescript\n   // BAD: Fetches ALL users just to count\n   const users = await prisma.user.findMany();\n   const count = users.length;\n   \n   // GOOD: Let database count\n   const count = await prisma.user.count();\n   ```\n\n4. **Calculating aggregates in JavaScript**:\n   ```typescript\n   // BAD: Fetches all orders to calculate sum\n   const orders = await prisma.order.findMany();\n   const total = orders.reduce((sum, o) => sum + o.total, 0);\n   \n   // GOOD: Let database calculate\n   const { _sum } = await prisma.order.aggregate({\n     _sum: { total: true }\n   });\n   ```\n\n5. **N+1 query problem**:\n   ```typescript\n   // BAD: 1 query for users + N queries for posts\n   const users = await prisma.user.findMany();\n   for (const user of users) {\n     const posts = await prisma.post.findMany({\n       where: { authorId: user.id }\n     });\n   }\n   \n   // GOOD: 1 query with include\n   const users = await prisma.user.findMany({\n     include: { posts: true }\n   });\n   ```\n\n6. **String interpolation in raw SQL (SQL injection!)**:\n   ```typescript\n   // DANGEROUS! SQL Injection vulnerability\n   const users = await prisma.$queryRawUnsafe(\n     `SELECT * FROM users WHERE name = '${userInput}'`\n   );\n   \n   // SAFE: Use tagged template\n   const users = await prisma.$queryRaw`\n     SELECT * FROM users WHERE name = ${userInput}\n   `;\n   ```\n\n7. **Mixing select and include**:\n   ```typescript\n   // ERROR: Can't use both at same level\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     select: { name: true },\n     include: { posts: true }  // Error!\n   });\n   \n   // CORRECT: Use select for everything\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     select: {\n       name: true,\n       posts: true  // Include via select\n     }\n   });\n   ```\n\n8. **Not using database indexes**:\n   ```prisma\n   // In schema.prisma - add indexes for queried fields\n   model User {\n     id    Int    @id @default(autoincrement())\n     email String @unique  // Automatically indexed\n     name  String\n     \n     @@index([name])       // Add index for name queries\n     @@index([createdAt])  // Add index for date sorting\n   }\n   ```\n\n9. **Fetching relations you don't need**:\n   ```typescript\n   // BAD: Fetches ALL posts even if you just need user info\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: { posts: true }  // Potentially thousands of posts!\n   });\n   \n   // GOOD: Limit what you fetch\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: {\n       posts: {\n         take: 5,\n         orderBy: { createdAt: 'desc' }\n       }\n     }\n   });\n   ```\n\n10. **Not batching bulk operations**:\n    ```typescript\n    // BAD: 100 individual queries\n    for (const data of items) {\n      await prisma.item.create({ data });\n    }\n    \n    // GOOD: Single bulk query\n    await prisma.item.createMany({\n      data: items\n    });\n    ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.7-challenge",
              "title": "Practice Challenge",
              "description": "Build a query optimization simulator:\n\n1. Create a MockDatabase with 100 users (id, name, department, salary)\n\n2. Implement these optimized query methods:\n   - findMany(options) with select, skip, take, where, orderBy\n   - count(where) - count matching records\n   - aggregate({ _sum, _avg, _min, _max }) - calculate stats\n   - groupBy({ by, _count, _avg }) - group statistics\n\n3. Demonstrate the difference between:\n   - Fetching all fields vs. selecting specific fields\n   - Getting count via length vs. count()\n   - Calculating average in JS vs. using aggregate\n\n4. Show pagination working (page 1, 2, 3)\n\n5. Group users by department and show average salary per department",
              "instructions": "Build a query optimization simulator:\n\n1. Create a MockDatabase with 100 users (id, name, department, salary)\n\n2. Implement these optimized query methods:\n   - findMany(options) with select, skip, take, where, orderBy\n   - count(where) - count matching records\n   - aggregate({ _sum, _avg, _min, _max }) - calculate stats\n   - groupBy({ by, _count, _avg }) - group statistics\n\n3. Demonstrate the difference between:\n   - Fetching all fields vs. selecting specific fields\n   - Getting count via length vs. count()\n   - Calculating average in JS vs. using aggregate\n\n4. Show pagination working (page 1, 2, 3)\n\n5. Group users by department and show average salary per department",
              "starterCode": "// Query Optimization Simulator\n\nclass MockDatabase {\n  constructor() {\n    this.users = Array.from({ length: 100 }, (_, i) => ({\n      id: i + 1,\n      name: `User ${i + 1}`,\n      email: `user${i + 1}@example.com`,\n      department: ['Engineering', 'Sales', 'Marketing', 'HR'][i % 4],\n      salary: 50000 + Math.floor(Math.random() * 50000),\n      createdAt: new Date(2024, 0, i + 1)\n    }));\n  }\n  \n  findMany(options = {}) {\n    let result = [...this.users];\n    \n    // Filter\n    if (options.where) {\n      result = result.filter(u => {\n        for (let [key, value] of Object.entries(options.where)) {\n          if (u[key] !== value) return false;\n        }\n        return true;\n      });\n    }\n    \n    // Order\n    if (options.orderBy) {\n      const [field, dir] = Object.entries(options.orderBy)[0];\n      result.sort((a, b) => dir === 'desc' ? b[field] - a[field] : a[field] - b[field]);\n    }\n    \n    // Pagination\n    if (options.skip) result = result.slice(options.skip);\n    if (options.take) result = result.slice(0, options.take);\n    \n    // Select\n    if (options.select) {\n      result = result.map(item => {\n        const obj = {};\n        for (let key of Object.keys(options.select)) {\n          if (options.select[key]) obj[key] = item[key];\n        }\n        return obj;\n      });\n    }\n    \n    return result;\n  }\n  \n  count(where = {}) {\n    return this.users.filter(u => {\n      for (let [k, v] of Object.entries(where)) {\n        if (u[k] !== v) return false;\n      }\n      return true;\n    }).length;\n  }\n  \n  aggregate(options) {\n    const result = {};\n    const data = this.users;\n    \n    if (options._count) result._count = data.length;\n    \n    if (options._sum) {\n      result._sum = {};\n      for (let field of Object.keys(options._sum)) {\n        result._sum[field] = data.reduce((s, u) => s + u[field], 0);\n      }\n    }\n    \n    if (options._avg) {\n      result._avg = {};\n      for (let field of Object.keys(options._avg)) {\n        result._avg[field] = data.reduce((s, u) => s + u[field], 0) / data.length;\n      }\n    }\n    \n    return result;\n  }\n  \n  groupBy(options) {\n    const groups = {};\n    \n    for (let item of this.users) {\n      const key = item[options.by[0]];\n      if (!groups[key]) groups[key] = { [options.by[0]]: key, _items: [] };\n      groups[key]._items.push(item);\n    }\n    \n    return Object.values(groups).map(g => {\n      const result = { [options.by[0]]: g[options.by[0]] };\n      if (options._count) result._count = g._items.length;\n      if (options._avg) {\n        result._avg = {};\n        for (let f of Object.keys(options._avg)) {\n          result._avg[f] = g._items.reduce((s, i) => s + i[f], 0) / g._items.length;\n        }\n      }\n      return result;\n    });\n  }\n}\n\nconst db = new MockDatabase();\n\n// Demo 1: Select specific fields\nconsole.log('1. Select specific fields:');\nconst selected = db.findMany({ select: { id: true, name: true }, take: 3 });\nconsole.log(selected);\n\n// Demo 2: Pagination\nconsole.log('\\n2. Pagination (5 per page):');\nfor (let page = 1; page <= 3; page++) {\n  const data = db.findMany({ skip: (page - 1) * 5, take: 5, select: { id: true, name: true } });\n  console.log(`Page ${page}:`, data.map(u => u.name).join(', '));\n}\n\n// Demo 3: Count\nconsole.log('\\n3. Counts:');\nconsole.log('Total users:', db.count());\nconsole.log('Engineering:', db.count({ department: 'Engineering' }));\n\n// Demo 4: Aggregations\nconsole.log('\\n4. Salary Stats:');\nconst stats = db.aggregate({ _count: true, _sum: { salary: true }, _avg: { salary: true } });\nconsole.log(stats);\n\n// Demo 5: Group By\nconsole.log('\\n5. By Department:');\nconst byDept = db.groupBy({ by: ['department'], _count: true, _avg: { salary: true } });\nconsole.log(byDept);",
              "solution": "// Complete Query Optimization Simulator\n\nclass MockDatabase {\n  constructor() {\n    this.queryCount = 0;\n    this.users = Array.from({ length: 100 }, (_, i) => ({\n      id: i + 1,\n      name: `User ${i + 1}`,\n      email: `user${i + 1}@example.com`,\n      department: ['Engineering', 'Sales', 'Marketing', 'HR'][i % 4],\n      salary: 50000 + Math.floor(Math.random() * 50000),\n      isActive: Math.random() > 0.2,\n      createdAt: new Date(2024, 0, i + 1)\n    }));\n  }\n  \n  log(operation, details) {\n    this.queryCount++;\n    console.log(`  [Query ${this.queryCount}] ${operation}: ${details}`);\n  }\n  \n  findMany(options = {}) {\n    let result = [...this.users];\n    let queryDetails = [];\n    \n    if (options.where) {\n      result = result.filter(u => {\n        for (let [key, value] of Object.entries(options.where)) {\n          if (typeof value === 'object') {\n            if (value.gte && u[key] < value.gte) return false;\n            if (value.lte && u[key] > value.lte) return false;\n          } else if (u[key] !== value) {\n            return false;\n          }\n        }\n        return true;\n      });\n      queryDetails.push(`WHERE ${JSON.stringify(options.where)}`);\n    }\n    \n    if (options.orderBy) {\n      const [field, dir] = Object.entries(options.orderBy)[0];\n      result.sort((a, b) => {\n        if (typeof a[field] === 'string') {\n          return dir === 'desc' ? b[field].localeCompare(a[field]) : a[field].localeCompare(b[field]);\n        }\n        return dir === 'desc' ? b[field] - a[field] : a[field] - b[field];\n      });\n      queryDetails.push(`ORDER BY ${field} ${dir.toUpperCase()}`);\n    }\n    \n    if (options.skip) {\n      result = result.slice(options.skip);\n      queryDetails.push(`SKIP ${options.skip}`);\n    }\n    \n    if (options.take) {\n      result = result.slice(0, options.take);\n      queryDetails.push(`TAKE ${options.take}`);\n    }\n    \n    if (options.select) {\n      const fields = Object.keys(options.select).filter(k => options.select[k]);\n      result = result.map(item => {\n        const obj = {};\n        for (let key of fields) {\n          obj[key] = item[key];\n        }\n        return obj;\n      });\n      queryDetails.push(`SELECT ${fields.join(', ')}`);\n    } else {\n      queryDetails.push('SELECT *');\n    }\n    \n    this.log('findMany', queryDetails.join(' '));\n    return result;\n  }\n  \n  count(where = null) {\n    let result = this.users;\n    \n    if (where) {\n      result = result.filter(u => {\n        for (let [k, v] of Object.entries(where)) {\n          if (u[k] !== v) return false;\n        }\n        return true;\n      });\n      this.log('count', `WHERE ${JSON.stringify(where)}`);\n    } else {\n      this.log('count', 'all records');\n    }\n    \n    return result.length;\n  }\n  \n  aggregate(options) {\n    let data = this.users;\n    const result = {};\n    const ops = [];\n    \n    if (options.where) {\n      data = data.filter(u => {\n        for (let [k, v] of Object.entries(options.where)) {\n          if (u[k] !== v) return false;\n        }\n        return true;\n      });\n    }\n    \n    if (options._count) {\n      result._count = data.length;\n      ops.push('COUNT');\n    }\n    \n    if (options._sum) {\n      result._sum = {};\n      for (let field of Object.keys(options._sum)) {\n        result._sum[field] = data.reduce((s, u) => s + (u[field] || 0), 0);\n        ops.push(`SUM(${field})`);\n      }\n    }\n    \n    if (options._avg) {\n      result._avg = {};\n      for (let field of Object.keys(options._avg)) {\n        const values = data.filter(u => u[field] != null);\n        result._avg[field] = Math.round(values.reduce((s, u) => s + u[field], 0) / values.length);\n        ops.push(`AVG(${field})`);\n      }\n    }\n    \n    if (options._min) {\n      result._min = {};\n      for (let field of Object.keys(options._min)) {\n        result._min[field] = Math.min(...data.map(u => u[field]).filter(v => v != null));\n        ops.push(`MIN(${field})`);\n      }\n    }\n    \n    if (options._max) {\n      result._max = {};\n      for (let field of Object.keys(options._max)) {\n        result._max[field] = Math.max(...data.map(u => u[field]).filter(v => v != null));\n        ops.push(`MAX(${field})`);\n      }\n    }\n    \n    this.log('aggregate', ops.join(', '));\n    return result;\n  }\n  \n  groupBy(options) {\n    const groups = {};\n    \n    for (let item of this.users) {\n      const key = options.by.map(f => item[f]).join('|');\n      if (!groups[key]) {\n        groups[key] = {\n          ...Object.fromEntries(options.by.map(f => [f, item[f]])),\n          _items: []\n        };\n      }\n      groups[key]._items.push(item);\n    }\n    \n    const result = Object.values(groups).map(g => {\n      const row = { ...g };\n      delete row._items;\n      \n      if (options._count) row._count = g._items.length;\n      \n      if (options._sum) {\n        row._sum = {};\n        for (let f of Object.keys(options._sum)) {\n          row._sum[f] = g._items.reduce((s, i) => s + (i[f] || 0), 0);\n        }\n      }\n      \n      if (options._avg) {\n        row._avg = {};\n        for (let f of Object.keys(options._avg)) {\n          row._avg[f] = Math.round(g._items.reduce((s, i) => s + i[f], 0) / g._items.length);\n        }\n      }\n      \n      return row;\n    });\n    \n    if (options.orderBy) {\n      const [key, dir] = Object.entries(options.orderBy)[0];\n      result.sort((a, b) => {\n        const aVal = key.startsWith('_') ? a[key] : a._sum?.[key] || a._avg?.[key] || 0;\n        const bVal = key.startsWith('_') ? b[key] : b._sum?.[key] || b._avg?.[key] || 0;\n        return dir === 'desc' ? bVal - aVal : aVal - bVal;\n      });\n    }\n    \n    this.log('groupBy', `BY ${options.by.join(', ')}`);\n    return result;\n  }\n}\n\nconst db = new MockDatabase();\n\nconsole.log('=== Query Optimization Demo ===\\n');\n\n// Demo 1: Full fetch vs Select\nconsole.log('1. COMPARISON: Full fetch vs Select');\nconsole.log('\\nFetching ALL fields:');\nconst allFields = db.findMany({ take: 2 });\nconsole.log(`  Fields returned: ${Object.keys(allFields[0]).length}`);\nconsole.log(`  Data: ${JSON.stringify(allFields[0])}`);\n\nconsole.log('\\nFetching SELECTED fields:');\nconst selectedFields = db.findMany({ take: 2, select: { id: true, name: true } });\nconsole.log(`  Fields returned: ${Object.keys(selectedFields[0]).length}`);\nconsole.log(`  Data: ${JSON.stringify(selectedFields[0])}`);\n\n// Demo 2: Pagination\nconsole.log('\\n2. PAGINATION (5 per page):');\nfor (let page = 1; page <= 3; page++) {\n  const data = db.findMany({\n    skip: (page - 1) * 5,\n    take: 5,\n    select: { id: true, name: true }\n  });\n  console.log(`  Page ${page}: IDs ${data.map(u => u.id).join(', ')}`);\n}\n\n// Demo 3: Count comparison\nconsole.log('\\n3. COMPARISON: length vs count()');\nconsole.log('\\nBAD: Fetching all to get count:');\nconst allUsers = db.findMany();\nconsole.log(`  Count: ${allUsers.length}`);\n\nconsole.log('\\nGOOD: Using count():');\nconst count = db.count();\nconsole.log(`  Count: ${count}`);\n\n// Demo 4: Aggregations\nconsole.log('\\n4. AGGREGATIONS:');\nconst stats = db.aggregate({\n  _count: true,\n  _sum: { salary: true },\n  _avg: { salary: true },\n  _min: { salary: true },\n  _max: { salary: true }\n});\nconsole.log(`  Total: ${stats._count} users`);\nconsole.log(`  Total Salary: $${stats._sum.salary.toLocaleString()}`);\nconsole.log(`  Avg Salary: $${stats._avg.salary.toLocaleString()}`);\nconsole.log(`  Salary Range: $${stats._min.salary.toLocaleString()} - $${stats._max.salary.toLocaleString()}`);\n\n// Demo 5: Group By\nconsole.log('\\n5. GROUP BY Department:');\nconst byDept = db.groupBy({\n  by: ['department'],\n  _count: true,\n  _avg: { salary: true },\n  orderBy: { _count: 'desc' }\n});\nbyDept.forEach(d => {\n  console.log(`  ${d.department}: ${d._count} employees, avg $${d._avg.salary.toLocaleString()}`);\n});\n\nconsole.log(`\\n=== Total Queries Executed: ${db.queryCount} ===`);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Select returns only specified fields",
                  "expectedOutput": "2",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Pagination returns correct pages",
                  "expectedOutput": "true",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For select, filter the object keys to only include those marked as true. For groupBy, use an object with department names as keys to collect items."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Fetching all data when only a count is needed",
                  "consequence": "Wastes memory and bandwidth, slows down the application significantly for large datasets.",
                  "correction": "Use count() method instead of findMany().length"
                },
                {
                  "mistake": "Calculating aggregates in JavaScript instead of database",
                  "consequence": "Fetches all data just to calculate sum/average, very inefficient.",
                  "correction": "Use aggregate() with _sum, _avg, etc. to let the database do the calculation."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-13",
      "title": "Module 13: Building Modern Front-End with React 19",
      "description": "Learn React 19's latest features including JSX, components, hooks (useState, useEffect), and the new React 19 hooks. Setup: Use Vite (npm create vite@latest) - Create React App (CRA) is deprecated as of 2023",
      "difficulty": "advanced",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "13.1",
          "title": "JSX - JavaScript Meets HTML (But It's NOT HTML!)",
          "moduleId": "module-13",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine writing a recipe:\n\nPlain text recipe:\n- Hard to read\n- No structure\n- Easy to mess up\n\nFormatted recipe with sections:\n- Ingredients (like HTML tags)\n- Instructions (like JavaScript logic)\n- Combined in one document\n\nJSX is like having ingredients AND instructions in one file:\n- Looks like HTML (familiar and readable)\n- But it's actually JavaScript (gets compiled)\n- Can use JavaScript expressions inside {}\n\nJSX = JavaScript XML. It's JavaScript that LOOKS like HTML!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// JSX - The Syntax That Powers React\n\n// IMPORTANT: JSX compiles to JavaScript!\n// This JSX:\n// <h1>Hello World</h1>\n//\n// Becomes this JavaScript:\n// React.createElement('h1', null, 'Hello World')\n\nconsole.log('=== JSX Fundamentals ===\\n');\n\n// 1. JSX LOOKS LIKE HTML (but isn't!)\nlet jsxElement = '<h1>Hello, React!</h1>'; // This is just a string\nconsole.log('String:', jsxElement);\n\n// Real JSX (conceptual - won't run in plain JavaScript):\n// let jsxElement = <h1>Hello, React!</h1>;\n// This compiles to: React.createElement('h1', null, 'Hello, React!');\n\n// 2. EMBEDDING JAVASCRIPT WITH {}\nlet name = 'Alice';\nlet age = 25;\n\n// JSX allows JavaScript expressions inside curly braces\nlet greeting = `<h1>Hello, ${name}!</h1>`;  // Template literal (similar concept)\nconsole.log('\\nGreeting:', greeting);\n\n// In real JSX:\n// <h1>Hello, {name}!</h1>\n// <p>You are {age} years old</p>\n// <p>Next year: {age + 1}</p>\n\n// 3. JSX VS HTML - KEY DIFFERENCES\nconsole.log('\\n=== JSX vs HTML Differences ===\\n');\n\nlet differences = {\n  'class': {\n    html: '<div class=\"card\">',\n    jsx: '<div className=\"card\">',\n    reason: 'class is a JavaScript keyword'\n  },\n  'for': {\n    html: '<label for=\"name\">',\n    jsx: '<label htmlFor=\"name\">',\n    reason: 'for is a JavaScript keyword'\n  },\n  'style': {\n    html: '<div style=\"color: red; font-size: 16px\">',\n    jsx: '<div style={{ color: \"red\", fontSize: \"16px\" }}>',\n    reason: 'JSX style is a JavaScript object'\n  },\n  'onclick': {\n    html: '<button onclick=\"handleClick()\">',\n    jsx: '<button onClick={handleClick}>',\n    reason: 'camelCase in JSX, function reference not string'\n  },\n  'self-closing': {\n    html: '<img src=\"pic.jpg\">',\n    jsx: '<img src=\"pic.jpg\" />',\n    reason: 'JSX requires closing slash for void elements'\n  }\n};\n\nfor (let [feature, diff] of Object.entries(differences)) {\n  console.log(`${feature.toUpperCase()}:`);\n  console.log(`  HTML: ${diff.html}`);\n  console.log(`  JSX:  ${diff.jsx}`);\n  console.log(`  Why:  ${diff.reason}\\n`);\n}\n\n// 4. JAVASCRIPT EXPRESSIONS IN JSX\nconsole.log('=== JavaScript in JSX ===\\n');\n\nlet user = {\n  firstName: 'Bob',\n  lastName: 'Smith',\n  age: 30\n};\n\n// You can use ANY JavaScript expression inside {}\nlet examples = [\n  `{user.firstName}           → ${user.firstName}`,\n  `{user.firstName + ' ' + user.lastName} → ${user.firstName + ' ' + user.lastName}`,\n  `{age > 18 ? 'Adult' : 'Minor'} → ${user.age > 18 ? 'Adult' : 'Minor'}`,\n  `{[1,2,3].map(n => n * 2)}  → ${[1,2,3].map(n => n * 2).join(', ')}`\n];\n\nexamples.forEach(ex => console.log(ex));\n\n// 5. MUST RETURN SINGLE ROOT ELEMENT\nconsole.log('\\n=== JSX Rules ===\\n');\n\n// WRONG (in JSX - multiple roots):\n// return (\n//   <h1>Title</h1>\n//   <p>Text</p>\n// );\n\n// CORRECT - Wrapped in div:\n// return (\n//   <div>\n//     <h1>Title</h1>\n//     <p>Text</p>\n//   </div>\n// );\n\n// BETTER - React Fragment (no extra DOM node):\n// return (\n//   <>\n//     <h1>Title</h1>\n//     <p>Text</p>\n//   </>\n// );\n\nconsole.log('✓ JSX must have ONE root element');\nconsole.log('✓ Use <> </> (Fragment) to avoid extra divs');\nconsole.log('✓ All tags must be closed (including <img />, <br />)');\nconsole.log('✓ Use className not class');\nconsole.log('✓ Use camelCase for attributes (onClick, onChange)');\n\n// 6. WHY JSX?\nlet benefits = [\n  'Familiar HTML-like syntax',\n  'JavaScript power with {} expressions',\n  'Type checking and autocomplete',\n  'Prevents injection attacks (auto-escapes)',\n  'Easier to visualize component structure',\n  'Not required but highly recommended'\n];\n\nconsole.log('\\nWhy use JSX:');\nbenefits.forEach(b => console.log(`  ✓ ${b}`));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "JSX syntax guide:\n\n1. **JSX is JavaScript, not HTML**:\n   ```jsx\n   // This JSX:\n   const element = <h1>Hello</h1>;\n   \n   // Compiles to:\n   const element = React.createElement('h1', null, 'Hello');\n   ```\n\n2. **Embedding Expressions** with {}:\n   ```jsx\n   const name = 'Alice';\n   const element = <h1>Hello, {name}!</h1>;\n   \n   // Any JavaScript expression works:\n   <p>{2 + 2}</p>                    // 4\n   <p>{user.name.toUpperCase()}</p>  // ALICE\n   <p>{isLoggedIn ? 'Hi' : 'Please login'}</p>\n   ```\n\n3. **Attributes in JSX**:\n   ```jsx\n   // className not class\n   <div className=\"container\"></div>\n   \n   // htmlFor not for\n   <label htmlFor=\"email\">Email:</label>\n   \n   // camelCase event handlers\n   <button onClick={handleClick}>Click</button>\n   \n   // Style as object\n   <div style={{ color: 'red', fontSize: 16 }}></div>\n   ```\n\n4. **Self-Closing Tags**:\n   ```jsx\n   // Must include /\n   <img src=\"logo.png\" />\n   <br />\n   <input type=\"text\" />\n   ```\n\n5. **Children**:\n   ```jsx\n   // String children\n   <h1>Title</h1>\n   \n   // Expression children\n   <p>{user.name}</p>\n   \n   // Component children\n   <div>\n     <Header />\n     <Main />\n     <Footer />\n   </div>\n   ```\n\n6. **Fragments** (avoid extra divs):\n   ```jsx\n   // Shorthand\n   return (\n     <>\n       <h1>Title</h1>\n       <p>Text</p>\n     </>\n   );\n   \n   // Full syntax (needed for keys)\n   return (\n     <React.Fragment>\n       <h1>Title</h1>\n       <p>Text</p>\n     </React.Fragment>\n   );\n   ```\n\n7. **Comments in JSX**:\n   ```jsx\n   return (\n     <div>\n       {/* This is a comment */}\n       <h1>Title</h1>\n     </div>\n   );\n   ```"
            },
            {
              "type": "KEY_POINT",
              "title": "Setting Up a React Project (2025)",
              "content": "**Modern React Project Setup:**\\n\\n```bash\\n# Create new React project with Vite (RECOMMENDED)\\nnpm create vite@latest my-app -- --template react\\ncd my-app\\nnpm install\\nnpm run dev\\n```\\n\\n**Why Vite over Create React App?**\\n- Create React App (CRA) is **deprecated** as of 2023\\n- Vite is 10-100x faster for development\\n- Native ES modules support\\n- Recommended by React documentation\\n\\n**Alternative: Next.js** (for full-stack React):\\n```bash\\nnpx create-next-app@latest my-app\\n```\\n\\nAlways use Vite or Next.js for new React projects in 2025!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common JSX mistakes:\n\n1. **Using `class` instead of `className`**:\n   ```jsx\n   // Wrong!\n   <div class=\"container\">  // Error in JSX\n   \n   // Correct!\n   <div className=\"container\">\n   ```\n\n2. **Forgetting to close tags**:\n   ```jsx\n   // Wrong!\n   <img src=\"logo.png\">     // Error!\n   <br>                     // Error!\n   \n   // Correct!\n   <img src=\"logo.png\" />\n   <br />\n   ```\n\n3. **Quotes around JavaScript expressions**:\n   ```jsx\n   // Wrong!\n   <p>{\"userName\"}</p>       // Renders the string \"userName\"\n   <p>{age + 1}</p>         // Wrong quotes\n   \n   // Correct!\n   <p>{userName}</p>        // Uses the variable\n   <p>{age + 1}</p>         // No quotes for expressions\n   ```\n\n4. **Multiple root elements**:\n   ```jsx\n   // Wrong!\n   return (\n     <h1>Title</h1>\n     <p>Text</p>            // Error: Adjacent JSX elements\n   );\n   \n   // Correct!\n   return (\n     <>\n       <h1>Title</h1>\n       <p>Text</p>\n     </>\n   );\n   ```\n\n5. **Inline style as string**:\n   ```jsx\n   // Wrong! (HTML syntax)\n   <div style=\"color: red; font-size: 16px\">\n   \n   // Correct! (JSX object syntax)\n   <div style={{ color: 'red', fontSize: 16 }}>\n   //          ^^^^ object  ^^^^^ camelCase\n   ```\n\n6. **Event handler called immediately**:\n   ```jsx\n   // Wrong!\n   <button onClick={handleClick()}>  // Calls immediately!\n   \n   // Correct!\n   <button onClick={handleClick}>    // Passes function reference\n   <button onClick={() => handleClick()}>  // Arrow function wrapper\n   ```\n\n7. **Conditional rendering syntax**:\n   ```jsx\n   // Wrong!\n   <div>\n     if (isLoggedIn) {      // Can't use if in JSX!\n       <p>Welcome</p>\n     }\n   </div>\n   \n   // Correct!\n   <div>\n     {isLoggedIn && <p>Welcome</p>}           // && operator\n     {isLoggedIn ? <p>Hi</p> : <p>Login</p>}  // Ternary\n   </div>\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.1-challenge",
              "title": "Practice Challenge",
              "description": "Practice JSX concepts:\n\n1. Create variables for:\n   - `firstName` = your first name\n   - `lastName` = your last name\n   - `age` = your age\n\n2. Create a `getFullName()` function that returns first + last name\n\n3. Create a simulated JSX structure (as a string) that includes:\n   - An h1 with full name\n   - A p showing age\n   - A p showing if adult (age >= 18)\n\n4. Log the result\n\nNote: Since we're in plain JavaScript, use template literals to simulate JSX.",
              "instructions": "Practice JSX concepts:\n\n1. Create variables for:\n   - `firstName` = your first name\n   - `lastName` = your last name\n   - `age` = your age\n\n2. Create a `getFullName()` function that returns first + last name\n\n3. Create a simulated JSX structure (as a string) that includes:\n   - An h1 with full name\n   - A p showing age\n   - A p showing if adult (age >= 18)\n\n4. Log the result\n\nNote: Since we're in plain JavaScript, use template literals to simulate JSX.",
              "starterCode": "// Simulate JSX with template literals\n\nlet firstName = 'Alice';\nlet lastName = 'Johnson';\nlet age = 25;\n\nfunction getFullName() {\n  return firstName + ' ' + lastName;\n}\n\n// Simulate JSX structure\nlet jsxOutput = `\n<div className=\"user-card\">\n  <h1>Name: ${getFullName()}</h1>\n  <p>Age: ${age}</p>\n  <p>Status: ${age >= 18 ? 'Adult' : 'Minor'}</p>\n</div>\n`;\n\nconsole.log('Simulated JSX:');\nconsole.log(jsxOutput);",
              "solution": "// Complete JSX simulation\n\nlet firstName = 'Alice';\nlet lastName = 'Johnson';\nlet age = 25;\nlet isStudent = true;\n\nfunction getFullName() {\n  return `${firstName} ${lastName}`;\n}\n\nfunction getStatus() {\n  if (age < 18) return 'Minor';\n  if (isStudent) return 'Adult Student';\n  return 'Adult';\n}\n\n// Simulated JSX with all features\nlet jsxOutput = `\n<div className=\"user-card\">\n  <h1>Welcome, ${getFullName()}!</h1>\n  <div className=\"user-info\">\n    <p>First Name: ${firstName}</p>\n    <p>Last Name: ${lastName}</p>\n    <p>Age: ${age}</p>\n    <p>Status: ${getStatus()}</p>\n    <p>Can Vote: ${age >= 18 ? 'Yes' : 'No'}</p>\n  </div>\n  ${isStudent ? '<p className=\"badge\">Student Discount Available!</p>' : ''}\n</div>\n`;\n\nconsole.log('=== Simulated JSX Output ===');\nconsole.log(jsxOutput);\n\n// Demonstrate JavaScript expressions\nconsole.log('\\n=== Expression Examples ===');\nconsole.log('Full name:', getFullName());\nconsole.log('Next year age:', age + 1);\nconsole.log('Name length:', getFullName().length);\nconsole.log('Uppercase:', getFullName().toUpperCase());\nconsole.log('Adult?', age >= 18);\n\n// Array mapping (common in JSX)\nlet hobbies = ['Reading', 'Coding', 'Gaming'];\nlet hobbiesList = hobbies.map(hobby => `<li>${hobby}</li>`).join('\\n');\nconsole.log('\\nHobbies list:');\nconsole.log('<ul>');\nconsole.log(hobbiesList);\nconsole.log('</ul>');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should concatenate names",
                  "expectedOutput": "John Doe",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should check adult status",
                  "expectedOutput": "Adult",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use template literals with ${} to embed JavaScript expressions."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common JSX mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common JSX mistakes:"
                },
                {
                  "mistake": "**Using `class` instead of `className`**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Using `class` instead of `className`**:\n   ```jsx\n   // Wrong!\n   <div class=\"container\">  // Error in JSX\n   \n   // Correct!\n   <div className=\"container\">\n   ```"
                },
                {
                  "mistake": "**Forgetting to close tags**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting to close tags**:\n   ```jsx\n   // Wrong!\n   <img src=\"logo.png\">     // Error!\n   <br>                     // Error!\n   \n   // Correct!\n   <img src=\"logo.png\" />\n   <br />\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "13.2",
          "title": "Components and Props (The LEGO Blocks Analogy)",
          "moduleId": "module-13",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of React components like LEGO blocks:\n\nBasic LEGO block:\n- Standard shape and size\n- Can connect to other blocks\n- Reusable - use the same piece many times\n- Different colors (props) make each one unique\n\nCustom LEGO creation (component):\n- Build a car from blocks\n- Want 5 cars? Use the same design 5 times\n- Each car can be different color (props)\n- Change the design once → All cars update\n\nReact components are reusable building blocks:\n- Define once, use many times\n- Pass props to customize each instance\n- Compose small components into bigger ones!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// React Components and Props\n\nconsole.log('=== React Components ===\\n');\n\n// COMPONENT = Reusable UI function\n// Props = Data passed to component (like function parameters)\n\n// 1. FUNCTION COMPONENT (modern React)\nfunction Greeting(props) {\n  return `<h1>Hello, ${props.name}!</h1>`;\n}\n\n// Use it multiple times with different props\nlet greeting1 = Greeting({ name: 'Alice' });\nlet greeting2 = Greeting({ name: 'Bob' });\nlet greeting3 = Greeting({ name: 'Charlie' });\n\nconsole.log('Same component, different props:');\nconsole.log(greeting1);  // Hello, Alice!\nconsole.log(greeting2);  // Hello, Bob!\nconsole.log(greeting3);  // Hello, Charlie!\n\n// 2. PROPS ARE READ-ONLY\nfunction UserCard(props) {\n  // props.name = 'Different'; // ERROR! Can't modify props!\n  \n  return `\n    <div className=\"user-card\">\n      <h2>${props.name}</h2>\n      <p>Email: ${props.email}</p>\n      <p>Role: ${props.role || 'User'}</p>\n    </div>\n  `;\n}\n\nlet user1 = UserCard({\n  name: 'Alice Johnson',\n  email: 'alice@example.com',\n  role: 'Admin'\n});\n\nlet user2 = UserCard({\n  name: 'Bob Smith',\n  email: 'bob@example.com'\n  // No role = uses default 'User'\n});\n\nconsole.log('\\nUser Cards:');\nconsole.log(user1);\nconsole.log(user2);\n\n// 3. DESTRUCTURING PROPS (cleaner syntax)\nfunction Button({ label, color, onClick }) {\n  // Instead of props.label, props.color, etc.\n  return `<button style=\"background: ${color}\" onClick=\"${onClick}\">${label}</button>`;\n}\n\nlet submitBtn = Button({\n  label: 'Submit',\n  color: 'blue',\n  onClick: 'handleSubmit()'\n});\n\nconsole.log('\\nButton:', submitBtn);\n\n// 4. PROPS WITH CHILDREN\nfunction Card({ title, children }) {\n  return `\n    <div className=\"card\">\n      <h3>${title}</h3>\n      <div className=\"card-body\">\n        ${children}\n      </div>\n    </div>\n  `;\n}\n\nlet card = Card({\n  title: 'My Card',\n  children: '<p>This is the card content</p><p>Multiple children!</p>'\n});\n\nconsole.log('\\nCard with children:');\nconsole.log(card);\n\n// 5. COMPONENT COMPOSITION\nfunction Header({ logo, title }) {\n  return `<header><img src=\"${logo}\" /><h1>${title}</h1></header>`;\n}\n\nfunction Footer({ year, company }) {\n  return `<footer><p>© ${year} ${company}</p></footer>`;\n}\n\nfunction App() {\n  return `\n    <div className=\"app\">\n      ${Header({ logo: 'logo.png', title: 'My App' })}\n      <main>\n        ${Card({ title: 'Welcome', children: '<p>Welcome to my app!</p>' })}\n      </main>\n      ${Footer({ year: 2025, company: 'My Company' })}\n    </div>\n  `;\n}\n\nconsole.log('\\nComplete App (composed of smaller components):');\nconsole.log(App());\n\n// 6. PROPS BEST PRACTICES\nconsole.log('\\n=== Props Best Practices ===\\n');\n\nlet practices = [\n  '✓ Props are read-only (immutable)',\n  '✓ Destructure props for cleaner code',\n  '✓ Provide default values: role || \"User\"',\n  '✓ Use clear, descriptive prop names',\n  '✓ Pass only what component needs',\n  '✓ Children prop for nested content',\n  '✓ Keep components focused and reusable'\n];\n\npractices.forEach(p => console.log(p));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Components and Props explained:\n\n1. **Function Component** (modern standard):\n   ```jsx\n   function Welcome(props) {\n     return <h1>Hello, {props.name}!</h1>;\n   }\n   \n   // Use it:\n   <Welcome name=\"Alice\" />\n   ```\n\n2. **Props Object**:\n   ```jsx\n   function UserCard(props) {\n     // props = { name: 'Alice', age: 25, email: 'alice@...' }\n     return (\n       <div>\n         <h2>{props.name}</h2>\n         <p>Age: {props.age}</p>\n         <p>Email: {props.email}</p>\n       </div>\n     );\n   }\n   ```\n\n3. **Destructuring Props** (recommended):\n   ```jsx\n   // Instead of props.name, props.age...\n   function UserCard({ name, age, email }) {\n     return (\n       <div>\n         <h2>{name}</h2>\n         <p>Age: {age}</p>\n         <p>Email: {email}</p>\n       </div>\n     );\n   }\n   ```\n\n4. **Default Props**:\n   ```jsx\n   function Button({ label, color = 'blue', size = 'medium' }) {\n     return <button style={{ backgroundColor: color }}>{label}</button>;\n   }\n   \n   // Uses defaults:\n   <Button label=\"Click\" />  // blue, medium\n   \n   // Override defaults:\n   <Button label=\"Submit\" color=\"green\" size=\"large\" />\n   ```\n\n5. **Children Prop** (special):\n   ```jsx\n   function Card({ title, children }) {\n     return (\n       <div className=\"card\">\n         <h3>{title}</h3>\n         <div className=\"card-body\">\n           {children}\n         </div>\n       </div>\n     );\n   }\n   \n   // Use with children:\n   <Card title=\"My Card\">\n     <p>This is the content</p>\n     <button>Action</button>\n   </Card>\n   ```\n\n6. **Passing Functions as Props**:\n   ```jsx\n   function Button({ label, onClick }) {\n     return <button onClick={onClick}>{label}</button>;\n   }\n   \n   // Parent passes function:\n   function App() {\n     function handleClick() {\n       console.log('Clicked!');\n     }\n     \n     return <Button label=\"Click Me\" onClick={handleClick} />;\n   }\n   ```\n\n7. **Component Composition**:\n   ```jsx\n   function App() {\n     return (\n       <div>\n         <Header />\n         <Sidebar />\n         <MainContent>\n           <Article title=\"Hello\" />\n           <Article title=\"World\" />\n         </MainContent>\n         <Footer />\n       </div>\n     );\n   }\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common component/props mistakes:\n\n1. **Modifying props (forbidden!)**:\n   ```jsx\n   function UserCard(props) {\n     props.name = 'Different';  // ERROR! Props are read-only!\n     return <h1>{props.name}</h1>;\n   }\n   ```\n   Props flow down (parent → child) and cannot be changed by child.\n\n2. **Forgetting to pass props**:\n   ```jsx\n   function Greeting({ name }) {\n     return <h1>Hello, {name}!</h1>;\n   }\n   \n   // Wrong!\n   <Greeting />  // name is undefined!\n   \n   // Correct!\n   <Greeting name=\"Alice\" />\n   ```\n\n3. **Component name not capitalized**:\n   ```jsx\n   // Wrong!\n   function greeting() {  // lowercase!\n     return <h1>Hello</h1>;\n   }\n   \n   // Correct!\n   function Greeting() {  // PascalCase!\n     return <h1>Hello</h1>;\n   }\n   ```\n   React treats lowercase as HTML tags, uppercase as components.\n\n4. **Not destructuring (verbose)**:\n   ```jsx\n   // Works but verbose:\n   function UserCard(props) {\n     return <div>{props.name} - {props.email} - {props.age}</div>;\n   }\n   \n   // Better (destructured):\n   function UserCard({ name, email, age }) {\n     return <div>{name} - {email} - {age}</div>;\n   }\n   ```\n\n5. **Missing key in lists**:\n   ```jsx\n   // Wrong!\n   {users.map(user => <UserCard {...user} />)}\n   \n   // Correct!\n   {users.map(user => <UserCard key={user.id} {...user} />)}\n   ```\n   React needs keys to track which items changed.\n\n6. **Passing strings incorrectly**:\n   ```jsx\n   // Wrong!\n   <UserCard age=\"25\" />     // age is string \"25\", not number!\n   \n   // Correct!\n   <UserCard age={25} />     // age is number 25\n   \n   // Strings don't need braces:\n   <UserCard name=\"Alice\" /> // OK\n   <UserCard name={'Alice'} /> // Also OK but unnecessary\n   ```\n\n7. **Inline object props (causes re-renders)**:\n   ```jsx\n   // Avoid (creates new object every render):\n   <UserCard style={{ color: 'red' }} />\n   \n   // Better (define outside):\n   const cardStyle = { color: 'red' };\n   <UserCard style={cardStyle} />\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.2-challenge",
              "title": "Practice Challenge",
              "description": "Create reusable components with props:\n\n1. Create a `BlogPost` function that takes props:\n   - title\n   - author\n   - content\n   - Returns formatted HTML string\n\n2. Create an `AuthorBio` function that takes:\n   - name\n   - bio\n   - Returns formatted HTML string\n\n3. Create a `Blog` function that:\n   - Uses BlogPost twice with different data\n   - Uses AuthorBio once\n   - Returns complete blog page\n\nTest by calling Blog() and logging result.",
              "instructions": "Create reusable components with props:\n\n1. Create a `BlogPost` function that takes props:\n   - title\n   - author\n   - content\n   - Returns formatted HTML string\n\n2. Create an `AuthorBio` function that takes:\n   - name\n   - bio\n   - Returns formatted HTML string\n\n3. Create a `Blog` function that:\n   - Uses BlogPost twice with different data\n   - Uses AuthorBio once\n   - Returns complete blog page\n\nTest by calling Blog() and logging result.",
              "starterCode": "// Component functions\n\nfunction BlogPost({ title, author, content }) {\n  return `\n    <article className=\"blog-post\">\n      <h2>${title}</h2>\n      <p className=\"author\">By ${author}</p>\n      <p>${content}</p>\n    </article>\n  `;\n}\n\nfunction AuthorBio({ name, bio }) {\n  return `\n    <div className=\"author-bio\">\n      <h3>About ${name}</h3>\n      <p>${bio}</p>\n    </div>\n  `;\n}\n\nfunction Blog() {\n  return `\n    <div className=\"blog\">\n      <h1>My Blog</h1>\n      ${BlogPost({\n        title: 'Learning React',\n        author: 'Alice',\n        content: 'React is amazing for building UIs!'\n      })}\n      ${BlogPost({\n        title: 'Understanding Props',\n        author: 'Alice',\n        content: 'Props make components reusable.'\n      })}\n      ${AuthorBio({\n        name: 'Alice',\n        bio: 'Web developer and React enthusiast.'\n      })}\n    </div>\n  `;\n}\n\nconsole.log(Blog());",
              "solution": "// Complete component system with props\n\nfunction BlogPost({ title, author, content, date = 'Today' }) {\n  return `\n    <article className=\"blog-post\">\n      <h2>${title}</h2>\n      <div className=\"meta\">\n        <span className=\"author\">By ${author}</span>\n        <span className=\"date\">${date}</span>\n      </div>\n      <p className=\"content\">${content}</p>\n    </article>\n  `;\n}\n\nfunction AuthorBio({ name, bio, avatar = 'default-avatar.png' }) {\n  return `\n    <div className=\"author-bio\">\n      <img src=\"${avatar}\" alt=\"${name}\" className=\"avatar\" />\n      <h3>About ${name}</h3>\n      <p>${bio}</p>\n    </div>\n  `;\n}\n\nfunction CommentSection({ comments = [] }) {\n  if (comments.length === 0) {\n    return '<p>No comments yet.</p>';\n  }\n  \n  return `\n    <div className=\"comments\">\n      <h3>${comments.length} Comment${comments.length !== 1 ? 's' : ''}</h3>\n      ${comments.map(c => `\n        <div className=\"comment\">\n          <strong>${c.author}:</strong> ${c.text}\n        </div>\n      `).join('')}\n    </div>\n  `;\n}\n\nfunction Blog() {\n  let posts = [\n    {\n      title: 'Getting Started with React',\n      author: 'Alice Johnson',\n      content: 'React makes building user interfaces simple and enjoyable!',\n      date: 'Jan 15, 2025'\n    },\n    {\n      title: 'Understanding Props and Components',\n      author: 'Alice Johnson',\n      content: 'Props are the way we pass data between components.',\n      date: 'Jan 16, 2025'\n    }\n  ];\n  \n  let comments = [\n    { author: 'Bob', text: 'Great article!' },\n    { author: 'Charlie', text: 'Very helpful, thanks!' }\n  ];\n  \n  return `\n    <div className=\"blog\">\n      <header>\n        <h1>My React Blog</h1>\n      </header>\n      \n      <main>\n        ${posts.map(post => BlogPost(post)).join('\\n')}\n      </main>\n      \n      <aside>\n        ${AuthorBio({\n          name: 'Alice Johnson',\n          bio: 'Full-stack developer passionate about React and modern web development.',\n          avatar: 'alice-avatar.jpg'\n        })}\n      </aside>\n      \n      ${CommentSection({ comments })}\n    </div>\n  `;\n}\n\nconsole.log('=== Complete Blog Application ===\\n');\nconsole.log(Blog());\n\n// Demonstrate component reusability\nconsole.log('\\n=== Reusability Demo ===\\n');\nconsole.log('Creating 3 blog posts with same component:');\n\nfor (let i = 1; i <= 3; i++) {\n  console.log(BlogPost({\n    title: `Post ${i}`,\n    author: 'Demo Author',\n    content: `Content for post number ${i}`\n  }));\n}",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should use props in template",
                  "expectedOutput": "<h2>Test</h2><p>By Bob</p>",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use destructuring in function parameters and template literals for HTML."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common component/props mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common component/props mistakes:"
                },
                {
                  "mistake": "**Modifying props (forbidden!)**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Modifying props (forbidden!)**:\n   ```jsx\n   function UserCard(props) {\n     props.name = 'Different';  // ERROR! Props are read-only!\n     return <h1>{props.name}</h1>;\n   }\n   ```\n   Props flow down (parent → child) and cannot be changed by child."
                },
                {
                  "mistake": "**Forgetting to pass props**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting to pass props**:\n   ```jsx\n   function Greeting({ name }) {\n     return <h1>Hello, {name}!</h1>;\n   }\n   \n   // Wrong!\n   <Greeting />  // name is undefined!\n   \n   // Correct!\n   <Greeting name=\"Alice\" />\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "13.3",
          "title": "useState Hook - Giving Components Memory (The Light Switch Analogy)",
          "moduleId": "module-13",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of a light switch in your house:\n\nWithout state (broken switch):\n- You flip the switch up\n- Light turns on for a moment\n- Switch immediately resets to off\n- Light goes back off\n- Can't remember if it was on or off!\n\nWith state (working switch):\n- You flip switch up → light turns ON\n- Switch REMEMBERS it's on\n- Stays on until you flip it down\n- Switch REMEMBERS it's off\n- State = Current position of the switch\n\nReact useState is like giving your component a working switch:\n- Component can remember values between renders\n- When state changes → component re-renders\n- UI updates automatically to show new state\n- Perfect for: counters, form inputs, toggles, user data!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// useState Hook - Component Memory\n\nconsole.log('=== React useState Hook ===\\n');\n\n// WHY WE NEED STATE\nconsole.log('--- Without State (Doesn\\'t Work!) ---\\n');\n\nfunction simulateComponentWithoutState() {\n  let count = 0;  // Regular variable\n  \n  console.log('[Component] Initial render: count =', count);\n  \n  // User clicks button\n  console.log('[User] Clicks +1 button');\n  count = count + 1;\n  console.log('[Component] count =', count, '(but component doesn\\'t re-render!)');\n  \n  // Component renders again (for some reason)\n  count = 0;  // RESETS! Regular variables don't persist\n  console.log('[Component] Re-render: count =', count, '(LOST the value!)');\n}\n\nsimulateComponentWithoutState();\n\n// WITH STATE (Works!)\nconsole.log('\\n--- With useState (Works!) ---\\n');\n\nfunction simulateComponentWithState() {\n  // useState hook - PERSISTS between renders\n  let state = {\n    count: 0,\n    setCount: function(newValue) {\n      this.count = newValue;\n      console.log('[State Update] count changed to:', newValue);\n      console.log('[React] Re-rendering component...');\n    }\n  };\n  \n  console.log('[Component] Initial render: count =', state.count);\n  \n  // User clicks button\n  console.log('\\n[User] Clicks +1 button');\n  state.setCount(state.count + 1);\n  console.log('[Component] Re-render: count =', state.count, '(PERSISTED!)');\n  \n  // User clicks again\n  console.log('\\n[User] Clicks +1 button again');\n  state.setCount(state.count + 1);\n  console.log('[Component] Re-render: count =', state.count);\n}\n\nsimulateComponentWithState();\n\n// REAL useState SYNTAX\nconsole.log('\\n\\n=== useState Syntax ===\\n');\n\nconsole.log('// Import from React');\nconsole.log('import { useState } from \"react\";\\n');\n\nconsole.log('function Counter() {');\nconsole.log('  // useState returns [currentValue, setterFunction]');\nconsole.log('  const [count, setCount] = useState(0);');\nconsole.log('  //      ^^^^^  ^^^^^^^^          ^^^');\nconsole.log('  //      value  updater          initial value\\n');\n\nconsole.log('  function increment() {');\nconsole.log('    setCount(count + 1);  // Update state');\nconsole.log('  }\\n');\n\nconsole.log('  return (');\nconsole.log('    <div>');\nconsole.log('      <p>Count: {count}</p>');\nconsole.log('      <button onClick={increment}>+1</button>');\nconsole.log('    </div>');\nconsole.log('  );');\nconsole.log('}\\n');\n\n// MULTIPLE STATE VARIABLES\nconsole.log('=== Multiple State Variables ===\\n');\n\nconsole.log('function UserProfile() {');\nconsole.log('  const [name, setName] = useState(\"Alice\");');\nconsole.log('  const [age, setAge] = useState(25);');\nconsole.log('  const [isLoggedIn, setIsLoggedIn] = useState(false);\\n');\n\nconsole.log('  // Each state is independent!');\nconsole.log('  setName(\"Bob\");        // Only updates name');\nconsole.log('  setAge(30);           // Only updates age');\nconsole.log('  setIsLoggedIn(true);  // Only updates isLoggedIn');\nconsole.log('}\\n');\n\n// STATE WITH OBJECTS\nconsole.log('=== State with Objects ===\\n');\n\nlet userState = {\n  user: { name: 'Alice', age: 25, email: 'alice@example.com' },\n  setUser: function(newUser) {\n    // MUST create new object (don't mutate!)\n    this.user = { ...this.user, ...newUser };\n    console.log('[State] Updated user:', this.user);\n  }\n};\n\nconsole.log('Initial user:', userState.user);\n\nconsole.log('\\nUpdating age:');\nuserState.setUser({ age: 26 });  // Spread syntax preserves other fields\n\nconsole.log('\\n// WRONG way (mutation):');\nconsole.log('user.age = 26;        // ✗ Don\\'t mutate directly!');\nconsole.log('setUser(user);       // ✗ React won\\'t detect change!\\n');\n\nconsole.log('// CORRECT way (new object):');\nconsole.log('setUser({ ...user, age: 26 });  // ✓ Creates new object');\n\n// STATE WITH ARRAYS\nconsole.log('\\n\\n=== State with Arrays ===\\n');\n\nlet todosState = {\n  todos: ['Learn React', 'Build app'],\n  setTodos: function(newTodos) {\n    this.todos = newTodos;\n    console.log('[State] Updated todos:', this.todos);\n  }\n};\n\nconsole.log('Initial todos:', todosState.todos);\n\nconsole.log('\\nAdding todo:');\ntodosState.setTodos([...todosState.todos, 'Deploy app']);\n\nconsole.log('\\nRemoving first todo:');\ntodosState.setTodos(todosState.todos.slice(1));\n\nconsole.log('\\n--- Array State Patterns ---');\nconsole.log('Add item:    setTodos([...todos, newItem])');\nconsole.log('Remove item: setTodos(todos.filter(t => t.id !== id))');\nconsole.log('Update item: setTodos(todos.map(t => t.id === id ? updated : t))');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "useState Hook explained:\n\n1. **Basic useState**:\n   ```jsx\n   import { useState } from 'react';\n   \n   function Counter() {\n     const [count, setCount] = useState(0);\n     //      ^^^^^  ^^^^^^^^          ^^^\n     //      state  setter           initial value\n     \n     return (\n       <div>\n         <p>{count}</p>\n         <button onClick={() => setCount(count + 1)}>+1</button>\n       </div>\n     );\n   }\n   ```\n\n2. **Array Destructuring** (what [count, setCount] means):\n   ```jsx\n   // useState returns an array: [value, setter]\n   const stateArray = useState(0);  // [0, function]\n   const count = stateArray[0];     // Get value\n   const setCount = stateArray[1];  // Get setter\n   \n   // Shorthand (array destructuring):\n   const [count, setCount] = useState(0);  // Same thing!\n   ```\n\n3. **Initial Value**:\n   ```jsx\n   const [count, setCount] = useState(0);      // Number\n   const [name, setName] = useState('Alice');  // String\n   const [isOpen, setIsOpen] = useState(false); // Boolean\n   const [items, setItems] = useState([]);     // Array\n   const [user, setUser] = useState({ name: 'Alice' }); // Object\n   ```\n\n4. **Updating State**:\n   ```jsx\n   // Simple value\n   setCount(5);           // Set to 5\n   setCount(count + 1);   // Increment\n   \n   // Using previous value (safer)\n   setCount(prevCount => prevCount + 1);\n   ```\n\n5. **Multiple State Variables**:\n   ```jsx\n   function Form() {\n     const [name, setName] = useState('');\n     const [email, setEmail] = useState('');\n     const [age, setAge] = useState(0);\n     \n     // Each is independent\n   }\n   ```\n\n6. **State with Objects** (must spread!):\n   ```jsx\n   const [user, setUser] = useState({ name: 'Alice', age: 25 });\n   \n   // WRONG!\n   user.age = 26;         // Don't mutate!\n   setUser(user);         // React won't detect change\n   \n   // CORRECT!\n   setUser({ ...user, age: 26 });  // Create new object\n   ```\n\n7. **State with Arrays**:\n   ```jsx\n   const [items, setItems] = useState([1, 2, 3]);\n   \n   // Add item\n   setItems([...items, 4]);\n   setItems([newItem, ...items]);  // Add to beginning\n   \n   // Remove item\n   setItems(items.filter((item, index) => index !== 0));\n   \n   // Update item\n   setItems(items.map((item, i) => i === 1 ? newValue : item));\n   ```\n\n8. **Lazy Initial State** (expensive calculation):\n   ```jsx\n   // WRONG! (runs every render)\n   const [data, setData] = useState(expensiveCalculation());\n   \n   // CORRECT! (runs once)\n   const [data, setData] = useState(() => expensiveCalculation());\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common useState mistakes:\n\n1. **Mutating state directly**:\n   ```jsx\n   // WRONG!\n   const [user, setUser] = useState({ name: 'Alice' });\n   user.name = 'Bob';     // Don't mutate!\n   setUser(user);         // React won't re-render\n   \n   // CORRECT!\n   setUser({ ...user, name: 'Bob' });  // New object\n   ```\n\n2. **Forgetting to use setter**:\n   ```jsx\n   const [count, setCount] = useState(0);\n   \n   // WRONG!\n   count = count + 1;     // Won't work!\n   \n   // CORRECT!\n   setCount(count + 1);   // Use setter\n   ```\n\n3. **Using state immediately after setting**:\n   ```jsx\n   const [count, setCount] = useState(0);\n   \n   function increment() {\n     setCount(count + 1);\n     console.log(count);    // Still 0! (state updates are async)\n   }\n   \n   // Use useEffect or callback to see new value:\n   setCount(prevCount => {\n     console.log('Will be:', prevCount + 1);\n     return prevCount + 1;\n   });\n   ```\n\n4. **Multiple setStates based on current state**:\n   ```jsx\n   // WRONG! (race condition)\n   setCount(count + 1);\n   setCount(count + 1);\n   setCount(count + 1);\n   // Count only increases by 1!\n   \n   // CORRECT!\n   setCount(c => c + 1);\n   setCount(c => c + 1);\n   setCount(c => c + 1);\n   // Count increases by 3!\n   ```\n\n5. **Mutating arrays**:\n   ```jsx\n   const [items, setItems] = useState([1, 2, 3]);\n   \n   // WRONG!\n   items.push(4);         // Mutates!\n   setItems(items);       // Won't re-render\n   \n   // CORRECT!\n   setItems([...items, 4]);  // New array\n   \n   // Other array operations:\n   setItems(items.filter(i => i !== 2));    // Remove\n   setItems(items.map(i => i === 2 ? 5 : i)); // Update\n   ```\n\n6. **Forgetting initial value**:\n   ```jsx\n   // WRONG!\n   const [count, setCount] = useState();  // undefined!\n   \n   // CORRECT!\n   const [count, setCount] = useState(0);  // Start at 0\n   ```\n\n7. **Using if/loops in component body with useState**:\n   ```jsx\n   // WRONG! (hooks must be at top level)\n   function MyComponent({ condition }) {\n     if (condition) {\n       const [state, setState] = useState(0);  // Error!\n     }\n   }\n   \n   // CORRECT!\n   function MyComponent({ condition }) {\n     const [state, setState] = useState(0);  // Always call\n     \n     if (condition) {\n       // Use state here\n     }\n   }\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.3-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a counter component with state:\n\n1. Create a `Counter` object with:\n   - state: { count: 0 }\n   - setCount(newValue) method that updates count and logs it\n   - increment() method that calls setCount with count + 1\n   - decrement() method that calls setCount with count - 1\n   - reset() method that calls setCount with 0\n\n2. Test all methods and log the count after each operation",
              "instructions": "Simulate a counter component with state:\n\n1. Create a `Counter` object with:\n   - state: { count: 0 }\n   - setCount(newValue) method that updates count and logs it\n   - increment() method that calls setCount with count + 1\n   - decrement() method that calls setCount with count - 1\n   - reset() method that calls setCount with 0\n\n2. Test all methods and log the count after each operation",
              "starterCode": "// Counter with state\n\nlet Counter = {\n  state: { count: 0 },\n  \n  setCount(newValue) {\n    this.state.count = newValue;\n    console.log('[State] count =', this.state.count);\n  },\n  \n  increment() {\n    this.setCount(this.state.count + 1);\n  },\n  \n  decrement() {\n    this.setCount(this.state.count - 1);\n  },\n  \n  reset() {\n    this.setCount(0);\n  },\n  \n  getCount() {\n    return this.state.count;\n  }\n};\n\n// Test\nconsole.log('Initial count:', Counter.getCount());\n\nCounter.increment();\nCounter.increment();\nCounter.increment();\nCounter.decrement();\nCounter.reset();\n\nconsole.log('Final count:', Counter.getCount());",
              "solution": "// Complete state management simulation\n\nlet Counter = {\n  state: { count: 0 },\n  listeners: [],\n  \n  setCount(newValue) {\n    let oldValue = this.state.count;\n    this.state.count = newValue;\n    console.log(`[State Update] count: ${oldValue} → ${newValue}`);\n    console.log('[React] Re-rendering component...');\n    this.notifyListeners();\n  },\n  \n  increment() {\n    console.log('[Action] Increment');\n    this.setCount(this.state.count + 1);\n  },\n  \n  decrement() {\n    console.log('[Action] Decrement');\n    this.setCount(this.state.count - 1);\n  },\n  \n  incrementBy(amount) {\n    console.log(`[Action] Increment by ${amount}`);\n    this.setCount(this.state.count + amount);\n  },\n  \n  reset() {\n    console.log('[Action] Reset');\n    this.setCount(0);\n  },\n  \n  getCount() {\n    return this.state.count;\n  },\n  \n  // Subscribe to changes\n  onChange(callback) {\n    this.listeners.push(callback);\n  },\n  \n  notifyListeners() {\n    this.listeners.forEach(fn => fn(this.state.count));\n  },\n  \n  render() {\n    console.log('\\n[Render] Counter UI:');\n    console.log(`┌─────────────────┐`);\n    console.log(`│  Count: ${String(this.state.count).padEnd(6)} │`);\n    console.log(`├─────────────────┤`);\n    console.log(`│  [ - ] [ + ]    │`);\n    console.log(`│  [ Reset ]      │`);\n    console.log(`└─────────────────┘\\n`);\n  }\n};\n\n// Advanced: TodoList with state\nlet TodoList = {\n  state: {\n    todos: [],\n    nextId: 1\n  },\n  \n  setTodos(newTodos) {\n    this.state.todos = newTodos;\n    console.log('[State] todos updated:', newTodos.length, 'items');\n  },\n  \n  addTodo(text) {\n    console.log(`[Action] Add todo: \"${text}\"`);\n    let newTodo = {\n      id: this.state.nextId++,\n      text: text,\n      completed: false\n    };\n    // Must create NEW array (don't mutate!)\n    this.setTodos([...this.state.todos, newTodo]);\n  },\n  \n  toggleTodo(id) {\n    console.log(`[Action] Toggle todo ${id}`);\n    this.setTodos(\n      this.state.todos.map(todo =>\n        todo.id === id\n          ? { ...todo, completed: !todo.completed }  // New object\n          : todo\n      )\n    );\n  },\n  \n  deleteTodo(id) {\n    console.log(`[Action] Delete todo ${id}`);\n    this.setTodos(\n      this.state.todos.filter(todo => todo.id !== id)\n    );\n  },\n  \n  render() {\n    console.log('\\n[Render] Todo List:');\n    if (this.state.todos.length === 0) {\n      console.log('  No todos yet!');\n    } else {\n      this.state.todos.forEach(todo => {\n        let checkbox = todo.completed ? '[✓]' : '[ ]';\n        let text = todo.completed ? `(${todo.text})` : todo.text;\n        console.log(`  ${checkbox} ${text}`);\n      });\n    }\n    console.log('');\n  }\n};\n\n// Run simulations\nconsole.log('=== Counter Simulation ===\\n');\n\nCounter.render();\n\nconsole.log('User clicks +1 three times:');\nCounter.increment();\nCounter.increment();\nCounter.increment();\nCounter.render();\n\nconsole.log('User clicks -1:');\nCounter.decrement();\nCounter.render();\n\nconsole.log('User clicks reset:');\nCounter.reset();\nCounter.render();\n\nconsole.log('\\n=== TodoList Simulation ===\\n');\n\nTodoList.render();\n\nTodoList.addTodo('Learn useState');\nTodoList.addTodo('Build a counter app');\nTodoList.addTodo('Master React');\nTodoList.render();\n\nconsole.log('User completes first todo:');\nTodoList.toggleTodo(1);\nTodoList.render();\n\nconsole.log('User deletes second todo:');\nTodoList.deleteTodo(2);\nTodoList.render();\n\nconsole.log('=== Key Takeaways ===\\n');\nlet takeaways = [\n  '✓ useState gives components memory',\n  '✓ State updates trigger re-renders',\n  '✓ Never mutate state directly',\n  '✓ Always create new objects/arrays',\n  '✓ Use setCount(prev => prev + 1) for updates based on previous',\n  '✓ Can have multiple state variables',\n  '✓ Each state is independent'\n];\ntakeaways.forEach(t => console.log(t));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should increment count",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should decrement count",
                  "expectedOutput": "4",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use this.state.count to access current count, and this.setCount() to update it"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common useState mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common useState mistakes:"
                },
                {
                  "mistake": "**Mutating state directly**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Mutating state directly**:\n   ```jsx\n   // WRONG!\n   const [user, setUser] = useState({ name: 'Alice' });\n   user.name = 'Bob';     // Don't mutate!\n   setUser(user);         // React won't re-render\n   \n   // CORRECT!\n   setUser({ ...user, name: 'Bob' });  // New object\n   ```"
                },
                {
                  "mistake": "**Forgetting to use setter**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting to use setter**:\n   ```jsx\n   const [count, setCount] = useState(0);\n   \n   // WRONG!\n   count = count + 1;     // Won't work!\n   \n   // CORRECT!\n   setCount(count + 1);   // Use setter\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "13.4",
          "title": "Event Handling - Responding to User Actions (The Doorbell Analogy)",
          "moduleId": "module-13",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine your house has a doorbell:\n\nPassive House (no doorbell):\n- Visitors knock\n- You don't hear them\n- Nothing happens\n- Frustrating for visitors!\n\nActive House (with doorbell):\n- Doorbell LISTENS for button press\n- Visitor presses button\n- Doorbell RESPONDS by ringing\n- You REACT by answering the door\n\nReact events work the same way:\n- Components LISTEN for events (onClick, onChange, etc.)\n- User performs action (click, type, submit)\n- Event handler RESPONDS\n- Component state updates → UI re-renders\n\nWithout event listeners → Your UI can't respond to users!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// React Event Handling\n\nconsole.log('=== Event Handling in React ===\\n');\n\n// CONCEPT: Event Listeners\nlet button = {\n  label: 'Click Me',\n  clickCount: 0,\n  \n  // Event handler function\n  handleClick: function() {\n    this.clickCount++;\n    console.log(`[Event] Button clicked! Total clicks: ${this.clickCount}`);\n  }\n};\n\n// Simulate user clicking button\nconsole.log('Button label:', button.label);\nconsole.log('\\nUser clicks button 3 times:\\n');\nbutton.handleClick();\nbutton.handleClick();\nbutton.handleClick();\n\n// COMMON EVENT TYPES\nconsole.log('\\n=== Common React Events ===\\n');\n\nlet events = {\n  'onClick': 'Button clicks, div clicks, any element click',\n  'onChange': 'Input field changes (text input, checkbox, select)',\n  'onSubmit': 'Form submission',\n  'onMouseEnter': 'Mouse cursor enters element',\n  'onMouseLeave': 'Mouse cursor leaves element',\n  'onKeyDown': 'Key pressed down',\n  'onKeyUp': 'Key released',\n  'onFocus': 'Element receives focus (clicked or tabbed to)',\n  'onBlur': 'Element loses focus'\n};\n\nfor (let [event, description] of Object.entries(events)) {\n  console.log(`${event.padEnd(15)} - ${description}`);\n}\n\n// REACT SYNTAX\nconsole.log('\\n\\n=== Event Handler Syntax ===\\n');\n\nconsole.log('// Method 1: Inline arrow function');\nconsole.log('<button onClick={() => console.log(\"Clicked!\")}>Click</button>\\n');\n\nconsole.log('// Method 2: Named function reference');\nconsole.log('function handleClick() {');\nconsole.log('  console.log(\"Clicked!\");');\nconsole.log('}');\nconsole.log('<button onClick={handleClick}>Click</button>\\n');\n\nconsole.log('// Method 3: With event object');\nconsole.log('function handleClick(event) {');\nconsole.log('  console.log(\"Button:\", event.target);');\nconsole.log('}');\nconsole.log('<button onClick={handleClick}>Click</button>\\n');\n\n// EVENT OBJECT\nconsole.log('=== The Event Object ===\\n');\n\nlet simulatedEvent = {\n  target: { tagName: 'BUTTON', textContent: 'Click Me', value: '' },\n  type: 'click',\n  preventDefault: function() {\n    console.log('[Event] Default action prevented');\n  },\n  stopPropagation: function() {\n    console.log('[Event] Event propagation stopped');\n  }\n};\n\nfunction handleEvent(event) {\n  console.log('Event type:', event.type);\n  console.log('Target element:', event.target.tagName);\n  console.log('Button text:', event.target.textContent);\n}\n\nconsole.log('Simulating click event:\\n');\nhandleEvent(simulatedEvent);\n\n// FORM HANDLING\nconsole.log('\\n\\n=== Form Event Handling ===\\n');\n\nlet form = {\n  state: { name: '', email: '' },\n  \n  handleNameChange: function(event) {\n    this.state.name = event.target.value;\n    console.log('[Input] Name:', this.state.name);\n  },\n  \n  handleEmailChange: function(event) {\n    this.state.email = event.target.value;\n    console.log('[Input] Email:', this.state.email);\n  },\n  \n  handleSubmit: function(event) {\n    event.preventDefault();\n    console.log('[Submit] Form data:', this.state);\n  }\n};\n\nconsole.log('User types in name field:');\nform.handleNameChange({ target: { value: 'Alice' } });\nform.handleNameChange({ target: { value: 'Alice J' } });\nform.handleNameChange({ target: { value: 'Alice Johnson' } });\n\nconsole.log('\\nUser types in email field:');\nform.handleEmailChange({ target: { value: 'alice@example.com' } });\n\nconsole.log('\\nUser submits form:');\nform.handleSubmit({ preventDefault: () => console.log('[Browser] Default submit prevented') });\n\n// REAL REACT EXAMPLE\nconsole.log('\\n\\n=== Complete React Example ===\\n');\n\nconsole.log('import { useState } from \"react\";\\n');\n\nconsole.log('function LoginForm() {');\nconsole.log('  const [email, setEmail] = useState(\"\");');\nconsole.log('  const [password, setPassword] = useState(\"\");\\n');\n\nconsole.log('  function handleSubmit(event) {');\nconsole.log('    event.preventDefault();  // Don\\'t reload page');\nconsole.log('    console.log(\"Login:\", email, password);');\nconsole.log('  }\\n');\n\nconsole.log('  return (');\nconsole.log('    <form onSubmit={handleSubmit}>');\nconsole.log('      <input');\nconsole.log('        type=\"email\"');\nconsole.log('        value={email}');\nconsole.log('        onChange={(e) => setEmail(e.target.value)}');\nconsole.log('      />');\nconsole.log('      <input');\nconsole.log('        type=\"password\"');\nconsole.log('        value={password}');\nconsole.log('        onChange={(e) => setPassword(e.target.value)}');\nconsole.log('      />');\nconsole.log('      <button type=\"submit\">Login</button>');\nconsole.log('    </form>');\nconsole.log('  );');\nconsole.log('}');\n\n// EVENT PATTERNS\nconsole.log('\\n\\n=== Common Event Patterns ===\\n');\n\nlet patterns = [\n  {    pattern: 'Button Click',\n    code: '<button onClick={handleClick}>Click</button>'\n  },\n  {\n    pattern: 'Input Change',\n    code: '<input onChange={(e) => setValue(e.target.value)} />'\n  },\n  {\n    pattern: 'Form Submit',\n    code: '<form onSubmit={handleSubmit}>...</form>'\n  },\n  {\n    pattern: 'Checkbox Toggle',\n    code: '<input type=\"checkbox\" onChange={(e) => setChecked(e.target.checked)} />'\n  },\n  {\n    pattern: 'Keyboard Event',\n    code: '<input onKeyDown={(e) => e.key === \"Enter\" && submit()} />'\n  },\n  {\n    pattern: 'Mouse Hover',\n    code: '<div onMouseEnter={handleEnter} onMouseLeave={handleLeave}>'\n  }\n];\n\npatterns.forEach(p => {\n  console.log(`${p.pattern}:`);\n  console.log(`  ${p.code}\\n`);\n});"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Event handling explained:\n\n1. **Basic onClick**:\n   ```jsx\n   function MyButton() {\n     function handleClick() {\n       console.log('Clicked!');\n     }\n     \n     return <button onClick={handleClick}>Click Me</button>;\n     //                      ^^^^^^^^^^^^\n     //                      Function REFERENCE (no parentheses!)\n   }\n   ```\n\n2. **Inline Arrow Function**:\n   ```jsx\n   <button onClick={() => console.log('Clicked!')}>Click</button>\n   \n   // With state update:\n   <button onClick={() => setCount(count + 1)}>+1</button>\n   ```\n\n3. **Event Object** (e or event):\n   ```jsx\n   function handleClick(event) {\n     console.log('Clicked element:', event.target);\n     console.log('Click position:', event.clientX, event.clientY);\n   }\n   \n   <button onClick={handleClick}>Click</button>\n   ```\n\n4. **Form Events** (onChange, onSubmit):\n   ```jsx\n   function Form() {\n     const [name, setName] = useState('');\n     \n     function handleSubmit(e) {\n       e.preventDefault();  // DON'T reload page!\n       console.log('Submitted:', name);\n     }\n     \n     return (\n       <form onSubmit={handleSubmit}>\n         <input\n           value={name}\n           onChange={(e) => setName(e.target.value)}\n           //                        ^^^^^^^^^^^^^\n           //                        Get input value\n         />\n         <button type=\"submit\">Submit</button>\n       </form>\n     );\n   }\n   ```\n\n5. **Passing Arguments** to event handlers:\n   ```jsx\n   // WRONG!\n   <button onClick={handleClick(id)}>  // Calls immediately!\n   \n   // CORRECT!\n   <button onClick={() => handleClick(id)}>  // Calls when clicked\n   <button onClick={handleClick.bind(null, id)}>  // Alternative\n   ```\n\n6. **Multiple Events**:\n   ```jsx\n   <div\n     onClick={handleClick}\n     onMouseEnter={handleEnter}\n     onMouseLeave={handleLeave}\n   >\n     Hover and click me!\n   </div>\n   ```\n\n7. **Controlled Inputs** (input value tied to state):\n   ```jsx\n   const [text, setText] = useState('');\n   \n   <input\n     value={text}              // Controlled by state\n     onChange={(e) => setText(e.target.value)}\n   />\n   ```\n\n8. **Checkbox Events**:\n   ```jsx\n   const [checked, setChecked] = useState(false);\n   \n   <input\n     type=\"checkbox\"\n     checked={checked}\n     onChange={(e) => setChecked(e.target.checked)}\n     //                            ^^^^^^^^^^^^^\n     //                            For checkboxes!\n   />\n   ```\n\n9. **Keyboard Events**:\n   ```jsx\n   function handleKeyDown(e) {\n     if (e.key === 'Enter') {\n       submit();\n     }\n     if (e.key === 'Escape') {\n       cancel();\n     }\n   }\n   \n   <input onKeyDown={handleKeyDown} />\n   ```\n\n10. **Prevent Default & Stop Propagation**:\n   ```jsx\n   function handleSubmit(e) {\n     e.preventDefault();     // Don't submit form\n     e.stopPropagation();    // Don't bubble up to parent\n     // Your code here\n   }\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common event handling mistakes:\n\n1. **Calling function immediately instead of passing reference**:\n   ```jsx\n   // WRONG! (calls immediately on render)\n   <button onClick={handleClick()}>Click</button>\n   \n   // CORRECT! (passes function reference)\n   <button onClick={handleClick}>Click</button>\n   \n   // Or use arrow function:\n   <button onClick={() => handleClick()}>Click</button>\n   ```\n\n2. **Forgetting e.preventDefault() on forms**:\n   ```jsx\n   function handleSubmit(e) {\n     // WRONG! (page reloads)\n     console.log('Submitted');\n     \n     // CORRECT!\n     e.preventDefault();  // Stop page reload\n     console.log('Submitted');\n   }\n   ```\n\n3. **Wrong event property for inputs**:\n   ```jsx\n   // Text input\n   <input onChange={(e) => setValue(e.target.value)} />\n   //                                   ^^^^^ value for text\n   \n   // Checkbox\n   <input type=\"checkbox\" onChange={(e) => setChecked(e.target.checked)} />\n   //                                                   ^^^^^^^ checked for checkbox\n   ```\n\n4. **Not binding 'this' in class components**:\n   ```jsx\n   // Old class component issue (not relevant for function components)\n   class MyComponent extends React.Component {\n     handleClick() {\n       this.setState(...);  // 'this' is undefined!\n     }\n     \n     // Fix 1: Bind in constructor\n     constructor() {\n       this.handleClick = this.handleClick.bind(this);\n     }\n     \n     // Fix 2: Arrow function\n     handleClick = () => {\n       this.setState(...);\n     }\n   }\n   ```\n\n5. **Trying to pass arguments incorrectly**:\n   ```jsx\n   // WRONG!\n   <button onClick={handleClick(id)}>  // Calls immediately!\n   \n   // CORRECT!\n   <button onClick={() => handleClick(id)}>Delete</button>\n   \n   // Or:\n   <button onClick={handleClick.bind(null, id)}>Delete</button>\n   ```\n\n6. **Uncontrolled vs controlled inputs confusion**:\n   ```jsx\n   // Uncontrolled (React doesn't control value)\n   <input defaultValue=\"Initial\" />\n   \n   // Controlled (React controls value via state)\n   const [text, setText] = useState('Initial');\n   <input\n     value={text}                          // Must have value\n     onChange={(e) => setText(e.target.value)}  // Must have onChange\n   />\n   ```\n\n7. **Multiple handlers without arrow functions**:\n   ```jsx\n   // WRONG! (both call immediately)\n   <div\n     onMouseEnter={handleEnter()}\n     onMouseLeave={handleLeave()}\n   >\n   \n   // CORRECT!\n   <div\n     onMouseEnter={handleEnter}\n     onMouseLeave={handleLeave}\n   >\n   \n   // Or with arguments:\n   <div\n     onMouseEnter={() => handleEnter(id)}\n     onMouseLeave={() => handleLeave(id)}\n   >\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.4-challenge",
              "title": "Practice Challenge",
              "description": "Create an interactive counter with event handling:\n\n1. Create a `CounterApp` object with:\n   - state: { count: 0, history: [] }\n   - handleIncrement() - increases count, adds to history\n   - handleDecrement() - decreases count, adds to history\n   - handleReset() - resets count to 0, clears history\n   - render() - displays current count and history\n\n2. Simulate user interactions and show the results",
              "instructions": "Create an interactive counter with event handling:\n\n1. Create a `CounterApp` object with:\n   - state: { count: 0, history: [] }\n   - handleIncrement() - increases count, adds to history\n   - handleDecrement() - decreases count, adds to history\n   - handleReset() - resets count to 0, clears history\n   - render() - displays current count and history\n\n2. Simulate user interactions and show the results",
              "starterCode": "// Interactive Counter App\n\nlet CounterApp = {\n  state: {\n    count: 0,\n    history: []\n  },\n  \n  handleIncrement() {\n    this.state.count++;\n    this.state.history.push('+1');\n    console.log('[Event] Increment → count:', this.state.count);\n  },\n  \n  handleDecrement() {\n    this.state.count--;\n    this.state.history.push('-1');\n    console.log('[Event] Decrement → count:', this.state.count);\n  },\n  \n  handleReset() {\n    this.state.count = 0;\n    this.state.history = [];\n    console.log('[Event] Reset → count:', this.state.count);\n  },\n  \n  render() {\n    console.log('\\n[Render]');\n    console.log('  Current Count:', this.state.count);\n    console.log('  History:', this.state.history.join(', ') || 'none');\n    console.log('');\n  }\n};\n\n// Simulate user interactions\nconsole.log('=== Counter App ===\\n');\n\nCounterApp.render();\n\nconsole.log('User clicks +1 button:');\nCounterApp.handleIncrement();\nCounterApp.render();\n\nconsole.log('User clicks +1 button again:');\nCounterApp.handleIncrement();\nCounterApp.render();\n\nconsole.log('User clicks -1 button:');\nCounterApp.handleDecrement();\nCounterApp.render();\n\nconsole.log('User clicks reset button:');\nCounterApp.handleReset();\nCounterApp.render();",
              "solution": "// Complete interactive app with event handling\n\nlet CounterApp = {\n  state: {\n    count: 0,\n    history: [],\n    lastAction: null\n  },\n  \n  handleIncrement() {\n    console.log('[Event] onClick={handleIncrement}');\n    this.state.count++;\n    this.state.history.push({ action: '+1', timestamp: Date.now() });\n    this.state.lastAction = 'increment';\n    this.render();\n  },\n  \n  handleDecrement() {\n    console.log('[Event] onClick={handleDecrement}');\n    this.state.count--;\n    this.state.history.push({ action: '-1', timestamp: Date.now() });\n    this.state.lastAction = 'decrement';\n    this.render();\n  },\n  \n  handleReset() {\n    console.log('[Event] onClick={handleReset}');\n    this.state.count = 0;\n    this.state.history = [];\n    this.state.lastAction = 'reset';\n    this.render();\n  },\n  \n  handleIncrementBy(amount) {\n    console.log(`[Event] onClick={() => handleIncrementBy(${amount})}`);\n    this.state.count += amount;\n    this.state.history.push({ action: `+${amount}`, timestamp: Date.now() });\n    this.render();\n  },\n  \n  render() {\n    console.log('\\n[React] Re-rendering component...');\n    console.log('┌────────────────────────────┐');\n    console.log(`│ Count: ${String(this.state.count).padEnd(19)} │`);\n    console.log('├────────────────────────────┤');\n    console.log('│ [ -1 ]  [ +1 ]  [ +5 ]     │');\n    console.log('│         [Reset]            │');\n    console.log('├────────────────────────────┤');\n    console.log(`│ Actions: ${String(this.state.history.length).padEnd(17)} │`);\n    if (this.state.history.length > 0) {\n      let recent = this.state.history.slice(-3).map(h => h.action).join(', ');\n      console.log(`│ Recent: ${recent.padEnd(18)} │`);\n    }\n    console.log('└────────────────────────────┘\\n');\n  }\n};\n\n// Form with event handling\nlet LoginForm = {\n  state: {\n    email: '',\n    password: '',\n    submitted: false,\n    errors: []\n  },\n  \n  handleEmailChange(event) {\n    console.log(`[Event] onChange={handleEmailChange}`);\n    this.state.email = event.target.value;\n    console.log(`  Email: \"${this.state.email}\"`);\n  },\n  \n  handlePasswordChange(event) {\n    console.log(`[Event] onChange={handlePasswordChange}`);\n    this.state.password = event.target.value;\n    console.log(`  Password: \"${'*'.repeat(this.state.password.length)}\"`);\n  },\n  \n  handleSubmit(event) {\n    console.log(`[Event] onSubmit={handleSubmit}`);\n    event.preventDefault();\n    \n    // Validation\n    this.state.errors = [];\n    if (!this.state.email.includes('@')) {\n      this.state.errors.push('Invalid email');\n    }\n    if (this.state.password.length < 6) {\n      this.state.errors.push('Password too short');\n    }\n    \n    if (this.state.errors.length === 0) {\n      this.state.submitted = true;\n      console.log('  ✓ Form valid! Logging in...');\n    } else {\n      console.log('  ✗ Form errors:', this.state.errors.join(', '));\n    }\n  },\n  \n  render() {\n    console.log('\\n[Render] Login Form');\n    console.log('  Email:', this.state.email || '(empty)');\n    console.log('  Password:', '*'.repeat(this.state.password.length) || '(empty)');\n    if (this.state.errors.length > 0) {\n      console.log('  Errors:', this.state.errors.join(', '));\n    }\n    if (this.state.submitted) {\n      console.log('  Status: ✓ Logged in!');\n    }\n    console.log('');\n  }\n};\n\n// Run simulations\nconsole.log('=== Counter App Simulation ===\\n');\n\nCounterApp.render();\n\nconsole.log('User clicks +1:');\nCounterApp.handleIncrement();\n\nconsole.log('User clicks +1 again:');\nCounterApp.handleIncrement();\n\nconsole.log('User clicks +5:');\nCounterApp.handleIncrementBy(5);\n\nconsole.log('User clicks -1:');\nCounterApp.handleDecrement();\n\nconsole.log('User clicks reset:');\nCounterApp.handleReset();\n\nconsole.log('\\n=== Login Form Simulation ===\\n');\n\nLoginForm.render();\n\nconsole.log('User types email:');\nLoginForm.handleEmailChange({ target: { value: 'a' } });\nLoginForm.handleEmailChange({ target: { value: 'al' } });\nLoginForm.handleEmailChange({ target: { value: 'alice@example.com' } });\nLoginForm.render();\n\nconsole.log('User types password:');\nLoginForm.handlePasswordChange({ target: { value: 'pass' } });\nLoginForm.render();\n\nconsole.log('User clicks submit (invalid):');\nLoginForm.handleSubmit({ preventDefault: () => {} });\nLoginForm.render();\n\nconsole.log('User fixes password:');\nLoginForm.handlePasswordChange({ target: { value: 'password123' } });\nLoginForm.render();\n\nconsole.log('User clicks submit (valid):');\nLoginForm.handleSubmit({ preventDefault: () => {} });\nLoginForm.render();\n\nconsole.log('=== Key Takeaways ===\\n');\nlet takeaways = [\n  '✓ Event handlers respond to user actions',\n  '✓ Use onClick, onChange, onSubmit, etc.',\n  '✓ Pass function reference, not call: onClick={handleClick}',\n  '✓ Access event with parameter: (e) => ...',\n  '✓ Use e.preventDefault() to prevent default behavior',\n  '✓ Controlled inputs: value={state} onChange={setState}',\n  '✓ Event updates state → state update triggers re-render'\n];\ntakeaways.forEach(t => console.log(t));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should handle increment",
                  "expectedOutput": "1",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should track history",
                  "expectedOutput": "1",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Update state in event handlers, then call render() to show changes"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common event handling mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common event handling mistakes:"
                },
                {
                  "mistake": "**Calling function immediately instead of passing reference**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Calling function immediately instead of passing reference**:\n   ```jsx\n   // WRONG! (calls immediately on render)\n   <button onClick={handleClick()}>Click</button>\n   \n   // CORRECT! (passes function reference)\n   <button onClick={handleClick}>Click</button>\n   \n   // Or use arrow function:\n   <button onClick={() => handleClick()}>Click</button>\n   ```"
                },
                {
                  "mistake": "**Forgetting e.preventDefault() on forms**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting e.preventDefault() on forms**:\n   ```jsx\n   function handleSubmit(e) {\n     // WRONG! (page reloads)\n     console.log('Submitted');\n     \n     // CORRECT!\n     e.preventDefault();  // Stop page reload\n     console.log('Submitted');\n   }\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "13.5",
          "title": "Conditional Rendering - Showing Different UI Based on State (The Traffic Light Analogy)",
          "moduleId": "module-13",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Think of a traffic light at an intersection:\n\nStatic Display (no conditions):\n- Always shows green light\n- Never changes\n- Dangerous! Cars and pedestrians confused\n\nConditional Display (based on state):\n- If state = 'stop' → Show RED light\n- If state = 'caution' → Show YELLOW light\n- If state = 'go' → Show GREEN light\n- Changes based on current condition\n\nReact conditional rendering works the same:\n- Different UI based on state/props\n- Show login button if NOT logged in\n- Show profile if logged in\n- Show loading spinner while fetching\n- Show error message if failed\n\nOne component, many possible displays!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Conditional Rendering in React\n\nconsole.log('=== Conditional Rendering ===\\n');\n\n// METHOD 1: if/else (outside JSX)\nfunction renderGreeting(isLoggedIn) {\n  if (isLoggedIn) {\n    return '<h1>Welcome back!</h1>';\n  } else {\n    return '<h1>Please log in.</h1>';\n  }\n}\n\nconsole.log('User logged in:');\nconsole.log(renderGreeting(true));\nconsole.log('\\nUser NOT logged in:');\nconsole.log(renderGreeting(false));\n\n// METHOD 2: Ternary operator (? :)\nfunction renderStatus(isOnline) {\n  return `<p>Status: ${isOnline ? 'Online' : 'Offline'}</p>`;\n}\n\nconsole.log('\\nTernary operator:');\nconsole.log(renderStatus(true));\nconsole.log(renderStatus(false));\n\n// METHOD 3: Logical AND (&&)\nfunction renderNotifications(hasNotifications, count) {\n  return `\n    <div>\n      <h2>Dashboard</h2>\n      ${hasNotifications && `<p>You have ${count} new notifications!</p>` || ''}\n    </div>\n  `;\n}\n\nconsole.log('\\nLogical AND (&&):');\nconsole.log(renderNotifications(true, 5));\nconsole.log(renderNotifications(false, 0));\n\n// REAL-WORLD EXAMPLE: Login/Logout Button\nlet app = {\n  state: { isLoggedIn: false, username: null },\n  \n  render() {\n    console.log('\\n[Render] App UI:\\n');\n    \n    if (this.state.isLoggedIn) {\n      console.log(`Welcome, ${this.state.username}!`);\n      console.log('[Logout Button]');\n    } else {\n      console.log('Welcome, Guest!');\n      console.log('[Login Button]');\n    }\n  },\n  \n  login(username) {\n    this.state.isLoggedIn = true;\n    this.state.username = username;\n    this.render();\n  },\n  \n  logout() {\n    this.state.isLoggedIn = false;\n    this.state.username = null;\n    this.render();\n  }\n};\n\nconsole.log('\\n=== Login/Logout Example ===');\napp.render();\n\nconsole.log('\\nUser clicks login:');\napp.login('Alice');\n\nconsole.log('\\nUser clicks logout:');\napp.logout();\n\n// LOADING STATES\nlet dataFetcher = {\n  state: { loading: true, data: null, error: null },\n  \n  render() {\n    console.log('\\n[Render] Data View:\\n');\n    \n    if (this.state.loading) {\n      console.log('⏳ Loading...');\n    } else if (this.state.error) {\n      console.log(`❌ Error: ${this.state.error}`);\n    } else if (this.state.data) {\n      console.log('✓ Data:', this.state.data);\n    } else {\n      console.log('No data yet.');\n    }\n  },\n  \n  async simulateFetch(shouldFail = false) {\n    this.state.loading = true;\n    this.state.error = null;\n    this.state.data = null;\n    this.render();\n    \n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    if (shouldFail) {\n      this.state.loading = false;\n      this.state.error = 'Network error';\n    } else {\n      this.state.loading = false;\n      this.state.data = { users: ['Alice', 'Bob', 'Charlie'] };\n    }\n    this.render();\n  }\n};\n\nconsole.log('\\n=== Loading State Example ===');\nsetTimeout(async () => {\n  dataFetcher.render();\n  \n  console.log('\\nFetching data (success):');\n  await dataFetcher.simulateFetch(false);\n  \n  console.log('\\nFetching data (failure):');\n  await dataFetcher.simulateFetch(true);\n}, 100);\n\n// CONDITIONAL CSS CLASSES\nsetTimeout(() => {\n  console.log('\\n\\n=== Conditional Styling ===\\n');\n  \n  function renderButton(isActive) {\n    let className = isActive ? 'btn-active' : 'btn-inactive';\n    let text = isActive ? 'Active' : 'Inactive';\n    return `<button class=\"${className}\">${text}</button>`;\n  }\n  \n  console.log('Active button:');\n  console.log(renderButton(true));\n  console.log('\\nInactive button:');\n  console.log(renderButton(false));\n  \n  // Multiple conditions\n  function renderAlert(type, message) {\n    let className = type === 'success' ? 'alert-success' :\n                    type === 'error' ? 'alert-error' :\n                    type === 'warning' ? 'alert-warning' :\n                    'alert-info';\n    \n    let icon = type === 'success' ? '✓' :\n               type === 'error' ? '✗' :\n               type === 'warning' ? '⚠' :\n               'ℹ';\n    \n    return `<div class=\"${className}\">${icon} ${message}</div>`;\n  }\n  \n  console.log('\\nConditional alerts:');\n  console.log(renderAlert('success', 'Saved successfully!'));\n  console.log(renderAlert('error', 'Failed to save!'));\n  console.log(renderAlert('warning', 'Are you sure?'));\n  console.log(renderAlert('info', 'New update available'));\n}, 1200);\n\n// LIST RENDERING WITH CONDITIONS\nsetTimeout(() => {\n  console.log('\\n\\n=== Conditional List Rendering ===\\n');\n  \n  let todos = [\n    { id: 1, text: 'Learn React', completed: true },\n    { id: 2, text: 'Build app', completed: false },\n    { id: 3, text: 'Deploy', completed: false }\n  ];\n  \n  console.log('All todos:');\n  todos.forEach(todo => {\n    let checkbox = todo.completed ? '[✓]' : '[ ]';\n    let style = todo.completed ? '(completed)' : '';\n    console.log(`${checkbox} ${todo.text} ${style}`);\n  });\n  \n  console.log('\\nCompleted only:');\n  todos.filter(todo => todo.completed).forEach(todo => {\n    console.log(`[✓] ${todo.text}`);\n  });\n  \n  console.log('\\nIncomplete only:');\n  todos.filter(todo => !todo.completed).forEach(todo => {\n    console.log(`[ ] ${todo.text}`);\n  });\n}, 1300);\n\n// REACT SYNTAX PATTERNS\nsetTimeout(() => {\n  console.log('\\n\\n=== React Conditional Rendering Patterns ===\\n');\n  \n  console.log('// Pattern 1: Ternary operator');\n  console.log('{isLoggedIn ? <Dashboard /> : <Login />}\\n');\n  \n  console.log('// Pattern 2: Logical AND (show/hide)');\n  console.log('{hasError && <ErrorMessage />}');\n  console.log('{count > 0 && <p>You have {count} items</p>}\\n');\n  \n  console.log('// Pattern 3: If/else (before return)');\n  console.log('if (loading) return <Spinner />;');\n  console.log('if (error) return <Error message={error} />;');\n  console.log('return <Data data={data} />;\\n');\n  \n  console.log('// Pattern 4: Switch for multiple conditions');\n  console.log('switch(status) {');\n  console.log('  case \"loading\": return <Spinner />;');\n  console.log('  case \"error\": return <Error />;');\n  console.log('  case \"success\": return <Data />;');\n  console.log('  default: return null;');\n  console.log('}\\n');\n  \n  console.log('// Pattern 5: Null for hiding');\n  console.log('{!shouldShow && null}  // Renders nothing');\n  console.log('{shouldShow ? <Component /> : null}');\n}, 1400);"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Conditional rendering patterns:\n\n1. **Ternary Operator** (? :):\n   ```jsx\n   function Greeting({ isLoggedIn }) {\n     return (\n       <div>\n         {isLoggedIn ? (\n           <h1>Welcome back!</h1>\n         ) : (\n           <h1>Please log in</h1>\n         )}\n       </div>\n     );\n   }\n   ```\n\n2. **Logical AND** (&&):\n   ```jsx\n   function Notifications({ count }) {\n     return (\n       <div>\n         <h2>Dashboard</h2>\n         {count > 0 && <p>You have {count} notifications</p>}\n       </div>\n     );\n   }\n   // Shows paragraph ONLY if count > 0\n   ```\n\n3. **Early Return**:\n   ```jsx\n   function UserProfile({ user }) {\n     if (!user) {\n       return <p>Loading...</p>;\n     }\n     \n     if (user.error) {\n       return <p>Error: {user.error}</p>;\n     }\n     \n     return (\n       <div>\n         <h1>{user.name}</h1>\n         <p>{user.email}</p>\n       </div>\n     );\n   }\n   ```\n\n4. **Variable Assignment**:\n   ```jsx\n   function Dashboard({ isLoggedIn }) {\n     let content;\n     \n     if (isLoggedIn) {\n       content = <UserDashboard />;\n     } else {\n       content = <LoginPrompt />;\n     }\n     \n     return <div>{content}</div>;\n   }\n   ```\n\n5. **Null for Hiding**:\n   ```jsx\n   function Alert({ message, show }) {\n     if (!show) return null;  // Render nothing\n     \n     return <div className=\"alert\">{message}</div>;\n   }\n   ```\n\n6. **Conditional CSS Classes**:\n   ```jsx\n   function Button({ isActive }) {\n     return (\n       <button className={isActive ? 'btn-active' : 'btn-inactive'}>\n         {isActive ? 'Active' : 'Inactive'}\n       </button>\n     );\n   }\n   ```\n\n7. **Multiple Conditions (Switch)**:\n   ```jsx\n   function StatusDisplay({ status }) {\n     switch(status) {\n       case 'loading':\n         return <Spinner />;\n       case 'error':\n         return <ErrorMessage />;\n       case 'success':\n         return <SuccessMessage />;\n       default:\n         return null;\n     }\n   }\n   ```\n\n8. **Conditional Props**:\n   ```jsx\n   <button\n     className={isActive ? 'active' : 'inactive'}\n     disabled={isLoading}\n     style={{ color: hasError ? 'red' : 'black' }}\n   >\n     {isLoading ? 'Loading...' : 'Submit'}\n   </button>\n   ```\n\n9. **List Filtering**:\n   ```jsx\n   function TodoList({ todos, filter }) {\n     const filteredTodos = filter === 'completed'\n       ? todos.filter(t => t.completed)\n       : filter === 'active'\n       ? todos.filter(t => !t.completed)\n       : todos;\n     \n     return (\n       <ul>\n         {filteredTodos.map(todo => <li key={todo.id}>{todo.text}</li>)}\n       </ul>\n     );\n   }\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common conditional rendering mistakes:\n\n1. **Using if statement inside JSX**:\n   ```jsx\n   // WRONG! Can't use if in JSX\n   return (\n     <div>\n       {if (isLoggedIn) { <p>Welcome</p> }}  // Syntax error!\n     </div>\n   );\n   \n   // CORRECT! Use ternary\n   return (\n     <div>\n       {isLoggedIn ? <p>Welcome</p> : <p>Login</p>}\n     </div>\n   );\n   \n   // Or if/else before return:\n   if (isLoggedIn) {\n     return <div><p>Welcome</p></div>;\n   }\n   return <div><p>Login</p></div>;\n   ```\n\n2. **Wrong use of && operator**:\n   ```jsx\n   // WRONG! Renders \"0\" when count is 0\n   {count && <p>You have {count} items</p>}\n   \n   // CORRECT! Use explicit boolean\n   {count > 0 && <p>You have {count} items</p>}\n   ```\n\n3. **Forgetting the else in ternary**:\n   ```jsx\n   // WRONG!\n   {isLoggedIn ? <Dashboard /> }  // Syntax error!\n   \n   // CORRECT!\n   {isLoggedIn ? <Dashboard /> : null}\n   {isLoggedIn ? <Dashboard /> : <Login />}\n   \n   // Or use &&:\n   {isLoggedIn && <Dashboard />}\n   ```\n\n4. **Nested ternaries (hard to read)**:\n   ```jsx\n   // WRONG! (too complex)\n   {isLoading ? <Spinner /> : hasError ? <Error /> : hasData ? <Data /> : <Empty />}\n   \n   // BETTER! Use if/else before return\n   if (isLoading) return <Spinner />;\n   if (hasError) return <Error />;\n   if (hasData) return <Data />;\n   return <Empty />;\n   ```\n\n5. **Rendering undefined or false**:\n   ```jsx\n   // WRONG! Renders \"false\" or \"undefined\" as text\n   <div>{isLoggedIn}</div>  // Renders \"true\" or \"false\"\n   <div>{userData}</div>    // Might render \"undefined\"\n   \n   // CORRECT!\n   <div>{isLoggedIn ? 'Yes' : 'No'}</div>\n   <div>{userData?.name || 'N/A'}</div>\n   ```\n\n6. **String conditions** (always truthy!):\n   ```jsx\n   // WRONG! String \"false\" is truthy!\n   const showBanner = \"false\";  // String, not boolean\n   {showBanner && <Banner />}   // Always shows!\n   \n   // CORRECT!\n   const showBanner = false;    // Boolean\n   {showBanner && <Banner />}   // Works correctly\n   ```\n\n7. **Not handling all states** (loading, error, data):\n   ```jsx\n   // WRONG! Missing loading and error states\n   function UserProfile({ user }) {\n     return <div>{user.name}</div>;  // Crashes if user is null!\n   }\n   \n   // CORRECT!\n   function UserProfile({ user, loading, error }) {\n     if (loading) return <Spinner />;\n     if (error) return <Error message={error} />;\n     if (!user) return <p>No user found</p>;\n     return <div>{user.name}</div>;\n   }\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.5-challenge",
              "title": "Practice Challenge",
              "description": "Create a user authentication UI with conditional rendering:\n\n1. Create an `AuthApp` object with:\n   - state: { isLoggedIn: false, user: null, loading: false }\n   - login(username) method\n   - logout() method\n   - render() method that shows different UI based on state\n\n2. Show:\n   - Loading message when loading = true\n   - Login button when not logged in\n   - Welcome message + Logout button when logged in\n\n3. Test all states",
              "instructions": "Create a user authentication UI with conditional rendering:\n\n1. Create an `AuthApp` object with:\n   - state: { isLoggedIn: false, user: null, loading: false }\n   - login(username) method\n   - logout() method\n   - render() method that shows different UI based on state\n\n2. Show:\n   - Loading message when loading = true\n   - Login button when not logged in\n   - Welcome message + Logout button when logged in\n\n3. Test all states",
              "starterCode": "// Authentication App with Conditional Rendering\n\nlet AuthApp = {\n  state: {\n    isLoggedIn: false,\n    user: null,\n    loading: false\n  },\n  \n  render() {\n    console.log('\\n[Render] Auth UI:');\n    console.log('─'.repeat(40));\n    \n    if (this.state.loading) {\n      console.log('⏳ Loading...');\n    } else if (this.state.isLoggedIn) {\n      console.log(`Welcome, ${this.state.user}!`);\n      console.log('[Logout Button]');\n    } else {\n      console.log('Please log in to continue');\n      console.log('[Login Button]');\n    }\n    \n    console.log('─'.repeat(40) + '\\n');\n  },\n  \n  async login(username) {\n    console.log(`[Action] Login as ${username}`);\n    this.state.loading = true;\n    this.render();\n    \n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    this.state.loading = false;\n    this.state.isLoggedIn = true;\n    this.state.user = username;\n    this.render();\n  },\n  \n  logout() {\n    console.log('[Action] Logout');\n    this.state.isLoggedIn = false;\n    this.state.user = null;\n    this.render();\n  }\n};\n\n// Test all states\nasync function testAuthApp() {\n  console.log('=== Auth App Test ===');\n  \n  AuthApp.render();\n  \n  await AuthApp.login('Alice');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  AuthApp.logout();\n}\n\ntestAuthApp();",
              "solution": "// Complete solution with all conditional rendering patterns\n\nlet AuthApp = {\n  state: {\n    isLoggedIn: false,\n    user: null,\n    loading: false,\n    error: null\n  },\n  \n  render() {\n    console.log('\\n┌────────────────────────────────────────┐');\n    console.log('│          Authentication App            │');\n    console.log('├────────────────────────────────────────┤');\n    \n    // Loading state\n    if (this.state.loading) {\n      console.log('│  ⏳ Loading...                         │');\n      console.log('└────────────────────────────────────────┘\\n');\n      return;\n    }\n    \n    // Error state\n    if (this.state.error) {\n      console.log(`│  ❌ Error: ${this.state.error.padEnd(25)} │`);\n      console.log('│  [Try Again]                           │');\n      console.log('└────────────────────────────────────────┘\\n');\n      return;\n    }\n    \n    // Logged in state\n    if (this.state.isLoggedIn) {\n      console.log(`│  Welcome, ${this.state.user}! ${' '.repeat(26 - this.state.user.length)} │`);\n      console.log('│  ─────────────────────────────────────│');\n      console.log('│  Dashboard                             │');\n      console.log('│  Profile                               │');\n      console.log('│  Settings                              │');\n      console.log('│  ─────────────────────────────────────│');\n      console.log('│  [Logout]                              │');\n    } else {\n      // Logged out state\n      console.log('│  Please log in to continue            │');\n      console.log('│  ─────────────────────────────────────│');\n      console.log('│  [Login]                               │');\n      console.log('│  [Sign Up]                             │');\n    }\n    \n    console.log('└────────────────────────────────────────┘\\n');\n  },\n  \n  async login(username, password) {\n    console.log(`[Action] Login as \"${username}\"`);\n    this.state.loading = true;\n    this.state.error = null;\n    this.render();\n    \n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 800));\n    \n    // Simulate authentication\n    if (password === 'wrong') {\n      this.state.loading = false;\n      this.state.error = 'Invalid credentials';\n      this.render();\n      return;\n    }\n    \n    this.state.loading = false;\n    this.state.isLoggedIn = true;\n    this.state.user = username;\n    this.render();\n  },\n  \n  logout() {\n    console.log('[Action] Logout');\n    this.state.isLoggedIn = false;\n    this.state.user = null;\n    this.state.error = null;\n    this.render();\n  }\n};\n\n// Todo List with conditional rendering\nlet TodoApp = {\n  state: {\n    todos: [\n      { id: 1, text: 'Learn conditional rendering', completed: true },\n      { id: 2, text: 'Build a todo app', completed: false },\n      { id: 3, text: 'Master React', completed: false }\n    ],\n    filter: 'all'  // 'all', 'active', 'completed'\n  },\n  \n  render() {\n    console.log('\\n┌────────────────────────────────────────┐');\n    console.log('│             Todo List                  │');\n    console.log('├────────────────────────────────────────┤');\n    \n    // Filter todos based on current filter\n    let filteredTodos;\n    if (this.state.filter === 'completed') {\n      filteredTodos = this.state.todos.filter(t => t.completed);\n    } else if (this.state.filter === 'active') {\n      filteredTodos = this.state.todos.filter(t => !t.completed);\n    } else {\n      filteredTodos = this.state.todos;\n    }\n    \n    // Empty state\n    if (filteredTodos.length === 0) {\n      console.log('│  No todos to show                      │');\n    } else {\n      filteredTodos.forEach(todo => {\n        let checkbox = todo.completed ? '[✓]' : '[ ]';\n        let text = todo.completed ? `${todo.text} (done)` : todo.text;\n        let line = `│  ${checkbox} ${text}`.padEnd(41) + '│';\n        console.log(line);\n      });\n    }\n    \n    console.log('├────────────────────────────────────────┤');\n    \n    // Filter buttons with active state\n    let allActive = this.state.filter === 'all' ? '*' : ' ';\n    let activeActive = this.state.filter === 'active' ? '*' : ' ';\n    let completedActive = this.state.filter === 'completed' ? '*' : ' ';\n    \n    console.log(`│  [${allActive}]All [${activeActive}]Active [${completedActive}]Completed      │`);\n    console.log('└────────────────────────────────────────┘\\n');\n  },\n  \n  setFilter(filter) {\n    console.log(`[Action] Set filter: ${filter}`);\n    this.state.filter = filter;\n    this.render();\n  }\n};\n\n// Run demonstrations\nasync function runDemo() {\n  console.log('=== Authentication Demo ===\\n');\n  \n  AuthApp.render();\n  \n  console.log('User attempts login with wrong password:');\n  await AuthApp.login('Alice', 'wrong');\n  \n  await new Promise(resolve => setTimeout(resolve, 1000));\n  \n  console.log('User attempts login with correct password:');\n  await AuthApp.login('Alice', 'correct');\n  \n  await new Promise(resolve => setTimeout(resolve, 1000));\n  \n  console.log('User logs out:');\n  AuthApp.logout();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  console.log('\\n=== Todo List Demo ===\\n');\n  \n  TodoApp.render();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  console.log('Show only active todos:');\n  TodoApp.setFilter('active');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  console.log('Show only completed todos:');\n  TodoApp.setFilter('completed');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  console.log('Show all todos:');\n  TodoApp.setFilter('all');\n}\n\nrunDemo();",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should show different UI when logged in",
                  "expectedOutput": "Welcome",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should show login when logged out",
                  "expectedOutput": "Login",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use if/else in render() to show different UI based on state"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common conditional rendering mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common conditional rendering mistakes:"
                },
                {
                  "mistake": "**Using if statement inside JSX**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Using if statement inside JSX**:\n   ```jsx\n   // WRONG! Can't use if in JSX\n   return (\n     <div>\n       {if (isLoggedIn) { <p>Welcome</p> }}  // Syntax error!\n     </div>\n   );\n   \n   // CORRECT! Use ternary\n   return (\n     <div>\n       {isLoggedIn ? <p>Welcome</p> : <p>Login</p>}\n     </div>\n   );\n   \n   // Or if/else before return:\n   if (isLoggedIn) {\n     return <div><p>Welcome</p></div>;\n   }\n   return <div><p>Login</p></div>;\n   ```"
                },
                {
                  "mistake": "**Wrong use of && operator**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong use of && operator**:\n   ```jsx\n   // WRONG! Renders \"0\" when count is 0\n   {count && <p>You have {count} items</p>}\n   \n   // CORRECT! Use explicit boolean\n   {count > 0 && <p>You have {count} items</p>}\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "13.6",
          "title": "useEffect Hook - Side Effects & Component Lifecycle (The Security Guard Analogy)",
          "moduleId": "module-13",
          "order": 6,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a security guard at a building entrance:\n\nWithout security guard:\n- People come and go\n- No one tracks entrances/exits\n- No one locks doors at night\n- No cleanup when building closes\n\nWith security guard (useEffect):\n- WHEN people arrive (component mounts) → Check them in\n- WHEN visitor badge expires (dependency changes) → Issue new badge\n- WHEN building closes (component unmounts) → Lock doors, cleanup\n- Guard watches specific things (dependencies)\n- Guard performs actions automatically\n\nReact useEffect is your component's security guard:\n- Runs code AFTER render (side effects)\n- Runs when component mounts\n- Runs when specific values change\n- Cleanup when component unmounts\n- Perfect for: API calls, timers, subscriptions, document title changes!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// useEffect Hook - Side Effects\n\nconsole.log('=== useEffect Hook ===\\n');\n\n// SIDE EFFECT = Code that affects something outside the component\n// Examples: API calls, timers, DOM manipulation, subscriptions\n\n// Simulating component lifecycle\nclass Component {\n  constructor(name) {\n    this.name = name;\n    this.effects = [];\n    this.mounted = false;\n  }\n  \n  useEffect(effect, dependencies) {\n    this.effects.push({ effect, dependencies });\n  }\n  \n  mount() {\n    console.log(`[${this.name}] Mounting...`);\n    this.mounted = true;\n    \n    // Run all effects\n    this.effects.forEach(({ effect, dependencies }) => {\n      console.log(`[${this.name}] Running effect (dependencies: ${dependencies || 'none'})`);\n      let cleanup = effect();\n      if (cleanup) {\n        console.log(`[${this.name}] Effect registered cleanup function`);\n      }\n    });\n  }\n  \n  unmount() {\n    console.log(`\\n[${this.name}] Unmounting...`);\n    console.log(`[${this.name}] Running cleanup functions`);\n    this.mounted = false;\n  }\n}\n\n// Example 1: Effect runs once on mount\nlet TitleComponent = new Component('TitleComponent');\n\nTitleComponent.useEffect(() => {\n  console.log('  Setting document title to: \"My React App\"');\n  // In real React: document.title = 'My React App';\n}, []); // Empty array = run once on mount\n\nTitleComponent.mount();\n\n// Example 2: Effect with cleanup\nconsole.log('\\n--- Timer Component ---');\nlet TimerComponent = new Component('TimerComponent');\n\nTimerComponent.useEffect(() => {\n  console.log('  Starting timer (setInterval)');\n  let intervalId = 123;\n  \n  // Cleanup function (returned)\n  return () => {\n    console.log('  Stopping timer (clearInterval)');\n  };\n}, []);\n\nTimerComponent.mount();\nsetTimeout(() => TimerComponent.unmount(), 1000);\n\n// Example 3: Effect runs when dependency changes\nsetTimeout(() => {\n  console.log('\\n--- User Profile Component ---');\n  \n  let ProfileComponent = new Component('ProfileComponent');\n  let userId = 1;\n  \n  ProfileComponent.useEffect(() => {\n    console.log(`  Fetching data for user ${userId}...`);\n    console.log(`  fetch('/api/users/${userId}')`);\n  }, [userId]); // Re-run when userId changes\n  \n  ProfileComponent.mount();\n  \n  // Simulate prop change\n  setTimeout(() => {\n    console.log('\\n[Props Changed] userId: 1 → 2');\n    userId = 2;\n    console.log('[ProfileComponent] Re-running effects with new userId');\n    console.log(`  Fetching data for user ${userId}...`);\n  }, 500);\n}, 1500);\n\n// DEPENDENCY ARRAY PATTERNS\nsetTimeout(() => {\n  console.log('\\n\\n=== useEffect Dependency Patterns ===\\n');\n  \n  let patterns = [\n    {\n      code: 'useEffect(() => { ... });',\n      deps: 'NO array',\n      runs: 'Every render (usually a mistake!)'\n    },\n    {\n      code: 'useEffect(() => { ... }, []);',\n      deps: 'Empty []',\n      runs: 'Once on mount only'\n    },\n    {\n      code: 'useEffect(() => { ... }, [count]);',\n      deps: '[count]',\n      runs: 'On mount + when count changes'\n    },\n    {\n      code: 'useEffect(() => { ... }, [a, b, c]);',\n      deps: '[a, b, c]',\n      runs: 'On mount + when a, b, OR c changes'\n    }\n  ];\n  \n  patterns.forEach(p => {\n    console.log(`${p.code}`);\n    console.log(`  Dependencies: ${p.deps}`);\n    console.log(`  Runs: ${p.runs}\\n`);\n  });\n}, 2500);\n\n// COMMON USE CASES\nsetTimeout(() => {\n  console.log('=== Common useEffect Use Cases ===\\n');\n  \n  console.log('1. FETCHING DATA:');\n  console.log('useEffect(() => {');\n  console.log('  fetch(\"/api/users\")');\n  console.log('    .then(res => res.json())');\n  console.log('    .then(data => setUsers(data));');\n  console.log('}, []); // Fetch once on mount\\n');\n  \n  console.log('2. SETTING DOCUMENT TITLE:');\n  console.log('useEffect(() => {');\n  console.log('  document.title = `Count: ${count}`;');\n  console.log('}, [count]); // Update when count changes\\n');\n  \n  console.log('3. SUBSCRIBING TO EVENTS:');\n  console.log('useEffect(() => {');\n  console.log('  function handleResize() {');\n  console.log('    setWidth(window.innerWidth);');\n  console.log('  }');\n  console.log('  ');\n  console.log('  window.addEventListener(\"resize\", handleResize);');\n  console.log('  ');\n  console.log('  return () => {  // Cleanup!');\n  console.log('    window.removeEventListener(\"resize\", handleResize);');\n  console.log('  };');\n  console.log('}, []); // Set up once\\n');\n  \n  console.log('4. TIMERS:');\n  console.log('useEffect(() => {');\n  console.log('  const timer = setInterval(() => {');\n  console.log('    setCount(c => c + 1);');\n  console.log('  }, 1000);');\n  console.log('  ');\n  console.log('  return () => clearInterval(timer); // Cleanup!');\n  console.log('}, []); // Start timer once\\n');\n  \n  console.log('5. LOCAL STORAGE:');\n  console.log('useEffect(() => {');\n  console.log('  localStorage.setItem(\"theme\", theme);');\n  console.log('}, [theme]); // Save when theme changes');\n}, 2600);"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "useEffect Hook explained:\n\n1. **Basic useEffect** (runs after every render):\n   ```jsx\n   import { useEffect } from 'react';\n   \n   function MyComponent() {\n     useEffect(() => {\n       console.log('Component rendered!');\n     });\n     // NO dependency array = runs after EVERY render\n   }\n   ```\n\n2. **Run once on mount** (empty dependency array):\n   ```jsx\n   useEffect(() => {\n     console.log('Component mounted!');\n   }, []);  // Empty array = run ONCE on mount\n   ```\n\n3. **Run when specific values change**:\n   ```jsx\n   useEffect(() => {\n     console.log('Count changed:', count);\n   }, [count]);  // Runs when count changes\n   ```\n\n4. **Cleanup function** (returned from effect):\n   ```jsx\n   useEffect(() => {\n     // Setup\n     const timer = setInterval(() => {\n       console.log('Tick');\n     }, 1000);\n     \n     // Cleanup (runs before next effect OR on unmount)\n     return () => {\n       clearInterval(timer);\n       console.log('Timer cleaned up');\n     };\n   }, []);\n   ```\n\n5. **Fetching data**:\n   ```jsx\n   useEffect(() => {\n     async function fetchData() {\n       const res = await fetch('/api/users');\n       const data = await res.json();\n       setUsers(data);\n     }\n     \n     fetchData();\n   }, []);  // Fetch once on mount\n   ```\n\n6. **Multiple dependencies**:\n   ```jsx\n   useEffect(() => {\n     // Runs when userId OR filter changes\n     fetchUserPosts(userId, filter);\n   }, [userId, filter]);\n   ```\n\n7. **Event listeners**:\n   ```jsx\n   useEffect(() => {\n     function handleScroll() {\n       setScrollY(window.scrollY);\n     }\n     \n     window.addEventListener('scroll', handleScroll);\n     \n     return () => {\n       window.removeEventListener('scroll', handleScroll);\n     };\n   }, []);\n   ```\n\n8. **Local Storage**:\n   ```jsx\n   useEffect(() => {\n     localStorage.setItem('user', JSON.stringify(user));\n   }, [user]);  // Save when user changes\n   ```\n\n9. **Document Title**:\n   ```jsx\n   useEffect(() => {\n     document.title = `Messages (${unreadCount})`;\n   }, [unreadCount]);\n   ```\n\n10. **Conditional Effect**:\n   ```jsx\n   useEffect(() => {\n     if (isLoggedIn) {\n       // Only run if logged in\n       connectToChat();\n       \n       return () => disconnectFromChat();\n     }\n   }, [isLoggedIn]);\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common useEffect mistakes:\n\n1. **Forgetting dependency array**:\n   ```jsx\n   // WRONG! Runs after EVERY render\n   useEffect(() => {\n     fetchData();  // Infinite loop if it updates state!\n   });\n   \n   // CORRECT!\n   useEffect(() => {\n     fetchData();\n   }, []);  // Run once on mount\n   ```\n\n2. **Using async directly in useEffect**:\n   ```jsx\n   // WRONG!\n   useEffect(async () => {  // Can't make effect async!\n     const data = await fetch('/api/users');\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     async function fetchData() {\n       const data = await fetch('/api/users');\n     }\n     fetchData();\n   }, []);\n   ```\n\n3. **Missing dependencies**:\n   ```jsx\n   // WRONG! (missing 'count' in dependencies)\n   useEffect(() => {\n     console.log('Count is:', count);\n   }, []);  // Should include [count]!\n   \n   // CORRECT!\n   useEffect(() => {\n     console.log('Count is:', count);\n   }, [count]);  // Re-run when count changes\n   ```\n\n4. **Not cleaning up**:\n   ```jsx\n   // WRONG! (memory leak)\n   useEffect(() => {\n     const timer = setInterval(() => setCount(c => c + 1), 1000);\n     // No cleanup!\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     const timer = setInterval(() => setCount(c => c + 1), 1000);\n     return () => clearInterval(timer);  // Cleanup!\n   }, []);\n   ```\n\n5. **Infinite loops**:\n   ```jsx\n   // WRONG! Infinite loop\n   useEffect(() => {\n     setCount(count + 1);  // Updates state → re-render → effect runs → updates state...\n   }, [count]);  // Depends on count!\n   \n   // CORRECT! (if you really need this pattern)\n   useEffect(() => {\n     if (count < 10) {  // Add condition\n       setCount(count + 1);\n     }\n   }, [count]);\n   ```\n\n6. **Stale closures**:\n   ```jsx\n   // WRONG! (captures old 'count')\n   useEffect(() => {\n     const timer = setInterval(() => {\n       setCount(count + 1);  // Always uses initial count!\n     }, 1000);\n     return () => clearInterval(timer);\n   }, []);  // Empty deps = count never updates\n   \n   // CORRECT!\n   useEffect(() => {\n     const timer = setInterval(() => {\n       setCount(c => c + 1);  // Use functional update\n     }, 1000);\n     return () => clearInterval(timer);\n   }, []);  // No dependency on count needed\n   ```\n\n7. **Multiple effects for unrelated logic** (good practice!):\n   ```jsx\n   // WRONG! (mixing concerns)\n   useEffect(() => {\n     fetchUsers();  // Unrelated\n     document.title = 'Users';  // to\n     window.addEventListener('resize', handleResize);  // each other\n   }, []);\n   \n   // CORRECT! (separate effects)\n   useEffect(() => {\n     fetchUsers();\n   }, []);\n   \n   useEffect(() => {\n     document.title = 'Users';\n   }, []);\n   \n   useEffect(() => {\n     window.addEventListener('resize', handleResize);\n     return () => window.removeEventListener('resize', handleResize);\n   }, []);\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.6-challenge",
              "title": "Practice Challenge",
              "description": "Create a clock component with useEffect:\n\n1. Create a `ClockComponent` object with:\n   - state: { time: current time string }\n   - mount() - simulates component mounting\n   - unmount() - simulates component unmounting\n   - Use effect to update time every second\n   - Cleanup timer on unmount\n\n2. Test by mounting, waiting 3 seconds, then unmounting",
              "instructions": "Create a clock component with useEffect:\n\n1. Create a `ClockComponent` object with:\n   - state: { time: current time string }\n   - mount() - simulates component mounting\n   - unmount() - simulates component unmounting\n   - Use effect to update time every second\n   - Cleanup timer on unmount\n\n2. Test by mounting, waiting 3 seconds, then unmounting",
              "starterCode": "// Clock Component with useEffect\n\nlet ClockComponent = {\n  state: { time: new Date().toLocaleTimeString() },\n  timerId: null,\n  \n  mount() {\n    console.log('[Clock] Mounting...');\n    console.log('[Clock] useEffect(() => { ... }, [])');\n    \n    // Effect: Start timer\n    this.timerId = setInterval(() => {\n      this.state.time = new Date().toLocaleTimeString();\n      console.log('[Clock] Tick:', this.state.time);\n    }, 1000);\n    \n    console.log('[Clock] Timer started (ID:', this.timerId, ')');\n    console.log('[Clock] Registered cleanup function\\n');\n  },\n  \n  unmount() {\n    console.log('\\n[Clock] Unmounting...');\n    console.log('[Clock] Running cleanup function');\n    \n    // Cleanup: Stop timer\n    if (this.timerId) {\n      clearInterval(this.timerId);\n      console.log('[Clock] Timer stopped');\n    }\n  }\n};\n\n// Test\nasync function testClock() {\n  console.log('=== Clock Component Test ===\\n');\n  \n  ClockComponent.mount();\n  \n  // Wait 3 seconds\n  await new Promise(resolve => setTimeout(resolve, 3000));\n  \n  ClockComponent.unmount();\n}\n\ntestClock();",
              "solution": "// Complete useEffect simulation\n\nlet ClockComponent = {\n  state: { time: new Date().toLocaleTimeString(), ticks: 0 },\n  timerId: null,\n  mounted: false,\n  \n  mount() {\n    console.log('┌────────────────────────────────┐');\n    console.log('│     Clock Component Mount      │');\n    console.log('└────────────────────────────────┘\\n');\n    \n    this.mounted = true;\n    \n    console.log('[useEffect] Starting side effects...');\n    console.log('[Effect 1] Setting document title');\n    // document.title = 'Clock App';\n    \n    console.log('[Effect 2] Starting interval timer\\n');\n    this.timerId = setInterval(() => {\n      if (this.mounted) {\n        this.state.time = new Date().toLocaleTimeString();\n        this.state.ticks++;\n        console.log(`⏰ ${this.state.time} (tick #${this.state.ticks})`);\n      }\n    }, 1000);\n    \n    console.log(`✓ Timer ID: ${this.timerId}`);\n    console.log('✓ Cleanup function registered\\n');\n  },\n  \n  unmount() {\n    console.log('\\n┌────────────────────────────────┐');\n    console.log('│    Clock Component Unmount     │');\n    console.log('└────────────────────────────────┘\\n');\n    \n    this.mounted = false;\n    \n    console.log('[Cleanup] Running effect cleanup...');\n    \n    if (this.timerId) {\n      clearInterval(this.timerId);\n      console.log(`✓ Timer ${this.timerId} cleared`);\n      this.timerId = null;\n    }\n    \n    console.log(`✓ Total ticks: ${this.state.ticks}`);\n    console.log('✓ Component unmounted cleanly\\n');\n  }\n};\n\n// Fetch component with cleanup\nlet DataFetcher = {\n  state: { data: null, loading: false },\n  controller: null,\n  \n  async mount(userId) {\n    console.log('┌────────────────────────────────┐');\n    console.log('│   DataFetcher Mount (user:${userId})   │'.replace('${userId}', userId));\n    console.log('└────────────────────────────────┘\\n');\n    \n    console.log('[useEffect] Running with [userId] dependency');\n    console.log(`  userId = ${userId}\\n`);\n    \n    // Simulate AbortController for fetch cancellation\n    this.controller = { aborted: false };\n    \n    this.state.loading = true;\n    console.log('[Fetch] Starting request...');\n    \n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    if (!this.controller.aborted) {\n      this.state.data = { id: userId, name: `User ${userId}` };\n      this.state.loading = false;\n      console.log('[Fetch] Success:', this.state.data);\n    } else {\n      console.log('[Fetch] Aborted');\n    }\n    \n    console.log('\\n✓ Cleanup function registered');\n  },\n  \n  unmount() {\n    console.log('\\n[Cleanup] Aborting fetch if in progress...');\n    if (this.controller) {\n      this.controller.aborted = true;\n      console.log('✓ Fetch aborted');\n    }\n  }\n};\n\n// Run demonstrations\nasync function runDemo() {\n  console.log('═══ useEffect Demo ═══\\n');\n  \n  // Demo 1: Clock\n  console.log('DEMO 1: Clock with Timer\\n');\n  ClockComponent.mount();\n  \n  await new Promise(resolve => setTimeout(resolve, 3500));\n  \n  ClockComponent.unmount();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // Demo 2: Data fetching\n  console.log('\\nDEMO 2: Data Fetching with Cleanup\\n');\n  console.log('Fetching user 1...');\n  let fetch1 = DataFetcher.mount(1);\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  console.log('\\n[Props Change] userId: 1 → 2');\n  console.log('Cleaning up old effect...');\n  DataFetcher.unmount();\n  \n  console.log('\\nFetching user 2...');\n  await DataFetcher.mount(2);\n  \n  console.log('\\n\\n=== useEffect Best Practices ===\\n');\n  let practices = [\n    '✓ Always include dependency array ([], [dep], etc.)',\n    '✓ Return cleanup function when needed',\n    '✓ Don\\'t call async functions directly in useEffect',\n    '✓ Clean up timers, subscriptions, event listeners',\n    '✓ Use separate useEffect for unrelated logic',\n    '✓ Put all dependencies in the array',\n    '✓ Cleanup prevents memory leaks'\n  ];\n  \n  practices.forEach(p => console.log(p));\n}\n\nrunDemo();",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should set up interval",
                  "expectedOutput": "number",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should clean up interval",
                  "expectedOutput": "cleaned",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use setInterval in mount(), clearInterval in unmount()"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common useEffect mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common useEffect mistakes:"
                },
                {
                  "mistake": "**Forgetting dependency array**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting dependency array**:\n   ```jsx\n   // WRONG! Runs after EVERY render\n   useEffect(() => {\n     fetchData();  // Infinite loop if it updates state!\n   });\n   \n   // CORRECT!\n   useEffect(() => {\n     fetchData();\n   }, []);  // Run once on mount\n   ```"
                },
                {
                  "mistake": "**Using async directly in useEffect**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Using async directly in useEffect**:\n   ```jsx\n   // WRONG!\n   useEffect(async () => {  // Can't make effect async!\n     const data = await fetch('/api/users');\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     async function fetchData() {\n       const data = await fetch('/api/users');\n     }\n     fetchData();\n   }, []);\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "13.7",
          "title": "React Context API - Global State Without Prop Drilling (The Radio Station Analogy)",
          "moduleId": "module-13",
          "order": 7,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you're running a radio station:\n\nWithout Radio (Prop Drilling):\n- Want to share a message with 100 people\n- Call person 1, they call person 2, they call person 3...\n- Message passes through everyone to reach the last person\n- Tedious! What if someone in the middle is busy?\n\nWith Radio Station (Context):\n- Broadcast once from the station\n- Everyone with a radio can tune in directly\n- No chain of messengers needed!\n- Anyone who needs the info just 'subscribes'\n\nReact Context works like a radio station:\n- **Provider** = The radio station (broadcasts data)\n- **Consumer/useContext** = The radio receiver (listens for data)\n- Any component can tune in without passing props through every level!\n\nPerfect for: Theme (dark/light), Auth (logged in user), Language (i18n)"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// React Context API - Global State\n\nconsole.log('=== React Context API ===\\n');\n\n// THE PROBLEM: Prop Drilling\nconsole.log('PROBLEM: Prop Drilling\\n');\nconsole.log('App → Layout → Header → UserMenu → UserName');\nconsole.log('Pass user prop through EVERY component? Tedious!\\n');\n\nlet propDrillingExample = `\n// Without Context (prop drilling nightmare)\nfunction App() {\n  const [user, setUser] = useState({ name: 'Alice' });\n  return <Layout user={user} />;  // Pass to Layout\n}\n\nfunction Layout({ user }) {\n  return <Header user={user} />;  // Pass to Header\n}\n\nfunction Header({ user }) {\n  return <UserMenu user={user} />;  // Pass to UserMenu\n}\n\nfunction UserMenu({ user }) {\n  return <span>{user.name}</span>;  // Finally use it!\n}\n`;\nconsole.log(propDrillingExample);\n\n// THE SOLUTION: Context\nconsole.log('\\nSOLUTION: Context API\\n');\n\n// Simulating React Context\nlet UserContext = {\n  _value: null,\n  Provider: function(props) {\n    this._value = props.value;\n    console.log('[Provider] Broadcasting:', props.value);\n    return props.children;\n  }\n};\n\nfunction useContext(context) {\n  console.log('[useContext] Receiving:', context._value);\n  return context._value;\n}\n\n// Create and use context\nconsole.log('// Step 1: Create Context');\nconsole.log('const UserContext = createContext(null);\\n');\n\nconsole.log('// Step 2: Provide value at top level');\nconsole.log('function App() {');\nconsole.log('  const [user, setUser] = useState({ name: \"Alice\" });');\nconsole.log('  return (');\nconsole.log('    <UserContext.Provider value={{ user, setUser }}>');\nconsole.log('      <Layout />  // No props needed!');\nconsole.log('    </UserContext.Provider>');\nconsole.log('  );');\nconsole.log('}\\n');\n\nconsole.log('// Step 3: Consume anywhere with useContext');\nconsole.log('function UserMenu() {');\nconsole.log('  const { user } = useContext(UserContext);  // Direct access!');\nconsole.log('  return <span>{user.name}</span>;');\nconsole.log('}\\n');\n\n// Simulate the flow\nconsole.log('=== Simulating Context Flow ===\\n');\n\nUserContext.Provider({ value: { name: 'Alice', role: 'admin' } });\nlet userData = useContext(UserContext);\nconsole.log('UserMenu displays:', userData.name);\n\n// Real-world example: Auth Context\nconsole.log('\\n\\n=== Real Example: Auth Context ===\\n');\n\nlet authContextCode = `\n// contexts/AuthContext.jsx\nimport { createContext, useContext, useState } from 'react';\n\n// 1. Create context\nconst AuthContext = createContext(null);\n\n// 2. Create provider component\nexport function AuthProvider({ children }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  const login = async (email, password) => {\n    const res = await fetch('/api/login', {\n      method: 'POST',\n      body: JSON.stringify({ email, password })\n    });\n    const data = await res.json();\n    setUser(data.user);\n  };\n\n  const logout = () => {\n    setUser(null);\n    // Clear cookies/tokens\n  };\n\n  return (\n    <AuthContext.Provider value={{ user, login, logout, loading }}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\n// 3. Create custom hook for easy access\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n}\n`;\nconsole.log(authContextCode);\n\nconsole.log('// Usage in App.jsx');\nconsole.log('import { AuthProvider } from \"./contexts/AuthContext\";\\n');\nconsole.log('function App() {');\nconsole.log('  return (');\nconsole.log('    <AuthProvider>');\nconsole.log('      <Router>');\nconsole.log('        <Routes>...</Routes>');\nconsole.log('      </Router>');\nconsole.log('    </AuthProvider>');\nconsole.log('  );');\nconsole.log('}\\n');\n\nconsole.log('// Usage in any component');\nconsole.log('function Navbar() {');\nconsole.log('  const { user, logout } = useAuth();');\nconsole.log('  return user ? (');\nconsole.log('    <button onClick={logout}>Logout {user.name}</button>');\nconsole.log('  ) : (');\nconsole.log('    <Link to=\"/login\">Login</Link>');\nconsole.log('  );');\nconsole.log('}');\n\n// Theme Context example\nconsole.log('\\n\\n=== Real Example: Theme Context ===\\n');\n\nlet ThemeContext = {\n  _value: { theme: 'light', toggleTheme: () => {} }\n};\n\nconsole.log('// contexts/ThemeContext.jsx');\nconsole.log('export function ThemeProvider({ children }) {');\nconsole.log('  const [theme, setTheme] = useState(\"light\");');\nconsole.log('');\nconsole.log('  const toggleTheme = () => {');\nconsole.log('    setTheme(prev => prev === \"light\" ? \"dark\" : \"light\");');\nconsole.log('  };');\nconsole.log('');\nconsole.log('  return (');\nconsole.log('    <ThemeContext.Provider value={{ theme, toggleTheme }}>');\nconsole.log('      {children}');\nconsole.log('    </ThemeContext.Provider>');\nconsole.log('  );');\nconsole.log('}\\n');\n\nconsole.log('// Any component can toggle theme!');\nconsole.log('function ThemeToggle() {');\nconsole.log('  const { theme, toggleTheme } = useTheme();');\nconsole.log('  return (');\nconsole.log('    <button onClick={toggleTheme}>');\nconsole.log('      {theme === \"light\" ? \"🌙\" : \"☀️\"}');\nconsole.log('    </button>');\nconsole.log('  );');\nconsole.log('}');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Context API step by step:\n\n1. **Create Context**:\n   ```jsx\n   import { createContext } from 'react';\n   \n   const MyContext = createContext(defaultValue);\n   // defaultValue used when no Provider found\n   ```\n\n2. **Create Provider Component**:\n   ```jsx\n   export function MyProvider({ children }) {\n     const [state, setState] = useState(initialValue);\n     \n     return (\n       <MyContext.Provider value={{ state, setState }}>\n         {children}\n       </MyContext.Provider>\n     );\n   }\n   ```\n\n3. **Create Custom Hook** (best practice!):\n   ```jsx\n   export function useMyContext() {\n     const context = useContext(MyContext);\n     if (!context) {\n       throw new Error('useMyContext must be within MyProvider');\n     }\n     return context;\n   }\n   ```\n\n4. **Wrap App with Provider**:\n   ```jsx\n   function App() {\n     return (\n       <MyProvider>\n         <RestOfApp />\n       </MyProvider>\n     );\n   }\n   ```\n\n5. **Use in Any Component**:\n   ```jsx\n   function DeepNestedComponent() {\n     const { state, setState } = useMyContext();\n     // Access state directly - no props needed!\n   }\n   ```\n\n**Common Context Use Cases**:\n- **AuthContext**: User login state, login/logout functions\n- **ThemeContext**: Dark/light mode, toggle function\n- **CartContext**: Shopping cart items, add/remove functions\n- **LanguageContext**: Current language, translation function\n\n**Multiple Contexts** (nest providers):\n```jsx\nfunction App() {\n  return (\n    <AuthProvider>\n      <ThemeProvider>\n        <CartProvider>\n          <Router>...</Router>\n        </CartProvider>\n      </ThemeProvider>\n    </AuthProvider>\n  );\n}\n```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Context mistakes:\n\n1. **Using Context for everything** (overuse):\n   ```jsx\n   // WRONG! Don't use context for local state\n   const ButtonContext = createContext();\n   // Button click count doesn't need global state!\n   \n   // CORRECT! Only use for truly global state:\n   // - Auth, Theme, Language, Shopping Cart\n   ```\n\n2. **Forgetting the Provider**:\n   ```jsx\n   // WRONG! useContext outside Provider returns undefined\n   function App() {\n     return <UserProfile />;  // No Provider!\n   }\n   \n   function UserProfile() {\n     const user = useContext(UserContext);  // undefined!\n   }\n   \n   // CORRECT!\n   function App() {\n     return (\n       <UserContext.Provider value={user}>\n         <UserProfile />\n       </UserContext.Provider>\n     );\n   }\n   ```\n\n3. **Not memoizing context value** (performance issue):\n   ```jsx\n   // WRONG! New object every render = all consumers re-render\n   <MyContext.Provider value={{ user, setUser }}>\n   \n   // CORRECT! Memoize the value\n   const value = useMemo(() => ({ user, setUser }), [user]);\n   <MyContext.Provider value={value}>\n   ```\n\n4. **Putting too much in one context**:\n   ```jsx\n   // WRONG! Everything in one context\n   const AppContext = createContext();\n   // value = { user, theme, cart, language, notifications... }\n   // Changing theme re-renders cart components!\n   \n   // CORRECT! Separate contexts\n   <AuthProvider>\n     <ThemeProvider>\n       <CartProvider>\n   ```\n\n5. **Not creating custom hook** (error-prone):\n   ```jsx\n   // WRONG! Raw useContext everywhere\n   const value = useContext(AuthContext);\n   // No error if used outside provider!\n   \n   // CORRECT! Custom hook with error checking\n   function useAuth() {\n     const context = useContext(AuthContext);\n     if (!context) {\n       throw new Error('useAuth must be within AuthProvider');\n     }\n     return context;\n   }\n   ```\n\n**When NOT to use Context**:\n- State only used by 1-2 nearby components (just pass props)\n- Frequently changing data (use state management like Zustand)\n- Server state (use React Query or SWR instead)"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.7-challenge",
              "title": "Practice Challenge: Theme Context",
              "description": "Create a simple Theme Context system:\n\n1. Create a ThemeContext simulation with:\n   - Current theme ('light' or 'dark')\n   - toggleTheme function\n\n2. Create a Provider that manages theme state\n\n3. Create components that use the theme:\n   - ThemeToggle button\n   - ThemedBox that shows current theme\n\n4. Demonstrate theme switching",
              "instructions": "Simulate React Context for theme management. Create provider, consumer, and demonstrate the toggle working.",
              "starterCode": "// Theme Context Simulation\n\n// Simulating React Context\nlet ThemeContext = {\n  _value: null,\n  Provider: function(value, children) {\n    this._value = value;\n    return children;\n  }\n};\n\nfunction useTheme() {\n  return ThemeContext._value;\n}\n\n// Theme Provider\nlet themeState = { theme: 'light' };\n\nfunction toggleTheme() {\n  themeState.theme = themeState.theme === 'light' ? 'dark' : 'light';\n  console.log('[Theme Changed]', themeState.theme);\n}\n\n// Set up provider\nThemeContext.Provider({ theme: themeState.theme, toggleTheme });\n\n// Components using context\nfunction ThemeToggle() {\n  let { theme, toggleTheme } = useTheme();\n  console.log(`[ThemeToggle] Current: ${theme}`);\n  console.log(`[ThemeToggle] Button: ${theme === 'light' ? '🌙 Dark Mode' : '☀️ Light Mode'}`);\n  return { toggle: toggleTheme };\n}\n\nfunction ThemedBox() {\n  let { theme } = useTheme();\n  let styles = theme === 'light' \n    ? { bg: 'white', text: 'black' }\n    : { bg: '#1a1a1a', text: 'white' };\n  console.log(`[ThemedBox] Background: ${styles.bg}, Text: ${styles.text}`);\n}\n\n// Test the context\nconsole.log('=== Theme Context Demo ===\\n');\nconsole.log('Initial state:');\nThemedBox();\n\nlet toggle = ThemeToggle();\nconsole.log('\\nClicking toggle button...');\ntoggle.toggle();\n\n// Update context with new state\nThemeContext.Provider({ theme: themeState.theme, toggleTheme });\n\nconsole.log('\\nAfter toggle:');\nThemedBox();",
              "solution": "// Complete Theme Context System\n\nconsole.log('═══════════════════════════════');\nconsole.log('   Theme Context Demo');\nconsole.log('═══════════════════════════════\\n');\n\n// Simulating React's createContext and useContext\nfunction createContext(defaultValue) {\n  return {\n    _value: defaultValue,\n    Provider: function(props) {\n      this._value = props.value;\n      console.log('[Context] Provider mounted with:', props.value.theme);\n      if (props.children) props.children();\n    }\n  };\n}\n\nfunction useContext(context) {\n  if (!context._value) {\n    throw new Error('useContext must be used within a Provider!');\n  }\n  return context._value;\n}\n\n// 1. Create Theme Context\nconst ThemeContext = createContext({ theme: 'light', toggleTheme: () => {} });\n\n// 2. Theme Provider (manages state)\nlet themeState = {\n  theme: 'light',\n  listeners: [],\n  \n  toggle() {\n    this.theme = this.theme === 'light' ? 'dark' : 'light';\n    console.log(`\\n[State] Theme changed to: ${this.theme}`);\n    this.notify();\n  },\n  \n  subscribe(fn) {\n    this.listeners.push(fn);\n  },\n  \n  notify() {\n    this.listeners.forEach(fn => fn(this.theme));\n  }\n};\n\nfunction ThemeProvider(children) {\n  const value = {\n    theme: themeState.theme,\n    toggleTheme: () => themeState.toggle()\n  };\n  \n  ThemeContext.Provider({ value, children });\n}\n\n// 3. Custom Hook (best practice!)\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n}\n\n// 4. Components using the context\nfunction Header() {\n  const { theme } = useTheme();\n  console.log(`\\n[Header] Rendering with ${theme} theme`);\n  console.log(`  Logo: ${theme === 'light' ? '🌞 MyApp' : '🌙 MyApp'}`);\n}\n\nfunction ThemeToggleButton() {\n  const { theme, toggleTheme } = useTheme();\n  console.log(`\\n[ThemeToggle] Button: ${theme === 'light' ? '🌙 Switch to Dark' : '☀️ Switch to Light'}`);\n  return { onClick: toggleTheme };\n}\n\nfunction Card() {\n  const { theme } = useTheme();\n  const styles = {\n    light: { bg: '#ffffff', text: '#000000', border: '#e0e0e0' },\n    dark: { bg: '#2d2d2d', text: '#ffffff', border: '#404040' }\n  };\n  const s = styles[theme];\n  console.log(`\\n[Card] Styled with ${theme} theme`);\n  console.log(`  Background: ${s.bg}`);\n  console.log(`  Text: ${s.text}`);\n  console.log(`  Border: ${s.border}`);\n}\n\nfunction Footer() {\n  const { theme } = useTheme();\n  console.log(`\\n[Footer] © 2024 MyApp (${theme} mode)`);\n}\n\n// 5. App with all components\nfunction App() {\n  Header();\n  Card();\n  let toggleBtn = ThemeToggleButton();\n  Footer();\n  return { toggleBtn };\n}\n\n// Run the demo\nconsole.log('─── Initial Render (Light Theme) ───');\nlet app;\nThemeProvider(() => {\n  app = App();\n});\n\nconsole.log('\\n─── User Clicks Theme Toggle ───');\nthemeState.toggle();\n\n// Re-render with new theme\nconsole.log('\\n─── Re-render (Dark Theme) ───');\nThemeProvider(() => {\n  app = App();\n});\n\nconsole.log('\\n─── Toggle Again ───');\nthemeState.toggle();\n\nThemeProvider(() => {\n  app = App();\n});\n\nconsole.log('\\n\\n═══════════════════════════════');\nconsole.log('   Context API Benefits');\nconsole.log('═══════════════════════════════');\nconsole.log('✓ No prop drilling through intermediate components');\nconsole.log('✓ Any component can access theme directly');\nconsole.log('✓ Single source of truth for theme state');\nconsole.log('✓ Easy to add new themed components');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Theme toggle works",
                  "expectedOutput": "dark",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Create a context object with _value property to store the current value"
                },
                {
                  "level": 2,
                  "text": "The Provider sets _value, useContext reads _value"
                },
                {
                  "level": 3,
                  "text": "toggleTheme should change 'light' to 'dark' and vice versa"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to wrap components in Provider",
                  "consequence": "useContext returns undefined or default value",
                  "correction": "Always wrap your component tree with <Provider value={...}>"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "13.8",
          "title": "React + TypeScript - Type-Safe Components (The Contract Analogy)",
          "moduleId": "module-13",
          "order": 8,
          "estimatedMinutes": 35,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine hiring a contractor to build a house:\n\nWithout a Contract (JavaScript):\n- 'Build me a house'\n- Contractor might forget the roof\n- Wrong number of rooms?\n- No way to verify until it's built\n\nWith a Contract (TypeScript):\n- 'Build a house with: 3 bedrooms, 2 bathrooms, a garage'\n- Contractor MUST follow the contract\n- Caught immediately if something's missing\n- Both parties know exactly what to expect\n\nTypeScript + React:\n- **Props interface** = Contract for component inputs\n- **State types** = Contract for component data\n- **Return types** = Contract for what component renders\n\nIDE catches errors BEFORE you run the app!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// React + TypeScript Fundamentals\n\nconsole.log('=== React + TypeScript ===\\n');\n\n// Setup: npm create vite@latest my-app -- --template react-ts\n\n// 1. TYPING PROPS\nconsole.log('1. Typing Component Props\\n');\n\nlet userCardExample = `\n// Define props interface\ninterface UserCardProps {\n  name: string;\n  email: string;\n  age: number;\n  isAdmin?: boolean;  // Optional prop\n  onEdit: (id: number) => void;  // Function prop\n}\n\n// Use interface with component\nfunction UserCard({ name, email, age, isAdmin = false, onEdit }: UserCardProps) {\n  return (\n    <div className=\"card\">\n      <h2>{name} {isAdmin && '👑'}</h2>\n      <p>{email}</p>\n      <p>Age: {age}</p>\n      <button onClick={() => onEdit(1)}>Edit</button>\n    </div>\n  );\n}\n\n// TypeScript catches errors:\n<UserCard name=\"Alice\" />  // ❌ Error: missing email, age, onEdit\n<UserCard name=\"Alice\" email=\"a@b.com\" age=\"25\" onEdit={() => {}} />  // ❌ age should be number\n<UserCard name=\"Alice\" email=\"a@b.com\" age={25} onEdit={() => {}} />  // ✅ Correct!\n`;\nconsole.log(userCardExample);\n\n// 2. TYPING STATE\nconsole.log('\\n2. Typing useState\\n');\n\nlet stateExample = `\n// Explicit type for complex state\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nfunction UserProfile() {\n  // Type inferred from initial value\n  const [count, setCount] = useState(0);  // number\n  const [name, setName] = useState('');   // string\n  \n  // Explicit type for complex objects\n  const [user, setUser] = useState<User | null>(null);\n  \n  // Array of objects\n  const [users, setUsers] = useState<User[]>([]);\n  \n  // Union types\n  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');\n  \n  return (\n    <div>\n      {user?.name}  // Safe access with optional chaining\n      {status === 'loading' && <Spinner />}\n    </div>\n  );\n}\n`;\nconsole.log(stateExample);\n\n// 3. TYPING EVENTS\nconsole.log('\\n3. Typing Event Handlers\\n');\n\nlet eventExample = `\nfunction SearchForm() {\n  const [query, setQuery] = useState('');\n  \n  // Input change event\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setQuery(e.target.value);\n  };\n  \n  // Form submit event\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    console.log('Searching:', query);\n  };\n  \n  // Button click event\n  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n    console.log('Button clicked');\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input value={query} onChange={handleChange} />\n      <button type=\"submit\" onClick={handleClick}>Search</button>\n    </form>\n  );\n}\n`;\nconsole.log(eventExample);\n\n// 4. TYPING CHILDREN\nconsole.log('\\n4. Typing Children Prop\\n');\n\nlet childrenExample = `\n// For components that wrap other components\ninterface CardProps {\n  title: string;\n  children: React.ReactNode;  // Any valid React child\n}\n\nfunction Card({ title, children }: CardProps) {\n  return (\n    <div className=\"card\">\n      <h2>{title}</h2>\n      {children}\n    </div>\n  );\n}\n\n// Usage\n<Card title=\"Profile\">\n  <p>User content here</p>\n  <UserAvatar />\n</Card>\n`;\nconsole.log(childrenExample);\n\n// 5. TYPING CONTEXT\nconsole.log('\\n5. Typing Context API\\n');\n\nlet contextExample = `\n// contexts/AuthContext.tsx\ninterface AuthContextType {\n  user: User | null;\n  login: (email: string, password: string) => Promise<void>;\n  logout: () => void;\n  loading: boolean;\n}\n\nconst AuthContext = createContext<AuthContextType | null>(null);\n\nexport function useAuth(): AuthContextType {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n}\n\n// Now TypeScript knows exactly what useAuth returns!\nfunction Navbar() {\n  const { user, logout } = useAuth();  // Fully typed!\n  //     ^^^^ TypeScript knows user is User | null\n}\n`;\nconsole.log(contextExample);\n\n// 6. COMMON PATTERNS\nconsole.log('\\n6. Common TypeScript + React Patterns\\n');\n\nlet patterns = `\n// Generic Components\ninterface ListProps<T> {\n  items: T[];\n  renderItem: (item: T) => React.ReactNode;\n}\n\nfunction List<T>({ items, renderItem }: ListProps<T>) {\n  return <ul>{items.map(renderItem)}</ul>;\n}\n\n// Usage with type inference\n<List \n  items={[{ id: 1, name: 'Alice' }]} \n  renderItem={(user) => <li key={user.id}>{user.name}</li>}\n/>\n\n// Discriminated Unions for State\ntype RequestState<T> = \n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: string };\n\nfunction UserList() {\n  const [state, setState] = useState<RequestState<User[]>>({ status: 'idle' });\n  \n  if (state.status === 'loading') return <Spinner />;\n  if (state.status === 'error') return <Error message={state.error} />;\n  if (state.status === 'success') return <List items={state.data} />;\n  return <button onClick={fetch}>Load Users</button>;\n}\n`;\nconsole.log(patterns);\n\nconsole.log('\\n=== Quick Reference ===\\n');\nconsole.log('Props:     interface XProps { prop: type }');\nconsole.log('State:     useState<Type>(initial)');\nconsole.log('Events:    (e: React.ChangeEvent<HTMLInputElement>) => void');\nconsole.log('Children:  React.ReactNode');\nconsole.log('Ref:       useRef<HTMLInputElement>(null)');\nconsole.log('Context:   createContext<Type | null>(null)');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "TypeScript + React essentials:\n\n1. **Props Interface**:\n   ```tsx\n   interface ButtonProps {\n     label: string;\n     onClick: () => void;\n     disabled?: boolean;  // Optional\n     variant: 'primary' | 'secondary';  // Union type\n   }\n   \n   function Button({ label, onClick, disabled = false }: ButtonProps) {\n     return <button disabled={disabled} onClick={onClick}>{label}</button>;\n   }\n   ```\n\n2. **Typed useState**:\n   ```tsx\n   // Simple types (inferred)\n   const [count, setCount] = useState(0);\n   \n   // Complex types (explicit)\n   const [user, setUser] = useState<User | null>(null);\n   const [items, setItems] = useState<Item[]>([]);\n   ```\n\n3. **Common Event Types**:\n   ```tsx\n   // Input\n   onChange: (e: React.ChangeEvent<HTMLInputElement>) => void\n   \n   // Form\n   onSubmit: (e: React.FormEvent<HTMLFormElement>) => void\n   \n   // Button\n   onClick: (e: React.MouseEvent<HTMLButtonElement>) => void\n   \n   // Keyboard\n   onKeyDown: (e: React.KeyboardEvent<HTMLInputElement>) => void\n   ```\n\n4. **Typed useRef**:\n   ```tsx\n   const inputRef = useRef<HTMLInputElement>(null);\n   const divRef = useRef<HTMLDivElement>(null);\n   \n   // Access with null check\n   inputRef.current?.focus();\n   ```\n\n5. **Typed Callbacks**:\n   ```tsx\n   const handleSave = useCallback((id: number, data: User) => {\n     // ...\n   }, []);\n   \n   const total = useMemo<number>(() => {\n     return items.reduce((sum, item) => sum + item.price, 0);\n   }, [items]);\n   ```\n\n6. **Function Component Type**:\n   ```tsx\n   // Explicit return type (optional but helpful)\n   const UserCard: React.FC<UserProps> = ({ name, email }) => {\n     return <div>{name}</div>;\n   };\n   \n   // Or simpler (preferred):\n   function UserCard({ name, email }: UserProps): JSX.Element {\n     return <div>{name}</div>;\n   }\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common TypeScript + React mistakes:\n\n1. **Forgetting null checks with state**:\n   ```tsx\n   // WRONG! user could be null\n   const [user, setUser] = useState<User | null>(null);\n   return <div>{user.name}</div>;  // ❌ Error!\n   \n   // CORRECT! Check for null\n   return <div>{user?.name}</div>;  // ✅ Optional chaining\n   // OR\n   if (!user) return <Loading />;\n   return <div>{user.name}</div>;  // ✅ TypeScript knows user exists\n   ```\n\n2. **Wrong event type**:\n   ```tsx\n   // WRONG! Using wrong element type\n   const handleChange = (e: React.ChangeEvent<HTMLButtonElement>) => {\n     console.log(e.target.value);  // Buttons don't have value!\n   };\n   \n   // CORRECT! Match element type\n   const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n     console.log(e.target.value);  // ✅\n   };\n   ```\n\n3. **Using `any` to avoid errors**:\n   ```tsx\n   // WRONG! Defeats the purpose of TypeScript\n   const [data, setData] = useState<any>(null);\n   \n   // CORRECT! Define proper types\n   interface ApiResponse {\n     users: User[];\n     total: number;\n   }\n   const [data, setData] = useState<ApiResponse | null>(null);\n   ```\n\n4. **Overusing React.FC**:\n   ```tsx\n   // Less preferred (implicit children, verbose)\n   const Card: React.FC<CardProps> = ({ title }) => { ... };\n   \n   // Preferred (simpler, explicit)\n   function Card({ title }: CardProps) { ... }\n   ```\n\n5. **Not typing async functions**:\n   ```tsx\n   // WRONG! Return type unclear\n   const fetchUsers = async () => {\n     const res = await fetch('/api/users');\n     return res.json();  // What type is this?\n   };\n   \n   // CORRECT! Explicit return type\n   const fetchUsers = async (): Promise<User[]> => {\n     const res = await fetch('/api/users');\n     return res.json();\n   };\n   ```\n\n**Setup TypeScript + React**:\n```bash\n# New project\nnpm create vite@latest my-app -- --template react-ts\n\n# Add to existing project\nnpm install typescript @types/react @types/react-dom\nnpx tsc --init\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.8-challenge",
              "title": "Practice Challenge: Type a React Component",
              "description": "Create a typed ProductCard component:\n\n1. Define a Product interface with:\n   - id: number\n   - name: string\n   - price: number\n   - inStock: boolean\n\n2. Define ProductCardProps interface with:\n   - product: Product\n   - onAddToCart: (id: number) => void\n\n3. Create a simulated ProductCard that uses these types\n\n4. Show how TypeScript catches errors",
              "instructions": "Define TypeScript interfaces and simulate a typed React component. Show error cases that TypeScript would catch.",
              "starterCode": "// TypeScript + React Simulation\n\n// Define interfaces\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  inStock: boolean;\n}\n\ninterface ProductCardProps {\n  product: Product;\n  onAddToCart: (id: number) => void;\n}\n\n// Simulate a typed component\nfunction ProductCard(props: ProductCardProps) {\n  let { product, onAddToCart } = props;\n  \n  console.log(`[ProductCard] Rendering: ${product.name}`);\n  console.log(`  Price: $${product.price.toFixed(2)}`);\n  console.log(`  In Stock: ${product.inStock ? 'Yes' : 'No'}`);\n  \n  if (product.inStock) {\n    console.log('  [Add to Cart] button enabled');\n  } else {\n    console.log('  [Out of Stock] button disabled');\n  }\n  \n  return {\n    addToCart: () => onAddToCart(product.id)\n  };\n}\n\n// Test with valid data\nconsole.log('=== Valid Usage ===\\n');\n\nlet laptop: Product = {\n  id: 1,\n  name: 'MacBook Pro',\n  price: 1999.99,\n  inStock: true\n};\n\nlet card = ProductCard({\n  product: laptop,\n  onAddToCart: (id) => console.log(`\\nAdded product ${id} to cart!`)\n});\n\ncard.addToCart();\n\n// TypeScript would catch these errors:\nconsole.log('\\n=== Errors TypeScript Would Catch ===\\n');\nconsole.log('❌ Missing required prop:');\nconsole.log('   ProductCard({ product: laptop })  // Error: missing onAddToCart');\n\nconsole.log('\\n❌ Wrong type:');\nconsole.log('   let bad = { id: \"1\", name: \"Item\", price: \"10\", inStock: \"yes\" }');\nconsole.log('   // Error: id should be number, price should be number, inStock should be boolean');\n\nconsole.log('\\n❌ Wrong function signature:');\nconsole.log('   onAddToCart: (name: string) => void');\nconsole.log('   // Error: expects (id: number) => void');",
              "solution": "// Complete TypeScript + React Type Safety Demo\n\nconsole.log('═══════════════════════════════');\nconsole.log('  TypeScript + React Demo');\nconsole.log('═══════════════════════════════\\n');\n\n// 1. Define interfaces\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  inStock: boolean;\n  category?: string;  // Optional property\n}\n\ninterface ProductCardProps {\n  product: Product;\n  onAddToCart: (id: number) => void;\n  showDetails?: boolean;  // Optional prop with default\n}\n\n// Type for cart state\ninterface CartItem {\n  product: Product;\n  quantity: number;\n}\n\n// 2. Simulate typed component\nfunction ProductCard({ product, onAddToCart, showDetails = true }: ProductCardProps) {\n  console.log(`\\n┌─ ProductCard ──────────────────┐`);\n  console.log(`│ ${product.name.padEnd(30)} │`);\n  console.log(`├────────────────────────────────┤`);\n  \n  if (showDetails) {\n    console.log(`│ Price: $${product.price.toFixed(2).padEnd(22)} │`);\n    console.log(`│ Stock: ${(product.inStock ? '✓ Available' : '✗ Out of Stock').padEnd(23)} │`);\n    if (product.category) {\n      console.log(`│ Category: ${product.category.padEnd(20)} │`);\n    }\n  }\n  \n  console.log(`│                                │`);\n  if (product.inStock) {\n    console.log(`│  [🛒 Add to Cart]              │`);\n  } else {\n    console.log(`│  [Notify When Available]       │`);\n  }\n  console.log(`└────────────────────────────────┘`);\n  \n  return {\n    handleClick: () => {\n      if (product.inStock) {\n        onAddToCart(product.id);\n      } else {\n        console.log(`[Notification] Will notify when ${product.name} is back!`);\n      }\n    }\n  };\n}\n\n// 3. Simulate cart with typed state\nlet cart: CartItem[] = [];\n\nfunction addToCart(productId: number, products: Product[]): void {\n  const product = products.find(p => p.id === productId);\n  if (!product) {\n    console.log(`[Error] Product ${productId} not found`);\n    return;\n  }\n  \n  const existing = cart.find(item => item.product.id === productId);\n  if (existing) {\n    existing.quantity++;\n    console.log(`[Cart] Updated ${product.name} quantity to ${existing.quantity}`);\n  } else {\n    cart.push({ product, quantity: 1 });\n    console.log(`[Cart] Added ${product.name} to cart`);\n  }\n}\n\n// 4. Test with typed data\nconst products: Product[] = [\n  { id: 1, name: 'MacBook Pro 16\"', price: 2499.99, inStock: true, category: 'Laptops' },\n  { id: 2, name: 'iPhone 15 Pro', price: 999.99, inStock: true, category: 'Phones' },\n  { id: 3, name: 'AirPods Max', price: 549.99, inStock: false, category: 'Audio' }\n];\n\nconsole.log('=== Rendering Product Cards ===');\n\nproducts.forEach(product => {\n  const card = ProductCard({\n    product,\n    onAddToCart: (id) => addToCart(id, products)\n  });\n  card.handleClick();\n});\n\nconsole.log('\\n\\n=== Cart Summary ===');\nconsole.log(`Total items: ${cart.length}`);\nconst total = cart.reduce((sum, item) => sum + (item.product.price * item.quantity), 0);\nconsole.log(`Total: $${total.toFixed(2)}`);\n\nconsole.log('\\n\\n=== TypeScript Error Prevention ===\\n');\n\nconst errorExamples = [\n  {\n    code: 'ProductCard({ product: laptop })',\n    error: 'Property onAddToCart is missing',\n    fixed: 'ProductCard({ product: laptop, onAddToCart: (id) => {} })'\n  },\n  {\n    code: '{ id: \"1\", name: \"Item\", price: \"10\" }',\n    error: 'Type string is not assignable to type number',\n    fixed: '{ id: 1, name: \"Item\", price: 10, inStock: true }'\n  },\n  {\n    code: 'onAddToCart: (name: string) => {}',\n    error: 'Parameter name incompatible with id: number',\n    fixed: 'onAddToCart: (id: number) => {}'\n  },\n  {\n    code: 'product.nonExistent',\n    error: 'Property nonExistent does not exist on type Product',\n    fixed: 'Use only defined properties: id, name, price, inStock'\n  }\n];\n\nerrorExamples.forEach((ex, i) => {\n  console.log(`${i + 1}. ❌ ${ex.code}`);\n  console.log(`   Error: ${ex.error}`);\n  console.log(`   ✅ Fix: ${ex.fixed}\\n`);\n});\n\nconsole.log('═══════════════════════════════');\nconsole.log('  Benefits of TypeScript + React');\nconsole.log('═══════════════════════════════');\nconsole.log('✓ Catch errors at compile time, not runtime');\nconsole.log('✓ IDE autocomplete for props and state');\nconsole.log('✓ Self-documenting code with interfaces');\nconsole.log('✓ Refactor with confidence');\nconsole.log('✓ Better team collaboration');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Correctly typed components work",
                  "expectedOutput": "Cart",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Define Product interface with all required properties"
                },
                {
                  "level": 2,
                  "text": "ProductCardProps needs product: Product and onAddToCart: (id: number) => void"
                },
                {
                  "level": 3,
                  "text": "Use optional properties (?) for non-required props"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using 'any' type to bypass errors",
                  "consequence": "Loses all type safety benefits",
                  "correction": "Define proper interfaces for all data structures"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "13.9",
          "title": "Tailwind CSS with React - Utility-First Styling (The Building Blocks Analogy)",
          "moduleId": "module-13",
          "order": 9,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine building with LEGO:\n\nTraditional CSS (Custom Bricks):\n- Design and manufacture each brick yourself\n- 'button-primary.css' with 20 properties\n- Change requires modifying the mold\n- Lots of unused bricks sitting around\n\nTailwind CSS (Standard LEGO Bricks):\n- Pre-made bricks in all sizes and colors\n- Combine small pieces: 'bg-blue-500 text-white px-4 py-2 rounded'\n- Want a change? Swap a brick!\n- Only bricks you use are in the final box\n\nTailwind = Utility classes that do ONE thing each:\n- bg-blue-500 → background: blue\n- text-white → color: white\n- px-4 → padding-left/right: 1rem\n- rounded → border-radius\n\nNo more writing custom CSS for every component!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Tailwind CSS with React\n\nconsole.log('=== Tailwind CSS Fundamentals ===\\n');\n\n// Setup: npm install -D tailwindcss postcss autoprefixer\n//        npx tailwindcss init -p\n\n// 1. BASIC CLASSES\nconsole.log('1. Basic Utility Classes\\n');\n\nlet basicClasses = {\n  spacing: {\n    'p-4': 'padding: 1rem (16px)',\n    'm-2': 'margin: 0.5rem (8px)',\n    'px-6': 'padding-left/right: 1.5rem',\n    'my-auto': 'margin-top/bottom: auto',\n    'space-x-4': 'horizontal spacing between children'\n  },\n  colors: {\n    'bg-blue-500': 'background-color: blue (medium)',\n    'text-white': 'color: white',\n    'border-gray-300': 'border-color: gray',\n    'bg-gradient-to-r': 'linear gradient to right'\n  },\n  typography: {\n    'text-xl': 'font-size: 1.25rem',\n    'font-bold': 'font-weight: 700',\n    'text-center': 'text-align: center',\n    'uppercase': 'text-transform: uppercase'\n  },\n  layout: {\n    'flex': 'display: flex',\n    'grid': 'display: grid',\n    'items-center': 'align-items: center',\n    'justify-between': 'justify-content: space-between'\n  }\n};\n\nfor (let [category, classes] of Object.entries(basicClasses)) {\n  console.log(`${category.toUpperCase()}:`);\n  for (let [className, meaning] of Object.entries(classes)) {\n    console.log(`  ${className.padEnd(20)} → ${meaning}`);\n  }\n  console.log('');\n}\n\n// 2. COMPONENT EXAMPLES\nconsole.log('\\n2. React Component Examples\\n');\n\nlet buttonExample = `\n// Button Component with Tailwind\nfunction Button({ children, variant = 'primary' }) {\n  const baseClasses = 'px-4 py-2 rounded font-medium transition-colors';\n  \n  const variants = {\n    primary: 'bg-blue-500 text-white hover:bg-blue-600',\n    secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300',\n    danger: 'bg-red-500 text-white hover:bg-red-600'\n  };\n  \n  return (\n    <button className={\\`\\${baseClasses} \\${variants[variant]}\\`}>\n      {children}\n    </button>\n  );\n}\n\n// Usage\n<Button>Save</Button>\n<Button variant=\"danger\">Delete</Button>\n`;\nconsole.log(buttonExample);\n\nlet cardExample = `\n// Card Component\nfunction Card({ title, children }) {\n  return (\n    <div className=\"bg-white rounded-lg shadow-md p-6 hover:shadow-lg transition-shadow\">\n      <h2 className=\"text-xl font-bold text-gray-800 mb-4\">{title}</h2>\n      <div className=\"text-gray-600\">{children}</div>\n    </div>\n  );\n}\n`;\nconsole.log(cardExample);\n\n// 3. RESPONSIVE DESIGN\nconsole.log('\\n3. Responsive Design (Mobile-First)\\n');\n\nlet responsiveExample = `\n// Responsive breakpoints:\n// sm:  640px and up\n// md:  768px and up\n// lg:  1024px and up\n// xl:  1280px and up\n// 2xl: 1536px and up\n\n// Mobile: 1 column, Tablet: 2 columns, Desktop: 4 columns\n<div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n  <Card>Item 1</Card>\n  <Card>Item 2</Card>\n  <Card>Item 3</Card>\n  <Card>Item 4</Card>\n</div>\n\n// Hide on mobile, show on desktop\n<nav className=\"hidden lg:flex\">\n  <Links />\n</nav>\n\n// Different padding at different sizes\n<div className=\"p-4 md:p-6 lg:p-8\">\n  Content\n</div>\n`;\nconsole.log(responsiveExample);\n\n// 4. DARK MODE\nconsole.log('\\n4. Dark Mode Support\\n');\n\nlet darkModeExample = `\n// tailwind.config.js\nmodule.exports = {\n  darkMode: 'class',  // or 'media' for system preference\n};\n\n// Component with dark mode\n<div className=\"bg-white dark:bg-gray-800 text-gray-900 dark:text-white\">\n  <h1 className=\"text-gray-800 dark:text-gray-100\">\n    Supports both themes!\n  </h1>\n</div>\n\n// Toggle dark mode\n<html className=\"dark\">  // Add/remove 'dark' class\n`;\nconsole.log(darkModeExample);\n\n// 5. COMMON PATTERNS\nconsole.log('\\n5. Common UI Patterns\\n');\n\nlet patterns = `\n// Centered Container\n<div className=\"max-w-4xl mx-auto px-4\">\n  Centered content\n</div>\n\n// Flex Row with Spacing\n<div className=\"flex items-center justify-between gap-4\">\n  <Logo />\n  <Nav />\n</div>\n\n// Form Input\n<input className=\"w-full px-4 py-2 border border-gray-300 rounded-lg \n                  focus:ring-2 focus:ring-blue-500 focus:border-transparent\n                  placeholder-gray-400\" />\n\n// Avatar\n<img className=\"w-10 h-10 rounded-full object-cover\" />\n\n// Badge\n<span className=\"px-2 py-1 text-xs font-medium bg-green-100 text-green-800 rounded-full\">\n  Active\n</span>\n\n// Loading Spinner\n<div className=\"animate-spin h-8 w-8 border-4 border-blue-500 \n                border-t-transparent rounded-full\" />\n`;\nconsole.log(patterns);\n\nconsole.log('\\n=== Tailwind Setup Commands ===\\n');\nconsole.log('npm install -D tailwindcss postcss autoprefixer');\nconsole.log('npx tailwindcss init -p');\nconsole.log('');\nconsole.log('// Add to tailwind.config.js');\nconsole.log('content: [\"./src/**/*.{js,jsx,ts,tsx}\"]');\nconsole.log('');\nconsole.log('// Add to src/index.css');\nconsole.log('@tailwind base;');\nconsole.log('@tailwind components;');\nconsole.log('@tailwind utilities;');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Tailwind class naming patterns:\n\n1. **Color Scale** (50-950):\n   ```jsx\n   // Lighter → Darker\n   bg-blue-50   // Very light blue\n   bg-blue-100\n   bg-blue-500  // Medium blue (default)\n   bg-blue-900  // Very dark blue\n   \n   text-gray-700  // Dark gray text\n   border-red-300  // Light red border\n   ```\n\n2. **Spacing Scale** (0-96):\n   ```jsx\n   // 1 unit = 0.25rem = 4px\n   p-0   // 0px\n   p-1   // 4px\n   p-2   // 8px\n   p-4   // 16px\n   p-8   // 32px\n   \n   // Directional\n   pt-4  // padding-top\n   pr-4  // padding-right\n   pb-4  // padding-bottom\n   pl-4  // padding-left\n   px-4  // padding left + right\n   py-4  // padding top + bottom\n   ```\n\n3. **State Modifiers**:\n   ```jsx\n   hover:bg-blue-600    // On hover\n   focus:ring-2         // On focus\n   active:scale-95      // On click\n   disabled:opacity-50  // When disabled\n   group-hover:visible  // When parent hovered\n   ```\n\n4. **Responsive Prefixes**:\n   ```jsx\n   // Mobile-first: no prefix = all sizes\n   w-full           // width: 100% on all\n   md:w-1/2         // width: 50% on medium+\n   lg:w-1/3         // width: 33% on large+\n   \n   hidden lg:block  // Hidden until large screens\n   ```\n\n5. **Flexbox Shortcuts**:\n   ```jsx\n   <div className=\"flex items-center justify-between gap-4\">\n   //              ^^^^  ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^  ^^^^^\n   //              display  align-items  justify-content  gap\n   ```\n\n6. **Grid Shortcuts**:\n   ```jsx\n   <div className=\"grid grid-cols-3 gap-4\">\n   //              ^^^^  ^^^^^^^^^^  ^^^^^\n   //              display  3 columns  gap\n   ```\n\n7. **Common Combinations**:\n   ```jsx\n   // Card\n   \"bg-white rounded-lg shadow-md p-6\"\n   \n   // Button\n   \"bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600\"\n   \n   // Input\n   \"border border-gray-300 rounded px-3 py-2 focus:ring-2\"\n   \n   // Centered container\n   \"max-w-4xl mx-auto px-4\"\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Tailwind mistakes:\n\n1. **Not purging unused styles in production**:\n   ```javascript\n   // tailwind.config.js - MUST configure content\n   module.exports = {\n     content: [\n       './src/**/*.{js,jsx,ts,tsx}',  // Scan these files\n       './public/index.html'\n     ],\n   };\n   // Without this: 3MB CSS file!\n   // With this: ~10KB CSS file\n   ```\n\n2. **Dynamic class names don't work**:\n   ```jsx\n   // WRONG! Tailwind can't detect dynamic classes\n   <div className={`bg-${color}-500`}>  // Won't work!\n   \n   // CORRECT! Use complete class names\n   const colorClasses = {\n     blue: 'bg-blue-500',\n     red: 'bg-red-500',\n     green: 'bg-green-500'\n   };\n   <div className={colorClasses[color]}>\n   ```\n\n3. **Class order doesn't matter (mostly)**:\n   ```jsx\n   // These are the same:\n   \"px-4 py-2 bg-blue-500\"\n   \"bg-blue-500 py-2 px-4\"\n   \n   // BUT: later classes don't override earlier ones!\n   \"text-red-500 text-blue-500\"  // Both applied, browser decides\n   ```\n\n4. **Forgetting mobile-first**:\n   ```jsx\n   // WRONG thinking: \"hide on large screens\"\n   <div className=\"lg:hidden\">  // Hidden on lg+, visible on mobile\n   \n   // CORRECT thinking: mobile-first\n   <div className=\"block lg:hidden\">  // Same, but clearer intent\n   <div className=\"hidden lg:block\">  // Hidden mobile, visible lg+\n   ```\n\n5. **Long class strings (use extraction)**:\n   ```jsx\n   // MESSY\n   <button className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 focus:ring-2 focus:ring-blue-300 disabled:opacity-50 transition-colors\">\n   \n   // BETTER: Extract to variable or component\n   const btnPrimary = 'px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600';\n   <button className={btnPrimary}>\n   \n   // BEST: Use @apply in CSS (sparingly)\n   .btn-primary {\n     @apply px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600;\n   }\n   ```\n\n6. **Not using the official plugins**:\n   ```bash\n   # Forms plugin - better form styling\n   npm install @tailwindcss/forms\n   \n   # Typography plugin - prose styling\n   npm install @tailwindcss/typography\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "12.9-challenge",
              "title": "Practice Challenge: Build a Profile Card",
              "description": "Create a profile card using Tailwind utility classes:\n\n1. Card container with:\n   - White background, rounded corners, shadow\n   - Padding and max-width\n\n2. Avatar section with:\n   - Circular image placeholder\n   - Centered\n\n3. User info with:\n   - Name (large, bold)\n   - Title (smaller, gray)\n   - Bio (normal text)\n\n4. Action buttons with:\n   - Follow (blue) and Message (gray) buttons\n   - Hover states",
              "instructions": "Build a profile card by logging the Tailwind classes you would use. Simulate the component structure.",
              "starterCode": "// Profile Card with Tailwind CSS\n\nconsole.log('=== Profile Card Component ===\\n');\n\n// Simulate the component structure with classes\nlet profileCard = {\n  container: 'bg-white rounded-xl shadow-lg p-6 max-w-sm mx-auto',\n  \n  avatar: {\n    wrapper: 'flex justify-center mb-4',\n    image: 'w-24 h-24 rounded-full bg-gray-200'\n  },\n  \n  info: {\n    name: 'text-xl font-bold text-gray-800 text-center',\n    title: 'text-gray-500 text-center mb-2',\n    bio: 'text-gray-600 text-center text-sm'\n  },\n  \n  buttons: {\n    wrapper: 'flex gap-3 mt-6',\n    follow: 'flex-1 bg-blue-500 text-white py-2 rounded-lg hover:bg-blue-600 transition-colors',\n    message: 'flex-1 bg-gray-200 text-gray-800 py-2 rounded-lg hover:bg-gray-300 transition-colors'\n  }\n};\n\n// Display the structure\nconsole.log('CARD CONTAINER:');\nconsole.log(`  className=\"${profileCard.container}\"`);\n\nconsole.log('\\nAVATAR:');\nconsole.log(`  wrapper: \"${profileCard.avatar.wrapper}\"`);\nconsole.log(`  image: \"${profileCard.avatar.image}\"`);\n\nconsole.log('\\nUSER INFO:');\nconsole.log(`  name: \"${profileCard.info.name}\"`);\nconsole.log(`  title: \"${profileCard.info.title}\"`);\nconsole.log(`  bio: \"${profileCard.info.bio}\"`);\n\nconsole.log('\\nBUTTONS:');\nconsole.log(`  wrapper: \"${profileCard.buttons.wrapper}\"`);\nconsole.log(`  follow: \"${profileCard.buttons.follow}\"`);\nconsole.log(`  message: \"${profileCard.buttons.message}\"`);\n\n// Render simulation\nconsole.log('\\n\\n=== Rendered Output (Simulated) ===\\n');\nconsole.log('┌────────────────────────────────┐');\nconsole.log('│                                │');\nconsole.log('│         ┌──────────┐           │');\nconsole.log('│         │  Avatar  │           │');\nconsole.log('│         └──────────┘           │');\nconsole.log('│                                │');\nconsole.log('│         Sarah Johnson          │');\nconsole.log('│      Product Designer          │');\nconsole.log('│                                │');\nconsole.log('│  Creating user-centered        │');\nconsole.log('│  experiences for startups.     │');\nconsole.log('│                                │');\nconsole.log('│  [Follow]       [Message]      │');\nconsole.log('│                                │');\nconsole.log('└────────────────────────────────┘');",
              "solution": "// Complete Profile Card with Tailwind CSS\n\nconsole.log('═══════════════════════════════');\nconsole.log('  Tailwind Profile Card Demo');\nconsole.log('═══════════════════════════════\\n');\n\n// Define the component with all Tailwind classes\nconst ProfileCard = {\n  // Main container\n  container: [\n    'bg-white',           // White background\n    'rounded-xl',         // Large rounded corners\n    'shadow-lg',          // Large shadow\n    'p-8',                // Padding all sides\n    'max-w-sm',           // Max width small\n    'mx-auto',            // Center horizontally\n    'hover:shadow-xl',    // Bigger shadow on hover\n    'transition-shadow',  // Smooth transition\n    'dark:bg-gray-800'    // Dark mode support\n  ].join(' '),\n  \n  // Avatar section\n  avatar: {\n    wrapper: 'flex justify-center mb-6',\n    image: [\n      'w-28', 'h-28',           // Size\n      'rounded-full',            // Circular\n      'object-cover',            // Image fit\n      'ring-4', 'ring-blue-100', // Border ring\n      'dark:ring-blue-900'       // Dark mode ring\n    ].join(' '),\n    placeholder: 'w-28 h-28 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center text-white text-3xl font-bold'\n  },\n  \n  // User information\n  info: {\n    name: 'text-2xl font-bold text-gray-800 text-center dark:text-white',\n    title: 'text-blue-500 text-center font-medium mt-1',\n    location: 'text-gray-400 text-sm text-center mt-1 flex items-center justify-center gap-1',\n    bio: 'text-gray-600 text-center mt-4 leading-relaxed dark:text-gray-300'\n  },\n  \n  // Stats section\n  stats: {\n    wrapper: 'flex justify-center gap-8 mt-6 pt-6 border-t border-gray-100 dark:border-gray-700',\n    item: 'text-center',\n    number: 'text-2xl font-bold text-gray-800 dark:text-white',\n    label: 'text-xs text-gray-500 uppercase tracking-wide'\n  },\n  \n  // Action buttons\n  buttons: {\n    wrapper: 'flex gap-3 mt-6',\n    primary: [\n      'flex-1',\n      'bg-blue-500', 'text-white',\n      'py-2.5', 'px-4',\n      'rounded-lg',\n      'font-medium',\n      'hover:bg-blue-600',\n      'active:scale-95',\n      'transition-all',\n      'flex', 'items-center', 'justify-center', 'gap-2'\n    ].join(' '),\n    secondary: [\n      'flex-1',\n      'bg-gray-100', 'text-gray-700',\n      'py-2.5', 'px-4',\n      'rounded-lg',\n      'font-medium',\n      'hover:bg-gray-200',\n      'active:scale-95',\n      'transition-all',\n      'dark:bg-gray-700', 'dark:text-gray-200'\n    ].join(' ')\n  }\n};\n\n// Log the classes for each section\nconsole.log('📦 CONTAINER');\nconsole.log(`   ${ProfileCard.container}\\n`);\n\nconsole.log('🖼️  AVATAR');\nconsole.log(`   Wrapper: ${ProfileCard.avatar.wrapper}`);\nconsole.log(`   Image: ${ProfileCard.avatar.image}\\n`);\n\nconsole.log('ℹ️  USER INFO');\nconsole.log(`   Name: ${ProfileCard.info.name}`);\nconsole.log(`   Title: ${ProfileCard.info.title}`);\nconsole.log(`   Bio: ${ProfileCard.info.bio}\\n`);\n\nconsole.log('📊 STATS');\nconsole.log(`   Wrapper: ${ProfileCard.stats.wrapper}`);\nconsole.log(`   Number: ${ProfileCard.stats.number}`);\nconsole.log(`   Label: ${ProfileCard.stats.label}\\n`);\n\nconsole.log('🔘 BUTTONS');\nconsole.log(`   Primary: ${ProfileCard.buttons.primary}`);\nconsole.log(`   Secondary: ${ProfileCard.buttons.secondary}\\n`);\n\n// Visual representation\nconsole.log('\\n═══════════════════════════════');\nconsole.log('     Visual Representation');\nconsole.log('═══════════════════════════════\\n');\n\nconsole.log('┌─────────────────────────────────────┐');\nconsole.log('│                                     │');\nconsole.log('│            ╭─────────╮              │');\nconsole.log('│            │   SJ    │              │');\nconsole.log('│            ╰─────────╯              │');\nconsole.log('│                                     │');\nconsole.log('│          Sarah Johnson              │');\nconsole.log('│         Product Designer            │');\nconsole.log('│          📍 San Francisco           │');\nconsole.log('│                                     │');\nconsole.log('│    Creating beautiful, functional   │');\nconsole.log('│    products that users love.        │');\nconsole.log('│                                     │');\nconsole.log('│  ─────────────────────────────────  │');\nconsole.log('│                                     │');\nconsole.log('│     234         89         12.4k    │');\nconsole.log('│    POSTS      PROJECTS    FOLLOWERS │');\nconsole.log('│                                     │');\nconsole.log('│  ┌──────────┐  ┌──────────────────┐ │');\nconsole.log('│  │  Follow  │  │     Message      │ │');\nconsole.log('│  └──────────┘  └──────────────────┘ │');\nconsole.log('│                                     │');\nconsole.log('└─────────────────────────────────────┘');\n\nconsole.log('\\n\\n═══════════════════════════════');\nconsole.log('       Key Tailwind Classes');\nconsole.log('═══════════════════════════════');\nconsole.log('• Layout: flex, justify-center, items-center, gap-*');\nconsole.log('• Spacing: p-*, m-*, mt-*, px-*');\nconsole.log('• Colors: bg-*, text-*, ring-*');\nconsole.log('• Typography: text-*, font-*');\nconsole.log('• Borders: rounded-*, border-*');\nconsole.log('• Effects: shadow-*, hover:*, transition-*');\nconsole.log('• Dark Mode: dark:bg-*, dark:text-*');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Card has proper Tailwind classes",
                  "expectedOutput": "rounded",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use bg-white, rounded-xl, shadow-lg for the card container"
                },
                {
                  "level": 2,
                  "text": "Use flex and justify-center to center the avatar"
                },
                {
                  "level": 3,
                  "text": "Add hover: prefixes for interactive states"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using dynamic class names like bg-${color}-500",
                  "consequence": "Tailwind purges classes it can't detect at build time",
                  "correction": "Use complete class names and map them to values"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-14",
      "title": "Module 14: Full-Stack Integration - Connecting Front-End & Back-End",
      "description": "Build complete full-stack applications by connecting React front-ends with Node.js/Hono backends and Prisma databases",
      "difficulty": "advanced",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "14.1",
          "title": "Full-Stack Architecture (The Restaurant Analogy)",
          "moduleId": "module-14",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "A restaurant has three main areas:\n\nDining Room (Front-End - React):\n- Where customers sit and interact\n- Beautiful presentation, easy to use\n- Menus, ordering interface, displays\n\nKitchen (Back-End - Node.js/Hono):\n- Where the real work happens\n- Receives orders, processes them\n- Business logic, data processing\n\nStorage Room (Database - Prisma/PostgreSQL):\n- Where ingredients are stored\n- Organized, persistent, reliable\n- Data that survives shutdowns\n\nWaiter (API):\n- Carries messages between dining room and kitchen\n- Takes orders from customers to chefs\n- Brings food from kitchen to customers\n\nFull-stack development means building ALL THREE parts and making them work together seamlessly!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Full-Stack Architecture Overview (Modern Stack)\n\n// FRONTEND (React) - What users see\nlet frontEnd = {\n  technology: 'React 19',\n  responsibilities: [\n    'User interface (buttons, forms, displays)',\n    'User interactions (clicks, typing)',\n    'API calls to backend',\n    'Display data from backend'\n  ],\n  example: 'Login form, dashboard, user profile page'\n};\n\nconsole.log('Frontend:', frontEnd);\n\n// BACKEND (Node.js + Hono) - Business logic\nlet backEnd = {\n  technology: 'Node.js 24 + Hono 4',\n  responsibilities: [\n    'API endpoints (routes)',\n    'Authentication & authorization',\n    'Business logic (validation, calculations)',\n    'Database operations',\n    'Security'\n  ],\n  example: 'POST /api/login, GET /api/users, PUT /api/profile'\n};\n\nconsole.log('\\nBackend:', backEnd);\n\n// DATABASE (PostgreSQL + Prisma) - Data storage\nlet database = {\n  technology: 'PostgreSQL + Prisma ORM',\n  responsibilities: [\n    'Store data persistently',\n    'Relationships between data',\n    'Query optimization',\n    'Data integrity'\n  ],\n  example: 'Users table, Posts table, Comments table'\n};\n\nconsole.log('\\nDatabase:', database);\n\n// HOW THEY COMMUNICATE (Example flow)\nconsole.log('\\n=== Full-Stack Data Flow ===\\n');\n\nfunction simulateFullStackFlow() {\n  console.log('1. USER ACTION: User clicks \"Login\" button in React');\n  console.log('   Frontend: <button onClick={handleLogin}>Login</button>');\n  \n  console.log('\\n2. FRONTEND: React sends HTTP request to backend');\n  console.log('   fetch(\"/api/login\", { method: \"POST\", body: { email, password } })');\n  \n  console.log('\\n3. BACKEND: Hono receives request at route');\n  console.log('   app.post(\"/api/login\", async (c) => { ... })');\n  \n  console.log('\\n4. BACKEND: Queries database via Prisma');\n  console.log('   const user = await prisma.user.findUnique({ where: { email } });');\n  \n  console.log('\\n5. DATABASE: Returns user data to backend');\n  console.log('   { id: 1, email: \"user@example.com\", name: \"Alice\" }');\n  \n  console.log('\\n6. BACKEND: Sends JSON response to frontend');\n  console.log('   return c.json({ success: true, user: { id: 1, name: \"Alice\" } });');\n  \n  console.log('\\n7. FRONTEND: React receives data and updates UI');\n  console.log('   setUser(data.user); // State update triggers re-render');\n  \n  console.log('\\n8. USER SEES: Dashboard with their name displayed');\n  console.log('   <h1>Welcome, {user.name}!</h1>');\n}\n\nsimulateFullStackFlow();\n\n// TECH STACK OPTIONS\nlet stacks = {\n  'Modern Stack': 'PostgreSQL + Hono + React + Node.js (recommended)',\n  PERN: 'PostgreSQL + Express + React + Node.js (legacy)',\n  MERN: 'MongoDB + Express + React + Node.js (legacy)',\n  'T3 Stack': 'TypeScript + tRPC + Tailwind + Prisma + Next.js'\n};\n\nconsole.log('\\nPopular Full-Stack Combinations:');\nfor (let [name, stack] of Object.entries(stacks)) {\n  console.log(`${name}: ${stack}`);\n}\n\nconsole.log('\\nWe\\'ll use: Hono + Prisma + React + TypeScript (modern, edge-ready)');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Full-Stack architecture explained:\n\n1. **Frontend (Client-Side)**:\n   - Runs in user's browser\n   - React components, HTML, CSS, JavaScript\n   - Makes HTTP requests to backend\n   - Port 3000 (development)\n\n2. **Backend (Server-Side)**:\n   - Runs on server (Node.js)\n   - Hono routes handle requests\n   - Connects to database\n   - Port 4000 or 5000 (development)\n\n3. **Database**:\n   - PostgreSQL server\n   - Stores all application data\n   - Accessed via Prisma ORM\n   - Port 5432 (default)\n\n4. **Communication (HTTP/REST)**:\n   ```javascript\n   // Frontend makes request\n   fetch('http://localhost:4000/api/users')\n     .then(res => res.json())\n     .then(users => setUsers(users));\n   \n   // Backend handles request (Hono)\n   app.get('/api/users', async (c) => {\n     const users = await prisma.user.findMany();\n     return c.json(users);\n   });\n   ```\n\n5. **CORS** (Cross-Origin Resource Sharing):\n   - Frontend and backend on different ports = different origins\n   - Need to enable CORS on backend:\n   ```javascript\n   import { Hono } from 'hono';\n   import { cors } from 'hono/cors';\n   const app = new Hono();\n   app.use('*', cors());\n   ```\n\n6. **Environment Variables**:\n   - Frontend: VITE_API_URL=http://localhost:4000\n   - Backend: DATABASE_URL=postgresql://...\n   - Never commit secrets to Git!"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common full-stack mistakes:\n\n1. **CORS errors**:\n   ```\n   Error: Access to fetch at 'http://localhost:4000/api/users' from origin 'http://localhost:3000' \n   has been blocked by CORS policy\n   ```\n   Solution: Enable CORS on backend (Hono):\n   ```javascript\n   import { Hono } from 'hono';\n   import { cors } from 'hono/cors';\n   const app = new Hono();\n   app.use('*', cors());\n   ```\n\n2. **Wrong API URLs**:\n   ```javascript\n   // Wrong! (missing http://)\n   fetch('localhost:4000/api/users')\n   \n   // Correct!\n   fetch('http://localhost:4000/api/users')\n   \n   // Better! (use environment variable)\n   fetch(`${import.meta.env.VITE_API_URL}/api/users`)\n   ```\n\n3. **Frontend and backend not running**:\n   - Need TWO terminal windows:\n     * Terminal 1: `cd frontend && npm run dev` (port 3000)\n     * Terminal 2: `cd backend && npm run dev` (port 4000)\n\n4. **Not handling async properly**:\n   ```javascript\n   // Wrong!\n   let users = fetch('/api/users'); // Returns Promise!\n   console.log(users); // Promise, not data\n   \n   // Correct!\n   let response = await fetch('/api/users');\n   let users = await response.json();\n   console.log(users); // Actual data\n   ```\n\n5. **Hardcoded URLs**:\n   - Don't hardcode: `http://localhost:4000`\n   - Use env variables: `process.env.API_URL`\n   - Different in dev vs production!\n\n6. **Not validating data**:\n   - Validate on frontend (UX)\n   - ALSO validate on backend (security)\n   - Never trust client data!\n\n7. **Accessing request data in Hono**:\n   ```javascript\n   // Hono route\n   app.post('/api/users/:id', async (c) => {\n     c.req.param('id')           // From URL: /api/users/123\n     c.req.query('name')         // From query: ?name=alice\n     const body = await c.req.json()  // From POST body\n     body.email                  // { email: '...' }\n   });\n   ```\n\n8. **Storing JWT tokens in localStorage** (security risk!):\n   ```javascript\n   // RISKY! localStorage is vulnerable to XSS attacks\n   localStorage.setItem('token', jwtToken);\n   \n   // BETTER: Use httpOnly cookies (set by backend)\n   // Backend sets cookie (Hono):\n   import { setCookie } from 'hono/cookie';\n   setCookie(c, 'token', jwtToken, {\n     httpOnly: true,  // Can't be accessed by JavaScript!\n     secure: true,    // Only sent over HTTPS\n     sameSite: 'Strict'\n   });\n   \n   // Frontend automatically sends cookies with credentials:\n   fetch('/api/protected', { credentials: 'include' });\n   ```\n   - httpOnly cookies can't be stolen via XSS\n   - For SPAs, consider short-lived tokens + refresh tokens"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Express Equivalent",
              "legacy": "express",
              "content": "If you encounter older codebases using Express, here's how the patterns compare. Express was the dominant Node.js framework before Hono.",
              "code": "// Express Full-Stack Setup\nimport express from 'express';\nimport cors from 'cors';\n\nconst app = express();\n\n// CORS middleware (separate package)\napp.use(cors());\napp.use(express.json());\n\n// Route handling uses (req, res)\napp.get('/api/users', async (req, res) => {\n  const users = await prisma.user.findMany();\n  res.json(users);\n});\n\n// Request data access\napp.post('/api/users/:id', (req, res) => {\n  req.params.id    // URL params\n  req.query.name   // Query string\n  req.body.email   // POST body (needs express.json())\n});\n\n// Cookies\nres.cookie('token', jwtToken, {\n  httpOnly: true,\n  secure: true,\n  sameSite: 'strict'\n});",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13.1-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a full-stack data flow:\n\n1. Create a `frontend` object with a method `fetchUsers()` that:\n   - Logs \"Sending GET request to /api/users\"\n   - Calls backend.handleGetUsers()\n   - Logs the result\n\n2. Create a `backend` object with method `handleGetUsers()` that:\n   - Logs \"Backend received request\"\n   - Calls database.getUsers()\n   - Returns the result\n\n3. Create a `database` object with method `getUsers()` that:\n   - Returns array of mock users\n\nTest the complete flow.",
              "instructions": "Simulate a full-stack data flow:\n\n1. Create a `frontend` object with a method `fetchUsers()` that:\n   - Logs \"Sending GET request to /api/users\"\n   - Calls backend.handleGetUsers()\n   - Logs the result\n\n2. Create a `backend` object with method `handleGetUsers()` that:\n   - Logs \"Backend received request\"\n   - Calls database.getUsers()\n   - Returns the result\n\n3. Create a `database` object with method `getUsers()` that:\n   - Returns array of mock users\n\nTest the complete flow.",
              "starterCode": "// Database layer\nlet database = {\n  users: [\n    { id: 1, name: 'Alice', email: 'alice@example.com' },\n    { id: 2, name: 'Bob', email: 'bob@example.com' }\n  ],\n  \n  getUsers() {\n    console.log('[Database] Querying users table');\n    return this.users;\n  }\n};\n\n// Backend layer\nlet backend = {\n  handleGetUsers() {\n    console.log('[Backend] Received GET /api/users');\n    let users = database.getUsers();\n    console.log('[Backend] Sending response:', users.length, 'users');\n    return users;\n  }\n};\n\n// Frontend layer  \nlet frontend = {\n  fetchUsers() {\n    console.log('[Frontend] Fetching users from API');\n    let users = backend.handleGetUsers();\n    console.log('[Frontend] Received users:', users);\n    return users;\n  }\n};\n\n// Test the full stack\nconsole.log('=== Full-Stack Simulation ===\\n');\nfrontend.fetchUsers();",
              "solution": "// Complete full-stack simulation\n\n// Database layer\nlet database = {\n  users: [\n    { id: 1, name: 'Alice', email: 'alice@example.com' },\n    { id: 2, name: 'Bob', email: 'bob@example.com' },\n    { id: 3, name: 'Charlie', email: 'charlie@example.com' }\n  ],\n  \n  getUsers() {\n    console.log('[Database] Executing: SELECT * FROM users');\n    return this.users;\n  },\n  \n  getUserById(id) {\n    console.log(`[Database] Executing: SELECT * FROM users WHERE id = ${id}`);\n    return this.users.find(u => u.id === id);\n  },\n  \n  createUser(name, email) {\n    console.log(`[Database] Executing: INSERT INTO users (name, email) VALUES ('${name}', '${email}')`);\n    let newUser = { id: this.users.length + 1, name, email };\n    this.users.push(newUser);\n    return newUser;\n  }\n};\n\n// Backend layer\nlet backend = {\n  handleGetUsers() {\n    console.log('[Backend] GET /api/users');\n    let users = database.getUsers();\n    console.log(`[Backend] Response: 200 OK (${users.length} users)`);\n    return { status: 200, data: users };\n  },\n  \n  handleGetUser(id) {\n    console.log(`[Backend] GET /api/users/${id}`);\n    let user = database.getUserById(id);\n    if (user) {\n      console.log('[Backend] Response: 200 OK');\n      return { status: 200, data: user };\n    } else {\n      console.log('[Backend] Response: 404 Not Found');\n      return { status: 404, error: 'User not found' };\n    }\n  },\n  \n  handleCreateUser(name, email) {\n    console.log(`[Backend] POST /api/users`);\n    let newUser = database.createUser(name, email);\n    console.log('[Backend] Response: 201 Created');\n    return { status: 201, data: newUser };\n  }\n};\n\n// Frontend layer\nlet frontend = {\n  state: { users: [], currentUser: null },\n  \n  async fetchUsers() {\n    console.log('[Frontend] User clicked \"View Users\" button');\n    console.log('[Frontend] fetch(\"http://localhost:4000/api/users\")');\n    \n    let response = backend.handleGetUsers();\n    \n    if (response.status === 200) {\n      this.state.users = response.data;\n      console.log('[Frontend] State updated, re-rendering UI');\n      console.log('[Frontend] Displaying:', this.state.users.length, 'users');\n    }\n    \n    return this.state.users;\n  },\n  \n  async fetchUser(id) {\n    console.log(`[Frontend] User clicked on user ${id}`);\n    console.log(`[Frontend] fetch(\"http://localhost:4000/api/users/${id}\")`);\n    \n    let response = backend.handleGetUser(id);\n    \n    if (response.status === 200) {\n      this.state.currentUser = response.data;\n      console.log('[Frontend] Displaying user profile:', response.data.name);\n    } else {\n      console.log('[Frontend] Showing error: User not found');\n    }\n  },\n  \n  async createUser(name, email) {\n    console.log('[Frontend] User submitted \"Create User\" form');\n    console.log(`[Frontend] fetch(\"http://localhost:4000/api/users\", { method: \"POST\", body: { name, email } })`);\n    \n    let response = backend.handleCreateUser(name, email);\n    \n    if (response.status === 201) {\n      console.log('[Frontend] Success! Refreshing user list...');\n      this.fetchUsers();\n    }\n  }\n};\n\n// Simulate full-stack application\nconsole.log('=== Full-Stack Application Flow ===\\n');\n\nconsole.log('--- Scenario 1: List all users ---');\nfrontend.fetchUsers();\n\nconsole.log('\\n--- Scenario 2: View specific user ---');\nfrontend.fetchUser(1);\n\nconsole.log('\\n--- Scenario 3: Create new user ---');\nfrontend.createUser('Diana', 'diana@example.com');\n\nconsole.log('\\n--- Final database state ---');\nconsole.log('Total users:', database.users.length);\nconsole.log('Users:', database.users.map(u => u.name).join(', '));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should simulate complete flow",
                  "expectedOutput": "1",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Chain the method calls: frontend → backend → database → backend → frontend"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common full-stack mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common full-stack mistakes:"
                },
                {
                  "mistake": "**CORS errors**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**CORS errors**:\n   ```\n   Error: Access to fetch at 'http://localhost:4000/api/users' from origin 'http://localhost:3000' \n   has been blocked by CORS policy\n   ```\n   Solution: Enable CORS on backend:\n   ```javascript\n   import cors from 'cors';\n   app.use(cors());\n   ```"
                },
                {
                  "mistake": "**Wrong API URLs**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong API URLs**:\n   ```javascript\n   // Wrong! (missing http://)\n   fetch('localhost:4000/api/users')\n   \n   // Correct!\n   fetch('http://localhost:4000/api/users')\n   \n   // Better! (use environment variable)\n   fetch(`${import.meta.env.VITE_API_URL}/api/users`)\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14.2",
          "title": "CORS - The #1 Error You'll Encounter (The Bouncer Analogy)",
          "moduleId": "module-14",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a nightclub with a strict bouncer:\n\nClub Rules:\n- Only people from the guest list can enter\n- The bouncer checks your ID and origin\n- If you're not on the list → DENIED!\n\nWeb Browser:\n- Your React app runs on http://localhost:3000 (origin A)\n- Your Hono API runs on http://localhost:4000 (origin B)\n- Browser: 'These are DIFFERENT addresses!'\n- Browser acts as bouncer: 'Can origin A talk to origin B?'\n\nCORS = Cross-Origin Resource Sharing:\n- Security feature built into ALL browsers\n- Prevents malicious websites from stealing data\n- By default: BLOCKS all cross-origin requests\n- You must EXPLICITLY allow your frontend to talk to your backend\n\nThe Fix:\n- Backend says: 'Yes, localhost:3000 is on the guest list'\n- Uses CORS headers to tell browser: 'This is allowed'\n- One line of code: app.use('*', cors())\n\nWithout CORS configuration → Every API call FAILS!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// CORS - The #1 Full-Stack Error (and how to fix it!)\n\nconsole.log('=== CORS Error Simulation ===\\n');\n\n// THE PROBLEM: Different origins\nlet origins = {\n  frontend: 'http://localhost:3000',\n  backend: 'http://localhost:4000'\n};\n\nconsole.log('Frontend origin:', origins.frontend);\nconsole.log('Backend origin:', origins.backend);\nconsole.log('\\nAre these the same origin?', origins.frontend === origins.backend);\nconsole.log('Result: DIFFERENT ORIGINS → Browser blocks by default!\\n');\n\n// What makes origins different?\nfunction analyzeOrigins() {\n  let examples = [\n    {\n      url1: 'http://localhost:3000',\n      url2: 'http://localhost:4000',\n      same: false,\n      reason: 'Different PORT'\n    },\n    {\n      url1: 'http://example.com',\n      url2: 'https://example.com',\n      same: false,\n      reason: 'Different PROTOCOL (http vs https)'\n    },\n    {\n      url1: 'http://example.com',\n      url2: 'http://api.example.com',\n      same: false,\n      reason: 'Different SUBDOMAIN'\n    },\n    {\n      url1: 'http://localhost:3000/page1',\n      url2: 'http://localhost:3000/page2',\n      same: true,\n      reason: 'Same protocol, domain, port (path doesn\\'t matter)'\n    }\n  ];\n  \n  console.log('=== What Makes Origins Different? ===\\n');\n  examples.forEach(ex => {\n    console.log(`${ex.url1}`);\n    console.log(`${ex.url2}`);\n    console.log(`Same origin? ${ex.same ? 'YES' : 'NO'}`);\n    console.log(`Reason: ${ex.reason}\\n`);\n  });\n}\n\nanalyzeOrigins();\n\n// THE ERROR students will see\nfunction simulateCORSError() {\n  console.log('=== The Error Message ===\\n');\n  console.log('Access to fetch at \\'http://localhost:4000/api/users\\' from origin');\n  console.log('   \\'http://localhost:3000\\' has been blocked by CORS policy:');\n  console.log('   No \\'Access-Control-Allow-Origin\\' header is present on the');\n  console.log('   requested resource.\\n');\n  console.log('Translation: Your backend didn\\'t give permission!\\n');\n}\n\nsimulateCORSError();\n\n// THE SOLUTION (Hono)\nconsole.log('=== The Fix (Hono Backend Code) ===\\n');\nconsole.log('// Hono has built-in CORS middleware - no extra package needed!\\n');\n\nconsole.log('// Import Hono and its CORS middleware');\nconsole.log('import { Hono } from \"hono\";');\nconsole.log('import { cors } from \"hono/cors\";  // Built-in!\\n');\n\nconsole.log('const app = new Hono();\\n');\n\nconsole.log('// THIS ONE LINE FIXES THE ERROR!');\nconsole.log('app.use(\"*\", cors());  // Allows ALL origins (dev only!)\\n');\n\nconsole.log('// Now your routes work');\nconsole.log('app.get(\"/api/users\", (c) => {');\nconsole.log('  return c.json([{ id: 1, name: \"Alice\" }]);');\nconsole.log('});\\n');\n\n// More secure CORS configuration\nconsole.log('=== Production CORS (More Secure) ===\\n');\nconsole.log('// Only allow specific origin');\nconsole.log('app.use(\"*\", cors({');\nconsole.log('  origin: \"https://myapp.com\",  // Only this domain allowed');\nconsole.log('  credentials: true,             // Allow cookies');\nconsole.log('  allowMethods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"]  // Allowed HTTP methods');\nconsole.log('}));\\n');\n\nconsole.log('// Multiple allowed origins');\nconsole.log('const allowedOrigins = [');\nconsole.log('  \"http://localhost:3000\",  // Dev');\nconsole.log('  \"https://myapp.com\",      // Production');\nconsole.log('  \"https://staging.myapp.com\"  // Staging');\nconsole.log('];\\n');\n\nconsole.log('app.use(\"*\", cors({');\nconsole.log('  origin: (origin) => {');\nconsole.log('    if (allowedOrigins.includes(origin)) {');\nconsole.log('      return origin;');\nconsole.log('    }');\nconsole.log('    return null;  // Deny other origins');\nconsole.log('  }');\nconsole.log('}));\\n');\n\n// What CORS actually does\nconsole.log('=== What CORS Does (Under the Hood) ===\\n');\nconsole.log('When you use app.use(\"*\", cors()), it adds these headers:\\n');\n\nlet corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization'\n};\n\nfor (let [header, value] of Object.entries(corsHeaders)) {\n  console.log(`${header}: ${value}`);\n}\n\nconsole.log('\\nThese headers tell the browser: \"It\\'s OK, I allow this!\"\\n');\n\n// Common CORS scenarios\nconsole.log('=== Common CORS Scenarios ===\\n');\n\nlet scenarios = [\n  {\n    scenario: 'React dev server calling Hono API',\n    frontend: 'http://localhost:3000',\n    backend: 'http://localhost:4000',\n    needsCORS: true,\n    solution: 'app.use(\"*\", cors())'\n  },\n  {\n    scenario: 'Production frontend calling production API',\n    frontend: 'https://myapp.com',\n    backend: 'https://api.myapp.com',\n    needsCORS: true,\n    solution: 'app.use(\"*\", cors({ origin: \"https://myapp.com\" }))'\n  },\n  {\n    scenario: 'React and API on same domain (proxy)',\n    frontend: 'https://myapp.com',\n    backend: 'https://myapp.com/api',\n    needsCORS: false,\n    solution: 'No CORS needed - same origin!'\n  }\n];\n\nscenarios.forEach((s, i) => {\n  console.log(`Scenario ${i + 1}: ${s.scenario}`);\n  console.log(`  Frontend: ${s.frontend}`);\n  console.log(`  Backend:  ${s.backend}`);\n  console.log(`  CORS needed? ${s.needsCORS ? 'YES' : 'NO'}`);\n  console.log(`  Solution: ${s.solution}\\n`);\n});\n\n// Debugging CORS\nconsole.log('=== Debugging CORS Errors ===\\n');\nlet debugSteps = [\n  '1. Check if both frontend and backend are running',\n  '2. Verify the URLs match (no typos)',\n  '3. Check backend has app.use(\"*\", cors()) BEFORE routes',\n  '4. Look in browser Network tab -> Response headers',\n  '5. Should see: Access-Control-Allow-Origin header',\n  '6. Try curl or Postman (they bypass CORS) to test API',\n  '7. Clear browser cache and restart dev servers'\n];\n\ndebugSteps.forEach(step => console.log(step));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "CORS configuration in Hono explained:\n\n1. **No extra package needed!** Hono has built-in CORS:\n   ```javascript\n   import { Hono } from 'hono';\n   import { cors } from 'hono/cors';  // Built-in!\n   ```\n\n2. **Basic CORS (allows all origins)**:\n   ```javascript\n   const app = new Hono();\n   app.use('*', cors());  // Must be BEFORE routes!\n   ```\n\n3. **Specific origin only** (recommended for production):\n   ```javascript\n   app.use('*', cors({\n     origin: 'https://myapp.com'\n   }));\n   ```\n\n4. **Multiple origins**:\n   ```javascript\n   const allowedOrigins = [\n     'http://localhost:3000',\n     'https://myapp.com'\n   ];\n   \n   app.use('*', cors({\n     origin: (origin) => {\n       if (allowedOrigins.includes(origin)) {\n         return origin;\n       }\n       return null;  // Deny\n     }\n   }));\n   ```\n\n5. **With credentials** (cookies, auth headers):\n   ```javascript\n   app.use('*', cors({\n     origin: 'http://localhost:3000',\n     credentials: true  // Allow cookies\n   }));\n   \n   // Frontend must also set:\n   fetch('http://localhost:4000/api/users', {\n     credentials: 'include'  // Send cookies\n   });\n   ```\n\n6. **Environment-based CORS**:\n   ```javascript\n   app.use('*', cors({\n     origin: process.env.NODE_ENV === 'production'\n       ? 'https://myapp.com'\n       : 'http://localhost:3000'\n   }));\n   ```\n\n7. **Preflight requests** (OPTIONS):\n   - Browser sends OPTIONS request first for PUT/DELETE/custom headers\n   - Hono CORS middleware handles this automatically\n   ```javascript\n   // This happens automatically with app.use('*', cors())\n   // No extra code needed!\n   ```\n\n8. **Manual CORS headers** (if not using middleware):\n   ```javascript\n   app.use('*', async (c, next) => {\n     c.header('Access-Control-Allow-Origin', '*');\n     c.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n     c.header('Access-Control-Allow-Headers', 'Content-Type');\n     await next();\n   });\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common CORS mistakes:\n\n1. **CORS middleware placed AFTER routes**:\n   ```javascript\n   // WRONG!\n   app.get('/api/users', (c) => { ... });\n   app.use('*', cors());  // Too late! Routes already defined\n   \n   // CORRECT!\n   app.use('*', cors());  // BEFORE routes!\n   app.get('/api/users', (c) => { ... });\n   ```\n\n2. **With Hono, CORS is built-in** - no package to install:\n   ```javascript\n   // Hono - built-in!\n   import { cors } from 'hono/cors';\n   ```\n\n3. **Using wrong origin in production**:\n   ```javascript\n   // WRONG in production!\n   app.use('*', cors({ origin: 'http://localhost:3000' }));\n   \n   // CORRECT - use environment variable\n   app.use('*', cors({ \n     origin: process.env.FRONTEND_URL  // https://myapp.com\n   }));\n   ```\n\n4. **Allowing all origins in production** (security risk!):\n   ```javascript\n   // WRONG in production!\n   app.use('*', cors());  // Any site can call your API!\n   \n   // CORRECT - be specific\n   app.use('*', cors({ origin: 'https://myapp.com' }));\n   ```\n\n5. **Credentials without specific origin**:\n   ```javascript\n   // WRONG!\n   app.use('*', cors({\n     origin: '*',\n     credentials: true  // Error! Can't use * with credentials\n   }));\n   \n   // CORRECT!\n   app.use('*', cors({\n     origin: 'http://localhost:3000',  // Specific origin required\n     credentials: true\n   }));\n   ```\n\n6. **Frontend not sending credentials**:\n   ```javascript\n   // Backend allows credentials\n   app.use('*', cors({ origin: '...', credentials: true }));\n   \n   // But frontend doesn't send them (cookies won't work!)\n   fetch('/api/users');  // WRONG!\n   \n   // CORRECT!\n   fetch('/api/users', { credentials: 'include' });\n   ```\n\n7. **Testing with curl/Postman and thinking CORS works**:\n   - curl and Postman BYPASS CORS (they're not browsers)\n   - Must test in actual browser!\n   ```bash\n   # This works even without CORS (not a browser!)\n   curl http://localhost:4000/api/users\n   \n   # But browser will still block it\n   ```\n\n8. **Different protocols (http vs https)**:\n   ```javascript\n   // Frontend: https://myapp.com\n   // Backend:  http://api.myapp.com\n   // DIFFERENT protocols -> CORS error!\n   \n   // Both must be https in production\n   ```"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Express CORS Equivalent",
              "legacy": "express",
              "content": "Express requires installing a separate cors package. If you encounter older codebases, here's how Express CORS differs from Hono.",
              "code": "// Express CORS (requires npm install cors)\nimport express from 'express';\nimport cors from 'cors';  // Separate package!\n\nconst app = express();\n\n// Basic CORS\napp.use(cors());\n\n// With options\napp.use(cors({\n  origin: 'https://myapp.com',\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE']  // Note: 'methods' not 'allowMethods'\n}));\n\n// Multiple origins (callback style)\napp.use(cors({\n  origin: function(origin, callback) {\n    if (allowedOrigins.includes(origin)) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  }\n}));",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13.2-challenge",
              "title": "Practice Challenge",
              "description": "Simulate CORS checking:\n\n1. Create a `browser` object with method `checkCORS(frontendOrigin, backendOrigin)` that:\n   - Compares the two origins\n   - Returns true if same origin (protocol + domain + port match)\n   - Returns false if different origins\n\n2. Create a `backend` object with:\n   - `corsEnabled` property (boolean)\n   - `allowedOrigins` array\n   - `handleRequest(origin)` method that:\n     - If corsEnabled is false → returns 'CORS Error: Blocked!'\n     - If origin is in allowedOrigins → returns 'Request allowed'\n     - Otherwise → returns 'CORS Error: Origin not allowed'\n\n3. Test various scenarios",
              "instructions": "Simulate CORS checking:\n\n1. Create a `browser` object with method `checkCORS(frontendOrigin, backendOrigin)` that:\n   - Compares the two origins\n   - Returns true if same origin (protocol + domain + port match)\n   - Returns false if different origins\n\n2. Create a `backend` object with:\n   - `corsEnabled` property (boolean)\n   - `allowedOrigins` array\n   - `handleRequest(origin)` method that:\n     - If corsEnabled is false → returns 'CORS Error: Blocked!'\n     - If origin is in allowedOrigins → returns 'Request allowed'\n     - Otherwise → returns 'CORS Error: Origin not allowed'\n\n3. Test various scenarios",
              "starterCode": "// CORS Simulation\n\nfunction parseOrigin(url) {\n  // Extract protocol, domain, port\n  let match = url.match(/(https?):\\/\\/([^:\\/]+)(?::(\\d+))?/);\n  return {\n    protocol: match[1],\n    domain: match[2],\n    port: match[3] || (match[1] === 'https' ? '443' : '80')\n  };\n}\n\nlet browser = {\n  checkCORS(frontendOrigin, backendOrigin) {\n    let f = parseOrigin(frontendOrigin);\n    let b = parseOrigin(backendOrigin);\n    \n    let sameOrigin = f.protocol === b.protocol &&\n                     f.domain === b.domain &&\n                     f.port === b.port;\n    \n    return sameOrigin;\n  }\n};\n\nlet backend = {\n  corsEnabled: true,\n  allowedOrigins: ['http://localhost:3000', 'https://myapp.com'],\n  \n  handleRequest(origin) {\n    if (!this.corsEnabled) {\n      return 'CORS Error: Blocked!';\n    }\n    \n    if (this.allowedOrigins.includes(origin)) {\n      return 'Request allowed';\n    }\n    \n    return 'CORS Error: Origin not allowed';\n  }\n};\n\n// Test scenarios\nconsole.log('=== CORS Tests ===\\n');\n\nlet tests = [\n  ['http://localhost:3000', 'http://localhost:4000'],\n  ['http://localhost:3000', 'http://localhost:3000'],\n  ['https://myapp.com', 'https://api.myapp.com']\n];\n\ntests.forEach(([frontend, api]) => {\n  console.log(`Frontend: ${frontend}`);\n  console.log(`Backend:  ${api}`);\n  console.log(`Same origin? ${browser.checkCORS(frontend, api)}`);\n  console.log(`Backend says: ${backend.handleRequest(frontend)}\\n`);\n});",
              "solution": "// Complete CORS simulation\n\nfunction parseOrigin(url) {\n  let match = url.match(/(https?):\\/\\/([^:\\/]+)(?::(\\d+))?/);\n  return {\n    protocol: match[1],\n    domain: match[2],\n    port: match[3] || (match[1] === 'https' ? '443' : '80'),\n    full: `${match[1]}://${match[2]}:${match[3] || (match[1] === 'https' ? '443' : '80')}`\n  };\n}\n\nlet browser = {\n  checkCORS(frontendOrigin, backendOrigin) {\n    let f = parseOrigin(frontendOrigin);\n    let b = parseOrigin(backendOrigin);\n    \n    let sameOrigin = f.protocol === b.protocol &&\n                     f.domain === b.domain &&\n                     f.port === b.port;\n    \n    console.log(`[Browser] Checking origins...`);\n    console.log(`  Frontend: ${f.protocol}://${f.domain}:${f.port}`);\n    console.log(`  Backend:  ${b.protocol}://${b.domain}:${b.port}`);\n    console.log(`  Same origin? ${sameOrigin}`);\n    \n    return sameOrigin;\n  },\n  \n  makeRequest(frontendOrigin, backendOrigin, backendObj) {\n    let sameOrigin = this.checkCORS(frontendOrigin, backendOrigin);\n    \n    if (sameOrigin) {\n      console.log('[Browser] Same origin - request allowed!\\n');\n      return { allowed: true, reason: 'Same origin' };\n    }\n    \n    console.log('[Browser] Different origin - checking CORS headers...');\n    let result = backendObj.handleRequest(frontendOrigin);\n    console.log(`[Browser] ${result}\\n`);\n    \n    return { allowed: result.includes('allowed'), reason: result };\n  }\n};\n\nlet backend = {\n  corsEnabled: true,\n  allowedOrigins: ['http://localhost:3000', 'https://myapp.com'],\n  allowCredentials: false,\n  \n  handleRequest(origin) {\n    console.log(`[Backend] Received request from: ${origin}`);\n    \n    if (!this.corsEnabled) {\n      console.log('[Backend] CORS is disabled - blocking all cross-origin requests');\n      return 'CORS Error: No Access-Control-Allow-Origin header';\n    }\n    \n    if (this.allowedOrigins.includes('*')) {\n      console.log('[Backend] CORS allows all origins (*)');  \n      return 'Request allowed (all origins)';\n    }\n    \n    if (this.allowedOrigins.includes(origin)) {\n      console.log(`[Backend] Origin ${origin} is in allowed list`);\n      console.log('[Backend] Adding header: Access-Control-Allow-Origin:', origin);\n      return 'Request allowed';\n    }\n    \n    console.log(`[Backend] Origin ${origin} is NOT in allowed list`);\n    console.log('[Backend] Blocking request');\n    return 'CORS Error: Origin not allowed';\n  },\n  \n  enableCORS(options = {}) {\n    this.corsEnabled = true;\n    if (options.origins) {\n      this.allowedOrigins = options.origins;\n    }\n    if (options.credentials) {\n      this.allowCredentials = options.credentials;\n    }\n    console.log('[Backend] CORS configured:', {\n      enabled: this.corsEnabled,\n      allowedOrigins: this.allowedOrigins,\n      credentials: this.allowCredentials\n    });\n  }\n};\n\n// Simulate different scenarios\nconsole.log('=== Scenario 1: React dev → Express API (CORS enabled) ===\\n');\nbackend.enableCORS({ origins: ['http://localhost:3000'] });\nbrowser.makeRequest('http://localhost:3000', 'http://localhost:4000', backend);\n\nconsole.log('=== Scenario 2: Same origin (no CORS needed) ===\\n');\nbrowser.makeRequest('http://localhost:3000', 'http://localhost:3000', backend);\n\nconsole.log('=== Scenario 3: Unauthorized origin (CORS blocks) ===\\n');\nbrowser.makeRequest('http://evil-site.com', 'http://localhost:4000', backend);\n\nconsole.log('=== Scenario 4: CORS disabled (everything blocked) ===\\n');\nbackend.corsEnabled = false;\nbrowser.makeRequest('http://localhost:3000', 'http://localhost:4000', backend);\n\nconsole.log('=== Scenario 5: Allow all origins (*) ===\\n');\nbackend.enableCORS({ origins: ['*'] });\nbrowser.makeRequest('http://any-site.com', 'http://localhost:4000', backend);\n\n// Summary\nconsole.log('\\n=== CORS Summary ===\\n');\nconsole.log('✓ Same origin = No CORS needed');\nconsole.log('✓ Different origin + CORS enabled + origin in list = Allowed');\nconsole.log('✗ Different origin + CORS disabled = Blocked');\nconsole.log('✗ Different origin + origin not in list = Blocked');\nconsole.log('\\n💡 Fix: Add app.use(cors()) to your Express backend!');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should detect same origin",
                  "expectedOutput": "true",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Should detect different ports",
                  "expectedOutput": "false",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Origins are same if protocol, domain, AND port all match"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common CORS mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common CORS mistakes:"
                },
                {
                  "mistake": "**CORS middleware placed AFTER routes**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**CORS middleware placed AFTER routes**:\n   ```javascript\n   // WRONG!\n   app.get('/api/users', (req, res) => { ... });\n   app.use(cors());  // Too late! Routes already defined\n   \n   // CORRECT!\n   app.use(cors());  // BEFORE routes!\n   app.get('/api/users', (req, res) => { ... });\n   ```"
                },
                {
                  "mistake": "**Forgot to install cors package**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgot to install cors package**:\n   ```bash\n   # Error: Cannot find module 'cors'\n   npm install cors\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14.3",
          "title": "Fetching Data with useEffect (The Automated Assistant Analogy)",
          "moduleId": "module-14",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine hiring an assistant for your office:\n\nManual Way (without useEffect):\n- Every morning YOU must remember to check the mailbox\n- YOU must remember to water the plants\n- YOU might forget → tasks don't get done\n\nAutomated Way (with useEffect):\n- Tell assistant: \"When you arrive (component mounts), check mail\"\n- Tell assistant: \"Every hour (dependency changes), water plants\"\n- Tell assistant: \"When you leave (component unmounts), lock doors\"\n- Assistant does these automatically → you don't have to remember!\n\nReact useEffect is your automated assistant:\n- Runs code automatically when component mounts\n- Runs code when specific values change\n- Cleanup when component unmounts\n- Perfect for fetching data from APIs!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// useEffect + fetch - Getting data from APIs\n\nconsole.log('=== useEffect for Data Fetching ===\\n');\n\n// Simulate React component lifecycle\nclass ComponentLifecycle {\n  constructor(name) {\n    this.name = name;\n    this.effects = [];\n    this.state = {};\n  }\n  \n  // Simulate useEffect\n  useEffect(callback, dependencies) {\n    console.log(`[${this.name}] Registering effect with dependencies:`, dependencies || 'none');\n    this.effects.push({ callback, dependencies });\n  }\n  \n  // Simulate component mount\n  mount() {\n    console.log(`\\n[${this.name}] Component mounting...`);\n    this.effects.forEach(effect => {\n      if (!effect.dependencies || effect.dependencies.length === 0) {\n        console.log(`[${this.name}] Running effect (runs on mount)`);\n        effect.callback();\n      }\n    });\n  }\n  \n  // Simulate state update\n  setState(newState) {\n    console.log(`\\n[${this.name}] State updating:`, newState);\n    let oldState = { ...this.state };\n    this.state = { ...this.state, ...newState };\n    \n    this.effects.forEach(effect => {\n      if (effect.dependencies) {\n        let changed = effect.dependencies.some(dep => {\n          return oldState[dep] !== this.state[dep];\n        });\n        if (changed) {\n          console.log(`[${this.name}] Dependency changed, re-running effect`);\n          effect.callback();\n        }\n      }\n    });\n  }\n}\n\n// Example 1: Fetch data on component mount\nconsole.log('=== Example 1: Fetch Users on Mount ===');\n\nlet UserList = new ComponentLifecycle('UserList');\n\nUserList.useEffect(() => {\n  console.log('[UserList] Fetching users from API...');\n  console.log('[UserList] fetch(\"http://localhost:4000/api/users\")');\n  \n  // Simulate API response\n  setTimeout(() => {\n    let users = [\n      { id: 1, name: 'Alice' },\n      { id: 2, name: 'Bob' }\n    ];\n    console.log('[UserList] Received:', users.length, 'users');\n    console.log('[UserList] setUsers(data) → triggers re-render');\n  }, 100);\n}, []); // Empty array = run once on mount\n\nUserList.mount();\n\n// Example 2: Fetch when dependency changes\nsetTimeout(() => {\n  console.log('\\n\\n=== Example 2: Fetch User Details When ID Changes ===');\n  \n  let UserProfile = new ComponentLifecycle('UserProfile');\n  UserProfile.state = { userId: null };\n  \n  UserProfile.useEffect(() => {\n    if (UserProfile.state.userId) {\n      console.log(`[UserProfile] Fetching user ${UserProfile.state.userId}...`);\n      console.log(`[UserProfile] fetch(\"http://localhost:4000/api/users/${UserProfile.state.userId}\")`);\n      \n      setTimeout(() => {\n        let user = { id: UserProfile.state.userId, name: 'Alice', email: 'alice@example.com' };\n        console.log('[UserProfile] Received:', user);\n      }, 100);\n    }\n  }, ['userId']); // Re-run when userId changes\n  \n  UserProfile.mount();\n  \n  // Simulate user clicking different profiles\n  setTimeout(() => {\n    console.log('\\n[User] Clicks on user 1');\n    UserProfile.setState({ userId: 1 });\n  }, 200);\n  \n  setTimeout(() => {\n    console.log('\\n[User] Clicks on user 2');\n    UserProfile.setState({ userId: 2 });\n  }, 400);\n}, 300);\n\n// Example 3: Real fetch pattern\nsetTimeout(() => {\n  console.log('\\n\\n=== Example 3: Complete Fetch Pattern ===\\n');\n  \n  console.log('// React component with useEffect\\n');\n  console.log('function UserList() {');\n  console.log('  const [users, setUsers] = useState([]);');\n  console.log('  const [loading, setLoading] = useState(true);');\n  console.log('  const [error, setError] = useState(null);\\n');\n  \n  console.log('  useEffect(() => {');\n  console.log('    async function fetchUsers() {');\n  console.log('      try {');\n  console.log('        setLoading(true);');\n  console.log('        const response = await fetch(\"http://localhost:4000/api/users\");');\n  console.log('        ');\n  console.log('        if (!response.ok) {');\n  console.log('          throw new Error(`HTTP error! status: ${response.status}`);');\n  console.log('        }');\n  console.log('        ');\n  console.log('        const data = await response.json();');\n  console.log('        setUsers(data);');\n  console.log('      } catch (err) {');\n  console.log('        setError(err.message);');\n  console.log('      } finally {');\n  console.log('        setLoading(false);');\n  console.log('      }');\n  console.log('    }\\n');\n  console.log('    fetchUsers();');\n  console.log('  }, []); // Run once on mount\\n');\n  \n  console.log('  if (loading) return <div>Loading...</div>;');\n  console.log('  if (error) return <div>Error: {error}</div>;');\n  \n  console.log('  return (');\n  console.log('    <ul>');\n  console.log('      {users.map(user => (');\n  console.log('        <li key={user.id}>{user.name}</li>');\n  console.log('      ))}');\n  console.log('    </ul>');\n  console.log('  );');\n  console.log('}');\n}, 800);\n\n// Dependency array explanation\nsetTimeout(() => {\n  console.log('\\n\\n=== useEffect Dependency Array ===\\n');\n  \n  let cases = [\n    {\n      code: 'useEffect(() => { ... });',\n      dependencies: 'NONE',\n      when: 'Every render (usually a mistake!)'\n    },\n    {\n      code: 'useEffect(() => { ... }, []);',\n      dependencies: '[] (empty)',\n      when: 'Once on mount only'\n    },\n    {\n      code: 'useEffect(() => { ... }, [userId]);',\n      dependencies: '[userId]',\n      when: 'On mount + whenever userId changes'\n    },\n    {\n      code: 'useEffect(() => { ... }, [userId, page]);',\n      dependencies: '[userId, page]',\n      when: 'On mount + when userId OR page changes'\n    }\n  ];\n  \n  cases.forEach(c => {\n    console.log(`${c.code}`);\n    console.log(`  Dependencies: ${c.dependencies}`);\n    console.log(`  Runs: ${c.when}\\n`);\n  });\n}, 1100);"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "useEffect with fetch explained:\n\n1. **Basic useEffect with fetch**:\n   ```jsx\n   import { useEffect, useState } from 'react';\n   \n   function UserList() {\n     const [users, setUsers] = useState([]);\n     \n     useEffect(() => {\n       fetch('http://localhost:4000/api/users')\n         .then(res => res.json())\n         .then(data => setUsers(data));\n     }, []); // Empty array = run once on mount\n     \n     return <div>{users.map(u => <div key={u.id}>{u.name}</div>)}</div>;\n   }\n   ```\n\n2. **With async/await** (recommended):\n   ```jsx\n   useEffect(() => {\n     async function fetchUsers() {\n       const response = await fetch('http://localhost:4000/api/users');\n       const data = await response.json();\n       setUsers(data);\n     }\n     \n     fetchUsers();\n   }, []);\n   ```\n\n3. **With loading and error states** (best practice):\n   ```jsx\n   const [users, setUsers] = useState([]);\n   const [loading, setLoading] = useState(true);\n   const [error, setError] = useState(null);\n   \n   useEffect(() => {\n     async function fetchUsers() {\n       try {\n         setLoading(true);\n         const res = await fetch('http://localhost:4000/api/users');\n         \n         if (!res.ok) {\n           throw new Error(`HTTP ${res.status}`);\n         }\n         \n         const data = await res.json();\n         setUsers(data);\n       } catch (err) {\n         setError(err.message);\n       } finally {\n         setLoading(false);\n       }\n     }\n     \n     fetchUsers();\n   }, []);\n   \n   if (loading) return <div>Loading...</div>;\n   if (error) return <div>Error: {error}</div>;\n   return <div>...</div>;\n   ```\n\n4. **Dependency array - fetch when value changes**:\n   ```jsx\n   const [userId, setUserId] = useState(1);\n   const [user, setUser] = useState(null);\n   \n   useEffect(() => {\n     fetch(`http://localhost:4000/api/users/${userId}`)\n       .then(res => res.json())\n       .then(data => setUser(data));\n   }, [userId]); // Re-fetch when userId changes\n   ```\n\n5. **Cleanup function** (abort requests):\n   ```jsx\n   useEffect(() => {\n     const controller = new AbortController();\n     \n     fetch('http://localhost:4000/api/users', {\n       signal: controller.signal\n     })\n       .then(res => res.json())\n       .then(data => setUsers(data))\n       .catch(err => {\n         if (err.name !== 'AbortError') {\n           setError(err.message);\n         }\n       });\n     \n     // Cleanup: abort fetch if component unmounts\n     return () => controller.abort();\n   }, []);\n   ```\n\n6. **POST request in useEffect**:\n   ```jsx\n   useEffect(() => {\n     async function createUser() {\n       const res = await fetch('http://localhost:4000/api/users', {\n         method: 'POST',\n         headers: { 'Content-Type': 'application/json' },\n         body: JSON.stringify({ name: 'Alice', email: 'alice@example.com' })\n       });\n       const newUser = await res.json();\n       console.log('Created:', newUser);\n     }\n     \n     createUser();\n   }, []);\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common useEffect + fetch mistakes:\n\n1. **Forgetting dependency array**:\n   ```jsx\n   // WRONG! Infinite loop!\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data)); // State update triggers re-render\n   }); // No dependency array → runs every render → infinite loop!\n   \n   // CORRECT!\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data));\n   }, []); // Empty array → run once\n   ```\n\n2. **Using async directly in useEffect**:\n   ```jsx\n   // WRONG!\n   useEffect(async () => {  // ← Can't do this!\n     const res = await fetch('/api/users');\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     async function fetchData() {  // Define async function inside\n       const res = await fetch('/api/users');\n     }\n     fetchData();  // Call it\n   }, []);\n   ```\n\n3. **Not handling loading/error states**:\n   ```jsx\n   // WRONG! (bad UX)\n   const [users, setUsers] = useState([]);\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data));\n   }, []);\n   return <div>{users.map(...)}</div>; // Empty while loading!\n   \n   // CORRECT!\n   const [users, setUsers] = useState([]);\n   const [loading, setLoading] = useState(true);\n   \n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => {\n         setUsers(data);\n         setLoading(false);\n       });\n   }, []);\n   \n   if (loading) return <div>Loading...</div>;\n   return <div>{users.map(...)}</div>;\n   ```\n\n4. **Not checking response.ok**:\n   ```jsx\n   // WRONG! (doesn't catch HTTP errors)\n   const res = await fetch('/api/users');\n   const data = await res.json(); // Fails if 404/500!\n   \n   // CORRECT!\n   const res = await fetch('/api/users');\n   if (!res.ok) {\n     throw new Error(`HTTP ${res.status}: ${res.statusText}`);\n   }\n   const data = await res.json();\n   ```\n\n5. **Missing cleanup (memory leaks)**:\n   ```jsx\n   // WRONG! (can cause \"Can't perform state update on unmounted component\")\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data)); // Component might unmount before this!\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     let cancelled = false;\n     \n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => {\n         if (!cancelled) {  // Only update if still mounted\n           setUsers(data);\n         }\n       });\n     \n     return () => {\n       cancelled = true;  // Cleanup\n     };\n   }, []);\n   ```\n\n6. **Wrong dependencies**:\n   ```jsx\n   function UserProfile({ userId }) {\n     const [user, setUser] = useState(null);\n     \n     // WRONG! (doesn't re-fetch when userId changes)\n     useEffect(() => {\n       fetch(`/api/users/${userId}`)\n         .then(res => res.json())\n         .then(data => setUser(data));\n     }, []); // Should include userId!\n     \n     // CORRECT!\n     useEffect(() => {\n       fetch(`/api/users/${userId}`)\n         .then(res => res.json())\n         .then(data => setUser(data));\n     }, [userId]); // Re-fetch when userId changes\n   }\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13.3-challenge",
              "title": "Practice Challenge",
              "description": "Build a complete data fetching flow:\n\n1. Create a `fetchUsers()` function that:\n   - Returns a Promise\n   - Simulates 1 second delay\n   - Resolves with array of mock users\n\n2. Create a `UserListComponent` object that:\n   - Has `state` with: users (array), loading (boolean), error (string|null)\n   - Has `mount()` method that simulates useEffect running\n   - In mount: sets loading true, calls fetchUsers, updates state\n\n3. Test by calling mount() and logging state changes",
              "instructions": "Build a complete data fetching flow:\n\n1. Create a `fetchUsers()` function that:\n   - Returns a Promise\n   - Simulates 1 second delay\n   - Resolves with array of mock users\n\n2. Create a `UserListComponent` object that:\n   - Has `state` with: users (array), loading (boolean), error (string|null)\n   - Has `mount()` method that simulates useEffect running\n   - In mount: sets loading true, calls fetchUsers, updates state\n\n3. Test by calling mount() and logging state changes",
              "starterCode": "// Simulate API\nfunction fetchUsers() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve([\n        { id: 1, name: 'Alice', email: 'alice@example.com' },\n        { id: 2, name: 'Bob', email: 'bob@example.com' },\n        { id: 3, name: 'Charlie', email: 'charlie@example.com' }\n      ]);\n    }, 1000);\n  });\n}\n\n// Simulate React component\nlet UserListComponent = {\n  state: {\n    users: [],\n    loading: false,\n    error: null\n  },\n  \n  setState(updates) {\n    this.state = { ...this.state, ...updates };\n    console.log('[State Updated]', this.state);\n  },\n  \n  async mount() {\n    console.log('[Component] Mounting...');\n    console.log('[useEffect] Running effect (fetch users)');\n    \n    this.setState({ loading: true });\n    \n    try {\n      console.log('[Fetch] Calling API...');\n      let users = await fetchUsers();\n      console.log('[Fetch] Received', users.length, 'users');\n      this.setState({ users, loading: false });\n    } catch (err) {\n      console.log('[Fetch] Error:', err.message);\n      this.setState({ error: err.message, loading: false });\n    }\n  }\n};\n\n// Test\nconsole.log('=== UserList Component ===\\n');\nUserListComponent.mount();",
              "solution": "// Complete data fetching simulation\n\n// Mock API with various endpoints\nlet mockAPI = {\n  users: [\n    { id: 1, name: 'Alice', email: 'alice@example.com', role: 'Admin' },\n    { id: 2, name: 'Bob', email: 'bob@example.com', role: 'User' },\n    { id: 3, name: 'Charlie', email: 'charlie@example.com', role: 'User' }\n  ],\n  \n  fetchUsers(delay = 1000) {\n    console.log(`[API] GET /api/users (simulating ${delay}ms network delay)`);\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        console.log('[API] Responding with', this.users.length, 'users');\n        resolve([...this.users]);\n      }, delay);\n    });\n  },\n  \n  fetchUserById(id, delay = 800) {\n    console.log(`[API] GET /api/users/${id}`);\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        let user = this.users.find(u => u.id === id);\n        if (user) {\n          console.log('[API] Found user:', user.name);\n          resolve({ ...user });\n        } else {\n          console.log('[API] 404 Not Found');\n          reject(new Error('User not found'));\n        }\n      }, delay);\n    });\n  },\n  \n  createUser(userData, delay = 1000) {\n    console.log('[API] POST /api/users', userData);\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        let newUser = {\n          id: this.users.length + 1,\n          ...userData\n        };\n        this.users.push(newUser);\n        console.log('[API] Created user:', newUser);\n        resolve(newUser);\n      }, delay);\n    });\n  }\n};\n\n// Component 1: UserList (fetch all users on mount)\nlet UserListComponent = {\n  state: { users: [], loading: false, error: null },\n  \n  setState(updates) {\n    this.state = { ...this.state, ...updates };\n    console.log('[UserList State]', this.state);\n  },\n  \n  async mount() {\n    console.log('[UserList] Component mounting...');\n    console.log('[UserList] useEffect(() => { fetchUsers() }, [])');\n    \n    try {\n      this.setState({ loading: true, error: null });\n      let users = await mockAPI.fetchUsers();\n      this.setState({ users, loading: false });\n      console.log('[UserList] Render with', users.length, 'users\\n');\n    } catch (err) {\n      this.setState({ error: err.message, loading: false });\n      console.log('[UserList] Render error state\\n');\n    }\n  }\n};\n\n// Component 2: UserProfile (fetch user when ID changes)\nlet UserProfileComponent = {\n  state: { userId: null, user: null, loading: false, error: null },\n  \n  setState(updates) {\n    let oldUserId = this.state.userId;\n    this.state = { ...this.state, ...updates };\n    console.log('[UserProfile State]', this.state);\n    \n    // Simulate useEffect with [userId] dependency\n    if ('userId' in updates && updates.userId !== oldUserId) {\n      console.log('[UserProfile] userId changed → running effect');\n      this.fetchUser();\n    }\n  },\n  \n  async fetchUser() {\n    if (!this.state.userId) {\n      console.log('[UserProfile] No userId, skipping fetch');\n      return;\n    }\n    \n    console.log(`[UserProfile] useEffect(() => { fetchUser(${this.state.userId}) }, [userId])`);\n    \n    try {\n      this.state.loading = true;\n      this.state.error = null;\n      let user = await mockAPI.fetchUserById(this.state.userId);\n      this.state.user = user;\n      this.state.loading = false;\n      console.log('[UserProfile] Render with user:', user.name, '\\n');\n    } catch (err) {\n      this.state.error = err.message;\n      this.state.loading = false;\n      console.log('[UserProfile] Render error\\n');\n    }\n  },\n  \n  mount() {\n    console.log('[UserProfile] Component mounting...');\n    console.log('[UserProfile] useEffect registered with [userId] dependency\\n');\n  }\n};\n\n// Run simulation\nasync function runSimulation() {\n  console.log('=== Full-Stack Data Fetching Simulation ===\\n');\n  \n  // Scenario 1: Fetch all users on mount\n  console.log('--- Scenario 1: UserList Component ---\\n');\n  await UserListComponent.mount();\n  \n  // Scenario 2: Fetch specific user when ID changes\n  console.log('--- Scenario 2: UserProfile Component ---\\n');\n  UserProfileComponent.mount();\n  \n  await new Promise(resolve => setTimeout(resolve, 100));\n  console.log('[User Action] Clicks on user 1');\n  UserProfileComponent.setState({ userId: 1 });\n  \n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log('[User Action] Clicks on user 2');\n  UserProfileComponent.setState({ userId: 2 });\n  \n  // Scenario 3: Create new user\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log('\\n--- Scenario 3: Create User ---\\n');\n  let newUser = await mockAPI.createUser({ \n    name: 'Diana', \n    email: 'diana@example.com',\n    role: 'User'\n  });\n  \n  console.log('\\n--- Final State ---');\n  console.log('Total users in database:', mockAPI.users.length);\n  console.log('Users:', mockAPI.users.map(u => u.name).join(', '));\n}\n\nrunSimulation();",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should fetch and return users",
                  "expectedOutput": "Array of 3 users",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use async/await and try/catch/finally for clean error handling"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common useEffect + fetch mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common useEffect + fetch mistakes:"
                },
                {
                  "mistake": "**Forgetting dependency array**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting dependency array**:\n   ```jsx\n   // WRONG! Infinite loop!\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data)); // State update triggers re-render\n   }); // No dependency array → runs every render → infinite loop!\n   \n   // CORRECT!\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data));\n   }, []); // Empty array → run once\n   ```"
                },
                {
                  "mistake": "**Using async directly in useEffect**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Using async directly in useEffect**:\n   ```jsx\n   // WRONG!\n   useEffect(async () => {  // ← Can't do this!\n     const res = await fetch('/api/users');\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     async function fetchData() {  // Define async function inside\n       const res = await fetch('/api/users');\n     }\n     fetchData();  // Call it\n   }, []);\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14.4",
          "title": "Complete Full-Stack Example - Todo App with React + Hono + Prisma",
          "moduleId": "module-14",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Building a full-stack app is like building a house:\n\nFoundation (Database - Prisma/PostgreSQL):\n- Permanent storage for all data\n- Structured (schema)\n- Reliable\n\nPlumbing & Electrical (Backend - Hono):\n- Hidden from view\n- Does the real work\n- Connects everything together\n\nInterior & Facade (Frontend - React):\n- What users see and interact with\n- Beautiful and intuitive\n- Makes requests to backend for functionality\n\nInspector (CORS):\n- Ensures everything is safe and connected properly\n- Allows frontend and backend to communicate\n\nA complete full-stack app needs ALL these parts working together!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Complete Full-Stack Todo App Simulation\n\nconsole.log('=== Full-Stack Todo Application ===\\n');\n\n// DATABASE LAYER (Prisma + PostgreSQL)\nlet database = {\n  todos: [\n    { id: 1, title: 'Learn React', completed: false, userId: 1 },\n    { id: 2, title: 'Build API', completed: true, userId: 1 },\n    { id: 3, title: 'Deploy app', completed: false, userId: 1 }\n  ],\n  \n  // Simulate Prisma queries\n  async findMany(filter = {}) {\n    console.log('[Database] SELECT * FROM todos WHERE userId =', filter.userId || 'ALL');\n    let results = filter.userId \n      ? this.todos.filter(t => t.userId === filter.userId)\n      : this.todos;\n    return results;\n  },\n  \n  async create(data) {\n    console.log('[Database] INSERT INTO todos', data);\n    let newTodo = {\n      id: this.todos.length + 1,\n      completed: false,\n      ...data\n    };\n    this.todos.push(newTodo);\n    return newTodo;\n  },\n  \n  async update(id, data) {\n    console.log(`[Database] UPDATE todos SET ... WHERE id = ${id}`);\n    let todo = this.todos.find(t => t.id === id);\n    if (todo) {\n      Object.assign(todo, data);\n      return todo;\n    }\n    return null;\n  },\n  \n  async delete(id) {\n    console.log(`[Database] DELETE FROM todos WHERE id = ${id}`);\n    let index = this.todos.findIndex(t => t.id === id);\n    if (index !== -1) {\n      let deleted = this.todos.splice(index, 1)[0];\n      return deleted;\n    }\n    return null;\n  }\n};\n\n// BACKEND LAYER (Hono API)\nlet backend = {\n  corsEnabled: true,\n  \n  async handleGetTodos(userId) {\n    console.log('[Backend] GET /api/todos');\n    console.log('[Backend] Checking CORS... ' + (this.corsEnabled ? 'Allowed' : 'Blocked'));\n    \n    if (!this.corsEnabled) {\n      return { status: 403, error: 'CORS error' };\n    }\n    \n    let todos = await database.findMany({ userId });\n    console.log(`[Backend] Found ${todos.length} todos`);\n    return { status: 200, data: todos };\n  },\n  \n  async handleCreateTodo(title, userId) {\n    console.log('[Backend] POST /api/todos', { title, userId });\n    \n    // Validation\n    if (!title || title.trim().length === 0) {\n      console.log('[Backend] Validation failed: title required');\n      return { status: 400, error: 'Title is required' };\n    }\n    \n    let newTodo = await database.create({ title, userId });\n    console.log('[Backend] Created todo:', newTodo.id);\n    return { status: 201, data: newTodo };\n  },\n  \n  async handleUpdateTodo(id, updates) {\n    console.log(`[Backend] PATCH /api/todos/${id}`, updates);\n    let updated = await database.update(id, updates);\n    \n    if (!updated) {\n      console.log('[Backend] Todo not found');\n      return { status: 404, error: 'Todo not found' };\n    }\n    \n    console.log('[Backend] Updated todo:', updated);\n    return { status: 200, data: updated };\n  },\n  \n  async handleDeleteTodo(id) {\n    console.log(`[Backend] DELETE /api/todos/${id}`);\n    let deleted = await database.delete(id);\n    \n    if (!deleted) {\n      return { status: 404, error: 'Todo not found' };\n    }\n    \n    console.log('[Backend] Deleted todo');\n    return { status: 200, data: { message: 'Deleted successfully' } };\n  }\n};\n\n// FRONTEND LAYER (React Component)\nlet TodoApp = {\n  state: {\n    todos: [],\n    loading: false,\n    error: null,\n    newTodoTitle: '',\n    currentUserId: 1\n  },\n  \n  setState(updates) {\n    this.state = { ...this.state, ...updates };\n    console.log('[TodoApp State]', {\n      todos: this.state.todos.length + ' todos',\n      loading: this.state.loading,\n      error: this.state.error\n    });\n  },\n  \n  // useEffect - fetch todos on mount\n  async componentDidMount() {\n    console.log('\\n[TodoApp] Component mounted');\n    console.log('[TodoApp] useEffect(() => { fetchTodos() }, [])');\n    await this.fetchTodos();\n  },\n  \n  async fetchTodos() {\n    console.log('[TodoApp] Fetching todos from API...');\n    console.log('[TodoApp] fetch(\"http://localhost:4000/api/todos\")');\n    \n    this.setState({ loading: true, error: null });\n    \n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 300));\n    \n    let response = await backend.handleGetTodos(this.state.currentUserId);\n    \n    if (response.status === 200) {\n      this.setState({ todos: response.data, loading: false });\n      console.log('[TodoApp] Rendering', response.data.length, 'todos');\n    } else {\n      this.setState({ error: response.error, loading: false });\n    }\n  },\n  \n  async addTodo(title) {\n    console.log(`\\n[TodoApp] User types \"${title}\" and clicks Add`);\n    console.log('[TodoApp] handleAddTodo()');\n    console.log('[TodoApp] fetch(\"http://localhost:4000/api/todos\", { method: \"POST\", ... })');\n    \n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    let response = await backend.handleCreateTodo(title, this.state.currentUserId);\n    \n    if (response.status === 201) {\n      console.log('[TodoApp] Todo created! Refreshing list...');\n      await this.fetchTodos();\n    } else {\n      this.setState({ error: response.error });\n    }\n  },\n  \n  async toggleTodo(id) {\n    console.log(`\\n[TodoApp] User clicks checkbox for todo ${id}`);\n    let todo = this.state.todos.find(t => t.id === id);\n    console.log(`[TodoApp] Toggling completed: ${todo.completed} → ${!todo.completed}`);\n    console.log(`[TodoApp] fetch(\"http://localhost:4000/api/todos/${id}\", { method: \"PATCH\", ... })`);\n    \n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    let response = await backend.handleUpdateTodo(id, { completed: !todo.completed });\n    \n    if (response.status === 200) {\n      console.log('[TodoApp] Updated! Refreshing...');\n      await this.fetchTodos();\n    }\n  },\n  \n  async deleteTodo(id) {\n    console.log(`\\n[TodoApp] User clicks delete for todo ${id}`);\n    console.log(`[TodoApp] fetch(\"http://localhost:4000/api/todos/${id}\", { method: \"DELETE\" })`);\n    \n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    let response = await backend.handleDeleteTodo(id);\n    \n    if (response.status === 200) {\n      console.log('[TodoApp] Deleted! Refreshing...');\n      await this.fetchTodos();\n    }\n  }\n};\n\n// RUN SIMULATION\nasync function runFullStackSimulation() {\n  console.log('=== Simulating Full-Stack Todo App ===\\n');\n  \n  // 1. App loads\n  await TodoApp.componentDidMount();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // 2. User adds new todo\n  await TodoApp.addTodo('Master full-stack development');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // 3. User toggles todo\n  await TodoApp.toggleTodo(1);\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // 4. User deletes todo\n  await TodoApp.deleteTodo(2);\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // 5. Final state\n  console.log('\\n=== Final Application State ===');\n  console.log('\\nDatabase:');\n  database.todos.forEach(todo => {\n    console.log(`  [${todo.completed ? '✓' : ' '}] ${todo.id}. ${todo.title}`);\n  });\n  \n  console.log('\\nFrontend State:');\n  console.log('  Todos displayed:', TodoApp.state.todos.length);\n  console.log('  Loading:', TodoApp.state.loading);\n  console.log('  Error:', TodoApp.state.error || 'none');\n}\n\nrunFullStackSimulation();"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Complete full-stack implementation:\n\n**1. Database (Prisma Schema)**:\n```prisma\n// schema.prisma\nmodel Todo {\n  id        Int      @id @default(autoincrement())\n  title     String\n  completed Boolean  @default(false)\n  userId    Int\n  createdAt DateTime @default(now())\n}\n```\n\n**2. Backend (Hono + Prisma)**:\n```javascript\n// server.js\nimport { Hono } from 'hono';\nimport { cors } from 'hono/cors';\nimport { serve } from '@hono/node-server';\nimport { PrismaClient } from '@prisma/client';\n\nconst app = new Hono();\nconst prisma = new PrismaClient();\n\napp.use('*', cors());  // Enable CORS!\n\n// GET all todos\napp.get('/api/todos', async (c) => {\n  const todos = await prisma.todo.findMany({\n    where: { userId: c.get('userId') },\n    orderBy: { createdAt: 'desc' }\n  });\n  return c.json(todos);\n});\n\n// POST new todo\napp.post('/api/todos', async (c) => {\n  const { title } = await c.req.json();\n  \n  if (!title) {\n    return c.json({ error: 'Title required' }, 400);\n  }\n  \n  const todo = await prisma.todo.create({\n    data: { title, userId: c.get('userId') }\n  });\n  \n  return c.json(todo, 201);\n});\n\n// PATCH update todo\napp.patch('/api/todos/:id', async (c) => {\n  const id = parseInt(c.req.param('id'));\n  const { completed, title } = await c.req.json();\n  \n  const todo = await prisma.todo.update({\n    where: { id },\n    data: { completed, title }\n  });\n  \n  return c.json(todo);\n});\n\n// DELETE todo\napp.delete('/api/todos/:id', async (c) => {\n  const id = parseInt(c.req.param('id'));\n  \n  await prisma.todo.delete({\n    where: { id }\n  });\n  \n  return c.json({ message: 'Deleted' });\n});\n\nserve(app, (info) => {\n  console.log(`API running on http://localhost:${info.port}`);\n});\n```\n\n**3. Frontend (React)**:\n```jsx\n// TodoApp.jsx\nimport { useState, useEffect } from 'react';\n\nconst API_URL = 'http://localhost:3000';\n\nfunction TodoApp() {\n  const [todos, setTodos] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [newTitle, setNewTitle] = useState('');\n  \n  // Fetch todos on mount\n  useEffect(() => {\n    fetchTodos();\n  }, []);\n  \n  async function fetchTodos() {\n    const res = await fetch(`${API_URL}/api/todos`);\n    const data = await res.json();\n    setTodos(data);\n    setLoading(false);\n  }\n  \n  async function addTodo(e) {\n    e.preventDefault();\n    \n    await fetch(`${API_URL}/api/todos`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ title: newTitle })\n    });\n    \n    setNewTitle('');\n    fetchTodos();\n  }\n  \n  async function toggleTodo(id, completed) {\n    await fetch(`${API_URL}/api/todos/${id}`, {\n      method: 'PATCH',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ completed: !completed })\n    });\n    \n    fetchTodos();\n  }\n  \n  async function deleteTodo(id) {\n    await fetch(`${API_URL}/api/todos/${id}`, {\n      method: 'DELETE'\n    });\n    \n    fetchTodos();\n  }\n  \n  if (loading) return <div>Loading...</div>;\n  \n  return (\n    <div>\n      <h1>My Todos</h1>\n      \n      <form onSubmit={addTodo}>\n        <input\n          value={newTitle}\n          onChange={(e) => setNewTitle(e.target.value)}\n          placeholder=\"New todo...\"\n        />\n        <button type=\"submit\">Add</button>\n      </form>\n      \n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id}>\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => toggleTodo(todo.id, todo.completed)}\n            />\n            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n              {todo.title}\n            </span>\n            <button onClick={() => deleteTodo(todo.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common full-stack integration mistakes:\n\n1. **Forgetting to enable CORS**:\n   ```javascript\n   // Hono backend missing:\n   app.use('*', cors());  // Add this!\n   ```\n\n2. **Wrong API URL**:\n   ```jsx\n   // Wrong!\n   fetch('localhost:4000/api/todos')  // Missing http://\n   \n   // Correct!\n   fetch('http://localhost:4000/api/todos')\n   \n   // Best!\n   const API_URL = import.meta.env.VITE_API_URL;\n   fetch(`${API_URL}/api/todos`);\n   ```\n\n3. **Not refreshing data after mutations**:\n   ```jsx\n   // Wrong! (UI doesn't update)\n   async function addTodo() {\n     await fetch('/api/todos', { method: 'POST', ... });\n     // Forgot to refresh!\n   }\n   \n   // Correct!\n   async function addTodo() {\n     await fetch('/api/todos', { method: 'POST', ... });\n     fetchTodos();  // Refresh the list!\n   }\n   ```\n\n4. **Not validating on backend (Hono)**:\n   ```javascript\n   // NEVER trust frontend data!\n   app.post('/api/todos', async (c) => {\n     const { title } = await c.req.json();\n     \n     // Validate!\n     if (!title || title.trim().length === 0) {\n       return c.json({ error: 'Title required' }, 400);\n     }\n     \n     // Now safe to create\n     const todo = await prisma.todo.create({ data: { title } });\n     return c.json(todo);\n   });\n   ```\n\n5. **Hardcoded user IDs** (security issue!):\n   ```javascript\n   // Wrong! (any user can access any todo)\n   app.get('/api/todos', async (c) => {\n     const todos = await prisma.todo.findMany();\n     return c.json(todos);\n   });\n   \n   // Correct! (filter by authenticated user)\n   app.get('/api/todos', async (c) => {\n     const todos = await prisma.todo.findMany({\n       where: { userId: c.get('userId') }  // From auth middleware\n     });\n     return c.json(todos);\n   });\n   ```"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Express Backend Equivalent",
              "legacy": "express",
              "content": "If you encounter older codebases using Express, here's the same Todo API. The main differences are: Express uses (req, res) instead of (c), res.json() instead of return c.json(), and requires a separate cors package.",
              "code": "// Express + Prisma Todo API\nimport express from 'express';\nimport cors from 'cors';  // Separate package!\nimport { PrismaClient } from '@prisma/client';\n\nconst app = express();\nconst prisma = new PrismaClient();\n\napp.use(cors());\napp.use(express.json());  // Required for req.body!\n\n// GET all todos\napp.get('/api/todos', async (req, res) => {\n  const todos = await prisma.todo.findMany({\n    where: { userId: req.user.id },\n    orderBy: { createdAt: 'desc' }\n  });\n  res.json(todos);\n});\n\n// POST new todo\napp.post('/api/todos', async (req, res) => {\n  const { title } = req.body;\n  \n  if (!title) {\n    return res.status(400).json({ error: 'Title required' });\n  }\n  \n  const todo = await prisma.todo.create({\n    data: { title, userId: req.user.id }\n  });\n  \n  res.status(201).json(todo);\n});\n\n// PATCH update todo\napp.patch('/api/todos/:id', async (req, res) => {\n  const { id } = req.params;\n  const { completed, title } = req.body;\n  \n  const todo = await prisma.todo.update({\n    where: { id: parseInt(id) },\n    data: { completed, title }\n  });\n  \n  res.json(todo);\n});\n\n// DELETE todo\napp.delete('/api/todos/:id', async (req, res) => {\n  const { id } = req.params;\n  \n  await prisma.todo.delete({\n    where: { id: parseInt(id) }\n  });\n  \n  res.json({ message: 'Deleted' });\n});\n\napp.listen(4000, () => {\n  console.log('API running on http://localhost:4000');\n});",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13.4-challenge",
              "title": "Practice Challenge",
              "description": "Build a simplified full-stack blog:\n\n1. Create a `database` object with:\n   - posts array with sample posts (id, title, content)\n   - findAll() method\n   - create(data) method\n\n2. Create a `backend` object with:\n   - handleGetPosts() - returns all posts\n   - handleCreatePost(title, content) - creates post\n\n3. Create a `BlogApp` object with:\n   - state: posts, loading\n   - fetchPosts() - calls backend\n   - createPost(title, content) - calls backend and refreshes\n\n4. Test the flow",
              "instructions": "Build a simplified full-stack blog:\n\n1. Create a `database` object with:\n   - posts array with sample posts (id, title, content)\n   - findAll() method\n   - create(data) method\n\n2. Create a `backend` object with:\n   - handleGetPosts() - returns all posts\n   - handleCreatePost(title, content) - creates post\n\n3. Create a `BlogApp` object with:\n   - state: posts, loading\n   - fetchPosts() - calls backend\n   - createPost(title, content) - calls backend and refreshes\n\n4. Test the flow",
              "starterCode": "// Simplified blog system\n\nlet database = {\n  posts: [\n    { id: 1, title: 'First Post', content: 'Hello world!' },\n    { id: 2, title: 'Second Post', content: 'Learning full-stack!' }\n  ],\n  \n  findAll() {\n    console.log('[DB] SELECT * FROM posts');\n    return [...this.posts];\n  },\n  \n  create(data) {\n    console.log('[DB] INSERT INTO posts', data);\n    let post = { id: this.posts.length + 1, ...data };\n    this.posts.push(post);\n    return post;\n  }\n};\n\nlet backend = {\n  handleGetPosts() {\n    console.log('[API] GET /api/posts');\n    let posts = database.findAll();\n    return { status: 200, data: posts };\n  },\n  \n  handleCreatePost(title, content) {\n    console.log('[API] POST /api/posts');\n    let post = database.create({ title, content });\n    return { status: 201, data: post };\n  }\n};\n\nlet BlogApp = {\n  state: { posts: [], loading: false },\n  \n  setState(updates) {\n    this.state = { ...this.state, ...updates };\n    console.log('[App State]', this.state);\n  },\n  \n  async mount() {\n    console.log('[App] Mounting...');\n    await this.fetchPosts();\n  },\n  \n  async fetchPosts() {\n    console.log('[App] Fetching posts...');\n    this.setState({ loading: true });\n    \n    let response = backend.handleGetPosts();\n    this.setState({ posts: response.data, loading: false });\n  },\n  \n  async createPost(title, content) {\n    console.log(`[App] Creating post: ${title}`);\n    let response = backend.handleCreatePost(title, content);\n    console.log('[App] Post created, refreshing...');\n    await this.fetchPosts();\n  }\n};\n\n// Test\nconsole.log('=== Blog App Test ===\\n');\nBlogApp.mount().then(() => {\n  console.log('\\n[User] Clicks \"New Post\"');\n  BlogApp.createPost('Third Post', 'Full-stack is awesome!');\n});",
              "solution": "// See the codeExample above for complete solution with full CRUD operations",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should fetch posts",
                  "expectedOutput": "2",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Follow the pattern: Frontend → Backend → Database → Backend → Frontend"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common full-stack integration mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common full-stack integration mistakes:"
                },
                {
                  "mistake": "**Forgetting to enable CORS**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting to enable CORS**:\n   ```javascript\n   // Hono backend missing:\n   app.use('*', cors());  // Add this!\n   ```"
                },
                {
                  "mistake": "**Wrong API URL**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong API URL**:\n   ```jsx\n   // Wrong!\n   fetch('localhost:4000/api/todos')  // Missing http://\n   \n   // Correct!\n   fetch('http://localhost:4000/api/todos')\n   \n   // Best!\n   const API_URL = import.meta.env.VITE_API_URL;\n   fetch(`${API_URL}/api/todos`);\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-15",
      "title": "Module 15: Deployment & Professional Tools",
      "description": "Deploy your applications to production, use Git for version control, and adopt professional development practices",
      "difficulty": "advanced",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "14.1",
          "title": "Version Control with Git (The Time Machine Analogy)",
          "moduleId": "module-14",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine writing a book:\n\nWithout version control:\n- Save as: book_final.docx\n- Save as: book_final_v2.docx\n- Save as: book_final_v2_ACTUALLY_FINAL.docx\n- Save as: book_final_v2_ACTUALLY_FINAL_fixed.docx\n- Which one is the real final version?!\n- Want to go back to Tuesday's version? Good luck finding it!\n- Working with co-author? Email files back and forth (nightmare!)\n\nWith Git (version control):\n- One file: book.docx\n- Every save creates a snapshot (commit)\n- Can jump to ANY previous version instantly\n- See exactly what changed and when\n- Multiple authors work simultaneously\n- Automatic merging of changes\n- Complete history preserved forever\n\nGit is like a time machine for your code. It tracks every change, lets you experiment safely, and makes collaboration seamless!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Git Concepts (Simulated)\n// Git is a command-line tool, not JavaScript, but let's understand the concepts!\n\nconsole.log('=== Git Version Control ===\\n');\n\n// CONCEPT 1: REPOSITORY - Project history\nlet repository = {\n  name: 'my-awesome-app',\n  commits: [],\n  currentBranch: 'main',\n  branches: ['main']\n};\n\nconsole.log('Repository:', repository.name);\n\n// CONCEPT 2: COMMIT - Snapshot of your code\nfunction commit(message, files) {\n  let snapshot = {\n    id: Math.random().toString(36).substr(2, 7),\n    message: message,\n    files: files,\n    timestamp: new Date().toISOString(),\n    author: 'You'\n  };\n  \n  repository.commits.push(snapshot);\n  console.log(`✓ Committed: \"${message}\" (${snapshot.id})`);\n  return snapshot;\n}\n\n// CONCEPT 3: BRANCH - Parallel version of code\nfunction createBranch(name) {\n  repository.branches.push(name);\n  console.log(`✓ Created branch: ${name}`);\n}\n\nfunction switchBranch(name) {\n  if (repository.branches.includes(name)) {\n    repository.currentBranch = name;\n    console.log(`✓ Switched to branch: ${name}`);\n  }\n}\n\n// SIMULATE GIT WORKFLOW\nconsole.log('\\n--- Simulating Git Workflow ---\\n');\n\n// 1. Initial commit\ncommit('Initial commit', ['index.html', 'app.js', 'styles.css']);\n\n// 2. Add feature\ncommit('Add user authentication', ['auth.js', 'login.html']);\n\n// 3. Fix bug\ncommit('Fix login button styling', ['styles.css']);\n\n// 4. Create feature branch\ncreate Branch('feature/dark-mode');\nswitchBranch('feature/dark-mode');\n\n// 5. Work on feature\ncommit('Add dark mode toggle', ['darkMode.js', 'styles.css']);\n\n// 6. Switch back to main\nswitchBranch('main');\n\nconsole.log('\\n--- Repository State ---');\nconsole.log('Total commits:', repository.commits.length);\nconsole.log('Branches:', repository.branches.join(', '));\nconsole.log('Current branch:', repository.currentBranch);\n\nconsole.log('\\n--- Commit History ---');\nrepository.commits.forEach((c, i) => {\n  console.log(`${i + 1}. [${c.id}] ${c.message}`);\n});\n\n// GIT COMMANDS REFERENCE\nconsole.log('\\n=== Essential Git Commands ===\\n');\n\nlet gitCommands = {\n  'git init': 'Create new Git repository',\n  'git clone <url>': 'Download existing repository',\n  'git status': 'See which files changed',\n  'git add <file>': 'Stage file for commit',\n  'git add .': 'Stage all changed files',\n  'git commit -m \"message\"': 'Save snapshot with message',\n  'git log': 'View commit history',\n  'git branch <name>': 'Create new branch',\n  'git checkout <branch>': 'Switch to branch',\n  'git merge <branch>': 'Merge branch into current',\n  'git pull': 'Download latest changes from remote',\n  'git push': 'Upload your commits to remote',\n  'git diff': 'See what changed in files'\n};\n\nfor (let [command, description] of Object.entries(gitCommands)) {\n  console.log(`${command.padEnd(30)} - ${description}`);\n}\n\n// TYPICAL WORKFLOW\nconsole.log('\\n=== Typical Git Workflow ===\\n');\n\nlet workflow = [\n  '1. Make changes to your code',\n  '2. git status               (see what changed)',\n  '3. git add .                (stage all changes)',\n  '4. git commit -m \"Add feature X\"  (save snapshot)',\n  '5. git push                 (upload to GitHub)',\n  '',\n  'Repeat for every feature/fix!'\n];\n\nworkflow.forEach(step => console.log(step));\n\nconsole.log('\\n--- Why Use Git? ---');\nlet benefits = [\n  '✓ Never lose code (complete history)',\n  '✓ Experiment safely (branches)',\n  '✓ Collaborate easily (merge changes)',\n  '✓ See who changed what and when',\n  '✓ Revert mistakes instantly',\n  '✓ Required by all professional teams',\n  '✓ Works with GitHub (code hosting)'\n];\n\nbenefits.forEach(b => console.log(b));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Git fundamentals:\n\n1. **Setting Up Git**:\n   ```bash\n   # Configure Git (one time)\n   git config --global user.name \"Your Name\"\n   git config --global user.email \"you@example.com\"\n   \n   # Create new repository\n   git init\n   \n   # Or clone existing\n   git clone https://github.com/username/repo.git\n   ```\n\n2. **Basic Workflow**:\n   ```bash\n   # 1. Check status\n   git status\n   \n   # 2. Stage changes\n   git add filename.js      # Single file\n   git add .                # All files\n   \n   # 3. Commit\n   git commit -m \"Add user login feature\"\n   \n   # 4. Push to remote (GitHub)\n   git push\n   ```\n\n3. **Branches**:\n   ```bash\n   # Create and switch to new branch\n   git checkout -b feature/new-feature\n   \n   # Switch between branches\n   git checkout main\n   git checkout feature/new-feature\n   \n   # Merge branch into current\n   git checkout main\n   git merge feature/new-feature\n   \n   # Delete branch\n   git branch -d feature/new-feature\n   ```\n\n4. **Viewing History**:\n   ```bash\n   # See commits\n   git log\n   git log --oneline    # Compact view\n   \n   # See changes\n   git diff             # Unstaged changes\n   git diff --staged    # Staged changes\n   ```\n\n5. **.gitignore** - Files to never commit:\n   ```\n   node_modules/\n   .env\n   .DS_Store\n   dist/\n   build/\n   *.log\n   ```\n\n6. **GitHub Workflow**:\n   ```bash\n   # First time setup\n   git remote add origin https://github.com/username/repo.git\n   git push -u origin main\n   \n   # Regular updates\n   git pull    # Download changes\n   git push    # Upload changes\n   ```\n\n7. **Commit Messages** (best practices):\n   - Start with verb: \"Add\", \"Fix\", \"Update\", \"Remove\"\n   - Be specific: \"Fix login button alignment\"\n   - Not vague: \"Fixed stuff\" or \"Changes\"\n   - Present tense: \"Add feature\" not \"Added feature\""
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Git mistakes:\n\n1. **Forgetting to commit**:\n   ```bash\n   # Made lots of changes, forgot to commit\n   # Now have 50 files changed\n   # Hard to write one commit message!\n   \n   # Better: Commit after each feature\n   git add .\n   git commit -m \"Add user login\"\n   # Then continue coding\n   ```\n\n2. **Committing secrets**:\n   ```bash\n   # NEVER commit .env files!\n   # Add to .gitignore:\n   .env\n   .env.local\n   config/secrets.js\n   ```\n\n3. **Not using .gitignore**:\n   ```bash\n   # Don't commit node_modules!\n   # Create .gitignore file:\n   node_modules/\n   .DS_Store\n   dist/\n   *.log\n   ```\n\n4. **Merge conflicts** (scary but normal!):\n   ```\n   <<<<<<< HEAD\n   const API_URL = 'http://localhost:3000';\n   =======\n   const API_URL = 'https://api.production.com';\n   >>>>>>> feature-branch\n   ```\n   - Choose which version to keep\n   - Delete conflict markers (<<<<, ====, >>>>)\n   - Commit the resolved file\n\n5. **Wrong branch**:\n   ```bash\n   # Check current branch BEFORE committing!\n   git branch        # Shows all branches\n   git status        # Shows current branch\n   \n   # If on wrong branch:\n   git stash         # Save changes temporarily\n   git checkout correct-branch\n   git stash pop     # Apply changes here\n   ```\n\n6. **Push without pull**:\n   ```bash\n   # Error: Updates were rejected\n   # Someone else pushed while you were working\n   \n   # Fix:\n   git pull          # Get their changes\n   # Resolve conflicts if any\n   git push          # Now it works\n   ```\n\n7. **Vague commit messages**:\n   ```bash\n   # Bad:\n   git commit -m \"fixes\"\n   git commit -m \"stuff\"\n   git commit -m \"asdf\"\n   \n   # Good:\n   git commit -m \"Fix login button alignment on mobile\"\n   git commit -m \"Add password reset functionality\"\n   git commit -m \"Update dependencies to latest versions\"\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14.1-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a Git repository:\n\n1. Create a `repo` object with:\n   - commits array\n   - branches array (start with 'main')\n   - currentBranch property\n\n2. Create function `makeCommit(message)` that:\n   - Adds commit to commits array\n   - Returns commit object with: id, message, timestamp\n\n3. Create function `createBranch(name)` that:\n   - Adds branch to branches array\n\n4. Test by making 3 commits and creating 1 branch",
              "instructions": "Simulate a Git repository:\n\n1. Create a `repo` object with:\n   - commits array\n   - branches array (start with 'main')\n   - currentBranch property\n\n2. Create function `makeCommit(message)` that:\n   - Adds commit to commits array\n   - Returns commit object with: id, message, timestamp\n\n3. Create function `createBranch(name)` that:\n   - Adds branch to branches array\n\n4. Test by making 3 commits and creating 1 branch",
              "starterCode": "// Git repository simulation\nlet repo = {\n  commits: [],\n  branches: ['main'],\n  currentBranch: 'main'\n};\n\nfunction makeCommit(message) {\n  let commit = {\n    id: Math.random().toString(36).substr(2, 7),\n    message: message,\n    timestamp: new Date().toISOString()\n  };\n  repo.commits.push(commit);\n  console.log(`Committed: ${message} (${commit.id})`);\n  return commit;\n}\n\nfunction createBranch(name) {\n  repo.branches.push(name);\n  console.log(`Created branch: ${name}`);\n}\n\n// Test\nmakeCommit('Initial commit');\nmakeCommit('Add homepage');\nmakeCommit('Fix CSS');\ncreateBranch('feature/login');\n\nconsole.log('\\nRepository state:');\nconsole.log('Commits:', repo.commits.length);\nconsole.log('Branches:', repo.branches);",
              "solution": "// Complete Git simulation\nlet repo = {\n  commits: [],\n  branches: ['main'],\n  currentBranch: 'main',\n  files: {}\n};\n\nfunction makeCommit(message, files = []) {\n  let commit = {\n    id: Math.random().toString(36).substr(2, 7),\n    message: message,\n    branch: repo.currentBranch,\n    files: files,\n    timestamp: new Date().toISOString(),\n    author: 'Developer'\n  };\n  \n  repo.commits.push(commit);\n  console.log(`✓ [${commit.id}] ${message}`);\n  return commit;\n}\n\nfunction createBranch(name) {\n  if (repo.branches.includes(name)) {\n    console.log(`✗ Branch ${name} already exists`);\n    return false;\n  }\n  repo.branches.push(name);\n  console.log(`✓ Created branch: ${name}`);\n  return true;\n}\n\nfunction switchBranch(name) {\n  if (!repo.branches.includes(name)) {\n    console.log(`✗ Branch ${name} does not exist`);\n    return false;\n  }\n  repo.currentBranch = name;\n  console.log(`✓ Switched to branch: ${name}`);\n  return true;\n}\n\nfunction showLog() {\n  console.log('\\n=== Commit History ===');\n  repo.commits.forEach((c, i) => {\n    console.log(`${i + 1}. [${c.id}] (${c.branch}) ${c.message}`);\n    if (c.files.length > 0) {\n      console.log(`   Files: ${c.files.join(', ')}`);\n    }\n  });\n}\n\nfunction showStatus() {\n  console.log('\\n=== Repository Status ===');\n  console.log(`Current branch: ${repo.currentBranch}`);\n  console.log(`Total branches: ${repo.branches.join(', ')}`);\n  console.log(`Total commits: ${repo.commits.length}`);\n}\n\n// Simulate development workflow\nconsole.log('=== Git Workflow Simulation ===\\n');\n\nmakeCommit('Initial commit', ['README.md', 'package.json']);\nmakeCommit('Add Express server', ['server.js']);\nmakeCommit('Add database connection', ['db.js', 'prisma/schema.prisma']);\n\ncreateBranch('feature/authentication');\nswitchBranch('feature/authentication');\n\nmakeCommit('Add login route', ['routes/auth.js']);\nmakeCommit('Add JWT middleware', ['middleware/auth.js']);\n\nswitchBranch('main');\nmakeCommit('Update README', ['README.md']);\n\nshowLog();\nshowStatus();\n\nconsole.log('\\n--- Git Best Practices ---');\nlet practices = [\n  '✓ Commit often (small, focused commits)',\n  '✓ Write clear commit messages',\n  '✓ Use branches for features',\n  '✓ Never commit secrets (.env files)',\n  '✓ Pull before you push',\n  '✓ Review changes before committing (git diff)',\n  '✓ Use .gitignore for node_modules, etc.'\n];\npractices.forEach(p => console.log(p));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should track commits",
                  "expectedOutput": "1",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use array push() to add commits and branches."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common Git mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common Git mistakes:"
                },
                {
                  "mistake": "**Forgetting to commit**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgetting to commit**:\n   ```bash\n   # Made lots of changes, forgot to commit\n   # Now have 50 files changed\n   # Hard to write one commit message!\n   \n   # Better: Commit after each feature\n   git add .\n   git commit -m \"Add user login\"\n   # Then continue coding\n   ```"
                },
                {
                  "mistake": "**Committing secrets**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Committing secrets**:\n   ```bash\n   # NEVER commit .env files!\n   # Add to .gitignore:\n   .env\n   .env.local\n   config/secrets.js\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14.2",
          "title": "Deploying Hono Backend (The Portable Restaurant Analogy)",
          "moduleId": "module-14",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine opening a food truck instead of a fixed restaurant:\n\nTraditional restaurant (Express + Node):\n- Fixed location (one platform)\n- Heavy kitchen equipment\n- Expensive to relocate\n- Works great, but locked to one spot\n\nFood truck (Hono):\n- Same great recipes work anywhere!\n- Set up at festivals (Cloudflare Workers)\n- Park downtown (Render with Bun)\n- Visit the beach (Deno Deploy)\n- Light and portable equipment\n\nHono is the food truck of web frameworks:\n- Write once, deploy anywhere\n- Same code runs on Bun, Deno, Cloudflare Workers, Node\n- Lightweight and blazing fast\n- Edge-ready (runs close to users worldwide)\n\nPopular deployment targets:\n- Bun on Render (free tier!)\n- Cloudflare Workers (edge computing)\n- Deno Deploy (serverless)\n- Traditional Node.js hosting"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "Hono works identically across platforms. Here's a complete API that deploys anywhere.",
              "language": "javascript",
              "code": "// Deploying Hono API - Multi-Platform\n\nconsole.log('=== Hono Multi-Platform Deployment ===\\n');\n\n// CONCEPT: One codebase, many platforms\nconst PORT = process.env.PORT || 3000;\nconst PLATFORM = process.env.PLATFORM || 'bun';\n\nconsole.log('Target Platform:', PLATFORM);\nconsole.log('Port:', PORT);\n\n// Simulating Hono app structure\nconst app = {\n  routes: [\n    { method: 'GET', path: '/', handler: 'home' },\n    { method: 'GET', path: '/api/users', handler: 'getUsers' },\n    { method: 'POST', path: '/api/users', handler: 'createUser' },\n    { method: 'GET', path: '/health', handler: 'healthCheck' }\n  ],\n  \n  // Hono's elegant response helpers\n  responseExamples: {\n    text: \"c.text('Hello!')\",\n    json: \"c.json({ users: [] })\",\n    html: \"c.html('<h1>Hello</h1>')\"\n  }\n};\n\nconsole.log('\\nHono App Routes:');\napp.routes.forEach(r => console.log(`  ${r.method} ${r.path}`));\n\n// PLATFORM-SPECIFIC DEPLOYMENT\nconsole.log('\\n\\n=== Deployment by Platform ===\\n');\n\nconst platforms = {\n  'bun-render': {\n    name: 'Bun on Render',\n    buildCmd: 'bun install',\n    startCmd: 'bun run src/index.ts',\n    envFile: '.env',\n    pros: ['Free tier', 'Fast builds', 'Easy setup'],\n    entryPoint: `// src/index.ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello from Hono!'))\napp.get('/health', (c) => c.json({ status: 'ok' }))\n\nexport default app  // Bun serves this automatically`\n  },\n  \n  'cloudflare-workers': {\n    name: 'Cloudflare Workers',\n    buildCmd: 'wrangler deploy',\n    startCmd: 'N/A (serverless)',\n    envFile: 'wrangler.toml',\n    pros: ['Edge locations worldwide', 'Instant cold starts', 'Free tier'],\n    entryPoint: `// src/index.ts\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello from the Edge!'))\napp.get('/health', (c) => c.json({ status: 'ok' }))\n\nexport default app  // Workers picks this up`\n  },\n  \n  'deno-deploy': {\n    name: 'Deno Deploy',\n    buildCmd: 'N/A (deploys from GitHub)',\n    startCmd: 'deno run --allow-net src/index.ts',\n    envFile: 'Dashboard',\n    pros: ['Git-based deploys', 'TypeScript native', 'Global edge'],\n    entryPoint: `// src/index.ts\nimport { Hono } from 'npm:hono'\nimport { serve } from 'https://deno.land/std/http/server.ts'\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Hello from Deno!'))\napp.get('/health', (c) => c.json({ status: 'ok' }))\n\nserve(app.fetch)  // Deno's serve function`\n  }\n};\n\nObject.entries(platforms).forEach(([key, platform]) => {\n  console.log(`--- ${platform.name} ---`);\n  console.log(`Build: ${platform.buildCmd}`);\n  console.log(`Start: ${platform.startCmd}`);\n  console.log(`Pros: ${platform.pros.join(', ')}`);\n  console.log('');\n});\n\n// HONO CODE PORTABILITY\nconsole.log('\\n=== The Magic: Same Code Everywhere ===\\n');\n\nconst honoApp = `// This EXACT code works on Bun, Deno, CF Workers, and Node!\nimport { Hono } from 'hono'\nimport { cors } from 'hono/cors'\nimport { logger } from 'hono/logger'\n\nconst app = new Hono()\n\n// Middleware (same everywhere)\napp.use('*', cors())\napp.use('*', logger())\n\n// Routes (same everywhere)\napp.get('/', (c) => c.text('Hello Hono!'))\n\napp.get('/api/users', (c) => {\n  return c.json([{ id: 1, name: 'Alice' }])\n})\n\napp.post('/api/users', async (c) => {\n  const body = await c.req.json()\n  return c.json({ id: 2, ...body }, 201)\n})\n\napp.get('/health', (c) => {\n  return c.json({ \n    status: 'ok', \n    timestamp: new Date().toISOString() \n  })\n})\n\nexport default app`;\n\nconsole.log(honoApp);\n\n// DEPLOYMENT STEPS FOR BUN ON RENDER\nconsole.log('\\n\\n=== Deploy to Render (Bun) ===\\n');\n\nconst renderSteps = [\n  { step: 1, title: 'Prepare', tasks: ['bun init', 'bun add hono', 'Create src/index.ts'] },\n  { step: 2, title: 'package.json', tasks: ['Add: \"start\": \"bun run src/index.ts\"'] },\n  { step: 3, title: 'Render Setup', tasks: ['New Web Service', 'Connect GitHub', 'Runtime: Node (Bun works here!)'] },\n  { step: 4, title: 'Configure', tasks: ['Build: bun install', 'Start: bun run src/index.ts'] },\n  { step: 5, title: 'Deploy', tasks: ['Add env vars', 'Click Deploy', 'Get URL!'] }\n];\n\nrenderSteps.forEach(({ step, title, tasks }) => {\n  console.log(`Step ${step}: ${title}`);\n  tasks.forEach(t => console.log(`  - ${t}`));\n});\n\nconsole.log('\\n=== Why Hono + Bun? ===');\nconsole.log('- 3x faster than Express');\nconsole.log('- TypeScript native');\nconsole.log('- Tiny bundle size');\nconsole.log('- Deploy anywhere with same code');"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Hono deployment configuration by platform:\n\n1. **Bun on Render** (recommended for beginners):\n   ```typescript\n   // src/index.ts\n   import { Hono } from 'hono'\n   import { cors } from 'hono/cors'\n   \n   const app = new Hono()\n   \n   app.use('*', cors())\n   app.get('/health', (c) => c.json({ status: 'ok' }))\n   \n   export default app\n   \n   // package.json\n   {\n     \"scripts\": {\n       \"start\": \"bun run src/index.ts\",\n       \"dev\": \"bun --watch src/index.ts\"\n     }\n   }\n   ```\n\n2. **Cloudflare Workers** (edge deployment):\n   ```typescript\n   // src/index.ts - same Hono code!\n   import { Hono } from 'hono'\n   const app = new Hono()\n   app.get('/', (c) => c.text('Hello from Edge!'))\n   export default app\n   \n   // wrangler.toml\n   name = \"my-api\"\n   main = \"src/index.ts\"\n   compatibility_date = \"2024-01-01\"\n   \n   // Deploy: wrangler deploy\n   ```\n\n3. **Deno Deploy** (serverless):\n   ```typescript\n   // src/index.ts\n   import { Hono } from 'npm:hono'\n   const app = new Hono()\n   app.get('/', (c) => c.text('Hello from Deno!'))\n   Deno.serve(app.fetch)\n   ```\n\n4. **Environment Variables** (Bun reads .env automatically!):\n   ```typescript\n   // Bun auto-loads .env - no dotenv needed!\n   const dbUrl = process.env.DATABASE_URL\n   const secret = Bun.env.JWT_SECRET  // or process.env\n   ```\n\n5. **CORS with Hono** (built-in middleware):\n   ```typescript\n   import { cors } from 'hono/cors'\n   \n   app.use('*', cors({\n     origin: ['https://my-app.vercel.app', 'http://localhost:5173'],\n     credentials: true\n   }))\n   ```\n\n6. **Health Check** (Hono style):\n   ```typescript\n   app.get('/health', (c) => {\n     return c.json({\n       status: 'ok',\n       timestamp: new Date().toISOString(),\n       runtime: typeof Bun !== 'undefined' ? 'bun' : 'other'\n     })\n   })\n   ```\n\n7. **Error Handling** (Hono's onError):\n   ```typescript\n   app.onError((err, c) => {\n     console.error(err)\n     if (process.env.NODE_ENV === 'production') {\n       return c.json({ error: 'Internal error' }, 500)\n     }\n     return c.json({ error: err.message }, 500)\n   })\n   ```\n\n8. **Database with Drizzle** (works everywhere):\n   ```typescript\n   import { drizzle } from 'drizzle-orm/postgres-js'\n   import postgres from 'postgres'\n   \n   const client = postgres(process.env.DATABASE_URL!)\n   const db = drizzle(client)\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common Hono deployment mistakes:\n\n1. **Forgetting to export default** (Bun/Workers need it!):\n   ```typescript\n   // WRONG! Bun won't serve this\n   const app = new Hono()\n   app.get('/', (c) => c.text('Hello'))\n   // Missing export!\n   \n   // CORRECT!\n   const app = new Hono()\n   app.get('/', (c) => c.text('Hello'))\n   export default app  // Required for Bun!\n   ```\n\n2. **Wrong import for Deno**:\n   ```typescript\n   // WRONG for Deno!\n   import { Hono } from 'hono'\n   \n   // CORRECT for Deno!\n   import { Hono } from 'npm:hono'\n   ```\n\n3. **Committed .env file** (security risk!):\n   ```bash\n   # .gitignore MUST include:\n   .env\n   .env.local\n   node_modules/\n   \n   # Bun lockfile is fine to commit:\n   # bun.lockb\n   ```\n\n4. **Missing start script for Render**:\n   ```json\n   // package.json for Bun on Render\n   {\n     \"scripts\": {\n       \"start\": \"bun run src/index.ts\",\n       \"dev\": \"bun --watch src/index.ts\"\n     }\n   }\n   ```\n\n5. **CORS not configured**:\n   ```typescript\n   // WRONG! No CORS = frontend blocked\n   const app = new Hono()\n   \n   // CORRECT!\n   import { cors } from 'hono/cors'\n   const app = new Hono()\n   app.use('*', cors({\n     origin: ['https://my-app.vercel.app', 'http://localhost:5173']\n   }))\n   ```\n\n6. **Missing health check**:\n   ```typescript\n   // Always add this for monitoring!\n   app.get('/health', (c) => c.json({ status: 'ok' }))\n   ```\n\n7. **Platform-specific code without checks**:\n   ```typescript\n   // WRONG! Bun.env doesn't exist in Cloudflare Workers\n   const secret = Bun.env.SECRET\n   \n   // CORRECT! Works everywhere\n   const secret = process.env.SECRET\n   ```\n\n8. **Not handling errors**:\n   ```typescript\n   // Add global error handler\n   app.onError((err, c) => {\n     console.error(err)\n     return c.json({ error: 'Internal error' }, 500)\n   })\n   \n   // Add 404 handler\n   app.notFound((c) => c.json({ error: 'Not found' }, 404))\n   ```"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Express Equivalent",
              "legacy": "express",
              "content": "Here's how the same deployment would look with Express + Node.js. Express requires more setup and is platform-specific.",
              "code": "// Express + Node.js deployment (traditional approach)\n\n// 1. Install dependencies\n// npm install express cors dotenv\n\n// 2. server.js\nconst express = require('express');\nconst cors = require('cors');\nrequire('dotenv').config();\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(cors({\n  origin: ['https://my-app.vercel.app', 'http://localhost:5173']\n}));\napp.use(express.json());\n\n// Routes\napp.get('/', (req, res) => {\n  res.send('Hello from Express!');\n});\n\napp.get('/api/users', (req, res) => {\n  res.json([{ id: 1, name: 'Alice' }]);\n});\n\napp.get('/health', (req, res) => {\n  res.json({ status: 'ok' });\n});\n\n// Error handler\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({ error: 'Internal error' });\n});\n\napp.listen(PORT, () => {\n  console.log(`Server on port ${PORT}`);\n});\n\n// 3. package.json\n// {\n//   \"scripts\": {\n//     \"start\": \"node server.js\",\n//     \"dev\": \"nodemon server.js\"\n//   }\n// }\n\n// Key Differences:\n// - Express is Node.js only (no Workers, no Deno)\n// - Requires dotenv package for .env\n// - More verbose syntax\n// - No built-in TypeScript\n// - Callback-based (req, res) vs Hono's context (c)",
              "language": "javascript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14.2-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a Hono server ready for multi-platform deployment:\n\n1. Create a `honoApp` object that:\n   - Has routes for /, /health, and /api/users\n   - Shows which platform it's running on\n   - Demonstrates Hono's response helpers (c.text, c.json)\n\n2. Simulate deploying to different platforms (Bun, Workers, Deno)",
              "instructions": "Simulate a Hono server ready for multi-platform deployment:\n\n1. Create a `honoApp` object that:\n   - Has routes for /, /health, and /api/users\n   - Shows which platform it's running on\n   - Demonstrates Hono's response helpers (c.text, c.json)\n\n2. Simulate deploying to different platforms (Bun, Workers, Deno)",
              "starterCode": "// Hono app ready for multi-platform deployment\n\nconst honoApp = {\n  platform: process.env.PLATFORM || 'bun',\n  \n  routes: {\n    '/': (c) => c.text('Hello from Hono!'),\n    '/health': (c) => c.json({ status: 'ok', timestamp: new Date() }),\n    '/api/users': (c) => c.json([{ id: 1, name: 'Alice' }])\n  },\n  \n  // Simulate Hono's context object\n  createContext() {\n    return {\n      text: (content) => ({ type: 'text', body: content }),\n      json: (data) => ({ type: 'json', body: JSON.stringify(data) })\n    };\n  },\n  \n  handleRequest(path) {\n    const c = this.createContext();\n    if (this.routes[path]) {\n      const response = this.routes[path](c);\n      console.log(`[${this.platform}] GET ${path}`);\n      console.log(`Response (${response.type}):`, response.body);\n      return response;\n    }\n    return c.json({ error: 'Not found' });\n  }\n};\n\n// Test\nconsole.log('=== Hono Multi-Platform Demo ===\\n');\nhonoApp.handleRequest('/');\nhonoApp.handleRequest('/health');\nhonoApp.handleRequest('/api/users');",
              "solution": "// Complete Hono app with multi-platform deployment simulation\n\nconst honoApp = {\n  platform: process.env.PLATFORM || 'bun',\n  env: process.env.NODE_ENV || 'development',\n  \n  routes: {\n    '/': (c) => c.text('Hello from Hono!'),\n    '/health': (c) => c.json({ \n      status: 'ok', \n      timestamp: new Date().toISOString(),\n      platform: honoApp.platform\n    }),\n    '/api/users': (c) => c.json([\n      { id: 1, name: 'Alice' },\n      { id: 2, name: 'Bob' }\n    ]),\n    '/api/users/:id': (c) => c.json({ id: c.params.id, name: 'User' })\n  },\n  \n  middleware: [\n    { name: 'cors', applied: true },\n    { name: 'logger', applied: true }\n  ],\n  \n  createContext(params = {}) {\n    return {\n      text: (content) => ({ type: 'text/plain', body: content, status: 200 }),\n      json: (data, status = 200) => ({ type: 'application/json', body: JSON.stringify(data), status }),\n      html: (content) => ({ type: 'text/html', body: content, status: 200 }),\n      params: params\n    };\n  },\n  \n  handleRequest(path, params = {}) {\n    const c = this.createContext(params);\n    console.log(`\\n[${this.platform.toUpperCase()}] GET ${path}`);\n    \n    if (this.routes[path]) {\n      const response = this.routes[path](c);\n      console.log(`Status: ${response.status}`);\n      console.log(`Content-Type: ${response.type}`);\n      console.log(`Body: ${response.body}`);\n      return response;\n    }\n    \n    console.log('Status: 404');\n    return c.json({ error: 'Not found' }, 404);\n  },\n  \n  deployTo(platform) {\n    this.platform = platform;\n    \n    const configs = {\n      bun: {\n        name: 'Bun on Render',\n        buildCmd: 'bun install',\n        startCmd: 'bun run src/index.ts',\n        export: 'export default app'\n      },\n      'cloudflare-workers': {\n        name: 'Cloudflare Workers',\n        buildCmd: 'wrangler deploy',\n        startCmd: '(serverless)',\n        export: 'export default app'\n      },\n      deno: {\n        name: 'Deno Deploy',\n        buildCmd: '(git deploy)',\n        startCmd: 'Deno.serve(app.fetch)',\n        export: 'Deno.serve(app.fetch)'\n      }\n    };\n    \n    const config = configs[platform] || configs.bun;\n    \n    console.log('\\n' + '='.repeat(45));\n    console.log(`Deploying to: ${config.name}`);\n    console.log('='.repeat(45));\n    console.log(`Build: ${config.buildCmd}`);\n    console.log(`Start: ${config.startCmd}`);\n    console.log(`Export: ${config.export}`);\n    console.log('');\n    \n    return config;\n  },\n  \n  showCode() {\n    console.log('\\n// This code works on ALL platforms!');\n    console.log('import { Hono } from \"hono\"');\n    console.log('import { cors } from \"hono/cors\"');\n    console.log('');\n    console.log('const app = new Hono()');\n    console.log('');\n    console.log('app.use(\"*\", cors())');\n    console.log('');\n    console.log('app.get(\"/\", (c) => c.text(\"Hello!\"))');\n    console.log('app.get(\"/health\", (c) => c.json({ status: \"ok\" }))');\n    console.log('app.get(\"/api/users\", (c) => c.json([...]))');\n    console.log('');\n    console.log('export default app  // Works for Bun & Workers');\n    console.log('// OR: Deno.serve(app.fetch)  // For Deno');\n  }\n};\n\n// Demonstrate multi-platform deployment\nconsole.log('=== Hono Multi-Platform Deployment Demo ===\\n');\n\n// Show the universal code\nhonoApp.showCode();\n\n// Test on each platform\nconst platforms = ['bun', 'cloudflare-workers', 'deno'];\n\nplatforms.forEach(platform => {\n  honoApp.deployTo(platform);\n  honoApp.handleRequest('/');\n  honoApp.handleRequest('/health');\n});\n\n// Show portability advantage\nconsole.log('\\n' + '='.repeat(45));\nconsole.log('KEY ADVANTAGE: Same Code Everywhere!');\nconsole.log('='.repeat(45));\nconsole.log('- Write once');\nconsole.log('- Deploy to Bun, Deno, Cloudflare, or Node');\nconsole.log('- Switch platforms without code changes');\nconsole.log('- Edge-ready by default');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should handle requests on multiple platforms",
                  "expectedOutput": "Hello from Hono!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Hono uses c.text(), c.json(), c.html() for responses - the same API works everywhere!"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting export default",
                  "consequence": "Bun and Cloudflare Workers need export default app to serve the application.",
                  "correction": "Always add: export default app"
                },
                {
                  "mistake": "Using Bun.env in Workers",
                  "consequence": "Bun.env only exists in Bun runtime, causing errors on Cloudflare Workers.",
                  "correction": "Use process.env which works everywhere, or check the runtime first."
                },
                {
                  "mistake": "Wrong import for Deno",
                  "consequence": "import { Hono } from 'hono' won't work in Deno without npm: prefix.",
                  "correction": "Use: import { Hono } from 'npm:hono'"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14.3",
          "title": "Deploying React Frontend to Vercel (The Storefront Going Live Analogy)",
          "moduleId": "module-14",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine opening a physical store:\n\nDevelopment (building in your garage):\n- Test the store layout\n- Only you can see it\n- localhost:5173 (your garage address)\n- Close garage door → store disappears\n\nProduction (real storefront on Main Street):\n- Open to the public!\n- Anyone can visit from anywhere\n- https://my-store.vercel.app (real address)\n- Open 24/7 (never closes)\n- Professional hosting (like a shopping mall)\n\nDeploying your React app is the same:\n- Move from localhost to real internet\n- Build optimized version (Vite build)\n- Get a public URL (vercel.app or netlify.app)\n- Hosted on fast servers worldwide (CDN)\n- Connects to your deployed API!\n\nPopular platforms: Vercel (made by Next.js creators, free!), Netlify, Cloudflare Pages"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Deploying React Frontend - Concepts\n\nconsole.log('=== React Frontend Deployment ===\\n');\n\n// CONCEPT: Build Process\nconst buildProcess = {\n  name: 'Vite Build',\n  \n  steps: [\n    'Read all your React components',\n    'Bundle JavaScript into optimized files',\n    'Minify code (remove whitespace, shorten names)',\n    'Optimize images and assets',\n    'Generate index.html',\n    'Output to dist/ folder'\n  ],\n  \n  before: {\n    files: ['src/App.jsx', 'src/components/*.jsx', 'src/main.jsx'],\n    size: '2.5 MB (readable code)'\n  },\n  \n  after: {\n    files: ['dist/index.html', 'dist/assets/index-a3b4c5d6.js', 'dist/assets/index-e7f8g9h0.css'],\n    size: '150 KB (minified and optimized!)'\n  },\n  \n  run() {\n    console.log('🔨 Building React app...\\n');\n    this.steps.forEach((step, i) => {\n      console.log(`  ${i + 1}. ${step}`);\n    });\n    console.log('\\n📦 Before build:');\n    console.log(`  Files: ${this.before.files.join(', ')}`);\n    console.log(`  Size: ${this.before.size}`);\n    console.log('\\n✅ After build:');\n    console.log(`  Files: ${this.after.files.join(', ')}`);\n    console.log(`  Size: ${this.after.size}`);\n    console.log('\\n✓ Build complete! Ready to deploy.');\n  }\n};\n\nbuildProcess.run();\n\n// CONCEPT: Environment Variables\nconsole.log('\\n\\n=== Environment Variables ===\\n');\n\nconst environmentConfig = {\n  development: {\n    API_URL: 'http://localhost:3000',\n    DEBUG: 'true'\n  },\n  \n  production: {\n    API_URL: 'https://my-api.onrender.com',\n    DEBUG: 'false'\n  },\n  \n  showConfig(env) {\n    console.log(`${env.toUpperCase()} Environment:`);\n    const config = this[env];\n    for (let [key, value] of Object.entries(config)) {\n      console.log(`  VITE_${key} = \"${value}\"`);\n    }\n  }\n};\n\nconsole.log('Local development:');\nenvironmentConfig.showConfig('development');\n\nconsole.log('\\nProduction deployment:');\nenvironmentConfig.showConfig('production');\n\nconsole.log('\\nIn your React code:');\nconsole.log(\"const API_URL = import.meta.env.VITE_API_URL;\");\nconsole.log(\"fetch(`${API_URL}/api/users`);\\n\");\n\n// DEPLOYMENT STEPS SIMULATION\nconsole.log('\\n=== Deployment Process (Vercel) ===\\n');\n\nconst deploymentSteps = [\n  {\n    step: 1,\n    title: 'Prepare Your React App',\n    tasks: [\n      'Update API URL to use environment variable',\n      'Test build locally: npm run build',\n      'Add .env to .gitignore',\n      'Commit and push to GitHub'\n    ]\n  },\n  {\n    step: 2,\n    title: 'Create Vercel Account',\n    tasks: [\n      'Go to vercel.com',\n      'Sign up with GitHub',\n      'Click \"Add New\" → \"Project\"'\n    ]\n  },\n  {\n    step: 3,\n    title: 'Import Repository',\n    tasks: [\n      'Select your GitHub repo',\n      'Framework Preset: Vite (auto-detected)',\n      'Root Directory: ./ (or your frontend folder)',\n      'Build Command: npm run build',\n      'Output Directory: dist'\n    ]\n  },\n  {\n    step: 4,\n    title: 'Configure Environment Variables',\n    tasks: [\n      'Click \"Environment Variables\"',\n      'Add: VITE_API_URL = https://my-api.onrender.com',\n      'Add any other VITE_ prefixed variables'\n    ]\n  },\n  {\n    step: 5,\n    title: 'Deploy!',\n    tasks: [\n      'Click \"Deploy\"',\n      'Wait for build (~1 minute)',\n      'Get your URL: https://my-app.vercel.app',\n      'Test: Open URL and check if it connects to API'\n    ]\n  },\n  {\n    step: 6,\n    title: 'Update Backend CORS',\n    tasks: [\n      'Add your Vercel URL to backend CORS',\n      \"In Express: allowedOrigins.push('https://my-app.vercel.app')\",\n      'Redeploy backend',\n      'Test frontend → backend connection'\n    ]\n  }\n];\n\ndeploymentSteps.forEach(({ step, title, tasks }) => {\n  console.log(`Step ${step}: ${title}`);\n  tasks.forEach(task => console.log(`  - ${task}`));\n  console.log('');\n});\n\n// SIMULATING DEPLOYMENT\nconsole.log('=== Simulating Frontend Deployment ===\\n');\n\nconst deployment = {\n  platform: 'Vercel',\n  project: 'my-react-app',\n  url: 'https://my-react-app.vercel.app',\n  status: 'Building',\n  \n  logs: [\n    '[1/6] Cloning repository from GitHub...',\n    '[2/6] Installing dependencies (npm install)...',\n    '[3/6] Building project (npm run build)...',\n    '  ✓ 1247 modules transformed',\n    '  ✓ Built in 8.3s',\n    '[4/6] Optimizing assets...',\n    '  ✓ Images optimized: 12 files',\n    '  ✓ JavaScript minified: 145 KB → 48 KB',\n    '[5/6] Deploying to global CDN...',\n    '[6/6] Assigning domains...',\n    '',\n    '✅ Deployment successful!',\n    '🌐 https://my-react-app.vercel.app',\n    '⚡ Served from 100+ edge locations worldwide'\n  ],\n  \n  deploy() {\n    console.log(`Deploying ${this.project} to ${this.platform}...\\n`);\n    this.logs.forEach(log => {\n      console.log(log);\n    });\n    console.log(`\\n✓ Live at: ${this.url}`);\n    this.status = 'Live';\n  },\n  \n  stats() {\n    console.log('\\n=== Deployment Stats ===\\n');\n    console.log('Status:', this.status);\n    console.log('Platform:', this.platform);\n    console.log('Build time: 8.3 seconds');\n    console.log('Deploy time: 12 seconds');\n    console.log('Total size: 48 KB (gzipped)');\n    console.log('CDN locations: 100+');\n    console.log('SSL: Enabled (HTTPS)');\n    console.log('Auto-deploy: Enabled (push to main → auto deploy)');\n  }\n};\n\ndeployment.deploy();\ndeployment.stats();\n\n// AUTO-DEPLOYMENT\nconsole.log('\\n\\n=== Auto-Deployment Workflow ===\\n');\n\nconst autoDeploySteps = [\n  '1. You push code to GitHub (git push)',\n  '2. Vercel detects the push',\n  '3. Automatically runs build',\n  '4. Deploys new version',\n  '5. Updates live site',\n  '',\n  '⚡ Total time: ~1 minute from push to live!'\n];\n\nautoDeploySteps.forEach(step => console.log(step));"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "React deployment configuration:\n\n1. **Environment Variables** (VITE_ prefix required!):\n   ```javascript\n   // .env.local (development)\n   VITE_API_URL=http://localhost:3000\n   VITE_DEBUG=true\n   \n   // In Vercel dashboard (production)\n   VITE_API_URL=https://my-api.onrender.com\n   VITE_DEBUG=false\n   ```\n   \n   ```javascript\n   // Using in React code\n   const API_URL = import.meta.env.VITE_API_URL;\n   \n   fetch(`${API_URL}/api/users`)\n     .then(res => res.json())\n     .then(data => console.log(data));\n   ```\n\n2. **vite.config.js** (usually default is fine):\n   ```javascript\n   import { defineConfig } from 'vite';\n   import react from '@vitejs/plugin-react';\n   \n   export default defineConfig({\n     plugins: [react()],\n     build: {\n       outDir: 'dist',  // Output folder\n       sourcemap: false  // Don't include source maps in production\n     }\n   });\n   ```\n\n3. **Build Command**:\n   ```bash\n   # Test build locally first!\n   npm run build\n   \n   # Creates dist/ folder with:\n   # - index.html\n   # - assets/index-[hash].js\n   # - assets/index-[hash].css\n   \n   # Preview build locally\n   npm run preview\n   # Opens http://localhost:4173\n   ```\n\n4. **package.json Scripts**:\n   ```json\n   {\n     \"scripts\": {\n       \"dev\": \"vite\",\n       \"build\": \"vite build\",\n       \"preview\": \"vite preview\"\n     }\n   }\n   ```\n\n5. **Connecting to Backend API**:\n   ```javascript\n   // src/config/api.js\n   const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000';\n   \n   export async function fetchUsers() {\n     const response = await fetch(`${API_URL}/api/users`);\n     return response.json();\n   }\n   \n   export async function createUser(userData) {\n     const response = await fetch(`${API_URL}/api/users`, {\n       method: 'POST',\n       headers: { 'Content-Type': 'application/json' },\n       body: JSON.stringify(userData)\n     });\n     return response.json();\n   }\n   ```\n\n6. **Update Backend CORS** (CRITICAL!):\n   ```javascript\n   // Express backend server.js\n   const allowedOrigins = [\n     'https://my-app.vercel.app',      // Your Vercel URL\n     'https://my-app-git-*.vercel.app', // Preview deployments\n     'http://localhost:5173'            // Local dev\n   ];\n   \n   app.use(cors({\n     origin: allowedOrigins,\n     credentials: true\n   }));\n   ```\n\n7. **Vercel Configuration** (optional vercel.json):\n   ```json\n   {\n     \"buildCommand\": \"npm run build\",\n     \"outputDirectory\": \"dist\",\n     \"rewrites\": [\n       {\n         \"source\": \"/(.*)\",\n         \"destination\": \"/index.html\"\n       }\n     ]\n   }\n   ```\n   The `rewrites` rule handles client-side routing (React Router).\n\n8. **.gitignore** (don't commit build folder!):\n   ```\n   node_modules/\n   dist/\n   .env\n   .env.local\n   .env.production\n   .vercel\n   ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common React deployment mistakes:\n\n1. **Wrong environment variable prefix**:\n   ```javascript\n   // WRONG! Won't work in Vite\n   const API_URL = process.env.REACT_APP_API_URL;  // ✗\n   const API_URL = process.env.API_URL;             // ✗\n   \n   // CORRECT for Vite!\n   const API_URL = import.meta.env.VITE_API_URL;   // ✓\n   ```\n\n2. **Hardcoded API URL**:\n   ```javascript\n   // WRONG! Won't work after deployment\n   fetch('http://localhost:3000/api/users');  // ✗\n   \n   // CORRECT!\n   const API_URL = import.meta.env.VITE_API_URL;\n   fetch(`${API_URL}/api/users`);  // ✓\n   ```\n\n3. **Forgot to add env vars in Vercel dashboard**:\n   ```\n   Error: import.meta.env.VITE_API_URL is undefined\n   \n   Fix:\n   1. Go to Vercel project settings\n   2. Environment Variables\n   3. Add: VITE_API_URL = https://my-api.onrender.com\n   4. Redeploy\n   ```\n\n4. **Backend CORS not updated**:\n   ```javascript\n   // Error in browser console:\n   // \"Access to fetch at 'https://api.com' from origin 'https://my-app.vercel.app' \n   // has been blocked by CORS policy\"\n   \n   // Fix in Express backend:\n   const allowedOrigins = [\n     'https://my-app.vercel.app',  // Add this!\n     'http://localhost:5173'\n   ];\n   \n   app.use(cors({ origin: allowedOrigins }));\n   ```\n\n5. **Build folder committed to Git**:\n   ```bash\n   # .gitignore should include:\n   dist/\n   build/\n   .vercel/\n   \n   # If accidentally committed:\n   git rm -r --cached dist\n   git commit -m \"Remove dist folder\"\n   ```\n\n6. **Wrong build output directory**:\n   ```\n   # Vercel settings:\n   Build Command: npm run build\n   Output Directory: dist    ← Must match Vite's output!\n   \n   # Vite outputs to dist/ by default\n   # If you changed it in vite.config.js, update Vercel settings\n   ```\n\n7. **Client-side routing 404 errors**:\n   ```\n   Problem: Refreshing /about gives 404 error\n   \n   Solution: Add vercel.json:\n   {\n     \"rewrites\": [\n       { \"source\": \"/(.*)\", \"destination\": \"/index.html\" }\n     ]\n   }\n   \n   This tells Vercel to serve index.html for all routes\n   (React Router handles routing on the client)\n   ```\n\n8. **Mixed content warning (HTTP/HTTPS)**:\n   ```javascript\n   // WRONG! Frontend is HTTPS, API is HTTP\n   VITE_API_URL=http://my-api.com  // ✗ Browser blocks this!\n   \n   // CORRECT! Both must be HTTPS\n   VITE_API_URL=https://my-api.com  // ✓\n   ```\n\n9. **Environment variables not rebuilding**:\n   ```\n   Changed VITE_API_URL but still seeing old value?\n   \n   Fix:\n   1. Environment vars are baked into build at build time\n   2. Must trigger new deployment after changing them\n   3. In Vercel: Deployments → Redeploy\n   ```\n\n10. **Forgot to test production build locally**:\n    ```bash\n    # Always test before deploying!\n    npm run build      # Build for production\n    npm run preview    # Preview the build locally\n    \n    # Open http://localhost:4173 and test everything\n    # Make sure API calls work!\n    ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14.3-challenge",
              "title": "Practice Challenge",
              "description": "Prepare a React app for deployment:\n\n1. Create a `frontendApp` object that:\n   - Has development and production API URLs\n   - Simulates build process\n   - Shows environment-specific configuration\n\n2. Create a `buildApp()` function that:\n   - Shows build steps\n   - Outputs stats (file size, optimization)\n\n3. Test building for both environments",
              "instructions": "Prepare a React app for deployment:\n\n1. Create a `frontendApp` object that:\n   - Has development and production API URLs\n   - Simulates build process\n   - Shows environment-specific configuration\n\n2. Create a `buildApp()` function that:\n   - Shows build steps\n   - Outputs stats (file size, optimization)\n\n3. Test building for both environments",
              "starterCode": "// React app deployment simulation\n\nconst frontendApp = {\n  name: 'My React App',\n  \n  env: {\n    development: {\n      API_URL: 'http://localhost:3000',\n      NODE_ENV: 'development'\n    },\n    production: {\n      API_URL: 'https://my-api.onrender.com',\n      NODE_ENV: 'production'\n    }\n  },\n  \n  build(environment) {\n    console.log(`\\n🔨 Building for ${environment}...\\n`);\n    \n    const config = this.env[environment];\n    console.log('Environment variables:');\n    console.log(`  VITE_API_URL=${config.API_URL}`);\n    console.log(`  NODE_ENV=${config.NODE_ENV}\\n`);\n    \n    console.log('Build steps:');\n    console.log('  1. Bundling React components');\n    console.log('  2. Minifying JavaScript');\n    console.log('  3. Optimizing assets');\n    console.log('  4. Generating index.html\\n');\n    \n    if (environment === 'production') {\n      console.log('✓ Production optimizations applied');\n      console.log('  - Code minified');\n      console.log('  - Source maps removed');\n      console.log('  - Tree-shaking applied\\n');\n    }\n    \n    console.log('✅ Build complete!');\n    console.log(`   Output: dist/`);\n    console.log(`   Ready to deploy to Vercel\\n`);\n  }\n};\n\n// Test\nfrontendApp.build('development');\nfrontendApp.build('production');",
              "solution": "// Complete React deployment simulation\n\nconst frontendApp = {\n  name: 'My React App',\n  version: '1.0.0',\n  \n  env: {\n    development: {\n      VITE_API_URL: 'http://localhost:3000',\n      VITE_DEBUG: 'true',\n      NODE_ENV: 'development'\n    },\n    production: {\n      VITE_API_URL: 'https://my-api.onrender.com',\n      VITE_DEBUG: 'false',\n      NODE_ENV: 'production'\n    }\n  },\n  \n  files: {\n    source: [\n      'src/App.jsx',\n      'src/components/UserList.jsx',\n      'src/components/LoginForm.jsx',\n      'src/main.jsx',\n      'src/styles.css'\n    ],\n    sourceSize: 2500,  // KB\n    \n    built: [\n      'dist/index.html',\n      'dist/assets/index-a3b4c5d6.js',\n      'dist/assets/index-e7f8g9h0.css'\n    ],\n    builtSize: 145  // KB after optimization\n  },\n  \n  build(environment) {\n    console.log('┌─────────────────────────────────────┐');\n    console.log('│       Building React App            │');\n    console.log('└─────────────────────────────────────┘\\n');\n    \n    console.log(`Environment: ${environment}`);\n    console.log(`Version: ${this.version}\\n`);\n    \n    const config = this.env[environment];\n    console.log('Environment Variables:');\n    Object.entries(config).forEach(([key, value]) => {\n      if (key.startsWith('VITE_')) {\n        console.log(`  ${key}=${value}`);\n      }\n    });\n    \n    console.log('\\n' + '─'.repeat(39));\n    console.log('\\nBuild Process:\\n');\n    \n    const steps = [\n      { name: 'Analyzing dependencies', time: 0.5 },\n      { name: 'Bundling React components', time: 2.1 },\n      { name: 'Transpiling JSX to JavaScript', time: 1.3 },\n      { name: 'Minifying JavaScript', time: 1.8 },\n      { name: 'Optimizing CSS', time: 0.7 },\n      { name: 'Compressing images', time: 0.9 },\n      { name: 'Generating index.html', time: 0.2 }\n    ];\n    \n    steps.forEach((step, i) => {\n      console.log(`  ${i + 1}. ${step.name.padEnd(35)} ${step.time}s`);\n    });\n    \n    const totalTime = steps.reduce((sum, s) => sum + s.time, 0);\n    console.log(`\\n  Total build time: ${totalTime.toFixed(1)}s`);\n    \n    console.log('\\n' + '─'.repeat(39));\n    \n    if (environment === 'production') {\n      console.log('\\n🚀 Production Optimizations:\\n');\n      const optimizations = [\n        'Code splitting enabled',\n        'Tree-shaking applied (removed unused code)',\n        'Minification: 2500 KB → 145 KB',\n        'Gzip compression ready',\n        'Source maps removed',\n        'Image optimization: 85% quality',\n        'CSS purged (unused styles removed)'\n      ];\n      optimizations.forEach(opt => console.log(`  ✓ ${opt}`));\n    } else {\n      console.log('\\n🔧 Development Build:\\n');\n      const devFeatures = [\n        'Source maps included',\n        'Hot module replacement enabled',\n        'Readable code (not minified)',\n        'Detailed error messages'\n      ];\n      devFeatures.forEach(feat => console.log(`  ✓ ${feat}`));\n    }\n    \n    console.log('\\n' + '─'.repeat(39));\n    console.log('\\n✅ Build Complete!\\n');\n    console.log('Output Directory: dist/');\n    console.log('Files generated:');\n    this.files.built.forEach(file => {\n      console.log(`  - ${file}`);\n    });\n    console.log(`\\nTotal size: ${this.files.builtSize} KB`);\n    \n    if (environment === 'production') {\n      console.log(`Compression: ${this.files.sourceSize} KB → ${this.files.builtSize} KB (${Math.round((1 - this.files.builtSize / this.files.sourceSize) * 100)}% smaller)\\n`);\n    }\n    \n    console.log('═'.repeat(39) + '\\n');\n  },\n  \n  deploy(platform) {\n    console.log(`\\n🚀 Deploying to ${platform}...\\n`);\n    \n    const deploySteps = [\n      'Uploading dist/ folder',\n      'Distributing to global CDN',\n      'Configuring SSL certificate',\n      'Assigning domain',\n      'Running health checks'\n    ];\n    \n    deploySteps.forEach((step, i) => {\n      console.log(`  ${i + 1}. ${step}...`);\n    });\n    \n    const url = `https://${this.name.toLowerCase().replace(/\\s+/g, '-')}.vercel.app`;\n    \n    console.log(`\\n✅ Deployment successful!\\n`);\n    console.log(`🌐 Live at: ${url}`);\n    console.log(`⚡ Served from 100+ edge locations worldwide\\n`);\n    \n    return url;\n  },\n  \n  testConnection(apiUrl) {\n    console.log(`\\n🧪 Testing connection to backend...\\n`);\n    console.log(`Frontend: https://my-app.vercel.app`);\n    console.log(`Backend:  ${apiUrl}\\n`);\n    \n    console.log('Testing endpoints:');\n    const tests = [\n      { endpoint: '/health', status: 200, result: 'OK' },\n      { endpoint: '/api/users', status: 200, result: '[2 users]' },\n      { endpoint: '/api/login', status: 200, result: 'OK' }\n    ];\n    \n    tests.forEach(test => {\n      console.log(`  GET ${apiUrl}${test.endpoint}`);\n      console.log(`    → ${test.status} ${test.result}`);\n    });\n    \n    console.log('\\n✅ All endpoints responding correctly!\\n');\n  }\n};\n\n// Simulate complete deployment workflow\nconsole.log('=== Complete Deployment Workflow ===\\n');\n\n// 1. Development build\nconsole.log('Step 1: Test build locally\\n');\nfrontendApp.build('development');\n\n// 2. Production build\nconsole.log('\\nStep 2: Production build\\n');\nfrontendApp.build('production');\n\n// 3. Deploy\nconsole.log('\\nStep 3: Deploy to Vercel\\n');\nconst liveUrl = frontendApp.deploy('Vercel');\n\n// 4. Test backend connection\nconsole.log('Step 4: Test API connection\\n');\nfrontendApp.testConnection(frontendApp.env.production.VITE_API_URL);\n\n// 5. Final checklist\nconsole.log('\\n=== Deployment Checklist ===\\n');\nconst checklist = [\n  '✓ Environment variables configured in Vercel',\n  '✓ API URL points to production backend',\n  '✓ Backend CORS allows Vercel domain',\n  '✓ Build completes without errors',\n  '✓ All API endpoints responding',\n  '✓ SSL certificate active (HTTPS)',\n  '✓ Auto-deploy enabled on git push',\n  '✓ .env files not committed to git'\n];\n\nchecklist.forEach(item => console.log(item));\n\nconsole.log('\\n🎉 Deployment complete! Your app is live!\\n');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should use correct API URL for environment",
                  "expectedOutput": "https://my-api.onrender.com (in production)",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use import.meta.env.VITE_* for environment variables in Vite/React"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common React deployment mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common React deployment mistakes:"
                },
                {
                  "mistake": "**Wrong environment variable prefix**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Wrong environment variable prefix**:\n   ```javascript\n   // WRONG! Won't work in Vite\n   const API_URL = process.env.REACT_APP_API_URL;  // ✗\n   const API_URL = process.env.API_URL;             // ✗\n   \n   // CORRECT for Vite!\n   const API_URL = import.meta.env.VITE_API_URL;   // ✓\n   ```"
                },
                {
                  "mistake": "**Hardcoded API URL**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Hardcoded API URL**:\n   ```javascript\n   // WRONG! Won't work after deployment\n   fetch('http://localhost:3000/api/users');  // ✗\n   \n   // CORRECT!\n   const API_URL = import.meta.env.VITE_API_URL;\n   fetch(`${API_URL}/api/users`);  // ✓\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14.4",
          "title": "Environment Variables in Production (The Secret Recipe Analogy)",
          "moduleId": "module-14",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine you own a restaurant chain:\n\nBad approach (hardcoded secrets):\n- Write secret sauce recipe directly in the cookbook\n- Every employee gets a copy\n- Recipe is in every branch location\n- Employee leaves → they have your secrets!\n- Want to change recipe → reprint all cookbooks!\n\nGood approach (environment variables):\n- Cookbook says: \"Use the secret sauce (see manager)\"\n- Each location stores recipe in a safe\n- Only managers have the combination\n- Employee leaves → recipe stays safe\n- Change recipe → just update the safe\n\nEnvironment variables work the same way:\n- Code says: process.env.DATABASE_PASSWORD\n- Secret stored separately (not in code!)\n- Different value per environment (dev vs prod)\n- Change secrets without changing code\n- Never committed to Git (safe!)\n\nThink of env vars as a safe for your app's secrets!"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Example",
              "content": "See the code example above demonstrating Code Example.",
              "language": "javascript",
              "code": "// Environment Variables - Concepts\n\nconsole.log('=== Environment Variables ===\\n');\n\n// CONCEPT: Separating Code from Configuration\n\n// BAD: Hardcoded secrets (NEVER DO THIS!)\nconst badExample = {\n  database: 'postgres://admin:super_secret_password@db.com/prod',\n  jwtSecret: 'my-secret-key-12345',\n  stripeKey: 'sk_live_abc123xyz',\n  apiKey: 'secret-api-key-do-not-share'\n};\n\nconsole.log('❌ WRONG - Hardcoded Secrets:\\n');\nObject.entries(badExample).forEach(([key, value]) => {\n  console.log(`const ${key} = '${value}';`);\n});\n\nconsole.log('\\nProblems:');\nconst problems = [\n  '✗ Secrets visible in Git history forever',\n  '✗ Everyone with code access sees secrets',\n  '✗ Different environments need different values',\n  '✗ Changing secrets requires code changes',\n  '✗ Accidental public repository = leaked secrets!'\n];\nproblems.forEach(p => console.log(`  ${p}`));\n\n// GOOD: Environment variables\nconsole.log('\\n\\n✅ CORRECT - Environment Variables:\\n');\n\nconst goodExample = {\n  database: process.env.DATABASE_URL,\n  jwtSecret: process.env.JWT_SECRET,\n  stripeKey: process.env.STRIPE_SECRET_KEY,\n  apiKey: process.env.API_KEY\n};\n\nObject.entries(goodExample).forEach(([key, value]) => {\n  console.log(`const ${key} = process.env.${value.replace('process.env.', '')};`);\n});\n\nconsole.log('\\nBenefits:');\nconst benefits = [\n  '✓ Secrets never in code or Git',\n  '✓ Different values per environment',\n  '✓ Change secrets without code changes',\n  '✓ Secure storage on hosting platforms',\n  '✓ Easy to rotate credentials'\n];\nbenefits.forEach(b => console.log(`  ${b}`));\n\n// CONCEPT: Different Environments\nconsole.log('\\n\\n=== Multi-Environment Setup ===\\n');\n\nconst environments = {\n  development: {\n    NODE_ENV: 'development',\n    DATABASE_URL: 'postgres://localhost/myapp_dev',\n    API_URL: 'http://localhost:3000',\n    JWT_SECRET: 'dev-secret-ok-to-be-simple',\n    DEBUG: 'true',\n    LOG_LEVEL: 'debug'\n  },\n  \n  staging: {\n    NODE_ENV: 'staging',\n    DATABASE_URL: 'postgres://staging-db.internal/myapp_staging',\n    API_URL: 'https://staging-api.myapp.com',\n    JWT_SECRET: 'complex-staging-secret-xyz789',\n    DEBUG: 'false',\n    LOG_LEVEL: 'info'\n  },\n  \n  production: {\n    NODE_ENV: 'production',\n    DATABASE_URL: 'postgres://prod-db.aws.com/myapp_prod',\n    API_URL: 'https://api.myapp.com',\n    JWT_SECRET: 'super-complex-production-secret-abc123xyz',\n    DEBUG: 'false',\n    LOG_LEVEL: 'error'\n  }\n};\n\nObject.entries(environments).forEach(([env, vars]) => {\n  console.log(`${env.toUpperCase()} Environment:`);\n  Object.entries(vars).forEach(([key, value]) => {\n    // Mask secrets\n    let displayValue = value;\n    if (key.includes('SECRET') || key.includes('PASSWORD')) {\n      displayValue = value.substring(0, 8) + '...[hidden]';\n    }\n    console.log(`  ${key}=${displayValue}`);\n  });\n  console.log('');\n});\n\n// SIMULATING ENVIRONMENT VARIABLE USAGE\nconsole.log('=== Using Environment Variables ===\\n');\n\nclass AppConfig {\n  constructor() {\n    // Simulate process.env\n    this.env = process.env;\n    \n    // Required variables\n    this.requiredVars = [\n      'DATABASE_URL',\n      'JWT_SECRET',\n      'NODE_ENV'\n    ];\n  }\n  \n  validate() {\n    console.log('Validating environment variables...\\n');\n    \n    const missing = [];\n    \n    this.requiredVars.forEach(varName => {\n      if (!this.env[varName]) {\n        missing.push(varName);\n      }\n    });\n    \n    if (missing.length > 0) {\n      console.log('❌ Missing required environment variables:');\n      missing.forEach(v => console.log(`  - ${v}`));\n      console.log('\\nApp cannot start without these variables!\\n');\n      return false;\n    } else {\n      console.log('✅ All required environment variables present\\n');\n      return true;\n    }\n  }\n  \n  get(key, fallback = null) {\n    const value = this.env[key];\n    if (!value && fallback !== null) {\n      console.log(`⚠ ${key} not set, using fallback: ${fallback}`);\n      return fallback;\n    }\n    return value;\n  }\n  \n  showConfig() {\n    console.log('Current Configuration:');\n    console.log(`  Environment: ${this.get('NODE_ENV', 'development')}`);\n    console.log(`  Database: ${this.maskSecret(this.get('DATABASE_URL', 'Not set'))}`);\n    console.log(`  JWT Secret: ${this.maskSecret(this.get('JWT_SECRET', 'Not set'))}`);\n    console.log(`  Port: ${this.get('PORT', '3000')}`);\n    console.log(`  Debug: ${this.get('DEBUG', 'false')}\\n`);\n  }\n  \n  maskSecret(value) {\n    if (!value || value === 'Not set') return value;\n    if (value.length < 10) return '***';\n    return value.substring(0, 10) + '...[hidden]';\n  }\n}\n\n// Test with development environment\nprocess.env.NODE_ENV = 'development';\nprocess.env.DATABASE_URL = 'postgres://localhost/myapp_dev';\nprocess.env.JWT_SECRET = 'dev-secret';\nprocess.env.PORT = '3000';\n\nconst config = new AppConfig();\nconfig.validate();\nconfig.showConfig();\n\n// BEST PRACTICES\nconsole.log('=== Environment Variable Best Practices ===\\n');\n\nconst bestPractices = [\n  {\n    rule: '1. Never commit secrets to Git',\n    example: 'Add .env to .gitignore immediately!'\n  },\n  {\n    rule: '2. Use descriptive names',\n    example: 'DATABASE_URL (good) vs DB (bad)'\n  },\n  {\n    rule: '3. Provide .env.example',\n    example: 'Template showing what vars are needed (no real values!)'\n  },\n  {\n    rule: '4. Validate on startup',\n    example: 'Crash early if required vars missing'\n  },\n  {\n    rule: '5. Use different values per environment',\n    example: 'dev-simple-secret vs prod-complex-secret-xyz789'\n  },\n  {\n    rule: '6. Rotate secrets regularly',\n    example: 'Change JWT_SECRET every few months'\n  },\n  {\n    rule: '7. Document all variables',\n    example: 'README lists all env vars and what they do'\n  }\n];\n\nbestPractices.forEach(({ rule, example }) => {\n  console.log(rule);\n  console.log(`   → ${example}\\n`);\n});\n\n// COMMON VARIABLES\nconsole.log('=== Common Environment Variables ===\\n');\n\nconst commonVars = {\n  'NODE_ENV': 'development | production | test',\n  'PORT': 'Server port (3000, 8080, etc.)',\n  'DATABASE_URL': 'Full database connection string',\n  'JWT_SECRET': 'Secret key for signing tokens',\n  'API_KEY': 'Third-party API keys',\n  'STRIPE_SECRET_KEY': 'Payment processing key',\n  'AWS_ACCESS_KEY_ID': 'AWS credentials',\n  'SMTP_HOST': 'Email server settings',\n  'CORS_ORIGIN': 'Allowed frontend URLs',\n  'LOG_LEVEL': 'debug | info | warn | error'\n};\n\nObject.entries(commonVars).forEach(([name, description]) => {\n  console.log(`${name.padEnd(20)} - ${description}`);\n});"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Environment variables in practice:\n\n1. **Development (.env file)**:\n   ```bash\n   # .env (local development only, never commit!)\n   NODE_ENV=development\n   PORT=3000\n   DATABASE_URL=postgres://localhost/myapp_dev\n   JWT_SECRET=dev-secret-simple-is-ok\n   STRIPE_SECRET_KEY=sk_test_abc123\n   FRONTEND_URL=http://localhost:5173\n   ```\n\n2. **Loading .env file** (using dotenv):\n   ```javascript\n   // At the very top of server.js\n   import 'dotenv/config';\n   // or\n   require('dotenv').config();\n   \n   // Now process.env has your variables!\n   console.log(process.env.DATABASE_URL);\n   ```\n\n3. **Using environment variables**:\n   ```javascript\n   // Good pattern with fallbacks\n   const PORT = process.env.PORT || 3000;\n   const NODE_ENV = process.env.NODE_ENV || 'development';\n   \n   // Required variables (no fallback)\n   const DATABASE_URL = process.env.DATABASE_URL;\n   if (!DATABASE_URL) {\n     throw new Error('DATABASE_URL environment variable is required!');\n   }\n   \n   // Type conversion\n   const MAX_CONNECTIONS = parseInt(process.env.MAX_CONNECTIONS || '10', 10);\n   const ENABLE_DEBUG = process.env.ENABLE_DEBUG === 'true';\n   ```\n\n4. **Validation helper**:\n   ```javascript\n   function requireEnv(name) {\n     const value = process.env[name];\n     if (!value) {\n       throw new Error(`Missing required environment variable: ${name}`);\n     }\n     return value;\n   }\n   \n   // Usage\n   const DATABASE_URL = requireEnv('DATABASE_URL');\n   const JWT_SECRET = requireEnv('JWT_SECRET');\n   ```\n\n5. **.env.example** (commit this!):\n   ```bash\n   # .env.example - Template for other developers\n   # Copy this to .env and fill in real values\n   \n   NODE_ENV=development\n   PORT=3000\n   DATABASE_URL=postgres://localhost/myapp_dev\n   JWT_SECRET=your-secret-here\n   STRIPE_SECRET_KEY=sk_test_your-key\n   ```\n\n6. **.gitignore** (CRITICAL!):\n   ```\n   # Never commit these!\n   .env\n   .env.local\n   .env.development\n   .env.production\n   .env.test\n   \n   # DO commit this:\n   # .env.example\n   ```\n\n7. **Setting in Render (Backend)**:\n   ```\n   Render Dashboard:\n   1. Go to your web service\n   2. Click \"Environment\"\n   3. Add variables:\n      DATABASE_URL = postgres://...\n      JWT_SECRET = your-production-secret\n      NODE_ENV = production\n   4. Save (triggers redeploy)\n   ```\n\n8. **Setting in Vercel (Frontend)**:\n   ```\n   Vercel Dashboard:\n   1. Project Settings → Environment Variables\n   2. Add variables (must start with VITE_):\n      VITE_API_URL = https://api.myapp.com\n      VITE_STRIPE_PUBLIC_KEY = pk_live_...\n   3. Redeploy to apply changes\n   ```\n\n9. **Environment-specific logic**:\n   ```javascript\n   const isDevelopment = process.env.NODE_ENV === 'development';\n   const isProduction = process.env.NODE_ENV === 'production';\n   \n   if (isDevelopment) {\n     // Detailed logging\n     console.log('Full error:', error.stack);\n     \n     // Allow all CORS in dev\n     app.use(cors({ origin: '*' }));\n   }\n   \n   if (isProduction) {\n     // Hide error details\n     console.log('Error occurred');\n     \n     // Strict CORS\n     app.use(cors({ origin: process.env.FRONTEND_URL }));\n   }\n   ```\n\n10. **Configuration module pattern**:\n    ```javascript\n    // config/index.js\n    export const config = {\n      env: process.env.NODE_ENV || 'development',\n      port: parseInt(process.env.PORT || '3000', 10),\n      \n      database: {\n        url: process.env.DATABASE_URL,\n        poolSize: parseInt(process.env.DB_POOL_SIZE || '10', 10)\n      },\n      \n      jwt: {\n        secret: process.env.JWT_SECRET,\n        expiresIn: process.env.JWT_EXPIRES || '7d'\n      },\n      \n      stripe: {\n        secretKey: process.env.STRIPE_SECRET_KEY,\n        webhookSecret: process.env.STRIPE_WEBHOOK_SECRET\n      },\n      \n      cors: {\n        origin: process.env.CORS_ORIGIN || 'http://localhost:5173'\n      }\n    };\n    \n    // Validate on import\n    const required = ['DATABASE_URL', 'JWT_SECRET'];\n    required.forEach(key => {\n      if (!process.env[key]) {\n        throw new Error(`Missing required env var: ${key}`);\n      }\n    });\n    ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common environment variable mistakes:\n\n1. **Committing .env to Git** (MAJOR security issue!):\n   ```bash\n   # Check if .env is tracked:\n   git ls-files | grep .env\n   \n   # If it returns .env, you've committed secrets!\n   # Fix immediately:\n   git rm --cached .env\n   echo \".env\" >> .gitignore\n   git commit -m \"Remove .env from git\"\n   \n   # If already pushed to GitHub:\n   # 1. Rotate all secrets immediately!\n   # 2. Consider the secrets compromised\n   ```\n\n2. **Forgot to load dotenv**:\n   ```javascript\n   // Error: process.env.DATABASE_URL is undefined\n   \n   // Fix: Load dotenv at the very top\n   import 'dotenv/config';  // Must be first!\n   import express from 'express';\n   \n   // or\n   require('dotenv').config();  // Must be first!\n   const express = require('express');\n   ```\n\n3. **Wrong variable names** (typos):\n   ```javascript\n   // .env\n   DATABASE_URL=postgres://...\n   \n   // server.js\n   const db = process.env.DATABSE_URL;  // ✗ Typo! Returns undefined\n   const db = process.env.DATABASE_URL;  // ✓ Correct\n   \n   // Tip: Use constants to avoid typos\n   const REQUIRED_VARS = ['DATABASE_URL', 'JWT_SECRET'];\n   ```\n\n4. **Not updating production env vars**:\n   ```\n   Changed .env locally but forgot to update Render!\n   \n   Fix:\n   1. Update .env → works locally\n   2. Update Render Environment Variables → works in production\n   3. Must update BOTH places!\n   ```\n\n5. **Hardcoded fallbacks for secrets**:\n   ```javascript\n   // WRONG! Production will use insecure fallback\n   const JWT_SECRET = process.env.JWT_SECRET || 'default-secret';  // ✗\n   \n   // CORRECT! Fail if secret is missing\n   const JWT_SECRET = process.env.JWT_SECRET;\n   if (!JWT_SECRET) {\n     throw new Error('JWT_SECRET environment variable is required!');\n   }\n   ```\n\n6. **Type confusion** (everything is a string!):\n   ```javascript\n   // WRONG! process.env values are always strings\n   const PORT = process.env.PORT;  // \"3000\" (string)\n   app.listen(PORT);  // Works but technically wrong type\n   \n   const MAX = process.env.MAX_ITEMS;  // \"10\" (string)\n   if (items.length > MAX) // ✗ String comparison!\n   \n   // CORRECT! Convert types explicitly\n   const PORT = parseInt(process.env.PORT || '3000', 10);  // number\n   const MAX = parseInt(process.env.MAX_ITEMS || '10', 10);  // number\n   const DEBUG = process.env.DEBUG === 'true';  // boolean\n   ```\n\n7. **Exposing env vars in frontend** (React/Vite):\n   ```javascript\n   // Backend (.env) - These are SECRET!\n   DATABASE_URL=postgres://...\n   JWT_SECRET=super-secret\n   STRIPE_SECRET_KEY=sk_live_...\n   \n   // Frontend (.env) - These are PUBLIC!\n   VITE_API_URL=https://api.com\n   VITE_STRIPE_PUBLIC_KEY=pk_live_...  // Note: PUBLIC key\n   \n   // Remember: VITE_ vars are bundled into JavaScript\n   // Anyone can see them in browser!\n   // NEVER put secrets in VITE_ variables!\n   ```\n\n8. **Missing .env.example**:\n   ```bash\n   # Create .env.example (commit this!)\n   # Other developers copy this to .env\n   \n   # .env.example\n   NODE_ENV=development\n   PORT=3000\n   DATABASE_URL=postgres://localhost/myapp_dev\n   JWT_SECRET=your-secret-here\n   STRIPE_SECRET_KEY=sk_test_your-key\n   \n   # Instructions for new developers:\n   # 1. Copy .env.example to .env\n   # 2. Fill in real values\n   # 3. Never commit .env!\n   ```\n\n9. **Environment variables not rebuilding**:\n   ```\n   React/Vite issue:\n   - Changed VITE_API_URL in Vercel\n   - Still seeing old value!\n   \n   Why: Env vars are baked into build at build time\n   \n   Fix:\n   1. Change env var in Vercel dashboard\n   2. Trigger new deployment (Deployments → Redeploy)\n   3. Env vars from build time are used, not runtime!\n   ```\n\n10. **Different formats on different platforms**:\n    ```bash\n    # .env file format (local)\n    DATABASE_URL=postgres://localhost/db\n    NODE_ENV=development\n    \n    # Render format (same!)\n    DATABASE_URL = postgres://render.com/db\n    NODE_ENV = production\n    \n    # Note: Render adds spaces around =, both work fine\n    # Just be consistent in your .env file\n    ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14.4-challenge",
              "title": "Practice Challenge",
              "description": "Create an environment configuration system:\n\n1. Create a `Config` class that:\n   - Loads variables from process.env\n   - Validates required variables\n   - Provides get() method with fallbacks\n   - Masks secrets when displaying\n\n2. Test with sample environment variables",
              "instructions": "Create an environment configuration system:\n\n1. Create a `Config` class that:\n   - Loads variables from process.env\n   - Validates required variables\n   - Provides get() method with fallbacks\n   - Masks secrets when displaying\n\n2. Test with sample environment variables",
              "starterCode": "// Environment configuration manager\n\nclass Config {\n  constructor() {\n    this.required = ['DATABASE_URL', 'JWT_SECRET'];\n  }\n  \n  validate() {\n    const missing = this.required.filter(key => !process.env[key]);\n    \n    if (missing.length > 0) {\n      console.log('❌ Missing required variables:');\n      missing.forEach(v => console.log(`  - ${v}`));\n      return false;\n    }\n    \n    console.log('✅ All required variables present');\n    return true;\n  }\n  \n  get(key, fallback = null) {\n    return process.env[key] || fallback;\n  }\n  \n  maskSecret(value) {\n    if (!value || value.length < 8) return '***';\n    return value.substring(0, 8) + '...';\n  }\n  \n  show() {\n    console.log('\\nConfiguration:');\n    console.log(`  NODE_ENV: ${this.get('NODE_ENV', 'development')}`);\n    console.log(`  PORT: ${this.get('PORT', '3000')}`);\n    console.log(`  DATABASE: ${this.maskSecret(this.get('DATABASE_URL', 'not set'))}`);\n    console.log(`  JWT_SECRET: ${this.maskSecret(this.get('JWT_SECRET', 'not set'))}`);\n  }\n}\n\n// Test\nprocess.env.NODE_ENV = 'production';\nprocess.env.PORT = '8080';\nprocess.env.DATABASE_URL = 'postgres://prod-db.com/myapp';\nprocess.env.JWT_SECRET = 'super-secret-key-xyz';\n\nconst config = new Config();\nconfig.validate();\nconfig.show();",
              "solution": "// Complete environment configuration system\n\nclass Config {\n  constructor() {\n    // Define required variables\n    this.required = [\n      'NODE_ENV',\n      'DATABASE_URL',\n      'JWT_SECRET'\n    ];\n    \n    // Define optional variables with defaults\n    this.defaults = {\n      PORT: '3000',\n      LOG_LEVEL: 'info',\n      CORS_ORIGIN: 'http://localhost:5173',\n      JWT_EXPIRES: '7d'\n    };\n    \n    this.env = process.env;\n  }\n  \n  validate() {\n    console.log('🔍 Validating environment configuration...\\n');\n    \n    const missing = [];\n    const present = [];\n    \n    this.required.forEach(key => {\n      if (!this.env[key]) {\n        missing.push(key);\n      } else {\n        present.push(key);\n      }\n    });\n    \n    if (present.length > 0) {\n      console.log('✅ Found required variables:');\n      present.forEach(v => console.log(`  ✓ ${v}`));\n      console.log('');\n    }\n    \n    if (missing.length > 0) {\n      console.log('❌ Missing required variables:');\n      missing.forEach(v => console.log(`  ✗ ${v}`));\n      console.log('\\n⚠ Application cannot start without these variables!\\n');\n      return false;\n    }\n    \n    console.log('✅ All required environment variables present!\\n');\n    return true;\n  }\n  \n  get(key, fallback = null) {\n    let value = this.env[key];\n    \n    // Use default if available\n    if (!value && this.defaults[key]) {\n      value = this.defaults[key];\n    }\n    \n    // Use provided fallback\n    if (!value && fallback !== null) {\n      value = fallback;\n    }\n    \n    return value;\n  }\n  \n  getInt(key, fallback = 0) {\n    const value = this.get(key, fallback.toString());\n    return parseInt(value, 10);\n  }\n  \n  getBool(key, fallback = false) {\n    const value = this.get(key, fallback.toString());\n    return value === 'true' || value === '1';\n  }\n  \n  isProduction() {\n    return this.get('NODE_ENV') === 'production';\n  }\n  \n  isDevelopment() {\n    return this.get('NODE_ENV') === 'development';\n  }\n  \n  maskSecret(value) {\n    if (!value || value === 'not set') return value;\n    if (value.length < 8) return '***';\n    return value.substring(0, 8) + '...[hidden]';\n  }\n  \n  show() {\n    console.log('┌─────────────────────────────────────┐');\n    console.log('│     Environment Configuration        │');\n    console.log('└─────────────────────────────────────┘\\n');\n    \n    console.log('General:');\n    console.log(`  NODE_ENV:     ${this.get('NODE_ENV')}`);\n    console.log(`  PORT:         ${this.get('PORT')}`);\n    console.log(`  LOG_LEVEL:    ${this.get('LOG_LEVEL')}\\n`);\n    \n    console.log('Database:');\n    console.log(`  DATABASE_URL: ${this.maskSecret(this.get('DATABASE_URL', 'not set'))}\\n`);\n    \n    console.log('Security:');\n    console.log(`  JWT_SECRET:   ${this.maskSecret(this.get('JWT_SECRET', 'not set'))}`);\n    console.log(`  JWT_EXPIRES:  ${this.get('JWT_EXPIRES')}\\n`);\n    \n    console.log('CORS:');\n    console.log(`  CORS_ORIGIN:  ${this.get('CORS_ORIGIN')}\\n`);\n    \n    if (this.isProduction()) {\n      console.log('🚀 Running in PRODUCTION mode');\n    } else {\n      console.log('🔧 Running in DEVELOPMENT mode');\n    }\n    \n    console.log('\\n' + '═'.repeat(39) + '\\n');\n  }\n  \n  toObject() {\n    return {\n      env: this.get('NODE_ENV'),\n      port: this.getInt('PORT'),\n      logLevel: this.get('LOG_LEVEL'),\n      \n      database: {\n        url: this.get('DATABASE_URL')\n      },\n      \n      jwt: {\n        secret: this.get('JWT_SECRET'),\n        expiresIn: this.get('JWT_EXPIRES')\n      },\n      \n      cors: {\n        origin: this.get('CORS_ORIGIN')\n      }\n    };\n  }\n}\n\n// Simulate different environments\nconsole.log('=== Testing Environment Configurations ===\\n');\n\n// Test 1: Development\nconsole.log('Test 1: Development Environment\\n');\nprocess.env.NODE_ENV = 'development';\nprocess.env.PORT = '3000';\nprocess.env.DATABASE_URL = 'postgres://localhost/myapp_dev';\nprocess.env.JWT_SECRET = 'dev-secret-simple';\n\nlet config = new Config();\nconfig.validate();\nconfig.show();\n\n// Test 2: Production\nconsole.log('\\nTest 2: Production Environment\\n');\nprocess.env.NODE_ENV = 'production';\nprocess.env.PORT = '8080';\nprocess.env.DATABASE_URL = 'postgres://prod.aws.com/myapp';\nprocess.env.JWT_SECRET = 'super-complex-prod-secret-xyz789';\nprocess.env.LOG_LEVEL = 'error';\nprocess.env.CORS_ORIGIN = 'https://myapp.com';\n\nconfig = new Config();\nconfig.validate();\nconfig.show();\n\n// Test 3: Missing required variable\nconsole.log('\\nTest 3: Missing Required Variable\\n');\ndelete process.env.JWT_SECRET;\n\nconfig = new Config();\nconst isValid = config.validate();\n\nif (!isValid) {\n  console.log('Cannot start application. Please set missing variables.\\n');\n}\n\n// Best practices guide\nconsole.log('\\n=== Environment Variable Best Practices ===\\n');\n\nconst guide = [\n  {\n    do: '✓ Use .env for local development',\n    dont: '✗ Commit .env to Git'\n  },\n  {\n    do: '✓ Provide .env.example template',\n    dont: '✗ Put real secrets in .env.example'\n  },\n  {\n    do: '✓ Validate required vars on startup',\n    dont: \"✗ Let app crash with 'undefined' errors\"\n  },\n  {\n    do: '✓ Use descriptive variable names',\n    dont: '✗ Use vague names like SECRET or KEY'\n  },\n  {\n    do: '✓ Different secrets per environment',\n    dont: '✗ Reuse dev secrets in production'\n  },\n  {\n    do: '✓ Document all variables in README',\n    dont: '✗ Leave developers guessing'\n  }\n];\n\nguide.forEach(({ do: good, dont: bad }) => {\n  console.log(good);\n  console.log(bad);\n  console.log('');\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should detect missing required variables",
                  "expectedOutput": "false (missing JWT_SECRET)",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use process.env to access environment variables"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Common environment variable mistakes:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "Common environment variable mistakes:"
                },
                {
                  "mistake": "**Committing .env to Git** (MAJOR security issue!):",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Committing .env to Git** (MAJOR security issue!):\n   ```bash\n   # Check if .env is tracked:\n   git ls-files | grep .env\n   \n   # If it returns .env, you've committed secrets!\n   # Fix immediately:\n   git rm --cached .env\n   echo \".env\" >> .gitignore\n   git commit -m \"Remove .env from git\"\n   \n   # If already pushed to GitHub:\n   # 1. Rotate all secrets immediately!\n   # 2. Consider the secrets compromised\n   ```"
                },
                {
                  "mistake": "**Forgot to load dotenv**:",
                  "consequence": "This can lead to errors or unexpected behavior.",
                  "correction": "**Forgot to load dotenv**:\n   ```javascript\n   // Error: process.env.DATABASE_URL is undefined\n   \n   // Fix: Load dotenv at the very top\n   import 'dotenv/config';  // Must be first!\n   import express from 'express';\n   \n   // or\n   require('dotenv').config();  // Must be first!\n   const express = require('express');\n   ```"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "14.5",
          "title": "CI/CD with GitHub Actions (The Assembly Line Analogy)",
          "moduleId": "module-14",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Understanding the Concept",
              "content": "Imagine a car factory assembly line:\n\nWithout automation (manual deployment):\n- Workers manually check each part\n- Someone forgets to test the brakes\n- Defective cars reach customers\n- Recalls are expensive and embarrassing\n- Inconsistent quality between shifts\n\nWith assembly line automation (CI/CD):\n- Robots test EVERY car automatically\n- Defects caught before shipping\n- Consistent quality every time\n- Faster production\n- Workers focus on improvements, not repetitive checks\n\nCI/CD (Continuous Integration / Continuous Deployment):\n- CI: Automatically test every code change\n- CD: Automatically deploy when tests pass\n- GitHub Actions: The robots that run your pipeline\n\nWith Bun, your CI/CD is FAST:\n- bun install: 10x faster than npm\n- bun test: Native test runner, blazing speed\n- Less waiting = more shipping\n\nEvery push triggers: Install → Test → Build → Deploy\nNo manual steps, no forgotten tests, no broken deployments!"
            },
            {
              "type": "EXAMPLE",
              "title": "GitHub Actions with Bun",
              "content": "A complete CI/CD pipeline that runs on every push using Bun for maximum speed.",
              "language": "yaml",
              "code": "# .github/workflows/ci.yml\n# CI/CD Pipeline with Bun - runs on every push\n\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    name: Test & Build\n    runs-on: ubuntu-latest\n    \n    steps:\n      # 1. Check out the code\n      - name: Checkout repository\n        uses: actions/checkout@v4\n      \n      # 2. Set up Bun (instead of Node.js!)\n      - name: Setup Bun\n        uses: oven-sh/setup-bun@v2\n        with:\n          bun-version: latest\n      \n      # 3. Install dependencies (10x faster than npm!)\n      - name: Install dependencies\n        run: bun install\n      \n      # 4. Run linting\n      - name: Lint code\n        run: bun run lint\n      \n      # 5. Run tests\n      - name: Run tests\n        run: bun test\n      \n      # 6. Build the project\n      - name: Build\n        run: bun run build\n      \n      # 7. Upload build artifacts\n      - name: Upload build\n        uses: actions/upload-artifact@v4\n        with:\n          name: build\n          path: dist/\n\n  deploy:\n    name: Deploy to Production\n    needs: test  # Only runs if tests pass!\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'  # Only on main branch\n    \n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n      \n      - name: Download build\n        uses: actions/download-artifact@v4\n        with:\n          name: build\n          path: dist/\n      \n      - name: Deploy to Render\n        run: |\n          curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}\n        # Or deploy to Cloudflare Workers:\n        # - name: Deploy to Workers\n        #   run: bunx wrangler deploy"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the Syntax",
              "content": "Understanding the GitHub Actions workflow with Bun:\n\n1. **Workflow File Location**:\n   ```\n   .github/workflows/ci.yml\n   \n   GitHub automatically detects YAML files here and runs them\n   ```\n\n2. **Triggers (on)**:\n   ```yaml\n   on:\n     push:\n       branches: [main, develop]  # Run on push to these branches\n     pull_request:\n       branches: [main]           # Run on PRs to main\n   ```\n\n3. **Setting up Bun** (key difference from npm!):\n   ```yaml\n   - name: Setup Bun\n     uses: oven-sh/setup-bun@v2\n     with:\n       bun-version: latest\n   ```\n\n4. **Bun Commands** (faster than npm!):\n   ```yaml\n   # Install dependencies (10x faster)\n   - run: bun install\n   \n   # Run tests (native test runner)\n   - run: bun test\n   \n   # Build project\n   - run: bun run build\n   \n   # Run scripts from package.json\n   - run: bun run lint\n   ```\n\n5. **Job Dependencies** (deploy only if tests pass):\n   ```yaml\n   deploy:\n     needs: test  # Wait for test job to succeed\n     if: github.ref == 'refs/heads/main'  # Only on main\n   ```\n\n6. **Secrets** (never hardcode!):\n   ```yaml\n   - run: curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}\n   \n   # Add secrets in: GitHub → Repo → Settings → Secrets\n   ```\n\n7. **Caching** (speed up future runs):\n   ```yaml\n   - name: Cache Bun dependencies\n     uses: actions/cache@v4\n     with:\n       path: ~/.bun/install/cache\n       key: ${{ runner.os }}-bun-${{ hashFiles('bun.lockb') }}\n   ```\n\n8. **Matrix Testing** (test multiple versions):\n   ```yaml\n   strategy:\n     matrix:\n       bun-version: ['1.0', '1.1', 'latest']\n   steps:\n     - uses: oven-sh/setup-bun@v2\n       with:\n         bun-version: ${{ matrix.bun-version }}\n   ```\n\n9. **Package.json Scripts for CI**:\n   ```json\n   {\n     \"scripts\": {\n       \"test\": \"bun test\",\n       \"lint\": \"bunx biome check .\",\n       \"build\": \"bun run build:app\",\n       \"typecheck\": \"bunx tsc --noEmit\"\n     }\n   }\n   ```\n\n10. **Complete CI Pipeline Order**:\n    ```\n    1. Checkout code (actions/checkout)\n    2. Setup Bun (oven-sh/setup-bun)\n    3. Install dependencies (bun install)\n    4. Lint code (bun run lint)\n    5. Type check (bunx tsc --noEmit)\n    6. Run tests (bun test)\n    7. Build (bun run build)\n    8. Deploy (if main branch and tests pass)\n    ```"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "Common CI/CD mistakes:\n\n1. **Using npm instead of bun**:\n   ```yaml\n   # WRONG! Slow installs\n   - run: npm install\n   - run: npm test\n   \n   # CORRECT! 10x faster\n   - uses: oven-sh/setup-bun@v2\n   - run: bun install\n   - run: bun test\n   ```\n\n2. **Deploying on failed tests**:\n   ```yaml\n   # WRONG! Deploy runs even if tests fail\n   jobs:\n     test:\n       ...\n     deploy:\n       ...  # No dependency!\n   \n   # CORRECT! Deploy waits for test\n   jobs:\n     test:\n       ...\n     deploy:\n       needs: test  # Only if test succeeds!\n   ```\n\n3. **Secrets in code**:\n   ```yaml\n   # WRONG! Never do this\n   - run: curl -X POST https://api.render.com/hooks/abc123\n   \n   # CORRECT! Use GitHub secrets\n   - run: curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}\n   \n   # Add in: Settings → Secrets → Actions\n   ```\n\n4. **Missing workflow file**:\n   ```\n   Correct location:\n   .github/workflows/ci.yml\n   \n   NOT:\n   - github/workflows/ci.yml (missing dot)\n   - .github/workflow/ci.yml (singular)\n   - workflows/ci.yml (wrong folder)\n   ```\n\n5. **Deploying every branch**:\n   ```yaml\n   # WRONG! Deploys on every push\n   deploy:\n     ...\n   \n   # CORRECT! Only deploy main\n   deploy:\n     if: github.ref == 'refs/heads/main'\n   ```\n\n6. **Not caching dependencies**:\n   ```yaml\n   # Add caching for faster builds\n   - name: Cache Bun\n     uses: actions/cache@v4\n     with:\n       path: ~/.bun/install/cache\n       key: ${{ runner.os }}-bun-${{ hashFiles('bun.lockb') }}\n   ```\n\n7. **No test coverage requirements**:\n   ```yaml\n   # Add coverage check\n   - name: Run tests with coverage\n     run: bun test --coverage\n   \n   # Fail if coverage too low\n   - run: bun run check-coverage\n   ```\n\n8. **Ignoring PR checks**:\n   ```yaml\n   # Always run on PRs!\n   on:\n     pull_request:\n       branches: [main]\n   \n   # Catch bugs BEFORE merging\n   ```"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "npm/Node.js Equivalent",
              "legacy": "npm",
              "content": "Here's the same CI/CD workflow using traditional npm and Node.js. Notice the slower install times and different setup.",
              "code": "# .github/workflows/ci.yml (npm version)\nname: CI/CD Pipeline (npm)\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      # Node.js setup (instead of Bun)\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      \n      # npm install (slower than bun)\n      - name: Install dependencies\n        run: npm ci\n      \n      # Run tests with npm\n      - run: npm run lint\n      - run: npm test\n      - run: npm run build\n      \n      - uses: actions/upload-artifact@v4\n        with:\n          name: build\n          path: dist/\n\n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    steps:\n      - uses: actions/checkout@v4\n      - run: curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}\n\n# Key Differences:\n# - setup-node instead of oven-sh/setup-bun\n# - npm ci instead of bun install (slower)\n# - npm test instead of bun test\n# - Separate test runner (Jest/Vitest vs bun test)\n# - Build times typically 2-5x slower",
              "language": "yaml"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14.5-challenge",
              "title": "Practice Challenge",
              "description": "Simulate a CI/CD pipeline:\n\n1. Create a `CIPipeline` class that:\n   - Runs steps in order (checkout, install, test, build, deploy)\n   - Stops if any step fails\n   - Shows timing for each step\n   - Only deploys if on 'main' branch\n\n2. Simulate running the pipeline with both passing and failing tests",
              "instructions": "Simulate a CI/CD pipeline:\n\n1. Create a `CIPipeline` class that:\n   - Runs steps in order (checkout, install, test, build, deploy)\n   - Stops if any step fails\n   - Shows timing for each step\n   - Only deploys if on 'main' branch\n\n2. Simulate running the pipeline with both passing and failing tests",
              "starterCode": "// CI/CD Pipeline Simulation\n\nclass CIPipeline {\n  constructor(branch) {\n    this.branch = branch;\n    this.steps = [];\n    this.failed = false;\n  }\n  \n  runStep(name, action) {\n    if (this.failed) {\n      console.log(`  [SKIPPED] ${name}`);\n      return false;\n    }\n    \n    const startTime = Date.now();\n    console.log(`  [RUNNING] ${name}...`);\n    \n    const success = action();\n    const duration = Date.now() - startTime;\n    \n    if (success) {\n      console.log(`  [PASSED] ${name} (${duration}ms)`);\n    } else {\n      console.log(`  [FAILED] ${name}`);\n      this.failed = true;\n    }\n    \n    return success;\n  }\n  \n  run(testsShouldPass = true) {\n    console.log(`\\n=== CI Pipeline: ${this.branch} ===\\n`);\n    \n    this.runStep('Checkout', () => true);\n    this.runStep('bun install', () => true);\n    this.runStep('bun test', () => testsShouldPass);\n    this.runStep('bun run build', () => true);\n    \n    if (this.branch === 'main' && !this.failed) {\n      this.runStep('Deploy to Production', () => true);\n    } else if (this.branch !== 'main') {\n      console.log('  [INFO] Not main branch - skipping deploy');\n    }\n    \n    console.log(`\\n${this.failed ? 'Pipeline FAILED' : 'Pipeline PASSED'}\\n`);\n  }\n}\n\n// Test\nconst pipeline = new CIPipeline('main');\npipeline.run(true);",
              "solution": "// Complete CI/CD Pipeline Simulation\n\nclass CIPipeline {\n  constructor(branch) {\n    this.branch = branch;\n    this.steps = [];\n    this.failed = false;\n    this.totalTime = 0;\n  }\n  \n  runStep(name, action, simulatedTime = 100) {\n    if (this.failed) {\n      console.log(`  [SKIPPED] ${name}`);\n      this.steps.push({ name, status: 'skipped', duration: 0 });\n      return false;\n    }\n    \n    const startTime = Date.now();\n    console.log(`  [RUNNING] ${name}...`);\n    \n    const success = action();\n    const duration = simulatedTime + Math.floor(Math.random() * 50);\n    this.totalTime += duration;\n    \n    if (success) {\n      console.log(`  [PASSED] ${name} (${duration}ms)`);\n      this.steps.push({ name, status: 'passed', duration });\n    } else {\n      console.log(`  [FAILED] ${name}`);\n      this.steps.push({ name, status: 'failed', duration });\n      this.failed = true;\n    }\n    \n    return success;\n  }\n  \n  run(testsShouldPass = true) {\n    console.log('\\n' + '='.repeat(50));\n    console.log(`CI Pipeline: ${this.branch}`);\n    console.log('='.repeat(50) + '\\n');\n    \n    console.log('Trigger: push to ' + this.branch);\n    console.log('Runner: ubuntu-latest\\n');\n    \n    // Job 1: Test & Build\n    console.log('Job: test');\n    console.log('-'.repeat(30));\n    \n    this.runStep('actions/checkout@v4', () => true, 50);\n    this.runStep('oven-sh/setup-bun@v2', () => true, 200);\n    this.runStep('bun install', () => true, 800);\n    this.runStep('bun run lint', () => true, 300);\n    this.runStep('bun test', () => testsShouldPass, 500);\n    this.runStep('bun run build', () => !this.failed, 600);\n    this.runStep('actions/upload-artifact@v4', () => !this.failed, 150);\n    \n    console.log('');\n    \n    // Job 2: Deploy (only on main and if tests pass)\n    if (this.branch === 'main') {\n      console.log('Job: deploy');\n      console.log('-'.repeat(30));\n      \n      if (!this.failed) {\n        this.runStep('Download artifact', () => true, 100);\n        this.runStep('Deploy to Render', () => true, 2000);\n        console.log('\\n  Deployed to: https://my-app.onrender.com');\n      } else {\n        console.log('  [BLOCKED] Deploy skipped - tests failed');\n      }\n    } else {\n      console.log(`Job: deploy`);\n      console.log('-'.repeat(30));\n      console.log(`  [SKIPPED] Only deploys on main branch`);\n    }\n    \n    // Summary\n    console.log('\\n' + '='.repeat(50));\n    console.log('PIPELINE SUMMARY');\n    console.log('='.repeat(50));\n    \n    const passed = this.steps.filter(s => s.status === 'passed').length;\n    const failed = this.steps.filter(s => s.status === 'failed').length;\n    const skipped = this.steps.filter(s => s.status === 'skipped').length;\n    \n    console.log(`\\nSteps: ${passed} passed, ${failed} failed, ${skipped} skipped`);\n    console.log(`Total time: ${this.totalTime}ms`);\n    console.log(`\\nResult: ${this.failed ? 'FAILED' : 'PASSED'}`);\n    \n    if (this.failed) {\n      const failedStep = this.steps.find(s => s.status === 'failed');\n      console.log(`\\nFailed at: ${failedStep.name}`);\n      console.log('Fix the failing tests before merging!');\n    } else if (this.branch === 'main') {\n      console.log('\\nDeployment successful!');\n    }\n    \n    console.log('\\n' + '='.repeat(50) + '\\n');\n  }\n}\n\n// Simulate different scenarios\nconsole.log('=== Scenario 1: Feature Branch (tests pass) ===');\nconst featurePipeline = new CIPipeline('feature/add-login');\nfeaturePipeline.run(true);\n\nconsole.log('=== Scenario 2: Main Branch (tests pass) ===');\nconst mainPipeline = new CIPipeline('main');\nmainPipeline.run(true);\n\nconsole.log('=== Scenario 3: Main Branch (tests FAIL) ===');\nconst failedPipeline = new CIPipeline('main');\nfailedPipeline.run(false);\n\n// CI/CD Best Practices\nconsole.log('=== CI/CD Best Practices with Bun ===\\n');\n\nconst bestPractices = [\n  '1. Use oven-sh/setup-bun@v2 for fast Bun setup',\n  '2. Cache ~/.bun/install/cache for faster installs',\n  '3. Add \"needs: test\" to deploy job',\n  '4. Only deploy on main: if: github.ref == refs/heads/main',\n  '5. Store secrets in GitHub Secrets, not code',\n  '6. Run tests on pull_request AND push',\n  '7. Use bun test --coverage for code coverage',\n  '8. Fail fast with continue-on-error: false'\n];\n\nbestPractices.forEach(p => console.log(p));\n\nconsole.log('\\nBun Advantages in CI:');\nconsole.log('- bun install: 10x faster than npm');\nconsole.log('- bun test: Native test runner, no setup');\nconsole.log('- Less CI minutes = lower costs!');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Should stop pipeline on failed tests",
                  "expectedOutput": "Pipeline FAILED",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use a 'failed' flag to skip remaining steps when a step fails"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Deploying without checking test results",
                  "consequence": "Broken code gets deployed to production.",
                  "correction": "Add 'needs: test' to the deploy job so it only runs after tests pass."
                },
                {
                  "mistake": "Using npm instead of bun in CI",
                  "consequence": "CI runs 10x slower, wasting time and money.",
                  "correction": "Use oven-sh/setup-bun@v2 and bun commands for faster builds."
                },
                {
                  "mistake": "Hardcoding secrets in workflow files",
                  "consequence": "Secrets are exposed in your public repository.",
                  "correction": "Use ${{ secrets.SECRET_NAME }} and add secrets in GitHub Settings."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-16",
      "title": "Module 16: Testing JavaScript with Bun",
      "description": "Learn to write reliable tests using Bun's built-in test runner - zero config, blazing fast",
      "difficulty": "intermediate",
      "estimatedHours": 4,
      "lessons": [
        {
          "id": "15.1",
          "title": "Why Testing Matters",
          "moduleId": "module-15",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Test Pyramid",
              "content": "Testing is like quality control in manufacturing. Before shipping a product, you check it works.\n\nThe Test Pyramid has three levels:\n\n1. **Unit Tests** (base) - Test individual functions in isolation. Fast, many of these.\n2. **Integration Tests** (middle) - Test how components work together. Slower, fewer.\n3. **End-to-End Tests** (top) - Test full user workflows. Slowest, fewest.\n\nWhy this shape? Unit tests are cheap and fast. E2E tests are expensive and slow. A healthy codebase has many unit tests, some integration tests, and few E2E tests.\n\nWithout tests, every change is a gamble. With tests, you refactor with confidence."
            },
            {
              "type": "EXAMPLE",
              "title": "Tests as Documentation",
              "content": "See the code example above demonstrating Tests as Documentation.",
              "language": "javascript",
              "code": "// Tests document expected behavior better than comments\n\n// What does this function do? The test tells us:\ntest('calculateDiscount applies 10% off for orders over $100', () => {\n  expect(calculateDiscount(150)).toBe(15);\n  expect(calculateDiscount(50)).toBe(0);\n});\n\n// Now we know:\n// - Orders over $100 get 10% discount\n// - Orders $100 or less get no discount\n// This documentation never goes stale!"
            },
            {
              "type": "KEY_POINT",
              "title": "TDD: Test-Driven Development",
              "content": "TDD flips the script: write tests BEFORE code.\n\n1. **Red** - Write a failing test for the feature you want\n2. **Green** - Write minimal code to make the test pass\n3. **Refactor** - Clean up the code, tests ensure it still works\n\nBenefits of TDD:\n- Forces you to think about requirements first\n- Produces testable, modular code by design\n- Builds a safety net as you code\n- Prevents over-engineering (only write what's needed)\n\nStart small: write one test, make it pass, repeat."
            },
            {
              "type": "WARNING",
              "title": "Common Testing Mistakes",
              "content": "Avoid these testing pitfalls:\n\n1. **Testing implementation, not behavior**:\n   ```javascript\n   // BAD - tests internal implementation\n   expect(user._privateMethod).toHaveBeenCalled();\n   \n   // GOOD - tests observable behavior\n   expect(user.getName()).toBe('Alice');\n   ```\n\n2. **Skipping edge cases**:\n   - Empty inputs (null, undefined, '', [])\n   - Boundary values (0, -1, MAX_INT)\n   - Invalid types\n\n3. **Tests that depend on each other**:\n   Each test should set up its own state. Don't rely on order.\n\n4. **Not testing the unhappy path**:\n   Test what happens when things go WRONG, not just when they go right.\n\n5. **Ignoring flaky tests**:\n   A test that sometimes passes and sometimes fails is worse than no test."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.1-challenge",
              "title": "Identify Test Types",
              "description": "Write comments identifying which type of test (unit, integration, or e2e) each scenario describes.",
              "instructions": "For each test description, add a comment identifying if it's a unit test, integration test, or e2e test.",
              "starterCode": "// Identify each test type: unit, integration, or e2e\n\n// Test 1: Check if formatPrice(10.5) returns '$10.50'\n// Type: ???\n\n// Test 2: Verify login form submits to API and stores token\n// Type: ???\n\n// Test 3: User can browse products, add to cart, and checkout\n// Type: ???\n\n// Test 4: Check if validateEmail returns false for 'invalid'\n// Type: ???\n\nconsole.log('Test 1: formatPrice - unit test');\nconsole.log('Test 2: login form + API - integration test');\nconsole.log('Test 3: full checkout flow - e2e test');\nconsole.log('Test 4: validateEmail - unit test');",
              "solution": "// Identify each test type: unit, integration, or e2e\n\n// Test 1: Check if formatPrice(10.5) returns '$10.50'\n// Type: unit (tests single pure function)\n\n// Test 2: Verify login form submits to API and stores token\n// Type: integration (tests form + API + storage together)\n\n// Test 3: User can browse products, add to cart, and checkout\n// Type: e2e (tests complete user journey)\n\n// Test 4: Check if validateEmail returns false for 'invalid'\n// Type: unit (tests single pure function)\n\nconsole.log('Test 1: formatPrice - unit test');\nconsole.log('Test 2: login form + API - integration test');\nconsole.log('Test 3: full checkout flow - e2e test');\nconsole.log('Test 4: validateEmail - unit test');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Correctly identifies test types",
                  "expectedOutput": "unit test",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Unit tests test ONE function. Integration tests test multiple components together. E2E tests simulate real user flows."
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.2",
          "title": "Bun Test Setup & First Test",
          "moduleId": "module-15",
          "order": 2,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Bun's Test Runner?",
              "content": "Bun has a built-in test runner that requires zero configuration:\n\n- **Zero Setup** - No installation, no config files, just works\n- **Blazing Fast** - Native speed, runs tests in parallel\n- **Jest-Compatible** - Same API you already know\n- **TypeScript Ready** - No setup needed for TS\n\nNo installation needed! Just create a test file:\n```bash\n# Create test file (*.test.ts, *.test.js, or *_test.ts)\ntouch math.test.ts\n\n# Run tests\nbun test\n```\n\nThat's it. No package.json scripts, no config files, no dependencies.\n\n`bun test` watches for changes by default. Use `bun test --run` to run once and exit."
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Test",
              "content": "See the code example above demonstrating Your First Test.",
              "language": "javascript",
              "code": "// math.ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\n// math.test.ts\nimport { describe, it, expect } from 'bun:test';\nimport { add } from './math';\n\ndescribe('add', () => {\n  it('adds two positive numbers', () => {\n    expect(add(2, 3)).toBe(5);\n  });\n\n  it('handles negative numbers', () => {\n    expect(add(-1, 1)).toBe(0);\n  });\n});\n\n// Run: bun test\n// Output: bun test v1.x\n//         math.test.ts:\n//         ✓ add > adds two positive numbers\n//         ✓ add > handles negative numbers"
            },
            {
              "type": "KEY_POINT",
              "title": "describe, it, expect",
              "content": "Three core functions from 'bun:test':\n\n**describe(name, fn)** - Groups related tests\n```javascript\nimport { describe } from 'bun:test';\ndescribe('Calculator', () => { ... });\n```\n\n**it(name, fn)** or **test(name, fn)** - Defines a single test\n```javascript\nimport { it, test } from 'bun:test';\nit('should add numbers', () => { ... });\n```\n\n**expect(value)** - Creates an assertion\n```javascript\nimport { expect } from 'bun:test';\nexpect(result).toBe(expected);     // Strict equality\nexpect(arr).toEqual([1, 2, 3]);    // Deep equality\nexpect(fn).toThrow();              // Throws error\nexpect(value).toBeTruthy();        // Truthy check\n```\n\nNaming convention: Test names should read like sentences.\n\"it should calculate total with tax\" tells you exactly what's being tested."
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Vitest Equivalent",
              "legacy": "vitest",
              "content": "In Vitest, you would need to install and configure the test runner first. Bun's test runner works identically but with zero setup.",
              "code": "// Vitest requires installation:\n// npm install -D vitest\n\n// And package.json scripts:\n// \"test\": \"vitest\"\n\n// Then import from 'vitest' instead of 'bun:test':\nimport { describe, it, expect } from 'vitest';\n\n// The test code itself is identical!\ndescribe('add', () => {\n  it('adds numbers', () => {\n    expect(add(2, 3)).toBe(5);\n  });\n});",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Common Bun Test Pitfalls",
              "content": "Watch out for these common issues:\n\n1. **Wrong file naming**:\n   ```bash\n   # WRONG - won't be found\n   mytest.js\n   tests.js\n   \n   # CORRECT - detected automatically\n   my.test.js\n   my.spec.js\n   my_test.js\n   ```\n\n2. **Forgetting async/await**:\n   ```javascript\n   // WRONG - test passes before promise resolves!\n   it('fetches data', () => {\n     fetchData().then(data => expect(data).toBe('ok'));\n   });\n   \n   // CORRECT - wait for promise\n   it('fetches data', async () => {\n     const data = await fetchData();\n     expect(data).toBe('ok');\n   });\n   ```\n\n3. **Confusing toBe vs toEqual**:\n   ```javascript\n   expect([1, 2]).toBe([1, 2]);    // FAILS! Different objects\n   expect([1, 2]).toEqual([1, 2]); // PASSES! Same values\n   ```\n\n4. **Not running in watch mode during development**:\n   ```bash\n   bun test          # Watch mode (default)\n   bun test --run    # Run once and exit (for CI)\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.2-challenge",
              "title": "Write Your First Tests",
              "description": "Write tests for a multiply function using describe, it, and expect.",
              "instructions": "Complete the test file for the multiply function. Test positive numbers, negative numbers, and zero.",
              "starterCode": "// Simulating bun:test functions for this exercise\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = (name, fn) => {\n  try { fn(); console.log(`  ✓ ${name}`); }\n  catch (e) { console.log(`  ✗ ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); }\n});\n\n// Function to test\nfunction multiply(a, b) {\n  return a * b;\n}\n\n// Write your tests below\ndescribe('multiply', () => {\n  it('multiplies two positive numbers', () => {\n    // YOUR CODE: expect multiply(3, 4) to be 12\n  });\n\n  it('handles negative numbers', () => {\n    // YOUR CODE: expect multiply(-2, 5) to be -10\n  });\n\n  it('returns zero when multiplied by zero', () => {\n    // YOUR CODE: expect multiply(100, 0) to be 0\n  });\n});",
              "solution": "// Simulating bun:test functions for this exercise\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = (name, fn) => {\n  try { fn(); console.log(`  ✓ ${name}`); }\n  catch (e) { console.log(`  ✗ ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); }\n});\n\n// Function to test\nfunction multiply(a, b) {\n  return a * b;\n}\n\n// Write your tests below\ndescribe('multiply', () => {\n  it('multiplies two positive numbers', () => {\n    expect(multiply(3, 4)).toBe(12);\n  });\n\n  it('handles negative numbers', () => {\n    expect(multiply(-2, 5)).toBe(-10);\n  });\n\n  it('returns zero when multiplied by zero', () => {\n    expect(multiply(100, 0)).toBe(0);\n  });\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "All tests pass",
                  "expectedOutput": "✓",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use expect(multiply(a, b)).toBe(expectedResult) pattern"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.3",
          "title": "Writing Good Tests (AAA Pattern)",
          "moduleId": "module-15",
          "order": 3,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Pure Functions & Testability",
              "content": "Pure functions are easiest to test:\n- Same input always gives same output\n- No side effects (no API calls, no DOM, no randomness)\n\n```javascript\n// Pure - easy to test\nfunction calculateTax(price, rate) {\n  return price * rate;\n}\n\n// Impure - harder to test (depends on external state)\nfunction calculateTaxWithDate(price) {\n  const rate = new Date().getMonth() < 6 ? 0.08 : 0.1;\n  return price * rate;\n}\n```\n\nRefactor impure functions: inject dependencies instead of creating them inside."
            },
            {
              "type": "EXAMPLE",
              "title": "Arrange-Act-Assert Pattern",
              "content": "See the code example above demonstrating Arrange-Act-Assert Pattern.",
              "language": "javascript",
              "code": "// AAA makes tests readable and consistent\n\nimport { describe, it, expect } from 'bun:test';\nimport { applyDiscount } from './pricing';\n\ndescribe('applyDiscount', () => {\n  it('applies percentage discount correctly', () => {\n    // Arrange - set up test data\n    const price = 100;\n    const discountPercent = 20;\n\n    // Act - call the function\n    const result = applyDiscount(price, discountPercent);\n\n    // Assert - verify the result\n    expect(result).toBe(80);\n  });\n});"
            },
            {
              "type": "KEY_POINT",
              "title": "test.each for Multiple Cases",
              "content": "Avoid repetitive tests with test.each:\n\n```javascript\nimport { describe, it, expect } from 'bun:test';\n\ndescribe('isEven', () => {\n  it.each([\n    [2, true],\n    [3, false],\n    [0, true],\n    [-4, true],\n  ])('isEven(%i) returns %s', (input, expected) => {\n    expect(isEven(input)).toBe(expected);\n  });\n});\n```\n\nTest edge cases:\n- Empty inputs (null, undefined, '', [])\n- Boundary values (0, -1, MAX_INT)\n- Invalid inputs (wrong types)\n- Large inputs (performance)"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Vitest Equivalent",
              "legacy": "vitest",
              "content": "The AAA pattern and test.each work identically in Vitest - just change the import.",
              "code": "// Vitest version - only the import changes\nimport { describe, it, expect } from 'vitest';\n\n// Everything else is the same!\ndescribe('isEven', () => {\n  it.each([[2, true], [3, false]])(\n    'isEven(%i) returns %s',\n    (input, expected) => {\n      expect(isEven(input)).toBe(expected);\n    }\n  );\n});",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "AAA Pattern Mistakes",
              "content": "Common AAA (Arrange-Act-Assert) mistakes:\n\n1. **Mixing Act and Assert**:\n   ```javascript\n   // WRONG - asserting while acting\n   it('calculates total', () => {\n     expect(cart.addItem({ price: 10 }).getTotal()).toBe(10);\n   });\n   \n   // CORRECT - separate steps\n   it('calculates total', () => {\n     const cart = new Cart();     // Arrange\n     cart.addItem({ price: 10 }); // Act\n     expect(cart.getTotal()).toBe(10); // Assert\n   });\n   ```\n\n2. **Too many assertions**:\n   One test should verify one behavior. If you have 10 assertions, you probably have 10 tests.\n\n3. **Arrange duplication**:\n   Use beforeEach for common setup:\n   ```javascript\n   describe('Cart', () => {\n     let cart;\n     beforeEach(() => cart = new Cart()); // Shared Arrange\n     \n     it('starts empty', () => {\n       expect(cart.items.length).toBe(0);\n     });\n   });\n   ```\n\n4. **Testing too many things at once**:\n   If a test fails, you should know exactly what's broken."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.3-challenge",
              "title": "Test Edge Cases",
              "description": "Write comprehensive tests for a validatePassword function including edge cases.",
              "instructions": "Test the validatePassword function with valid passwords, short passwords, missing numbers, and edge cases.",
              "starterCode": "// Simulating bun:test\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = (name, fn) => {\n  try { fn(); console.log(`  ✓ ${name}`); }\n  catch (e) { console.log(`  ✗ ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); }\n});\n\n// Function to test: password must be 8+ chars with at least one number\nfunction validatePassword(password) {\n  if (!password || password.length < 8) return false;\n  return /\\d/.test(password);\n}\n\ndescribe('validatePassword', () => {\n  // Arrange-Act-Assert pattern\n  \n  it('returns true for valid password', () => {\n    // Arrange\n    const password = 'secure123';\n    // Act\n    const result = validatePassword(password);\n    // Assert\n    expect(result).toBe(true);\n  });\n\n  it('returns false for password without number', () => {\n    // YOUR CODE HERE\n  });\n\n  it('returns false for short password', () => {\n    // YOUR CODE HERE\n  });\n\n  it('returns false for empty string', () => {\n    // YOUR CODE HERE\n  });\n\n  it('returns false for null', () => {\n    // YOUR CODE HERE\n  });\n});",
              "solution": "// Simulating bun:test\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = (name, fn) => {\n  try { fn(); console.log(`  ✓ ${name}`); }\n  catch (e) { console.log(`  ✗ ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); }\n});\n\n// Function to test: password must be 8+ chars with at least one number\nfunction validatePassword(password) {\n  if (!password || password.length < 8) return false;\n  return /\\d/.test(password);\n}\n\ndescribe('validatePassword', () => {\n  it('returns true for valid password', () => {\n    const password = 'secure123';\n    const result = validatePassword(password);\n    expect(result).toBe(true);\n  });\n\n  it('returns false for password without number', () => {\n    const password = 'securepassword';\n    const result = validatePassword(password);\n    expect(result).toBe(false);\n  });\n\n  it('returns false for short password', () => {\n    const password = 'abc1';\n    const result = validatePassword(password);\n    expect(result).toBe(false);\n  });\n\n  it('returns false for empty string', () => {\n    const password = '';\n    const result = validatePassword(password);\n    expect(result).toBe(false);\n  });\n\n  it('returns false for null', () => {\n    const password = null;\n    const result = validatePassword(password);\n    expect(result).toBe(false);\n  });\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "All tests pass",
                  "expectedOutput": "✓",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Follow the Arrange-Act-Assert pattern for each test"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.4",
          "title": "Mocking with Bun",
          "moduleId": "module-15",
          "order": 4,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Mock?",
              "content": "Mocks replace real dependencies with controlled fakes.\n\nWhen to mock:\n- API calls (don't hit real servers in tests)\n- Databases (tests should be fast and isolated)\n- Time/dates (make tests deterministic)\n- External services (payment, email)\n\nWhen NOT to mock:\n- The code you're actually testing\n- Simple utility functions\n- When real behavior is fast and reliable\n\nBun provides `mock()` and `spyOn()` from 'bun:test' - no external packages needed!\n\nOver-mocking makes tests brittle and less valuable. Mock at the boundaries, not everywhere."
            },
            {
              "type": "EXAMPLE",
              "title": "mock() and mock.module()",
              "content": "See the code example above demonstrating mock() and mock.module().",
              "language": "javascript",
              "code": "import { describe, it, expect, mock, spyOn } from 'bun:test';\n\n// Create a mock function\nconst mockFetch = mock(() => Promise.resolve({ name: 'Alice' }));\n\n// Mock an entire module\nmock.module('./api', () => ({\n  fetchUser: mockFetch\n}));\n\nimport { getUserGreeting } from './greeting';\n\ndescribe('getUserGreeting', () => {\n  it('greets the user by name', async () => {\n    // Setup mock return value\n    mockFetch.mockResolvedValue({ name: 'Alice' });\n\n    const greeting = await getUserGreeting(1);\n\n    expect(greeting).toBe('Hello, Alice!');\n    expect(mockFetch).toHaveBeenCalledWith(1);\n  });\n\n  it('handles API errors gracefully', async () => {\n    mockFetch.mockRejectedValue(new Error('Network error'));\n\n    const greeting = await getUserGreeting(1);\n\n    expect(greeting).toBe('Hello, Guest!');\n  });\n});"
            },
            {
              "type": "KEY_POINT",
              "title": "spyOn() for Watching Calls",
              "content": "**spyOn** watches function calls and optionally changes behavior:\n```javascript\nimport { spyOn } from 'bun:test';\n\nconst spy = spyOn(console, 'log');\nmyFunction();\nexpect(spy).toHaveBeenCalledWith('expected message');\nspy.mockRestore(); // Restore original\n```\n\n**mock()** creates a mock function:\n```javascript\nimport { mock } from 'bun:test';\n\nconst mockFn = mock(() => 42);\nexpect(mockFn()).toBe(42);\n```\n\nUseful mock methods:\n- `mockReturnValue(val)` - Always return val\n- `mockResolvedValue(val)` - Return Promise.resolve(val)\n- `mockRejectedValue(err)` - Return Promise.reject(err)\n- `mockImplementation(fn)` - Custom logic\n\nVerify calls:\n- `toHaveBeenCalled()` - Was it called?\n- `toHaveBeenCalledWith(args)` - With what?\n- `toHaveBeenCalledTimes(n)` - How many times?"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Vitest Equivalent",
              "legacy": "vitest",
              "content": "Vitest uses vi.fn() and vi.mock() instead of Bun's mock() and mock.module(). The API is similar but uses a different namespace.",
              "code": "// Vitest version\nimport { vi, describe, it, expect } from 'vitest';\n\n// vi.fn() instead of mock()\nconst mockFetch = vi.fn();\n\n// vi.mock() instead of mock.module()\nvi.mock('./api', () => ({\n  fetchUser: mockFetch\n}));\n\n// vi.spyOn() instead of spyOn()\nconst spy = vi.spyOn(console, 'log');\n\n// Everything else works the same!",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Mocking Pitfalls",
              "content": "Common mocking mistakes:\n\n1. **Over-mocking**:\n   ```javascript\n   // BAD - mocking everything defeats the purpose\n   mock(add);  // Why mock a simple function?\n   mock(multiply);\n   mock(subtract);\n   \n   // GOOD - mock only external dependencies\n   mock(fetchFromAPI);\n   ```\n\n2. **Forgetting to restore mocks**:\n   ```javascript\n   // Mocks persist between tests!\n   afterEach(() => {\n     mockFn.mockRestore();\n   });\n   ```\n\n3. **Mocking implementation instead of interface**:\n   If you change the mock every time you refactor, your tests are too coupled.\n\n4. **Not resetting call history**:\n   ```javascript\n   // WRONG - call count from previous test\n   expect(mock).toHaveBeenCalledTimes(1);\n   \n   // CORRECT - reset in beforeEach\n   beforeEach(() => mock.mockClear());\n   ```\n\n5. **Mocking what you're testing**:\n   Never mock the module you're actually trying to test!"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.4-challenge",
              "title": "Mock an API Call",
              "description": "Write tests using mocks to test a function that depends on an API call.",
              "instructions": "Test the getWeatherMessage function by mocking the fetchWeather dependency. Test both success and error cases.",
              "starterCode": "// Simulating bun:test mock functions\nconst mock = (fn) => {\n  const mockFn = (...args) => mockFn._returnValue;\n  mockFn._calls = [];\n  mockFn.mockReturnValue = (val) => { mockFn._returnValue = val; return mockFn; };\n  mockFn.mockResolvedValue = (val) => { mockFn._returnValue = Promise.resolve(val); return mockFn; };\n  mockFn.mockRejectedValue = (err) => { mockFn._returnValue = Promise.reject(err); return mockFn; };\n  return mockFn;\n};\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  ✓ ${name}`); }\n  catch (e) { console.log(`  ✗ ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); }\n});\n\n// The API function we'll mock\nlet fetchWeather = async (city) => {\n  // In reality this would call an API\n  return { temp: 72, condition: 'sunny' };\n};\n\n// Function to test\nasync function getWeatherMessage(city) {\n  try {\n    const weather = await fetchWeather(city);\n    return `It's ${weather.temp}°F and ${weather.condition} in ${city}`;\n  } catch (error) {\n    return `Weather unavailable for ${city}`;\n  }\n}\n\ndescribe('getWeatherMessage', () => {\n  it('returns formatted weather message on success', async () => {\n    // Mock fetchWeather to return controlled data\n    fetchWeather = mock().mockResolvedValue({ temp: 75, condition: 'cloudy' });\n    \n    const message = await getWeatherMessage('Seattle');\n    \n    expect(message).toBe(\"It's 75°F and cloudy in Seattle\");\n  });\n\n  it('returns fallback message on API error', async () => {\n    // YOUR CODE: Mock fetchWeather to reject with an error\n    // Then call getWeatherMessage and verify the fallback message\n  });\n});",
              "solution": "// Simulating bun:test mock functions\nconst mock = (fn) => {\n  const mockFn = (...args) => mockFn._returnValue;\n  mockFn._calls = [];\n  mockFn.mockReturnValue = (val) => { mockFn._returnValue = val; return mockFn; };\n  mockFn.mockResolvedValue = (val) => { mockFn._returnValue = Promise.resolve(val); return mockFn; };\n  mockFn.mockRejectedValue = (err) => { mockFn._returnValue = Promise.reject(err); return mockFn; };\n  return mockFn;\n};\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  ✓ ${name}`); }\n  catch (e) { console.log(`  ✗ ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); }\n});\n\n// The API function we'll mock\nlet fetchWeather = async (city) => {\n  return { temp: 72, condition: 'sunny' };\n};\n\n// Function to test\nasync function getWeatherMessage(city) {\n  try {\n    const weather = await fetchWeather(city);\n    return `It's ${weather.temp}°F and ${weather.condition} in ${city}`;\n  } catch (error) {\n    return `Weather unavailable for ${city}`;\n  }\n}\n\ndescribe('getWeatherMessage', () => {\n  it('returns formatted weather message on success', async () => {\n    fetchWeather = mock().mockResolvedValue({ temp: 75, condition: 'cloudy' });\n    \n    const message = await getWeatherMessage('Seattle');\n    \n    expect(message).toBe(\"It's 75°F and cloudy in Seattle\");\n  });\n\n  it('returns fallback message on API error', async () => {\n    fetchWeather = mock().mockRejectedValue(new Error('Network error'));\n    \n    const message = await getWeatherMessage('Seattle');\n    \n    expect(message).toBe('Weather unavailable for Seattle');\n  });\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Both tests pass",
                  "expectedOutput": "✓",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use mockRejectedValue to simulate an API error"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.5",
          "title": "Testing Async Code with Bun",
          "moduleId": "module-15",
          "order": 5,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Async Testing Patterns",
              "content": "Async code needs special handling in tests. Bun's test runner handles async naturally:\n\n**Return a Promise:**\n```javascript\nit('fetches data', () => {\n  return fetchData().then(data => {\n    expect(data).toBeDefined();\n  });\n});\n```\n\n**Use async/await (preferred):**\n```javascript\nit('fetches data', async () => {\n  const data = await fetchData();\n  expect(data).toBeDefined();\n});\n```\n\n**Key rule:** Always await or return async operations. Forgotten awaits cause tests to pass incorrectly because assertions run after the test completes."
            },
            {
              "type": "EXAMPLE",
              "title": "Controlling Time with setSystemTime()",
              "content": "Bun provides built-in fake timers through setSystemTime().",
              "language": "javascript",
              "code": "import { describe, it, expect, beforeEach, afterEach, mock, setSystemTime } from 'bun:test';\n\nfunction delayedGreeting(name, callback) {\n  setTimeout(() => callback(`Hello, ${name}!`), 1000);\n}\n\ndescribe('delayedGreeting', () => {\n  beforeEach(() => {\n    setSystemTime(new Date('2024-01-01'));  // Take control of time\n  });\n\n  afterEach(() => {\n    setSystemTime();  // Restore real time\n  });\n\n  it('calls callback after 1 second', async () => {\n    const callback = mock(() => {});\n\n    delayedGreeting('Alice', callback);\n    \n    expect(callback).not.toHaveBeenCalled();  // Not yet!\n    \n    // Use Bun.sleep or advance time manually\n    await Bun.sleep(1000);\n    \n    expect(callback).toHaveBeenCalledWith('Hello, Alice!');\n  });\n});"
            },
            {
              "type": "KEY_POINT",
              "title": "Testing Promise States",
              "content": "Test all promise outcomes with Bun:\n\n```javascript\nimport { describe, it, expect } from 'bun:test';\n\ndescribe('fetchUser', () => {\n  it('resolves with user data', async () => {\n    const user = await fetchUser(1);\n    expect(user.name).toBe('Alice');\n  });\n\n  it('rejects for invalid id', async () => {\n    expect(fetchUser(-1)).rejects.toThrow('Invalid ID');\n  });\n\n  it('rejects with specific error type', async () => {\n    expect(fetchUser(999))\n      .rejects\n      .toBeInstanceOf(NotFoundError);\n  });\n});\n```\n\nUseful matchers:\n- `resolves.toBe()` - Unwraps resolved value\n- `rejects.toThrow()` - Checks rejection\n- `Bun.sleep(ms)` - Async sleep for timing tests"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Vitest Equivalent",
              "legacy": "vitest",
              "content": "Vitest uses vi.useFakeTimers() and vi.advanceTimersByTime() for timer control. Bun uses setSystemTime() instead.",
              "code": "// Vitest version\nimport { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';\n\nbeforeEach(() => {\n  vi.useFakeTimers();  // Vitest fake timers\n});\n\nafterEach(() => {\n  vi.restoreAllMocks();\n});\n\nit('delays execution', () => {\n  const callback = vi.fn();\n  delayedGreeting('Alice', callback);\n  \n  vi.advanceTimersByTime(1000);  // Vitest time advance\n  \n  expect(callback).toHaveBeenCalled();\n});",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Async Testing Gotchas",
              "content": "Common async testing mistakes:\n\n1. **Forgotten await**:\n   ```javascript\n   // WRONG - test passes before promise resolves!\n   it('fetches user', () => {\n     const user = fetchUser(1);  // Missing await!\n     expect(user.name).toBe('Alice');  // user is a Promise, not data\n   });\n   \n   // CORRECT\n   it('fetches user', async () => {\n     const user = await fetchUser(1);\n     expect(user.name).toBe('Alice');\n   });\n   ```\n\n2. **Not resetting fake timers**:\n   ```javascript\n   afterEach(() => {\n     setSystemTime();  // Reset to real time!\n   });\n   ```\n\n3. **Racing conditions**:\n   Tests that sometimes pass and sometimes fail are worse than no tests. Use proper synchronization.\n\n4. **Testing implementation timing**:\n   Don't test that something takes exactly 100ms. Test that it completes and returns correct data.\n\n5. **Unhandled rejections**:\n   Always wrap async tests in try/catch or use `.rejects` matcher."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.5-challenge",
              "title": "Test Async Functions",
              "description": "Write tests for async functions including timer-based code.",
              "instructions": "Complete the tests for the fetchUserData function and the debounce utility. Use async/await and fake timers.",
              "starterCode": "// Simulating bun:test\nconst mock = (fn) => {\n  const mockFn = (...args) => { mockFn._calls.push(args); return mockFn._returnValue; };\n  mockFn._calls = [];\n  mockFn._returnValue = undefined;\n  mockFn.mockReturnValue = (val) => { mockFn._returnValue = val; return mockFn; };\n  return mockFn;\n};\nlet _fakeTime = 0;\nconst setSystemTime = (date) => { _fakeTime = date ? date.getTime() : 0; };\nconst advanceTime = (ms) => {\n  _fakeTime += ms;\n  global._pendingTimers?.forEach(t => {\n    if (t.time <= _fakeTime && !t.called) {\n      t.called = true; t.fn();\n    }\n  });\n};\nglobal._pendingTimers = [];\nconst originalSetTimeout = setTimeout;\nglobal.setTimeout = (fn, ms) => {\n  global._pendingTimers.push({ fn, time: (_fakeTime || 0) + ms, called: false });\n};\n\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toHaveBeenCalled: () => { if (val._calls.length === 0) throw new Error('Expected function to be called'); },\n  not: { toHaveBeenCalled: () => { if (val._calls?.length > 0) throw new Error('Expected function not to be called'); } }\n});\nconst beforeEach = (fn) => fn();\nconst afterEach = (fn) => {};\n\n// Functions to test\nasync function fetchUserData(id) {\n  await new Promise(r => originalSetTimeout(r, 10));\n  if (id <= 0) throw new Error('Invalid ID');\n  return { id, name: 'Test User' };\n}\n\nfunction debounce(fn, delay) {\n  let timeoutId;\n  return (...args) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn(...args), delay);\n  };\n}\n\ndescribe('fetchUserData', () => {\n  it('returns user data for valid id', async () => {\n    const user = await fetchUserData(1);\n    expect(user.name).toBe('Test User');\n  });\n\n  it('throws error for invalid id', async () => {\n    // YOUR CODE: Test that fetchUserData(0) throws 'Invalid ID'\n    try {\n      await fetchUserData(0);\n      throw new Error('Should have thrown');\n    } catch (e) {\n      expect(e.message).toBe('Invalid ID');\n    }\n  });\n});\n\ndescribe('debounce', () => {\n  beforeEach(() => {\n    setSystemTime(new Date('2024-01-01'));\n  });\n\n  it('delays function execution', () => {\n    const fn = mock();\n    const debounced = debounce(fn, 500);\n\n    debounced();\n    expect(fn).not.toHaveBeenCalled();\n\n    // YOUR CODE: Advance time and verify fn was called\n    advanceTime(500);\n    expect(fn).toHaveBeenCalled();\n  });\n});",
              "solution": "// Simulating bun:test\nconst mock = (fn) => {\n  const mockFn = (...args) => { mockFn._calls.push(args); return mockFn._returnValue; };\n  mockFn._calls = [];\n  mockFn._returnValue = undefined;\n  mockFn.mockReturnValue = (val) => { mockFn._returnValue = val; return mockFn; };\n  return mockFn;\n};\nlet _fakeTime = 0;\nconst setSystemTime = (date) => { _fakeTime = date ? date.getTime() : 0; };\nconst advanceTime = (ms) => {\n  _fakeTime += ms;\n  global._pendingTimers?.forEach(t => {\n    if (t.time <= _fakeTime && !t.called) {\n      t.called = true; t.fn();\n    }\n  });\n};\nglobal._pendingTimers = [];\nconst originalSetTimeout = setTimeout;\nglobal.setTimeout = (fn, ms) => {\n  global._pendingTimers.push({ fn, time: (_fakeTime || 0) + ms, called: false });\n};\n\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toHaveBeenCalled: () => { if (val._calls.length === 0) throw new Error('Expected function to be called'); },\n  not: { toHaveBeenCalled: () => { if (val._calls?.length > 0) throw new Error('Expected function not to be called'); } }\n});\nconst beforeEach = (fn) => fn();\nconst afterEach = (fn) => {};\n\n// Functions to test\nasync function fetchUserData(id) {\n  await new Promise(r => originalSetTimeout(r, 10));\n  if (id <= 0) throw new Error('Invalid ID');\n  return { id, name: 'Test User' };\n}\n\nfunction debounce(fn, delay) {\n  let timeoutId;\n  return (...args) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn(...args), delay);\n  };\n}\n\ndescribe('fetchUserData', () => {\n  it('returns user data for valid id', async () => {\n    const user = await fetchUserData(1);\n    expect(user.name).toBe('Test User');\n  });\n\n  it('throws error for invalid id', async () => {\n    try {\n      await fetchUserData(0);\n      throw new Error('Should have thrown');\n    } catch (e) {\n      expect(e.message).toBe('Invalid ID');\n    }\n  });\n});\n\ndescribe('debounce', () => {\n  beforeEach(() => {\n    setSystemTime(new Date('2024-01-01'));\n  });\n\n  it('delays function execution', () => {\n    const fn = mock();\n    const debounced = debounce(fn, 500);\n\n    debounced();\n    expect(fn).not.toHaveBeenCalled();\n\n    advanceTime(500);\n    expect(fn).toHaveBeenCalled();\n  });\n});",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "All async tests pass",
                  "expectedOutput": "✓",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use try/catch to test for thrown errors in async functions"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.6",
          "title": "Test Organization with Bun",
          "moduleId": "module-15",
          "order": 6,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Bun Test File Patterns & Preload",
              "content": "Bun automatically finds test files matching these patterns:\n- `*.test.ts` / `*.test.js`\n- `*_test.ts` / `*_test.js`\n- `*.spec.ts` / `*.spec.js`\n- Files in `__tests__` directories\n\n**Using --preload for setup:**\n```bash\n# Run setup before all tests\nbun test --preload ./tests/setup.ts\n```\n\nCreate a setup file for global configuration:\n```javascript\n// tests/setup.ts\nimport { beforeAll, afterAll } from 'bun:test';\n\nbeforeAll(() => {\n  // Global setup: connect to test DB, etc.\n});\n\nafterAll(() => {\n  // Global cleanup\n});\n```\n\nAdd to bunfig.toml for persistence:\n```toml\n[test]\npreload = [\"./tests/setup.ts\"]\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Organizing Tests by Feature",
              "content": "See the code example above demonstrating test organization.",
              "language": "javascript",
              "code": "// Project structure:\n// src/\n//   users/\n//     user.service.ts\n//     user.service.test.ts    <- Co-located tests\n//   orders/\n//     order.service.ts\n//     order.service.test.ts\n// tests/\n//   setup.ts                  <- Global setup\n//   integration/\n//     api.test.ts             <- Integration tests\n\n// tests/setup.ts - runs before all tests\nimport { beforeAll, afterAll, mock } from 'bun:test';\n\n// Mock environment for all tests\nprocess.env.NODE_ENV = 'test';\n\n// Global test database setup\nbeforeAll(async () => {\n  console.log('Setting up test environment...');\n});\n\nafterAll(async () => {\n  console.log('Cleaning up test environment...');\n});\n\n// Run with: bun test --preload ./tests/setup.ts"
            },
            {
              "type": "KEY_POINT",
              "title": "Bun Test CLI Options",
              "content": "Useful bun test flags:\n\n```bash\n# Run specific file or pattern\nbun test user.test.ts\nbun test --filter \"auth\"\n\n# Watch mode (default)\nbun test --watch\n\n# Run once and exit\nbun test --run\n\n# Timeout per test (default 5000ms)\nbun test --timeout 10000\n\n# Run tests in parallel (default)\nbun test --parallel\n\n# Run tests sequentially\nbun test --no-parallel\n\n# Bail on first failure\nbun test --bail\n\n# Show verbose output\nbun test --verbose\n```\n\nConfigure defaults in bunfig.toml:\n```toml\n[test]\npreload = [\"./tests/setup.ts\"]\ntimeout = 10000\nroot = \"./tests\"\n```"
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Vitest Equivalent",
              "legacy": "vitest",
              "content": "Vitest uses vitest.config.ts for setup files. Bun uses --preload flag or bunfig.toml.",
              "code": "// Vitest config (vitest.config.ts)\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    setupFiles: ['./tests/setup.ts'],  // Vitest setup\n    globals: true,\n    environment: 'node',\n    include: ['**/*.test.ts']\n  }\n});\n\n// Bun equivalent (bunfig.toml)\n// [test]\n// preload = [\"./tests/setup.ts\"]",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Test Organization Pitfalls",
              "content": "Common organization mistakes:\n\n1. **Wrong hook usage**:\n   ```javascript\n   // WRONG - expensive setup runs before EVERY test\n   beforeEach(() => {\n     db = await connectToDatabase();  // Slow!\n   });\n   \n   // CORRECT - connect once, reset data each test\n   beforeAll(() => db = await connectToDatabase());\n   beforeEach(() => await db.clear());\n   afterAll(() => await db.disconnect());\n   ```\n\n2. **Missing afterAll cleanup**:\n   Open connections, temp files, and running servers leak between test files.\n\n3. **Tests that rely on order**:\n   ```javascript\n   // WRONG - test 2 depends on test 1\n   it('creates user', () => { db.users.push({id: 1}); });\n   it('finds user', () => { expect(db.users[0]).toBeDefined(); });\n   \n   // CORRECT - each test is independent\n   it('finds user', () => {\n     db.users.push({id: 1});  // Own setup\n     expect(db.users[0]).toBeDefined();\n   });\n   ```\n\n4. **Too many files in one directory**:\n   Co-locate tests with source files, not in a giant /tests folder."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.6-challenge",
              "title": "Organize a Test Suite",
              "description": "Create a well-organized test structure with setup and lifecycle hooks.",
              "instructions": "Complete the test organization example using beforeAll, afterAll, beforeEach, and afterEach hooks properly.",
              "starterCode": "// Simulating bun:test lifecycle hooks\nlet setupLog = [];\nconst beforeAll = (fn) => { setupLog.push('beforeAll'); fn(); };\nconst afterAll = (fn) => { setupLog.push('afterAll scheduled'); };\nconst beforeEach = (fn) => { fn(); };\nconst afterEach = (fn) => {};\n\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = (name, fn) => {\n  try { fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toContain: (exp) => { if (!val.includes(exp)) throw new Error(`Expected to contain ${exp}`); },\n  toHaveLength: (exp) => { if (val.length !== exp) throw new Error(`Expected length ${exp}`); }\n});\n\n// Database simulation\nlet db = { connected: false, users: [] };\n\ndescribe('UserService', () => {\n  // YOUR CODE: Add beforeAll to connect to database\n  beforeAll(() => {\n    db.connected = true;\n    db.users = [];\n    console.log('  [setup] Database connected');\n  });\n\n  // YOUR CODE: Add afterAll to disconnect\n  afterAll(() => {\n    db.connected = false;\n    console.log('  [cleanup] Database disconnected');\n  });\n\n  // YOUR CODE: Add beforeEach to reset users array\n  beforeEach(() => {\n    db.users = [];\n  });\n\n  describe('createUser', () => {\n    it('creates a user in the database', () => {\n      // Simulate creating a user\n      db.users.push({ id: 1, name: 'Alice' });\n      \n      expect(db.users).toHaveLength(1);\n      expect(db.connected).toBe(true);\n    });\n\n    it('starts with empty users after reset', () => {\n      // beforeEach should have reset the users\n      expect(db.users).toHaveLength(0);\n    });\n  });\n});\n\nconsole.log('\\nSetup log:', setupLog.join(' -> '));",
              "solution": "// Simulating bun:test lifecycle hooks\nlet setupLog = [];\nconst beforeAll = (fn) => { setupLog.push('beforeAll'); fn(); };\nconst afterAll = (fn) => { setupLog.push('afterAll scheduled'); };\nconst beforeEach = (fn) => { fn(); };\nconst afterEach = (fn) => {};\n\nconst describe = (name, fn) => { console.log(`describe: ${name}`); fn(); };\nconst it = (name, fn) => {\n  try { fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toContain: (exp) => { if (!val.includes(exp)) throw new Error(`Expected to contain ${exp}`); },\n  toHaveLength: (exp) => { if (val.length !== exp) throw new Error(`Expected length ${exp}`); }\n});\n\n// Database simulation\nlet db = { connected: false, users: [] };\n\ndescribe('UserService', () => {\n  beforeAll(() => {\n    db.connected = true;\n    db.users = [];\n    console.log('  [setup] Database connected');\n  });\n\n  afterAll(() => {\n    db.connected = false;\n    console.log('  [cleanup] Database disconnected');\n  });\n\n  beforeEach(() => {\n    db.users = [];\n  });\n\n  describe('createUser', () => {\n    it('creates a user in the database', () => {\n      db.users.push({ id: 1, name: 'Alice' });\n      \n      expect(db.users).toHaveLength(1);\n      expect(db.connected).toBe(true);\n    });\n\n    it('starts with empty users after reset', () => {\n      expect(db.users).toHaveLength(0);\n    });\n  });\n});\n\nconsole.log('\\nSetup log:', setupLog.join(' -> '));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "All lifecycle hooks work correctly",
                  "expectedOutput": "✓",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "beforeAll runs once before all tests, beforeEach runs before each test"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.7",
          "title": "Code Coverage & CI with Bun",
          "moduleId": "module-15",
          "order": 7,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Understanding Code Coverage",
              "content": "Code coverage measures how much of your code is executed by tests.\n\n**Coverage types:**\n- **Lines** - % of lines executed\n- **Statements** - % of statements executed\n- **Branches** - % of if/else paths taken\n- **Functions** - % of functions called\n\nEnable coverage in Bun with a single flag:\n```bash\nbun test --coverage\n```\n\nBun outputs coverage to the console by default. No configuration needed!\n\nFor detailed reports, Bun generates lcov format:\n```bash\nbun test --coverage --coverage-reporter=lcov\n```\n\n**80% coverage** is a common target. 100% is often impractical and can lead to testing implementation details."
            },
            {
              "type": "EXAMPLE",
              "title": "GitHub Actions Workflow with Bun",
              "content": "This GitHub Actions workflow runs your tests automatically on every push and pull request using Bun's built-in test runner.",
              "language": "yaml",
              "code": "# .github/workflows/test.yml\nname: Tests\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup Bun\n        uses: oven-sh/setup-bun@v2\n        with:\n          bun-version: latest\n\n      - name: Install dependencies\n        run: bun install\n\n      - name: Run tests with coverage\n        run: bun test --coverage\n\n      - name: Run tests (fail if any fail)\n        run: bun test --bail"
            },
            {
              "type": "KEY_POINT",
              "title": "Coverage Best Practices",
              "content": "**Do:**\n- Set coverage thresholds to prevent regression\n- Focus on critical paths (auth, payments, core logic)\n- Use coverage to find untested code, not prove quality\n- Review coverage reports in CI to catch gaps\n\n**Don't:**\n- Chase 100% coverage\n- Write tests just to increase numbers\n- Ignore uncovered code if it's dead code\n- Test trivial getters/setters\n\nConfigure coverage in bunfig.toml:\n```toml\n[test]\ncoverage = true\ncoverageReporter = [\"text\", \"lcov\"]\ncoverageThreshold = { line = 80, function = 80, branch = 75 }\n```\n\nOr use CLI flags:\n```bash\nbun test --coverage --coverage-threshold 80\n```\n\nCI will fail if coverage drops below these thresholds."
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Vitest Equivalent",
              "legacy": "vitest",
              "content": "Vitest requires configuration files and external coverage providers. Bun's coverage is built-in.",
              "code": "// Vitest requires a config file (vitest.config.ts)\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      provider: 'v8',  // Must specify provider\n      reporter: ['text', 'html', 'lcov'],\n      thresholds: {\n        lines: 80,\n        branches: 75,\n        functions: 80,\n        statements: 80\n      }\n    }\n  }\n});\n\n// And in GitHub Actions:\n// - uses: actions/setup-node@v4\n// - run: npm ci\n// - run: npx vitest run --coverage\n\n// Bun equivalent - just one command!\n// bun test --coverage",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Coverage & CI Pitfalls",
              "content": "Common mistakes:\n\n1. **Chasing 100% coverage**:\n   100% coverage doesn't mean bug-free code. You can have 100% coverage and still miss edge cases.\n\n2. **Ignoring branch coverage**:\n   ```javascript\n   // Line covered, but only one branch tested!\n   function status(age) {\n     return age >= 18 ? 'adult' : 'minor';\n   }\n   status(25);  // Only tests 'adult' branch\n   ```\n\n3. **Using old setup-bun version**:\n   ```yaml\n   # WRONG - v1 is outdated\n   uses: oven-sh/setup-bun@v2\n   \n   # CORRECT - use v2\n   uses: oven-sh/setup-bun@v2\n   ```\n\n4. **Not failing CI on coverage drop**:\n   Without thresholds, coverage can silently regress.\n\n5. **Testing generated/third-party code**:\n   Exclude node_modules and generated files from coverage.\n\n6. **Forgetting to run tests on PRs**:\n   ```yaml\n   on:\n     push:\n       branches: [main]\n     pull_request:      # Don't forget this!\n       branches: [main]\n   ```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.7-challenge",
              "title": "Configure Coverage & CI",
              "description": "Create a bunfig.toml with coverage settings and a GitHub Actions workflow.",
              "instructions": "Complete the Bun config to enable coverage with 80% thresholds, and verify the GitHub Actions workflow.",
              "starterCode": "// bunfig.toml configuration (as JavaScript object for this exercise)\n// Complete this configuration\nconst bunfig = {\n  test: {\n    preload: ['./tests/setup.ts'],\n    // YOUR CODE: Enable coverage\n    coverage: false,\n    // YOUR CODE: Set coverage reporters\n    coverageReporter: [],\n    // YOUR CODE: Set coverage thresholds\n    coverageThreshold: {}\n  }\n};\n\n// Verify configuration\nconst test = bunfig.test;\n\nif (test.coverage === true) {\n  console.log('\\u2713 Coverage enabled');\n} else {\n  console.log('\\u2717 Enable coverage');\n}\n\nif (test.coverageReporter.includes('text')) {\n  console.log('\\u2713 Text reporter configured');\n} else {\n  console.log('\\u2717 Add text reporter');\n}\n\nif (test.coverageThreshold.line === 80) {\n  console.log('\\u2713 Line coverage threshold set to 80%');\n} else {\n  console.log('\\u2717 Set line threshold to 80');\n}\n\n// GitHub Actions workflow (as object for validation)\nconst workflow = {\n  name: 'Tests',\n  on: {\n    push: { branches: ['main'] },\n    pull_request: { branches: ['main'] }\n  },\n  jobs: {\n    test: {\n      'runs-on': 'ubuntu-latest',\n      steps: [\n        { uses: 'actions/checkout@v4' },\n        { name: 'Setup Bun', uses: 'oven-sh/setup-bun@v2' },\n        { name: 'Install', run: 'bun install' },\n        { name: 'Test', run: 'bun test --coverage' }\n      ]\n    }\n  }\n};\n\nconsole.log('\\u2713 GitHub Actions workflow configured for Bun');",
              "solution": "// bunfig.toml configuration (as JavaScript object for this exercise)\nconst bunfig = {\n  test: {\n    preload: ['./tests/setup.ts'],\n    coverage: true,\n    coverageReporter: ['text', 'lcov'],\n    coverageThreshold: {\n      line: 80,\n      function: 80,\n      branch: 75\n    }\n  }\n};\n\n// Verify configuration\nconst test = bunfig.test;\n\nif (test.coverage === true) {\n  console.log('\\u2713 Coverage enabled');\n} else {\n  console.log('\\u2717 Enable coverage');\n}\n\nif (test.coverageReporter.includes('text')) {\n  console.log('\\u2713 Text reporter configured');\n} else {\n  console.log('\\u2717 Add text reporter');\n}\n\nif (test.coverageThreshold.line === 80) {\n  console.log('\\u2713 Line coverage threshold set to 80%');\n} else {\n  console.log('\\u2717 Set line threshold to 80');\n}\n\nconst workflow = {\n  name: 'Tests',\n  on: {\n    push: { branches: ['main'] },\n    pull_request: { branches: ['main'] }\n  },\n  jobs: {\n    test: {\n      'runs-on': 'ubuntu-latest',\n      steps: [\n        { uses: 'actions/checkout@v4' },\n        { name: 'Setup Bun', uses: 'oven-sh/setup-bun@v2' },\n        { name: 'Install', run: 'bun install' },\n        { name: 'Test', run: 'bun test --coverage' }\n      ]\n    }\n  }\n};\n\nconsole.log('\\u2713 GitHub Actions workflow configured for Bun');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Coverage configuration is correct",
                  "expectedOutput": "✓ Line coverage threshold set to 80%",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Set coverage: true, and add 'text' and 'lcov' to coverageReporter array"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.8",
          "title": "Integration Testing with Hono",
          "moduleId": "module-15",
          "order": 8,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Testing Hono Apps with app.request()",
              "content": "Hono provides a built-in way to test your API without starting a server:\n\n```javascript\nimport { Hono } from 'hono';\n\nconst app = new Hono();\napp.get('/users', (c) => c.json([{ id: 1, name: 'Alice' }]));\n\n// Test without starting a server!\nconst res = await app.request('/users');\nconst data = await res.json();\n```\n\n**Why app.request()?**\n- No server startup/shutdown overhead\n- Tests run faster\n- No port conflicts\n- Full request/response testing\n\nTest structure for APIs:\n```\nsrc/\n  routes/\n    users.ts\n    users.test.ts    <- Co-located tests\n  app.ts\ntests/\n  integration/\n    api.test.ts      <- Full API tests\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Testing Hono Routes",
              "content": "See the code example above demonstrating Testing Hono Routes.",
              "language": "javascript",
              "code": "import { describe, it, expect, beforeEach } from 'bun:test';\nimport { Hono } from 'hono';\n\n// Create app with routes\nconst createApp = () => {\n  const app = new Hono();\n  const todos: { id: number; text: string; done: boolean }[] = [];\n  let nextId = 1;\n\n  app.get('/todos', (c) => c.json(todos));\n  \n  app.post('/todos', async (c) => {\n    const { text } = await c.req.json();\n    if (!text) return c.json({ error: 'Text required' }, 400);\n    const todo = { id: nextId++, text, done: false };\n    todos.push(todo);\n    return c.json(todo, 201);\n  });\n\n  app.patch('/todos/:id', async (c) => {\n    const id = parseInt(c.req.param('id'));\n    const todo = todos.find(t => t.id === id);\n    if (!todo) return c.json({ error: 'Not found' }, 404);\n    todo.done = !todo.done;\n    return c.json(todo);\n  });\n\n  return app;\n};\n\ndescribe('Todo API', () => {\n  let app: ReturnType<typeof createApp>;\n\n  beforeEach(() => {\n    app = createApp();  // Fresh app for each test\n  });\n\n  it('GET /todos returns empty array initially', async () => {\n    const res = await app.request('/todos');\n    expect(res.status).toBe(200);\n    expect(await res.json()).toEqual([]);\n  });\n\n  it('POST /todos creates a todo', async () => {\n    const res = await app.request('/todos', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ text: 'Learn Bun' })\n    });\n    \n    expect(res.status).toBe(201);\n    const todo = await res.json();\n    expect(todo.text).toBe('Learn Bun');\n    expect(todo.done).toBe(false);\n  });\n\n  it('POST /todos returns 400 for missing text', async () => {\n    const res = await app.request('/todos', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({})\n    });\n    \n    expect(res.status).toBe(400);\n  });\n});"
            },
            {
              "type": "KEY_POINT",
              "title": "Integration Test Best Practices",
              "content": "**Test HTTP semantics:**\n```javascript\n// Status codes\nexpect(res.status).toBe(201);  // Created\nexpect(res.status).toBe(404);  // Not found\n\n// Headers\nexpect(res.headers.get('Content-Type')).toContain('application/json');\n\n// Response body\nconst data = await res.json();\nexpect(data.id).toBeDefined();\n```\n\n**Test full flows:**\n```javascript\nit('full todo lifecycle', async () => {\n  // Create\n  const createRes = await app.request('/todos', {\n    method: 'POST',\n    body: JSON.stringify({ text: 'Test' })\n  });\n  const { id } = await createRes.json();\n  \n  // Update\n  await app.request(`/todos/${id}`, { method: 'PATCH' });\n  \n  // Verify\n  const getRes = await app.request('/todos');\n  const todos = await getRes.json();\n  expect(todos[0].done).toBe(true);\n});\n```\n\n**Isolate tests:** Create fresh app instance in beforeEach."
            },
            {
              "type": "LEGACY_COMPARISON",
              "title": "Vitest Equivalent",
              "legacy": "vitest",
              "content": "Testing Hono works the same in Vitest - app.request() is framework-agnostic. Only the test imports differ.",
              "code": "// Vitest version\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { Hono } from 'hono';\n\n// Same app setup...\n\ndescribe('Todo API', () => {\n  let app;\n\n  beforeEach(() => {\n    app = createApp();\n  });\n\n  it('GET /todos returns empty array', async () => {\n    const res = await app.request('/todos');\n    expect(res.status).toBe(200);\n    // Works exactly the same!\n  });\n});",
              "language": "javascript"
            },
            {
              "type": "WARNING",
              "title": "Integration Testing Pitfalls",
              "content": "Common Hono integration testing mistakes:\n\n1. **Sharing app state between tests**:\n   ```javascript\n   // WRONG - state leaks between tests\n   const app = createApp();\n   \n   // CORRECT - fresh app each test\n   beforeEach(() => {\n     app = createApp();\n   });\n   ```\n\n2. **Forgetting Content-Type header**:\n   ```javascript\n   // WRONG - Hono won't parse body\n   await app.request('/todos', {\n     method: 'POST',\n     body: JSON.stringify({ text: 'Test' })\n   });\n   \n   // CORRECT - include Content-Type\n   await app.request('/todos', {\n     method: 'POST',\n     headers: { 'Content-Type': 'application/json' },\n     body: JSON.stringify({ text: 'Test' })\n   });\n   ```\n\n3. **Not testing error responses**:\n   Always test 400, 404, 401 cases, not just happy paths.\n\n4. **Calling res.json() twice**:\n   ```javascript\n   const data = await res.json();  // First call\n   console.log(await res.json());  // ERROR! Body already consumed\n   ```\n\n5. **Ignoring async/await**:\n   Both app.request() and res.json() return Promises. Always await them."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.8-challenge",
              "title": "Test a Hono API",
              "description": "Create integration tests for a Todo API using Hono's app.request() method.",
              "instructions": "Complete the test suite for the Todo API. Test GET, POST, and PATCH endpoints including error cases.",
              "starterCode": "// Simulating bun:test and Hono\nconst describe = (name, fn) => { console.log(`\\ndescribe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toEqual: (exp) => { if (JSON.stringify(val) !== JSON.stringify(exp)) throw new Error(`Expected ${JSON.stringify(exp)}`); },\n  toContain: (exp) => { if (!val.includes(exp)) throw new Error(`Expected to contain ${exp}`); }\n});\nconst beforeEach = (fn) => { fn(); };\n\n// Simulating Hono app\nfunction createApp() {\n  const todos = [];\n  let nextId = 1;\n  \n  return {\n    request: async (path, options = {}) => {\n      const method = options.method || 'GET';\n      const body = options.body ? JSON.parse(options.body) : null;\n      \n      if (path === '/todos' && method === 'GET') {\n        return { status: 200, json: async () => [...todos] };\n      }\n      \n      if (path === '/todos' && method === 'POST') {\n        if (!body?.text) {\n          return { status: 400, json: async () => ({ error: 'Text required' }) };\n        }\n        const todo = { id: nextId++, text: body.text, done: false };\n        todos.push(todo);\n        return { status: 201, json: async () => todo };\n      }\n      \n      if (path.startsWith('/todos/') && method === 'PATCH') {\n        const id = parseInt(path.split('/')[2]);\n        const todo = todos.find(t => t.id === id);\n        if (!todo) return { status: 404, json: async () => ({ error: 'Not found' }) };\n        todo.done = !todo.done;\n        return { status: 200, json: async () => todo };\n      }\n      \n      return { status: 404 };\n    }\n  };\n}\n\ndescribe('Todo API Integration Tests', () => {\n  let app;\n  \n  beforeEach(() => {\n    app = createApp();\n  });\n\n  describe('GET /todos', () => {\n    it('returns empty array initially', async () => {\n      const res = await app.request('/todos');\n      expect(res.status).toBe(200);\n      expect(await res.json()).toEqual([]);\n    });\n  });\n\n  describe('POST /todos', () => {\n    it('creates a todo with valid text', async () => {\n      const res = await app.request('/todos', {\n        method: 'POST',\n        body: JSON.stringify({ text: 'Learn Bun testing' })\n      });\n      \n      expect(res.status).toBe(201);\n      const todo = await res.json();\n      expect(todo.text).toBe('Learn Bun testing');\n      expect(todo.done).toBe(false);\n    });\n\n    it('returns 400 for missing text', async () => {\n      // YOUR CODE: Test POST with empty body returns 400\n      const res = await app.request('/todos', {\n        method: 'POST',\n        body: JSON.stringify({})\n      });\n      expect(res.status).toBe(400);\n    });\n  });\n\n  describe('PATCH /todos/:id', () => {\n    it('toggles todo done status', async () => {\n      // First create a todo\n      const createRes = await app.request('/todos', {\n        method: 'POST',\n        body: JSON.stringify({ text: 'Test todo' })\n      });\n      const { id } = await createRes.json();\n      \n      // YOUR CODE: PATCH the todo and verify done is true\n      const patchRes = await app.request(`/todos/${id}`, { method: 'PATCH' });\n      expect(patchRes.status).toBe(200);\n      const updated = await patchRes.json();\n      expect(updated.done).toBe(true);\n    });\n\n    it('returns 404 for non-existent todo', async () => {\n      // YOUR CODE: Test PATCH /todos/999 returns 404\n      const res = await app.request('/todos/999', { method: 'PATCH' });\n      expect(res.status).toBe(404);\n    });\n  });\n});\n\nconsole.log('\\n--- Integration Tests Complete ---');",
              "solution": "// Simulating bun:test and Hono\nconst describe = (name, fn) => { console.log(`\\ndescribe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toEqual: (exp) => { if (JSON.stringify(val) !== JSON.stringify(exp)) throw new Error(`Expected ${JSON.stringify(exp)}`); },\n  toContain: (exp) => { if (!val.includes(exp)) throw new Error(`Expected to contain ${exp}`); }\n});\nconst beforeEach = (fn) => { fn(); };\n\nfunction createApp() {\n  const todos = [];\n  let nextId = 1;\n  \n  return {\n    request: async (path, options = {}) => {\n      const method = options.method || 'GET';\n      const body = options.body ? JSON.parse(options.body) : null;\n      \n      if (path === '/todos' && method === 'GET') {\n        return { status: 200, json: async () => [...todos] };\n      }\n      \n      if (path === '/todos' && method === 'POST') {\n        if (!body?.text) {\n          return { status: 400, json: async () => ({ error: 'Text required' }) };\n        }\n        const todo = { id: nextId++, text: body.text, done: false };\n        todos.push(todo);\n        return { status: 201, json: async () => todo };\n      }\n      \n      if (path.startsWith('/todos/') && method === 'PATCH') {\n        const id = parseInt(path.split('/')[2]);\n        const todo = todos.find(t => t.id === id);\n        if (!todo) return { status: 404, json: async () => ({ error: 'Not found' }) };\n        todo.done = !todo.done;\n        return { status: 200, json: async () => todo };\n      }\n      \n      return { status: 404 };\n    }\n  };\n}\n\ndescribe('Todo API Integration Tests', () => {\n  let app;\n  \n  beforeEach(() => {\n    app = createApp();\n  });\n\n  describe('GET /todos', () => {\n    it('returns empty array initially', async () => {\n      const res = await app.request('/todos');\n      expect(res.status).toBe(200);\n      expect(await res.json()).toEqual([]);\n    });\n  });\n\n  describe('POST /todos', () => {\n    it('creates a todo with valid text', async () => {\n      const res = await app.request('/todos', {\n        method: 'POST',\n        body: JSON.stringify({ text: 'Learn Bun testing' })\n      });\n      \n      expect(res.status).toBe(201);\n      const todo = await res.json();\n      expect(todo.text).toBe('Learn Bun testing');\n      expect(todo.done).toBe(false);\n    });\n\n    it('returns 400 for missing text', async () => {\n      const res = await app.request('/todos', {\n        method: 'POST',\n        body: JSON.stringify({})\n      });\n      expect(res.status).toBe(400);\n    });\n  });\n\n  describe('PATCH /todos/:id', () => {\n    it('toggles todo done status', async () => {\n      const createRes = await app.request('/todos', {\n        method: 'POST',\n        body: JSON.stringify({ text: 'Test todo' })\n      });\n      const { id } = await createRes.json();\n      \n      const patchRes = await app.request(`/todos/${id}`, { method: 'PATCH' });\n      expect(patchRes.status).toBe(200);\n      const updated = await patchRes.json();\n      expect(updated.done).toBe(true);\n    });\n\n    it('returns 404 for non-existent todo', async () => {\n      const res = await app.request('/todos/999', { method: 'PATCH' });\n      expect(res.status).toBe(404);\n    });\n  });\n});\n\nconsole.log('\\n--- Integration Tests Complete ---');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "All integration tests pass",
                  "expectedOutput": "Integration Tests Complete",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use app.request() with method and body options to test POST and PATCH"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "integration-testing",
          "title": "Integration Testing APIs",
          "moduleId": "module-16",
          "order": 9,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "CONCEPT",
              "title": "Unit vs Integration Tests",
              "content": "Understanding when to use unit tests versus integration tests is fundamental to building a robust test suite. Unit tests verify individual functions in isolation - they're fast, focused, and numerous. Integration tests verify that multiple components work together correctly - they're slower but catch different types of bugs.\n\nThe Testing Pyramid guides test distribution:\n\n**Unit Tests (Base)**: Test pure functions, business logic, utilities. Run in milliseconds. You should have hundreds of these.\n\n**Integration Tests (Middle)**: Test API endpoints, database operations, service interactions. Run in seconds. You should have dozens of these.\n\n**End-to-End Tests (Top)**: Test complete user workflows through the UI. Run in minutes. You should have few of these.\n\n**Cost-Benefit Tradeoffs:**\n- Unit tests are cheap to write and run but miss integration issues\n- Integration tests catch real-world bugs but are slower and more complex\n- E2E tests catch everything but are brittle and expensive to maintain\n\n**What Integration Tests Actually Test:**\n- Real HTTP request/response cycles\n- Database connections and queries\n- Authentication and authorization flows\n- Error handling across system boundaries\n- Request validation and serialization\n\nA healthy codebase follows the pyramid: many unit tests, some integration tests, few E2E tests. Integration tests fill the gap between isolated function testing and full system testing."
            },
            {
              "type": "CODE",
              "title": "Testing HTTP Endpoints",
              "content": "Integration tests make real HTTP requests to your API and verify the complete request/response cycle. With Hono's built-in test client, you can test endpoints without starting a server.",
              "language": "javascript",
              "code": "import { describe, it, expect, beforeEach } from 'bun:test';\nimport { Hono } from 'hono';\n\n// Create a testable app factory\nfunction createApp() {\n  const app = new Hono();\n  const users = new Map();\n  let nextId = 1;\n\n  // GET all users\n  app.get('/api/users', (c) => {\n    return c.json(Array.from(users.values()));\n  });\n\n  // GET single user\n  app.get('/api/users/:id', (c) => {\n    const id = parseInt(c.req.param('id'));\n    const user = users.get(id);\n    if (!user) {\n      return c.json({ error: 'User not found' }, 404);\n    }\n    return c.json(user);\n  });\n\n  // POST create user\n  app.post('/api/users', async (c) => {\n    const body = await c.req.json();\n    if (!body.name || !body.email) {\n      return c.json({ error: 'Name and email required' }, 400);\n    }\n    const user = { id: nextId++, name: body.name, email: body.email };\n    users.set(user.id, user);\n    return c.json(user, 201);\n  });\n\n  // PUT update user\n  app.put('/api/users/:id', async (c) => {\n    const id = parseInt(c.req.param('id'));\n    const user = users.get(id);\n    if (!user) {\n      return c.json({ error: 'User not found' }, 404);\n    }\n    const body = await c.req.json();\n    const updated = { ...user, ...body };\n    users.set(id, updated);\n    return c.json(updated);\n  });\n\n  // DELETE user\n  app.delete('/api/users/:id', (c) => {\n    const id = parseInt(c.req.param('id'));\n    if (!users.has(id)) {\n      return c.json({ error: 'User not found' }, 404);\n    }\n    users.delete(id);\n    return c.json({ deleted: true });\n  });\n\n  return app;\n}\n\ndescribe('Users API', () => {\n  let app;\n\n  beforeEach(() => {\n    app = createApp();  // Fresh app with empty state\n  });\n\n  describe('GET /api/users', () => {\n    it('returns empty array when no users exist', async () => {\n      const res = await app.request('/api/users');\n      \n      expect(res.status).toBe(200);\n      expect(await res.json()).toEqual([]);\n    });\n\n    it('returns all users', async () => {\n      // Create two users first\n      await app.request('/api/users', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name: 'Alice', email: 'alice@test.com' })\n      });\n      await app.request('/api/users', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name: 'Bob', email: 'bob@test.com' })\n      });\n\n      const res = await app.request('/api/users');\n      const users = await res.json();\n      \n      expect(res.status).toBe(200);\n      expect(users).toHaveLength(2);\n      expect(users[0].name).toBe('Alice');\n      expect(users[1].name).toBe('Bob');\n    });\n  });\n\n  describe('POST /api/users', () => {\n    it('creates user with valid data', async () => {\n      const res = await app.request('/api/users', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name: 'Alice', email: 'alice@test.com' })\n      });\n      \n      expect(res.status).toBe(201);\n      const user = await res.json();\n      expect(user.id).toBe(1);\n      expect(user.name).toBe('Alice');\n      expect(user.email).toBe('alice@test.com');\n    });\n  });\n\n  describe('PUT /api/users/:id', () => {\n    it('updates existing user', async () => {\n      // Create user\n      const createRes = await app.request('/api/users', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name: 'Alice', email: 'alice@test.com' })\n      });\n      const { id } = await createRes.json();\n\n      // Update user\n      const updateRes = await app.request(`/api/users/${id}`, {\n        method: 'PUT',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name: 'Alice Updated' })\n      });\n      \n      expect(updateRes.status).toBe(200);\n      const updated = await updateRes.json();\n      expect(updated.name).toBe('Alice Updated');\n      expect(updated.email).toBe('alice@test.com');  // Unchanged\n    });\n  });\n\n  describe('DELETE /api/users/:id', () => {\n    it('deletes existing user', async () => {\n      // Create user\n      const createRes = await app.request('/api/users', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name: 'Alice', email: 'alice@test.com' })\n      });\n      const { id } = await createRes.json();\n\n      // Delete user\n      const deleteRes = await app.request(`/api/users/${id}`, {\n        method: 'DELETE'\n      });\n      expect(deleteRes.status).toBe(200);\n\n      // Verify deleted\n      const getRes = await app.request(`/api/users/${id}`);\n      expect(getRes.status).toBe(404);\n    });\n  });\n});"
            },
            {
              "type": "CODE",
              "title": "Test Database Setup",
              "content": "Integration tests need a real database, but you want tests to be fast and isolated. In-memory SQLite is perfect for testing - it behaves like a real database but runs entirely in memory with no cleanup needed.",
              "language": "javascript",
              "code": "import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'bun:test';\nimport { Database } from 'bun:sqlite';\nimport { Hono } from 'hono';\n\n// Test database setup\nfunction createTestDatabase() {\n  // In-memory SQLite - destroyed when connection closes\n  const db = new Database(':memory:');\n  \n  // Create schema\n  db.run(`\n    CREATE TABLE users (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      name TEXT NOT NULL,\n      email TEXT UNIQUE NOT NULL,\n      created_at TEXT DEFAULT CURRENT_TIMESTAMP\n    )\n  `);\n  \n  db.run(`\n    CREATE TABLE posts (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      user_id INTEGER NOT NULL,\n      title TEXT NOT NULL,\n      content TEXT,\n      created_at TEXT DEFAULT CURRENT_TIMESTAMP,\n      FOREIGN KEY (user_id) REFERENCES users(id)\n    )\n  `);\n  \n  return db;\n}\n\n// Seed test data\nfunction seedTestData(db) {\n  const insertUser = db.prepare(\n    'INSERT INTO users (name, email) VALUES (?, ?)'\n  );\n  const insertPost = db.prepare(\n    'INSERT INTO posts (user_id, title, content) VALUES (?, ?, ?)'\n  );\n  \n  // Create test users\n  insertUser.run('Alice', 'alice@test.com');\n  insertUser.run('Bob', 'bob@test.com');\n  \n  // Create test posts\n  insertPost.run(1, 'First Post', 'Content of first post');\n  insertPost.run(1, 'Second Post', 'Content of second post');\n  insertPost.run(2, 'Bob Post', 'Bob writes something');\n}\n\n// Clear all data between tests\nfunction clearTestData(db) {\n  db.run('DELETE FROM posts');\n  db.run('DELETE FROM users');\n  // Reset autoincrement counters\n  db.run(\"DELETE FROM sqlite_sequence WHERE name='users'\");\n  db.run(\"DELETE FROM sqlite_sequence WHERE name='posts'\");\n}\n\n// Create app with injected database\nfunction createApp(db) {\n  const app = new Hono();\n\n  app.get('/api/users', (c) => {\n    const users = db.query('SELECT * FROM users').all();\n    return c.json(users);\n  });\n\n  app.get('/api/users/:id/posts', (c) => {\n    const userId = parseInt(c.req.param('id'));\n    const posts = db.query(\n      'SELECT * FROM posts WHERE user_id = ?'\n    ).all(userId);\n    return c.json(posts);\n  });\n\n  app.post('/api/users', async (c) => {\n    const { name, email } = await c.req.json();\n    try {\n      const result = db.run(\n        'INSERT INTO users (name, email) VALUES (?, ?)',\n        [name, email]\n      );\n      const user = db.query(\n        'SELECT * FROM users WHERE id = ?'\n      ).get(result.lastInsertRowid);\n      return c.json(user, 201);\n    } catch (error) {\n      if (error.message.includes('UNIQUE constraint')) {\n        return c.json({ error: 'Email already exists' }, 409);\n      }\n      throw error;\n    }\n  });\n\n  return app;\n}\n\ndescribe('Database Integration Tests', () => {\n  let db;\n  let app;\n\n  beforeAll(() => {\n    // Create database once for all tests\n    db = createTestDatabase();\n  });\n\n  afterAll(() => {\n    // Close database connection\n    db.close();\n  });\n\n  beforeEach(() => {\n    // Reset data before each test for isolation\n    clearTestData(db);\n    seedTestData(db);\n    app = createApp(db);\n  });\n\n  describe('GET /api/users', () => {\n    it('returns seeded users from database', async () => {\n      const res = await app.request('/api/users');\n      const users = await res.json();\n      \n      expect(users).toHaveLength(2);\n      expect(users[0].name).toBe('Alice');\n      expect(users[1].name).toBe('Bob');\n    });\n  });\n\n  describe('GET /api/users/:id/posts', () => {\n    it('returns posts for specific user', async () => {\n      const res = await app.request('/api/users/1/posts');\n      const posts = await res.json();\n      \n      expect(posts).toHaveLength(2);\n      expect(posts[0].title).toBe('First Post');\n    });\n\n    it('returns empty array for user with no posts', async () => {\n      // Create new user with no posts\n      await app.request('/api/users', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name: 'Charlie', email: 'charlie@test.com' })\n      });\n\n      const res = await app.request('/api/users/3/posts');\n      const posts = await res.json();\n      \n      expect(posts).toEqual([]);\n    });\n  });\n\n  describe('POST /api/users', () => {\n    it('persists user to database', async () => {\n      const res = await app.request('/api/users', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name: 'Charlie', email: 'charlie@test.com' })\n      });\n      \n      expect(res.status).toBe(201);\n      \n      // Verify in database directly\n      const user = db.query(\n        'SELECT * FROM users WHERE email = ?'\n      ).get('charlie@test.com');\n      expect(user.name).toBe('Charlie');\n    });\n\n    it('rejects duplicate email', async () => {\n      const res = await app.request('/api/users', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name: 'Duplicate', email: 'alice@test.com' })\n      });\n      \n      expect(res.status).toBe(409);\n      const error = await res.json();\n      expect(error.error).toBe('Email already exists');\n    });\n  });\n});"
            },
            {
              "type": "CODE",
              "title": "Testing Authentication Flows",
              "content": "Authentication tests verify login, token handling, and protected route access. You need to test the full flow: login to get a token, use the token to access protected routes, and verify unauthorized access is blocked.",
              "language": "javascript",
              "code": "import { describe, it, expect, beforeEach } from 'bun:test';\nimport { Hono } from 'hono';\nimport { sign, verify } from 'hono/jwt';\n\nconst JWT_SECRET = 'test-secret-key';\n\n// Create app with authentication\nfunction createAuthApp() {\n  const app = new Hono();\n  \n  // Mock user database\n  const users = new Map([\n    ['alice@test.com', { id: 1, email: 'alice@test.com', password: 'password123', role: 'admin' }],\n    ['bob@test.com', { id: 2, email: 'bob@test.com', password: 'secret456', role: 'user' }]\n  ]);\n\n  // Login endpoint\n  app.post('/api/auth/login', async (c) => {\n    const { email, password } = await c.req.json();\n    const user = users.get(email);\n    \n    if (!user || user.password !== password) {\n      return c.json({ error: 'Invalid credentials' }, 401);\n    }\n    \n    const token = await sign(\n      { userId: user.id, email: user.email, role: user.role },\n      JWT_SECRET\n    );\n    \n    return c.json({ token, user: { id: user.id, email: user.email, role: user.role } });\n  });\n\n  // Auth middleware\n  const authMiddleware = async (c, next) => {\n    const authHeader = c.req.header('Authorization');\n    if (!authHeader?.startsWith('Bearer ')) {\n      return c.json({ error: 'No token provided' }, 401);\n    }\n    \n    const token = authHeader.slice(7);\n    try {\n      const payload = await verify(token, JWT_SECRET);\n      c.set('user', payload);\n      await next();\n    } catch {\n      return c.json({ error: 'Invalid token' }, 401);\n    }\n  };\n\n  // Admin-only middleware\n  const adminOnly = async (c, next) => {\n    const user = c.get('user');\n    if (user.role !== 'admin') {\n      return c.json({ error: 'Admin access required' }, 403);\n    }\n    await next();\n  };\n\n  // Public endpoint\n  app.get('/api/public', (c) => c.json({ message: 'Public data' }));\n\n  // Protected endpoint\n  app.get('/api/profile', authMiddleware, (c) => {\n    const user = c.get('user');\n    return c.json({ userId: user.userId, email: user.email });\n  });\n\n  // Admin-only endpoint\n  app.get('/api/admin/users', authMiddleware, adminOnly, (c) => {\n    return c.json(Array.from(users.values()).map(u => ({\n      id: u.id, email: u.email, role: u.role\n    })));\n  });\n\n  // Logout (client-side token deletion, but we can test the endpoint)\n  app.post('/api/auth/logout', authMiddleware, (c) => {\n    return c.json({ message: 'Logged out successfully' });\n  });\n\n  return app;\n}\n\n// Helper to get auth token\nasync function loginAs(app, email, password) {\n  const res = await app.request('/api/auth/login', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ email, password })\n  });\n  const { token } = await res.json();\n  return token;\n}\n\ndescribe('Authentication API', () => {\n  let app;\n\n  beforeEach(() => {\n    app = createAuthApp();\n  });\n\n  describe('POST /api/auth/login', () => {\n    it('returns token for valid credentials', async () => {\n      const res = await app.request('/api/auth/login', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ email: 'alice@test.com', password: 'password123' })\n      });\n      \n      expect(res.status).toBe(200);\n      const data = await res.json();\n      expect(data.token).toBeDefined();\n      expect(data.user.email).toBe('alice@test.com');\n      expect(data.user.role).toBe('admin');\n    });\n\n    it('rejects invalid email', async () => {\n      const res = await app.request('/api/auth/login', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ email: 'wrong@test.com', password: 'password123' })\n      });\n      \n      expect(res.status).toBe(401);\n      const error = await res.json();\n      expect(error.error).toBe('Invalid credentials');\n    });\n\n    it('rejects invalid password', async () => {\n      const res = await app.request('/api/auth/login', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ email: 'alice@test.com', password: 'wrongpassword' })\n      });\n      \n      expect(res.status).toBe(401);\n    });\n  });\n\n  describe('Protected Routes', () => {\n    it('allows access with valid token', async () => {\n      const token = await loginAs(app, 'alice@test.com', 'password123');\n      \n      const res = await app.request('/api/profile', {\n        headers: { 'Authorization': `Bearer ${token}` }\n      });\n      \n      expect(res.status).toBe(200);\n      const profile = await res.json();\n      expect(profile.email).toBe('alice@test.com');\n    });\n\n    it('rejects request without token', async () => {\n      const res = await app.request('/api/profile');\n      \n      expect(res.status).toBe(401);\n      const error = await res.json();\n      expect(error.error).toBe('No token provided');\n    });\n\n    it('rejects invalid token', async () => {\n      const res = await app.request('/api/profile', {\n        headers: { 'Authorization': 'Bearer invalid-token-here' }\n      });\n      \n      expect(res.status).toBe(401);\n      const error = await res.json();\n      expect(error.error).toBe('Invalid token');\n    });\n\n    it('rejects malformed authorization header', async () => {\n      const res = await app.request('/api/profile', {\n        headers: { 'Authorization': 'NotBearer token' }\n      });\n      \n      expect(res.status).toBe(401);\n    });\n  });\n\n  describe('Authorization (Roles)', () => {\n    it('allows admin to access admin routes', async () => {\n      const token = await loginAs(app, 'alice@test.com', 'password123');\n      \n      const res = await app.request('/api/admin/users', {\n        headers: { 'Authorization': `Bearer ${token}` }\n      });\n      \n      expect(res.status).toBe(200);\n      const users = await res.json();\n      expect(users).toHaveLength(2);\n    });\n\n    it('denies non-admin from admin routes', async () => {\n      const token = await loginAs(app, 'bob@test.com', 'secret456');\n      \n      const res = await app.request('/api/admin/users', {\n        headers: { 'Authorization': `Bearer ${token}` }\n      });\n      \n      expect(res.status).toBe(403);\n      const error = await res.json();\n      expect(error.error).toBe('Admin access required');\n    });\n  });\n\n  describe('Logout', () => {\n    it('successfully logs out authenticated user', async () => {\n      const token = await loginAs(app, 'alice@test.com', 'password123');\n      \n      const res = await app.request('/api/auth/logout', {\n        method: 'POST',\n        headers: { 'Authorization': `Bearer ${token}` }\n      });\n      \n      expect(res.status).toBe(200);\n      const data = await res.json();\n      expect(data.message).toBe('Logged out successfully');\n    });\n  });\n});"
            },
            {
              "type": "CODE",
              "title": "Testing Error Cases",
              "content": "Error testing ensures your API handles failures gracefully. Test validation errors (400), not found errors (404), unauthorized access (401), forbidden actions (403), and server errors (500). Every error response should have a consistent format.",
              "language": "javascript",
              "code": "import { describe, it, expect, beforeEach } from 'bun:test';\nimport { Hono } from 'hono';\n\nfunction createApp() {\n  const app = new Hono();\n  const products = new Map([\n    [1, { id: 1, name: 'Widget', price: 29.99, stock: 10 }],\n    [2, { id: 2, name: 'Gadget', price: 49.99, stock: 0 }]  // Out of stock\n  ]);\n\n  // Validation middleware\n  const validateProduct = async (c, next) => {\n    const body = await c.req.json();\n    const errors = [];\n    \n    if (!body.name || typeof body.name !== 'string') {\n      errors.push({ field: 'name', message: 'Name is required and must be a string' });\n    }\n    if (body.name && body.name.length < 2) {\n      errors.push({ field: 'name', message: 'Name must be at least 2 characters' });\n    }\n    if (typeof body.price !== 'number' || body.price < 0) {\n      errors.push({ field: 'price', message: 'Price must be a positive number' });\n    }\n    if (body.stock !== undefined && (!Number.isInteger(body.stock) || body.stock < 0)) {\n      errors.push({ field: 'stock', message: 'Stock must be a non-negative integer' });\n    }\n    \n    if (errors.length > 0) {\n      return c.json({ error: 'Validation failed', details: errors }, 400);\n    }\n    \n    c.set('validatedBody', body);\n    await next();\n  };\n\n  // GET single product\n  app.get('/api/products/:id', (c) => {\n    const id = parseInt(c.req.param('id'));\n    \n    if (isNaN(id)) {\n      return c.json({ error: 'Invalid product ID format' }, 400);\n    }\n    \n    const product = products.get(id);\n    if (!product) {\n      return c.json({ error: 'Product not found', productId: id }, 404);\n    }\n    \n    return c.json(product);\n  });\n\n  // POST create product\n  app.post('/api/products', validateProduct, (c) => {\n    const body = c.get('validatedBody');\n    const id = products.size + 1;\n    const product = { id, ...body, stock: body.stock ?? 0 };\n    products.set(id, product);\n    return c.json(product, 201);\n  });\n\n  // POST purchase product\n  app.post('/api/products/:id/purchase', async (c) => {\n    const id = parseInt(c.req.param('id'));\n    const product = products.get(id);\n    \n    if (!product) {\n      return c.json({ error: 'Product not found' }, 404);\n    }\n    \n    const { quantity } = await c.req.json();\n    \n    if (!Number.isInteger(quantity) || quantity < 1) {\n      return c.json({ \n        error: 'Validation failed',\n        details: [{ field: 'quantity', message: 'Quantity must be a positive integer' }]\n      }, 400);\n    }\n    \n    if (product.stock < quantity) {\n      return c.json({ \n        error: 'Insufficient stock',\n        available: product.stock,\n        requested: quantity\n      }, 409);  // Conflict\n    }\n    \n    product.stock -= quantity;\n    return c.json({ \n      message: 'Purchase successful',\n      product: product,\n      purchased: quantity\n    });\n  });\n\n  // Simulate server error\n  app.get('/api/crash', () => {\n    throw new Error('Simulated server error');\n  });\n\n  // Global error handler\n  app.onError((err, c) => {\n    console.error('Server error:', err.message);\n    return c.json({ \n      error: 'Internal server error',\n      message: process.env.NODE_ENV === 'development' ? err.message : undefined\n    }, 500);\n  });\n\n  return app;\n}\n\ndescribe('Error Handling Tests', () => {\n  let app;\n\n  beforeEach(() => {\n    app = createApp();\n  });\n\n  describe('400 Bad Request - Validation Errors', () => {\n    it('rejects product with missing name', async () => {\n      const res = await app.request('/api/products', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ price: 19.99 })\n      });\n      \n      expect(res.status).toBe(400);\n      const error = await res.json();\n      expect(error.error).toBe('Validation failed');\n      expect(error.details).toContainEqual({\n        field: 'name',\n        message: 'Name is required and must be a string'\n      });\n    });\n\n    it('rejects product with negative price', async () => {\n      const res = await app.request('/api/products', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name: 'Test', price: -10 })\n      });\n      \n      expect(res.status).toBe(400);\n      const error = await res.json();\n      expect(error.details.some(d => d.field === 'price')).toBe(true);\n    });\n\n    it('rejects invalid ID format', async () => {\n      const res = await app.request('/api/products/abc');\n      \n      expect(res.status).toBe(400);\n      const error = await res.json();\n      expect(error.error).toBe('Invalid product ID format');\n    });\n\n    it('returns multiple validation errors at once', async () => {\n      const res = await app.request('/api/products', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name: '', price: -5, stock: -1 })\n      });\n      \n      expect(res.status).toBe(400);\n      const error = await res.json();\n      expect(error.details.length).toBeGreaterThan(1);\n    });\n  });\n\n  describe('404 Not Found', () => {\n    it('returns 404 for non-existent product', async () => {\n      const res = await app.request('/api/products/999');\n      \n      expect(res.status).toBe(404);\n      const error = await res.json();\n      expect(error.error).toBe('Product not found');\n      expect(error.productId).toBe(999);\n    });\n  });\n\n  describe('409 Conflict - Business Logic Errors', () => {\n    it('rejects purchase with insufficient stock', async () => {\n      const res = await app.request('/api/products/1/purchase', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ quantity: 100 })  // Only 10 in stock\n      });\n      \n      expect(res.status).toBe(409);\n      const error = await res.json();\n      expect(error.error).toBe('Insufficient stock');\n      expect(error.available).toBe(10);\n      expect(error.requested).toBe(100);\n    });\n\n    it('rejects purchase of out-of-stock item', async () => {\n      const res = await app.request('/api/products/2/purchase', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ quantity: 1 })\n      });\n      \n      expect(res.status).toBe(409);\n      const error = await res.json();\n      expect(error.available).toBe(0);\n    });\n  });\n\n  describe('500 Internal Server Error', () => {\n    it('handles unexpected errors gracefully', async () => {\n      const res = await app.request('/api/crash');\n      \n      expect(res.status).toBe(500);\n      const error = await res.json();\n      expect(error.error).toBe('Internal server error');\n    });\n  });\n\n  describe('Error Response Format Consistency', () => {\n    it('all errors have error field', async () => {\n      const responses = await Promise.all([\n        app.request('/api/products/abc'),           // 400\n        app.request('/api/products/999'),           // 404\n        app.request('/api/products', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({})\n        })                                           // 400\n      ]);\n      \n      for (const res of responses) {\n        expect(res.status).toBeGreaterThanOrEqual(400);\n        const body = await res.json();\n        expect(body.error).toBeDefined();\n      }\n    });\n  });\n});"
            },
            {
              "type": "WARNING",
              "title": "Integration Testing Pitfalls",
              "content": "Common integration testing mistakes to avoid:\n\n**1. Shared State Between Tests:**\n```javascript\n// WRONG - state leaks between tests\nconst app = createApp();\n\n// CORRECT - fresh instance each test\nbeforeEach(() => {\n  app = createApp();\n});\n```\n\n**2. Forgetting to Seed Test Data:**\n```javascript\n// WRONG - test depends on previous test\nit('finds user', async () => {\n  const res = await app.request('/api/users/1');\n  // Fails if 'creates user' test didn't run first\n});\n\n// CORRECT - each test is self-contained\nbeforeEach(() => {\n  seedTestData(db);\n});\n```\n\n**3. Not Cleaning Up Resources:**\n```javascript\nafterAll(() => {\n  db.close();  // Always close connections!\n});\n```\n\n**4. Testing Implementation Instead of Behavior:**\nTest what the API returns, not how it computes the result internally.\n\n**5. Forgetting Content-Type Header:**\n```javascript\n// WRONG - body won't be parsed\nawait app.request('/api/users', {\n  method: 'POST',\n  body: JSON.stringify({ name: 'Test' })\n});\n\n// CORRECT\nawait app.request('/api/users', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ name: 'Test' })\n});\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "integration-testing-crud",
              "title": "Test a CRUD API",
              "description": "Write a complete integration test suite for a Book API with Create, Read, Update, and Delete operations.",
              "instructions": "Complete the test suite for the Book API. Test all CRUD operations including edge cases like not found and validation errors. Each test should be independent and not rely on other tests.",
              "starterCode": "// Simulating bun:test and Hono for this exercise\nconst describe = (name, fn) => { console.log(`\\ndescribe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toEqual: (exp) => { if (JSON.stringify(val) !== JSON.stringify(exp)) throw new Error(`Expected ${JSON.stringify(exp)}`); },\n  toHaveLength: (n) => { if (val.length !== n) throw new Error(`Expected length ${n}, got ${val.length}`); },\n  toBeDefined: () => { if (val === undefined) throw new Error('Expected value to be defined'); }\n});\nconst beforeEach = (fn) => fn();\n\n// Book API simulation\nfunction createBookApp() {\n  const books = new Map();\n  let nextId = 1;\n\n  return {\n    request: async (path, options = {}) => {\n      const method = options.method || 'GET';\n      const body = options.body ? JSON.parse(options.body) : null;\n\n      // GET /api/books\n      if (path === '/api/books' && method === 'GET') {\n        return { status: 200, json: async () => Array.from(books.values()) };\n      }\n\n      // GET /api/books/:id\n      if (path.match(/\\/api\\/books\\/\\d+$/) && method === 'GET') {\n        const id = parseInt(path.split('/').pop());\n        const book = books.get(id);\n        if (!book) return { status: 404, json: async () => ({ error: 'Book not found' }) };\n        return { status: 200, json: async () => book };\n      }\n\n      // POST /api/books\n      if (path === '/api/books' && method === 'POST') {\n        if (!body?.title || !body?.author) {\n          return { status: 400, json: async () => ({ error: 'Title and author required' }) };\n        }\n        const book = { id: nextId++, title: body.title, author: body.author, year: body.year || null };\n        books.set(book.id, book);\n        return { status: 201, json: async () => book };\n      }\n\n      // PUT /api/books/:id\n      if (path.match(/\\/api\\/books\\/\\d+$/) && method === 'PUT') {\n        const id = parseInt(path.split('/').pop());\n        const book = books.get(id);\n        if (!book) return { status: 404, json: async () => ({ error: 'Book not found' }) };\n        const updated = { ...book, ...body };\n        books.set(id, updated);\n        return { status: 200, json: async () => updated };\n      }\n\n      // DELETE /api/books/:id\n      if (path.match(/\\/api\\/books\\/\\d+$/) && method === 'DELETE') {\n        const id = parseInt(path.split('/').pop());\n        if (!books.has(id)) return { status: 404, json: async () => ({ error: 'Book not found' }) };\n        books.delete(id);\n        return { status: 200, json: async () => ({ deleted: true }) };\n      }\n\n      return { status: 404, json: async () => ({ error: 'Not found' }) };\n    }\n  };\n}\n\ndescribe('Book API CRUD Tests', () => {\n  let app;\n\n  beforeEach(() => {\n    app = createBookApp();\n  });\n\n  describe('CREATE - POST /api/books', () => {\n    it('creates a book with valid data', async () => {\n      const res = await app.request('/api/books', {\n        method: 'POST',\n        body: JSON.stringify({ title: '1984', author: 'George Orwell', year: 1949 })\n      });\n\n      expect(res.status).toBe(201);\n      const book = await res.json();\n      expect(book.title).toBe('1984');\n      expect(book.id).toBeDefined();\n    });\n\n    it('rejects book without title', async () => {\n      // YOUR CODE: Test POST with missing title returns 400\n    });\n  });\n\n  describe('READ - GET /api/books', () => {\n    it('returns empty array initially', async () => {\n      const res = await app.request('/api/books');\n      expect(res.status).toBe(200);\n      expect(await res.json()).toEqual([]);\n    });\n\n    it('returns created books', async () => {\n      // YOUR CODE: Create a book, then verify GET returns it\n    });\n  });\n\n  describe('READ - GET /api/books/:id', () => {\n    it('returns 404 for non-existent book', async () => {\n      // YOUR CODE: Test GET /api/books/999 returns 404\n    });\n  });\n\n  describe('UPDATE - PUT /api/books/:id', () => {\n    it('updates existing book', async () => {\n      // Create book first\n      const createRes = await app.request('/api/books', {\n        method: 'POST',\n        body: JSON.stringify({ title: 'Draft', author: 'Unknown' })\n      });\n      const { id } = await createRes.json();\n\n      // YOUR CODE: Update the book title and verify the change\n    });\n  });\n\n  describe('DELETE - DELETE /api/books/:id', () => {\n    it('deletes existing book', async () => {\n      // YOUR CODE: Create book, delete it, verify it's gone\n    });\n  });\n});\n\nconsole.log('\\n--- CRUD Tests Complete ---');",
              "solution": "// Simulating bun:test and Hono for this exercise\nconst describe = (name, fn) => { console.log(`\\ndescribe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toEqual: (exp) => { if (JSON.stringify(val) !== JSON.stringify(exp)) throw new Error(`Expected ${JSON.stringify(exp)}`); },\n  toHaveLength: (n) => { if (val.length !== n) throw new Error(`Expected length ${n}, got ${val.length}`); },\n  toBeDefined: () => { if (val === undefined) throw new Error('Expected value to be defined'); }\n});\nconst beforeEach = (fn) => fn();\n\nfunction createBookApp() {\n  const books = new Map();\n  let nextId = 1;\n\n  return {\n    request: async (path, options = {}) => {\n      const method = options.method || 'GET';\n      const body = options.body ? JSON.parse(options.body) : null;\n\n      if (path === '/api/books' && method === 'GET') {\n        return { status: 200, json: async () => Array.from(books.values()) };\n      }\n\n      if (path.match(/\\/api\\/books\\/\\d+$/) && method === 'GET') {\n        const id = parseInt(path.split('/').pop());\n        const book = books.get(id);\n        if (!book) return { status: 404, json: async () => ({ error: 'Book not found' }) };\n        return { status: 200, json: async () => book };\n      }\n\n      if (path === '/api/books' && method === 'POST') {\n        if (!body?.title || !body?.author) {\n          return { status: 400, json: async () => ({ error: 'Title and author required' }) };\n        }\n        const book = { id: nextId++, title: body.title, author: body.author, year: body.year || null };\n        books.set(book.id, book);\n        return { status: 201, json: async () => book };\n      }\n\n      if (path.match(/\\/api\\/books\\/\\d+$/) && method === 'PUT') {\n        const id = parseInt(path.split('/').pop());\n        const book = books.get(id);\n        if (!book) return { status: 404, json: async () => ({ error: 'Book not found' }) };\n        const updated = { ...book, ...body };\n        books.set(id, updated);\n        return { status: 200, json: async () => updated };\n      }\n\n      if (path.match(/\\/api\\/books\\/\\d+$/) && method === 'DELETE') {\n        const id = parseInt(path.split('/').pop());\n        if (!books.has(id)) return { status: 404, json: async () => ({ error: 'Book not found' }) };\n        books.delete(id);\n        return { status: 200, json: async () => ({ deleted: true }) };\n      }\n\n      return { status: 404, json: async () => ({ error: 'Not found' }) };\n    }\n  };\n}\n\ndescribe('Book API CRUD Tests', () => {\n  let app;\n\n  beforeEach(() => {\n    app = createBookApp();\n  });\n\n  describe('CREATE - POST /api/books', () => {\n    it('creates a book with valid data', async () => {\n      const res = await app.request('/api/books', {\n        method: 'POST',\n        body: JSON.stringify({ title: '1984', author: 'George Orwell', year: 1949 })\n      });\n\n      expect(res.status).toBe(201);\n      const book = await res.json();\n      expect(book.title).toBe('1984');\n      expect(book.id).toBeDefined();\n    });\n\n    it('rejects book without title', async () => {\n      const res = await app.request('/api/books', {\n        method: 'POST',\n        body: JSON.stringify({ author: 'Unknown' })\n      });\n      expect(res.status).toBe(400);\n    });\n  });\n\n  describe('READ - GET /api/books', () => {\n    it('returns empty array initially', async () => {\n      const res = await app.request('/api/books');\n      expect(res.status).toBe(200);\n      expect(await res.json()).toEqual([]);\n    });\n\n    it('returns created books', async () => {\n      await app.request('/api/books', {\n        method: 'POST',\n        body: JSON.stringify({ title: 'Test Book', author: 'Test Author' })\n      });\n\n      const res = await app.request('/api/books');\n      const books = await res.json();\n      expect(books).toHaveLength(1);\n      expect(books[0].title).toBe('Test Book');\n    });\n  });\n\n  describe('READ - GET /api/books/:id', () => {\n    it('returns 404 for non-existent book', async () => {\n      const res = await app.request('/api/books/999');\n      expect(res.status).toBe(404);\n    });\n  });\n\n  describe('UPDATE - PUT /api/books/:id', () => {\n    it('updates existing book', async () => {\n      const createRes = await app.request('/api/books', {\n        method: 'POST',\n        body: JSON.stringify({ title: 'Draft', author: 'Unknown' })\n      });\n      const { id } = await createRes.json();\n\n      const updateRes = await app.request(`/api/books/${id}`, {\n        method: 'PUT',\n        body: JSON.stringify({ title: 'Final Title' })\n      });\n      expect(updateRes.status).toBe(200);\n      const updated = await updateRes.json();\n      expect(updated.title).toBe('Final Title');\n    });\n  });\n\n  describe('DELETE - DELETE /api/books/:id', () => {\n    it('deletes existing book', async () => {\n      const createRes = await app.request('/api/books', {\n        method: 'POST',\n        body: JSON.stringify({ title: 'To Delete', author: 'Someone' })\n      });\n      const { id } = await createRes.json();\n\n      const deleteRes = await app.request(`/api/books/${id}`, { method: 'DELETE' });\n      expect(deleteRes.status).toBe(200);\n\n      const getRes = await app.request(`/api/books/${id}`);\n      expect(getRes.status).toBe(404);\n    });\n  });\n});\n\nconsole.log('\\n--- CRUD Tests Complete ---');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "All CRUD tests pass",
                  "expectedOutput": "CRUD Tests Complete",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Each test should create its own data - don't rely on other tests"
                },
                {
                  "level": 2,
                  "text": "Use await app.request() for all API calls and await res.json() to read responses"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "integration-testing-auth",
              "title": "Authentication Test Suite",
              "description": "Write tests for a complete authentication flow including login, accessing protected routes, and verifying unauthorized access is blocked.",
              "instructions": "Complete the authentication test suite. Test login with valid/invalid credentials, access to protected routes with/without tokens, and logout functionality.",
              "starterCode": "// Simulating bun:test for this exercise\nconst describe = (name, fn) => { console.log(`\\ndescribe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toBeDefined: () => { if (val === undefined) throw new Error('Expected to be defined'); },\n  toContain: (exp) => { if (!val.includes(exp)) throw new Error(`Expected to contain ${exp}`); }\n});\nconst beforeEach = (fn) => fn();\n\n// Auth API simulation\nfunction createAuthApp() {\n  const users = new Map([\n    ['user@test.com', { id: 1, email: 'user@test.com', password: 'pass123' }]\n  ]);\n  const tokens = new Map();\n\n  return {\n    request: async (path, options = {}) => {\n      const method = options.method || 'GET';\n      const body = options.body ? JSON.parse(options.body) : null;\n      const authHeader = options.headers?.Authorization || '';\n\n      // POST /api/login\n      if (path === '/api/login' && method === 'POST') {\n        const user = users.get(body?.email);\n        if (!user || user.password !== body?.password) {\n          return { status: 401, json: async () => ({ error: 'Invalid credentials' }) };\n        }\n        const token = `token_${Date.now()}`;\n        tokens.set(token, user);\n        return { status: 200, json: async () => ({ token, user: { id: user.id, email: user.email } }) };\n      }\n\n      // GET /api/me (protected)\n      if (path === '/api/me' && method === 'GET') {\n        if (!authHeader.startsWith('Bearer ')) {\n          return { status: 401, json: async () => ({ error: 'No token provided' }) };\n        }\n        const token = authHeader.slice(7);\n        const user = tokens.get(token);\n        if (!user) {\n          return { status: 401, json: async () => ({ error: 'Invalid token' }) };\n        }\n        return { status: 200, json: async () => ({ id: user.id, email: user.email }) };\n      }\n\n      // POST /api/logout (protected)\n      if (path === '/api/logout' && method === 'POST') {\n        if (!authHeader.startsWith('Bearer ')) {\n          return { status: 401, json: async () => ({ error: 'No token provided' }) };\n        }\n        const token = authHeader.slice(7);\n        tokens.delete(token);\n        return { status: 200, json: async () => ({ message: 'Logged out' }) };\n      }\n\n      return { status: 404, json: async () => ({ error: 'Not found' }) };\n    }\n  };\n}\n\n// Helper to login and get token\nasync function login(app, email, password) {\n  const res = await app.request('/api/login', {\n    method: 'POST',\n    body: JSON.stringify({ email, password })\n  });\n  if (res.status !== 200) return null;\n  const { token } = await res.json();\n  return token;\n}\n\ndescribe('Authentication Flow Tests', () => {\n  let app;\n\n  beforeEach(() => {\n    app = createAuthApp();\n  });\n\n  describe('Login', () => {\n    it('returns token for valid credentials', async () => {\n      const res = await app.request('/api/login', {\n        method: 'POST',\n        body: JSON.stringify({ email: 'user@test.com', password: 'pass123' })\n      });\n\n      expect(res.status).toBe(200);\n      const data = await res.json();\n      expect(data.token).toBeDefined();\n      expect(data.user.email).toBe('user@test.com');\n    });\n\n    it('rejects invalid password', async () => {\n      // YOUR CODE: Test login with wrong password returns 401\n    });\n\n    it('rejects non-existent user', async () => {\n      // YOUR CODE: Test login with unknown email returns 401\n    });\n  });\n\n  describe('Protected Routes', () => {\n    it('allows access with valid token', async () => {\n      const token = await login(app, 'user@test.com', 'pass123');\n\n      const res = await app.request('/api/me', {\n        headers: { Authorization: `Bearer ${token}` }\n      });\n\n      expect(res.status).toBe(200);\n      const user = await res.json();\n      expect(user.email).toBe('user@test.com');\n    });\n\n    it('rejects request without token', async () => {\n      // YOUR CODE: Test /api/me without Authorization header\n    });\n\n    it('rejects request with invalid token', async () => {\n      // YOUR CODE: Test /api/me with fake token\n    });\n  });\n\n  describe('Logout', () => {\n    it('invalidates token after logout', async () => {\n      // YOUR CODE: Login, logout, then verify token no longer works\n    });\n  });\n});\n\nconsole.log('\\n--- Auth Tests Complete ---');",
              "solution": "// Simulating bun:test for this exercise\nconst describe = (name, fn) => { console.log(`\\ndescribe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toBeDefined: () => { if (val === undefined) throw new Error('Expected to be defined'); },\n  toContain: (exp) => { if (!val.includes(exp)) throw new Error(`Expected to contain ${exp}`); }\n});\nconst beforeEach = (fn) => fn();\n\nfunction createAuthApp() {\n  const users = new Map([\n    ['user@test.com', { id: 1, email: 'user@test.com', password: 'pass123' }]\n  ]);\n  const tokens = new Map();\n\n  return {\n    request: async (path, options = {}) => {\n      const method = options.method || 'GET';\n      const body = options.body ? JSON.parse(options.body) : null;\n      const authHeader = options.headers?.Authorization || '';\n\n      if (path === '/api/login' && method === 'POST') {\n        const user = users.get(body?.email);\n        if (!user || user.password !== body?.password) {\n          return { status: 401, json: async () => ({ error: 'Invalid credentials' }) };\n        }\n        const token = `token_${Date.now()}`;\n        tokens.set(token, user);\n        return { status: 200, json: async () => ({ token, user: { id: user.id, email: user.email } }) };\n      }\n\n      if (path === '/api/me' && method === 'GET') {\n        if (!authHeader.startsWith('Bearer ')) {\n          return { status: 401, json: async () => ({ error: 'No token provided' }) };\n        }\n        const token = authHeader.slice(7);\n        const user = tokens.get(token);\n        if (!user) {\n          return { status: 401, json: async () => ({ error: 'Invalid token' }) };\n        }\n        return { status: 200, json: async () => ({ id: user.id, email: user.email }) };\n      }\n\n      if (path === '/api/logout' && method === 'POST') {\n        if (!authHeader.startsWith('Bearer ')) {\n          return { status: 401, json: async () => ({ error: 'No token provided' }) };\n        }\n        const token = authHeader.slice(7);\n        tokens.delete(token);\n        return { status: 200, json: async () => ({ message: 'Logged out' }) };\n      }\n\n      return { status: 404, json: async () => ({ error: 'Not found' }) };\n    }\n  };\n}\n\nasync function login(app, email, password) {\n  const res = await app.request('/api/login', {\n    method: 'POST',\n    body: JSON.stringify({ email, password })\n  });\n  if (res.status !== 200) return null;\n  const { token } = await res.json();\n  return token;\n}\n\ndescribe('Authentication Flow Tests', () => {\n  let app;\n\n  beforeEach(() => {\n    app = createAuthApp();\n  });\n\n  describe('Login', () => {\n    it('returns token for valid credentials', async () => {\n      const res = await app.request('/api/login', {\n        method: 'POST',\n        body: JSON.stringify({ email: 'user@test.com', password: 'pass123' })\n      });\n\n      expect(res.status).toBe(200);\n      const data = await res.json();\n      expect(data.token).toBeDefined();\n      expect(data.user.email).toBe('user@test.com');\n    });\n\n    it('rejects invalid password', async () => {\n      const res = await app.request('/api/login', {\n        method: 'POST',\n        body: JSON.stringify({ email: 'user@test.com', password: 'wrong' })\n      });\n      expect(res.status).toBe(401);\n    });\n\n    it('rejects non-existent user', async () => {\n      const res = await app.request('/api/login', {\n        method: 'POST',\n        body: JSON.stringify({ email: 'unknown@test.com', password: 'pass123' })\n      });\n      expect(res.status).toBe(401);\n    });\n  });\n\n  describe('Protected Routes', () => {\n    it('allows access with valid token', async () => {\n      const token = await login(app, 'user@test.com', 'pass123');\n\n      const res = await app.request('/api/me', {\n        headers: { Authorization: `Bearer ${token}` }\n      });\n\n      expect(res.status).toBe(200);\n      const user = await res.json();\n      expect(user.email).toBe('user@test.com');\n    });\n\n    it('rejects request without token', async () => {\n      const res = await app.request('/api/me');\n      expect(res.status).toBe(401);\n    });\n\n    it('rejects request with invalid token', async () => {\n      const res = await app.request('/api/me', {\n        headers: { Authorization: 'Bearer fake-token-12345' }\n      });\n      expect(res.status).toBe(401);\n    });\n  });\n\n  describe('Logout', () => {\n    it('invalidates token after logout', async () => {\n      const token = await login(app, 'user@test.com', 'pass123');\n\n      // Logout\n      await app.request('/api/logout', {\n        method: 'POST',\n        headers: { Authorization: `Bearer ${token}` }\n      });\n\n      // Token should no longer work\n      const res = await app.request('/api/me', {\n        headers: { Authorization: `Bearer ${token}` }\n      });\n      expect(res.status).toBe(401);\n    });\n  });\n});\n\nconsole.log('\\n--- Auth Tests Complete ---');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "All authentication tests pass",
                  "expectedOutput": "Auth Tests Complete",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the login helper to get a token, then use it in the Authorization header"
                },
                {
                  "level": 2,
                  "text": "For logout test: login first, call logout, then try to use the same token"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "integration-testing-errors",
              "title": "Error Scenario Tests",
              "description": "Write comprehensive tests for all error scenarios of an Order API endpoint including validation errors, not found, and business logic errors.",
              "instructions": "Complete the error scenario tests. Test 400 (validation), 404 (not found), and 409 (conflict) error cases. Verify error response formats are consistent.",
              "starterCode": "// Simulating bun:test for this exercise\nconst describe = (name, fn) => { console.log(`\\ndescribe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toBeDefined: () => { if (val === undefined) throw new Error('Expected defined'); },\n  toBeGreaterThan: (n) => { if (!(val > n)) throw new Error(`Expected > ${n}`); }\n});\nconst beforeEach = (fn) => fn();\n\n// Order API with various error scenarios\nfunction createOrderApp() {\n  const products = new Map([\n    [1, { id: 1, name: 'Widget', price: 10, stock: 5 }],\n    [2, { id: 2, name: 'Gadget', price: 25, stock: 0 }]  // Out of stock\n  ]);\n\n  return {\n    request: async (path, options = {}) => {\n      const method = options.method || 'GET';\n      const body = options.body ? JSON.parse(options.body) : null;\n\n      // POST /api/orders\n      if (path === '/api/orders' && method === 'POST') {\n        // Validation: required fields\n        if (!body?.productId || !body?.quantity) {\n          return { \n            status: 400, \n            json: async () => ({ \n              error: 'Validation failed',\n              details: [{ field: 'productId/quantity', message: 'Required fields missing' }]\n            })\n          };\n        }\n\n        // Validation: quantity must be positive\n        if (body.quantity < 1) {\n          return {\n            status: 400,\n            json: async () => ({\n              error: 'Validation failed',\n              details: [{ field: 'quantity', message: 'Must be at least 1' }]\n            })\n          };\n        }\n\n        // 404: Product not found\n        const product = products.get(body.productId);\n        if (!product) {\n          return {\n            status: 404,\n            json: async () => ({ error: 'Product not found', productId: body.productId })\n          };\n        }\n\n        // 409: Insufficient stock\n        if (product.stock < body.quantity) {\n          return {\n            status: 409,\n            json: async () => ({\n              error: 'Insufficient stock',\n              available: product.stock,\n              requested: body.quantity\n            })\n          };\n        }\n\n        // Success\n        product.stock -= body.quantity;\n        return {\n          status: 201,\n          json: async () => ({\n            orderId: Date.now(),\n            product: product.name,\n            quantity: body.quantity,\n            total: product.price * body.quantity\n          })\n        };\n      }\n\n      return { status: 404 };\n    }\n  };\n}\n\ndescribe('Order API Error Scenarios', () => {\n  let app;\n\n  beforeEach(() => {\n    app = createOrderApp();\n  });\n\n  describe('400 Validation Errors', () => {\n    it('rejects order without productId', async () => {\n      const res = await app.request('/api/orders', {\n        method: 'POST',\n        body: JSON.stringify({ quantity: 2 })\n      });\n\n      expect(res.status).toBe(400);\n      const error = await res.json();\n      expect(error.error).toBe('Validation failed');\n      expect(error.details).toBeDefined();\n    });\n\n    it('rejects order with quantity less than 1', async () => {\n      // YOUR CODE: Test order with quantity: 0\n    });\n\n    it('rejects order with negative quantity', async () => {\n      // YOUR CODE: Test order with quantity: -5\n    });\n  });\n\n  describe('404 Not Found', () => {\n    it('returns 404 for non-existent product', async () => {\n      // YOUR CODE: Order product ID 999\n    });\n\n    it('includes productId in error response', async () => {\n      // YOUR CODE: Verify error response contains the productId\n    });\n  });\n\n  describe('409 Conflict (Business Logic)', () => {\n    it('rejects order exceeding stock', async () => {\n      // YOUR CODE: Order 100 of product 1 (only 5 in stock)\n    });\n\n    it('rejects order for out-of-stock item', async () => {\n      // YOUR CODE: Order product 2 (0 stock)\n    });\n\n    it('includes stock info in error response', async () => {\n      const res = await app.request('/api/orders', {\n        method: 'POST',\n        body: JSON.stringify({ productId: 1, quantity: 100 })\n      });\n\n      expect(res.status).toBe(409);\n      const error = await res.json();\n      // YOUR CODE: Verify error contains available and requested\n    });\n  });\n\n  describe('Success Case (for comparison)', () => {\n    it('creates order with valid data', async () => {\n      const res = await app.request('/api/orders', {\n        method: 'POST',\n        body: JSON.stringify({ productId: 1, quantity: 2 })\n      });\n\n      expect(res.status).toBe(201);\n      const order = await res.json();\n      expect(order.orderId).toBeDefined();\n      expect(order.total).toBe(20);  // 10 * 2\n    });\n  });\n});\n\nconsole.log('\\n--- Error Tests Complete ---');",
              "solution": "// Simulating bun:test for this exercise\nconst describe = (name, fn) => { console.log(`\\ndescribe: ${name}`); fn(); };\nconst it = async (name, fn) => {\n  try { await fn(); console.log(`  \\u2713 ${name}`); }\n  catch (e) { console.log(`  \\u2717 ${name}: ${e.message}`); }\n};\nconst expect = (val) => ({\n  toBe: (exp) => { if (val !== exp) throw new Error(`Expected ${exp}, got ${val}`); },\n  toBeDefined: () => { if (val === undefined) throw new Error('Expected defined'); },\n  toBeGreaterThan: (n) => { if (!(val > n)) throw new Error(`Expected > ${n}`); }\n});\nconst beforeEach = (fn) => fn();\n\nfunction createOrderApp() {\n  const products = new Map([\n    [1, { id: 1, name: 'Widget', price: 10, stock: 5 }],\n    [2, { id: 2, name: 'Gadget', price: 25, stock: 0 }]\n  ]);\n\n  return {\n    request: async (path, options = {}) => {\n      const method = options.method || 'GET';\n      const body = options.body ? JSON.parse(options.body) : null;\n\n      if (path === '/api/orders' && method === 'POST') {\n        if (!body?.productId || !body?.quantity) {\n          return { \n            status: 400, \n            json: async () => ({ \n              error: 'Validation failed',\n              details: [{ field: 'productId/quantity', message: 'Required fields missing' }]\n            })\n          };\n        }\n\n        if (body.quantity < 1) {\n          return {\n            status: 400,\n            json: async () => ({\n              error: 'Validation failed',\n              details: [{ field: 'quantity', message: 'Must be at least 1' }]\n            })\n          };\n        }\n\n        const product = products.get(body.productId);\n        if (!product) {\n          return {\n            status: 404,\n            json: async () => ({ error: 'Product not found', productId: body.productId })\n          };\n        }\n\n        if (product.stock < body.quantity) {\n          return {\n            status: 409,\n            json: async () => ({\n              error: 'Insufficient stock',\n              available: product.stock,\n              requested: body.quantity\n            })\n          };\n        }\n\n        product.stock -= body.quantity;\n        return {\n          status: 201,\n          json: async () => ({\n            orderId: Date.now(),\n            product: product.name,\n            quantity: body.quantity,\n            total: product.price * body.quantity\n          })\n        };\n      }\n\n      return { status: 404 };\n    }\n  };\n}\n\ndescribe('Order API Error Scenarios', () => {\n  let app;\n\n  beforeEach(() => {\n    app = createOrderApp();\n  });\n\n  describe('400 Validation Errors', () => {\n    it('rejects order without productId', async () => {\n      const res = await app.request('/api/orders', {\n        method: 'POST',\n        body: JSON.stringify({ quantity: 2 })\n      });\n\n      expect(res.status).toBe(400);\n      const error = await res.json();\n      expect(error.error).toBe('Validation failed');\n      expect(error.details).toBeDefined();\n    });\n\n    it('rejects order with quantity less than 1', async () => {\n      const res = await app.request('/api/orders', {\n        method: 'POST',\n        body: JSON.stringify({ productId: 1, quantity: 0 })\n      });\n      expect(res.status).toBe(400);\n    });\n\n    it('rejects order with negative quantity', async () => {\n      const res = await app.request('/api/orders', {\n        method: 'POST',\n        body: JSON.stringify({ productId: 1, quantity: -5 })\n      });\n      expect(res.status).toBe(400);\n    });\n  });\n\n  describe('404 Not Found', () => {\n    it('returns 404 for non-existent product', async () => {\n      const res = await app.request('/api/orders', {\n        method: 'POST',\n        body: JSON.stringify({ productId: 999, quantity: 1 })\n      });\n      expect(res.status).toBe(404);\n    });\n\n    it('includes productId in error response', async () => {\n      const res = await app.request('/api/orders', {\n        method: 'POST',\n        body: JSON.stringify({ productId: 999, quantity: 1 })\n      });\n      const error = await res.json();\n      expect(error.productId).toBe(999);\n    });\n  });\n\n  describe('409 Conflict (Business Logic)', () => {\n    it('rejects order exceeding stock', async () => {\n      const res = await app.request('/api/orders', {\n        method: 'POST',\n        body: JSON.stringify({ productId: 1, quantity: 100 })\n      });\n      expect(res.status).toBe(409);\n    });\n\n    it('rejects order for out-of-stock item', async () => {\n      const res = await app.request('/api/orders', {\n        method: 'POST',\n        body: JSON.stringify({ productId: 2, quantity: 1 })\n      });\n      expect(res.status).toBe(409);\n    });\n\n    it('includes stock info in error response', async () => {\n      const res = await app.request('/api/orders', {\n        method: 'POST',\n        body: JSON.stringify({ productId: 1, quantity: 100 })\n      });\n\n      expect(res.status).toBe(409);\n      const error = await res.json();\n      expect(error.available).toBeDefined();\n      expect(error.requested).toBe(100);\n    });\n  });\n\n  describe('Success Case (for comparison)', () => {\n    it('creates order with valid data', async () => {\n      const res = await app.request('/api/orders', {\n        method: 'POST',\n        body: JSON.stringify({ productId: 1, quantity: 2 })\n      });\n\n      expect(res.status).toBe(201);\n      const order = await res.json();\n      expect(order.orderId).toBeDefined();\n      expect(order.total).toBe(20);\n    });\n  });\n});\n\nconsole.log('\\n--- Error Tests Complete ---');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "All error scenario tests pass",
                  "expectedOutput": "Error Tests Complete",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Each error type (400, 404, 409) should be tested separately"
                },
                {
                  "level": 2,
                  "text": "Error responses should include helpful information like productId or stock levels"
                }
              ],
              "commonMistakes": [],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-17",
      "title": "Module 17: Type-Safe JavaScript with JSDoc",
      "description": "Get TypeScript-level type safety without changing your file extensions. Learn to use JSDoc comments for full IDE support, catch errors before runtime, and create a migration path to TypeScript.",
      "difficulty": "intermediate",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "16.1",
          "title": "Why Types Matter (The Blueprint Analogy)",
          "moduleId": "module-16",
          "order": 1,
          "estimatedMinutes": 20,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Building Without a Blueprint",
              "content": "Imagine building a house without blueprints. The electrician runs wires where they think outlets should go. The plumber puts pipes wherever is convenient. When the drywall goes up, half the outlets are in the wrong places and pipes cross where they shouldn't.\n\nDynamic typing in JavaScript is like building without blueprints. Everything MIGHT work, but you won't find out until the house is built (or your app is in production).\n\nTypes are your blueprints. They catch mistakes before anyone starts building."
            },
            {
              "type": "EXAMPLE",
              "title": "A Real Production Bug",
              "content": "This code shipped to production. Can you spot the bug?",
              "language": "javascript",
              "code": "function calculateDiscount(price, discountPercent) {\n  return price - (price * discountPercent);\n}\n\n// Developer A uses it correctly\nconst salePrice = calculateDiscount(100, 0.2);  // 80\n\n// Developer B reads \"discountPercent\" and does this\nconst wrongPrice = calculateDiscount(100, 20);  // -1900 (oops!)\n\n// With JSDoc types, the IDE would warn Developer B immediately:\n/**\n * @param {number} price - Original price\n * @param {number} discountPercent - Discount as decimal (0.2 = 20%)\n * @returns {number}\n */\nfunction calculateDiscountTyped(price, discountPercent) {\n  return price - (price * discountPercent);\n}"
            },
            {
              "type": "THEORY",
              "title": "What You Get With Types",
              "content": "JSDoc types give you:\n\n1. **Autocomplete**: Your IDE knows what methods are available\n2. **Inline Documentation**: Hover over any function to see what it does\n3. **Error Detection**: Red squiggles appear BEFORE you run the code\n4. **Refactoring Safety**: Rename a property and find all usages instantly\n\nAnd the best part? It's just JavaScript. No build step, no compilation, no new syntax to learn."
            },
            {
              "type": "WARNING",
              "title": "Common Objections (and Why They're Wrong)",
              "content": "1. **\"Types slow me down\"** - Types slow you down for 10 seconds while saving you hours of debugging.\n\n2. **\"JavaScript is supposed to be flexible\"** - Types don't remove flexibility, they document your intentions.\n\n3. **\"I'll just write tests instead\"** - Types catch bugs BEFORE tests run. Use both."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "16.1-challenge",
              "title": "Spot the Type Bug",
              "description": "This code has a type bug. The function expects an array but gets called with a string. Add JSDoc to document what the function expects.",
              "instructions": "Add JSDoc comments to the processItems function to document that it expects an array of strings.",
              "starterCode": "// Add JSDoc here\nfunction processItems(items) {\n  return items.map(item => item.toUpperCase());\n}\n\n// This should show a type error in your IDE\nprocessItems('hello');",
              "solution": "/**\n * @param {string[]} items - Array of strings to process\n * @returns {string[]} Uppercased strings\n */\nfunction processItems(items) {\n  return items.map(item => item.toUpperCase());\n}\n\n// This should show a type error in your IDE\nprocessItems('hello');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Correct usage works",
                  "expectedOutput": "[\"HELLO\",\"WORLD\"]",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use @param {string[]} to indicate an array of strings"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using @param {array} instead of @param {string[]}",
                  "consequence": "Generic 'array' doesn't give you element type safety",
                  "correction": "Use @param {string[]} for arrays of strings, @param {number[]} for arrays of numbers, etc."
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "16.2",
          "title": "JSDoc Basics (@param, @returns, @type)",
          "moduleId": "module-16",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Labels on Shipping Boxes",
              "content": "Every shipping box has labels: 'FRAGILE', 'THIS SIDE UP', 'CONTENTS: Electronics'. Without labels, the delivery person has to guess.\n\nJSDoc tags are your labels. `@param` says 'this box contains a string'. `@returns` says 'you'll get back a number'. Anyone handling your code knows exactly what to expect."
            },
            {
              "type": "EXAMPLE",
              "title": "The Core JSDoc Tags",
              "content": "These three core JSDoc tags cover 90% of your typing needs. Use @param for function parameters, @returns for return types, and @type for variables.",
              "language": "javascript",
              "code": "/**\n * Calculates the total price with tax\n * @param {number} price - The base price\n * @param {number} [taxRate=0.1] - Tax rate (default 10%)\n * @returns {number} The total with tax\n */\nfunction calculateTotal(price, taxRate = 0.1) {\n  return price * (1 + taxRate);\n}\n\n// @type for variables\n/** @type {string[]} */\nconst names = ['Alice', 'Bob', 'Charlie'];\n\n/** @type {{ id: number, name: string }} */\nconst user = { id: 1, name: 'Alice' };\n\n// @type for destructuring\n/** @type {{ port: number, host: string }} */\nconst { port, host } = config;"
            },
            {
              "type": "THEORY",
              "title": "JSDoc Type Syntax",
              "content": "**Primitive types:**\n- `{string}` - text\n- `{number}` - any number\n- `{boolean}` - true/false\n- `{null}` - null value\n- `{undefined}` - undefined value\n\n**Arrays:**\n- `{string[]}` - array of strings\n- `{Array<number>}` - array of numbers (alternative syntax)\n\n**Objects:**\n- `{{ name: string, age: number }}` - inline object type\n- `{Object}` - any object (avoid, too vague)\n\n**Optional parameters:**\n- `{string} [name]` - optional string\n- `{number} [count=0]` - optional with default\n\n**Union types:**\n- `{string|number}` - either string or number\n- `{string|null}` - string or null"
            },
            {
              "type": "WARNING",
              "title": "JSDoc Gotchas",
              "content": "1. **Put JSDoc DIRECTLY above the function** - No blank lines between!\n```javascript\n// WRONG - blank line breaks the connection\n/**\n * My function\n */\n\nfunction myFunc() {}\n\n// RIGHT - no blank line\n/**\n * My function\n */\nfunction myFunc() {}\n```\n\n2. **Use curly braces around types**: It's `@param {string}` not `@param string`\n\n3. **Arrays need element type**: `{string[]}` not just `{array}`"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "16.2-challenge",
              "title": "Document the API Function",
              "description": "Add complete JSDoc documentation to this API function.",
              "instructions": "Add @param and @returns tags to document this function. The id should be a number, and the function returns a Promise that resolves to a user object with id and name properties.",
              "starterCode": "// Add JSDoc here\nasync function getUser(id) {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n}\n\nconst user = await getUser(42);\nconsole.log(user.name);",
              "solution": "/**\n * Fetches a user by their ID\n * @param {number} id - The user's ID\n * @returns {Promise<{ id: number, name: string }>} The user object\n */\nasync function getUser(id) {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n}\n\nconst user = await getUser(42);\nconsole.log(user.name);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Function is documented with JSDoc",
                  "expectedOutput": "Alice",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For async functions, the @returns type should be Promise<...>"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting Promise wrapper on async function returns",
                  "consequence": "The actual return type of async functions is always a Promise",
                  "correction": "@returns {Promise<{ id: number, name: string }>}"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "16.3",
          "title": "Complex Types (@typedef, @template, Unions)",
          "moduleId": "module-16",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Creating Your Own Label Templates",
              "content": "Shipping companies don't write 'Fragile Electronics from China containing 50 smartphones' on every box. They create a template label: 'PRODUCT-TECH-001' that everyone understands.\n\n@typedef lets you create reusable type templates. Define 'User' once, use it everywhere."
            },
            {
              "type": "EXAMPLE",
              "title": "Reusable Types with @typedef",
              "content": "Define complex types once and reuse them throughout your codebase:",
              "language": "javascript",
              "code": "/**\n * @typedef {Object} User\n * @property {number} id - Unique identifier\n * @property {string} name - Display name\n * @property {string} email - Email address\n * @property {'admin'|'user'|'guest'} role - User role\n */\n\n/**\n * @typedef {Object} ApiResponse\n * @property {boolean} success\n * @property {T} [data] - Response data (when success)\n * @property {string} [error] - Error message (when failed)\n * @template T\n */\n\n/**\n * @param {number} id\n * @returns {Promise<ApiResponse<User>>}\n */\nasync function fetchUser(id) {\n  const res = await fetch(`/api/users/${id}`);\n  if (!res.ok) {\n    return { success: false, error: 'User not found' };\n  }\n  return { success: true, data: await res.json() };\n}"
            },
            {
              "type": "THEORY",
              "title": "@template - Generic Types",
              "content": "@template lets you create flexible, reusable types:\n\n```javascript\n/**\n * Wraps any value in an object with metadata\n * @template T\n * @param {T} value - Any value\n * @returns {{ value: T, timestamp: number }}\n */\nfunction wrap(value) {\n  return { value, timestamp: Date.now() };\n}\n\nconst wrapped = wrap('hello');  // { value: string, timestamp: number }\nconst wrappedNum = wrap(42);    // { value: number, timestamp: number }\n```\n\n**Multiple type parameters:**\n```javascript\n/**\n * @template K, V\n * @param {K} key\n * @param {V} value\n * @returns {Map<K, V>}\n */\nfunction createMap(key, value) {\n  return new Map([[key, value]]);\n}\n```"
            },
            {
              "type": "WARNING",
              "title": "When JSDoc Gets Too Complex",
              "content": "If you find yourself writing types like this:\n\n```javascript\n/**\n * @typedef {Object} DeepNestedType\n * @property {{ items: Array<{ id: number, data: { nested: { value: string }[] } }> }} response\n */\n```\n\n**It's time to consider TypeScript.** JSDoc is great for adding types to JavaScript, but deeply nested generic types become unreadable. That's your signal to migrate."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "16.3-challenge",
              "title": "Create a Product Type",
              "description": "Create a @typedef for Product and use it in a function.",
              "instructions": "Create a Product typedef with id (number), name (string), price (number), and inStock (boolean). Then use it to type the getProduct function return value.",
              "starterCode": "// Create @typedef for Product here\n\n/**\n * @param {number} id\n * @returns {???} - Use your Product type here\n */\nfunction getProduct(id) {\n  return {\n    id: id,\n    name: 'Widget',\n    price: 9.99,\n    inStock: true\n  };\n}\n\nconst product = getProduct(1);\nconsole.log(`${product.name}: $${product.price}`);",
              "solution": "/**\n * @typedef {Object} Product\n * @property {number} id\n * @property {string} name\n * @property {number} price\n * @property {boolean} inStock\n */\n\n/**\n * @param {number} id\n * @returns {Product}\n */\nfunction getProduct(id) {\n  return {\n    id: id,\n    name: 'Widget',\n    price: 9.99,\n    inStock: true\n  };\n}\n\nconst product = getProduct(1);\nconsole.log(`${product.name}: $${product.price}`);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Returns properly typed product",
                  "expectedOutput": "Widget: $9.99",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "@typedef {Object} Product starts the type definition, then use @property for each field"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Defining typedef inside function",
                  "consequence": "Typedef should be at module level so it can be reused",
                  "correction": "Put @typedef at the top of your file, before any functions"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "16.4",
          "title": "Type Checking with Bun (// @ts-check)",
          "moduleId": "module-16",
          "order": 4,
          "estimatedMinutes": 20,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Building Inspector",
              "content": "You can draw blueprints all day, but without an inspector, nobody verifies you're following them. `// @ts-check` is your building inspector - it reads your JSDoc blueprints and verifies your code matches."
            },
            {
              "type": "EXAMPLE",
              "title": "Enabling Type Checking",
              "content": "Add `// @ts-check` at the top of any JavaScript file to enable type checking:",
              "language": "javascript",
              "code": "// @ts-check\n\n/**\n * @param {string} name\n * @returns {string}\n */\nfunction greet(name) {\n  return `Hello, ${name}!`;\n}\n\ngreet(42);  // ERROR: Argument of type 'number' is not assignable to parameter of type 'string'\n\n/**\n * @type {number}\n */\nconst count = 'five';  // ERROR: Type 'string' is not assignable to type 'number'"
            },
            {
              "type": "THEORY",
              "title": "Project-Wide Type Checking",
              "content": "For entire projects, create a `jsconfig.json`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"checkJs\": true,\n    \"strict\": true,\n    \"target\": \"ESNext\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"bundler\"\n  },\n  \"include\": [\"src/**/*.js\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n**Key options:**\n- `checkJs: true` - Check all .js files\n- `strict: true` - Enable all strict checks\n- `target/module: ESNext` - Use latest JavaScript features\n\nBun respects `jsconfig.json`, so your IDE and runtime are in sync."
            },
            {
              "type": "KEY_POINT",
              "title": "Ignoring Errors",
              "content": "Sometimes you know better than the type checker:\n\n```javascript\n// @ts-ignore - Ignore the next line only\n// @ts-expect-error - Same, but fails if no error exists (preferred)\n\nconst data = JSON.parse(input);\n// @ts-expect-error - API returns wrong type, we handle it\ndata.items = data.items || [];\n```\n\n**Use sparingly!** Every ignore is technical debt."
            },
            {
              "type": "WARNING",
              "title": "TypeScript 7.0 Changes",
              "content": "**TypeScript 7.0 (December 2025) changes JSDoc handling:**\n\n1. **Stricter checking** - Some relaxed rules in JavaScript have been tightened\n2. **Removed tags** - `@enum` and `@constructor` are no longer recognized\n3. **More errors** - Codebases may see new errors that need fixing\n\n**If upgrading:**\n- Run `tsc --checkJs` to find new errors\n- Update or remove unsupported JSDoc tags\n- Consider migrating complex types to TypeScript"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "16.4-challenge",
              "title": "Fix the Type Errors",
              "description": "Enable type checking and fix the errors in this code.",
              "instructions": "Add // @ts-check, then fix the type errors. The function should accept a number and return a string.",
              "starterCode": "function formatPrice(price) {\n  return '$' + price.toFixed(2);\n}\n\nconst result = formatPrice('19.99');\nconsole.log(result);",
              "solution": "// @ts-check\n\n/**\n * @param {number} price\n * @returns {string}\n */\nfunction formatPrice(price) {\n  return '$' + price.toFixed(2);\n}\n\nconst result = formatPrice(19.99);\nconsole.log(result);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Formats price correctly",
                  "expectedOutput": "$19.99",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "The function expects a number but is being called with a string. Fix the call site."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Converting number to string inside function",
                  "consequence": "The function signature says it takes a number, so callers should pass numbers",
                  "correction": "Change formatPrice('19.99') to formatPrice(19.99)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "16.5",
          "title": "Migration Path to TypeScript",
          "moduleId": "module-16",
          "order": 5,
          "estimatedMinutes": 20,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "Learning to Drive Stick",
              "content": "You learned to drive automatic first. Now you understand how the car works - when to shift, how the engine revs. Learning stick shift is much easier because you already understand the fundamentals.\n\nJSDoc is your automatic transmission. Once you're comfortable with types through JSDoc, TypeScript's syntax is just a different way to write the same things."
            },
            {
              "type": "EXAMPLE",
              "title": "JSDoc to TypeScript - Side by Side",
              "content": "The concepts are identical, only the syntax changes:",
              "language": "typescript",
              "code": "// JSDoc (JavaScript)\n/**\n * @typedef {Object} User\n * @property {number} id\n * @property {string} name\n */\n\n/**\n * @param {User} user\n * @returns {string}\n */\nfunction greet(user) {\n  return `Hello, ${user.name}!`;\n}\n\n// TypeScript\ninterface User {\n  id: number;\n  name: string;\n}\n\nfunction greet(user: User): string {\n  return `Hello, ${user.name}!`;\n}\n\n// Same types, same behavior, different syntax!"
            },
            {
              "type": "THEORY",
              "title": "When to Migrate",
              "content": "**Stay with JSDoc when:**\n- Your project is small (<10 files)\n- You want zero build step\n- Team is new to types\n- You're adding types to legacy code gradually\n\n**Migrate to TypeScript when:**\n- JSDoc comments become too verbose\n- You need advanced features (decorators, enums, namespaces)\n- Team is comfortable with type concepts\n- You're starting a new large project\n\n**The Migration:**\n1. Rename `.js` to `.ts` (Bun handles both!)\n2. Convert JSDoc comments to type annotations\n3. Fix any new errors TypeScript catches\n4. Repeat file by file"
            },
            {
              "type": "KEY_POINT",
              "title": "Bun Makes This Easy",
              "content": "With Bun, there's no compilation step for TypeScript:\n\n```bash\n# JavaScript with JSDoc\nbun run index.js\n\n# TypeScript\nbun run index.ts\n\n# Both work the same way - no tsc, no build!\n```\n\nYou can even mix `.js` and `.ts` files in the same project during migration."
            },
            {
              "type": "WARNING",
              "title": "Migration Pitfalls",
              "content": "**Common mistakes when migrating:**\n\n1. **Converting everything at once** - Migrate file by file, test as you go\n\n2. **Losing type safety during migration**\n```typescript\n// WRONG - 'any' defeats the purpose\nconst user: any = getUser();\n\n// RIGHT - Use unknown or proper types\nconst user: unknown = getUser();\n```\n\n3. **Forgetting to update imports** - TypeScript may need explicit `.js` extensions in ESM\n\n4. **Not testing after each file** - Run `bun test` after converting each file"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "16.5-challenge",
              "title": "Convert JSDoc to TypeScript",
              "description": "Convert this JSDoc-typed JavaScript to TypeScript syntax.",
              "instructions": "Rewrite this code using TypeScript type annotations instead of JSDoc comments. Keep the same logic.",
              "starterCode": "/**\n * @typedef {Object} Product\n * @property {string} name\n * @property {number} price\n */\n\n/**\n * @param {Product[]} products\n * @returns {number}\n */\nfunction totalPrice(products) {\n  return products.reduce((sum, p) => sum + p.price, 0);\n}",
              "solution": "interface Product {\n  name: string;\n  price: number;\n}\n\nfunction totalPrice(products: Product[]): number {\n  return products.reduce((sum, p) => sum + p.price, 0);\n}",
              "language": "typescript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Function works correctly",
                  "expectedOutput": "29.98",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Replace @typedef with 'interface', and put types after colons instead of in JSDoc"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Keeping JSDoc AND TypeScript annotations",
                  "consequence": "Redundant and can cause conflicts",
                  "correction": "Remove JSDoc comments when using TypeScript annotations"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-18",
      "title": "Module 18: ES2025 Modern Patterns",
      "description": "Master the cutting-edge JavaScript features in ES2025. Learn Promise.try(), Import Attributes, RegExp modifiers, and get a preview of upcoming decorators.",
      "difficulty": "intermediate",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "17.1",
          "title": "Modern Promise Patterns (Promise.try & withResolvers)",
          "moduleId": "module-17",
          "order": 1,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Safety Net and The Remote Control",
              "content": "Imagine a circus trapeze act. `Promise.try()` is like having a safety net - whether the acrobat jumps wrong (sync error) or misses the catch mid-air (async error), they land safely in the net.\n\n`Promise.withResolvers()` is like having a remote control for a TV that's across the room. Instead of being stuck next to the TV to change channels (executor callback), you can control it from anywhere (separate resolve/reject functions)."
            },
            {
              "type": "EXAMPLE",
              "title": "Promise.try() - The Universal Error Catcher",
              "content": "Promise.try() wraps any function and catches ALL errors - sync or async:",
              "language": "javascript",
              "code": "// The Problem: Sync errors bypass .catch()\nfunction riskySync(input) {\n  if (!input) throw new Error('Input required!');  // This is sync!\n  return fetch(`/api/${input}`);\n}\n\n// OLD WAY: Errors thrown before the promise is created aren't caught\nriskySync(null).catch(console.error);  // UNCAUGHT! throws before .catch() is set up\n\n// OLD WORKAROUND: Wrap in Promise.resolve().then()\nPromise.resolve().then(() => riskySync(null)).catch(console.error);  // Works but ugly\n\n// NEW WAY: Promise.try() handles everything\nPromise.try(() => riskySync(null)).catch(console.error);  // 'Input required!' - caught!\n\n// Works with any return value:\nPromise.try(() => 42).then(console.log);                    // 42\nPromise.try(() => fetch('/api')).then(r => console.log(r)); // Response\nPromise.try(() => { throw 'oops'; }).catch(console.log);    // 'oops'"
            },
            {
              "type": "EXAMPLE",
              "title": "Promise.withResolvers() - External Control",
              "content": "Promise.withResolvers() lets you get resolve and reject functions outside the executor callback, enabling cleaner deferred patterns.",
              "language": "javascript",
              "code": "// OLD WAY: Hoisting variables out of executor\nlet resolveFromOutside, rejectFromOutside;\nconst promise = new Promise((resolve, reject) => {\n  resolveFromOutside = resolve;\n  rejectFromOutside = reject;\n});\nresolveFromOutside('done');  // Awkward!\n\n// NEW WAY: Promise.withResolvers()\nconst { promise: p, resolve, reject } = Promise.withResolvers();\n\n// Now you can pass resolve/reject anywhere\nsetTimeout(() => resolve('done'), 1000);\n\n// Real-world example: Deferred pattern\nfunction createDeferred() {\n  return Promise.withResolvers();\n}\n\nconst deferred = createDeferred();\neventEmitter.once('complete', deferred.resolve);\neventEmitter.once('error', deferred.reject);\nawait deferred.promise;"
            },
            {
              "type": "THEORY",
              "title": "When to Use Each",
              "content": "**Use Promise.try() when:**\n- Calling functions that might throw synchronously\n- Normalizing sync/async function returns\n- Building robust error handling chains\n\n**Use Promise.withResolvers() when:**\n- Building event-to-promise adapters\n- Creating deferred/lazy promises\n- Passing resolve/reject to callbacks or other functions\n- Implementing timeout patterns"
            },
            {
              "type": "WARNING",
              "title": "Don't Overuse",
              "content": "1. **Don't wrap async functions in Promise.try()** - They already return promises!\n```javascript\nasync function safe() { /* ... */ }\n\n// WRONG: Unnecessary wrapping\nPromise.try(() => safe());\n\n// RIGHT: Just call it\nsafe();\n```\n\n2. **Don't use withResolvers() for simple cases** - The executor pattern is fine for simple promises."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "17.1-challenge",
              "title": "Build a Timeout Wrapper",
              "description": "Use Promise.withResolvers() to create a timeout wrapper.",
              "instructions": "Create a function that takes a promise and a timeout. If the promise doesn't resolve within the timeout, reject with 'Timeout'.",
              "starterCode": "function withTimeout(promise, ms) {\n  // Use Promise.withResolvers() here\n  // Set up a timeout that rejects\n  // Race between the timeout and the original promise\n}\n\n// Test it:\nconst slow = new Promise(r => setTimeout(() => r('done'), 5000));\nwithTimeout(slow, 1000).catch(console.log);  // Should log 'Timeout'",
              "solution": "function withTimeout(promise, ms) {\n  const { promise: timeoutPromise, reject } = Promise.withResolvers();\n  \n  const timer = setTimeout(() => reject(new Error('Timeout')), ms);\n  \n  return Promise.race([promise, timeoutPromise])\n    .finally(() => clearTimeout(timer));\n}\n\nconst slow = new Promise(r => setTimeout(() => r('done'), 5000));\nwithTimeout(slow, 1000).catch(err => console.log(err.message));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Times out slow promises",
                  "expectedOutput": "Timeout",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use Promise.race() to race between the original promise and your timeout promise"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not cleaning up the timeout on success",
                  "consequence": "Memory leak if many timeouts are created",
                  "correction": "Use .finally(() => clearTimeout(timer)) to clean up"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "17.2",
          "title": "Import Attributes Deep Dive",
          "moduleId": "module-17",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Import Security Guard",
              "content": "Airport security X-rays your luggage. They're not just checking the label - they verify the contents match what you declared.\n\nImport Attributes are JavaScript's security checkpoint. When you write `with { type: 'json' }`, you're declaring 'this file contains ONLY data, no code.' The runtime verifies this and blocks any attempts to sneak executable code through a JSON import."
            },
            {
              "type": "EXAMPLE",
              "title": "All Import Attribute Syntaxes",
              "content": "Master every way to use import attributes:",
              "language": "javascript",
              "code": "// Static imports - most common\nimport config from './config.json' with { type: 'json' };\nimport styles from './app.css' with { type: 'css' };\n\n// Dynamic imports - note the different structure\nconst data = await import('./data.json', {\n  with: { type: 'json' }\n});\n\n// Re-exports with attributes\nexport { default as config } from './config.json' with { type: 'json' };\n\n// Namespace imports\nimport * as pkg from './package.json' with { type: 'json' };\nconsole.log(pkg.default.name);\n\n// Multiple attributes (future-proofing)\nimport schema from './schema.json' with {\n  type: 'json',\n  integrity: 'sha384-abc...'\n};"
            },
            {
              "type": "THEORY",
              "title": "Why Not Just Parse JSON Manually?",
              "content": "You might wonder: why not just use `JSON.parse(Bun.file('./config.json').text())`?\n\n**Import attributes offer:**\n\n1. **Static analysis**: Bundlers know what you're importing at build time\n2. **Caching**: Imported JSON is cached like any other module\n3. **Security**: Prevents code injection through JSON files\n4. **Portability**: Same syntax works in Bun, Node, Deno, browsers\n\n**Without import attributes:**\n```javascript\n// Node 18: This could execute code if evil.json contains a \".default\" export!\nimport data from './evil.json';  // DANGEROUS in some runtimes\n```\n\n**With import attributes:**\n```javascript\n// All runtimes: Guaranteed to be pure JSON, no code execution\nimport data from './evil.json' with { type: 'json' };\n```"
            },
            {
              "type": "WARNING",
              "title": "Runtime Support",
              "content": "Import attributes are ES2025 but runtime support varies:\n\n| Runtime | JSON | CSS | Other |\n|---------|------|-----|-------|\n| Bun 1.0+ | Full | Full | - |\n| Node 22+ | Full | - | - |\n| Deno 1.37+ | Full | - | - |\n| Chrome 123+ | Full | Full | - |\n\nFor older runtimes, you may need to fall back to:\n```javascript\n// Fallback for older Node.js\nimport { readFileSync } from 'fs';\nconst config = JSON.parse(readFileSync('./config.json', 'utf-8'));\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "17.2-challenge",
              "title": "Dynamic Config Loading",
              "description": "Load config dynamically based on environment.",
              "instructions": "Create a loadConfig function that dynamically imports a JSON config file based on the environment (development or production). Use import attributes.",
              "starterCode": "async function loadConfig(env) {\n  // Dynamically import config based on env\n  // Use import attributes!\n}\n\nconst config = await loadConfig('development');\nconsole.log(config.apiUrl);",
              "solution": "async function loadConfig(env) {\n  const configPath = env === 'production'\n    ? './config.prod.json'\n    : './config.dev.json';\n  \n  const module = await import(configPath, {\n    with: { type: 'json' }\n  });\n  \n  return module.default;\n}\n\nconst config = await loadConfig('development');\nconsole.log(config.apiUrl);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Loads correct config",
                  "expectedOutput": "http://localhost:3000",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Dynamic import returns a module object - the JSON data is in .default"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting .default on dynamic JSON imports",
                  "consequence": "You get the module wrapper, not the JSON data",
                  "correction": "const data = (await import('./file.json', { with: { type: 'json' } })).default;"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "17.3",
          "title": "Top-Level Await in Practice",
          "moduleId": "module-17",
          "order": 3,
          "estimatedMinutes": 20,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Restaurant Before Opening",
              "content": "Before a restaurant opens, the chef needs ingredients. The waiters need menus. The host needs the reservation book. Everyone waits until everything is ready - THEN the doors open.\n\nTop-level await is your pre-opening checklist. Load config, connect to database, verify dependencies - all before your app starts accepting requests."
            },
            {
              "type": "EXAMPLE",
              "title": "Modern Server Initialization",
              "content": "Top-level await makes initialization clean and readable:",
              "language": "javascript",
              "code": "// server.js - Bun + Hono\nimport { Hono } from 'hono';\n\n// Top-level await: Load everything before starting\nconst config = await Bun.file('config.json').json();\nconst secrets = await loadSecrets(config.vaultUrl);\nconst db = await connectDatabase(secrets.databaseUrl);\n\nconsole.log(`Environment: ${config.env}`);\nconsole.log(`Database connected: ${db.isConnected}`);\n\nconst app = new Hono();\n\napp.get('/health', (c) => c.json({ status: 'ok', db: db.isConnected }));\n\napp.get('/users', async (c) => {\n  const users = await db.query('SELECT * FROM users');\n  return c.json(users);\n});\n\n// Export for Bun to serve\nexport default {\n  port: config.port,\n  fetch: app.fetch,\n};"
            },
            {
              "type": "THEORY",
              "title": "How Top-Level Await Works",
              "content": "**The module loading story:**\n\n1. Your module starts executing\n2. Hits a top-level `await`\n3. Module loading PAUSES (but doesn't block the event loop)\n4. Other modules can still load in parallel\n5. Once await resolves, your module continues\n6. When all awaits complete, module is 'ready'\n7. Modules that import yours wait until you're ready\n\n**This means:**\n- Circular dependencies with top-level await can deadlock\n- Import order matters more\n- Errors in top-level await crash module loading\n\n**Best practice:** Keep top-level await for true initialization, not ongoing work."
            },
            {
              "type": "WARNING",
              "title": "Anti-Patterns",
              "content": "**DON'T: Lazy-load at top level**\n```javascript\n// BAD: This delays every import of your module\nconst rarelyUsedLib = await import('heavy-library');\n```\n\n**DO: Lazy-load inside functions**\n```javascript\n// GOOD: Only load when needed\nasync function useRareFeature() {\n  const lib = await import('heavy-library');\n  return lib.doThing();\n}\n```\n\n**DON'T: Top-level await in loops**\n```javascript\n// BAD: Sequential loading, very slow\nfor (const url of urls) {\n  const data = await fetch(url);  // One at a time!\n}\n```\n\n**DO: Parallelize**\n```javascript\n// GOOD: All at once\nconst results = await Promise.all(urls.map(fetch));\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "17.3-challenge",
              "title": "App Initialization",
              "description": "Create a proper app initialization sequence.",
              "instructions": "Use top-level await to load config, validate it, and initialize the app. Log 'App ready' when done.",
              "starterCode": "// Load config.json with import attributes\n// Validate that config has required fields: port, env\n// Log the environment\n// Log 'App ready'\n\nconsole.log('Starting...');",
              "solution": "import config from './config.json' with { type: 'json' };\n\nconsole.log('Starting...');\n\n// Validate config\nif (!config.port || !config.env) {\n  throw new Error('Missing required config fields');\n}\n\nconsole.log(`Environment: ${config.env}`);\nconsole.log('App ready');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Initializes correctly",
                  "expectedOutput": "Starting...\\nEnvironment: development\\nApp ready",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use import with type: 'json' for the config file"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not validating config before using it",
                  "consequence": "Cryptic errors later when fields are undefined",
                  "correction": "Always validate required config fields at startup"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "17.4",
          "title": "ES2025 RegExp Modifiers",
          "moduleId": "module-17",
          "order": 4,
          "estimatedMinutes": 20,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Search Filter Toggle",
              "content": "Imagine a search bar with filter toggles: 'Case Sensitive', 'Whole Words', etc. You can turn them on globally, but what if you want case-insensitive for just part of your search?\n\nRegExp modifiers are like inline filter toggles. You can turn flags on or off for just a portion of your pattern."
            },
            {
              "type": "EXAMPLE",
              "title": "Inline Flag Modifiers",
              "content": "ES2025 adds the ability to enable or disable flags within a pattern:",
              "language": "javascript",
              "code": "// Enable case-insensitive for part of the pattern\nconst re1 = /hello(?i:world)/;\nre1.test('helloWorld');  // true - 'world' is case-insensitive\nre1.test('Helloworld');  // false - 'hello' is still case-sensitive\n\n// Disable a flag for part of the pattern\nconst re2 = /(?-i:strict)(?i:flexible)/i;  // Global 'i' flag\nre2.test('STRICTflexible');  // false - 'strict' must match exactly\nre2.test('strictFLEXIBLE');  // true\n\n// Multiple flags at once\nconst re3 = /(?ims:pattern)/;  // Enable i, m, s for this group\n\n// Real-world: Case-insensitive keywords, case-sensitive values\nconst configLine = /(?i:setting)=(.+)/;\nconfigLine.exec('SETTING=MyValue');  // ['SETTING=MyValue', 'MyValue']"
            },
            {
              "type": "THEORY",
              "title": "Available Modifiers",
              "content": "**Modifiable flags:**\n- `i` - case-insensitive\n- `m` - multiline (^ and $ match line starts/ends)\n- `s` - dotAll (. matches newlines)\n\n**Syntax:**\n- `(?i:...)` - Enable flag i for this group\n- `(?-i:...)` - Disable flag i for this group\n- `(?i-s:...)` - Enable i, disable s\n- `(?:...)` - Non-capturing group (unchanged)\n\n**Why this matters:**\nPreviously, flags were all-or-nothing. Now you can have fine-grained control:\n\n```javascript\n// Match 'http' or 'HTTPS' but capture exact case of domain\nconst url = /(?i:https?):\\/\\/([a-z0-9.]+)/;\nurl.exec('HTTP://Example.COM');  // ['HTTP://Example.COM', 'example.com'] - domain lowercased\n```"
            },
            {
              "type": "WARNING",
              "title": "Compatibility Note",
              "content": "RegExp modifiers are ES2025 but may not be available in all environments yet:\n\n| Runtime | Support |\n|---------|--------|\n| Bun 1.1+ | Yes |\n| Node 23+ | Yes |\n| Chrome 125+ | Yes |\n| Firefox | Not yet |\n\nFor maximum compatibility, consider using separate regex patterns or libraries like `re2` for complex cases."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "17.4-challenge",
              "title": "Parse Config Lines",
              "description": "Create a regex that matches config keys case-insensitively but preserves value case.",
              "instructions": "Write a regex that matches 'PORT=3000' where 'PORT' is case-insensitive but the value after = is captured exactly.",
              "starterCode": "// Create regex with inline modifiers\nconst configRegex = // your regex here\n\nconst match = configRegex.exec('port=MyValue');\nconsole.log(match[1]);  // Should print 'MyValue' (exact case)",
              "solution": "const configRegex = /(?i:port)=(.+)/;\n\nconst match = configRegex.exec('port=MyValue');\nconsole.log(match[1]);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Captures value with exact case",
                  "expectedOutput": "MyValue",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use (?i:...) to make only the key part case-insensitive"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using global 'i' flag",
                  "consequence": "Makes the entire pattern case-insensitive, including capture groups",
                  "correction": "Use inline (?i:...) only around the parts you want case-insensitive"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "17.5",
          "title": "Decorators Preview (Stage 3)",
          "moduleId": "module-17",
          "order": 5,
          "estimatedMinutes": 25,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Gift Wrapper",
              "content": "When you gift-wrap a present, you don't change what's inside - you enhance its presentation. You might add a bow, a card, or ribbons.\n\nDecorators wrap your code. They don't change what your function/class does, but they can add logging, validation, caching, or access control around it."
            },
            {
              "type": "EXAMPLE",
              "title": "Decorator Syntax",
              "content": "Decorators use the @ symbol and can wrap classes, methods, and fields:",
              "language": "javascript",
              "code": "// Method decorator - add logging\nfunction logged(target, context) {\n  return function (...args) {\n    console.log(`Calling ${context.name} with`, args);\n    const result = target.apply(this, args);\n    console.log(`${context.name} returned`, result);\n    return result;\n  };\n}\n\nclass Calculator {\n  @logged\n  add(a, b) {\n    return a + b;\n  }\n}\n\nconst calc = new Calculator();\ncalc.add(2, 3);\n// Logs: Calling add with [2, 3]\n// Logs: add returned 5"
            },
            {
              "type": "EXAMPLE",
              "title": "Practical Decorators",
              "content": "Common real-world decorator patterns:",
              "language": "javascript",
              "code": "// Rate limiting decorator\nfunction rateLimit(callsPerSecond) {\n  let lastCall = 0;\n  return function(target, context) {\n    return function(...args) {\n      const now = Date.now();\n      const minInterval = 1000 / callsPerSecond;\n      if (now - lastCall < minInterval) {\n        throw new Error('Rate limit exceeded');\n      }\n      lastCall = now;\n      return target.apply(this, args);\n    };\n  };\n}\n\nclass ApiClient {\n  @rateLimit(10)  // Max 10 calls per second\n  async fetchData(id) {\n    return await fetch(`/api/${id}`);\n  }\n}\n\n// Validation decorator\nfunction validate(schema) {\n  return function(target, context) {\n    return function(...args) {\n      for (let i = 0; i < args.length; i++) {\n        if (!schema[i](args[i])) {\n          throw new TypeError(`Invalid argument at position ${i}`);\n        }\n      }\n      return target.apply(this, args);\n    };\n  };\n}\n\nclass UserService {\n  @validate([x => typeof x === 'number', x => typeof x === 'string'])\n  createUser(id, name) {\n    return { id, name };\n  }\n}"
            },
            {
              "type": "THEORY",
              "title": "Decorator Kinds",
              "content": "The Stage 3 decorators proposal supports:\n\n| Kind | Target | Example Use |\n|------|--------|-------------|\n| Class | `class Foo {}` | Singleton, frozen, service registration |\n| Method | `method() {}` | Logging, timing, validation |\n| Getter/Setter | `get foo() {}` | Lazy loading, caching |\n| Field | `x = 1;` | Observable, computed |\n| Accessor | `accessor x = 1;` | Reactive fields |\n\n**The `context` object includes:**\n- `kind`: 'class', 'method', 'getter', 'setter', 'field', 'accessor'\n- `name`: The member name\n- `access`: { get, set } for fields/accessors\n- `isStatic`: boolean\n- `isPrivate`: boolean\n- `addInitializer`: Add initialization code"
            },
            {
              "type": "WARNING",
              "title": "Stage 3 = Not Yet Standard",
              "content": "Decorators are Stage 3 in TC39, meaning:\n\n- Syntax is stable but not yet ES standard\n- Bun and TypeScript support them with configuration\n- May change before final standardization\n\n**To use in Bun today:**\n```bash\n# No config needed! Bun supports decorators out of the box\nbun run decorated.ts\n```\n\n**To use in TypeScript:**\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true\n  }\n}\n```\n\nNote: TypeScript decorators use an older spec. Stage 3 decorators have slightly different semantics."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "17.5-challenge",
              "title": "Create a Timing Decorator",
              "description": "Create a decorator that logs how long a method takes.",
              "instructions": "Create a @timed decorator that logs 'methodName took Xms' after each call.",
              "starterCode": "function timed(target, context) {\n  // Your decorator implementation\n}\n\nclass DataProcessor {\n  @timed\n  processData(data) {\n    // Simulate work\n    let sum = 0;\n    for (let i = 0; i < 1000000; i++) sum += i;\n    return sum;\n  }\n}\n\nconst processor = new DataProcessor();\nprocessor.processData([1, 2, 3]);",
              "solution": "function timed(target, context) {\n  return function(...args) {\n    const start = performance.now();\n    const result = target.apply(this, args);\n    const end = performance.now();\n    console.log(`${context.name} took ${(end - start).toFixed(2)}ms`);\n    return result;\n  };\n}\n\nclass DataProcessor {\n  @timed\n  processData(data) {\n    let sum = 0;\n    for (let i = 0; i < 1000000; i++) sum += i;\n    return sum;\n  }\n}\n\nconst processor = new DataProcessor();\nprocessor.processData([1, 2, 3]);",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Logs timing information",
                  "expectedOutput": "processData took",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use performance.now() before and after calling the original function"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to return the wrapped function",
                  "consequence": "Decorator doesn't work, original function is replaced with undefined",
                  "correction": "Always return a function from your decorator"
                }
              ],
              "difficulty": "advanced"
            }
          ]
        }
      ]
    },
    {
      "id": "module-19",
      "title": "Module 19: Advanced Bun Features",
      "description": "Unlock Bun's full potential with built-in SQLite, secure password hashing, shell scripting, bundling for production, and calling native code.",
      "difficulty": "advanced",
      "estimatedHours": 3,
      "lessons": [
        {
          "id": "18.1",
          "title": "Built-in SQLite with bun:sqlite",
          "moduleId": "module-18",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Swiss Army Knife Database",
              "content": "Most runtimes make you install database drivers, ORMs, and connection libraries. It's like needing 5 different tools to open a can.\n\nBun comes with SQLite built-in. It's like a Swiss Army knife - the database is right there, ready to use, no installation required."
            },
            {
              "type": "EXAMPLE",
              "title": "Zero-Dependency Database",
              "content": "Create a fully functional database with zero npm packages:",
              "language": "javascript",
              "code": "import { Database } from 'bun:sqlite';\n\n// Create or open a database file\nconst db = new Database('app.db');\n\n// Create tables\ndb.run(`\n  CREATE TABLE IF NOT EXISTS users (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    name TEXT NOT NULL,\n    email TEXT UNIQUE,\n    created_at TEXT DEFAULT CURRENT_TIMESTAMP\n  )\n`);\n\n// Insert data (prepared statement for safety)\nconst insert = db.prepare(\n  'INSERT INTO users (name, email) VALUES ($name, $email)'\n);\n\ninsert.run({ $name: 'Alice', $email: 'alice@example.com' });\ninsert.run({ $name: 'Bob', $email: 'bob@example.com' });\n\n// Query data\nconst users = db.query('SELECT * FROM users').all();\nconsole.log(users);\n// [\n//   { id: 1, name: 'Alice', email: 'alice@example.com', created_at: '...' },\n//   { id: 2, name: 'Bob', email: 'bob@example.com', created_at: '...' }\n// ]"
            },
            {
              "type": "THEORY",
              "title": "Query Methods",
              "content": "**Prepared Statements (always use for user input!):**\n```javascript\nconst stmt = db.prepare('SELECT * FROM users WHERE id = ?');\nstmt.get(1);  // Single row or undefined\nstmt.all();   // All rows as array\nstmt.run();   // For INSERT/UPDATE/DELETE, returns changes info\n```\n\n**Direct Queries (for trusted SQL only):**\n```javascript\ndb.query('SELECT COUNT(*) as count FROM users').get();  // { count: 42 }\ndb.run('DELETE FROM logs WHERE age > 30');  // Execute without results\n```\n\n**Transactions:**\n```javascript\nconst transaction = db.transaction((users) => {\n  for (const user of users) {\n    insert.run(user);\n  }\n});\n\n// Runs all inserts atomically\ntransaction([{ $name: 'Carol', $email: 'carol@example.com' }]);\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "In-Memory Databases",
              "content": "For testing or ephemeral data, use an in-memory database:\n\n```javascript\n// ':memory:' creates a database that exists only in RAM\nconst testDb = new Database(':memory:');\n\n// Perfect for tests - fast and isolated\ntestDb.run('CREATE TABLE temp (id INTEGER)');\ntestDb.run('INSERT INTO temp VALUES (1)');\n\n// Database is automatically deleted when the process ends\n```"
            },
            {
              "type": "WARNING",
              "title": "Security Reminders",
              "content": "1. **Always use prepared statements for user input**\n```javascript\n// WRONG - SQL injection vulnerability!\ndb.run(`DELETE FROM users WHERE id = ${userId}`);\n\n// RIGHT - Safe parameterized query\ndb.prepare('DELETE FROM users WHERE id = ?').run(userId);\n```\n\n2. **Close connections when done**\n```javascript\ndb.close();\n```\n\n3. **Use WAL mode for concurrent access**\n```javascript\ndb.run('PRAGMA journal_mode = WAL');\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "18.1-challenge",
              "title": "Build a Todo API",
              "description": "Create a simple todo storage using bun:sqlite.",
              "instructions": "Create a todos table with id, title, and completed. Write functions to add a todo and list all todos.",
              "starterCode": "import { Database } from 'bun:sqlite';\n\nconst db = new Database(':memory:');\n\n// Create todos table\n\n// Function to add a todo\nfunction addTodo(title) {\n  // Your code here\n}\n\n// Function to get all todos\nfunction getTodos() {\n  // Your code here\n}\n\n// Test it\naddTodo('Learn Bun');\naddTodo('Build an app');\nconsole.log(getTodos());",
              "solution": "import { Database } from 'bun:sqlite';\n\nconst db = new Database(':memory:');\n\ndb.run(`\n  CREATE TABLE todos (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    title TEXT NOT NULL,\n    completed INTEGER DEFAULT 0\n  )\n`);\n\nconst insertStmt = db.prepare('INSERT INTO todos (title) VALUES (?)');\n\nfunction addTodo(title) {\n  insertStmt.run(title);\n}\n\nfunction getTodos() {\n  return db.query('SELECT * FROM todos').all();\n}\n\naddTodo('Learn Bun');\naddTodo('Build an app');\nconsole.log(getTodos());",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Creates and retrieves todos",
                  "expectedOutput": "[{\"id\":1,\"title\":\"Learn Bun\",\"completed\":0},{\"id\":2,\"title\":\"Build an app\",\"completed\":0}]",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use db.query(...).all() to get all rows as an array"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using db.run() for SELECT queries",
                  "consequence": "run() is for INSERT/UPDATE/DELETE and doesn't return rows",
                  "correction": "Use db.query(...).all() or db.prepare(...).all() for SELECT"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "18.2",
          "title": "Secure Password Hashing with Bun.password",
          "moduleId": "module-18",
          "order": 2,
          "estimatedMinutes": 20,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Fingerprint Scanner",
              "content": "A fingerprint scanner doesn't store your actual fingerprint - it stores a mathematical representation that can verify you later. If someone steals the database, they can't recreate your fingerprint.\n\nPassword hashing works the same way. Bun.password stores a hash, not the password itself. Even if attackers get the hash, they can't reverse it to get the original password."
            },
            {
              "type": "EXAMPLE",
              "title": "Hash and Verify Passwords",
              "content": "Bun.password provides secure bcrypt/argon2 hashing with zero dependencies:",
              "language": "javascript",
              "code": "// Hash a password (use when user signs up)\nconst hash = await Bun.password.hash('mySecretPassword');\n// '$argon2id$v=19$m=65536,t=2,p=1$...' - secure hash\n\n// Store 'hash' in your database, never the plain password!\n\n// Verify a password (use when user logs in)\nconst isValid = await Bun.password.verify('mySecretPassword', hash);\nconsole.log(isValid);  // true\n\nconst isWrong = await Bun.password.verify('wrongPassword', hash);\nconsole.log(isWrong);  // false\n\n// Complete signup/login example\nasync function signup(email, password) {\n  const hash = await Bun.password.hash(password);\n  db.prepare('INSERT INTO users (email, password_hash) VALUES (?, ?)')\n    .run(email, hash);\n}\n\nasync function login(email, password) {\n  const user = db.prepare('SELECT * FROM users WHERE email = ?').get(email);\n  if (!user) return null;\n  \n  const valid = await Bun.password.verify(password, user.password_hash);\n  return valid ? user : null;\n}"
            },
            {
              "type": "THEORY",
              "title": "Algorithm Options",
              "content": "Bun supports multiple algorithms:\n\n```javascript\n// Argon2id (default, recommended)\nawait Bun.password.hash(password, { algorithm: 'argon2id' });\n\n// Argon2d (faster, less memory-hard)\nawait Bun.password.hash(password, { algorithm: 'argon2d' });\n\n// Bcrypt (widely compatible)\nawait Bun.password.hash(password, { algorithm: 'bcrypt', cost: 12 });\n```\n\n**Which to choose:**\n- **argon2id**: Best security, recommended for new projects\n- **bcrypt**: Use if you need compatibility with existing systems"
            },
            {
              "type": "WARNING",
              "title": "Security Best Practices",
              "content": "1. **Never store plain passwords** - Always hash before storing\n\n2. **Never log passwords** - Even during debugging\n```javascript\n// WRONG\nconsole.log('User password:', password);\n\n// RIGHT\nconsole.log('Login attempt for:', email);\n```\n\n3. **Use HTTPS** - Passwords should only travel encrypted\n\n4. **Add rate limiting** - Prevent brute force attacks\n```javascript\nconst attempts = new Map();\nif (attempts.get(email) > 5) {\n  throw new Error('Too many attempts');\n}\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "18.2-challenge",
              "title": "User Authentication",
              "description": "Build a simple auth system with signup and login.",
              "instructions": "Create signup and login functions using Bun.password. The signup should hash the password, and login should verify it.",
              "starterCode": "const users = new Map();\n\nasync function signup(username, password) {\n  // Hash password and store in users Map\n}\n\nasync function login(username, password) {\n  // Verify password and return true/false\n}\n\n// Test\nawait signup('alice', 'secret123');\nconsole.log(await login('alice', 'secret123'));  // true\nconsole.log(await login('alice', 'wrong'));      // false",
              "solution": "const users = new Map();\n\nasync function signup(username, password) {\n  const hash = await Bun.password.hash(password);\n  users.set(username, hash);\n}\n\nasync function login(username, password) {\n  const hash = users.get(username);\n  if (!hash) return false;\n  return await Bun.password.verify(password, hash);\n}\n\nawait signup('alice', 'secret123');\nconsole.log(await login('alice', 'secret123'));\nconsole.log(await login('alice', 'wrong'));",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Authenticates correctly",
                  "expectedOutput": "true\\nfalse",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use Bun.password.hash() for signup and Bun.password.verify() for login"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Comparing hashes directly",
                  "consequence": "Hashes include random salt, so same password produces different hashes",
                  "correction": "Always use Bun.password.verify() to compare"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "18.3",
          "title": "Shell Scripting with Bun Shell",
          "moduleId": "module-18",
          "order": 3,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "JavaScript Meets Bash",
              "content": "You know how template literals let you embed expressions in strings? Bun Shell does the same thing for shell commands. It's like having bash superpowers inside your JavaScript.\n\nInstead of spawning processes and parsing stdout, you write shell commands as naturally as template strings."
            },
            {
              "type": "EXAMPLE",
              "title": "The $ Tagged Template",
              "content": "Run shell commands with the $ tag:",
              "language": "javascript",
              "code": "import { $ } from 'bun';\n\n// Simple commands\nawait $`echo 'Hello from Bun Shell!'`;\n\n// Variable interpolation (safely escaped!)\nconst name = 'my-project';\nawait $`mkdir -p ${name}/src`;\n\n// Capture output\nconst result = await $`ls -la`.text();\nconsole.log(result);\n\n// Get as JSON (if command outputs JSON)\nconst pkg = await $`cat package.json`.json();\nconsole.log(pkg.name);\n\n// Pipe commands\nawait $`cat file.txt | grep 'pattern' | wc -l`;\n\n// Environment variables\nawait $`NODE_ENV=production bun run build`;"
            },
            {
              "type": "THEORY",
              "title": "Output Handling",
              "content": "**Get output in different formats:**\n```javascript\nconst cmd = $`echo 'hello'`;\n\nawait cmd.text();    // 'hello\\n'\nawait cmd.json();    // Parse as JSON\nawait cmd.blob();    // As Blob\nawait cmd.lines();   // ['hello']\nawait cmd.bytes();   // Uint8Array\n```\n\n**Check exit code:**\n```javascript\nconst result = await $`exit 1`.nothrow();\nconsole.log(result.exitCode);  // 1\n```\n\n**Quiet mode (suppress output):**\n```javascript\nawait $`npm install`.quiet();\n```"
            },
            {
              "type": "WARNING",
              "title": "Security & Escaping",
              "content": "Bun Shell automatically escapes interpolated values:\n\n```javascript\nconst userInput = 'file; rm -rf /';\nawait $`cat ${userInput}`;  // Safe! Escapes the semicolon\n```\n\n**But be careful with:**\n```javascript\n// DANGEROUS - raw() bypasses escaping\nawait $`${$.raw(untrustedInput)}`;  // Never do this!\n\n// SAFE - let Bun escape it\nawait $`${untrustedInput}`;  // Bun escapes automatically\n```\n\n**Additional security notes:**\n- Strings starting with `-` may be interpreted as flags - validate input\n- Keep Bun updated to get security patches\n- Never pass untrusted input directly to shell commands without validation"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "18.3-challenge",
              "title": "Build Script",
              "description": "Create a build script using Bun Shell.",
              "instructions": "Write a script that creates a dist folder, copies files, and shows the result.",
              "starterCode": "import { $ } from 'bun';\n\n// 1. Create dist directory\n// 2. Copy all .js files to dist\n// 3. List the dist contents\n// 4. Print 'Build complete!'",
              "solution": "import { $ } from 'bun';\n\nawait $`mkdir -p dist`;\nawait $`cp *.js dist/ 2>/dev/null || true`;\nconst files = await $`ls dist`.text();\nconsole.log('Files in dist:', files);\nconsole.log('Build complete!');",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Runs build script",
                  "expectedOutput": "Build complete!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use await $`command` for each shell operation"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to await shell commands",
                  "consequence": "Commands run in parallel, causing race conditions",
                  "correction": "Always await each $`...` call"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "18.4",
          "title": "Bundling for Production with Bun.build()",
          "moduleId": "module-18",
          "order": 4,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Shipping Container",
              "content": "When shipping goods overseas, you don't send each item separately. You pack everything into containers that are optimized for transport.\n\nBun.build() is your shipping container for JavaScript. It takes all your files, dependencies, and assets, then packs them into optimized bundles ready for production."
            },
            {
              "type": "EXAMPLE",
              "title": "Basic Bundling",
              "content": "Bundle your app with one function call:",
              "language": "javascript",
              "code": "const result = await Bun.build({\n  entrypoints: ['./src/index.ts'],\n  outdir: './dist',\n  minify: true,\n  sourcemap: 'external',\n  target: 'browser',  // or 'bun', 'node'\n});\n\nif (!result.success) {\n  console.error('Build failed:', result.logs);\n  process.exit(1);\n}\n\nconsole.log('Build complete!');\nconsole.log('Output files:', result.outputs.map(o => o.path));\n\n// For multiple entry points (e.g., multi-page app)\nawait Bun.build({\n  entrypoints: [\n    './src/home.ts',\n    './src/about.ts',\n    './src/contact.ts',\n  ],\n  outdir: './dist',\n  splitting: true,  // Enable code splitting\n});"
            },
            {
              "type": "THEORY",
              "title": "Build Options",
              "content": "**Common options:**\n```javascript\nawait Bun.build({\n  entrypoints: ['./src/index.ts'],\n  outdir: './dist',\n  \n  // Optimization\n  minify: true,           // Minify output\n  sourcemap: 'external',  // 'none' | 'inline' | 'external'\n  \n  // Target environment\n  target: 'browser',      // 'bun' | 'node' | 'browser'\n  \n  // Code splitting (for multiple entry points)\n  splitting: true,\n  \n  // Naming\n  naming: '[dir]/[name]-[hash].[ext]',\n  \n  // External packages (don't bundle these)\n  external: ['react', 'react-dom'],\n  \n  // Define globals\n  define: {\n    'process.env.NODE_ENV': '\"production\"',\n  },\n});\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "Build for Different Targets",
              "content": "**Browser:**\n```javascript\nawait Bun.build({\n  target: 'browser',\n  // Bundles everything, polyfills Node APIs\n});\n```\n\n**Node.js:**\n```javascript\nawait Bun.build({\n  target: 'node',\n  // Keeps require(), doesn't bundle node_modules\n});\n```\n\n**Bun:**\n```javascript\nawait Bun.build({\n  target: 'bun',\n  // Optimized for Bun runtime\n});\n```"
            },
            {
              "type": "WARNING",
              "title": "Common Bundling Mistakes",
              "content": "**1. Not checking build success:**\n```javascript\n// WRONG - Ignoring errors\nawait Bun.build({ entrypoints: ['./index.ts'] });\n\n// RIGHT - Handle failures\nconst result = await Bun.build({ entrypoints: ['./index.ts'] });\nif (!result.success) {\n  console.error(result.logs);\n  process.exit(1);\n}\n```\n\n**2. Wrong target for your environment:**\n- Browser code with `target: 'node'` won't work in browsers\n- Server code with `target: 'browser'` may include unnecessary polyfills\n\n**3. Forgetting to externalize large dependencies:**\n```javascript\n// For libraries, don't bundle peer dependencies\nexternal: ['react', 'react-dom']\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "18.4-challenge",
              "title": "Production Build Script",
              "description": "Create a production build configuration.",
              "instructions": "Write a build script that minifies code, generates sourcemaps, and reports the output file sizes.",
              "starterCode": "// build.ts\nasync function build() {\n  const result = await Bun.build({\n    // Your configuration here\n  });\n  \n  // Report results\n}\n\nbuild();",
              "solution": "async function build() {\n  const result = await Bun.build({\n    entrypoints: ['./src/index.ts'],\n    outdir: './dist',\n    minify: true,\n    sourcemap: 'external',\n    target: 'browser',\n  });\n  \n  if (!result.success) {\n    console.error('Build failed!');\n    for (const log of result.logs) {\n      console.error(log);\n    }\n    process.exit(1);\n  }\n  \n  console.log('Build successful!');\n  for (const output of result.outputs) {\n    const size = (output.size / 1024).toFixed(2);\n    console.log(`  ${output.path}: ${size} KB`);\n  }\n}\n\nbuild();",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Builds successfully",
                  "expectedOutput": "Build successful!",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Check result.success and iterate over result.outputs for file info"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not checking result.success",
                  "consequence": "Build errors go unnoticed, broken code gets deployed",
                  "correction": "Always check result.success and handle result.logs"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "18.5",
          "title": "Calling Native Code with FFI",
          "moduleId": "module-18",
          "order": 5,
          "estimatedMinutes": 30,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Universal Translator",
              "content": "Imagine you're at a UN meeting where everyone speaks different languages. A translator lets you communicate with anyone, regardless of their native language.\n\nFFI (Foreign Function Interface) is Bun's translator. It lets your JavaScript talk directly to code written in C, Rust, Zig, or any language that compiles to native code."
            },
            {
              "type": "EXAMPLE",
              "title": "Calling C Functions",
              "content": "Load and call functions from shared libraries:",
              "language": "javascript",
              "code": "import { dlopen, FFIType, suffix } from 'bun:ffi';\n\n// Load a system library (libc)\nconst lib = dlopen(`libc.${suffix}`, {\n  // Define the function signature\n  strlen: {\n    args: [FFIType.cstring],  // Takes a C string\n    returns: FFIType.i32,      // Returns int32\n  },\n  getpid: {\n    args: [],\n    returns: FFIType.i32,\n  },\n});\n\n// Call the functions\nconst length = lib.symbols.strlen('Hello, Bun!');\nconsole.log('String length:', length);  // 11\n\nconst pid = lib.symbols.getpid();\nconsole.log('Process ID:', pid);\n\n// Don't forget to close when done\nlib.close();"
            },
            {
              "type": "THEORY",
              "title": "FFI Types",
              "content": "**Available types:**\n```javascript\nimport { FFIType } from 'bun:ffi';\n\n// Integers\nFFIType.i8   // int8_t\nFFIType.u8   // uint8_t\nFFIType.i16  // int16_t\nFFIType.u16  // uint16_t\nFFIType.i32  // int32_t  (int)\nFFIType.u32  // uint32_t\nFFIType.i64  // int64_t  (long long)\nFFIType.u64  // uint64_t\n\n// Floats\nFFIType.f32  // float\nFFIType.f64  // double\n\n// Pointers\nFFIType.ptr     // void*\nFFIType.cstring // char* (null-terminated)\n\n// Special\nFFIType.void    // void (for returns only)\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Custom Native Libraries",
              "content": "Call your own Rust/C code:",
              "language": "javascript",
              "code": "// Assume you compiled a Rust library: libmath.dylib\n// #[no_mangle]\n// pub extern \"C\" fn add(a: i32, b: i32) -> i32 { a + b }\n\nimport { dlopen, FFIType, suffix } from 'bun:ffi';\n\nconst mathLib = dlopen(`./libmath.${suffix}`, {\n  add: {\n    args: [FFIType.i32, FFIType.i32],\n    returns: FFIType.i32,\n  },\n  multiply: {\n    args: [FFIType.f64, FFIType.f64],\n    returns: FFIType.f64,\n  },\n});\n\nconsole.log(mathLib.symbols.add(5, 3));       // 8\nconsole.log(mathLib.symbols.multiply(2.5, 4)); // 10.0"
            },
            {
              "type": "WARNING",
              "title": "FFI Risks",
              "content": "**FFI is powerful but dangerous:**\n\n1. **Memory safety is your responsibility**\n   - Native code can crash your entire process\n   - No garbage collection for native memory\n\n2. **Type mismatches cause undefined behavior**\n```javascript\n// WRONG - passing string where int expected\nlib.symbols.add('5', 3);  // Crash or garbage!\n```\n\n3. **Always close libraries**\n```javascript\nlib.close();  // Free resources\n```\n\n**When to use FFI:**\n- Performance-critical code (image processing, crypto)\n- Interfacing with system libraries\n- Reusing existing native code\n\n**When NOT to use FFI:**\n- Simple operations (JavaScript is fast enough)\n- When a npm package already wraps the native code"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "18.5-challenge",
              "title": "System Info via FFI",
              "description": "Use FFI to get system information.",
              "instructions": "Use FFI to call getpid() from libc and print the process ID.",
              "starterCode": "import { dlopen, FFIType, suffix } from 'bun:ffi';\n\n// Load libc and call getpid()\n// Print: 'Process ID: <pid>'",
              "solution": "import { dlopen, FFIType, suffix } from 'bun:ffi';\n\nconst libc = dlopen(`libc.${suffix}`, {\n  getpid: {\n    args: [],\n    returns: FFIType.i32,\n  },\n});\n\nconst pid = libc.symbols.getpid();\nconsole.log(`Process ID: ${pid}`);\n\nlibc.close();",
              "language": "javascript",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Gets process ID",
                  "expectedOutput": "Process ID:",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "getpid() takes no arguments and returns an i32"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Wrong library suffix on different OS",
                  "consequence": "Library fails to load on macOS/Linux/Windows",
                  "correction": "Use suffix from bun:ffi - it's 'dylib' on macOS, 'so' on Linux, 'dll' on Windows"
                }
              ],
              "difficulty": "advanced"
            }
          ]
        }
      ]
    }
  ]
}