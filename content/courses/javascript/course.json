{
  "id": "javascript-typescript",
  "language": "javascript",
  "title": "JavaScript & TypeScript Full-Stack Development",
  "description": "Master JavaScript and TypeScript from fundamentals to advanced concepts, including modern ES6+ features, async programming, and full-stack development.",
  "difficulty": "beginner",
  "estimatedHours": 22,
  "prerequisites": [],
  "modules": [
    {
      "id": "module-01",
      "title": "Module 1: The Absolute Basics (The 'What')",
      "description": "Understanding what programming is and writing your first lines of code",
      "difficulty": "beginner",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-01-1-1",
          "title": "What Is Programming? (The Recipe Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# What Is Programming? (The Recipe Analogy)\n\n## Understanding the Concept\n\nImagine you're teaching a very literal robot to make a peanut butter and jelly sandwich. You can't just say 'make a sandwich' - the robot doesn't know what that means!\n\nYou have to break it down into tiny, specific steps: 'Pick up the knife. Dip the knife into the peanut butter jar. Spread the peanut butter on one slice of bread.' That's exactly what programming is.\n\nProgramming is writing a list of very specific instructions that a computer can follow. The computer is like that literal robot - it will do exactly what you tell it to do, but nothing more. It can't guess what you mean, and it can't read your mind. You have to be crystal clear.\n\nThe 'language' we use to give these instructions is called a programming language. Today, we're learning JavaScript, which is like giving instructions to a web browser.\n\n## Code Example\n\n```javascript\n// This is a comment - the computer ignores this line.\n// Comments are notes we leave for ourselves.\n\n// This is an instruction to the computer:\nconsole.log('Hello, World!');\n\n// The computer will display the text 'Hello, World!' on the screen.\n```\n\n## Breaking Down the Syntax\n\nLet's break down that code line by line:\n\n1. Lines starting with // are comments. They're ignored by the computer. Think of them as sticky notes you leave for yourself (or other programmers) to explain what the code does.\n\n2. console.log('Hello, World!'); - This is an instruction (we'll call it a 'statement' later). Let's unpack it:\n   - console is like a special message board built into your web browser\n   - log means 'write a message'\n   - The text inside the parentheses and quotes ('Hello, World!') is the message we want to write\n   - The semicolon ; at the end is like a period at the end of a sentence - it tells the computer 'this instruction is complete'\n\nSo the whole thing means: 'Computer, write the message Hello, World! to the console.'\n\n## Common Mistakes & Tips\n\nCommon mistakes beginners make:\n\n1. Forgetting the quotes: console.log(Alice); won't work because the computer thinks Alice is a variable (a 'box' we'll learn about soon), not text.\n\n2. Forgetting the semicolon: While JavaScript is forgiving about this, it's good practice to always end statements with ;\n\n3. Misspelling console or log: Programming is case-sensitive! Console.log or console.Log won't work.\n\n4. Missing parentheses: console.log 'Alice'; won't work. The parentheses are how we 'pass' the message to the log function."
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Now it's your turn! Your challenge: Write code that displays your own name to the console. Replace 'Your Name Here' with your actual name (keep the quotes!).",
              "starterCode": "// Replace 'Your Name Here' with your name\nconsole.log('Your Name Here');",
              "solution": "console.log('Alice');  // Replace Alice with your actual name",
              "hints": [
                "Make sure to keep the quotes around your name, and don't forget the semicolon at the end!"
              ],
              "testCases": [
                {
                  "description": "Code runs without errors",
                  "input": "",
                  "expectedOutput": ""
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-01-1-2",
          "title": "Your First Workspace (The Browser Console)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Your First Workspace (The Browser Console)\n\n## Understanding the Concept\n\nThink of the browser console as your workshop - it's where you'll build and test your code. Just like a carpenter has a workbench where they can quickly test if a joint fits or a piece is the right size, the browser console is where you can quickly try out JavaScript code and see the results immediately.\n\nThe console is a special tool built into every modern web browser. It's hidden by default, but once you open it, you can type JavaScript code directly and the browser will run it instantly. It's like having a conversation with the browser - you give it instructions (in JavaScript), and it responds.\n\n## Code Example\n\n```javascript\n// You can do math in the console!\nconsole.log(5 + 3);\n\n// You can write multiple messages\nconsole.log('First message');\nconsole.log('Second message');\nconsole.log('Third message');\n\n// You can even do math inside the message\nconsole.log('The answer is: ' + (10 * 2));\n```\n\n## Breaking Down the Syntax\n\nLet's look at what's happening:\n\n1. console.log(5 + 3); - The computer will actually do the math (5 + 3 = 8) and then display '8'. The computer evaluates (figures out) what's inside the parentheses first, then displays the result.\n\n2. Multiple console.log statements run in order, from top to bottom. The computer executes them one at a time, like following a recipe step by step.\n\n3. The + symbol does two things in JavaScript:\n   - When used with numbers, it adds them: 5 + 3 = 8\n   - When used with text (in quotes), it joins them together: 'Hello' + ' ' + 'World' becomes 'Hello World'\n\n4. Notice the parentheses around (10 * 2) in the last example? That tells the computer 'do this math first, then join it with the text.'\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Putting quotes around the numbers: console.log('100 - 45'); will display the text '100 - 45' instead of doing the math. Remove the quotes to make the computer calculate it.\n\n2. Forgetting the console.log part: Just writing 100 - 45; won't display anything. You need console.log() to actually show the result.\n\n3. Wrong symbols: Make sure you use * for multiplication (not x), and - for subtraction (not a dash that might look similar)."
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a mini calculator! Write code that:\n1. Displays the result of 15 + 27\n2. Displays the result of 100 - 45\n3. Displays the result of 6 * 7 (the * symbol means multiply)",
              "starterCode": "// Calculate and display 15 + 27\nconsole.log(15 + 27);\n\n// Calculate and display 100 - 45\n// YOUR CODE HERE\n\n// Calculate and display 6 * 7\n// YOUR CODE HERE",
              "solution": "console.log(15 + 27);\nconsole.log(100 - 45);\nconsole.log(6 * 7);",
              "hints": [
                "Follow the same pattern as the first line: console.log(), put the math inside the parentheses, and end with a semicolon."
              ],
              "testCases": [
                {
                  "description": "Displays 42 (the result of 15 + 27)",
                  "input": "",
                  "expectedOutput": "42"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-01-1-3",
          "title": "Leaving Notes for Yourself (Comments)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Leaving Notes for Yourself (Comments)\n\n## Understanding the Concept\n\nImagine you're cooking a complex recipe, and you write little notes in the margins: 'This takes 20 minutes' or 'Make sure the oven is preheated!' Those notes aren't part of the recipe itself - they're reminders to yourself.\n\nComments in code work the same way. They're notes you leave for yourself (or other programmers) that the computer completely ignores. The computer will skip right over them like they don't exist.\n\nWhy are comments important? Because code that makes perfect sense today might be confusing in a month. Comments explain WHY you wrote the code a certain way, not just WHAT the code does.\n\n## Code Example\n\n```javascript\n// This is a single-line comment\n// The computer ignores everything after the //\n\nconsole.log('This runs!');  // You can also put comments at the end of a line\n\n// console.log('This does NOT run because it is commented out');\n\n/*\n  This is a multi-line comment.\n  Everything between the /* and */ is ignored.\n  This is useful for longer explanations.\n*/\n\nconsole.log('This also runs!');\n\n/* You can also use multi-line comments\n   to temporarily 'turn off' code:\n   console.log('This is turned off');\n   console.log('So is this');\n*/\n```\n\n## Breaking Down the Syntax\n\nTwo types of comments:\n\n1. Single-line comments: //\n   - Everything after // on that line is ignored\n   - Great for short notes\n   - Example: // This calculates the total price\n\n2. Multi-line comments: /* */\n   - Everything between /* and */ is ignored, even across multiple lines\n   - Great for longer explanations or temporarily disabling multiple lines of code\n   - Example:\n     /*\n       This function is complex, so here's how it works:\n       First, it checks if the user is logged in...\n     */\n\nPro tip: Use comments to explain WHY, not WHAT. The code itself shows WHAT it does. Comments should explain WHY you made that choice.\n\nGood comment: // Using 30-day trial period instead of 7-day based on user feedback\nBad comment: // This sets the trial period to 30\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Forgetting the space after //: While //comment works, // comment is more readable.\n\n2. Trying to nest multi-line comments: /* /* nested */ */ doesn't work. Once the computer sees */, it thinks the comment is over.\n\n3. Not closing a multi-line comment: If you forget the */, everything after /* will be treated as a comment, and your code won't run!\n\n4. Over-commenting: Don't comment every single line. Comment the WHY and the complex parts, not the obvious stuff."
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Practice using comments! Add a single-line comment above the console.log explaining what the code does. Then, comment out the second console.log (so it doesn't run) using //.",
              "starterCode": "console.log('I am learning JavaScript!');\n\nconsole.log('Comment me out!');",
              "solution": "// This displays a message about learning JavaScript\nconsole.log('I am learning JavaScript!');\n\n// console.log('Comment me out!');",
              "hints": [
                "Put // at the beginning of the line you want to comment out."
              ],
              "testCases": [
                {
                  "description": "Only the first message is displayed",
                  "input": "",
                  "expectedOutput": "I am learning JavaScript!"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "module-02",
      "title": "Module 2: Storing & Using Information (The 'Boxes')",
      "description": "Learn how to store and label information for later use",
      "difficulty": "beginner",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-02-2-1",
          "title": "Variables: Your Labeled Storage Boxes (let and const)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Variables: Your Labeled Storage Boxes (let and const)\n\n## Understanding the Concept\n\nImagine you have a storage room with many boxes. Each box can hold one thing, and you put a label on each box so you remember what's inside.\n\n'Age: 25' - A box labeled 'Age' that contains the number 25\n'Name: Alice' - A box labeled 'Name' that contains the text 'Alice'\n'Is Student: true' - A box labeled 'Is Student' that contains the answer 'yes' (true)\n\nIn programming, these labeled boxes are called VARIABLES. A variable is just a named container that holds a piece of information. You create a variable, give it a name (the label), and store something in it (the contents).\n\nWhy are variables useful? Because you can create a box once and then use what's inside it many times throughout your code. If you need to change what's in the box, you change it in ONE place, and everywhere that uses that box automatically gets the new value.\n\n## Code Example\n\n```javascript\n// Creating a variable with 'let'\n// 'let' means 'create a new box'\nlet age = 25;\nlet name = 'Alice';\nlet isStudent = true;\n\n// Now we can use these boxes!\nconsole.log(name);  // Displays: Alice\nconsole.log(age);   // Displays: 25\n\n// We can change what's inside a 'let' box\nage = 26;  // It's Alice's birthday!\nconsole.log(age);  // Displays: 26\n\n// Creating a variable with 'const'\n// 'const' means 'constant' - a box whose contents CANNOT change\nconst birthYear = 1998;\nconsole.log(birthYear);  // Displays: 1998\n\n// This would cause an ERROR:\n// birthYear = 1999;  // Can't change a const!\n```\n\n## Breaking Down the Syntax\n\nLet's break down the anatomy of creating a variable:\n\nlet age = 25;\n│   │   │ │\n│   │   │ └─ The value (what goes IN the box)\n│   │   └─── The equals sign (means 'store this value')\n│   └─────── The variable name (the label on the box)\n└─────────── The keyword 'let' (tells the computer to create a box)\n\nThink of it as: let [label] = [contents];\n\nTwo keywords for creating variables:\n\n1. let - Use this when the value might change later\n   - Example: let score = 0; (score will increase during a game)\n   \n2. const - Use this when the value will NEVER change\n   - Example: const PI = 3.14159; (pi is always pi)\n   - If you try to change a const, you'll get an error\n\nVariable naming rules:\n- Must start with a letter, $, or _\n- Can contain letters, numbers, $, or _ (but not spaces!)\n- Cannot be a reserved word (like 'let', 'const', 'if', etc.)\n- Case sensitive: 'age' and 'Age' are different variables\n\nNaming conventions (not required, but everyone does it):\n- Use camelCase: firstName, not firstname or first_name\n- Use descriptive names: userAge, not x or ua\n- Start with lowercase: age, not Age (unless it's a special case we'll learn later)\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Forgetting 'let' or 'const': Writing just age = 25; instead of let age = 25; In strict mode, this causes an error.\n\n2. Using 'let' or 'const' when USING a variable: You only use 'let' or 'const' when CREATING the variable. After that, just use the name:\n   Correct: let age = 25; age = 26;\n   Wrong: let age = 25; let age = 26; (Can't create the same box twice!)\n\n3. Trying to change a 'const': Remember, const means 'constant'. Once set, it cannot be changed.\n\n4. Misspelling variable names: If you create 'userName' but later try to use 'username', JavaScript will say 'username is not defined' because it's looking for a box with that exact label.\n\n5. Not using quotes for text: let name = Alice; won't work. Text must be in quotes: let name = 'Alice';"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create three variables:\n1. A 'const' variable called 'city' that stores your favorite city name (as text in quotes)\n2. A 'let' variable called 'temperature' that stores the number 72\n3. Use console.log to display both variables",
              "starterCode": "// Create your variables here\n\n// Display them here",
              "solution": "const city = 'New York';\nlet temperature = 72;\n\nconsole.log(city);\nconsole.log(temperature);",
              "hints": [
                "Remember: const city = 'some city'; and let temperature = 72; Then use console.log for each."
              ],
              "testCases": [
                {
                  "description": "Code creates variables and displays them",
                  "input": "",
                  "expectedOutput": ""
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-02-2-2",
          "title": "Types of Information: Strings, Numbers, and Booleans",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Types of Information: Strings, Numbers, and Booleans\n\n## Understanding the Concept\n\nJust like in real life, we store different TYPES of things in different ways:\n\n- Words and sentences: We write them down as text (String)\n- Counting and measuring: We use numbers (Number)\n- Yes/No questions: We use true or false (Boolean)\n\nJavaScript has different 'types' of data for the same reason. Each type works differently and has different things you can do with it.\n\nThink of it like different types of storage containers:\n- A filing cabinet is for documents (text/strings)\n- A scale is for numbers (you can add, subtract, compare)\n- A light switch is for true/false (on or off, yes or no)\n\nYou wouldn't try to do math with words, and you wouldn't try to write a letter with numbers. JavaScript keeps track of what TYPE each variable is so it knows how to work with it.\n\n## Code Example\n\n```javascript\n// STRINGS (text) - always in quotes\nlet firstName = 'Alice';\nlet lastName = \"Smith\";  // Single or double quotes both work\nlet greeting = 'Hello, World!';\n\n// You can join strings together with +\nlet fullName = firstName + ' ' + lastName;\nconsole.log(fullName);  // Displays: Alice Smith\n\n// NUMBERS - no quotes!\nlet age = 25;\nlet price = 19.99;  // Decimals are fine\nlet temperature = -5;  // Negative numbers too\n\n// You can do math with numbers\nlet total = price + 10;\nconsole.log(total);  // Displays: 29.99\n\n// BOOLEANS (true or false) - no quotes!\nlet isStudent = true;\nlet hasGraduated = false;\nlet isRaining = true;\n\nconsole.log(isStudent);  // Displays: true\n\n// A common mistake: don't put quotes around booleans!\nlet wrong = 'true';  // This is a STRING containing the word 'true'\nlet right = true;    // This is a BOOLEAN with the value true\n```\n\n## Breaking Down the Syntax\n\nThe three basic data types:\n\n1. STRING - Text\n   - Always enclosed in quotes (single ' or double \")\n   - Can be empty: let empty = '';\n   - Can contain numbers as text: let code = '12345';\n   - Use + to join strings: 'Hello' + ' ' + 'World' = 'Hello World'\n\n2. NUMBER - Numeric values\n   - NO quotes\n   - Can be positive, negative, or decimal\n   - Can do math: +, -, *, / (division), % (remainder)\n   - Special values: Infinity, -Infinity, NaN (Not a Number)\n\n3. BOOLEAN - True or False\n   - Only two possible values: true or false\n   - NO quotes (quotes would make it a string)\n   - Used for yes/no, on/off, exists/doesn't exist\n   - We'll use these a lot when making decisions (if statements)\n\nHow to remember:\n- If it's text, it needs quotes → String\n- If it's a number for math, no quotes → Number\n- If it's true or false, no quotes → Boolean\n\nThe + operator:\n- With numbers: 5 + 3 = 8 (addition)\n- With strings: 'Hello' + 'World' = 'HelloWorld' (joining)\n- Mixed: 'Age: ' + 25 = 'Age: 25' (converts number to string and joins)\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Quotes around numbers: let age = '25'; makes age a STRING, not a NUMBER. You can't do math with it: '25' + 5 = '255' (string joining, not 30).\n\n2. Quotes around booleans: let isStudent = 'true'; makes it a STRING containing the word 'true', not the boolean value true.\n\n3. Forgetting quotes around text: let name = Alice; won't work. JavaScript thinks Alice is a variable, not text. Use let name = 'Alice';\n\n4. Mixing up + for numbers vs strings:\n   - 5 + 5 = 10 (math)\n   - '5' + '5' = '55' (joining strings)\n   - '5' + 5 = '55' (JavaScript converts the number to a string)\n\n5. Case matters: true and false must be lowercase. True or FALSE won't work."
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a mini profile:\n1. Create a const 'userName' with your name (string)\n2. Create a let 'userAge' with your age (number)\n3. Create a const 'isLearning' set to true (boolean)\n4. Display a message: 'Name: [name], Age: [age], Learning: [boolean]' by joining strings and variables",
              "starterCode": "// Create your variables\n\n// Create a message by joining strings with +\n// Example: 'Name: ' + userName + ', Age: ' + userAge ...\nlet message = // YOUR CODE HERE\n\nconsole.log(message);",
              "solution": "const userName = 'Alice';\nlet userAge = 25;\nconst isLearning = true;\n\nlet message = 'Name: ' + userName + ', Age: ' + userAge + ', Learning: ' + isLearning;\n\nconsole.log(message);",
              "hints": [
                "Use + to join strings and variables: 'Name: ' + userName + ', Age: ' + userAge + ', Learning: ' + isLearning"
              ],
              "testCases": [
                {
                  "description": "Displays a formatted profile message",
                  "input": "",
                  "expectedOutput": ""
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "module-03",
      "title": "Module 3: Making Decisions (The 'Forks in the Road')",
      "description": "Teach your program to make choices based on conditions",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-03-3-1",
          "title": "Teaching Your Code to Choose (if Statements)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Teaching Your Code to Choose (if Statements)\n\n## Understanding the Concept\n\nImagine you're a traffic cop at an intersection. When you see a red light, you tell cars to STOP. When you see a green light, you tell them to GO. You're making a decision based on a condition (the light color).\n\nThat's exactly what an 'if' statement does in code. It checks a condition (is something true or false?), and based on the answer, it decides what action to take.\n\nThink of it like a flowchart with a diamond-shaped decision box: 'Is it raining?' If YES, take umbrella. If NO, leave it home. In code, we call these YES/NO questions 'conditions', and they always evaluate to either true or false (remember booleans from Module 2?).\n\n## Code Example\n\n```javascript\nlet temperature = 75;\n\n// The 'if' statement: \"IF this condition is true, THEN do this\"\nif (temperature > 70) {\n  console.log('It is warm outside!');\n}\n\nconsole.log('This line runs no matter what');\n\n// Another example\nlet isRaining = true;\n\nif (isRaining) {\n  console.log('Take an umbrella');\n}\n\n// You can check if something is false\nlet hasKeys = false;\n\nif (!hasKeys) {  // The ! means \"NOT\"\n  console.log('Go back and get your keys!');\n}\n```\n\n## Breaking Down the Syntax\n\nLet's break down an if statement:\n\nif (condition) {\n│  │          │ │\n│  │          │ └─ The code to run (the 'action')\n│  │          └─── Closing parenthesis\n│  └─────────────── The condition (must be true/false)\n└────────────────── The 'if' keyword\n\nKey points:\n\n1. if - This keyword says \"I'm about to check a condition\"\n\n2. (condition) - This must be something that evaluates to true or false\n   - temperature > 70 → either true or false\n   - isRaining → already a boolean (true or false)\n   - !hasKeys → the ! flips the boolean (false becomes true)\n\n3. { } - Curly braces contain the code that runs IF the condition is true\n   - If the condition is false, everything inside { } is skipped\n   - You can have multiple lines of code inside { }\n\n4. Code outside the if statement runs no matter what\n\nThe ! operator (NOT):\n- !true → false\n- !false → true\n- It flips/inverts the boolean value\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Forgetting parentheses around the condition: if age >= 18 won't work. Must be if (age >= 18)\n\n2. Using = instead of ==  or ===:\n   - if (age = 18) is WRONG - this assigns 18 to age!\n   - if (age === 18) is CORRECT - this checks if age equals 18\n\n3. Forgetting curly braces: While technically optional for single-line if statements, always use { } to avoid bugs later.\n\n4. Putting a semicolon after the condition: if (age >= 18); is wrong. The semicolon ends the if statement before it does anything!\n\n5. Trying to use 'AND' or 'OR' in English: if (age > 17 and age < 65) won't work. JavaScript uses && for 'and' and || for 'or' (we'll learn these soon)."
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a simple age checker:\n1. Create a variable 'age' and set it to any number\n2. Write an if statement that displays 'You can vote!' if age is 18 or greater\n3. Test it with different ages (try 17, then try 18)",
              "starterCode": "// Create your age variable\nlet age = 17;\n\n// Write your if statement here\n",
              "solution": "let age = 18;\n\nif (age >= 18) {\n  console.log('You can vote!');\n}",
              "hints": [
                "Use the >= operator (greater than or equal to). Format: if (age >= 18) { console.log('You can vote!'); }"
              ],
              "testCases": [
                {
                  "description": "Works for age 18 or above",
                  "input": "let age = 18; if (age >= 18) { console.log('You can vote!'); }",
                  "expectedOutput": "You can vote!"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-03-3-2",
          "title": "Multiple Paths (else if and else)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Multiple Paths (else if and else)\n\n## Understanding the Concept\n\nImagine you're getting dressed based on the weather. Here's your thought process:\n\n'IF it's snowing → wear a heavy coat'\n'ELSE IF it's raining → wear a raincoat'\n'ELSE IF it's cold → wear a jacket'\n'ELSE → wear a t-shirt' (default for all other cases)\n\nYou're checking multiple conditions in order, and taking the FIRST one that's true. Once you've made a decision, you don't check the rest - you're already dressed!\n\nThis is exactly how else if and else work in programming. You can have multiple 'forks in the road', and your code will take the first path where the condition is true.\n\n## Code Example\n\n```javascript\nlet temperature = 45;\n\n// Multiple conditions with if...else if...else\nif (temperature > 80) {\n  console.log('It is hot! Wear shorts.');\n} else if (temperature > 60) {\n  console.log('It is nice! Wear a t-shirt.');\n} else if (temperature > 40) {\n  console.log('It is cold! Wear a jacket.');\n} else {\n  console.log('It is freezing! Wear a heavy coat.');\n}\n\n// Another example: letter grades\nlet score = 85;\n\nif (score >= 90) {\n  console.log('Grade: A');\n} else if (score >= 80) {\n  console.log('Grade: B');\n} else if (score >= 70) {\n  console.log('Grade: C');\n} else if (score >= 60) {\n  console.log('Grade: D');\n} else {\n  console.log('Grade: F');\n}\n```\n\n## Breaking Down the Syntax\n\nThe structure:\n\nif (first condition) {\n  // Runs if first condition is true\n} else if (second condition) {\n  // Runs if first is false BUT second is true  \n} else if (third condition) {\n  // Runs if first and second are false BUT third is true\n} else {\n  // Runs if ALL above conditions are false (the 'default')\n}\n\nImportant rules:\n\n1. You MUST start with 'if' - you can't have 'else if' or 'else' without an 'if' first\n\n2. You can have as many 'else if' blocks as you want (0, 1, 5, 100...)\n\n3. The 'else' block is optional - it's the \"catch-all\" for when nothing else is true\n\n4. ONLY ONE block of code will run - the first one with a true condition\n   - If the first 'if' is true, the rest are skipped completely\n   - If the first 'if' is false, check the first 'else if'\n   - And so on...\n\n5. Order matters! In the grade example:\n   - We check >= 90 first\n   - Then >= 80 (which also includes 90-100, but we already handled those)\n   - If we checked >= 60 first, everyone would get a 'D' because 90 >= 60 is true!\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Wrong order of conditions:\n   if (score >= 60) { ... } else if (score >= 90) { ... }\n   This is wrong! If score is 95, the first condition (>= 60) is true, so it stops there. Always check from most specific to least specific.\n\n2. Using separate if statements instead of else if:\n   if (temp > 80) { ... }\n   if (temp > 60) { ... }  // WRONG - both could run!\n   Instead use: else if (temp > 60) { ... }\n\n3. Forgetting the 'else' keyword: writing if (cond1) { } if (cond2) { } won't work as intended.\n\n4. Putting code between the blocks:\n   if (x > 5) { }\n   console.log('hello');  // This runs no matter what!\n   else { }  // ERROR - can't have code between if and else"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a movie rating advisor:\n1. Create a variable 'age' with a number\n2. If age is under 13: display 'You can watch G and PG movies'\n3. Else if age is under 17: display 'You can watch G, PG, and PG-13 movies'\n4. Else: display 'You can watch all movies including R-rated'",
              "starterCode": "let age = 15;\n\n// Write your if...else if...else statement here\n",
              "solution": "let age = 15;\n\nif (age < 13) {\n  console.log('You can watch G and PG movies');\n} else if (age < 17) {\n  console.log('You can watch G, PG, and PG-13 movies');\n} else {\n  console.log('You can watch all movies including R-rated');\n}",
              "hints": [
                "Use if (age < 13), then else if (age < 17), then else for the rest."
              ],
              "testCases": [
                {
                  "description": "Correctly handles age 15",
                  "input": "let age = 15; if (age < 13) { console.log('You can watch G and PG movies'); } else if (age < 17) { console.log('You can watch G, PG, and PG-13 movies'); } else { console.log('You can watch all movies including R-rated'); }",
                  "expectedOutput": "You can watch G, PG, and PG-13 movies"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-03-3-3",
          "title": "Comparison Operators (How to Compare Things)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Comparison Operators (How to Compare Things)\n\n## Understanding the Concept\n\nWhen you're shopping, you constantly compare things:\n\n'Is this apple bigger than that one?' (>)\n'Is this shirt the same price as that one?' (===)\n'Is this milk carton NOT expired?' (not equal to today's date)\n\nIn programming, we have special symbols for making these comparisons. They're called 'comparison operators', and they always give you a true/false answer - perfect for use in if statements!\n\nThink of them as questions you can ask:\n- '>' means 'Is this bigger?'\n- '<' means 'Is this smaller?'\n- '===' means 'Are these exactly the same?'\n- '!==' means 'Are these different?'\n\n## Code Example\n\n```javascript\n// Greater than (>)\nlet age = 25;\nif (age > 18) {\n  console.log('You are an adult');  // true, runs\n}\n\n// Less than (<)\nlet temperature = 32;\nif (temperature < 40) {\n  console.log('It is very cold');  // true, runs\n}\n\n// Greater than or equal to (>=)\nlet score = 60;\nif (score >= 60) {\n  console.log('You passed!');  // true, runs (60 equals 60)\n}\n\n// Less than or equal to (<=)\nlet speed = 55;\nif (speed <= 55) {\n  console.log('You are within the speed limit');  // true, runs\n}\n\n// Equal to (===)\nlet userAnswer = 'Paris';\nif (userAnswer === 'Paris') {\n  console.log('Correct!');  // true, runs\n}\n\n// Not equal to (!==)\nlet status = 'pending';\nif (status !== 'complete') {\n  console.log('Still waiting...');  // true, runs\n}\n\n// You can also store comparison results in variables!\nlet isAdult = age >= 18;  // isAdult now holds true or false\nconsole.log(isAdult);  // Displays: true\n```\n\n## Breaking Down the Syntax\n\nThe six comparison operators:\n\n1. >   Greater than\n   - 5 > 3 → true\n   - 3 > 5 → false\n   - 5 > 5 → false (not greater, they're equal)\n\n2. <   Less than\n   - 3 < 5 → true\n   - 5 < 3 → false\n   - 5 < 5 → false\n\n3. >=  Greater than OR equal to\n   - 5 >= 5 → true (the equal part makes it true)\n   - 6 >= 5 → true\n   - 4 >= 5 → false\n\n4. <=  Less than OR equal to\n   - 5 <= 5 → true\n   - 4 <= 5 → true\n   - 6 <= 5 → false\n\n5. === Exactly equal to (strict equality)\n   - 5 === 5 → true\n   - 5 === '5' → false (number vs string)\n   - 'cat' === 'cat' → true\n   - 'Cat' === 'cat' → false (case matters!)\n\n6. !== Not equal to (strict inequality)\n   - 5 !== 3 → true (they are different)\n   - 5 !== 5 → false (they are the same)\n\nAll comparison operators return a boolean (true or false). You can use them:\n- Directly in if statements: if (age > 18)\n- Store in variables: let canVote = age >= 18;\n- Display them: console.log(5 > 3);  // Shows: true\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Using = instead of ===:\n   if (age = 18)  // WRONG - this assigns 18 to age!\n   if (age === 18)  // CORRECT - this compares\n\n2. Using == instead of ===:\n   JavaScript has == (loose equality) and === (strict equality)\n   - 5 == '5' → true (converts types, then compares)\n   - 5 === '5' → false (different types)\n   ALWAYS use === and !== to avoid surprises\n\n3. Comparing strings with > or <:\n   'apple' < 'banana' → true (alphabetical order works!)\n   But '10' < '2' → true (compares as strings, not numbers)\n   To compare string numbers, convert first: Number('10') < Number('2') → false\n\n4. Case sensitivity:\n   'Hello' === 'hello' → false\n   To ignore case: 'Hello'.toLowerCase() === 'hello'.toLowerCase()\n\n5. Confusing >= and =>:\n   >= is greater-than-or-equal (comparison)\n   => is for arrow functions (we'll learn later)"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a simple login validator:\n1. Create two variables: 'password' (a string) and 'confirmPassword' (another string)\n2. If they are equal (===), display 'Passwords match!'\n3. If they are not equal (!==), display 'Passwords do not match'",
              "starterCode": "let password = 'secret123';\nlet confirmPassword = 'secret123';\n\n// Write your if...else statement here\n",
              "solution": "let password = 'secret123';\nlet confirmPassword = 'secret123';\n\nif (password === confirmPassword) {\n  console.log('Passwords match!');\n} else {\n  console.log('Passwords do not match');\n}",
              "hints": [
                "Use === to check if they're equal: if (password === confirmPassword)"
              ],
              "testCases": [
                {
                  "description": "Detects matching passwords",
                  "input": "let password = 'abc'; let confirmPassword = 'abc'; if (password === confirmPassword) { console.log('Passwords match!'); }",
                  "expectedOutput": "Passwords match!"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-03-3-4",
          "title": "The Loose vs Strict Check (== vs ===)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# The Loose vs Strict Check (== vs ===)\n\n## Understanding the Concept\n\nImagine you're checking if two people are 'the same':\n\n**Loose check (==)**: 'Are they the same height?' You might say yes even if one person is wearing heels - you're flexible about what 'same' means.\n\n**Strict check (===)**: 'Are they the EXACT same height, measured precisely, wearing the exact same shoes?' You're being very specific.\n\nIn JavaScript:\n- == (loose equality) tries to be helpful by converting types: '5' == 5 → true\n- === (strict equality) requires exact match: '5' === 5 → false\n\nAlmost all professional JavaScript developers use === exclusively because it's more predictable and prevents bugs.\n\n## Code Example\n\n```javascript\n// The difference between == and ===\n\n// == (loose equality) - converts types\nconsole.log(5 == '5');     // true (converts '5' to number)\nconsole.log(true == 1);    // true (converts true to 1)\nconsole.log(false == 0);   // true (converts false to 0)\nconsole.log(null == undefined);  // true (special case)\n\n// === (strict equality) - no conversion\nconsole.log(5 === '5');    // false (number vs string)\nconsole.log(true === 1);   // false (boolean vs number)\nconsole.log(false === 0);  // false (boolean vs number)\nconsole.log(null === undefined);  // false (different types)\n\n// Real-world example where == causes bugs\nlet userInput = '0';  // User typed '0' in a form\n\nif (userInput == false) {\n  console.log('This runs! But did the user mean false?');\n}\n\nif (userInput === false) {\n  console.log('This does NOT run - safer!');\n}\n\n// Best practice: ALWAYS use ===\nlet count = 0;\nif (count === 0) {\n  console.log('Count is zero');\n}\n```\n\n## Breaking Down the Syntax\n\nUnderstanding the two equality operators:\n\n== (Loose Equality)\n- Also called 'abstract equality'\n- Converts types before comparing\n- Can lead to unexpected results\n- Example: '5' == 5 → JavaScript converts '5' to 5, then compares → true\n\n=== (Strict Equality)\n- Also called 'strict equality'\n- No type conversion\n- Both value AND type must match\n- Example: '5' === 5 → Different types (string vs number) → false\n\nThe same applies to inequality:\n\n!= (Loose Inequality)\n- Converts types before comparing\n- 5 != '5' → false (they're 'equal' after conversion)\n\n!== (Strict Inequality)  \n- No type conversion\n- 5 !== '5' → true (different types, so not equal)\n\nType coercion with ==:\n- true == 1 → true\n- false == 0 → true\n- '' == 0 → true (empty string)\n- ' ' == 0 → true (space string)\n- [] == 0 → true (empty array)\n- null == undefined → true\n\nThese are all FALSE with ===!\n\n**Best Practice**: Use === and !== exclusively. The only time to use == is if you specifically want type coercion, which is rare.\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Using == when you mean ===:\n   This is SO common. Most bugs from == are subtle and hard to spot.\n   Rule of thumb: ALWAYS use ===\n\n2. Not understanding type coercion:\n   if (userInput == true)  // Almost never what you want\n   Better: if (userInput === true) or just if (userInput)\n\n3. Assuming null == 0:\n   Actually, null == 0 → false\n   But null == undefined → true\n   Weird, right? That's why we use ===\n\n4. Forgetting that form inputs are strings:\n   <input type='number'> still gives you a string!\n   Always convert: Number(input.value)\n\n5. Triple equals in other languages:\n   PHP has ===, but most languages (Java, Python, C#) only have ==\n   JavaScript is unique in needing this distinction"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Debug this code! A user typed their age in a form (stored as a string). We want to check if they're 18, but the code isn't working:\n\nlet userAge = '18';  // String from form input\nif (userAge === 18) {\n  console.log('You are 18!');\n} else {\n  console.log('You are not 18');\n}\n\nFix it TWO ways:\n1. Convert userAge to a number before comparing (use Number(userAge))\n2. Compare as strings (userAge === '18')",
              "starterCode": "// Method 1: Convert to number\nlet userAge = '18';\n// YOUR CODE HERE\n\n// Method 2: Compare as strings  \nlet userAge2 = '18';\n// YOUR CODE HERE",
              "solution": "// Method 1: Convert to number\nlet userAge = '18';\nif (Number(userAge) === 18) {\n  console.log('You are 18!');\n}\n\n// Method 2: Compare as strings\nlet userAge2 = '18';\nif (userAge2 === '18') {\n  console.log('You are 18!');\n}",
              "hints": [
                "Method 1: if (Number(userAge) === 18)\nMethod 2: if (userAge === '18')"
              ],
              "testCases": [
                {
                  "description": "Compares correctly",
                  "input": "let userAge = '18'; if (Number(userAge) === 18) { console.log('You are 18!'); }",
                  "expectedOutput": "You are 18!"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-03-3-5",
          "title": "Combining Conditions (Logical Operators: &&, ||, !)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Combining Conditions (Logical Operators: &&, ||, !)\n\n## Understanding the Concept\n\nSometimes you need to check multiple conditions at once:\n\n'Can I go to the movies?' \n- I need money AND I need time AND the movie needs to be showing\n- If ANY of these are false, I can't go\n\nThis is what the && operator does - it means 'AND'. All conditions must be true.\n\nOr consider:\n'Should I bring an umbrella?'\n- IF it's raining OR IF it's cloudy OR IF the forecast says rain\n- If ANY of these are true, bring it\n\nThis is what the || operator does - it means 'OR'. At least one condition must be true.\n\nWe also have ! which means 'NOT' - it flips true to false and vice versa.\n\n## Code Example\n\n```javascript\n// AND operator (&&) - ALL must be true\nlet hasTicket = true;\nlet hasTime = true;\nlet isShowing = true;\n\nif (hasTicket && hasTime && isShowing) {\n  console.log('You can watch the movie!');  // All true, this runs\n}\n\nlet age = 25;\nlet hasLicense = true;\n\nif (age >= 16 && hasLicense) {\n  console.log('You can drive');  // Both true, this runs\n}\n\n// OR operator (||) - AT LEAST ONE must be true\nlet isWeekend = true;\nlet isHoliday = false;\n\nif (isWeekend || isHoliday) {\n  console.log('You can sleep in!');  // One is true, this runs\n}\n\nlet temperature = 95;\nif (temperature > 90 || temperature < 32) {\n  console.log('Extreme weather!');  // First condition true, runs\n}\n\n// NOT operator (!) - flips true/false\nlet isRaining = false;\n\nif (!isRaining) {\n  console.log('No umbrella needed');  // !false = true, runs\n}\n\n// Combining operators\nlet hour = 14;\nlet isWeekday = true;\n\nif ((hour >= 9 && hour <= 17) && isWeekday) {\n  console.log('Office is open');\n}\n```\n\n## Breaking Down the Syntax\n\nThe three logical operators:\n\n1. && (AND)\n   - true && true → true\n   - true && false → false\n   - false && true → false\n   - false && false → false\n   - ALL conditions must be true for the result to be true\n\n2. || (OR)\n   - true || true → true\n   - true || false → true\n   - false || true → true\n   - false || false → false\n   - AT LEAST ONE condition must be true for the result to be true\n\n3. ! (NOT)\n   - !true → false\n   - !false → true\n   - Flips/inverts the boolean value\n\nOrder of operations:\n1. ! (NOT) happens first\n2. && (AND) happens second\n3. || (OR) happens last\n\nExample:\n!false && true || false\n= true && true || false  // ! first\n= true || false          // && second\n= true                   // || last\n\nUse parentheses for clarity:\n(age >= 18) && (hasLicense)\n\nShort-circuit evaluation:\n- With &&: If first is false, second is never checked\n  - false && (anything) → immediately false\n- With ||: If first is true, second is never checked\n  - true || (anything) → immediately true\n\nThis is useful but can cause subtle bugs if you're not careful!\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Using 'and' or 'or' instead of symbols:\n   if (age > 18 and hasLicense)  // WRONG\n   if (age > 18 && hasLicense)   // CORRECT\n\n2. Confusing && and ||:\n   if (isWeekend || hasWork)  // Do I work on weekends or any day?\n   vs\n   if (isWeekend && !hasWork) // Free weekend?\n   Read them out loud to check!\n\n3. Forgetting parentheses with mixed operators:\n   if (a || b && c)  // Unclear!\n   if (a || (b && c))  // Better\n   if ((a || b) && c)  // Different meaning!\n\n4. Double negatives:\n   if (!!isLoggedIn)  // Just use: if (isLoggedIn)\n   Don't overthink it!\n\n5. Not understanding short-circuit:\n   if (user && user.name)  // Safe - checks user exists first\n   if (user.name && user)  // DANGEROUS - might error if user is null\n\n6. Trying to check multiple values at once:\n   if (x === 1 || 2 || 3)  // WRONG - doesn't work!\n   if (x === 1 || x === 2 || x === 3)  // CORRECT\n   Or better: if ([1,2,3].includes(x))  // We'll learn this later!"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a simple access control system for a secure building:\n1. Create variables: isEmployee (boolean), hasKeycard (boolean), securityLevel (number 1-3)\n2. Access is granted if:\n   - Person is an employee AND has a keycard\n   - OR security level is 3 (admin access)\n3. Display 'Access Granted' or 'Access Denied'",
              "starterCode": "let isEmployee = true;\nlet hasKeycard = true;\nlet securityLevel = 2;\n\n// Write your if statement here\n// Access granted if: (isEmployee AND hasKeycard) OR securityLevel is 3\n",
              "solution": "let isEmployee = true;\nlet hasKeycard = true;\nlet securityLevel = 2;\n\nif ((isEmployee && hasKeycard) || securityLevel === 3) {\n  console.log('Access Granted');\n} else {\n  console.log('Access Denied');\n}",
              "hints": [
                "Use parentheses to group: if ((isEmployee && hasKeycard) || securityLevel === 3)"
              ],
              "testCases": [
                {
                  "description": "Grants access for employee with keycard",
                  "input": "let isEmployee = true; let hasKeycard = true; let securityLevel = 1; if ((isEmployee && hasKeycard) || securityLevel === 3) { console.log('Access Granted'); } else { console.log('Access Denied'); }",
                  "expectedOutput": "Access Granted"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "module-04",
      "title": "Module 4: Repeating Actions (The 'Loops')",
      "description": "Automate repetitive tasks using loops",
      "difficulty": "beginner",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-04-4-1",
          "title": "Doing Something a Specific Number of Times (for Loops)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Doing Something a Specific Number of Times (for Loops)\n\n## Understanding the Concept\n\nImagine you're a teacher taking attendance. You have a list of 25 students, and you need to call out each name, one by one:\n\n'Student 1: Are you here?'\n'Student 2: Are you here?'\n'Student 3: Are you here?'\n...and so on until student 25.\n\nYou're doing the SAME action 25 times, just changing the number. This is tedious to write out, but perfect for a loop!\n\nA 'for loop' is like saying: 'Start at 1, keep going until 25, and for each number, do this action.' The loop handles the counting automatically - you just tell it what to do each time.\n\n## Code Example\n\n```javascript\n// Basic for loop - count from 0 to 4\nfor (let i = 0; i < 5; i++) {\n  console.log('Count: ' + i);\n}\n// Displays: Count: 0, Count: 1, Count: 2, Count: 3, Count: 4\n\n// Count from 1 to 10\nfor (let i = 1; i <= 10; i++) {\n  console.log(i);\n}\n\n// Count by twos (even numbers)\nfor (let i = 0; i <= 10; i += 2) {\n  console.log(i);  // 0, 2, 4, 6, 8, 10\n}\n\n// Count backwards\nfor (let i = 10; i >= 1; i--) {\n  console.log(i);\n}\nconsole.log('Blast off!');\n\n// Practical example: calculate total\nlet total = 0;\nfor (let i = 1; i <= 5; i++) {\n  total += i;  // Same as: total = total + i\n}\nconsole.log('Sum of 1 to 5: ' + total);  // 15\n```\n\n## Breaking Down the Syntax\n\nAnatomy of a for loop:\n\nfor (initialization; condition; update) {\n     │              │          │\n     │              │          └─ What happens after each loop\n     │              └──────────── When to keep looping\n     └─────────────────────────── Where to start\n  // Code to repeat\n}\n\nLet's break down: for (let i = 0; i < 5; i++)\n\n1. **Initialization** (let i = 0)\n   - Runs ONCE at the very beginning\n   - Creates a counter variable (usually named i)\n   - Sets its starting value\n\n2. **Condition** (i < 5)\n   - Checked BEFORE each loop iteration\n   - If true, run the loop body\n   - If false, exit the loop\n\n3. **Update** (i++)\n   - Runs AFTER each loop iteration\n   - Usually increments the counter\n   - i++ means 'add 1 to i' (same as i = i + 1)\n\nHow it flows:\n1. let i = 0           (start)\n2. Is i < 5? Yes (0 < 5)  → run loop body\n3. i++ → i is now 1\n4. Is i < 5? Yes (1 < 5)  → run loop body\n5. i++ → i is now 2\n6. Is i < 5? Yes (2 < 5)  → run loop body\n7. i++ → i is now 3\n8. Is i < 5? Yes (3 < 5)  → run loop body\n9. i++ → i is now 4\n10. Is i < 5? Yes (4 < 5) → run loop body\n11. i++ → i is now 5\n12. Is i < 5? No (5 is NOT < 5) → EXIT LOOP\n\nCommon patterns:\n- Count up: i++\n- Count down: i--\n- Skip by 2: i += 2\n- Count by 10s: i += 10\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Off-by-one errors (VERY common!):\n   for (let i = 0; i < 5; i++)  // Runs 5 times (0,1,2,3,4)\n   for (let i = 1; i < 5; i++)  // Runs 4 times (1,2,3,4)\n   for (let i = 1; i <= 5; i++) // Runs 5 times (1,2,3,4,5)\n   Always test: does this loop run the right number of times?\n\n2. Infinite loops:\n   for (let i = 0; i < 5; i--) // i gets SMALLER, never reaches 5!\n   This will crash your program!\n\n3. Forgetting to increment:\n   for (let i = 0; i < 5; ) // Missing i++\n   Another infinite loop!\n\n4. Using = instead of ==:\n   for (let i = 0; i = 5; i++)  // WRONG - assigns 5 to i!\n   for (let i = 0; i < 5; i++)  // CORRECT\n\n5. Modifying the loop variable inside:\n   for (let i = 0; i < 5; i++) {\n     i = 0;  // BAD - creates infinite loop!\n   }\n   Don't change i inside the loop body!"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a multiplication table for 7:\nUse a for loop to display:\n7 x 1 = 7\n7 x 2 = 14\n7 x 3 = 21\n...up to...\n7 x 10 = 70\n\nHint: Loop from 1 to 10, and each time display: console.log('7 x ' + i + ' = ' + (7 * i));",
              "starterCode": "// Create a for loop that goes from 1 to 10\n// Each time, display the multiplication\n",
              "solution": "for (let i = 1; i <= 10; i++) {\n  console.log('7 x ' + i + ' = ' + (7 * i));\n}",
              "hints": [
                "for (let i = 1; i <= 10; i++) { console.log('7 x ' + i + ' = ' + (7 * i)); }"
              ],
              "testCases": [
                {
                  "description": "Displays 7 x 1 = 7",
                  "input": "for (let i = 1; i <= 10; i++) { console.log('7 x ' + i + ' = ' + (7 * i)); }",
                  "expectedOutput": "7 x 1 = 7"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-04-4-2",
          "title": "Looping Until a Condition Changes (while Loops)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Looping Until a Condition Changes (while Loops)\n\n## Understanding the Concept\n\nImagine you're filling a bathtub. You don't know EXACTLY how many seconds it will take - you just know you need to keep the water running WHILE the tub is not full.\n\nEvery few seconds you check: 'Is it full yet?' No → keep filling. 'Is it full yet?' No → keep filling. 'Is it full yet?' YES → turn off the water!\n\nThis is what a 'while loop' does. Unlike a for loop (where you know how many times to repeat), a while loop keeps going UNTIL a condition becomes false. You don't know how many times it will run - you just know the condition that needs to be met to stop.\n\n## Code Example\n\n```javascript\n// Basic while loop - count to 5\nlet count = 0;\n\nwhile (count < 5) {\n  console.log('Count: ' + count);\n  count++;  // IMPORTANT: Don't forget to update!\n}\n\n// Practical example: password attempts\nlet password = 'secret';\nlet userInput = 'wrong';\nlet attempts = 0;\nlet maxAttempts = 3;\n\nwhile (userInput !== password && attempts < maxAttempts) {\n  console.log('Attempt ' + (attempts + 1) + ': Incorrect password');\n  // In a real app, you'd ask for input here\n  // For this example, we'll just increment\n  attempts++;\n  if (attempts === 2) {\n    userInput = 'secret';  // Correct on 3rd try\n  }\n}\n\nif (userInput === password) {\n  console.log('Access granted!');\n} else {\n  console.log('Too many failed attempts');\n}\n\n// Countdown example\nlet countdown = 5;\nwhile (countdown > 0) {\n  console.log(countdown);\n  countdown--;\n}\nconsole.log('Liftoff!');\n```\n\n## Breaking Down the Syntax\n\nStructure of a while loop:\n\nwhile (condition) {\n       │\n       └─ Keep looping while this is true\n  // Code to repeat\n  // MUST update something that affects the condition!\n}\n\nHow it works:\n1. Check the condition\n2. If true: run the loop body, then go back to step 1\n3. If false: exit the loop\n\nCritical difference from for loop:\n- for loop: Use when you KNOW how many times to loop\n  for (let i = 0; i < 10; i++) { }  // Exactly 10 times\n\n- while loop: Use when you DON'T know how many times\n  while (notFullYet) { }  // Until it's full (who knows how long?)\n\n**WARNING**: You MUST change something in the loop that affects the condition, or you'll create an infinite loop!\n\nGood (will eventually stop):\nlet x = 0;\nwhile (x < 5) {\n  console.log(x);\n  x++;  // x changes, will eventually reach 5\n}\n\nBAD (infinite loop!):\nlet x = 0;\nwhile (x < 5) {\n  console.log(x);  // x never changes!\n  // Loop runs forever!\n}\n\nCommon while loop patterns:\n- Keep trying until success\n- Process until data runs out\n- Wait for a condition to change\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Forgetting to update the condition variable:\n   let x = 0;\n   while (x < 10) {\n     console.log(x);  // x never changes - INFINITE LOOP!\n   }\n\n2. Updating in the wrong direction:\n   let x = 0;\n   while (x < 10) {\n     console.log(x);\n     x--;  // x gets MORE negative - INFINITE LOOP!\n   }\n\n3. Wrong comparison operator:\n   let x = 0;\n   while (x < 10) {\n     console.log(x);\n     x--;  // Should be x++\n   }\n\n4. Condition that's never true:\n   let x = 5;\n   while (x < 0) {  // 5 is not < 0\n     // This never runs at all!\n   }\n\n5. Not initializing before the loop:\n   while (count < 10) {  // count is not defined!\n     count++;\n   }\n   Must declare: let count = 0; BEFORE the while loop"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a simple number guessing game:\n1. Set a target number (e.g., 7)\n2. Set a guess variable to 1\n3. Use a while loop that runs while guess is not equal to target\n4. Each time through the loop:\n   - Display: 'Guess: [number] - Wrong!'\n   - Increment guess by 1\n5. After the loop, display: 'Guess: [number] - Correct!'",
              "starterCode": "let target = 7;\nlet guess = 1;\n\n// Write your while loop here\n\n// After the loop, display the correct message\n",
              "solution": "let target = 7;\nlet guess = 1;\n\nwhile (guess !== target) {\n  console.log('Guess: ' + guess + ' - Wrong!');\n  guess++;\n}\n\nconsole.log('Guess: ' + guess + ' - Correct!');",
              "hints": [
                "while (guess !== target) { console.log('Guess: ' + guess + ' - Wrong!'); guess++; }"
              ],
              "testCases": [
                {
                  "description": "Keeps guessing until correct",
                  "input": "let target = 3; let guess = 1; let output = ''; while (guess !== target) { output += 'Guess: ' + guess + ' - Wrong!\\n'; guess++; } console.log(output + 'Guess: ' + guess + ' - Correct!');",
                  "expectedOutput": "Guess: 1 - Wrong!\nGuess: 2 - Wrong!\nGuess: 3 - Correct!"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-04-4-3",
          "title": "Breaking Out Early (break and continue)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Breaking Out Early (break and continue)\n\n## Understanding the Concept\n\nImagine you're looking through a stack of 100 papers for a specific document:\n\n**break**: You find the document on paper #37. You don't need to look through the remaining 63 papers - you STOP immediately and leave. That's what 'break' does - it exits the loop early.\n\n**continue**: You're reading through papers, but whenever you see a blank page, you skip it and go to the next one without processing it. That's what 'continue' does - it skips to the next iteration of the loop.\n\nBoth are useful for making loops more efficient and handling special cases.\n\n## Code Example\n\n```javascript\n// BREAK - exit the loop early\nconsole.log('--- Using break ---');\nfor (let i = 1; i <= 10; i++) {\n  if (i === 5) {\n    console.log('Found 5! Stopping.');\n    break;  // Exit the entire loop\n  }\n  console.log(i);\n}\nconsole.log('Loop finished');\n// Output: 1, 2, 3, 4, Found 5! Stopping., Loop finished\n\n// CONTINUE - skip to next iteration\nconsole.log('--- Using continue ---');\nfor (let i = 1; i <= 10; i++) {\n  if (i % 2 === 0) {  // If even number\n    continue;  // Skip the rest, go to next iteration\n  }\n  console.log(i);  // Only odd numbers print\n}\n// Output: 1, 3, 5, 7, 9\n\n// Practical: searching for a value\nlet numbers = [5, 8, 12, 15, 20, 25];\nlet target = 15;\nlet found = false;\n\nfor (let i = 0; i < numbers.length; i++) {\n  if (numbers[i] === target) {\n    console.log('Found ' + target + ' at position ' + i);\n    found = true;\n    break;  // No need to keep searching!\n  }\n}\n\nif (!found) {\n  console.log(target + ' not found');\n}\n\n// Skip invalid data\nfor (let i = 1; i <= 5; i++) {\n  if (i === 3) {\n    console.log('Skipping 3');\n    continue;\n  }\n  console.log('Processing: ' + i);\n}\n// Processes 1, 2, skips 3, processes 4, 5\n```\n\n## Breaking Down the Syntax\n\nTwo flow control keywords:\n\n**break**\n- Immediately exits the loop\n- Execution continues after the loop\n- Use when you've found what you're looking for\n- Use when a condition makes continuing pointless\n\nExample:\nfor (let i = 0; i < 100; i++) {\n  if (found) {\n    break;  // Don't check remaining 90 items\n  }\n}\nconsole.log('Continue here');  // This runs after break\n\n**continue**\n- Skips the rest of the current iteration\n- Goes directly to the next iteration\n- Use to skip invalid/unwanted values\n- Use to avoid deep nesting\n\nExample:\nfor (let i = 0; i < 10; i++) {\n  if (i === 5) {\n    continue;  // Skip when i is 5\n  }\n  console.log(i);  // This doesn't run when i is 5\n  // But runs for all other values\n}\n\nComparing break vs continue:\n\nbreak:\nfor (let i = 0; i < 5; i++) {\n  if (i === 3) break;\n  console.log(i);\n}\n// Prints: 0, 1, 2 (then EXITS loop)\n\ncontinue:\nfor (let i = 0; i < 5; i++) {\n  if (i === 3) continue;\n  console.log(i);\n}\n// Prints: 0, 1, 2, 4 (SKIPS 3, continues loop)\n\nImportant: break and continue only affect the INNERMOST loop they're in. If you have nested loops, they don't break out of all loops.\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Using break outside a loop:\n   if (x > 5) {\n     break;  // ERROR - not in a loop!\n   }\n   break only works inside loops or switch statements\n\n2. Confusing break and return:\n   - break exits a loop\n   - return exits a function (we'll learn soon)\n   Don't mix them up!\n\n3. Expecting break to exit nested loops:\n   for (let i = 0; i < 3; i++) {\n     for (let j = 0; j < 3; j++) {\n       if (j === 1) break;  // Only exits inner loop!\n     }\n   }\n   To exit all loops, use a flag or a function with return\n\n4. Forgetting to update counter before continue:\n   let i = 0;\n   while (i < 10) {\n     if (i === 5) continue;  // INFINITE LOOP!\n     console.log(i);\n     i++;  // Never reached when i is 5\n   }\n   Fix: Put i++ before the continue check\n\n5. Overusing break/continue:\n   Sometimes an if statement is clearer:\n   for (let i = 0; i < 10; i++) {\n     if (i !== 5) {  // Clearer than using continue\n       console.log(i);\n     }\n   }"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a loop that finds the first number divisible by 7 between 1 and 50:\n1. Use a for loop from 1 to 50\n2. Check if the number is divisible by 7 (use i % 7 === 0)\n3. When you find it, display 'First number divisible by 7: [number]'\n4. Use 'break' to exit the loop (no need to check the rest)",
              "starterCode": "// Loop from 1 to 50\n// Check if divisible by 7\n// Display and break when found\n",
              "solution": "for (let i = 1; i <= 50; i++) {\n  if (i % 7 === 0) {\n    console.log('First number divisible by 7: ' + i);\n    break;\n  }\n}",
              "hints": [
                "for (let i = 1; i <= 50; i++) { if (i % 7 === 0) { console.log('First number divisible by 7: ' + i); break; } }"
              ],
              "testCases": [
                {
                  "description": "Finds first number divisible by 7",
                  "input": "for (let i = 1; i <= 50; i++) { if (i % 7 === 0) { console.log('First number divisible by 7: ' + i); break; } }",
                  "expectedOutput": "First number divisible by 7: 7"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-04-4-4",
          "title": "Looping Through Lists (for...of)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Looping Through Lists (for...of)\n\n## Understanding the Concept\n\nImagine you have a playlist of songs, and you want to play each one in order. You don't care about the position (song #1, song #2, etc.) - you just want to go through each song:\n\n'Play song: Song A'\n'Play song: Song B'\n'Play song: Song C'\n\nYou're iterating through the LIST, not counting numbers. This is perfect for the 'for...of' loop - it's designed specifically for going through each item in a list (array) without worrying about indices or counters.\n\n## Code Example\n\n```javascript\n// Old way: using a regular for loop with an index\nlet fruits = ['apple', 'banana', 'cherry'];\n\nfor (let i = 0; i < fruits.length; i++) {\n  console.log(fruits[i]);  // Need to use fruits[i] to get the item\n}\n\n// New way: for...of loop (much cleaner!)\nfor (let fruit of fruits) {\n  console.log(fruit);  // Direct access to each item\n}\n\n// Another example: summing numbers\nlet numbers = [10, 20, 30, 40, 50];\nlet total = 0;\n\nfor (let num of numbers) {\n  total += num;\n}\nconsole.log('Total: ' + total);  // 150\n\n// Works with strings too! (string is a list of characters)\nlet word = 'hello';\n\nfor (let letter of word) {\n  console.log(letter);  // h, e, l, l, o\n}\n\n// Practical: find if item exists\nlet shoppingCart = ['milk', 'eggs', 'bread', 'butter'];\nlet lookingFor = 'eggs';\nlet hasItem = false;\n\nfor (let item of shoppingCart) {\n  if (item === lookingFor) {\n    hasItem = true;\n    break;\n  }\n}\n\nconsole.log(hasItem ? 'Found it!' : 'Not in cart');\n```\n\n## Breaking Down the Syntax\n\nUnderstanding for...of:\n\nfor (let item of array) {\n     │   │    │    │\n     │   │    │    └─ The array to loop through\n     │   │    └────── The 'of' keyword\n     │   └─────────── Variable to hold each item (you choose the name)\n     └─────────────── let (or const)\n  // Use 'item' here\n}\n\nComparing loop types:\n\n// Regular for loop - use when you need the INDEX\nfor (let i = 0; i < arr.length; i++) {\n  console.log('Position ' + i + ': ' + arr[i]);\n}\n\n// for...of loop - use when you just need the ITEMS\nfor (let item of arr) {\n  console.log(item);  // Don't care about position\n}\n\n// while loop - use when you don't know how many times\nwhile (notDone) {\n  // Keep going until condition changes\n}\n\nWhen to use for...of:\n✓ Going through all items in an array\n✓ Don't need the index/position\n✓ Cleaner, more readable code\n\nWhen NOT to use for...of:\n✗ Need the index number\n✗ Need to modify the array while looping\n✗ Looping a specific number of times (use regular for)\n\nNote: You can use 'const' instead of 'let' in for...of:\nfor (const fruit of fruits) {\n  // fruit is reassigned each iteration, so const works!\n}\n\nArray.length:\n- Every array has a .length property\n- fruits.length → 3 (number of items)\n- Use in regular for loops: i < arr.length\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Using 'in' instead of 'of':\n   for (let fruit in fruits)  // WRONG - gives index, not item!\n   for (let fruit of fruits)  // CORRECT - gives the item\n   \n   Confusing, right? Remember: 'of' for values, 'in' for keys (we'll learn later)\n\n2. Trying to get the index:\n   for (let fruit of fruits) {\n     console.log(i);  // ERROR - i doesn't exist!\n   }\n   If you need the index, use a regular for loop or .forEach() (later)\n\n3. Modifying the array while looping:\n   for (let fruit of fruits) {\n     fruits.push('new');  // DANGEROUS - might cause infinite loop!\n   }\n   Don't modify the array you're looping through\n\n4. Expecting it to work on objects:\n   let person = {name: 'Alice', age: 25};\n   for (let prop of person)  // ERROR - for...of doesn't work on plain objects!\n   Use for...in for objects (later lesson)\n\n5. Using wrong variable name:\n   for (let fruit of fruits) {\n     console.log(fruits);  // Prints whole array each time!\n   }\n   Should be: console.log(fruit);  // Just one item"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "You have a list of temperatures in Celsius. Convert each to Fahrenheit and display it:\n1. Given array: [0, 10, 20, 30, 40]\n2. Use a for...of loop\n3. For each temperature, convert to Fahrenheit: (celsius * 9/5) + 32\n4. Display: '[celsius]°C is [fahrenheit]°F'",
              "starterCode": "let celsiusTemps = [0, 10, 20, 30, 40];\n\n// Use for...of to loop through each temperature\n// Convert and display each one\n",
              "solution": "let celsiusTemps = [0, 10, 20, 30, 40];\n\nfor (let celsius of celsiusTemps) {\n  let fahrenheit = (celsius * 9/5) + 32;\n  console.log(celsius + '°C is ' + fahrenheit + '°F');\n}",
              "hints": [
                "for (let celsius of celsiusTemps) { let fahrenheit = (celsius * 9/5) + 32; console.log(...); }"
              ],
              "testCases": [
                {
                  "description": "Converts 0°C correctly",
                  "input": "let celsiusTemps = [0]; for (let celsius of celsiusTemps) { let fahrenheit = (celsius * 9/5) + 32; console.log(celsius + '°C is ' + fahrenheit + '°F'); }",
                  "expectedOutput": "0°C is 32°F"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "module-05",
      "title": "Module 5: Grouping Information (The 'Containers')",
      "description": "Store and organize multiple pieces of related information using arrays and objects",
      "difficulty": "beginner",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-05-5-1",
          "title": "Ordered Lists of Things (Arrays)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Ordered Lists of Things (Arrays)\n\n## Understanding the Concept\n\nImagine you have a shopping list written on paper:\n\n1. Milk\n2. Eggs\n3. Bread\n4. Butter\n\nThis is an ordered list - each item has a position (1st, 2nd, 3rd, etc.). In programming, we call this an ARRAY. It's a single variable that can hold multiple values in a specific order.\n\nThink of an array like a train with numbered cars: Car 0 has apples, Car 1 has bananas, Car 2 has cherries. The numbers (0, 1, 2) are called 'indices' (plural of index), and they tell you where each item is located.\n\nImportant quirk: Programming counts from 0, not 1! So the first item is at position 0, the second at position 1, and so on.\n\n## Code Example\n\n```javascript\n// Creating an array\nlet fruits = ['apple', 'banana', 'cherry'];\n\n// Accessing items by index (position)\nconsole.log(fruits[0]);  // apple (first item)\nconsole.log(fruits[1]);  // banana (second item)\nconsole.log(fruits[2]);  // cherry (third item)\n\n// Arrays can hold different types\nlet mixed = ['text', 42, true, null];\nconsole.log(mixed[1]);  // 42\n\n// Empty array\nlet empty = [];\n\n// Array length (how many items)\nconsole.log(fruits.length);  // 3\n\n// Last item (using length)\nlet lastFruit = fruits[fruits.length - 1];\nconsole.log(lastFruit);  // cherry\n\n// Changing an item\nfruits[1] = 'blueberry';\nconsole.log(fruits);  // ['apple', 'blueberry', 'cherry']\n\n// Loop through array\nfor (let i = 0; i < fruits.length; i++) {\n  console.log('Item ' + i + ': ' + fruits[i]);\n}\n```\n\n## Breaking Down the Syntax\n\nArray syntax:\n\n// Creating arrays\nlet arrayName = [item1, item2, item3];\nlet empty = [];\n\n// Accessing items (zero-indexed!)\narray[0]  // First item\narray[1]  // Second item\narray[2]  // Third item\n\n// Index visualization:\nlet numbers = [10, 20, 30, 40, 50];\n//  Index:     0   1   2   3   4\n//  Value:    10  20  30  40  50\n\nnumbers[0] → 10\nnumbers[4] → 50\nnumbers[5] → undefined (doesn't exist)\n\nKey properties:\n\n1. .length - number of items\n   - ['a', 'b', 'c'].length → 3\n   - [].length → 0\n\n2. Zero-indexed\n   - First item: array[0]\n   - Last item: array[array.length - 1]\n\n3. Mutable (can be changed)\n   - array[0] = 'new value'\n\n4. Can hold any type\n   - [1, 'text', true, {}, []]  // all valid\n\nCommon patterns:\n\n// Last item\nlet last = array[array.length - 1];\n\n// Check if empty\nif (array.length === 0) {\n  console.log('Empty');\n}\n\n// Loop through all items\nfor (let i = 0; i < array.length; i++) {\n  // use array[i]\n}\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Starting at index 1 instead of 0:\n   array[1]  // This is the SECOND item, not first!\n   array[0]  // This is the first item\n\n2. Accessing index === length:\n   let arr = ['a', 'b', 'c'];  // length is 3\n   arr[3]  // undefined - no such index!\n   // Valid indices: 0, 1, 2\n\n3. Forgetting .length is a property, not a method:\n   array.length()  // WRONG\n   array.length    // CORRECT (no parentheses)\n\n4. Confusing length with last index:\n   let arr = ['a', 'b', 'c'];\n   arr.length       // 3 (count of items)\n   arr[arr.length]  // undefined!\n   arr[arr.length - 1]  // 'c' (last item)\n\n5. Treating arrays like single values:\n   let arr = [1, 2, 3];\n   console.log(arr);  // Prints whole array [1, 2, 3]\n   console.log(arr[0]);  // Prints just first item: 1"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a simple gradebook:\n1. Create an array of test scores: [85, 92, 78, 95, 88]\n2. Display the first score (index 0)\n3. Display the last score (use .length - 1)\n4. Calculate and display the average score (sum all, divide by length)",
              "starterCode": "let scores = [85, 92, 78, 95, 88];\n\n// Display first score\n\n// Display last score\n\n// Calculate average\nlet total = 0;\n// Use a loop to sum all scores\n// Then divide by scores.length\n",
              "solution": "let scores = [85, 92, 78, 95, 88];\n\nconsole.log('First score: ' + scores[0]);\nconsole.log('Last score: ' + scores[scores.length - 1]);\n\nlet total = 0;\nfor (let i = 0; i < scores.length; i++) {\n  total += scores[i];\n}\n\nlet average = total / scores.length;\nconsole.log('Average: ' + average);",
              "hints": [
                "First: scores[0], Last: scores[scores.length - 1], Average: sum all in loop, divide by scores.length"
              ],
              "testCases": [
                {
                  "description": "Displays first score",
                  "input": "let scores = [85, 92, 78, 95, 88]; console.log(scores[0]);",
                  "expectedOutput": "85"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-05-5-2",
          "title": "Adding and Removing Items (Array Methods: push, pop, shift, unshift)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Adding and Removing Items (Array Methods: push, pop, shift, unshift)\n\n## Understanding the Concept\n\nImagine your array is a line of people:\n\n**push()**: Someone new joins the END of the line\n**pop()**: The person at the END of the line leaves\n**unshift()**: Someone cuts in at the FRONT of the line\n**shift()**: The person at the FRONT of the line leaves\n\nThese four methods let you add or remove items from either end of an array. They're like doors - two at the back (push/pop) and two at the front (shift/unshift).\n\n## Code Example\n\n```javascript\nlet fruits = ['apple', 'banana'];\nconsole.log(fruits);  // ['apple', 'banana']\n\n// push() - add to the END\nfruits.push('cherry');\nconsole.log(fruits);  // ['apple', 'banana', 'cherry']\n\n// Can push multiple at once\nfruits.push('date', 'elderberry');\nconsole.log(fruits);  // ['apple', 'banana', 'cherry', 'date', 'elderberry']\n\n// pop() - remove from the END, returns the removed item\nlet removed = fruits.pop();\nconsole.log(removed);  // 'elderberry'\nconsole.log(fruits);  // ['apple', 'banana', 'cherry', 'date']\n\n// unshift() - add to the FRONT\nfruits.unshift('apricot');\nconsole.log(fruits);  // ['apricot', 'apple', 'banana', 'cherry', 'date']\n\n// shift() - remove from the FRONT, returns the removed item\nlet firstItem = fruits.shift();\nconsole.log(firstItem);  // 'apricot'\nconsole.log(fruits);  // ['apple', 'banana', 'cherry', 'date']\n\n// Practical: stack (Last In, First Out)\nlet stack = [];\nstack.push('task 1');\nstack.push('task 2');\nstack.push('task 3');\nlet current = stack.pop();  // 'task 3' - most recent\n\n// Practical: queue (First In, First Out)\nlet queue = [];\nqueue.push('person 1');\nqueue.push('person 2');\nqueue.push('person 3');\nlet next = queue.shift();  // 'person 1' - first in line\n```\n\n## Breaking Down the Syntax\n\nThe four basic array methods:\n\n1. push(item) - add to END\n   - Adds one or more items to the end\n   - Returns new length\n   - Example: arr.push('x') → adds 'x' to end\n\n2. pop() - remove from END\n   - Removes last item\n   - Returns the removed item\n   - Example: let last = arr.pop()\n\n3. unshift(item) - add to FRONT\n   - Adds one or more items to the beginning\n   - Shifts all existing items to higher indices\n   - Returns new length\n   - Example: arr.unshift('x') → adds 'x' to front\n\n4. shift() - remove from FRONT\n   - Removes first item\n   - Shifts all remaining items to lower indices\n   - Returns the removed item\n   - Example: let first = arr.shift()\n\nMemory trick:\n- push/pop: work with the END (both have 'p')\n- shift/unshift: work with the FRONT\n- push/unshift: ADD items\n- pop/shift: REMOVE items\n\nPerformance notes:\n- push() and pop(): Fast (O(1))\n- shift() and unshift(): Slower (O(n)) because indices must be recalculated\n- For large arrays, avoid shift/unshift if performance matters\n\nThese methods MODIFY the original array:\nlet arr = [1, 2];\narr.push(3);  // arr is now [1, 2, 3]\n// The original array changed!\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Forgetting these methods modify the array:\n   let arr = [1, 2, 3];\n   arr.push(4);  // arr is NOW [1, 2, 3, 4]\n   // It's not arr2 = arr.push(4)\n\n2. Expecting push/pop to work on both ends:\n   arr.pop()  // Removes from END, not front\n   // Use shift() to remove from front\n\n3. Not using the return value:\n   arr.pop();  // Item is removed AND returned\n   let item = arr.pop();  // Save the removed item!\n\n4. Confusing shift/unshift names:\n   shift = remove first (shifts everything left)\n   unshift = add to first (unshifts everything right)\n   Confusing, but that's the name!\n\n5. Using on non-arrays:\n   let str = 'hello';\n   str.push('x');  // ERROR - strings don't have push\n   // Convert to array first: str.split('')"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Simulate a simple to-do list:\n1. Start with an empty array: let todos = []\n2. Add 'Buy groceries' to the end\n3. Add 'Clean room' to the end\n4. Add 'URGENT: Pay bills' to the FRONT (it's urgent!)\n5. Display the array\n6. Complete the first task (remove it with shift())\n7. Display the updated array",
              "starterCode": "let todos = [];\n\n// Add tasks\n\n// Display\n\n// Complete first task\n\n// Display again\n",
              "solution": "let todos = [];\n\ntodos.push('Buy groceries');\ntodos.push('Clean room');\ntodos.unshift('URGENT: Pay bills');\n\nconsole.log('Todos:', todos);\n// ['URGENT: Pay bills', 'Buy groceries', 'Clean room']\n\nlet completed = todos.shift();\nconsole.log('Completed:', completed);\nconsole.log('Remaining todos:', todos);\n// ['Buy groceries', 'Clean room']",
              "hints": [
                "push() for end, unshift() for front, shift() to remove first"
              ],
              "testCases": [
                {
                  "description": "Builds todo list correctly",
                  "input": "let todos = []; todos.push('Buy groceries'); todos.push('Clean room'); todos.unshift('URGENT: Pay bills'); console.log(todos.length);",
                  "expectedOutput": "3"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-05-5-3",
          "title": "Searching and Transforming Lists (find, filter, map, reduce)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Searching and Transforming Lists (find, filter, map, reduce)\n\n## Understanding the Concept\n\nImagine you're managing a music playlist with 1000 songs:\n\n**find()**: 'Find me the first song by Taylor Swift' - you scan through until you find ONE match, then stop.\n\n**filter()**: 'Give me all songs from 2020' - you go through the entire list and create a NEW list with only the songs that match.\n\n**map()**: 'Convert all song titles to uppercase' - you go through each song and create a NEW list where each item has been transformed.\n\n**reduce()**: 'Calculate the total duration of all songs' - you go through each song, adding up all the durations into a SINGLE result. Reduce is like a snowball rolling down a hill, accumulating more snow (data) as it goes.\n\nThese are four of the most powerful array methods in JavaScript. They don't change the original array - they create new values or arrays.\n\n## Code Example\n\n```javascript\nlet numbers = [1, 4, 7, 10, 15, 20];\n\n// find() - returns FIRST item that matches\nlet firstBigNumber = numbers.find(function(num) {\n  return num > 10;\n});\nconsole.log(firstBigNumber);  // 15 (first one > 10)\n\n// filter() - returns ALL items that match\nlet bigNumbers = numbers.filter(function(num) {\n  return num > 10;\n});\nconsole.log(bigNumbers);  // [15, 20]\n\n// map() - transforms each item, returns new array\nlet doubled = numbers.map(function(num) {\n  return num * 2;\n});\nconsole.log(doubled);  // [2, 8, 14, 20, 30, 40]\nconsole.log(numbers);  // [1, 4, 7, 10, 15, 20] - original unchanged!\n\n// Real-world examples\nlet products = [\n  { name: 'Laptop', price: 1000 },\n  { name: 'Mouse', price: 25 },\n  { name: 'Keyboard', price: 75 },\n  { name: 'Monitor', price: 300 }\n];\n\n// Find first expensive item\nlet expensive = products.find(p => p.price > 500);\nconsole.log(expensive);  // {name: 'Laptop', price: 1000}\n\n// Filter affordable items\nlet affordable = products.filter(p => p.price < 100);\nconsole.log(affordable);  // Mouse and Keyboard\n\n// Get array of just names\nlet names = products.map(p => p.name);\nconsole.log(names);  // ['Laptop', 'Mouse', 'Keyboard', 'Monitor']\n\n// reduce() - accumulate values into a single result\nlet prices = [100, 200, 50, 75];\n\n// Calculate total (the snowball rolling down the hill!)\nlet total = prices.reduce(function(accumulator, currentPrice) {\n  return accumulator + currentPrice;\n}, 0);  // 0 is the starting value\n\nconsole.log(total);  // 425\n\n// Real-world: Calculate total price of cart\nlet totalCartPrice = products.reduce(function(sum, product) {\n  return sum + product.price;\n}, 0);\n\nconsole.log('Cart total: $' + totalCartPrice);  // $1400\n\n// Count items (using reduce creatively)\nlet words = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple'];\nlet wordCount = words.reduce(function(counts, word) {\n  counts[word] = (counts[word] || 0) + 1;\n  return counts;\n}, {});\n\nconsole.log(wordCount);  // {apple: 3, banana: 2, cherry: 1}\n```\n\n## Breaking Down the Syntax\n\nUnderstanding the three methods:\n\n1. **find(callbackFunction)**\n   - Goes through array until callback returns true\n   - Returns the FIRST matching item\n   - Returns undefined if no match found\n   - Syntax: array.find(item => condition)\n\nExample:\nlet ages = [12, 18, 25, 30];\nlet adult = ages.find(age => age >= 18);  // 18\n\n2. **filter(callbackFunction)**\n   - Goes through ENTIRE array\n   - Returns NEW array with ALL matching items\n   - Returns empty array [] if no matches\n   - Original array unchanged\n   - Syntax: array.filter(item => condition)\n\nExample:\nlet adults = ages.filter(age => age >= 18);  // [18, 25, 30]\n\n3. **map(callbackFunction)**\n   - Goes through ENTIRE array\n   - Transforms each item\n   - Returns NEW array (same length as original)\n   - Original array unchanged\n   - Syntax: array.map(item => transformation)\n\nExample:\nlet doubled = ages.map(age => age * 2);  // [24, 36, 50, 60]\n\nCallback function:\n- A function you pass to another function\n- Gets called for each item\n- Receives: (item, index, array)\n- Usually you only need: item\n\nArrow function shorthand:\n// Long form\narray.find(function(item) {\n  return item > 10;\n})\n\n// Short form\narray.find(item => item > 10)\n\n4. **reduce(callbackFunction, initialValue)**\n   - Goes through ENTIRE array\n   - Accumulates/combines all values into a SINGLE result\n   - Like a snowball rolling downhill, gathering more\n   - Can return ANY type (number, string, object, array)\n   - Syntax: array.reduce((accumulator, item) => newAccumulator, startValue)\n\nExample - Sum numbers:\nlet prices = [10, 20, 30];\nlet total = prices.reduce((sum, price) => sum + price, 0);\n// Step 1: sum=0, price=10 → returns 10\n// Step 2: sum=10, price=20 → returns 30\n// Step 3: sum=30, price=30 → returns 60\n// Result: 60\n\nExample - Build object:\nlet fruits = ['apple', 'banana', 'apple'];\nlet counts = fruits.reduce((obj, fruit) => {\n  obj[fruit] = (obj[fruit] || 0) + 1;\n  return obj;\n}, {});\n// Result: {apple: 2, banana: 1}\n\nCallback function parameters:\n- **accumulator**: The accumulated value (result so far)\n- **currentValue**: Current item being processed\n- **index**: Current index (optional)\n- **array**: Original array (optional)\n\nInitial value:\n- Second argument to reduce()\n- Starting point for accumulator\n- Common values: 0 (for sums), '' (for strings), {} (for objects), [] (for arrays)\n- If omitted, first array element is used\n\nReturn value patterns:\n- find: single item or undefined\n- filter: new array (could be empty)\n- map: new array (same length as original)\n- reduce: single value of ANY type (number, string, object, array, etc.)\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Expecting find() to return all matches:\n   arr.find(x => x > 5)  // Returns FIRST match only\n   arr.filter(x => x > 5)  // Returns ALL matches\n\n2. Forgetting that map() always returns same-length array:\n   [1, 2, 3].map(x => x * 2)  // [2, 4, 6] - still 3 items\n   // Can't make array shorter with map, use filter for that\n\n3. Confusing filter and map:\n   filter: selects items (can make array shorter)\n   map: transforms items (same length)\n\n4. Not returning in the callback:\n   arr.map(x => { x * 2 })  // Returns [undefined, undefined, ...]\n   arr.map(x => x * 2)  // Correct - implicit return\n   arr.map(x => { return x * 2 })  // Also correct - explicit return\n\n5. Forgetting these don't modify original:\n   let arr = [1, 2, 3];\n   arr.map(x => x * 2);  // arr is still [1, 2, 3]!\n   let doubled = arr.map(x => x * 2);  // Save the result!"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "You have a list of student objects. Use array methods to:\n1. Find the first student with a grade >= 90\n2. Filter to get all students who passed (grade >= 60)\n3. Map to get an array of just the student names\n\nlet students = [\n  {name: 'Alice', grade: 85},\n  {name: 'Bob', grade: 92},\n  {name: 'Charlie', grade: 58},\n  {name: 'Diana', grade: 95}\n];",
              "starterCode": "let students = [\n  {name: 'Alice', grade: 85},\n  {name: 'Bob', grade: 92},\n  {name: 'Charlie', grade: 58},\n  {name: 'Diana', grade: 95}\n];\n\n// Find first with grade >= 90\n\n// Filter students who passed (>= 60)\n\n// Map to get just names\n",
              "solution": "let students = [\n  {name: 'Alice', grade: 85},\n  {name: 'Bob', grade: 92},\n  {name: 'Charlie', grade: 58},\n  {name: 'Diana', grade: 95}\n];\n\nlet topStudent = students.find(s => s.grade >= 90);\nconsole.log('Top student:', topStudent);  // Bob\n\nlet passed = students.filter(s => s.grade >= 60);\nconsole.log('Passed:', passed);  // Alice, Bob, Diana\n\nlet names = students.map(s => s.name);\nconsole.log('All names:', names);  // ['Alice', 'Bob', 'Charlie', 'Diana']",
              "hints": [
                "find(s => s.grade >= 90), filter(s => s.grade >= 60), map(s => s.name)"
              ],
              "testCases": [
                {
                  "description": "Finds first top student",
                  "input": "let students = [{name: 'Alice', grade: 85}, {name: 'Bob', grade: 92}]; let top = students.find(s => s.grade >= 90); console.log(top.name);",
                  "expectedOutput": "Bob"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-05-5-4",
          "title": "Dictionaries: Storing Information with Labels (Objects)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Dictionaries: Storing Information with Labels (Objects)\n\n## Understanding the Concept\n\nImagine you're filling out a form about yourself:\n\nName: Alice\nAge: 25\nCity: New York\nIs Student: true\n\nEach piece of info has a LABEL (Name, Age, etc.) and a VALUE ('Alice', 25, etc.). This is different from an array, where items are accessed by position numbers. Here, you access items by NAME.\n\nIn JavaScript, this is called an OBJECT. Think of it like a real dictionary: you look up a WORD (the key) to find its DEFINITION (the value). Or like a person's contact card: each field (label) has a value.\n\nObjects are perfect for representing things with named properties: a user, a product, a car, etc.\n\n## Code Example\n\n```javascript\n// Creating an object\nlet person = {\n  name: 'Alice',\n  age: 25,\n  city: 'New York',\n  isStudent: false\n};\n\n// Accessing properties (two ways)\nconsole.log(person.name);      // Alice (dot notation)\nconsole.log(person['age']);    // 25 (bracket notation)\n\n// Changing a property\nperson.age = 26;\nconsole.log(person.age);  // 26\n\n// Adding a new property\nperson.email = 'alice@example.com';\nconsole.log(person.email);  // alice@example.com\n\n// Deleting a property\ndelete person.isStudent;\nconsole.log(person.isStudent);  // undefined\n\n// Object with different types\nlet product = {\n  name: 'Laptop',\n  price: 999.99,\n  inStock: true,\n  specs: ['16GB RAM', '512GB SSD'],  // Array inside object!\n  manufacturer: {\n    name: 'Dell',\n    country: 'USA'\n  }  // Object inside object!\n};\n\nconsole.log(product.specs[0]);  // 16GB RAM\nconsole.log(product.manufacturer.name);  // Dell\n\n// Empty object\nlet empty = {};\n```\n\n## Breaking Down the Syntax\n\nObject syntax:\n\n// Creating an object\nlet objectName = {\n  key1: value1,\n  key2: value2,\n  key3: value3\n};\n\nKey points:\n\n1. Surrounded by curly braces { }\n2. Key-value pairs separated by commas\n3. Key and value separated by colon :\n4. Keys are usually unquoted (unless they have spaces)\n5. Values can be any type\n\nAccessing properties:\n\n// Dot notation (most common)\nobject.propertyName\n\n// Bracket notation (for special cases)\nobject['property name']  // Property has space\nobject[variableName]     // Property name is in a variable\n\nWhen to use brackets:\n- Property name has spaces/special chars: obj['first name']\n- Property name is in a variable: let prop = 'age'; obj[prop]\n- Property name is computed: obj['item' + i]\n\nModifying objects:\n\n// Change existing property\nobj.name = 'new value';\n\n// Add new property\nobj.newProperty = 'value';\n\n// Delete property\ndelete obj.property;\n\n// Check if property exists\nif (obj.property !== undefined) { }\n// OR\nif ('property' in obj) { }\n\nNested structures:\nlet user = {\n  name: 'Alice',\n  address: {\n    street: '123 Main St',\n    city: 'NYC'\n  },\n  hobbies: ['reading', 'coding']\n};\n\nuser.address.city  // NYC\nuser.hobbies[0]    // reading\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Forgetting commas between properties:\n   {name: 'Alice' age: 25}  // WRONG - missing comma\n   {name: 'Alice', age: 25}  // CORRECT\n\n2. Using = instead of ::\n   {name = 'Alice'}  // WRONG\n   {name: 'Alice'}   // CORRECT\n\n3. Trailing comma on last property:\n   {name: 'Alice', age: 25,}  // Works in modern JS, but some old browsers error\n\n4. Confusing arrays and objects:\n   let arr = [1, 2, 3];    // Square brackets\n   let obj = {a: 1, b: 2}; // Curly braces\n\n5. Trying to use dot notation with spaces:\n   obj.first name  // WRONG\n   obj['first name']  // CORRECT\n   obj.firstName   // BETTER - use camelCase\n\n6. Expecting specific order:\n   Objects don't guarantee property order (though modern JS usually preserves it)\n   If order matters, use an array!"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create an object representing a book:\n1. Create object with: title (string), author (string), pages (number), isRead (boolean)\n2. Display the title\n3. Change isRead to true\n4. Add a new property 'rating' with a number 1-5\n5. Display the entire object",
              "starterCode": "// Create your book object\n\n// Display title\n\n// Mark as read\n\n// Add rating\n\n// Display object\n",
              "solution": "let book = {\n  title: '1984',\n  author: 'George Orwell',\n  pages: 328,\n  isRead: false\n};\n\nconsole.log('Title:', book.title);\n\nbook.isRead = true;\n\nbook.rating = 5;\n\nconsole.log('Book:', book);",
              "hints": [
                "let book = {title: '...', author: '...', pages: 300, isRead: false};"
              ],
              "testCases": [
                {
                  "description": "Creates book object correctly",
                  "input": "let book = {title: 'Harry Potter', author: 'J.K. Rowling', pages: 300, isRead: false}; console.log(book.title);",
                  "expectedOutput": "Harry Potter"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-05-5-5",
          "title": "Working with Object Properties (Iterating and Manipulating)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Working with Object Properties (Iterating and Manipulating)\n\n## Understanding the Concept\n\nImagine you're a store clerk inventorying products. You need to go through each product and check its details:\n\n'Product 1: Name = Laptop, Price = $1000'\n'Product 2: Name = Mouse, Price = $25'\n\nJust like we looped through arrays, we need to loop through objects. But objects don't have index numbers - they have property NAMES. JavaScript gives us special tools to work with object properties: get all keys, all values, or all key-value pairs.\n\n## Code Example\n\n```javascript\nlet student = {\n  name: 'Alice',\n  age: 20,\n  grade: 'A',\n  major: 'Computer Science'\n};\n\n// Get all property names (keys)\nlet keys = Object.keys(student);\nconsole.log(keys);  // ['name', 'age', 'grade', 'major']\n\n// Get all property values\nlet values = Object.values(student);\nconsole.log(values);  // ['Alice', 20, 'A', 'Computer Science']\n\n// Get all key-value pairs\nlet entries = Object.entries(student);\nconsole.log(entries);  // [['name', 'Alice'], ['age', 20], ...]\n\n// Loop through keys\nfor (let key of Object.keys(student)) {\n  console.log(key + ': ' + student[key]);\n}\n\n// Loop through key-value pairs (more elegant)\nfor (let [key, value] of Object.entries(student)) {\n  console.log(key + ': ' + value);\n}\n\n// for...in loop (older way)\nfor (let key in student) {\n  console.log(key + ': ' + student[key]);\n}\n\n// Practical: calculate total prices\nlet cart = {\n  laptop: 1000,\n  mouse: 25,\n  keyboard: 75\n};\n\nlet total = 0;\nfor (let price of Object.values(cart)) {\n  total += price;\n}\nconsole.log('Total: $' + total);  // $1100\n```\n\n## Breaking Down the Syntax\n\nThree key Object methods:\n\n1. **Object.keys(obj)**\n   - Returns array of property names\n   - {a: 1, b: 2} → ['a', 'b']\n   - Use when you need property names\n\n2. **Object.values(obj)**\n   - Returns array of property values\n   - {a: 1, b: 2} → [1, 2]\n   - Use when you only need values\n\n3. **Object.entries(obj)**\n   - Returns array of [key, value] pairs\n   - {a: 1, b: 2} → [['a', 1], ['b', 2]]\n   - Use when you need both keys and values\n\nLoop patterns:\n\n// Pattern 1: Loop through keys\nfor (let key of Object.keys(obj)) {\n  console.log(key);          // Property name\n  console.log(obj[key]);     // Property value\n}\n\n// Pattern 2: Loop through values\nfor (let value of Object.values(obj)) {\n  console.log(value);  // Just the values\n}\n\n// Pattern 3: Loop through entries (destructuring)\nfor (let [key, value] of Object.entries(obj)) {\n  console.log(key, value);  // Both at once\n}\n\n// Pattern 4: for...in loop (older)\nfor (let key in obj) {\n  console.log(key, obj[key]);\n}\n\nDestructuring in loops:\n// This:\nfor (let entry of Object.entries(obj)) {\n  let key = entry[0];\n  let value = entry[1];\n}\n\n// Can be written as:\nfor (let [key, value] of Object.entries(obj)) {\n  // key and value are extracted automatically!\n}\n\nCounting properties:\nObject.keys(obj).length  // Number of properties\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Calling Object.keys() on non-object:\n   Object.keys([1,2,3])  // Works but returns ['0', '1', '2'] (indices as strings)\n   Object.keys('hello')  // Works but returns ['0', '1', '2', '3', '4']\n   \n2. Forgetting Object.keys() returns an array:\n   Object.keys(obj)  // Returns ARRAY of keys\n   // Must loop through: for (let key of Object.keys(obj))\n\n3. Confusing for...of and for...in:\n   for (let key of obj)  // ERROR - objects aren't iterable with for...of\n   for (let key in obj)  // CORRECT - for...in works on objects\n   for (let key of Object.keys(obj))  // ALSO CORRECT\n\n4. Not using destructuring with entries:\n   for (let entry of Object.entries(obj)) {\n     console.log(entry[0], entry[1]);  // Works but clunky\n   }\n   for (let [key, value] of Object.entries(obj)) {\n     console.log(key, value);  // Much cleaner!\n   }\n\n5. Expecting specific order:\n   Object properties don't have a guaranteed order\n   (Though modern JS usually maintains insertion order)"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "You have a product inventory object. Calculate:\n1. Total number of products (count of properties)\n2. Total value of all inventory (sum of all prices)\n3. Display each product with its price\n\nlet inventory = {\n  laptop: 1200,\n  mouse: 30,\n  keyboard: 80,\n  monitor: 350\n};",
              "starterCode": "let inventory = {\n  laptop: 1200,\n  mouse: 30,\n  keyboard: 80,\n  monitor: 350\n};\n\n// Count products\n\n// Calculate total value\n\n// Display each product\n",
              "solution": "let inventory = {\n  laptop: 1200,\n  mouse: 30,\n  keyboard: 80,\n  monitor: 350\n};\n\nlet productCount = Object.keys(inventory).length;\nconsole.log('Total products: ' + productCount);\n\nlet totalValue = 0;\nfor (let price of Object.values(inventory)) {\n  totalValue += price;\n}\nconsole.log('Total inventory value: $' + totalValue);\n\nconsole.log('Product list:');\nfor (let [product, price] of Object.entries(inventory)) {\n  console.log(product + ': $' + price);\n}",
              "hints": [
                "Object.keys(inventory).length for count, loop through Object.values() to sum"
              ],
              "testCases": [
                {
                  "description": "Counts products correctly",
                  "input": "let inventory = {laptop: 1200, mouse: 30}; console.log(Object.keys(inventory).length);",
                  "expectedOutput": "2"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "module-06",
      "title": "Module 6: Creating Reusable Tools (The 'Recipes')",
      "description": "Write code once and reuse it many times with functions",
      "difficulty": "intermediate",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-06-6-1",
          "title": "What Is a Function? (The Recipe Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# What Is a Function? (The Recipe Analogy)\n\n## Understanding the Concept\n\nA recipe is a list of instructions for making a specific dish. Once you write the recipe down, you can use it over and over without rewriting the steps each time.\n\nA function in programming is exactly like a recipe:\n- It has a NAME (e.g., 'Make Pancakes')\n- It has INGREDIENTS (inputs, called 'parameters')\n- It has INSTRUCTIONS (the code inside)\n- It produces a RESULT (output, called a 'return value')\n\nJust like you can call out 'Make Pancakes!' and the recipe executes, in code you can 'call' a function and it executes its instructions. Functions let you avoid repeating the same code - write once, use many times!\n\n## Code Example\n\n```javascript\n// Defining a function\nfunction sayHello() {\n  console.log('Hello, World!');\n}\n\n// Calling (using) the function\nsayHello();  // Hello, World!\nsayHello();  // Hello, World!\n// Can call as many times as you want!\n\n// Function with a parameter (ingredient)\nfunction greet(name) {\n  console.log('Hello, ' + name + '!');\n}\n\ngreet('Alice');   // Hello, Alice!\ngreet('Bob');     // Hello, Bob!\ngreet('Charlie'); // Hello, Charlie!\n\n// Function that returns a value\nfunction add(a, b) {\n  return a + b;\n}\n\nlet sum = add(5, 3);\nconsole.log(sum);  // 8\n\nlet result = add(10, 20);\nconsole.log(result);  // 30\n```\n\n## Breaking Down the Syntax\n\nFunction anatomy:\n\nfunction functionName(parameter1, parameter2) {\n│        │            │                      │\n│        │            └──────────────────────┴─ Parameters (inputs)\n│        └──────────────────────────────────── Name (you choose)\n└───────────────────────────────────────────── 'function' keyword\n  // Code to run\n  return result;  // Optional: send back a value\n}\n\nKey parts:\n\n1. **function keyword** - Tells JavaScript you're creating a function\n\n2. **Name** - What you call the function (use camelCase)\n   - Should describe what it does: calculateTotal, getUserName, etc.\n\n3. **Parameters** - Inputs the function needs (inside parentheses)\n   - Can have 0, 1, 2, or many parameters\n   - Separated by commas\n   - Like variables that exist only inside the function\n\n4. **Function body** - The code inside { }\n   - The instructions to execute\n\n5. **return statement** - Sends a value back (optional)\n   - Function stops executing when it hits return\n   - If no return, function returns undefined\n\nCalling a function:\nfunctionName(argument1, argument2);\n\n- Use the function name\n- Add parentheses ()\n- Pass arguments (values) for parameters\n\nWithout () it's just a reference:\ngreet     // The function itself (reference)\ngreet()   // Calling the function (execution)\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Forgetting parentheses when calling:\n   greet  // Doesn't execute - just references the function\n   greet()  // Executes the function\n\n2. Confusing parameters and arguments:\n   function greet(name) { }  // 'name' is a parameter (placeholder)\n   greet('Alice');  // 'Alice' is an argument (actual value)\n\n3. Not returning a value when you need one:\n   function add(a, b) {\n     a + b;  // WRONG - doesn't return anything!\n   }\n   function add(a, b) {\n     return a + b;  // CORRECT\n   }\n\n4. Code after return never runs:\n   function test() {\n     return 5;\n     console.log('This never runs!');  // Unreachable\n   }\n\n5. Wrong number of arguments:\n   function add(a, b) { return a + b; }\n   add(5);  // b is undefined, returns NaN\n   add(5, 3, 7);  // Extra argument ignored, returns 8"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a function that converts Celsius to Fahrenheit:\n1. Name it celsiusToFahrenheit\n2. It should take one parameter: celsius\n3. Formula: (celsius * 9/5) + 32\n4. Return the result\n5. Test by calling it with 0, 100, and 37",
              "starterCode": "// Define your function here\n\n// Test it\nconsole.log(celsiusToFahrenheit(0));    // Should be 32\nconsole.log(celsiusToFahrenheit(100));  // Should be 212\nconsole.log(celsiusToFahrenheit(37));   // Should be 98.6",
              "solution": "function celsiusToFahrenheit(celsius) {\n  return (celsius * 9/5) + 32;\n}\n\nconsole.log(celsiusToFahrenheit(0));    // 32\nconsole.log(celsiusToFahrenheit(100));  // 212\nconsole.log(celsiusToFahrenheit(37));   // 98.6",
              "hints": [
                "function celsiusToFahrenheit(celsius) { return (celsius * 9/5) + 32; }"
              ],
              "testCases": [
                {
                  "description": "Converts 0°C correctly",
                  "input": "function celsiusToFahrenheit(celsius) { return (celsius * 9/5) + 32; } console.log(celsiusToFahrenheit(0));",
                  "expectedOutput": "32"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-06-6-2",
          "title": "The Modern Shorthand (Arrow Functions =>)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# The Modern Shorthand (Arrow Functions =>)\n\n## Understanding the Concept\n\nImagine you have two ways to give someone your address:\n\n**Long form**: 'My address is 123 Main Street, New York, NY 10001'\n\n**Short form**: '123 Main St, NYC'\n\nBoth give the same information, but the short form is quicker for simple cases. Arrow functions (=>) are the 'short form' for writing functions in modern JavaScript. They do the same thing as regular functions, but with less typing for simple cases.\n\n## Code Example\n\n```javascript\n// Traditional function\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow function (same thing, shorter)\nconst add = (a, b) => {\n  return a + b;\n};\n\n// Even shorter (implicit return for one-liners)\nconst add = (a, b) => a + b;\n\n// Examples of different arrow function forms\n\n// No parameters\nconst sayHello = () => console.log('Hello!');\nsayHello();  // Hello!\n\n// One parameter (parentheses optional)\nconst double = num => num * 2;\nconsole.log(double(5));  // 10\n\n// Multiple parameters (need parentheses)\nconst multiply = (a, b) => a * b;\nconsole.log(multiply(3, 4));  // 12\n\n// Multiple lines (need curly braces and explicit return)\nconst greetPerson = (name) => {\n  let greeting = 'Hello, ' + name;\n  return greeting + '!';\n};\nconsole.log(greetPerson('Alice'));  // Hello, Alice!\n\n// Using with array methods\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = numbers.map(n => n * 2);\nconsole.log(doubled);  // [2, 4, 6, 8, 10]\n```\n\n## Breaking Down the Syntax\n\nArrow function syntax:\n\nconst functionName = (parameters) => { body };\n│     │              │            │  │      │\n│     │              │            │  │      └─ Function body\n│     │              │            │  └──────── Arrow\n│     │              └────────────┴─────────── Parameters\n│     └──────────────────────────────────────── Name\n└────────────────────────────────────────────── const (or let)\n\nShorthand rules:\n\n1. **No parameters**: Use empty ()\n   const greet = () => 'Hello';\n\n2. **One parameter**: Parentheses optional\n   const double = x => x * 2;\n   const double = (x) => x * 2;  // Also valid\n\n3. **Multiple parameters**: Need parentheses\n   const add = (a, b) => a + b;\n\n4. **One-line body**: Can omit { } and return\n   const add = (a, b) => a + b;  // Implicit return\n\n5. **Multi-line body**: Need { } and explicit return\n   const greet = (name) => {\n     let msg = 'Hello, ' + name;\n     return msg;\n   };\n\nComparing to traditional functions:\n\n// Traditional\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow (full form)\nconst add = (a, b) => {\n  return a + b;\n};\n\n// Arrow (short form)\nconst add = (a, b) => a + b;\n\nWhen to use arrow functions:\n✓ Short, simple functions\n✓ Callback functions (map, filter, etc.)\n✓ Modern JavaScript style\n\nWhen to use traditional functions:\n✓ Methods in objects/classes\n✓ Need 'this' keyword (advanced)\n✓ Personal preference for readability\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Forgetting parentheses with multiple parameters:\n   const add = a, b => a + b;  // WRONG\n   const add = (a, b) => a + b;  // CORRECT\n\n2. Forgetting curly braces for multi-line:\n   const greet = name =>\n     let msg = 'Hello';\n     return msg;  // WRONG - syntax error\n   \n   const greet = name => {\n     let msg = 'Hello';\n     return msg;  // CORRECT\n   };\n\n3. Trying to return an object without parentheses:\n   const getUser = () => {name: 'Alice'};  // WRONG - thinks { } is function body\n   const getUser = () => ({name: 'Alice'});  // CORRECT - wrapped in ()\n\n4. Using arrow function as method:\n   const person = {\n     name: 'Alice',\n     greet: () => console.log(this.name)  // WRONG - 'this' doesn't work as expected\n   };\n   Use traditional function for object methods\n\n5. Mixing up = and =>:\n   const add = (a, b) = a + b;  // WRONG - single =\n   const add = (a, b) => a + b;  // CORRECT - arrow =>"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Convert these traditional functions to arrow functions:\n\n1. function square(x) { return x * x; }\n2. function isEven(num) { return num % 2 === 0; }\n3. function getFullName(first, last) { return first + ' ' + last; }\n\nUse the shortest form possible!",
              "starterCode": "// Convert to arrow functions\nconst square = // YOUR CODE HERE\n\nconst isEven = // YOUR CODE HERE\n\nconst getFullName = // YOUR CODE HERE\n\n// Test them\nconsole.log(square(5));  // 25\nconsole.log(isEven(4));  // true\nconsole.log(getFullName('John', 'Doe'));  // John Doe",
              "solution": "const square = x => x * x;\n\nconst isEven = num => num % 2 === 0;\n\nconst getFullName = (first, last) => first + ' ' + last;\n\n// Test them\nconsole.log(square(5));  // 25\nconsole.log(isEven(4));  // true\nconsole.log(getFullName('John', 'Doe'));  // John Doe",
              "hints": [
                "Use: const name = params => expression"
              ],
              "testCases": [
                {
                  "description": "Square function works",
                  "input": "const square = x => x * x; console.log(square(5));",
                  "expectedOutput": "25"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-06-6-3",
          "title": "Ingredients and Results (Parameters and Return Values)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Ingredients and Results (Parameters and Return Values)\n\n## Understanding the Concept\n\nA coffee machine is a perfect analogy for functions with parameters and return values:\n\n**Inputs (Parameters)**: You put in coffee beans, water, and select a size\n**Process**: The machine does its work inside (you don't see this)\n**Output (Return Value)**: You get a cup of coffee\n\nSimilarly, a function:\n- Takes INPUTS (parameters)\n- Does some PROCESSING (the function body)\n- Gives back an OUTPUT (return value)\n\nJust like you can put different beans in the coffee machine and get different coffee, you can pass different parameters to a function and get different results.\n\n## Code Example\n\n```javascript\n// Function with one parameter\nfunction greet(name) {\n  return 'Hello, ' + name + '!';\n}\n\nlet message = greet('Alice');\nconsole.log(message);  // Hello, Alice!\n\n// Function with multiple parameters\nfunction calculateArea(width, height) {\n  return width * height;\n}\n\nlet area = calculateArea(5, 10);\nconsole.log(area);  // 50\n\n// Parameters with default values (ES2015+)\nfunction greet(name = 'Guest') {\n  return 'Hello, ' + name + '!';\n}\n\nconsole.log(greet());        // Hello, Guest!\nconsole.log(greet('Bob'));   // Hello, Bob!\n\n// Function that doesn't return (returns undefined)\nfunction logMessage(msg) {\n  console.log(msg);\n  // No return statement\n}\n\nlet result = logMessage('Test');\nconsole.log(result);  // undefined\n\n// Returning early\nfunction divide(a, b) {\n  if (b === 0) {\n    return 'Cannot divide by zero';\n  }\n  return a / b;\n}\n\nconsole.log(divide(10, 2));  // 5\nconsole.log(divide(10, 0));  // Cannot divide by zero\n\n// Returning objects\nfunction createUser(name, age) {\n  return {\n    name: name,\n    age: age,\n    isAdult: age >= 18\n  };\n}\n\nlet user = createUser('Alice', 25);\nconsole.log(user);  // {name: 'Alice', age: 25, isAdult: true}\n```\n\n## Breaking Down the Syntax\n\nUnderstanding parameters and returns:\n\n**Parameters** (Function Definition):\nfunction doSomething(param1, param2, param3) {\n                     │      │      │\n                     └──────┴──────┴─ Placeholders for values\n}\n\n**Arguments** (Function Call):\ndoSomething(value1, value2, value3);\n            │       │       │\n            └───────┴───────┴─ Actual values passed in\n\nParameter patterns:\n\n1. **No parameters**:\n   function sayHello() {\n     return 'Hello!';\n   }\n\n2. **One parameter**:\n   function double(x) {\n     return x * 2;\n   }\n\n3. **Multiple parameters**:\n   function add(a, b) {\n     return a + b;\n   }\n\n4. **Default parameters** (ES2015):\n   function greet(name = 'Guest', greeting = 'Hello') {\n     return greeting + ', ' + name;\n   }\n   greet();  // Hello, Guest\n   greet('Alice');  // Hello, Alice\n   greet('Bob', 'Hi');  // Hi, Bob\n\n5. **Rest parameters** (collect all remaining args):\n   function sum(...numbers) {\n     return numbers.reduce((total, n) => total + n, 0);\n   }\n   sum(1, 2, 3, 4);  // 10\n\nReturn value patterns:\n\n1. **Return a value**:\n   return 42;\n   return 'text';\n   return true;\n\n2. **Return early** (exit function immediately):\n   if (error) {\n     return 'Error';\n   }\n   // Rest of function\n\n3. **No return** (implicitly returns undefined):\n   function doSomething() {\n     console.log('Done');\n   }\n\n4. **Return object** (use parentheses with arrow functions):\n   const getUser = () => ({name: 'Alice', age: 25});\n\n5. **Return another function**:\n   function outer() {\n     return function inner() {\n       return 'Hello';\n     };\n   }\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Wrong number of arguments:\n   function add(a, b) { return a + b; }\n   add(5);  // b is undefined, returns NaN\n   add(5, 3, 7);  // 7 is ignored\n\n2. Not returning the value:\n   function add(a, b) {\n     a + b;  // Calculated but not returned!\n   }\n   let result = add(5, 3);  // undefined\n\n3. Trying to use parameters outside function:\n   function greet(name) {\n     return 'Hello, ' + name;\n   }\n   console.log(name);  // ERROR - name only exists inside function\n\n4. Forgetting to call the function:\n   let result = add;  // result is the function itself\n   let result = add(5, 3);  // result is 8\n\n5. Returning in wrong place:\n   function test() {\n     if (true) {\n       let x = 5;\n       return x;  // WRONG - x might not be accessible\n     }\n   }\n   Better: calculate first, then return"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a function called calculateGrade that:\n1. Takes one parameter: score (a number 0-100)\n2. Returns a letter grade based on:\n   - 90+ = 'A'\n   - 80-89 = 'B'\n   - 70-79 = 'C'\n   - 60-69 = 'D'\n   - Below 60 = 'F'\n3. Test with scores: 95, 87, 72, 65, 45",
              "starterCode": "function calculateGrade(score) {\n  // YOUR CODE HERE\n}\n\n// Test\nconsole.log(calculateGrade(95));  // Should be 'A'\nconsole.log(calculateGrade(87));  // Should be 'B'\nconsole.log(calculateGrade(72));  // Should be 'C'",
              "solution": "function calculateGrade(score) {\n  if (score >= 90) {\n    return 'A';\n  } else if (score >= 80) {\n    return 'B';\n  } else if (score >= 70) {\n    return 'C';\n  } else if (score >= 60) {\n    return 'D';\n  } else {\n    return 'F';\n  }\n}\n\nconsole.log(calculateGrade(95));  // A\nconsole.log(calculateGrade(87));  // B\nconsole.log(calculateGrade(72));  // C\nconsole.log(calculateGrade(65));  // D\nconsole.log(calculateGrade(45));  // F",
              "hints": [
                "Use if/else if/else with return statements"
              ],
              "testCases": [
                {
                  "description": "Returns 'A' for 95",
                  "input": "function calculateGrade(score) { if (score >= 90) return 'A'; if (score >= 80) return 'B'; if (score >= 70) return 'C'; if (score >= 60) return 'D'; return 'F'; } console.log(calculateGrade(95));",
                  "expectedOutput": "A"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-06-6-4",
          "title": "What's 'In the Kitchen'? (Scope and Variable Visibility)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# What's 'In the Kitchen'? (Scope and Variable Visibility)\n\n## Understanding the Concept\n\nImagine a restaurant with different areas:\n\n**The Kitchen** (Function Scope): Chefs can use all the kitchen tools and ingredients. But customers in the dining room can't reach into the kitchen and grab a spatula.\n\n**The Dining Room** (Global Scope): Everyone can see and use things here - tables, chairs, menus.\n\n**A Chef's Personal Station** (Block Scope): Each chef has their own station. Their tools are theirs - other chefs can't use them.\n\nThis is SCOPE in programming - which parts of your code can 'see' and use which variables. Variables declared inside a function are like kitchen tools - only accessible inside that function. Variables declared outside are like the dining room - everyone can access them.\n\n## Code Example\n\n```javascript\n// Global scope - accessible everywhere\nlet globalVar = 'I am global';\n\nfunction testScope() {\n  // Function scope - only accessible inside this function\n  let localVar = 'I am local';\n  \n  console.log(globalVar);  // Works - can access global\n  console.log(localVar);   // Works - we're inside the function\n}\n\ntestScope();\nconsole.log(globalVar);  // Works - global is accessible\n// console.log(localVar);   // ERROR - localVar doesn't exist here!\n\n// Block scope (let and const)\nif (true) {\n  let blockVar = 'I am in a block';\n  const alsoBlock = 'Me too';\n  var notBlock = 'I escape!';\n  \n  console.log(blockVar);  // Works\n}\n\n// console.log(blockVar);  // ERROR - blockVar is block-scoped\nconsole.log(notBlock);   // Works - var ignores block scope (bad!)\n\n// Nested scopes\nlet outer = 'outer';\n\nfunction outerFunc() {\n  let middle = 'middle';\n  \n  function innerFunc() {\n    let inner = 'inner';\n    \n    console.log(outer);   // Works - can see outer\n    console.log(middle);  // Works - can see parent\n    console.log(inner);   // Works - own scope\n  }\n  \n  innerFunc();\n  // console.log(inner);  // ERROR - can't see child scope\n}\n\nouterFunc();\n\n// Shadowing (be careful!)\nlet name = 'Global Alice';\n\nfunction greet() {\n  let name = 'Local Bob';  // Different variable!\n  console.log(name);  // Local Bob\n}\n\ngreet();\nconsole.log(name);  // Global Alice\n```\n\n## Breaking Down the Syntax\n\nUnderstanding scope:\n\n**1. Global Scope**\n- Variables declared outside any function\n- Accessible everywhere in your code\n- Use sparingly - can cause naming conflicts\n\nlet globalVar = 'accessible everywhere';\n\nfunction anywhere() {\n  console.log(globalVar);  // Can access\n}\n\n**2. Function Scope**\n- Variables declared inside a function\n- Only accessible inside that function\n- Includes parameters\n\nfunction myFunc(param) {  // param has function scope\n  let localVar = 'only here';  // localVar has function scope\n}\n\n**3. Block Scope** (let and const only)\n- Variables declared inside { }\n- Only accessible inside that block\n- if, for, while, etc. create blocks\n\nif (true) {\n  let x = 5;  // Block scoped\n  const y = 10;  // Block scoped\n  var z = 15;  // Function scoped (escapes block!)\n}\n\n**Scope Chain** (looking up variables):\n\nlet a = 'global';\n\nfunction outer() {\n  let b = 'outer';\n  \n  function inner() {\n    let c = 'inner';\n    \n    // JavaScript looks for variables in this order:\n    // 1. Current scope (inner) - c\n    // 2. Parent scope (outer) - b\n    // 3. Grandparent scope (global) - a\n  }\n}\n\n**Best Practices**:\n\n1. Use let and const (not var)\n   - They respect block scope\n   - Prevent accidental global variables\n\n2. Keep variables in smallest scope needed\n   - Declare inside functions/blocks when possible\n   - Reduces naming conflicts\n\n3. Avoid global variables\n   - Hard to track who modifies them\n   - Can cause bugs\n\n4. Don't shadow variables (same name in nested scopes)\n   - Confusing to read\n   - Use different names\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Using variables outside their scope:\n   function test() {\n     let x = 5;\n   }\n   console.log(x);  // ERROR - x only exists inside test()\n\n2. Forgetting var escapes block scope:\n   if (true) {\n     var x = 5;  // Function scoped, not block scoped!\n   }\n   console.log(x);  // 5 - var leaks out\n   \n   Always use let/const, never var!\n\n3. Shadowing by accident:\n   let name = 'Alice';\n   function greet() {\n     let name = 'Bob';  // Different variable!\n   }\n   Confusing - use different names\n\n4. Trying to access parameters outside function:\n   function add(a, b) {\n     return a + b;\n   }\n   console.log(a);  // ERROR - parameters are function-scoped\n\n5. Not understanding hoisting:\n   console.log(x);  // undefined (not error with var)\n   var x = 5;\n   \n   vs\n   \n   console.log(x);  // ERROR - cannot access before initialization\n   let x = 5;\n   \n   Another reason to use let/const!"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Debug this code - it has scope issues:\n\nfunction calculateTotal() {\n  let price = 100;\n  let tax = 0.08;\n  \n  if (price > 50) {\n    let discount = 10;\n  }\n  \n  let total = price - discount + (price * tax);\n  return total;\n}\n\nFix it so discount is accessible. Then calculate the total correctly.",
              "starterCode": "function calculateTotal() {\n  let price = 100;\n  let tax = 0.08;\n  \n  if (price > 50) {\n    let discount = 10;\n  }\n  \n  let total = price - discount + (price * tax);\n  return total;\n}\n\nconsole.log(calculateTotal());",
              "solution": "function calculateTotal() {\n  let price = 100;\n  let tax = 0.08;\n  let discount = 0;  // Declare in function scope\n  \n  if (price > 50) {\n    discount = 10;  // Assign (no let)\n  }\n  \n  let total = price - discount + (price * tax);\n  return total;\n}\n\nconsole.log(calculateTotal());  // 98",
              "hints": [
                "Declare discount outside the if block, or move the calculation inside"
              ],
              "testCases": [
                {
                  "description": "Calculates total correctly",
                  "input": "function calculateTotal() { let price = 100; let tax = 0.08; let discount = 0; if (price > 50) { discount = 10; } let total = price - discount + (price * tax); return total; } console.log(calculateTotal());",
                  "expectedOutput": "98"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "module-07",
      "title": "Module 7: Working with the Web Page (The 'Browser')",
      "description": "Make your code interact with HTML and create dynamic web pages",
      "difficulty": "intermediate",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-07-7-1",
          "title": "The Three Layers of a Webpage (HTML, CSS, and JavaScript)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# The Three Layers of a Webpage (HTML, CSS, and JavaScript)\n\n## Understanding the Concept\n\nBuilding a house has three distinct phases:\n\n**HTML (The Structure)**: This is like the wooden frame of a house - the walls, roof, floors. It defines WHAT exists (rooms, doors, windows) but not how they look or behave.\n\n**CSS (The Styling)**: This is like painting, decorating, choosing furniture. It makes the structure LOOK good - colors, fonts, layouts, spacing.\n\n**JavaScript (The Behavior)**: This is like the electrical wiring, plumbing, security system. It makes things WORK - lights turn on/off, doors lock/unlock, alarms sound.\n\nYou need all three! A house with just a frame is boring. A house with no wiring doesn't work. Together, they create a complete, functional, beautiful home.\n\n## Code Example\n\n```javascript\n<!-- HTML: The structure (skeleton) -->\n<!DOCTYPE html>\n<html>\n<head>\n  <title>My Page</title>\n  <!-- CSS: The styling (clothes) -->\n  <style>\n    h1 {\n      color: blue;        /* Make heading blue */\n      font-size: 32px;    /* Make it big */\n    }\n    .highlight {\n      background-color: yellow;\n    }\n  </style>\n</head>\n<body>\n  <h1 id=\"title\">Hello, World!</h1>\n  <button id=\"myButton\">Click Me!</button>\n  <p id=\"message\"></p>\n\n  <!-- JavaScript: The behavior (brain) -->\n  <script>\n    // This code runs when the page loads\n    \n    // Find the button element\n    let button = document.getElementById('myButton');\n    \n    // Make something happen when button is clicked\n    button.addEventListener('click', function() {\n      // Find the message paragraph\n      let message = document.getElementById('message');\n      \n      // Change its text content\n      message.textContent = 'Button was clicked!';\n      \n      // Add styling class\n      message.className = 'highlight';\n    });\n  </script>\n</body>\n</html>\n```\n\n## Breaking Down the Syntax\n\nUnderstanding the three layers:\n\n**1. HTML (HyperText Markup Language)**\n- Defines the STRUCTURE and CONTENT\n- Uses tags: <tagname>content</tagname>\n- Common tags:\n  - <h1> to <h6>: Headings\n  - <p>: Paragraphs\n  - <div>: Generic container\n  - <button>: Clickable button\n  - <input>: Form input\n- Attributes give extra info:\n  - id=\"unique-name\" (unique identifier)\n  - class=\"style-class\" (styling group)\n\n**2. CSS (Cascading Style Sheets)**\n- Defines how HTML elements LOOK\n- Syntax: selector { property: value; }\n- Can be:\n  - Inline: <p style=\"color: red\">Text</p>\n  - Internal: <style> tags in <head>\n  - External: <link rel=\"stylesheet\" href=\"style.css\">\n- Selectors:\n  - h1 { } - All <h1> tags\n  - #myId { } - Element with id=\"myId\"\n  - .myClass { } - Elements with class=\"myClass\"\n\n**3. JavaScript (The Programming Language)**\n- Makes pages INTERACTIVE and DYNAMIC\n- Can:\n  - Find HTML elements\n  - Change their content\n  - Change their styling\n  - Respond to user actions (clicks, typing, etc.)\n  - Fetch data from servers\n  - Validate forms\n  - Animate elements\n\nHow they work together:\n1. HTML creates structure\n2. CSS makes it pretty\n3. JavaScript makes it interactive\n\nExample flow:\n1. User sees button (HTML)\n2. Button is styled blue (CSS)\n3. User clicks button (JavaScript detects)\n4. Message appears (JavaScript changes HTML)\n5. Message is highlighted (JavaScript adds CSS class)\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Forgetting quotes around IDs:\n   document.getElementById(heading)  // WRONG - thinks heading is a variable\n   document.getElementById('heading')  // CORRECT - string literal\n\n2. Running JavaScript before HTML loads:\n   <script>document.getElementById('myButton')</script>\n   <button id=\"myButton\">Click</button>\n   The script runs before button exists! Put scripts at end of <body>\n\n3. Typos in IDs (case-sensitive!):\n   HTML: <div id=\"myDiv\"></div>\n   JS: document.getElementById('mydiv')  // WRONG - lowercase d\n   JS: document.getElementById('myDiv')  // CORRECT\n\n4. Confusing textContent, innerHTML, and value:\n   - textContent: Text only (safe, no HTML)\n   - innerHTML: HTML content (can be dangerous!)\n   - value: For form inputs (<input>, <textarea>)\n\n5. Forgetting to attach event listener:\n   button.addEventListener('click', myFunction)  // Correct\n   button.addEventListener('click', myFunction())  // WRONG - calls immediately!"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "You'll work with this HTML structure:\n\n<h1 id=\"heading\">Welcome</h1>\n<button id=\"changeButton\">Change Text</button>\n\nWrite JavaScript that:\n1. Finds the heading element (use document.getElementById)\n2. Finds the button element\n3. When button is clicked, change heading text to 'Hello, JavaScript!'",
              "starterCode": "// Find the heading element\nlet heading = document.getElementById('heading');\n\n// Find the button element\nlet button = document.getElementById('changeButton');\n\n// Add click event listener\nbutton.addEventListener('click', function() {\n  // YOUR CODE HERE: Change heading.textContent\n});",
              "solution": "let heading = document.getElementById('heading');\nlet button = document.getElementById('changeButton');\n\nbutton.addEventListener('click', function() {\n  heading.textContent = 'Hello, JavaScript!';\n});",
              "hints": [
                "Inside the click function, use: heading.textContent = 'Hello, JavaScript!';"
              ],
              "testCases": [
                {
                  "description": "Changes heading text on click",
                  "input": "let heading = {textContent: 'Welcome'}; let button = {addEventListener: function(event, callback) { callback(); }}; button.addEventListener('click', function() { heading.textContent = 'Hello, JavaScript!'; }); console.log(heading.textContent);",
                  "expectedOutput": "Hello, JavaScript!"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-07-7-2",
          "title": "The Browser's Live Blueprint (What Is the DOM?)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# The Browser's Live Blueprint (What Is the DOM?)\n\n## Understanding the Concept\n\nImagine you're building with LEGO blocks. You have the instruction manual (HTML code), but you also have the actual LEGO structure you've built (the DOM).\n\nThe **DOM (Document Object Model)** is the browser's LIVE representation of your webpage. It's not the HTML code itself - it's the browser's interpretation of that code, turned into a tree of objects that JavaScript can manipulate.\n\nThink of it like this:\n- **HTML**: Blueprint on paper (static text)\n- **DOM**: Actual LEGO construction (living, changeable structure)\n\nWhen you use JavaScript to change the DOM, you're rebuilding parts of the LEGO structure on the fly. The browser immediately shows your changes on screen.\n\n## Code Example\n\n```javascript\n// The DOM is a tree structure\n// HTML:\n// <html>\n//   <body>\n//     <h1>Title</h1>\n//     <p>Paragraph</p>\n//   </body>\n// </html>\n//\n// Becomes this tree:\n// document\n//   └─ html\n//      └─ body\n//         ├─ h1 (\"Title\")\n//         └─ p (\"Paragraph\")\n\n// Accessing the DOM\nconsole.log(document);  // The entire page\nconsole.log(document.body);  // The <body> element\nconsole.log(document.title);  // Page title\n\n// Finding elements (we'll learn more about this next)\nlet element = document.getElementById('myId');\nlet elements = document.getElementsByClassName('myClass');\nlet firstDiv = document.querySelector('div');\nlet allDivs = document.querySelectorAll('div');\n\n// The DOM is LIVE - changes appear immediately\nlet heading = document.getElementById('title');\nheading.textContent = 'New Title';  // Page updates instantly!\n\n// DOM nodes have properties\nconsole.log(heading.tagName);  // 'H1'\nconsole.log(heading.id);  // 'title'\nconsole.log(heading.className);  // CSS classes\n\n// DOM nodes have relationships (tree structure)\nlet parent = heading.parentElement;  // Element above\nlet children = parent.children;  // Elements below\nlet nextSibling = heading.nextElementSibling;  // Next element at same level\n```\n\n## Breaking Down the Syntax\n\nUnderstanding the DOM:\n\n**What is the DOM?**\n- Browser's representation of the HTML page\n- Tree structure of objects\n- Each HTML element becomes a JavaScript object\n- You can read and modify these objects\n- Changes appear instantly on the page\n\n**DOM Tree Structure:**\n\nHTML:\n<body>\n  <div id=\"container\">\n    <h1>Title</h1>\n    <p>Text</p>\n  </div>\n</body>\n\nDOM Tree:\ndocument\n  └─ body\n     └─ div (id=\"container\")\n        ├─ h1 (\"Title\")\n        └─ p (\"Text\")\n\n**Key DOM Methods:**\n\n1. Finding single elements:\n   - document.getElementById('id')\n   - document.querySelector('selector')\n\n2. Finding multiple elements:\n   - document.getElementsByClassName('class')\n   - document.getElementsByTagName('tag')\n   - document.querySelectorAll('selector')\n\n3. Element properties:\n   - element.textContent (text only)\n   - element.innerHTML (HTML content)\n   - element.value (for inputs)\n   - element.id (element's ID)\n   - element.className (CSS classes)\n   - element.style (inline CSS)\n\n4. Tree navigation:\n   - element.parentElement (parent)\n   - element.children (child elements)\n   - element.nextElementSibling (next)\n   - element.previousElementSibling (previous)\n\n**Important Concepts:**\n\n1. The DOM is LIVE\n   - Changes happen immediately\n   - No need to \"refresh\" or \"save\"\n\n2. Elements are objects\n   - They have properties you can read/write\n   - They have methods you can call\n\n3. Everything is a node\n   - Elements, text, comments, etc.\n   - Forms a tree structure\n\n4. querySelector is modern and flexible\n   - Uses CSS selectors\n   - More powerful than getElementBy...\n   - We'll use this primarily\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Confusing the DOM with HTML:\n   - HTML: Static code you write\n   - DOM: Live structure in browser\n   - Changing HTML file doesn't change running page\n   - Changing DOM changes page immediately\n\n2. Null reference errors:\n   let element = document.getElementById('wrong-id');\n   element.textContent = 'Hi';  // ERROR - element is null!\n   \n   Always check:\n   if (element !== null) {\n     element.textContent = 'Hi';\n   }\n\n3. Mixing up textContent and innerHTML:\n   element.textContent = '<b>Bold</b>';  // Shows literal <b> tags\n   element.innerHTML = '<b>Bold</b>';  // Renders as bold\n   \n   Use textContent for safety (prevents XSS attacks)\n\n4. Timing issues:\n   If JavaScript runs before HTML loads, elements don't exist yet\n   Solution: Put <script> at end of <body> or use DOMContentLoaded event\n\n5. getElementsByClassName returns collection, not array:\n   let items = document.getElementsByClassName('item');\n   items.forEach(...)  // ERROR - not an array!\n   Array.from(items).forEach(...)  // Correct"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Given this HTML:\n<div id=\"container\">\n  <h1 id=\"title\">Original Title</h1>\n  <p id=\"description\">Original description</p>\n</div>\n\nWrite JavaScript that:\n1. Finds the container div\n2. Finds the title h1\n3. Finds the description p\n4. Change title to 'Updated Title'\n5. Change description to 'Updated description'\n6. Log the container's number of children",
              "starterCode": "// Find the elements\nlet container = // YOUR CODE\nlet title = // YOUR CODE\nlet description = // YOUR CODE\n\n// Update content\n// YOUR CODE\n\n// Log number of children\nconsole.log(container.children.length);",
              "solution": "let container = document.getElementById('container');\nlet title = document.getElementById('title');\nlet description = document.getElementById('description');\n\ntitle.textContent = 'Updated Title';\ndescription.textContent = 'Updated description';\n\nconsole.log(container.children.length);  // 2",
              "hints": [
                "Use document.getElementById('id') for each element"
              ],
              "testCases": [
                {
                  "description": "Updates both elements correctly",
                  "input": "let container = {children: {length: 2}}; let title = {textContent: 'Original'}; let description = {textContent: 'Original'}; title.textContent = 'Updated Title'; description.textContent = 'Updated description'; console.log(container.children.length);",
                  "expectedOutput": "2"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-07-7-3",
          "title": "Finding Elements on the Page (querySelector)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Finding Elements on the Page (querySelector)\n\n## Understanding the Concept\n\nImagine you're in a huge library looking for books:\n\n**Old way** (getElementById, getElementsByClassName): You can only search by:\n- Call number (ID): \"Find book #12345\"\n- Category (class): \"Find all books in Science section\"\n\n**New way** (querySelector): You can search by ANYTHING:\n- \"Find the first red book on the third shelf\"\n- \"Find all books by Author X with 'JavaScript' in the title\"\n- \"Find the book inside the Special Collections room\"\n\nquerySelector uses CSS selectors, which means you can find elements in incredibly flexible ways. It's like having a super-powered library search system!\n\n## Code Example\n\n```javascript\n// querySelector finds the FIRST match\n// querySelectorAll finds ALL matches\n\n// By ID (same as getElementById, but with # prefix)\nlet title = document.querySelector('#title');\n\n// By class (same as getElementsByClassName, but with . prefix)\nlet firstItem = document.querySelector('.item');\nlet allItems = document.querySelectorAll('.item');\n\n// By tag name\nlet firstParagraph = document.querySelector('p');\nlet allParagraphs = document.querySelectorAll('p');\n\n// By attribute\nlet input = document.querySelector('[type=\"email\"]');\nlet required = document.querySelectorAll('[required]');\n\n// Combining selectors\nlet redButton = document.querySelector('button.red');\nlet containerDiv = document.querySelector('div#container');\n\n// Descendant selectors (inside)\nlet linkInNav = document.querySelector('nav a');\nlet itemsInList = document.querySelectorAll('ul.menu li');\n\n// Direct children (>)\nlet directChild = document.querySelector('div > p');\n\n// Pseudo-selectors\nlet firstChild = document.querySelector('li:first-child');\nlet lastChild = document.querySelector('li:last-child');\nlet evenItems = document.querySelectorAll('li:nth-child(even)');\n\n// Complex example\nlet specificButton = document.querySelector('div.container button.primary:not(.disabled)');\n// Finds: button with class 'primary', inside div with class 'container', not having class 'disabled'\n\n// querySelectorAll returns NodeList (array-like)\nlet buttons = document.querySelectorAll('button');\nconsole.log(buttons.length);  // Number of buttons\nbuttons.forEach(btn => {\n  console.log(btn.textContent);\n});\n```\n\n## Breaking Down the Syntax\n\nquerySelector syntax (uses CSS selectors):\n\n**Basic Selectors:**\n\n1. By ID: #idName\n   document.querySelector('#myId')\n   // Same as: document.getElementById('myId')\n\n2. By class: .className\n   document.querySelector('.myClass')\n   document.querySelectorAll('.myClass')  // All matches\n\n3. By tag: tagname\n   document.querySelector('p')\n   document.querySelectorAll('div')\n\n4. By attribute: [attribute]\n   document.querySelector('[href]')  // Has href attribute\n   document.querySelector('[type=\"submit\"]')  // type=\"submit\"\n\n**Combinators:**\n\n1. Descendant: space (anywhere inside)\n   document.querySelector('div p')  // p inside any div\n\n2. Direct child: >\n   document.querySelector('div > p')  // p directly inside div\n\n3. Multiple selectors: comma\n   document.querySelectorAll('h1, h2, h3')  // All headings\n\n4. Combined: no space\n   document.querySelector('button.primary')  // button with class 'primary'\n\n**Pseudo-selectors:**\n\n1. :first-child, :last-child\n2. :nth-child(n) - The nth child\n3. :nth-child(even), :nth-child(odd)\n4. :not(selector) - Exclude matches\n5. :hover, :focus, :checked (for CSS, less useful in JS)\n\n**Differences from getElementBy...:**\n\nquerySelector:\n✓ More flexible (any CSS selector)\n✓ Consistent syntax\n✓ Returns null if not found\n✓ Modern and recommended\n✗ Slightly slower (negligible)\n\ngetElementBy...:\n✓ Slightly faster\n✓ Returns live collections (auto-updates)\n✗ Limited to ID, class, or tag\n✗ Different syntax for each\n\n**Best Practice:**\nUse querySelector/querySelectorAll for everything. They're more powerful and the syntax is consistent.\n\n**NodeList vs Array:**\nquerySelectorAll returns a NodeList (not an Array)\n- Has .length\n- Has .forEach() (modern browsers)\n- Doesn't have .map(), .filter(), etc.\n\nConvert to array if needed:\nlet itemsArray = Array.from(document.querySelectorAll('.item'));\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Forgetting the . or # prefix:\n   document.querySelector('myClass')  // WRONG - looks for <myClass> tag\n   document.querySelector('.myClass')  // CORRECT - looks for class\n\n2. Expecting querySelectorAll to be an array:\n   let items = document.querySelectorAll('.item');\n   items.map(...)  // ERROR - NodeList doesn't have map\n   \n   Convert first:\n   Array.from(items).map(...)\n   // Or use forEach (works on NodeList):\n   items.forEach(...)\n\n3. Confusing querySelector with querySelectorAll:\n   querySelector returns: first match or null\n   querySelectorAll returns: NodeList of all matches (can be empty)\n\n4. Complex selectors with typos:\n   'div.container button.primary'  // Correct\n   'div .container button .primary'  // WRONG - extra spaces change meaning\n\n5. Not checking for null:\n   let element = document.querySelector('.doesnt-exist');\n   element.textContent = 'Hi';  // ERROR - element is null!\n   \n   Always check:\n   if (element) {\n     element.textContent = 'Hi';\n   }"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Given this HTML:\n<nav>\n  <ul class=\"menu\">\n    <li class=\"item\">Home</li>\n    <li class=\"item active\">About</li>\n    <li class=\"item\">Contact</li>\n  </ul>\n</nav>\n<div class=\"content\">\n  <button class=\"primary\">Save</button>\n  <button class=\"secondary\">Cancel</button>\n</div>\n\nWrite JavaScript using querySelector to:\n1. Find the active menu item\n2. Find all menu items\n3. Find the primary button\n4. Find all buttons\n5. Log the text of the active item",
              "starterCode": "// Find the active menu item\nlet activeItem = document.querySelector(/* YOUR SELECTOR */);\n\n// Find all menu items\nlet allItems = document.querySelectorAll(/* YOUR SELECTOR */);\n\n// Find the primary button\nlet primaryButton = document.querySelector(/* YOUR SELECTOR */);\n\n// Find all buttons\nlet allButtons = document.querySelectorAll(/* YOUR SELECTOR */);\n\n// Log the active item text\nconsole.log(activeItem.textContent);",
              "solution": "let activeItem = document.querySelector('.item.active');\nlet allItems = document.querySelectorAll('.item');\nlet primaryButton = document.querySelector('.primary');\nlet allButtons = document.querySelectorAll('button');\n\nconsole.log(activeItem.textContent);  // About",
              "hints": [
                "Use '.item.active' for active item, '.item' for all items, '.primary' for primary button, 'button' for all buttons"
              ],
              "testCases": [
                {
                  "description": "Finds active item correctly",
                  "input": "let activeItem = {textContent: 'About', className: 'item active'}; console.log(activeItem.textContent);",
                  "expectedOutput": "About"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-07-7-4",
          "title": "Changing What Users See (Modifying .textContent and .style)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Changing What Users See (Modifying .textContent and .style)\n\n## Understanding the Concept\n\nImagine you have a puppet theater:\n\n**textContent**: This is like changing what the puppet SAYS. You're swapping out the dialogue.\n\n**style**: This is like changing what the puppet WEARS or how it LOOKS. You're changing the costume, makeup, lighting.\n\nJavaScript lets you be the puppeteer - you can change what elements say (their text) and how they look (their styling) on the fly, creating a dynamic, interactive show for your users.\n\n## Code Example\n\n```javascript\n// Changing text content\nlet heading = document.querySelector('h1');\nheading.textContent = 'New Heading';\n\nlet paragraph = document.querySelector('p');\nparagraph.textContent = 'New paragraph text';\n\n// Changing inline styles (CSS properties)\nlet box = document.querySelector('.box');\nbox.style.color = 'red';  // Text color\nbox.style.backgroundColor = 'yellow';  // Background (note camelCase!)\nbox.style.fontSize = '24px';  // Font size\nbox.style.width = '200px';  // Width\nbox.style.padding = '20px';  // Padding\nbox.style.border = '2px solid black';  // Border\n\n// CSS properties with hyphens become camelCase in JavaScript\n// CSS: background-color → JavaScript: backgroundColor\n// CSS: font-size → JavaScript: fontSize\n// CSS: margin-top → JavaScript: marginTop\n\n// Working with classes (better than inline styles!)\nlet element = document.querySelector('.item');\n\n// Add a class\nelement.classList.add('active');\n\n// Remove a class\nelement.classList.remove('inactive');\n\n// Toggle a class (add if missing, remove if present)\nelement.classList.toggle('highlighted');\n\n// Check if class exists\nif (element.classList.contains('active')) {\n  console.log('Element is active');\n}\n\n// Practical example: Dark mode toggle\nlet button = document.querySelector('#darkModeBtn');\nbutton.addEventListener('click', function() {\n  document.body.classList.toggle('dark-mode');\n});\n\n// Changing multiple styles at once\nlet card = document.querySelector('.card');\nObject.assign(card.style, {\n  width: '300px',\n  height: '200px',\n  backgroundColor: '#f0f0f0',\n  borderRadius: '10px',\n  padding: '20px'\n});\n\n// Getting current styles\nlet computedStyle = window.getComputedStyle(element);\nconsole.log(computedStyle.color);  // Current color\n```\n\n## Breaking Down the Syntax\n\nModifying DOM elements:\n\n**1. Changing Text Content:**\n\n// textContent (recommended - safe, text only)\nelement.textContent = 'New text';\n\n// innerHTML (can include HTML, but risky!)\nelement.innerHTML = '<b>Bold text</b>';\n\n// innerText (similar to textContent, but respects CSS visibility)\nelement.innerText = 'New text';\n\n**Best practice**: Use textContent unless you specifically need HTML\n\n**2. Changing Inline Styles:**\n\nelement.style.propertyName = 'value';\n\nKey points:\n- CSS properties with hyphens become camelCase\n- Values are strings (include units: '20px', '50%')\n- This adds inline styles (highest priority)\n\nExamples:\nCSS Property        → JavaScript Property\ncolor               → color\nbackground-color    → backgroundColor\nfont-size           → fontSize\nmargin-top          → marginTop\nborder-radius       → borderRadius\nz-index             → zIndex\n\n**3. Working with Classes (Preferred Method):**\n\n// classList provides methods to manipulate classes\nelement.classList.add('class1', 'class2');\nelement.classList.remove('class1');\nelement.classList.toggle('class1');  // Add if missing, remove if present\nelement.classList.contains('class1');  // Returns true/false\nelement.classList.replace('old', 'new');\n\n// Old way (not recommended):\nelement.className = 'class1 class2';  // Replaces all classes\n\n**Why use classes instead of inline styles?**\n\n✓ Separation of concerns (CSS in CSS, JS in JS)\n✓ Easier to maintain\n✓ Can change multiple properties at once\n✓ Better performance\n✓ CSS can be cached\n✓ Easier to override\n\nExample:\n// Instead of:\nelement.style.color = 'red';\nelement.style.fontWeight = 'bold';\nelement.style.fontSize = '20px';\n\n// Do this:\nelement.classList.add('error');\n\n// And in CSS:\n.error {\n  color: red;\n  font-weight: bold;\n  font-size: 20px;\n}\n\n**4. Reading Styles:**\n\n// Inline styles only\nelement.style.color  // Only returns inline styles\n\n// All computed styles (including CSS)\nlet styles = window.getComputedStyle(element);\nstyles.color\nstyles.fontSize\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Forgetting camelCase for CSS properties:\n   element.style.background-color = 'red';  // SYNTAX ERROR\n   element.style.backgroundColor = 'red';  // CORRECT\n\n2. Forgetting units:\n   element.style.width = 200;  // WRONG - no effect\n   element.style.width = '200px';  // CORRECT\n\n3. Overusing inline styles instead of classes:\n   Bad:\n   element.style.color = 'red';\n   element.style.fontWeight = 'bold';\n   \n   Better:\n   element.classList.add('error');\n   // Define .error in CSS\n\n4. Confusing textContent, innerHTML, and innerText:\n   textContent: Safest, pure text\n   innerHTML: Can include HTML (security risk if user input!)\n   innerText: Respects CSS (slower)\n\n5. Not checking if element exists:\n   let el = document.querySelector('.missing');\n   el.textContent = 'Hi';  // ERROR if el is null!\n   \n   Always check:\n   if (el) {\n     el.textContent = 'Hi';\n   }"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create an interactive element:\n\n<div id=\"box\" class=\"normal\">Click Me!</div>\n\nWrite JavaScript that:\n1. Finds the box\n2. When clicked, toggles a 'highlighted' class\n3. Also changes the textContent to show if it's highlighted or normal\n\nCSS (already defined):\n.normal { background: gray; }\n.highlighted { background: yellow; }",
              "starterCode": "let box = document.querySelector('#box');\n\nbox.addEventListener('click', function() {\n  // Toggle the highlighted class\n  \n  // Check if highlighted and update text\n  if (box.classList.contains('highlighted')) {\n    box.textContent = 'Highlighted!';\n  } else {\n    box.textContent = 'Click Me!';\n  }\n});",
              "solution": "let box = document.querySelector('#box');\n\nbox.addEventListener('click', function() {\n  box.classList.toggle('highlighted');\n  \n  if (box.classList.contains('highlighted')) {\n    box.textContent = 'Highlighted!';\n  } else {\n    box.textContent = 'Click Me!';\n  }\n});",
              "hints": [
                "Use box.classList.toggle('highlighted') and box.classList.contains('highlighted')"
              ],
              "testCases": [
                {
                  "description": "Toggles class and updates text",
                  "input": "let box = {classList: {toggle: function(c) { this.highlighted = !this.highlighted; }, contains: function(c) { return this.highlighted; }, highlighted: false}, textContent: ''}; box.addEventListener = function(e, cb) { cb(); cb(); }; box.addEventListener('click', function() { box.classList.toggle('highlighted'); if (box.classList.contains('highlighted')) { box.textContent = 'Highlighted!'; } else { box.textContent = 'Click Me!'; } }); console.log(box.textContent);",
                  "expectedOutput": "Click Me!"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-07-7-5",
          "title": "Responding to User Actions (Event Listeners)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Responding to User Actions (Event Listeners)\n\n## Understanding the Concept\n\nImagine you're a security guard at a building:\n\nYou're not actively doing anything most of the time - you're LISTENING and WAITING for specific events to happen:\n\n- **Event**: Someone presses the doorbell → **Response**: You open the door\n- **Event**: Fire alarm goes off → **Response**: You evacuate everyone\n- **Event**: Someone tries wrong password 3 times → **Response**: You lock them out\n\nEvent listeners work the same way. Your JavaScript code sits idle, LISTENING for specific events (clicks, key presses, mouse movements, etc.). When an event happens, your code RESPONDS by running a function.\n\n## Code Example\n\n```javascript\n// Basic event listener\nlet button = document.querySelector('#myButton');\n\nbutton.addEventListener('click', function() {\n  console.log('Button was clicked!');\n});\n\n// Common events\nlet input = document.querySelector('#nameInput');\n\n// 'input' fires when user types\ninput.addEventListener('input', function(event) {\n  console.log('User typed:', event.target.value);\n});\n\n// 'change' fires when input loses focus after being changed\ninput.addEventListener('change', function(event) {\n  console.log('Input changed to:', event.target.value);\n});\n\n// 'focus' fires when element receives focus\ninput.addEventListener('focus', function() {\n  console.log('Input focused');\n});\n\n// 'blur' fires when element loses focus\ninput.addEventListener('blur', function() {\n  console.log('Input lost focus');\n});\n\n// Mouse events\nlet box = document.querySelector('.box');\n\nbox.addEventListener('mouseenter', function() {\n  console.log('Mouse entered box');\n});\n\nbox.addEventListener('mouseleave', function() {\n  console.log('Mouse left box');\n});\n\nbox.addEventListener('mousemove', function(event) {\n  console.log('Mouse position:', event.clientX, event.clientY);\n});\n\n// Keyboard events\ndocument.addEventListener('keydown', function(event) {\n  console.log('Key pressed:', event.key);\n  \n  if (event.key === 'Enter') {\n    console.log('Enter key pressed!');\n  }\n});\n\n// Form events\nlet form = document.querySelector('#myForm');\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();  // Prevent default form submission\n  console.log('Form submitted');\n  \n  // Get form data\n  let formData = new FormData(form);\n  console.log(formData.get('username'));\n});\n\n// Event object\nbutton.addEventListener('click', function(event) {\n  console.log('Event type:', event.type);  // 'click'\n  console.log('Target element:', event.target);  // The button\n  console.log('Mouse position:', event.clientX, event.clientY);\n});\n\n// Removing event listeners\nfunction handleClick() {\n  console.log('Clicked!');\n}\n\nbutton.addEventListener('click', handleClick);\nbutton.removeEventListener('click', handleClick);  // Must be same function\n\n// Multiple listeners on same event\nbutton.addEventListener('click', function() {\n  console.log('First listener');\n});\n\nbutton.addEventListener('click', function() {\n  console.log('Second listener');\n});\n// Both run when button is clicked!\n```\n\n## Breaking Down the Syntax\n\nEvent listeners syntax:\n\nelement.addEventListener(eventType, callbackFunction);\n│                        │          │\n│                        │          └─ Function to run when event fires\n│                        └──────────── Type of event to listen for\n└───────────────────────────────────── Element to listen on\n\n**Common Event Types:**\n\nMouse Events:\n- 'click' - Element is clicked\n- 'dblclick' - Element is double-clicked\n- 'mouseenter' - Mouse enters element\n- 'mouseleave' - Mouse leaves element\n- 'mousemove' - Mouse moves over element\n- 'mousedown' - Mouse button pressed\n- 'mouseup' - Mouse button released\n\nKeyboard Events:\n- 'keydown' - Key is pressed down\n- 'keyup' - Key is released\n- 'keypress' - Key is pressed (deprecated, use keydown)\n\nForm Events:\n- 'submit' - Form is submitted\n- 'input' - Input value changes (real-time)\n- 'change' - Input value changes (on blur)\n- 'focus' - Element receives focus\n- 'blur' - Element loses focus\n\nWindow/Document Events:\n- 'load' - Page fully loaded\n- 'DOMContentLoaded' - HTML loaded (before images)\n- 'resize' - Window resized\n- 'scroll' - Page scrolled\n\n**Event Object:**\n\nThe callback receives an event object:\n\nelement.addEventListener('click', function(event) {\n  // event contains information about the event\n});\n\nUseful properties:\n- event.type - Type of event ('click', 'keydown', etc.)\n- event.target - Element that triggered the event\n- event.currentTarget - Element the listener is attached to\n- event.key - Key that was pressed (keyboard events)\n- event.clientX, event.clientY - Mouse position\n- event.preventDefault() - Prevent default behavior\n- event.stopPropagation() - Stop event bubbling\n\n**Preventing Defaults:**\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();  // Stop form from actually submitting\n  // Handle with JavaScript instead\n});\n\nlink.addEventListener('click', function(event) {\n  event.preventDefault();  // Stop link from navigating\n  // Do something else\n});\n\n**Arrow Functions:**\n\n// Traditional function\nelement.addEventListener('click', function() {\n  console.log('Clicked');\n});\n\n// Arrow function (more modern)\nelement.addEventListener('click', () => {\n  console.log('Clicked');\n});\n\n// With event parameter\nelement.addEventListener('click', (event) => {\n  console.log(event.target);\n});\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Calling the function immediately:\n   button.addEventListener('click', myFunction());  // WRONG - runs now!\n   button.addEventListener('click', myFunction);  // CORRECT - runs on click\n\n2. Forgetting event.preventDefault() for forms:\n   form.addEventListener('submit', function(event) {\n     // Form submits and page reloads before your code runs!\n   });\n   \n   Must prevent default:\n   form.addEventListener('submit', function(event) {\n     event.preventDefault();  // Now your code can run\n   });\n\n3. Confusing input vs change:\n   'input' - Fires on every keystroke (real-time)\n   'change' - Fires when field loses focus (final value)\n\n4. Not getting input values correctly:\n   let value = input;  // WRONG - this is the element!\n   let value = input.value;  // CORRECT - this is the text\n\n5. Trying to remove anonymous function:\n   element.addEventListener('click', function() { });\n   element.removeEventListener('click', function() { });  // Doesn't work!\n   \n   Must use named function:\n   function handleClick() { }\n   element.addEventListener('click', handleClick);\n   element.removeEventListener('click', handleClick);  // Works!\n\n6. Forgetting 'this' context in arrow functions:\n   // Traditional function: 'this' is the element\n   button.addEventListener('click', function() {\n     console.log(this);  // The button\n   });\n   \n   // Arrow function: 'this' is lexical scope\n   button.addEventListener('click', () => {\n     console.log(this);  // NOT the button!\n   });"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create an interactive form validator:\n\n<form id=\"signupForm\">\n  <input type=\"text\" id=\"username\" placeholder=\"Username\">\n  <input type=\"email\" id=\"email\" placeholder=\"Email\">\n  <button type=\"submit\">Sign Up</button>\n  <p id=\"message\"></p>\n</form>\n\nWrite JavaScript that:\n1. When the form is submitted, prevent default behavior\n2. Get the username and email values\n3. If username is empty, show error message\n4. If email doesn't contain '@', show error message\n5. If both valid, show success message",
              "starterCode": "let form = document.querySelector('#signupForm');\nlet message = document.querySelector('#message');\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();\n  \n  let username = document.querySelector('#username').value;\n  let email = document.querySelector('#email').value;\n  \n  // YOUR CODE HERE\n  // Check if username is empty\n  // Check if email contains '@'\n  // Show appropriate message\n});",
              "solution": "let form = document.querySelector('#signupForm');\nlet message = document.querySelector('#message');\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();\n  \n  let username = document.querySelector('#username').value;\n  let email = document.querySelector('#email').value;\n  \n  if (username === '') {\n    message.textContent = 'Username is required';\n    message.style.color = 'red';\n  } else if (!email.includes('@')) {\n    message.textContent = 'Please enter a valid email';\n    message.style.color = 'red';\n  } else {\n    message.textContent = 'Sign up successful!';\n    message.style.color = 'green';\n  }\n});",
              "hints": [
                "Use if/else to check: username === '' and !email.includes('@')"
              ],
              "testCases": [
                {
                  "description": "Validates empty username",
                  "input": "let message = {textContent: ''}; let username = ''; let email = 'test@test.com'; if (username === '') { message.textContent = 'Username required'; } else if (!email.includes('@')) { message.textContent = 'Invalid email'; } else { message.textContent = 'Success!'; } console.log(message.textContent);",
                  "expectedOutput": "Username required"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "module-08",
      "title": "Module 8: Asynchronous JavaScript (The 'Waiting Game')",
      "description": "Handle tasks that take time without freezing your application",
      "difficulty": "intermediate",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-08-8-1",
          "title": "The Restaurant Buzzer (Synchronous vs. Asynchronous)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# The Restaurant Buzzer (Synchronous vs. Asynchronous)\n\n## Understanding the Concept\n\nImagine two different ways of ordering food:\n\n**Synchronous (Blocking)**: You stand at the counter. The cook makes your burger while you wait, staring at them. You can't do ANYTHING else until your burger is ready. If it takes 20 minutes, you stand there for 20 minutes. This is how most code works - one line after another, waiting for each to finish.\n\n**Asynchronous (Non-blocking)**: You order, get a buzzer, and sit down. While the kitchen makes your food, you can chat with friends, check your phone, or relax. When food is ready, the buzzer vibrates, and you go pick it up. You're not stuck waiting!\n\nJavaScript is single-threaded (one line at a time), but asynchronous code lets it START a slow task, move on to other things, then come back when the slow task is done. Perfect for network requests, file reading, or anything that takes time.\n\n## Code Example\n\n```javascript\n// SYNCHRONOUS (Blocking) - Everything waits\nconsole.log('Start');\nfor (let i = 0; i < 3; i++) {\n  console.log('Step ' + i);\n}\nconsole.log('End');\n// Output: Start, Step 0, Step 1, Step 2, End (in order)\n\n// ASYNCHRONOUS (Non-blocking) - Using setTimeout\nconsole.log('Start');\n\nsetTimeout(function() {\n  console.log('This runs after 2 seconds');\n}, 2000);\n\nconsole.log('End');\n// Output: Start, End, (wait 2 seconds), This runs after 2 seconds\n// Notice 'End' comes BEFORE the timeout!\n\n// Practical example: Loading data\nconsole.log('Fetching user data...');\n\n// Simulating a slow network request (async)\nsetTimeout(function() {\n  console.log('User data loaded: Alice, age 25');\n}, 1000);\n\nconsole.log('Continuing with other tasks...');\n// Output:\n// Fetching user data...\n// Continuing with other tasks...\n// (1 second later) User data loaded: Alice, age 25\n\n// Multiple async operations\nconsole.log('Cooking eggs');\n\nsetTimeout(() => console.log('Eggs done!'), 2000);\nsetTimeout(() => console.log('Toast done!'), 1000);\nsetTimeout(() => console.log('Coffee done!'), 1500);\n\nconsole.log('Started all cooking tasks');\n// Output:\n// Cooking eggs\n// Started all cooking tasks\n// (1s) Toast done!\n// (1.5s) Coffee done!\n// (2s) Eggs done!\n```\n\n## Breaking Down the Syntax\n\nUnderstanding sync vs async:\n\n**Synchronous Code (Default):**\n- Runs line by line\n- Each line waits for the previous to complete\n- Blocking (stops everything until done)\n\nlet a = 1;\nlet b = 2;\nlet c = a + b;  // Waits for a and b\nconsole.log(c);  // Waits for c\n\n**Asynchronous Code:**\n- Starts a task\n- Doesn't wait for it to finish\n- Continues to next line immediately\n- Comes back when task completes\n\nCommon async operations:\n- setTimeout / setInterval (timers)\n- fetch() (network requests)\n- Reading files (Node.js)\n- Database queries\n- User interactions (clicks are async events)\n\n**setTimeout Syntax:**\n\nsetTimeout(callbackFunction, delayInMilliseconds);\n\nExamples:\nsetTimeout(() => console.log('Hi'), 1000);  // After 1 second\nsetTimeout(myFunction, 500);  // After 0.5 seconds\nsetTimeout(() => {\n  console.log('Multiple');\n  console.log('Lines');\n}, 2000);  // After 2 seconds\n\n**setInterval (Repeating Timer):**\n\nsetInterval(callbackFunction, intervalInMilliseconds);\n\nlet count = 0;\nlet intervalId = setInterval(() => {\n  count++;\n  console.log('Count:', count);\n  \n  if (count === 5) {\n    clearInterval(intervalId);  // Stop the interval\n  }\n}, 1000);  // Every 1 second\n\n**Why Async Matters:**\n\n// Synchronous (BAD for web):\nlet data = fetchDataFromServer();  // Takes 3 seconds, UI freezes!\nconsole.log(data);\n\n// Asynchronous (GOOD for web):\nfetchDataFromServer((data) => {\n  console.log(data);\n});  // UI stays responsive!\n\n**The Event Loop:**\n\nJavaScript has:\n1. Call stack (current code running)\n2. Web APIs (setTimeout, fetch, etc.)\n3. Callback queue (waiting callbacks)\n4. Event loop (moves callbacks to stack when empty)\n\nThis is how async works without multiple threads!\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Expecting async code to run in order:\n   setTimeout(() => console.log('A'), 1000);\n   console.log('B');\n   // Output: B, (wait), A  (not A, B!)\n\n2. Not storing interval ID to clear it:\n   setInterval(() => console.log('Hi'), 1000);\n   // Can't stop it now!\n   \n   Correct:\n   let id = setInterval(() => console.log('Hi'), 1000);\n   clearInterval(id);  // Can stop it\n\n3. Confusing milliseconds with seconds:\n   setTimeout(() => console.log('Hi'), 5);  // 5 milliseconds!\n   setTimeout(() => console.log('Hi'), 5000);  // 5 seconds\n\n4. Creating infinite intervals:\n   setInterval(() => {\n     // Runs forever!\n   }, 1000);\n   // Remember to clearInterval when done\n\n5. Trying to 'wait' for async with sync code:\n   setTimeout(() => data = fetchData(), 1000);\n   console.log(data);  // undefined! Timeout hasn't run yet\n   \n   Must use callbacks or promises (next lessons)"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a countdown timer that:\n1. Starts at 3\n2. Logs the number every second\n3. Logs 'Liftoff!' after 0\n\nExpected output (over 4 seconds):\n3\n2\n1\n0\nLiftoff!",
              "starterCode": "let count = 3;\n\n// Create an interval that runs every 1000ms\nlet intervalId = setInterval(() => {\n  // YOUR CODE HERE\n  // Log count\n  // Decrease count\n  // If count < 0, log 'Liftoff!' and stop interval\n}, 1000);",
              "solution": "let count = 3;\n\nlet intervalId = setInterval(() => {\n  console.log(count);\n  count--;\n  \n  if (count < 0) {\n    console.log('Liftoff!');\n    clearInterval(intervalId);\n  }\n}, 1000);",
              "hints": [
                "Log count, then count--, then if (count < 0) clearInterval and log Liftoff"
              ],
              "testCases": [
                {
                  "description": "Countdown works correctly",
                  "input": "let count = 3; let output = ''; while (count >= 0) { output += count + '\\n'; count--; } output += 'Liftoff!'; console.log(output.trim());",
                  "expectedOutput": "3\n2\n1\n0\nLiftoff!"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-08-8-2",
          "title": "The Promise of a Future Result (Promises)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# The Promise of a Future Result (Promises)\n\n## Understanding the Concept\n\nYou order a pizza for delivery:\n\n1. **You place the order** (create a Promise) - The restaurant promises to either deliver your pizza OR call you with a problem.\n\n2. **You wait** (Promise is 'pending') - The pizza is being made. You don't have it yet, but you have a promise.\n\n3. **Two possible outcomes**:\n   - **Fulfilled (Resolved)**: Pizza arrives! You eat it (the 'then' callback runs)\n   - **Rejected**: Restaurant calls - they're out of ingredients (the 'catch' callback runs)\n\nA Promise is JavaScript's way of saying: 'I'll get you a result eventually. Here's a guarantee (promise) that I'll let you know when it's done, whether it succeeds or fails.'\n\n## Code Example\n\n```javascript\n// Creating a Promise\nlet myPromise = new Promise((resolve, reject) => {\n  // Simulating async operation\n  let success = true;\n  \n  setTimeout(() => {\n    if (success) {\n      resolve('Operation successful!');  // Fulfilled\n    } else {\n      reject('Operation failed!');  // Rejected\n    }\n  }, 1000);\n});\n\n// Using a Promise\nmyPromise\n  .then((result) => {\n    console.log('Success:', result);\n  })\n  .catch((error) => {\n    console.log('Error:', error);\n  });\n\n// Practical example: Fetching data\nfunction fetchUserData(userId) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId > 0) {\n        resolve({ id: userId, name: 'Alice' });\n      } else {\n        reject('Invalid user ID');\n      }\n    }, 1000);\n  });\n}\n\nfetchUserData(1)\n  .then((user) => {\n    console.log('User:', user.name);\n  })\n  .catch((error) => {\n    console.log('Error:', error);\n  });\n\n// Chaining Promises\nfetchUserData(1)\n  .then((user) => {\n    console.log('Got user:', user.name);\n    return fetchUserPosts(user.id);  // Returns another promise\n  })\n  .then((posts) => {\n    console.log('Got posts:', posts);\n  })\n  .catch((error) => {\n    console.log('Error:', error);\n  });\n\n// Promise.all - Wait for multiple promises\nlet promise1 = fetchUserData(1);\nlet promise2 = fetchUserData(2);\nlet promise3 = fetchUserData(3);\n\nPromise.all([promise1, promise2, promise3])\n  .then((results) => {\n    console.log('All users:', results);\n  })\n  .catch((error) => {\n    console.log('At least one failed:', error);\n  });\n\n// Promise.race - First one to finish\nPromise.race([promise1, promise2, promise3])\n  .then((result) => {\n    console.log('First result:', result);\n  });\n\n// Promise.withResolvers() - ES2024 new feature!\nlet { promise, resolve, reject } = Promise.withResolvers();\n\n// Can resolve/reject from anywhere\nsetTimeout(() => resolve('Done!'), 1000);\n\npromise.then(result => console.log(result));\n```\n\n## Breaking Down the Syntax\n\nPromise syntax:\n\n**Creating a Promise:**\n\nlet promise = new Promise((resolve, reject) => {\n                           │        │\n                           │        └─ Call when operation fails\n                           └────────── Call when operation succeeds\n  // Do async work\n  if (success) {\n    resolve(successValue);\n  } else {\n    reject(errorValue);\n  }\n});\n\n**Using a Promise:**\n\npromise\n  .then((result) => {\n    // Runs if promise resolves (success)\n    console.log(result);\n  })\n  .catch((error) => {\n    // Runs if promise rejects (failure)\n    console.log(error);\n  })\n  .finally(() => {\n    // Always runs (success or failure)\n    console.log('Done');\n  });\n\n**Promise States:**\n\n1. Pending - Initial state, not yet resolved or rejected\n2. Fulfilled - Operation completed successfully (resolve called)\n3. Rejected - Operation failed (reject called)\n\nOnce settled (fulfilled or rejected), state can't change!\n\n**Promise Chaining:**\n\nfetch('/api/user')\n  .then(response => response.json())  // Parse JSON\n  .then(user => {\n    console.log('User:', user);\n    return fetch('/api/posts/' + user.id);  // Next request\n  })\n  .then(response => response.json())\n  .then(posts => {\n    console.log('Posts:', posts);\n  })\n  .catch(error => {\n    console.log('Error anywhere in chain:', error);\n  });\n\n**Promise Utilities:**\n\n1. Promise.all([p1, p2, p3])\n   - Waits for ALL to resolve\n   - Rejects if ANY rejects\n   - Returns array of results\n\n2. Promise.race([p1, p2, p3])\n   - Returns when FIRST settles (resolve or reject)\n\n3. Promise.allSettled([p1, p2, p3])\n   - Waits for ALL to settle\n   - Never rejects\n   - Returns array of {status, value/reason}\n\n4. Promise.any([p1, p2, p3])\n   - Returns when FIRST resolves\n   - Rejects only if ALL reject\n\n5. Promise.withResolvers() - ES2024!\n   - Returns {promise, resolve, reject}\n   - Useful when you need to resolve/reject from outside\n\n**Error Handling:**\n\n// Catch errors\npromise.catch(error => console.log(error));\n\n// Or use second argument to then\npromise.then(\n  result => console.log(result),\n  error => console.log(error)\n);\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Forgetting to return a promise from a function:\n   function getData() {\n     new Promise((resolve) => { ... });  // WRONG - not returned!\n   }\n   \n   function getData() {\n     return new Promise((resolve) => { ... });  // CORRECT\n   }\n\n2. Not returning in .then() for chaining:\n   promise\n     .then(data => {\n       processData(data);  // Returns undefined!\n     })\n     .then(result => {\n       console.log(result);  // undefined\n     });\n   \n   Must return:\n   .then(data => {\n     return processData(data);\n   })\n\n3. Calling resolve/reject multiple times:\n   new Promise((resolve) => {\n     resolve('first');\n     resolve('second');  // Ignored!\n   });\n   // Only first resolve/reject counts\n\n4. Mixing callbacks and promises:\n   // Don't do this:\n   getData(function(result) {\n     // Old callback style mixed with promises\n   });\n   \n   // Use promises consistently\n\n5. Not catching errors:\n   fetch('/api/data')\n     .then(response => response.json());\n   // If error occurs, it's unhandled!\n   \n   Always add .catch():\n   fetch('/api/data')\n     .then(response => response.json())\n     .catch(error => console.log(error));"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a function that simulates a dice roll:\n\nfunction rollDice() {\n  // Returns a promise that resolves after 1 second\n  // Resolves with a random number 1-6\n}\n\nUse it like:\nrollDice()\n  .then(result => console.log('Rolled:', result));\n\nHint: Use Math.floor(Math.random() * 6) + 1 for random 1-6",
              "starterCode": "function rollDice() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      // YOUR CODE: Generate random number 1-6 and resolve with it\n    }, 1000);\n  });\n}\n\n// Test it\nrollDice()\n  .then(result => {\n    console.log('You rolled:', result);\n  });",
              "solution": "function rollDice() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      let roll = Math.floor(Math.random() * 6) + 1;\n      resolve(roll);\n    }, 1000);\n  });\n}\n\nrollDice()\n  .then(result => {\n    console.log('You rolled:', result);\n  });",
              "hints": [
                "let roll = Math.floor(Math.random() * 6) + 1; resolve(roll);"
              ],
              "testCases": [
                {
                  "description": "Returns a number",
                  "input": "function rollDice() { return Promise.resolve(4); } rollDice().then(result => console.log(result));",
                  "expectedOutput": "4"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-08-8-3",
          "title": "The Modern, Clean Way (async and await)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# The Modern, Clean Way (async and await)\n\n## Understanding the Concept\n\nPromises are like getting a tracking number for your package:\n\n**Promises (.then)**: You keep checking the tracking number and saying 'THEN when it arrives, THEN I'll open it, THEN I'll use it, THEN I'll write a review...'\n\n**async/await**: You just wait at the door for the package to arrive, open it when it comes, use it, write review - one step at a time, in order. More natural!\n\nasync/await is syntactic sugar over Promises. It makes asynchronous code LOOK and READ like synchronous code, while still being non-blocking. It's the modern, preferred way to handle async operations.\n\n## Code Example\n\n```javascript\n// OLD WAY: Promises with .then()\nfunction getUser() {\n  fetchUser(1)\n    .then(user => {\n      console.log('User:', user);\n      return fetchPosts(user.id);\n    })\n    .then(posts => {\n      console.log('Posts:', posts);\n    })\n    .catch(error => {\n      console.log('Error:', error);\n    });\n}\n\n// NEW WAY: async/await (same thing, cleaner!)\nasync function getUser() {\n  try {\n    let user = await fetchUser(1);\n    console.log('User:', user);\n    \n    let posts = await fetchPosts(user.id);\n    console.log('Posts:', posts);\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}\n\n// async function returns a Promise\nasync function getData() {\n  return 'Hello';  // Automatically wrapped in Promise.resolve()\n}\n\ngetData().then(result => console.log(result));  // Hello\n\n// await pauses until Promise resolves\nasync function example() {\n  console.log('Start');\n  \n  let result = await someAsyncOperation();  // Waits here\n  console.log('Result:', result);  // Runs after promise resolves\n  \n  console.log('End');\n}\n\n// Multiple awaits in sequence\nasync function sequential() {\n  let user = await fetchUser(1);  // Wait for this\n  let posts = await fetchPosts(user.id);  // Then wait for this\n  let comments = await fetchComments(posts[0].id);  // Then wait for this\n  return { user, posts, comments };\n}\n\n// Multiple awaits in parallel (faster!)\nasync function parallel() {\n  // Start all at once\n  let userPromise = fetchUser(1);\n  let postsPromise = fetchPosts(1);\n  let commentsPromise = fetchComments(1);\n  \n  // Wait for all to finish\n  let user = await userPromise;\n  let posts = await postsPromise;\n  let comments = await commentsPromise;\n  \n  return { user, posts, comments };\n}\n\n// Or use Promise.all\nasync function parallelAll() {\n  let [user, posts, comments] = await Promise.all([\n    fetchUser(1),\n    fetchPosts(1),\n    fetchComments(1)\n  ]);\n  return { user, posts, comments };\n}\n\n// Error handling\nasync function withErrorHandling() {\n  try {\n    let data = await riskyOperation();\n    return data;\n  } catch (error) {\n    console.log('Caught error:', error);\n    return null;\n  }\n}\n\n// Can only use await inside async function\n// This is WRONG:\nfunction normal() {\n  let result = await fetchData();  // ERROR!\n}\n\n// This is CORRECT:\nasync function async() {\n  let result = await fetchData();  // Works!\n}\n\n// Top-level await (ES2022 - in modules only)\nawait fetchData();  // Now works at module top level!\n```\n\n## Breaking Down the Syntax\n\nasync/await syntax:\n\n**async function:**\n\nasync function functionName() {\n│     │\n│     └─ Makes function asynchronous\n└─────── async keyword required\n  // Can use 'await' inside\n}\n\n// async function automatically returns a Promise\nasync function getName() {\n  return 'Alice';  // Becomes Promise.resolve('Alice')\n}\n\n// These are equivalent:\nasync function a() { return 'Hi'; }\nfunction b() { return Promise.resolve('Hi'); }\n\n**await keyword:**\n\nlet result = await promise;\n│            │     │\n│            │     └─ A Promise\n│            └─────── await keyword (pauses until resolved)\n└──────────────────── Result of the promise\n\nRules for await:\n1. Can ONLY be used inside async functions (or module top-level)\n2. Pauses function execution until Promise resolves\n3. Returns the resolved value\n4. Throws if Promise rejects (use try/catch)\n\n**Error Handling:**\n\n// Promises:\npromise\n  .then(result => { })\n  .catch(error => { });\n\n// async/await:\ntry {\n  let result = await promise;\n} catch (error) {\n  // Handle error\n}\n\n**Sequential vs Parallel:**\n\n// Sequential (one after another - SLOW)\nasync function sequential() {\n  let a = await fetchA();  // Wait 1 second\n  let b = await fetchB();  // Wait 1 second\n  // Total: 2 seconds\n}\n\n// Parallel (at same time - FAST)\nasync function parallel() {\n  let [a, b] = await Promise.all([\n    fetchA(),  // Both start at same time\n    fetchB()\n  ]);\n  // Total: 1 second (whichever is slower)\n}\n\n**Common Patterns:**\n\n1. Simple fetch:\n   async function getData() {\n     let response = await fetch('/api/data');\n     let data = await response.json();\n     return data;\n   }\n\n2. With error handling:\n   async function getData() {\n     try {\n       let response = await fetch('/api/data');\n       if (!response.ok) throw new Error('Failed');\n       return await response.json();\n     } catch (error) {\n       console.log('Error:', error);\n       return null;\n     }\n   }\n\n3. Multiple parallel requests:\n   async function getAll() {\n     let [users, posts, comments] = await Promise.all([\n       fetch('/api/users').then(r => r.json()),\n       fetch('/api/posts').then(r => r.json()),\n       fetch('/api/comments').then(r => r.json())\n     ]);\n     return { users, posts, comments };\n   }\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Forgetting 'async' keyword:\n   function getData() {\n     let result = await fetch();  // ERROR!\n   }\n   \n   Must be:\n   async function getData() {\n     let result = await fetch();\n   }\n\n2. Not awaiting Promises:\n   async function getData() {\n     let data = fetchData();  // data is a Promise!\n     console.log(data.name);  // undefined!\n   }\n   \n   Must await:\n   async function getData() {\n     let data = await fetchData();\n     console.log(data.name);  // Works!\n   }\n\n3. Sequential when could be parallel:\n   // SLOW (3 seconds total):\n   async function slow() {\n     let a = await fetchA();  // 1s\n     let b = await fetchB();  // 1s\n     let c = await fetchC();  // 1s\n   }\n   \n   // FAST (1 second total):\n   async function fast() {\n     let [a, b, c] = await Promise.all([\n       fetchA(),\n       fetchB(),\n       fetchC()\n     ]);  // All at once!\n   }\n\n4. Not handling errors:\n   async function getData() {\n     let data = await fetch('/api/data');  // What if it fails?\n   }\n   \n   Always try/catch:\n   async function getData() {\n     try {\n       let data = await fetch('/api/data');\n     } catch (error) {\n       console.log('Error:', error);\n     }\n   }\n\n5. Mixing async/await with .then():\n   // Pick one style, don't mix:\n   async function mixed() {\n     let data = await fetchData();\n     data.then(result => { });  // Confusing!\n   }\n   \n   // Use async/await consistently:\n   async function clean() {\n     let data = await fetchData();\n     let result = await processData(data);\n   }"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Convert this Promise code to async/await:\n\nfunction loadUserData() {\n  return fetchUser(1)\n    .then(user => {\n      console.log('User:', user.name);\n      return fetchPosts(user.id);\n    })\n    .then(posts => {\n      console.log('Posts:', posts.length);\n      return posts;\n    })\n    .catch(error => {\n      console.log('Error:', error);\n    });\n}\n\nRewrite as async/await with try/catch.",
              "starterCode": "async function loadUserData() {\n  // YOUR CODE HERE using async/await\n}",
              "solution": "async function loadUserData() {\n  try {\n    let user = await fetchUser(1);\n    console.log('User:', user.name);\n    \n    let posts = await fetchPosts(user.id);\n    console.log('Posts:', posts.length);\n    \n    return posts;\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}",
              "hints": [
                "async function with try/catch, await fetchUser, await fetchPosts"
              ],
              "testCases": [
                {
                  "description": "Uses async/await correctly",
                  "input": "async function loadUserData() { try { let user = {name: 'Alice', id: 1}; console.log('User:', user.name); let posts = [{}, {}]; console.log('Posts:', posts.length); return posts; } catch (error) { console.log('Error:', error); } } loadUserData();",
                  "expectedOutput": ""
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-08-8-4",
          "title": "Ordering from the Menu (Using fetch() to Get API Data)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Ordering from the Menu (Using fetch() to Get API Data)\n\n## Understanding the Concept\n\nUsing an API is like ordering from a restaurant:\n\n1. **You look at the menu** (API documentation) - What dishes (endpoints) are available?\n2. **You place an order** (fetch request) - 'I'll have the user data for ID 123, please'\n3. **Kitchen prepares it** (server processes) - Takes time, you wait\n4. **Server brings your food** (response) - Here's your data!\n5. **You eat it** (use the data) - Display on your webpage\n\nAPIs (Application Programming Interfaces) are how websites talk to servers. fetch() is JavaScript's built-in way to request data from APIs. It returns a Promise, so we use async/await!\n\n## Code Example\n\n```javascript\n// Basic fetch - GET request\nasync function getUsers() {\n  try {\n    let response = await fetch('https://jsonplaceholder.typicode.com/users');\n    \n    // Check if request was successful\n    if (!response.ok) {\n      throw new Error('Request failed: ' + response.status);\n    }\n    \n    // Parse JSON response\n    let users = await response.json();\n    console.log(users);\n    \n    return users;\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}\n\n// Fetch with options - POST request\nasync function createUser(userData) {\n  try {\n    let response = await fetch('https://api.example.com/users', {\n      method: 'POST',  // HTTP method\n      headers: {\n        'Content-Type': 'application/json'  // Sending JSON\n      },\n      body: JSON.stringify(userData)  // Convert object to JSON string\n    });\n    \n    let newUser = await response.json();\n    console.log('Created:', newUser);\n    return newUser;\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}\n\n// Example: Create user\ncreateUser({\n  name: 'Alice',\n  email: 'alice@example.com',\n  age: 25\n});\n\n// UPDATE - PUT/PATCH request\nasync function updateUser(userId, updates) {\n  let response = await fetch(`https://api.example.com/users/${userId}`, {\n    method: 'PATCH',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(updates)\n  });\n  \n  return await response.json();\n}\n\n// DELETE request\nasync function deleteUser(userId) {\n  let response = await fetch(`https://api.example.com/users/${userId}`, {\n    method: 'DELETE'\n  });\n  \n  if (response.ok) {\n    console.log('User deleted');\n  }\n}\n\n// Practical example: Display users on page\nasync function displayUsers() {\n  try {\n    let response = await fetch('https://jsonplaceholder.typicode.com/users');\n    let users = await response.json();\n    \n    let userList = document.querySelector('#userList');\n    \n    users.forEach(user => {\n      let li = document.createElement('li');\n      li.textContent = user.name;\n      userList.appendChild(li);\n    });\n  } catch (error) {\n    console.log('Failed to load users:', error);\n  }\n}\n\n// With loading state\nasync function fetchWithLoading() {\n  let loadingEl = document.querySelector('#loading');\n  let contentEl = document.querySelector('#content');\n  \n  try {\n    loadingEl.style.display = 'block';  // Show loading\n    \n    let response = await fetch('/api/data');\n    let data = await response.json();\n    \n    contentEl.textContent = JSON.stringify(data);\n  } catch (error) {\n    contentEl.textContent = 'Error loading data';\n  } finally {\n    loadingEl.style.display = 'none';  // Hide loading\n  }\n}\n```\n\n## Breaking Down the Syntax\n\nfetch() syntax:\n\n**Basic GET request:**\n\nlet response = await fetch(url);\nlet data = await response.json();\n\n**With options:**\n\nlet response = await fetch(url, {\n  method: 'POST',  // GET, POST, PUT, PATCH, DELETE\n  headers: {       // Request headers\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer token123'\n  },\n  body: JSON.stringify(data)  // Request body (POST/PUT/PATCH)\n});\n\n**Response object properties:**\n\nresponse.ok          // true if status 200-299\nresponse.status      // HTTP status code (200, 404, 500, etc.)\nresponse.statusText  // Status message ('OK', 'Not Found', etc.)\nresponse.headers     // Response headers\nresponse.json()      // Parse as JSON (returns Promise)\nresponse.text()      // Get as text (returns Promise)\nresponse.blob()      // Get as binary (for images, files)\n\n**HTTP Methods (CRUD):**\n\nGET    - Read data (default)\nPOST   - Create new resource\nPUT    - Replace entire resource\nPATCH  - Update part of resource\nDELETE - Delete resource\n\n**Complete pattern:**\n\nasync function apiCall() {\n  try {\n    // 1. Make request\n    let response = await fetch(url, options);\n    \n    // 2. Check if successful\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    // 3. Parse response\n    let data = await response.json();\n    \n    // 4. Use data\n    return data;\n    \n  } catch (error) {\n    // 5. Handle errors\n    console.error('Fetch error:', error);\n    throw error;  // Re-throw or handle\n  }\n}\n\n**Common Headers:**\n\n'Content-Type': 'application/json'  // Sending JSON\n'Authorization': 'Bearer token'      // Authentication\n'Accept': 'application/json'         // Expecting JSON\n\n**Sending Data:**\n\n// Object to JSON string\nlet user = { name: 'Alice', age: 25 };\nlet jsonString = JSON.stringify(user);\n\n// Send in fetch\nbody: JSON.stringify(user)\n\n// Parsing response\nlet data = await response.json();  // JSON string to object\n\n**Error Handling:**\n\n// Network errors (no connection)\ntry {\n  let response = await fetch(url);\n} catch (error) {\n  console.log('Network error:', error);\n}\n\n// HTTP errors (404, 500, etc.)\nif (!response.ok) {\n  throw new Error('HTTP ' + response.status);\n}\n\n// JSON parsing errors\ntry {\n  let data = await response.json();\n} catch (error) {\n  console.log('Invalid JSON:', error);\n}\n\n## Common Mistakes & Tips\n\nCommon mistakes:\n\n1. Not awaiting response.json():\n   let response = await fetch(url);\n   let data = response.json();  // WRONG - data is a Promise!\n   \n   Must await:\n   let data = await response.json();\n\n2. Forgetting to check response.ok:\n   let response = await fetch(url);\n   let data = await response.json();  // Might fail!\n   \n   Always check:\n   if (!response.ok) {\n     throw new Error('HTTP error');\n   }\n\n3. Not stringifying request body:\n   fetch(url, {\n     body: {name: 'Alice'}  // WRONG - object!\n   });\n   \n   Must stringify:\n   fetch(url, {\n     body: JSON.stringify({name: 'Alice'})\n   });\n\n4. CORS errors (Cross-Origin Request Blocked):\n   // Can't fetch from different domain without server permission\n   fetch('https://other-site.com/api')  // Might be blocked\n   // Server must send CORS headers to allow\n\n5. Forgetting Content-Type header:\n   fetch(url, {\n     method: 'POST',\n     body: JSON.stringify(data)  // Server might not parse it!\n   });\n   \n   Need header:\n   fetch(url, {\n     method: 'POST',\n     headers: {\n       'Content-Type': 'application/json'\n     },\n     body: JSON.stringify(data)\n   });\n\n6. Not handling network errors:\n   // If internet is down, fetch throws\n   try {\n     await fetch(url);\n   } catch (error) {\n     // Handle network error\n   }"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a function that:\n1. Fetches a random user from: https://randomuser.me/api/\n2. Extracts the name (results[0].name.first)\n3. Returns the name\n4. Handles errors appropriately\n\nHint: The API returns { results: [{name: {first: 'John', last: 'Doe'}}] }",
              "starterCode": "async function getRandomUser() {\n  try {\n    // YOUR CODE HERE\n    // 1. fetch from URL\n    // 2. Check response.ok\n    // 3. Parse JSON\n    // 4. Extract and return name\n  } catch (error) {\n    console.log('Error:', error);\n    return null;\n  }\n}\n\n// Test it\ngetRandomUser().then(name => console.log('Random user:', name));",
              "solution": "async function getRandomUser() {\n  try {\n    let response = await fetch('https://randomuser.me/api/');\n    \n    if (!response.ok) {\n      throw new Error('Request failed');\n    }\n    \n    let data = await response.json();\n    let firstName = data.results[0].name.first;\n    \n    return firstName;\n  } catch (error) {\n    console.log('Error:', error);\n    return null;\n  }\n}\n\ngetRandomUser().then(name => console.log('Random user:', name));",
              "hints": [
                "let response = await fetch(url); let data = await response.json(); return data.results[0].name.first;"
              ],
              "testCases": [
                {
                  "description": "Fetches and parses data",
                  "input": "async function getRandomUser() { let data = {results: [{name: {first: 'John'}}]}; return data.results[0].name.first; } getRandomUser().then(name => console.log(name));",
                  "expectedOutput": "John"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "module-09",
      "title": "Module 9: Introducing TypeScript",
      "description": "Learn why TypeScript exists and how it makes your code safer and more predictable through type checking",
      "difficulty": "intermediate",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-09-9-1",
          "title": "Why TypeScript? (The LEGO Instructions Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Why TypeScript? (The LEGO Instructions Analogy)\n\n## Understanding the Concept\n\nImagine building a complex LEGO set without instructions versus with a detailed manual.\n\nWithout instructions (plain JavaScript):\n- You might try to put the wrong pieces together\n- You won't know if you're missing pieces until the end\n- You can build it any way you want (freedom but risky)\n- Mistakes are discovered when the model doesn't work\n\nWith instructions (TypeScript):\n- The manual tells you exactly which pieces go where\n- You know immediately if you're using the wrong piece\n- You still have freedom within the design\n- Mistakes are caught BEFORE you finish building\n\nTypeScript is like having LEGO instructions for your code. It doesn't stop you from building creative things—it just helps you catch mistakes earlier!\n\n## Code Example\n\n```javascript\n// JavaScript: No type checking (risky)\nfunction addNumbers(a, b) {\n  return a + b;\n}\n\nconsole.log(addNumbers(5, 3));        // 8 ✓\nconsole.log(addNumbers('5', '3'));    // '53' (string concatenation - oops!)\nconsole.log(addNumbers(5, 'hello')); // '5hello' (probably not what you wanted)\n\n// TypeScript: Type checking (safer)\nfunction addNumbersTyped(a: number, b: number): number {\n  return a + b;\n}\n\nconsole.log(addNumbersTyped(5, 3));        // 8 ✓\n// console.log(addNumbersTyped('5', '3'));    // ERROR: Type 'string' is not assignable to type 'number'\n// console.log(addNumbersTyped(5, 'hello')); // ERROR: Argument of type 'string' is not assignable to parameter of type 'number'\n\n// TypeScript catches mistakes BEFORE you run the code!\n```\n\n## Breaking Down the Syntax\n\nLet's break down the TypeScript syntax:\n\n1. **Parameter Types**: `a: number`\n   - The colon `:` means \"this variable should be\"\n   - `number` is the type we're expecting\n   - Think of it as a label on a LEGO piece\n\n2. **Return Type**: `: number` after the parentheses\n   - Tells TypeScript what type of value the function returns\n   - Optional but recommended for clarity\n\n3. **Type Checking**: TypeScript analyzes your code\n   - Happens BEFORE you run the code (compile-time)\n   - Catches type mismatches and shows red squiggly lines in your editor\n   - Your code won't compile if types don't match\n\n4. **Benefits**:\n   - Catch bugs early (before runtime)\n   - Better autocomplete in your editor\n   - Self-documenting code (types show intent)\n   - Safer refactoring (TypeScript tells you what breaks)\n\n## Common Mistakes & Tips\n\nCommon mistakes when starting with TypeScript:\n\n1. **Forgetting the colon**: `width number` won't work - you need `width: number`\n2. **Using the wrong type**: `width: string` when you mean numbers\n3. **Thinking TypeScript runs in the browser**: TypeScript must be compiled to JavaScript first\n4. **Over-typing everything**: Start simple, add types gradually\n5. **Confusing TypeScript with JavaScript**: TypeScript is a superset - all valid JavaScript is valid TypeScript, but not all TypeScript features work in plain JavaScript\n\nRemember: TypeScript is JavaScript with type safety training wheels. The training wheels help you learn to avoid crashes!"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a TypeScript function called `calculateArea` that:\n1. Takes two parameters: `width` and `height` (both should be numbers)\n2. Returns the area (width * height)\n3. Add type annotations to ensure only numbers can be passed\n\nTest your function with: calculateArea(10, 5)",
              "starterCode": "// Write your calculateArea function here\nfunction calculateArea(width, height) {\n  return width * height;\n}\n\nconsole.log(calculateArea(10, 5));",
              "solution": "function calculateArea(width: number, height: number): number {\n  return width * height;\n}\n\nconsole.log(calculateArea(10, 5));  // 50\nconsole.log(calculateArea(7.5, 4)); // 30",
              "hints": [
                "Add `: number` after each parameter name, and `: number` after the closing parenthesis to specify the return type."
              ],
              "testCases": [
                {
                  "description": "Should calculate area correctly",
                  "input": "calculateArea(10, 5)",
                  "expectedOutput": "50"
                },
                {
                  "description": "Should work with decimal numbers",
                  "input": "calculateArea(7.5, 4)",
                  "expectedOutput": "30"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-09-9-2",
          "title": "Your First Types (The Label Maker Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Your First Types (The Label Maker Analogy)\n\n## Understanding the Concept\n\nImagine organizing a kitchen with a label maker:\n\nWithout labels (JavaScript):\n- You can put anything in any container\n- Sugar in the salt jar? Sure!\n- Flour in the coffee can? Why not!\n- You discover mistakes when you taste your food\n\nWith labels (TypeScript):\n- Each container has a clear label\n- You know immediately if you're putting the wrong thing in\n- The label maker prevents you from mislabeling\n- Mistakes are caught BEFORE cooking\n\nTypeScript's basic types are like labels for your variables. They tell you (and the computer) what kind of data should go in each container.\n\n## Code Example\n\n```javascript\n// TypeScript 5.7 Basic Types (2024-2025)\n\n// 1. STRING - Text data\nlet playerName: string = 'Alice';\nlet greeting: string = \"Hello, world!\";\nlet message: string = `Welcome, ${playerName}!`; // Template literal\n\nconsole.log(message); // 'Welcome, Alice!'\n\n// 2. NUMBER - Numeric data (integers and decimals)\nlet score: number = 100;\nlet health: number = 95.5;\nlet temperature: number = -5;\n\nconsole.log('Score:', score); // 100\n\n// 3. BOOLEAN - True or false\nlet isGameOver: boolean = false;\nlet hasWon: boolean = true;\nlet isLoggedIn: boolean = score > 50;\n\nconsole.log('Game over?', isGameOver); // false\n\n// 4. ARRAYS - Lists of the same type\nlet scores: number[] = [100, 95, 87, 92];\nlet names: string[] = ['Alice', 'Bob', 'Charlie'];\nlet flags: boolean[] = [true, false, true];\n\nconsole.log('First score:', scores[0]);   // 100\nconsole.log('All names:', names);         // ['Alice', 'Bob', 'Charlie']\n\n// Alternative array syntax (both work the same)\nlet moreScores: Array<number> = [88, 92, 76];\n\n// 5. TYPE INFERENCE - TypeScript guesses the type\nlet autoString = 'TypeScript is smart!'; // TypeScript knows this is a string\nlet autoNumber = 42;                      // TypeScript knows this is a number\nlet autoBool = true;                      // TypeScript knows this is a boolean\n\n// autoString = 123; // ERROR: Can't assign number to string variable\n\n// 6. ANY - Escape hatch (use sparingly!)\nlet anything: any = 'I can be anything';\nanything = 42;        // OK\nanything = true;      // OK\nanything = [1, 2, 3]; // OK\n// Using 'any' turns off type checking - avoid it when possible!\n\nconsole.log('Anything:', anything);\n```\n\n## Breaking Down the Syntax\n\nLet's break down TypeScript's basic types:\n\n1. **String Type**: `let name: string = 'Alice'`\n   - For text data\n   - Use single quotes, double quotes, or backticks\n   - Can't assign numbers or booleans to string variables\n\n2. **Number Type**: `let age: number = 25`\n   - For all numeric data (integers and decimals)\n   - JavaScript/TypeScript doesn't distinguish between int and float\n   - Can't assign strings or booleans to number variables\n\n3. **Boolean Type**: `let isActive: boolean = true`\n   - Only two values: `true` or `false`\n   - Used for yes/no, on/off logic\n   - Can't assign strings or numbers (even 0 and 1)\n\n4. **Array Types**: `let numbers: number[] = [1, 2, 3]`\n   - Square brackets `[]` after the type\n   - All elements must be the same type\n   - Alternative syntax: `Array<number>`\n\n5. **Type Inference**: TypeScript is smart!\n   - If you assign a value immediately, TypeScript guesses the type\n   - `let x = 5` → TypeScript knows x is a number\n   - Still type-safe, just less typing!\n\n6. **The 'any' Type**: Last resort!\n   - Turns off type checking for that variable\n   - Defeats the purpose of TypeScript\n   - Use only when absolutely necessary (like external APIs)\n\n## Common Mistakes & Tips\n\nCommon beginner mistakes:\n\n1. **Mixing up type names**: `String` vs `string`\n   - Use lowercase: `string`, `number`, `boolean`\n   - Uppercase versions (String, Number, Boolean) are JavaScript wrapper objects - avoid them!\n\n2. **Forgetting array brackets**: `let nums: number` vs `let nums: number[]`\n   - `number` is a single number\n   - `number[]` is an array of numbers\n\n3. **Type mismatch errors**: `let age: number = '25'`\n   - '25' is a string, not a number\n   - Remove quotes: `let age: number = 25`\n\n4. **Overusing 'any'**: Using `any` everywhere defeats TypeScript's purpose\n   - Only use 'any' as a last resort\n   - Better to learn the correct type\n\n5. **Type inference confusion**: \"Do I always need type annotations?\"\n   - No! If you assign immediately, TypeScript infers the type\n   - `let x = 5` is the same as `let x: number = 5`\n   - Explicit types are good for function parameters and return values"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create variables with proper TypeScript types:\n1. A string variable `username` with your name\n2. A number variable `age` with your age\n3. A boolean variable `isStudent` set to true\n4. An array of numbers called `grades` with at least 3 grade values\n5. Calculate and log the average grade\n\nLog all variables to see their values.",
              "starterCode": "// Add type annotations to these variables\nlet username = 'YourName';\nlet age = 0;\nlet isStudent = true;\nlet grades = [85, 92, 78];\n\n// Calculate average\nlet sum = 0;\nfor (let grade of grades) {\n  sum = sum + grade;\n}\nlet average = sum / grades.length;\n\nconsole.log('Username:', username);\nconsole.log('Age:', age);\nconsole.log('Student?', isStudent);\nconsole.log('Grades:', grades);\nconsole.log('Average:', average);",
              "solution": "// Properly typed variables\nlet username: string = 'Alice';\nlet age: number = 20;\nlet isStudent: boolean = true;\nlet grades: number[] = [85, 92, 78];\n\n// Calculate average\nlet sum: number = 0;\nfor (let grade of grades) {\n  sum = sum + grade;\n}\nlet average: number = sum / grades.length;\n\nconsole.log('Username:', username);  // Alice\nconsole.log('Age:', age);            // 20\nconsole.log('Student?', isStudent);  // true\nconsole.log('Grades:', grades);      // [85, 92, 78]\nconsole.log('Average:', average);    // 85",
              "hints": [
                "Add `: string`, `: number`, `: boolean`, and `: number[]` after each variable name."
              ],
              "testCases": [
                {
                  "description": "Should create typed variables",
                  "input": "typeof username === 'string' && typeof age === 'number' && typeof isStudent === 'boolean'",
                  "expectedOutput": "true"
                },
                {
                  "description": "Should calculate average correctly",
                  "input": "let grades = [85, 92, 78]; let sum = 0; for (let g of grades) sum += g; sum / grades.length",
                  "expectedOutput": "85"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-09-9-3",
          "title": "Creating Custom Blueprints (Interfaces and Types)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Creating Custom Blueprints (Interfaces and Types)\n\n## Understanding the Concept\n\nImagine you're running a car dealership:\n\nWithout blueprints (plain JavaScript):\n- Every car is just an object with random properties\n- One car has 'color', another has 'colour'\n- No one knows what properties a car should have\n- Lots of inconsistency and confusion\n\nWith blueprints (TypeScript Interfaces):\n- You create a 'Car Blueprint' that says every car must have:\n  * make (string)\n  * model (string)\n  * year (number)\n  * color (string)\n- Now every car follows the same structure\n- If someone forgets a property, the blueprint catches it\n- Everyone knows exactly what a car object should look like\n\nInterfaces are blueprints for objects. They define the exact shape your data should have.\n\n## Code Example\n\n```javascript\n// TypeScript 5.7 Interfaces and Type Aliases (2024-2025)\n\n// INTERFACE - Blueprint for an object\ninterface User {\n  id: number;\n  username: string;\n  email: string;\n  isActive: boolean;\n}\n\n// Using the interface\nlet alice: User = {\n  id: 1,\n  username: 'alice',\n  email: 'alice@example.com',\n  isActive: true\n};\n\nconsole.log('User:', alice.username); // 'alice'\n\n// This will cause an error (missing properties):\n// let bob: User = {\n//   id: 2,\n//   username: 'bob'\n//   // ERROR: Missing email and isActive!\n// };\n\n// OPTIONAL PROPERTIES - Sometimes a property might not exist\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  description?: string;  // ? means optional\n  inStock?: boolean;\n}\n\nlet laptop: Product = {\n  id: 101,\n  name: 'Gaming Laptop',\n  price: 1299.99\n  // description and inStock are optional - no error!\n};\n\nlet phone: Product = {\n  id: 102,\n  name: 'Smartphone',\n  price: 799.99,\n  description: 'Latest model with amazing camera',\n  inStock: true\n};\n\nconsole.log('Laptop:', laptop.name);      // 'Gaming Laptop'\nconsole.log('Phone stock:', phone.inStock); // true\n\n// TYPE ALIASES - Alternative way to create custom types\ntype Point = {\n  x: number;\n  y: number;\n};\n\nlet origin: Point = { x: 0, y: 0 };\nlet cursor: Point = { x: 150, y: 200 };\n\nconsole.log('Cursor position:', cursor.x, cursor.y); // 150 200\n\n// UNION TYPES - A value can be one of several types\ntype Status = 'pending' | 'approved' | 'rejected';\n\nlet orderStatus: Status = 'pending';\nconsole.log('Order status:', orderStatus); // 'pending'\n\norderStatus = 'approved';  // OK\n// orderStatus = 'cancelled'; // ERROR: Not one of the allowed values!\n\n// INTERFACES WITH METHODS - Objects can have functions\ninterface Calculator {\n  add(a: number, b: number): number;\n  subtract(a: number, b: number): number;\n}\n\nlet calc: Calculator = {\n  add(a, b) {\n    return a + b;\n  },\n  subtract(a, b) {\n    return a - b;\n  }\n};\n\nconsole.log('5 + 3 =', calc.add(5, 3));      // 8\nconsole.log('10 - 4 =', calc.subtract(10, 4)); // 6\n```\n\n## Breaking Down the Syntax\n\nLet's break down custom types in TypeScript:\n\n1. **Interface Definition**: `interface User { ... }`\n   - Starts with the `interface` keyword\n   - Name should be PascalCase (capitalized)\n   - Properties inside curly braces\n   - Each property has a type\n\n2. **Using an Interface**: `let user: User = { ... }`\n   - Use the interface name as a type annotation\n   - Object must have ALL required properties\n   - Properties must match the specified types\n\n3. **Optional Properties**: `description?: string`\n   - Question mark `?` after property name\n   - Means this property might not exist\n   - Still type-safe when it does exist\n\n4. **Type Aliases**: `type Point = { x: number; y: number }`\n   - Alternative to interfaces\n   - Use the `type` keyword\n   - Can create complex types\n\n5. **Union Types**: `type Status = 'pending' | 'approved' | 'rejected'`\n   - Pipe `|` means \"OR\"\n   - Value must be one of the listed options\n   - Great for status codes, modes, etc.\n\n6. **Method Signatures**: `add(a: number, b: number): number`\n   - Functions inside interfaces\n   - Parameters have types\n   - Return type after the closing parenthesis\n\nWhen to use Interface vs Type:\n- Use `interface` for object shapes (most common)\n- Use `type` for unions, primitives, or complex combinations\n- Both work for objects, choose based on preference\n\n## Common Mistakes & Tips\n\nCommon mistakes with interfaces:\n\n1. **Forgetting required properties**:\n   ```typescript\n   let user: User = { id: 1 }; // ERROR: Missing username, email, isActive\n   ```\n   Solution: Include ALL required properties\n\n2. **Wrong property names**:\n   ```typescript\n   let user: User = { \n     id: 1, \n     userName: 'alice' // ERROR: Should be 'username' not 'userName'\n   };\n   ```\n   Solution: Match property names exactly (case-sensitive!)\n\n3. **Extra properties**:\n   ```typescript\n   let user: User = {\n     id: 1,\n     username: 'alice',\n     email: 'alice@example.com',\n     isActive: true,\n     age: 25 // ERROR: 'age' doesn't exist in User interface\n   };\n   ```\n   Solution: Only include properties defined in the interface\n\n4. **Confusing `?` placement**: `string?` is wrong, `property?: string` is correct\n\n5. **Interface vs Type confusion**:\n   - Both can define object shapes\n   - Interfaces can be extended and merged\n   - Types can do unions and complex types\n   - For simple object shapes, use either one - they're interchangeable!"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a TypeScript interface called `Book` with the following properties:\n1. `title` (string, required)\n2. `author` (string, required)\n3. `pages` (number, required)\n4. `isbn` (string, optional)\n5. `isRead` (boolean, required)\n\nThen create two book objects using this interface:\n- A book you've read (with all properties including isbn)\n- A book you haven't read yet (without isbn)\n\nLog both books to verify they work.",
              "starterCode": "// Define your Book interface here\ninterface Book {\n  // Add properties here\n}\n\n// Create two book objects\nlet book1: Book = {\n  title: 'The Great Gatsby',\n  author: 'F. Scott Fitzgerald',\n  pages: 180,\n  isbn: '978-0743273565',\n  isRead: true\n};\n\nlet book2: Book = {\n  title: '1984',\n  author: 'George Orwell',\n  pages: 328,\n  isRead: false\n};\n\nconsole.log('Book 1:', book1.title);\nconsole.log('Book 2:', book2.title);",
              "solution": "// Book interface with optional isbn\ninterface Book {\n  title: string;\n  author: string;\n  pages: number;\n  isbn?: string;  // Optional property\n  isRead: boolean;\n}\n\n// Book with all properties\nlet book1: Book = {\n  title: 'The Great Gatsby',\n  author: 'F. Scott Fitzgerald',\n  pages: 180,\n  isbn: '978-0743273565',\n  isRead: true\n};\n\n// Book without optional isbn\nlet book2: Book = {\n  title: '1984',\n  author: 'George Orwell',\n  pages: 328,\n  isRead: false\n};\n\nconsole.log('Book 1:', book1.title);  // 'The Great Gatsby'\nconsole.log('Book 2:', book2.title);  // '1984'\nconsole.log('Book 1 ISBN:', book1.isbn); // '978-0743273565'\nconsole.log('Book 2 ISBN:', book2.isbn); // undefined",
              "hints": [
                "Use `?` to make isbn optional. The syntax is: `propertyName?: type`"
              ],
              "testCases": [
                {
                  "description": "Should create book objects with interface",
                  "input": "let b = { title: 'Test', author: 'Author', pages: 100, isRead: true }; b.title",
                  "expectedOutput": "Test"
                },
                {
                  "description": "Should handle optional isbn",
                  "input": "let b = { title: 'Book', author: 'Writer', pages: 200, isRead: false }; b.pages",
                  "expectedOutput": "200"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-09-9-4",
          "title": "TypeScript Project Setup (The Toolbox Assembly)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# TypeScript Project Setup (The Toolbox Assembly)\n\n## Understanding the Concept\n\nImagine you're setting up a woodworking shop:\n\nWoodworking setup:\n- You need tools (saw, hammer, drill)\n- You need a workspace (workshop with proper layout)\n- You need safety equipment (goggles, gloves)\n- You need instructions on how to use everything\n\nTypeScript project setup:\n- You need TypeScript installed (the compiler)\n- You need a configuration file (tsconfig.json)\n- You need a folder structure (organized workspace)\n- You need to know how to compile TS → JS\n\nJust like you can't start woodworking without setting up your shop, you can't start a TypeScript project without proper configuration!\n\n## Code Example\n\n```javascript\n// TypeScript 5.7 Project Setup (2024-2025)\n\n// STEP 1: Initialize a Node.js project (run in terminal)\n// npm init -y\n\n// STEP 2: Install TypeScript (run in terminal)\n// npm install -D typescript\n\n// STEP 3: Create tsconfig.json configuration file\n// Content of tsconfig.json:\n/*\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2024\",           // Use ES2024 features\n    \"module\": \"ESNext\",           // Modern module system\n    \"outDir\": \"./dist\",           // Compiled JS goes here\n    \"rootDir\": \"./src\",           // TypeScript source files here\n    \"strict\": true,               // Enable all strict type checks\n    \"esModuleInterop\": true,      // Better import compatibility\n    \"skipLibCheck\": true,         // Skip type checking of declaration files\n    \"forceConsistentCasingInFileNames\": true  // Case-sensitive imports\n  },\n  \"include\": [\"src/**/*\"],       // Include all files in src folder\n  \"exclude\": [\"node_modules\"]    // Exclude dependencies\n}\n*/\n\n// STEP 4: Create folder structure\n// project/\n//   ├── src/           (TypeScript source files)\n//   │   └── index.ts\n//   ├── dist/          (Compiled JavaScript - auto-generated)\n//   ├── node_modules/  (Dependencies)\n//   ├── package.json\n//   └── tsconfig.json\n\n// STEP 5: Write TypeScript code in src/index.ts\ninterface Greeting {\n  message: string;\n  name: string;\n}\n\nfunction greet(greeting: Greeting): string {\n  return `${greeting.message}, ${greeting.name}!`;\n}\n\nconst welcome: Greeting = {\n  message: 'Hello',\n  name: 'TypeScript Developer'\n};\n\nconsole.log(greet(welcome));\n\n// STEP 6: Compile TypeScript to JavaScript (run in terminal)\n// npx tsc\n// This creates dist/index.js\n\n// STEP 7: Run the compiled JavaScript (run in terminal)\n// node dist/index.js\n\n// STEP 8: (Optional) Watch mode - auto-compile on file changes\n// npx tsc --watch\n\n// MODERN WORKFLOW: Use ts-node for development\n// npm install -D ts-node\n// npx ts-node src/index.ts  (runs TypeScript directly!)\n\nconsole.log('TypeScript project setup complete!');\n```\n\n## Breaking Down the Syntax\n\nLet's break down TypeScript project configuration:\n\n1. **tsconfig.json**: The command center\n   - Tells TypeScript how to compile your code\n   - Lives in the project root directory\n   - JSON format (strict syntax)\n\n2. **Key Configuration Options**:\n   - `target`: Which JavaScript version to output (ES2024 is latest)\n   - `module`: How to handle imports/exports (ESNext for modern)\n   - `outDir`: Where compiled JavaScript goes (usually 'dist' or 'build')\n   - `rootDir`: Where TypeScript source files are (usually 'src')\n   - `strict`: Turn on all strict type checking (HIGHLY recommended)\n\n3. **Compilation Process**:\n   - Write `.ts` files (TypeScript)\n   - Run `npx tsc` command\n   - TypeScript compiler reads tsconfig.json\n   - Generates `.js` files in outDir\n   - Run the `.js` files with Node.js\n\n4. **Development Tools**:\n   - `tsc`: TypeScript compiler\n   - `ts-node`: Run TypeScript directly without manual compilation\n   - `--watch`: Auto-recompile when files change\n   - `npm install -D`: Install as development dependency\n\n5. **Folder Structure Best Practices**:\n   - `/src`: All TypeScript source code\n   - `/dist`: Compiled JavaScript (gitignored)\n   - `/node_modules`: Dependencies (gitignored)\n   - Root: Config files (tsconfig.json, package.json)\n\n6. **Why We Need Compilation**:\n   - Browsers and Node.js don't understand TypeScript\n   - TypeScript must be converted (transpiled) to JavaScript\n   - The type checking happens during compilation\n   - Runtime uses the generated JavaScript\n\n## Common Mistakes & Tips\n\nCommon setup mistakes:\n\n1. **Wrong tsconfig.json location**:\n   - Must be in project root (not inside src/)\n   - Must be named exactly 'tsconfig.json' (case-sensitive)\n\n2. **JSON syntax errors**:\n   ```json\n   {\n     \"target\": \"ES2024\",  // ERROR: No trailing comma on last item!\n   }\n   ```\n   Solution: Remove trailing commas in JSON files\n\n3. **Running .ts files directly**: `node src/index.ts`\n   - Node.js can't run TypeScript!\n   - Either compile first: `npx tsc` then `node dist/index.js`\n   - Or use ts-node: `npx ts-node src/index.ts`\n\n4. **Forgetting to install TypeScript**:\n   - Must run `npm install -D typescript` first\n   - Check with `npx tsc --version`\n\n5. **Wrong folder structure**:\n   - TypeScript files should be in src/\n   - If you put them elsewhere, update `rootDir` in tsconfig.json\n\n6. **Confusion about compilation**:\n   - TypeScript → JavaScript (compilation/transpilation)\n   - Types are removed during compilation\n   - The .js output has no type information\n   - Type checking happens at compile-time only\n\n7. **Not using strict mode**:\n   - `\"strict\": false` allows many unsafe patterns\n   - Always use `\"strict\": true` for maximum safety\n   - You're learning TypeScript to catch bugs - use all its power!"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Simulate a TypeScript project setup by creating the necessary configuration:\n\n1. Create a simple TypeScript configuration object with these properties:\n   - `target`: 'ES2024'\n   - `strict`: true\n   - `outDir`: './dist'\n\n2. Create an interface `ProjectConfig` that matches this structure\n\n3. Create a function `validateConfig` that takes a ProjectConfig and returns true if strict is enabled\n\n4. Test your function with a config object\n\nLog the validation result.",
              "starterCode": "// Define ProjectConfig interface\ninterface ProjectConfig {\n  // Add properties here\n}\n\n// Create validation function\nfunction validateConfig(config) {\n  return config.strict === true;\n}\n\n// Create a config object\nlet myConfig = {\n  target: 'ES2024',\n  strict: true,\n  outDir: './dist'\n};\n\nconsole.log('Strict mode enabled?', validateConfig(myConfig));",
              "solution": "// ProjectConfig interface\ninterface ProjectConfig {\n  target: string;\n  strict: boolean;\n  outDir: string;\n}\n\n// Typed validation function\nfunction validateConfig(config: ProjectConfig): boolean {\n  return config.strict === true;\n}\n\n// Create typed config object\nlet myConfig: ProjectConfig = {\n  target: 'ES2024',\n  strict: true,\n  outDir: './dist'\n};\n\nconsole.log('Strict mode enabled?', validateConfig(myConfig)); // true\n\n// Test with strict mode disabled\nlet loosConfig: ProjectConfig = {\n  target: 'ES2024',\n  strict: false,\n  outDir: './dist'\n};\n\nconsole.log('Loose mode:', validateConfig(loosConfig)); // false",
              "hints": [
                "Add type annotations to the interface properties and function parameter."
              ],
              "testCases": [
                {
                  "description": "Should validate strict mode is enabled",
                  "input": "validateConfig({ target: 'ES2024', strict: true, outDir: './dist' })",
                  "expectedOutput": "true"
                },
                {
                  "description": "Should detect when strict mode is disabled",
                  "input": "validateConfig({ target: 'ES2024', strict: false, outDir: './dist' })",
                  "expectedOutput": "false"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-09-9-5",
          "title": "Converting JavaScript to TypeScript (The Upgrade Path)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Converting JavaScript to TypeScript (The Upgrade Path)\n\n## Understanding the Concept\n\nImagine you have a bicycle and you want to upgrade it to an electric bike:\n\nBicycle (JavaScript):\n- Works perfectly fine as-is\n- You can ride it anywhere\n- No extra features\n\nE-bike (TypeScript):\n- Same bicycle underneath\n- Added motor, battery, controls\n- More features and safety\n- Still works as a regular bike if battery dies\n\nConverting JavaScript to TypeScript is the same:\n- Start with working JavaScript code\n- Add type annotations (the electric components)\n- Get extra safety and features\n- The underlying logic stays the same!\n\nYou don't have to convert everything at once - you can gradually upgrade piece by piece.\n\n## Code Example\n\n```javascript\n// BEFORE: Plain JavaScript (works but no type safety)\nfunction calculateDiscount(price, discountPercent) {\n  if (discountPercent < 0 || discountPercent > 100) {\n    return 'Invalid discount';\n  }\n  let discount = price * (discountPercent / 100);\n  return price - discount;\n}\n\nlet product = {\n  name: 'Laptop',\n  price: 1000,\n  category: 'Electronics'\n};\n\nlet discountedPrice = calculateDiscount(product.price, 20);\nconsole.log('Original JavaScript:', discountedPrice); // 800\n\n// Problems with the JavaScript version:\n// calculateDiscount('abc', 'xyz')  // No error until runtime!\n// calculateDiscount(1000, 150)     // Accepts invalid discount percent\n\n// AFTER: TypeScript (type-safe)\ninterface Product {\n  name: string;\n  price: number;\n  category: string;\n}\n\nfunction calculateDiscountTyped(\n  price: number, \n  discountPercent: number\n): number | string {\n  if (discountPercent < 0 || discountPercent > 100) {\n    return 'Invalid discount';\n  }\n  let discount: number = price * (discountPercent / 100);\n  return price - discount;\n}\n\nlet typedProduct: Product = {\n  name: 'Laptop',\n  price: 1000,\n  category: 'Electronics'\n};\n\nlet typedDiscountedPrice = calculateDiscountTyped(typedProduct.price, 20);\nconsole.log('TypeScript version:', typedDiscountedPrice); // 800\n\n// These will now cause COMPILE-TIME errors:\n// calculateDiscountTyped('abc', 'xyz')  // ERROR: string is not assignable to number\n// calculateDiscountTyped(1000, 150)     // Still runs, but you can add validation\n\n// MIGRATION STRATEGY: Step-by-step conversion\n\n// Step 1: Rename .js files to .ts (start simple)\n// app.js → app.ts\n\n// Step 2: Add return types to functions\nfunction greet(name: string): string {\n  return `Hello, ${name}!`;\n}\n\n// Step 3: Add parameter types\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// Step 4: Create interfaces for complex objects\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// Step 5: Update variable declarations\nlet users: User[] = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' }\n];\n\n// Step 6: Enable strict mode in tsconfig.json (gradually)\n// Start with \"strict\": false, then enable incrementally\n\nconsole.log('Migration complete!');\nconsole.log('User count:', users.length); // 2\n```\n\n## Breaking Down the Syntax\n\nConverting JavaScript to TypeScript step-by-step:\n\n1. **File Renaming** (easiest step):\n   - `.js` → `.ts` (JavaScript → TypeScript)\n   - `.jsx` → `.tsx` (React files)\n   - All valid JavaScript is valid TypeScript!\n\n2. **Add Function Return Types**:\n   ```typescript\n   // Before\n   function getName() {\n     return 'Alice';\n   }\n   \n   // After\n   function getName(): string {\n     return 'Alice';\n   }\n   ```\n\n3. **Add Parameter Types**:\n   ```typescript\n   // Before\n   function greet(name) {\n     return `Hello, ${name}`;\n   }\n   \n   // After  \n   function greet(name: string): string {\n     return `Hello, ${name}`;\n   }\n   ```\n\n4. **Create Interfaces for Objects**:\n   ```typescript\n   // Before\n   let user = {\n     id: 1,\n     name: 'Alice'\n   };\n   \n   // After\n   interface User {\n     id: number;\n     name: string;\n   }\n   \n   let user: User = {\n     id: 1,\n     name: 'Alice'\n   };\n   ```\n\n5. **Type Arrays**:\n   ```typescript\n   // Before\n   let numbers = [1, 2, 3];\n   \n   // After\n   let numbers: number[] = [1, 2, 3];\n   ```\n\n6. **Union Types for Multiple Return Types**:\n   ```typescript\n   function getValue(): number | string {\n     // Can return either number or string\n   }\n   ```\n\n7. **Migration Strategy**:\n   - Start with strict: false in tsconfig.json\n   - Convert one file at a time\n   - Focus on functions and interfaces first\n   - Gradually enable strict checks\n   - Don't try to convert everything at once!\n\n## Common Mistakes & Tips\n\nCommon migration mistakes:\n\n1. **Trying to convert everything at once**:\n   - This is overwhelming and error-prone\n   - Convert one file or module at a time\n   - Start with core utilities, then work outward\n\n2. **Using 'any' everywhere**:\n   ```typescript\n   function process(data: any): any {  // Bad!\n     // ...\n   }\n   ```\n   - This defeats the purpose of TypeScript\n   - Take time to figure out the correct types\n   - Use 'any' only as a temporary placeholder\n\n3. **Ignoring type errors**:\n   - TypeScript errors are there to help!\n   - Don't use `@ts-ignore` to suppress them\n   - Fix the underlying issue instead\n\n4. **Not updating tests**:\n   - If you have .test.js files, convert them to .test.ts\n   - Add types to test data and assertions\n\n5. **Forgetting about third-party types**:\n   - Many libraries need type definitions\n   - Install them: `npm install -D @types/lodash`\n   - Check DefinitelyTyped for available types\n\n6. **Over-typing simple code**:\n   ```typescript\n   // Over-typed (unnecessary)\n   let name: string = 'Alice';\n   \n   // Better (type inference)\n   let name = 'Alice';  // TypeScript knows it's a string\n   ```\n   - Let TypeScript infer obvious types\n   - Add explicit types for function parameters and returns\n\n7. **Not communicating with team**:\n   - Migration affects everyone\n   - Set coding standards together\n   - Pair program on tricky conversions\n   - Document your migration strategy\n\nRemember: Migration is a gradual process. It's okay to have both .js and .ts files in your project during the transition!"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Convert this JavaScript code to TypeScript:\n\nYou have a function `getFullName` that takes a user object with firstName and lastName properties and returns the full name.\n\nTasks:\n1. Create a `User` interface with firstName and lastName (both strings)\n2. Add type annotations to the function parameter and return type\n3. Create a typed user object\n4. Test the function\n\nOriginal JavaScript:\n```javascript\nfunction getFullName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nlet user = {\n  firstName: 'Jane',\n  lastName: 'Doe'\n};\n```",
              "starterCode": "// Step 1: Create User interface\ninterface User {\n  // Add properties\n}\n\n// Step 2: Add types to function\nfunction getFullName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\n// Step 3: Create typed user\nlet user = {\n  firstName: 'Jane',\n  lastName: 'Doe'\n};\n\nconsole.log(getFullName(user));",
              "solution": "// Step 1: Create User interface\ninterface User {\n  firstName: string;\n  lastName: string;\n}\n\n// Step 2: Add types to function\nfunction getFullName(user: User): string {\n  return user.firstName + ' ' + user.lastName;\n}\n\n// Step 3: Create typed user\nlet user: User = {\n  firstName: 'Jane',\n  lastName: 'Doe'\n};\n\nconsole.log(getFullName(user)); // 'Jane Doe'\n\n// Bonus: Array of users\nlet users: User[] = [\n  { firstName: 'Jane', lastName: 'Doe' },\n  { firstName: 'John', lastName: 'Smith' }\n];\n\nfor (let u of users) {\n  console.log(getFullName(u));\n}\n// Output:\n// 'Jane Doe'\n// 'John Smith'",
              "hints": [
                "Add `: string` to both interface properties, `: User` to the function parameter, and `: string` for the return type."
              ],
              "testCases": [
                {
                  "description": "Should return full name",
                  "input": "getFullName({ firstName: 'Jane', lastName: 'Doe' })",
                  "expectedOutput": "Jane Doe"
                },
                {
                  "description": "Should work with different names",
                  "input": "getFullName({ firstName: 'John', lastName: 'Smith' })",
                  "expectedOutput": "John Smith"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "module-10",
      "title": "Module 10: Building for the Server - Node.js & Express",
      "description": "Learn how to build server-side applications with Node.js 24 and Express 5, handling HTTP requests, routing, and APIs",
      "difficulty": "intermediate",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-10-10-1",
          "title": "What Is Node.js? (The Restaurant Kitchen Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# What Is Node.js? (The Restaurant Kitchen Analogy)\n\n## Understanding the Concept\n\nImagine the difference between a food truck and a restaurant:\n\nFood Truck (Browser JavaScript):\n- Serves food directly to customers on the street\n- Limited space and equipment\n- Can't do heavy-duty cooking\n- Works in one location at a time\n\nRestaurant Kitchen (Node.js):\n- Behind the scenes, powerful equipment\n- Can handle many orders simultaneously\n- Access to storage, databases, file systems\n- Can coordinate multiple stations (services)\n- Sends finished dishes out to customers\n\nNode.js is JavaScript running on the server (the kitchen), not in the browser (the food truck). It can do things browser JavaScript can't: read files, connect to databases, handle thousands of requests, and much more!\n\n## Code Example\n\n```javascript\n// Node.js 24 LTS 'Krypton' - Server-Side JavaScript (2025)\n\n// BUILT-IN MODULES - Node.js comes with powerful tools\n// (Note: These won't work in browser JavaScript!)\n\n// 1. FILE SYSTEM - Read and write files\n// const fs = require('fs');\n// In this demo, we'll simulate file operations\n\nlet simulatedFileContent = 'Hello from a file!';\nconsole.log('File content:', simulatedFileContent);\n\n// 2. PATH - Handle file paths across operating systems\nfunction joinPath(...parts) {\n  return parts.join('/');\n}\n\nlet filePath = joinPath('users', 'documents', 'notes.txt');\nconsole.log('File path:', filePath); // 'users/documents/notes.txt'\n\n// 3. HTTP - Create web servers\n// In Node.js, you can create a server with built-in modules:\n// const http = require('http');\n// const server = http.createServer((req, res) => {\n//   res.writeHead(200, { 'Content-Type': 'text/plain' });\n//   res.end('Hello from Node.js server!');\n// });\n// server.listen(3000);\n\nconsole.log('Node.js can create web servers!');\n\n// 4. PROCESS - Information about the running program\n// Node.js provides a global 'process' object\nlet nodeVersion = 'v24.11.0'; // Node.js 24 LTS\nlet platform = 'linux'; // Could be 'win32', 'darwin' (macOS), etc.\n\nconsole.log('Node.js version:', nodeVersion);\nconsole.log('Platform:', platform);\n\n// 5. ASYNCHRONOUS BY DEFAULT - Node.js is built for async\nfunction simulateFileRead(filename, callback) {\n  // In real Node.js: fs.readFile(filename, 'utf8', callback);\n  setTimeout(() => {\n    callback(null, `Contents of ${filename}`);\n  }, 100);\n}\n\nsimulatFileRead('data.txt', (error, data) => {\n  if (error) {\n    console.log('Error reading file:', error);\n  } else {\n    console.log('File data:', data);\n  }\n});\n\n// 6. NPM PACKAGES - Access to millions of libraries\n// Node.js uses npm (Node Package Manager)\n// You can install packages like:\n// npm install express\n// npm install mongoose\n// npm install axios\n\nconsole.log('Node.js has access to 2+ million npm packages!');\n\n// 7. COMMONJS vs ES MODULES (Node.js 24 supports both)\n// CommonJS (older style):\n// const express = require('express');\n\n// ES Modules (modern style, recommended):\n// import express from 'express';\n\n// Node.js 24 fully supports ES modules!\n\n// 8. NEW IN NODE.JS 24 - Explicit Resource Management\nclass DatabaseConnection {\n  constructor() {\n    console.log('Database connected');\n  }\n  \n  query(sql) {\n    console.log('Executing:', sql);\n    return { rows: [] };\n  }\n  \n  close() {\n    console.log('Database disconnected');\n  }\n}\n\n// Using keyword ensures cleanup (Node.js 24 feature)\nlet db = new DatabaseConnection();\ndb.query('SELECT * FROM users');\ndb.close(); // Always clean up resources!\n\nconsole.log('Node.js 24 supports explicit resource management!');\n```\n\n## Breaking Down the Syntax\n\nUnderstanding Node.js fundamentals:\n\n1. **Server-Side JavaScript**:\n   - JavaScript outside the browser\n   - Runs on your computer/server\n   - Has access to file system, network, etc.\n   - No DOM, no window object\n\n2. **Built-in Modules**:\n   - `fs`: File system operations\n   - `path`: File path utilities\n   - `http`: Create web servers\n   - `crypto`: Encryption and hashing\n   - `os`: Operating system information\n   - Import with: `import fs from 'fs'` (ES modules)\n\n3. **Global Objects** (available everywhere):\n   - `process`: Info about current Node.js process\n   - `__dirname`: Current directory path\n   - `__filename`: Current file path\n   - `console`: Same as browser console\n   - `setTimeout`, `setInterval`: Same as browser\n\n4. **NPM (Node Package Manager)**:\n   - Install packages: `npm install package-name`\n   - Save to dependencies: `npm install --save express`\n   - Dev dependencies: `npm install --save-dev typescript`\n   - package.json tracks all dependencies\n\n5. **Module Systems** (Node.js 24):\n   - CommonJS: `require()` and `module.exports`\n   - ES Modules: `import` and `export` (recommended)\n   - Use \"type\": \"module\" in package.json for ES modules\n\n6. **Async-First Design**:\n   - Most Node.js operations are asynchronous\n   - Use callbacks, Promises, or async/await\n   - Non-blocking I/O for high performance\n\n7. **Running Node.js Code**:\n   - Save file as `app.js`\n   - Run with: `node app.js`\n   - No browser needed!\n\n## Common Mistakes & Tips\n\nCommon Node.js beginner mistakes:\n\n1. **Trying to use browser APIs**:\n   ```javascript\n   // ERROR in Node.js - no DOM!\n   document.getElementById('app'); // ReferenceError: document is not defined\n   window.location.href;           // ReferenceError: window is not defined\n   ```\n   Solution: Node.js is for servers, not browsers\n\n2. **Forgetting Node.js is async**:\n   ```javascript\n   // Wrong - file might not be read yet\n   let data;\n   fs.readFile('file.txt', (err, content) => {\n     data = content;\n   });\n   console.log(data); // undefined!\n   ```\n   Solution: Use callbacks, Promises, or async/await\n\n3. **Module confusion**: `require()` vs `import`\n   - Old style: `const fs = require('fs')`\n   - New style: `import fs from 'fs'` (need \"type\": \"module\" in package.json)\n   - Can't mix both in the same file!\n\n4. **Not handling errors**:\n   ```javascript\n   // Dangerous - no error handling\n   fs.readFile('file.txt', (err, data) => {\n     console.log(data.toString()); // Crashes if file doesn't exist!\n   });\n   ```\n   Solution: Always check for errors first\n\n5. **Wrong file paths**:\n   - Use `path.join()` for cross-platform compatibility\n   - Use `__dirname` for absolute paths\n   - Don't hardcode paths like `C:\\Users\\...`\n\n6. **Not installing dependencies**:\n   - `npm install` before running the app\n   - Check package.json for required packages\n   - Use .gitignore for node_modules/\n\n7. **Running browser code in Node.js**:\n   - Node.js and browser JavaScript are different environments\n   - Some code works in both, some doesn't\n   - Use bundlers (webpack, vite) for browser code"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a simple Node.js utility module:\n\n1. Create a function `getSystemInfo()` that returns an object with:\n   - `platform`: 'linux' (simulate process.platform)\n   - `nodeVersion`: 'v24.11.0'\n   - `uptime`: any number (simulate process.uptime())\n\n2. Create a function `readConfig(filename)` that:\n   - Takes a filename as a parameter\n   - Returns a Promise that resolves with simulated file content\n   - Use setTimeout to simulate async file reading\n\n3. Test both functions and log the results",
              "starterCode": "// System info function\nfunction getSystemInfo() {\n  return {\n    platform: 'linux',\n    nodeVersion: 'v24.11.0',\n    uptime: 12345\n  };\n}\n\n// Async file reading simulation\nfunction readConfig(filename) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(`Config from ${filename}`);\n    }, 100);\n  });\n}\n\n// Test the functions\nlet info = getSystemInfo();\nconsole.log('System:', info);\n\nreadConfig('app.config').then(data => {\n  console.log('Config:', data);\n});",
              "solution": "// Complete Node.js utility module\n\n// System info function\nfunction getSystemInfo() {\n  return {\n    platform: 'linux',\n    nodeVersion: 'v24.11.0',\n    uptime: 12345\n  };\n}\n\n// Async file reading simulation\nfunction readConfig(filename) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (!filename) {\n        reject(new Error('Filename is required'));\n      } else {\n        resolve(`Config from ${filename}`);\n      }\n    }, 100);\n  });\n}\n\n// Test the functions\nlet info = getSystemInfo();\nconsole.log('System info:', info);\nconsole.log('Platform:', info.platform);       // linux\nconsole.log('Node version:', info.nodeVersion); // v24.11.0\n\n// Test async config reading\nreadConfig('app.config').then(data => {\n  console.log('Config loaded:', data); // Config from app.config\n}).catch(error => {\n  console.log('Error:', error.message);\n});\n\n// Using async/await (modern pattern)\nasync function loadSystemConfig() {\n  try {\n    let config = await readConfig('database.config');\n    console.log('Database config:', config);\n  } catch (error) {\n    console.log('Failed to load config:', error.message);\n  }\n}\n\nloadSystemConfig();",
              "hints": [
                "Use new Promise((resolve, reject) => {...}) and setTimeout to simulate async operations."
              ],
              "testCases": [
                {
                  "description": "Should return system info",
                  "input": "getSystemInfo().platform",
                  "expectedOutput": "linux"
                },
                {
                  "description": "Should read config asynchronously",
                  "input": "readConfig('test.config').then(d => d)",
                  "expectedOutput": "Config from test.config"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-10-10-2",
          "title": "Your First Express Server (The Restaurant Manager Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Your First Express Server (The Restaurant Manager Analogy)\n\n## Understanding the Concept\n\nImagine running a restaurant:\n\nWithout a manager (plain Node.js HTTP):\n- You handle every customer request manually\n- You write the same instructions over and over\n- You manage reservations, orders, payments all yourself\n- Lots of repetitive work\n\nWith a manager (Express framework):\n- The manager handles common tasks automatically\n- Organized system for taking orders (routes)\n- Standardized way to serve dishes (responses)\n- Easy to add new menu items (endpoints)\n- Less work, more organized!\n\nExpress is like a restaurant manager for your Node.js server. It handles the repetitive stuff so you can focus on your unique features!\n\n## Code Example\n\n```javascript\n// Express 5.1 - Modern Web Framework (2025)\n// Note: This is simulated Express code for learning\n\n// BASIC EXPRESS SERVER STRUCTURE\n\n// Step 1: Import Express (in real Node.js)\n// import express from 'express';\n\n// Step 2: Create an Express application\n// const app = express();\n\n// For this demo, we'll simulate Express behavior:\nclass ExpressApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n    console.log(`Route registered: GET ${path}`);\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n    console.log(`Route registered: POST ${path}`);\n  }\n  \n  listen(port, callback) {\n    console.log(`Server listening on port ${port}`);\n    if (callback) callback();\n  }\n  \n  simulateRequest(method, path) {\n    let route = this.routes.find(r => r.method === method && r.path === path);\n    if (route) {\n      let req = { method, path, query: {}, params: {}, body: {} };\n      let res = {\n        status: function(code) {\n          this.statusCode = code;\n          return this;\n        },\n        json: function(data) {\n          console.log(`Response [${this.statusCode || 200}]:`, JSON.stringify(data));\n        },\n        send: function(data) {\n          console.log(`Response [${this.statusCode || 200}]:`, data);\n        }\n      };\n      route.handler(req, res);\n    } else {\n      console.log(`404 Not Found: ${method} ${path}`);\n    }\n  }\n}\n\nlet app = new ExpressApp();\n\n// ROUTE DEFINITIONS\n\n// 1. Simple GET route - Homepage\napp.get('/', (req, res) => {\n  res.send('Welcome to Express 5.1!');\n});\n\n// 2. GET route with response data\napp.get('/api/status', (req, res) => {\n  res.json({\n    status: 'online',\n    version: '1.0.0',\n    timestamp: Date.now()\n  });\n});\n\n// 3. GET route - List of users\napp.get('/api/users', (req, res) => {\n  let users = [\n    { id: 1, name: 'Alice', email: 'alice@example.com' },\n    { id: 2, name: 'Bob', email: 'bob@example.com' }\n  ];\n  res.json(users);\n});\n\n// 4. POST route - Create new user\napp.post('/api/users', (req, res) => {\n  // In real Express: let newUser = req.body;\n  let newUser = { id: 3, name: 'Charlie', email: 'charlie@example.com' };\n  \n  res.status(201).json({\n    message: 'User created successfully',\n    user: newUser\n  });\n});\n\n// 5. Error handling route\napp.get('/api/error', (req, res) => {\n  res.status(500).json({\n    error: 'Something went wrong!',\n    message: 'Internal server error'\n  });\n});\n\n// Start the server\napp.listen(3000, () => {\n  console.log('Express server is ready!');\n});\n\n// SIMULATE REQUESTS (to demonstrate the routes)\nconsole.log('\\n--- Simulating HTTP Requests ---\\n');\n\napp.simulateRequest('GET', '/');\napp.simulateRequest('GET', '/api/status');\napp.simulateRequest('GET', '/api/users');\napp.simulateRequest('POST', '/api/users');\napp.simulateRequest('GET', '/api/error');\napp.simulateRequest('GET', '/api/notfound');\n```\n\n## Breaking Down the Syntax\n\nUnderstanding Express fundamentals:\n\n1. **Creating an Express App**:\n   ```javascript\n   import express from 'express';\n   const app = express();\n   ```\n   - `express()` creates a new application\n   - `app` is your main server object\n\n2. **Route Methods** (HTTP verbs):\n   - `app.get()` - Read data\n   - `app.post()` - Create data\n   - `app.put()` - Update data (replace)\n   - `app.patch()` - Update data (partial)\n   - `app.delete()` - Delete data\n\n3. **Route Structure**: `app.get(path, handler)`\n   - Path: URL pattern (`'/'`, `'/api/users'`)\n   - Handler: Function that runs when route is accessed\n   - Handler gets `req` (request) and `res` (response)\n\n4. **Request Object (req)**:\n   - `req.params` - URL parameters (`/users/:id`)\n   - `req.query` - Query strings (`?search=hello`)\n   - `req.body` - POST/PUT data\n   - `req.headers` - HTTP headers\n\n5. **Response Object (res)**:\n   - `res.send()` - Send text/HTML\n   - `res.json()` - Send JSON data\n   - `res.status()` - Set status code (200, 404, 500, etc.)\n   - `res.sendFile()` - Send a file\n\n6. **Status Codes**:\n   - 200: OK (success)\n   - 201: Created (new resource)\n   - 400: Bad Request (client error)\n   - 404: Not Found\n   - 500: Internal Server Error\n\n7. **Starting the Server**:\n   ```javascript\n   app.listen(3000, () => {\n     console.log('Server running on port 3000');\n   });\n   ```\n   - Port 3000 is common for development\n   - Callback runs when server starts\n   - Server keeps running until you stop it (Ctrl+C)\n\n## Common Mistakes & Tips\n\nCommon Express mistakes:\n\n1. **Forgetting to call res.send() or res.json()**:\n   ```javascript\n   app.get('/api/users', (req, res) => {\n     let users = getUsers();\n     // Missing res.json(users)! Request will hang\n   });\n   ```\n   Solution: Always send a response!\n\n2. **Sending multiple responses**:\n   ```javascript\n   app.get('/api/data', (req, res) => {\n     res.json({ data: 'first' });\n     res.json({ data: 'second' }); // ERROR: Can't send twice!\n   });\n   ```\n   Solution: Only call res.send/json once per request\n\n3. **Route order matters**:\n   ```javascript\n   app.get('/api/users/active', ...);  // Must come first\n   app.get('/api/users/:id', ...);     // This would match /api/users/active too!\n   ```\n   Solution: Put specific routes before parameterized routes\n\n4. **Not parsing request body**:\n   ```javascript\n   // Need middleware to parse JSON\n   app.use(express.json()); // Add this line!\n   \n   app.post('/api/users', (req, res) => {\n     console.log(req.body); // Now this works\n   });\n   ```\n\n5. **Wrong port (already in use)**:\n   - Error: \"EADDRINUSE: Port 3000 already in use\"\n   - Solution: Use a different port or kill the other process\n\n6. **Not handling errors**:\n   ```javascript\n   app.get('/api/users/:id', (req, res) => {\n     let user = findUser(req.params.id);\n     if (!user) {\n       return res.status(404).json({ error: 'User not found' });\n     }\n     res.json(user);\n   });\n   ```\n   Always check if data exists before sending!\n\n7. **Mixing up req.params, req.query, and req.body**:\n   - `req.params`: URL parameters (`/users/:id`)\n   - `req.query`: Query strings (`?search=hello`)\n   - `req.body`: POST/PUT request data"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a simple API for a todo list:\n\n1. Create a GET route `/api/todos` that returns an array of todo objects\n   - Each todo should have: id, task, completed\n\n2. Create a POST route `/api/todos` that:\n   - Simulates creating a new todo\n   - Returns status 201 and the new todo\n\n3. Create a GET route `/api/todos/completed` that:\n   - Returns only completed todos\n\nUse the ExpressApp class from the example. Simulate requests to test your routes.",
              "starterCode": "// Express app simulation\nclass ExpressApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n  }\n  \n  simulateRequest(method, path) {\n    let route = this.routes.find(r => r.method === method && r.path === path);\n    if (route) {\n      let req = { method, path };\n      let res = {\n        status: function(code) { this.statusCode = code; return this; },\n        json: function(data) { console.log(`[${this.statusCode || 200}]`, JSON.stringify(data)); }\n      };\n      route.handler(req, res);\n    }\n  }\n}\n\nlet app = new ExpressApp();\n\n// Sample todo data\nlet todos = [\n  { id: 1, task: 'Learn Express', completed: false },\n  { id: 2, task: 'Build an API', completed: true }\n];\n\n// TODO: Add your routes here\n\n// Test your routes\napp.simulateRequest('GET', '/api/todos');\napp.simulateRequest('POST', '/api/todos');\napp.simulateRequest('GET', '/api/todos/completed');",
              "solution": "// Express app simulation\nclass ExpressApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n  }\n  \n  simulateRequest(method, path) {\n    let route = this.routes.find(r => r.method === method && r.path === path);\n    if (route) {\n      let req = { method, path };\n      let res = {\n        status: function(code) { this.statusCode = code; return this; },\n        json: function(data) { console.log(`[${this.statusCode || 200}]`, JSON.stringify(data)); }\n      };\n      route.handler(req, res);\n    }\n  }\n}\n\nlet app = new ExpressApp();\n\n// Sample todo data\nlet todos = [\n  { id: 1, task: 'Learn Express', completed: false },\n  { id: 2, task: 'Build an API', completed: true },\n  { id: 3, task: 'Deploy app', completed: true }\n];\n\n// Route 1: Get all todos\napp.get('/api/todos', (req, res) => {\n  res.json(todos);\n});\n\n// Route 2: Create new todo\napp.post('/api/todos', (req, res) => {\n  let newTodo = {\n    id: todos.length + 1,\n    task: 'New task',\n    completed: false\n  };\n  todos.push(newTodo);\n  \n  res.status(201).json({\n    message: 'Todo created',\n    todo: newTodo\n  });\n});\n\n// Route 3: Get completed todos only\napp.get('/api/todos/completed', (req, res) => {\n  let completedTodos = todos.filter(t => t.completed);\n  res.json(completedTodos);\n});\n\n// Test the routes\nconsole.log('All todos:');\napp.simulateRequest('GET', '/api/todos');\n\nconsole.log('\\nCreate todo:');\napp.simulateRequest('POST', '/api/todos');\n\nconsole.log('\\nCompleted todos:');\napp.simulateRequest('GET', '/api/todos/completed');",
              "hints": [
                "Use app.get() and app.post(). For filtering, use todos.filter(t => t.completed)."
              ],
              "testCases": [
                {
                  "description": "Should return all todos",
                  "input": "let todos = [{ id: 1, task: 'Test', completed: false }]; todos.length",
                  "expectedOutput": "1"
                },
                {
                  "description": "Should filter completed todos",
                  "input": "let todos = [{ id: 1, task: 'A', completed: true }, { id: 2, task: 'B', completed: false }]; todos.filter(t => t.completed).length",
                  "expectedOutput": "1"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-10-10-3",
          "title": "Routing and Parameters (The Address System Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Routing and Parameters (The Address System Analogy)\n\n## Understanding the Concept\n\nImagine delivering packages in a city:\n\nSimple addresses (static routes):\n- 123 Main Street (exact address)\n- City Hall (exact location)\n- Central Park (exact destination)\n\nDynamic addresses (parameterized routes):\n- \"Apartment {number} on Floor {floor}\" → Many apartments, one pattern\n- \"House number {X} on {Street Name}\" → Any house, flexible pattern\n- \"Locker {number} at Gym\" → Dynamic, but follows a pattern\n\nExpress routing works the same way:\n- Static routes: `/about`, `/contact` (exact paths)\n- Dynamic routes: `/users/:id`, `/products/:category/:item` (pattern-based)\n\nParameters let you create one route that handles many similar requests!\n\n## Code Example\n\n```javascript\n// Express 5.1 - Advanced Routing (2025)\n\n// Simulated Express with routing features\nclass ExpressApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  simulateRequest(method, url) {\n    console.log(`\\n${method} ${url}`);\n    \n    for (let route of this.routes) {\n      if (route.method !== method) continue;\n      \n      let params = this.matchRoute(route.path, url);\n      if (params !== null) {\n        let [path, queryString] = url.split('?');\n        let query = this.parseQuery(queryString);\n        \n        let req = { method, url, params, query };\n        let res = {\n          json: (data) => console.log('Response:', JSON.stringify(data)),\n          status: function(code) { this.statusCode = code; return this; }\n        };\n        \n        route.handler(req, res);\n        return;\n      }\n    }\n    \n    console.log('404 Not Found');\n  }\n  \n  matchRoute(pattern, url) {\n    let [urlPath] = url.split('?');\n    let patternParts = pattern.split('/');\n    let urlParts = urlPath.split('/');\n    \n    if (patternParts.length !== urlParts.length) return null;\n    \n    let params = {};\n    for (let i = 0; i < patternParts.length; i++) {\n      if (patternParts[i].startsWith(':')) {\n        let paramName = patternParts[i].slice(1);\n        params[paramName] = urlParts[i];\n      } else if (patternParts[i] !== urlParts[i]) {\n        return null;\n      }\n    }\n    return params;\n  }\n  \n  parseQuery(queryString) {\n    if (!queryString) return {};\n    let query = {};\n    queryString.split('&').forEach(pair => {\n      let [key, value] = pair.split('=');\n      query[key] = value;\n    });\n    return query;\n  }\n}\n\nlet app = new ExpressApp();\n\n// ROUTE PARAMETERS (Dynamic segments in URL)\n\n// 1. Single parameter - Get user by ID\napp.get('/api/users/:id', (req, res) => {\n  let userId = req.params.id;\n  \n  // Simulate database lookup\n  let user = {\n    id: userId,\n    name: 'Alice',\n    email: 'alice@example.com'\n  };\n  \n  res.json(user);\n});\n\n// 2. Multiple parameters - Get specific product\napp.get('/api/products/:category/:productId', (req, res) => {\n  let { category, productId } = req.params;\n  \n  res.json({\n    category: category,\n    productId: productId,\n    name: 'Sample Product',\n    price: 29.99\n  });\n});\n\n// 3. Query parameters - Search and filter\napp.get('/api/search', (req, res) => {\n  // Access with req.query\n  let { q, category, minPrice, maxPrice } = req.query;\n  \n  res.json({\n    searchTerm: q || 'none',\n    category: category || 'all',\n    priceRange: {\n      min: minPrice || 0,\n      max: maxPrice || 'unlimited'\n    },\n    results: [\n      { id: 1, name: 'Product A' },\n      { id: 2, name: 'Product B' }\n    ]\n  });\n});\n\n// 4. Combining params and query\napp.get('/api/categories/:category/products', (req, res) => {\n  let category = req.params.category;\n  let { sort, limit } = req.query;\n  \n  res.json({\n    category: category,\n    sortBy: sort || 'name',\n    limit: limit || 10,\n    products: ['Product 1', 'Product 2']\n  });\n});\n\n// TEST THE ROUTES\n\n// Parameter examples\napp.simulateRequest('GET', '/api/users/42');\napp.simulateRequest('GET', '/api/users/999');\n\napp.simulateRequest('GET', '/api/products/electronics/laptop-123');\napp.simulateRequest('GET', '/api/products/books/novel-456');\n\n// Query parameter examples  \napp.simulateRequest('GET', '/api/search?q=laptop&category=electronics&minPrice=500&maxPrice=2000');\napp.simulateRequest('GET', '/api/search?q=headphones');\n\n// Combined params and query\napp.simulateRequest('GET', '/api/categories/electronics/products?sort=price&limit=20');\napp.simulateRequest('GET', '/api/categories/books/products');\n```\n\n## Breaking Down the Syntax\n\nUnderstanding Express routing:\n\n1. **Route Parameters** (`:paramName`):\n   ```javascript\n   app.get('/users/:id', (req, res) => {\n     let id = req.params.id;  // Extract from URL\n   });\n   ```\n   - Colon `:` marks a parameter\n   - Matches any value in that position\n   - `/users/42` → `req.params.id = '42'`\n   - `/users/alice` → `req.params.id = 'alice'`\n\n2. **Multiple Parameters**:\n   ```javascript\n   app.get('/posts/:year/:month/:day', (req, res) => {\n     let { year, month, day } = req.params;\n     // /posts/2025/01/15 → year=2025, month=01, day=15\n   });\n   ```\n\n3. **Query Parameters** (after `?`):\n   ```javascript\n   // URL: /search?q=express&page=2\n   app.get('/search', (req, res) => {\n     let searchTerm = req.query.q;     // 'express'\n     let page = req.query.page;        // '2'\n   });\n   ```\n   - Not part of the route pattern\n   - Optional by default\n   - Multiple values: `?key1=value1&key2=value2`\n\n4. **Parameter vs Query - When to Use**:\n   - **Route parameters** (`:id`):\n     * Required parts of the URL\n     * Identifying resources\n     * `/users/:userId/posts/:postId`\n   \n   - **Query parameters** (`?key=value`):\n     * Optional filters\n     * Search terms\n     * Pagination, sorting\n     * `/products?category=books&sort=price&page=2`\n\n5. **Accessing Parameters**:\n   - `req.params` → Object with route parameters\n   - `req.query` → Object with query parameters\n   - `req.body` → Object with POST/PUT data (needs middleware)\n\n6. **Type Conversion**:\n   ```javascript\n   app.get('/api/users/:id', (req, res) => {\n     // req.params.id is always a STRING\n     let userId = parseInt(req.params.id);  // Convert to number\n     let page = parseInt(req.query.page) || 1; // Default to 1\n   });\n   ```\n   All parameters come as strings - convert as needed!\n\n## Common Mistakes & Tips\n\nCommon routing mistakes:\n\n1. **Parameter type confusion**:\n   ```javascript\n   app.get('/users/:id', (req, res) => {\n     if (req.params.id > 100) {  // String comparison! '9' > '100' is true!\n       // Wrong!\n     }\n     \n     // Correct:\n     if (parseInt(req.params.id) > 100) {\n       // Right!\n     }\n   });\n   ```\n   Remember: ALL params and query values are strings!\n\n2. **Route order conflicts**:\n   ```javascript\n   // Wrong order!\n   app.get('/users/:id', ...);        // This matches EVERYTHING\n   app.get('/users/active', ...);     // Never reached!\n   \n   // Correct order:\n   app.get('/users/active', ...);     // Specific route first\n   app.get('/users/:id', ...);        // Generic route last\n   ```\n\n3. **Missing query parameters**:\n   ```javascript\n   app.get('/search', (req, res) => {\n     let limit = req.query.limit;  // undefined if not provided!\n     \n     // Better:\n     let limit = req.query.limit || 10;  // Default value\n     let limit = parseInt(req.query.limit) || 10;  // With parsing\n   });\n   ```\n\n4. **Confusing params, query, and body**:\n   - URL: `/api/users/42?active=true`\n   - `req.params.id` → '42' (from `:id`)\n   - `req.query.active` → 'true' (from `?active=true`)\n   - `req.body` → POST/PUT data (not in GET requests)\n\n5. **Complex parameter patterns**:\n   ```javascript\n   // This works but is confusing:\n   app.get('/api/:version/:resource/:id/:action', ...);\n   \n   // Better - use query params for optional stuff:\n   app.get('/api/v1/users/:id', ...);\n   ```\n   Keep route patterns simple and predictable!\n\n6. **Forgetting URL encoding**:\n   - Query values may contain special characters\n   - `?search=hello world` → Spaces become `%20`\n   - Express automatically decodes for you\n   - Use `encodeURIComponent()` when building URLs"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a blog API with routing:\n\n1. GET `/api/posts/:postId` - Get a specific post by ID\n   - Return object with: postId, title, content\n\n2. GET `/api/authors/:authorId/posts` - Get all posts by an author\n   - Return array of posts with authorId in each\n\n3. GET `/api/posts` with query parameters - Search posts\n   - Support: `?search=keyword&category=tech&limit=10`\n   - Return search parameters and mock results\n\nUse the ExpressApp class. Test all routes with simulated requests.",
              "starterCode": "class ExpressApp {\n  constructor() { this.routes = []; }\n  get(path, handler) { this.routes.push({ method: 'GET', path, handler }); }\n  simulateRequest(method, url) {\n    console.log(`\\n${method} ${url}`);\n    for (let route of this.routes) {\n      if (route.method !== method) continue;\n      let params = this.matchRoute(route.path, url);\n      if (params !== null) {\n        let [path, queryString] = url.split('?');\n        let query = this.parseQuery(queryString);\n        let req = { params, query };\n        let res = { json: (d) => console.log(JSON.stringify(d)) };\n        route.handler(req, res);\n        return;\n      }\n    }\n  }\n  matchRoute(pattern, url) {\n    let [urlPath] = url.split('?');\n    let patternParts = pattern.split('/');\n    let urlParts = urlPath.split('/');\n    if (patternParts.length !== urlParts.length) return null;\n    let params = {};\n    for (let i = 0; i < patternParts.length; i++) {\n      if (patternParts[i].startsWith(':')) {\n        params[patternParts[i].slice(1)] = urlParts[i];\n      } else if (patternParts[i] !== urlParts[i]) return null;\n    }\n    return params;\n  }\n  parseQuery(qs) {\n    if (!qs) return {};\n    let q = {};\n    qs.split('&').forEach(p => { let [k,v] = p.split('='); q[k] = v; });\n    return q;\n  }\n}\n\nlet app = new ExpressApp();\n\n// TODO: Add your routes here\n\n// Test routes\napp.simulateRequest('GET', '/api/posts/123');\napp.simulateRequest('GET', '/api/authors/42/posts');\napp.simulateRequest('GET', '/api/posts?search=express&category=tech&limit=5');",
              "solution": "class ExpressApp {\n  constructor() { this.routes = []; }\n  get(path, handler) { this.routes.push({ method: 'GET', path, handler }); }\n  simulateRequest(method, url) {\n    console.log(`\\n${method} ${url}`);\n    for (let route of this.routes) {\n      if (route.method !== method) continue;\n      let params = this.matchRoute(route.path, url);\n      if (params !== null) {\n        let [path, queryString] = url.split('?');\n        let query = this.parseQuery(queryString);\n        let req = { params, query };\n        let res = { json: (d) => console.log(JSON.stringify(d, null, 2)) };\n        route.handler(req, res);\n        return;\n      }\n    }\n    console.log('404 Not Found');\n  }\n  matchRoute(pattern, url) {\n    let [urlPath] = url.split('?');\n    let patternParts = pattern.split('/');\n    let urlParts = urlPath.split('/');\n    if (patternParts.length !== urlParts.length) return null;\n    let params = {};\n    for (let i = 0; i < patternParts.length; i++) {\n      if (patternParts[i].startsWith(':')) {\n        params[patternParts[i].slice(1)] = urlParts[i];\n      } else if (patternParts[i] !== urlParts[i]) return null;\n    }\n    return params;\n  }\n  parseQuery(qs) {\n    if (!qs) return {};\n    let q = {};\n    qs.split('&').forEach(p => { let [k,v] = p.split('='); q[k] = v; });\n    return q;\n  }\n}\n\nlet app = new ExpressApp();\n\n// Route 1: Get specific post\napp.get('/api/posts/:postId', (req, res) => {\n  let { postId } = req.params;\n  \n  res.json({\n    postId: postId,\n    title: `Post ${postId} Title`,\n    content: 'This is the post content...',\n    author: 'Alice'\n  });\n});\n\n// Route 2: Get posts by author\napp.get('/api/authors/:authorId/posts', (req, res) => {\n  let { authorId } = req.params;\n  \n  res.json({\n    authorId: authorId,\n    posts: [\n      { id: 1, title: 'First Post', content: 'Content 1' },\n      { id: 2, title: 'Second Post', content: 'Content 2' }\n    ]\n  });\n});\n\n// Route 3: Search posts with query parameters\napp.get('/api/posts', (req, res) => {\n  let { search, category, limit } = req.query;\n  \n  res.json({\n    search: search || 'all',\n    category: category || 'all',\n    limit: limit || '10',\n    results: [\n      { id: 1, title: 'Express Tutorial', category: 'tech' },\n      { id: 2, title: 'Node.js Guide', category: 'tech' }\n    ]\n  });\n});\n\n// Test all routes\napp.simulateRequest('GET', '/api/posts/123');\napp.simulateRequest('GET', '/api/authors/42/posts');\napp.simulateRequest('GET', '/api/posts?search=express&category=tech&limit=5');\napp.simulateRequest('GET', '/api/posts');",
              "hints": [
                "Use req.params for :postId and :authorId. Use req.query for search parameters."
              ],
              "testCases": [
                {
                  "description": "Should extract post ID from params",
                  "input": "let params = { postId: '123' }; params.postId",
                  "expectedOutput": "123"
                },
                {
                  "description": "Should parse query parameters",
                  "input": "let query = { search: 'test', limit: '10' }; query.limit",
                  "expectedOutput": "10"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-10-10-4",
          "title": "Middleware (The Assembly Line Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Middleware (The Assembly Line Analogy)\n\n## Understanding the Concept\n\nImagine a factory assembly line:\n\nWithout assembly line (no middleware):\n- One worker does EVERYTHING for each product\n- Unwrap materials, assemble, test, package, label\n- Repetitive, inefficient, error-prone\n\nWith assembly line (middleware):\n- Station 1: Unwrap and inspect materials (authentication)\n- Station 2: Assemble parts (body parsing)\n- Station 3: Quality check (validation)\n- Station 4: Package product (route handler)\n- Station 5: Add label (response formatting)\n\nEach station does one job, passes to the next!\n\nExpress middleware works the same way:\n- Request comes in\n- Passes through middleware functions in order\n- Each middleware does one specific task\n- Finally reaches your route handler\n- Response goes back to client\n\nMiddleware = functions that process requests before they reach your routes!\n\n## Code Example\n\n```javascript\n// Express 5.1 - Middleware (2025)\n\n// Simulated Express with middleware support\nclass ExpressApp {\n  constructor() {\n    this.routes = [];\n    this.middleware = [];\n  }\n  \n  use(handler) {\n    this.middleware.push(handler);\n    console.log('Middleware registered');\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n  }\n  \n  simulateRequest(method, path, body = null) {\n    console.log(`\\n--- ${method} ${path} ---`);\n    \n    let req = { \n      method, \n      path, \n      body: body,\n      headers: { 'user-agent': 'Test Client' },\n      timestamp: Date.now()\n    };\n    \n    let res = {\n      statusCode: 200,\n      headers: {},\n      sent: false,\n      json: function(data) {\n        if (this.sent) {\n          console.log('ERROR: Response already sent!');\n          return;\n        }\n        this.sent = true;\n        console.log(`Response [${this.statusCode}]:`, JSON.stringify(data));\n      },\n      status: function(code) {\n        this.statusCode = code;\n        return this;\n      },\n      setHeader: function(key, value) {\n        this.headers[key] = value;\n      }\n    };\n    \n    // Run middleware chain\n    let middlewareIndex = 0;\n    \n    let next = () => {\n      if (middlewareIndex < this.middleware.length) {\n        let currentMiddleware = this.middleware[middlewareIndex++];\n        currentMiddleware(req, res, next);\n      } else {\n        // Middleware done, find and run route handler\n        let route = this.routes.find(r => r.method === method && r.path === path);\n        if (route) {\n          route.handler(req, res);\n        } else {\n          res.status(404).json({ error: 'Not found' });\n        }\n      }\n    };\n    \n    next(); // Start middleware chain\n  }\n}\n\nlet app = new ExpressApp();\n\n// MIDDLEWARE EXAMPLES\n\n// 1. Logging Middleware - Runs on EVERY request\napp.use((req, res, next) => {\n  console.log(`[LOG] ${req.method} ${req.path} at ${new Date(req.timestamp).toISOString()}`);\n  next(); // MUST call next() to continue!\n});\n\n// 2. Request Timing Middleware\napp.use((req, res, next) => {\n  req.startTime = Date.now();\n  \n  // Wrap res.json to add timing\n  let originalJson = res.json;\n  res.json = function(data) {\n    let duration = Date.now() - req.startTime;\n    console.log(`[TIMING] Request took ${duration}ms`);\n    originalJson.call(this, data);\n  };\n  \n  next();\n});\n\n// 3. Authentication Middleware\napp.use((req, res, next) => {\n  // Simulate checking auth token\n  let token = req.headers['authorization'] || 'valid-token';\n  \n  if (token === 'valid-token') {\n    req.user = { id: 1, name: 'Alice', role: 'admin' };\n    console.log('[AUTH] User authenticated:', req.user.name);\n    next();\n  } else {\n    console.log('[AUTH] Invalid token!');\n    res.status(401).json({ error: 'Unauthorized' });\n    // Note: No next() call - request stops here!\n  }\n});\n\n// 4. Request Body Parser Middleware (simulated)\napp.use((req, res, next) => {\n  if (req.method === 'POST' && req.body) {\n    // In real Express: express.json() does this\n    console.log('[PARSER] Parsing JSON body');\n    // req.body is already parsed in our simulation\n  }\n  next();\n});\n\n// ROUTES (run AFTER middleware)\n\napp.get('/api/public', (req, res) => {\n  res.json({ \n    message: 'Public endpoint',\n    user: req.user ? req.user.name : 'anonymous'\n  });\n});\n\napp.get('/api/protected', (req, res) => {\n  // req.user added by auth middleware\n  res.json({ \n    message: 'Protected data',\n    user: req.user.name,\n    role: req.user.role\n  });\n});\n\napp.post('/api/data', (req, res) => {\n  res.json({ \n    message: 'Data received',\n    data: req.body,\n    processedBy: req.user.name\n  });\n});\n\n// TEST MIDDLEWARE CHAIN\n\napp.simulateRequest('GET', '/api/public');\napp.simulateRequest('GET', '/api/protected');\napp.simulateRequest('POST', '/api/data', { title: 'Test', value: 42 });\n```\n\n## Breaking Down the Syntax\n\nUnderstanding Express middleware:\n\n1. **Middleware Signature**: `(req, res, next) => { ... }`\n   - `req`: Request object (incoming data)\n   - `res`: Response object (sending data back)\n   - `next`: Function to call the next middleware\n   - MUST call `next()` to continue the chain!\n\n2. **Registering Middleware**: `app.use(middlewareFunction)`\n   - Runs on EVERY request\n   - Order matters - middleware runs in the order you add it\n   - Place before routes\n\n3. **Middleware Flow**:\n   ```\n   Request → Middleware 1 → Middleware 2 → Middleware 3 → Route Handler → Response\n   ```\n   Each middleware calls `next()` to pass control\n\n4. **Common Built-in Middleware**:\n   ```javascript\n   // Parse JSON request bodies\n   app.use(express.json());\n   \n   // Parse URL-encoded forms\n   app.use(express.urlencoded({ extended: true }));\n   \n   // Serve static files (HTML, CSS, images)\n   app.use(express.static('public'));\n   ```\n\n5. **Stopping the Chain**:\n   ```javascript\n   app.use((req, res, next) => {\n     if (!isAuthorized(req)) {\n       res.status(401).json({ error: 'Unauthorized' });\n       // No next() - request stops here!\n       return;\n     }\n     next(); // Continue to next middleware\n   });\n   ```\n\n6. **Route-Specific Middleware**:\n   ```javascript\n   // Only runs for this route\n   app.get('/admin', authMiddleware, (req, res) => {\n     res.json({ message: 'Admin panel' });\n   });\n   ```\n\n7. **Error Handling Middleware** (4 parameters):\n   ```javascript\n   app.use((err, req, res, next) => {\n     console.error(err);\n     res.status(500).json({ error: 'Something went wrong' });\n   });\n   ```\n   Must have 4 parameters and go at the end!\n\n8. **Middleware Use Cases**:\n   - Authentication/Authorization\n   - Logging requests\n   - Parsing request bodies\n   - CORS handling\n   - Rate limiting\n   - Compression\n   - Session management\n\n## Common Mistakes & Tips\n\nCommon middleware mistakes:\n\n1. **Forgetting to call next()**:\n   ```javascript\n   app.use((req, res, next) => {\n     console.log('Request received');\n     // Missing next()! Request hangs forever!\n   });\n   ```\n   Solution: Always call `next()` unless you're ending the request\n\n2. **Calling next() after sending response**:\n   ```javascript\n   app.use((req, res, next) => {\n     res.json({ error: 'Error' });\n     next(); // WRONG! Response already sent\n   });\n   ```\n   Solution: Use `return` after sending response\n\n3. **Wrong middleware order**:\n   ```javascript\n   // Wrong!\n   app.get('/api/users', ...);  // Routes first\n   app.use(express.json());     // Body parser after routes!\n   \n   // Correct!\n   app.use(express.json());     // Middleware first\n   app.get('/api/users', ...);  // Routes after\n   ```\n   Middleware must come BEFORE routes that need it\n\n4. **Modifying req/res incorrectly**:\n   ```javascript\n   app.use((req, res, next) => {\n     req.user = getCurrentUser(); // Good - adding property\n     req = {}; // BAD - replacing entire object!\n     next();\n   });\n   ```\n   Add properties to req/res, don't replace them\n\n5. **Error handling middleware placement**:\n   ```javascript\n   // Must be LAST!\n   app.use((err, req, res, next) => {\n     res.status(500).json({ error: err.message });\n   });\n   ```\n   Error middleware (4 parameters) must be registered last\n\n6. **Async middleware without error handling**:\n   ```javascript\n   // Wrong - errors not caught\n   app.use(async (req, res, next) => {\n     await someAsyncOperation();\n     next();\n   });\n   \n   // Correct - wrap in try/catch\n   app.use(async (req, res, next) => {\n     try {\n       await someAsyncOperation();\n       next();\n     } catch (error) {\n       next(error); // Pass error to error handler\n     }\n   });\n   ```\n\n7. **Using middleware for everything**:\n   - Not every function needs to be middleware\n   - If it's specific to one route, make it a regular function\n   - Use middleware for cross-cutting concerns (logging, auth, etc.)"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a middleware system for a blog API:\n\n1. Create a logging middleware that logs the method and path\n2. Create a validation middleware that:\n   - For POST requests, checks if req.body has a 'title' property\n   - If missing, return 400 error and stop the chain\n   - If present, call next()\n3. Create a route POST `/api/posts` that:\n   - Returns the post data with a generated ID\n4. Register middleware in the correct order\n5. Test with valid and invalid requests\n\nUse the ExpressApp class provided.",
              "starterCode": "class ExpressApp {\n  constructor() { this.routes = []; this.middleware = []; }\n  use(handler) { this.middleware.push(handler); }\n  post(path, handler) { this.routes.push({ method: 'POST', path, handler }); }\n  simulateRequest(method, path, body) {\n    console.log(`\\n${method} ${path}`);\n    let req = { method, path, body };\n    let res = {\n      json: function(d) { console.log('Response:', JSON.stringify(d)); },\n      status: function(c) { this.statusCode = c; return this; }\n    };\n    let i = 0;\n    let next = () => {\n      if (i < this.middleware.length) {\n        this.middleware[i++](req, res, next);\n      } else {\n        let route = this.routes.find(r => r.method === method && r.path === path);\n        if (route) route.handler(req, res);\n      }\n    };\n    next();\n  }\n}\n\nlet app = new ExpressApp();\n\n// TODO: Add logging middleware\n\n// TODO: Add validation middleware\n\n// TODO: Add POST route\n\n// Test\napp.simulateRequest('POST', '/api/posts', { title: 'My Post', content: 'Hello' });\napp.simulateRequest('POST', '/api/posts', { content: 'No title!' });",
              "solution": "class ExpressApp {\n  constructor() { this.routes = []; this.middleware = []; }\n  use(handler) { this.middleware.push(handler); }\n  post(path, handler) { this.routes.push({ method: 'POST', path, handler }); }\n  simulateRequest(method, path, body) {\n    console.log(`\\n${method} ${path}`);\n    let req = { method, path, body };\n    let res = {\n      sent: false,\n      json: function(d) {\n        if (this.sent) return;\n        this.sent = true;\n        console.log(`Response [${this.statusCode || 200}]:`, JSON.stringify(d));\n      },\n      status: function(c) { this.statusCode = c; return this; }\n    };\n    let i = 0;\n    let next = () => {\n      if (i < this.middleware.length) {\n        this.middleware[i++](req, res, next);\n      } else {\n        let route = this.routes.find(r => r.method === method && r.path === path);\n        if (route) route.handler(req, res);\n      }\n    };\n    next();\n  }\n}\n\nlet app = new ExpressApp();\n\n// Middleware 1: Logging\napp.use((req, res, next) => {\n  console.log(`[LOG] ${req.method} ${req.path}`);\n  next();\n});\n\n// Middleware 2: Validation\napp.use((req, res, next) => {\n  if (req.method === 'POST') {\n    if (!req.body || !req.body.title) {\n      console.log('[VALIDATION] Missing title!');\n      res.status(400).json({ \n        error: 'Validation failed',\n        message: 'Title is required'\n      });\n      // Don't call next() - stop here!\n      return;\n    }\n    console.log('[VALIDATION] Title found:', req.body.title);\n  }\n  next();\n});\n\n// Route: Create post\napp.post('/api/posts', (req, res) => {\n  let post = {\n    id: Math.floor(Math.random() * 1000),\n    title: req.body.title,\n    content: req.body.content || '',\n    createdAt: new Date().toISOString()\n  };\n  \n  res.json({\n    message: 'Post created successfully',\n    post: post\n  });\n});\n\n// Test with valid request\napp.simulateRequest('POST', '/api/posts', { \n  title: 'My First Post', \n  content: 'Hello World!' \n});\n\n// Test with invalid request (missing title)\napp.simulateRequest('POST', '/api/posts', { \n  content: 'No title here!' \n});\n\n// Test with completely empty body\napp.simulateRequest('POST', '/api/posts', null);",
              "hints": [
                "In validation middleware, check if (!req.body.title) and return error without calling next(). Otherwise, call next()."
              ],
              "testCases": [
                {
                  "description": "Should validate title exists",
                  "input": "let body = { title: 'Test' }; body.title ? true : false",
                  "expectedOutput": "true"
                },
                {
                  "description": "Should detect missing title",
                  "input": "let body = { content: 'Test' }; body.title ? true : false",
                  "expectedOutput": "false"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-10-10-5",
          "title": "Building a RESTful API (The Library Catalog Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Building a RESTful API (The Library Catalog Analogy)\n\n## Understanding the Concept\n\nImagine managing a library catalog system:\n\nLibrary Operations (RESTful API):\n- GET /books - View all books (like browsing shelves)\n- GET /books/:id - View one specific book (like requesting a book by card number)\n- POST /books - Add a new book (like cataloging a new arrival)\n- PUT /books/:id - Update book info completely (like replacing a catalog card)\n- PATCH /books/:id - Update part of book info (like correcting a typo)\n- DELETE /books/:id - Remove a book (like removing from catalog)\n\nEach operation uses a specific method (GET, POST, etc.) and follows a pattern!\n\nREST = Representational State Transfer\n- A standard way to design APIs\n- Uses HTTP methods correctly\n- Predictable URL patterns\n- Stateless (each request is independent)\n\nFollowing REST makes your API intuitive and easy to use!\n\n## Code Example\n\n```javascript\n// Express 5.1 - RESTful API Example (2025)\n\n// Simulated Express app\nclass ExpressApp {\n  constructor() { this.routes = []; }\n  get(path, handler) { this.routes.push({ method: 'GET', path, handler }); }\n  post(path, handler) { this.routes.push({ method: 'POST', path, handler }); }\n  put(path, handler) { this.routes.push({ method: 'PUT', path, handler }); }\n  delete(path, handler) { this.routes.push({ method: 'DELETE', path, handler }); }\n  \n  simulateRequest(method, path, body = null) {\n    console.log(`\\n=== ${method} ${path} ===`);\n    if (body) console.log('Body:', JSON.stringify(body));\n    \n    let [urlPath, paramId] = this.parseUrl(path);\n    let route = this.routes.find(r => {\n      if (r.method !== method) return false;\n      let routePattern = r.path.replace(':id', '([^/]+)');\n      return new RegExp('^' + routePattern + '$').test(path);\n    });\n    \n    if (route) {\n      let id = path.match(/\\d+$/)?.[0];\n      let req = { method, path, params: { id }, body };\n      let res = {\n        status: function(code) { this.statusCode = code; return this; },\n        json: function(data) {\n          console.log(`Status: ${this.statusCode || 200}`);\n          console.log('Response:', JSON.stringify(data, null, 2));\n        }\n      };\n      route.handler(req, res);\n    } else {\n      console.log('Status: 404');\n      console.log('Response: Not Found');\n    }\n  }\n  \n  parseUrl(url) {\n    let parts = url.split('/');\n    let id = parts[parts.length - 1];\n    let path = parts.slice(0, -1).join('/');\n    return [path, id];\n  }\n}\n\nlet app = new ExpressApp();\n\n// IN-MEMORY DATABASE (simulated)\nlet books = [\n  { id: 1, title: '1984', author: 'George Orwell', year: 1949, available: true },\n  { id: 2, title: 'To Kill a Mockingbird', author: 'Harper Lee', year: 1960, available: true },\n  { id: 3, title: 'The Great Gatsby', author: 'F. Scott Fitzgerald', year: 1925, available: false }\n];\n\nlet nextId = 4;\n\n// RESTful API ROUTES\n\n// 1. GET /api/books - List all books\napp.get('/api/books', (req, res) => {\n  res.json({\n    count: books.length,\n    books: books\n  });\n});\n\n// 2. GET /api/books/:id - Get one book\napp.get('/api/books/:id', (req, res) => {\n  let id = parseInt(req.params.id);\n  let book = books.find(b => b.id === id);\n  \n  if (!book) {\n    return res.status(404).json({ \n      error: 'Book not found',\n      id: id \n    });\n  }\n  \n  res.json(book);\n});\n\n// 3. POST /api/books - Create new book\napp.post('/api/books', (req, res) => {\n  let newBook = {\n    id: nextId++,\n    title: req.body.title,\n    author: req.body.author,\n    year: req.body.year,\n    available: true\n  };\n  \n  // Validation\n  if (!newBook.title || !newBook.author) {\n    return res.status(400).json({\n      error: 'Validation failed',\n      message: 'Title and author are required'\n    });\n  }\n  \n  books.push(newBook);\n  \n  res.status(201).json({\n    message: 'Book created successfully',\n    book: newBook\n  });\n});\n\n// 4. PUT /api/books/:id - Update entire book (replace)\napp.put('/api/books/:id', (req, res) => {\n  let id = parseInt(req.params.id);\n  let index = books.findIndex(b => b.id === id);\n  \n  if (index === -1) {\n    return res.status(404).json({ error: 'Book not found' });\n  }\n  \n  // Replace entire book (keeping the ID)\n  books[index] = {\n    id: id,\n    title: req.body.title,\n    author: req.body.author,\n    year: req.body.year,\n    available: req.body.available\n  };\n  \n  res.json({\n    message: 'Book updated successfully',\n    book: books[index]\n  });\n});\n\n// 5. DELETE /api/books/:id - Delete a book\napp.delete('/api/books/:id', (req, res) => {\n  let id = parseInt(req.params.id);\n  let index = books.findIndex(b => b.id === id);\n  \n  if (index === -1) {\n    return res.status(404).json({ error: 'Book not found' });\n  }\n  \n  let deletedBook = books.splice(index, 1)[0];\n  \n  res.json({\n    message: 'Book deleted successfully',\n    book: deletedBook\n  });\n});\n\n// TEST THE API\n\nconsole.log('\\n🔥 RESTful API Demo - Book Library System\\n');\n\n// List all books\napp.simulateRequest('GET', '/api/books');\n\n// Get specific book\napp.simulateRequest('GET', '/api/books/1');\n\n// Get non-existent book\napp.simulateRequest('GET', '/api/books/999');\n\n// Create new book\napp.simulateRequest('POST', '/api/books', {\n  title: 'The Hobbit',\n  author: 'J.R.R. Tolkien',\n  year: 1937\n});\n\n// Update book\napp.simulateRequest('PUT', '/api/books/1', {\n  title: '1984',\n  author: 'George Orwell',\n  year: 1949,\n  available: false  // Changed to unavailable\n});\n\n// Delete book\napp.simulateRequest('DELETE', '/api/books/2');\n\n// List all books after changes\napp.simulateRequest('GET', '/api/books');\n```\n\n## Breaking Down the Syntax\n\nRESTful API design principles:\n\n1. **HTTP Methods Map to CRUD**:\n   - CREATE → POST\n   - READ → GET\n   - UPDATE → PUT (complete) or PATCH (partial)\n   - DELETE → DELETE\n\n2. **RESTful URL Patterns**:\n   ```\n   GET    /api/resources      → List all\n   GET    /api/resources/:id  → Get one\n   POST   /api/resources      → Create new\n   PUT    /api/resources/:id  → Update (replace)\n   PATCH  /api/resources/:id  → Update (partial)\n   DELETE /api/resources/:id  → Delete\n   ```\n\n3. **Status Codes**:\n   - 200 OK - Successful GET, PUT, PATCH\n   - 201 Created - Successful POST\n   - 204 No Content - Successful DELETE (no body)\n   - 400 Bad Request - Validation error\n   - 404 Not Found - Resource doesn't exist\n   - 500 Internal Server Error - Server problem\n\n4. **Response Format** (JSON is standard):\n   ```javascript\n   // Success\n   res.status(200).json({ data: [...] });\n   \n   // Error\n   res.status(404).json({ \n     error: 'Not found',\n     message: 'Resource does not exist'\n   });\n   ```\n\n5. **Naming Conventions**:\n   - Use plural nouns: `/books` not `/book`\n   - Use lowercase: `/api/users` not `/API/Users`\n   - Use hyphens for multi-word: `/api/book-reviews`\n   - Avoid verbs in URLs: `/api/books/1` not `/api/getBook/1`\n\n6. **Validation**:\n   ```javascript\n   if (!req.body.title) {\n     return res.status(400).json({ \n       error: 'Title is required' \n     });\n   }\n   ```\n   Always validate input before processing!\n\n7. **Idempotency**:\n   - GET, PUT, DELETE should be idempotent (same result if called multiple times)\n   - POST is NOT idempotent (creates new resource each time)\n\n8. **Versioning** (optional but recommended):\n   ```javascript\n   app.get('/api/v1/books', ...);\n   app.get('/api/v2/books', ...);\n   ```\n\n## Common Mistakes & Tips\n\nCommon RESTful API mistakes:\n\n1. **Using verbs in URLs**:\n   ```javascript\n   // Wrong!\n   app.get('/api/getUsers', ...);\n   app.post('/api/createUser', ...);\n   \n   // Correct!\n   app.get('/api/users', ...);\n   app.post('/api/users', ...);\n   ```\n   The HTTP method IS the verb!\n\n2. **Inconsistent responses**:\n   ```javascript\n   // Inconsistent\n   res.json(users);                    // Sometimes array\n   res.json({ data: users });          // Sometimes object\n   \n   // Consistent\n   res.json({ users: users });         // Always object with property\n   res.json({ count: 5, users: [] });  // Always same structure\n   ```\n\n3. **Wrong status codes**:\n   ```javascript\n   // Wrong - returning 200 for error\n   res.json({ error: 'Not found' });  // Still 200!\n   \n   // Correct\n   res.status(404).json({ error: 'Not found' });\n   ```\n\n4. **Not validating input**:\n   ```javascript\n   // Dangerous!\n   app.post('/api/users', (req, res) => {\n     let user = req.body;  // What if body is malformed?\n     users.push(user);\n   });\n   \n   // Safe\n   app.post('/api/users', (req, res) => {\n     if (!req.body.name || !req.body.email) {\n       return res.status(400).json({ error: 'Invalid input' });\n     }\n     // ...\n   });\n   ```\n\n5. **Forgetting to handle not found**:\n   ```javascript\n   app.get('/api/users/:id', (req, res) => {\n     let user = users.find(u => u.id === req.params.id);\n     res.json(user);  // What if user is undefined?\n   });\n   \n   // Better\n   app.get('/api/users/:id', (req, res) => {\n     let user = users.find(u => u.id === req.params.id);\n     if (!user) {\n       return res.status(404).json({ error: 'User not found' });\n     }\n     res.json(user);\n   });\n   ```\n\n6. **Nesting resources too deeply**:\n   ```javascript\n   // Too complex!\n   GET /api/users/123/posts/456/comments/789/replies/999\n   \n   // Better\n   GET /api/comments/789/replies\n   GET /api/replies/999\n   ```\n   Keep URLs simple and flat\n\n7. **Not using plural nouns**:\n   - Use `/api/users` not `/api/user`\n   - Use `/api/products` not `/api/product`\n   - Consistency matters!"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Build a RESTful API for managing tasks (todo items):\n\n1. Create an array to store tasks (each has: id, title, completed)\n2. Implement these endpoints:\n   - GET /api/tasks - Return all tasks\n   - GET /api/tasks/:id - Return one task (404 if not found)\n   - POST /api/tasks - Create new task (validate title exists)\n   - PUT /api/tasks/:id - Update task completely\n   - DELETE /api/tasks/:id - Delete task\n\n3. Use proper status codes:\n   - 200 for successful GET/PUT\n   - 201 for successful POST\n   - 404 for not found\n   - 400 for validation errors\n\n4. Test all endpoints\n\nUse the ExpressApp class provided.",
              "starterCode": "class ExpressApp {\n  constructor() { this.routes = []; }\n  get(p, h) { this.routes.push({ method: 'GET', path: p, handler: h }); }\n  post(p, h) { this.routes.push({ method: 'POST', path: p, handler: h }); }\n  put(p, h) { this.routes.push({ method: 'PUT', path: p, handler: h }); }\n  delete(p, h) { this.routes.push({ method: 'DELETE', path: p, handler: h }); }\n  simulateRequest(method, path, body = null) {\n    console.log(`\\n${method} ${path}`);\n    let id = path.match(/\\d+$/)?.[0];\n    let route = this.routes.find(r => {\n      if (r.method !== method) return false;\n      let pattern = r.path.replace(':id', '([^/]+)');\n      return new RegExp('^' + pattern + '$').test(path);\n    });\n    if (route) {\n      let req = { params: { id }, body };\n      let res = {\n        status: function(c) { this.statusCode = c; return this; },\n        json: function(d) { console.log(`[${this.statusCode || 200}]`, JSON.stringify(d)); }\n      };\n      route.handler(req, res);\n    }\n  }\n}\n\nlet app = new ExpressApp();\n\n// Task storage\nlet tasks = [\n  { id: 1, title: 'Learn REST', completed: false }\n];\nlet nextId = 2;\n\n// TODO: Implement your routes here\n\n// Test\napp.simulateRequest('GET', '/api/tasks');\napp.simulateRequest('POST', '/api/tasks', { title: 'Build API' });\napp.simulateRequest('GET', '/api/tasks/1');\napp.simulateRequest('DELETE', '/api/tasks/1');",
              "solution": "class ExpressApp {\n  constructor() { this.routes = []; }\n  get(p, h) { this.routes.push({ method: 'GET', path: p, handler: h }); }\n  post(p, h) { this.routes.push({ method: 'POST', path: p, handler: h }); }\n  put(p, h) { this.routes.push({ method: 'PUT', path: p, handler: h }); }\n  delete(p, h) { this.routes.push({ method: 'DELETE', path: p, handler: h }); }\n  simulateRequest(method, path, body = null) {\n    console.log(`\\n${method} ${path}`);\n    let id = path.match(/\\d+$/)?.[0];\n    let route = this.routes.find(r => {\n      if (r.method !== method) return false;\n      let pattern = r.path.replace(':id', '([^/]+)');\n      return new RegExp('^' + pattern + '$').test(path);\n    });\n    if (route) {\n      let req = { params: { id }, body };\n      let res = {\n        status: function(c) { this.statusCode = c; return this; },\n        json: function(d) { console.log(`[${this.statusCode || 200}]`, JSON.stringify(d, null, 2)); }\n      };\n      route.handler(req, res);\n    }\n  }\n}\n\nlet app = new ExpressApp();\n\n// Task storage\nlet tasks = [\n  { id: 1, title: 'Learn REST', completed: false },\n  { id: 2, title: 'Build API', completed: true }\n];\nlet nextId = 3;\n\n// GET /api/tasks - List all\napp.get('/api/tasks', (req, res) => {\n  res.json({ count: tasks.length, tasks });\n});\n\n// GET /api/tasks/:id - Get one\napp.get('/api/tasks/:id', (req, res) => {\n  let task = tasks.find(t => t.id === parseInt(req.params.id));\n  if (!task) {\n    return res.status(404).json({ error: 'Task not found' });\n  }\n  res.json(task);\n});\n\n// POST /api/tasks - Create\napp.post('/api/tasks', (req, res) => {\n  if (!req.body || !req.body.title) {\n    return res.status(400).json({ error: 'Title is required' });\n  }\n  \n  let newTask = {\n    id: nextId++,\n    title: req.body.title,\n    completed: false\n  };\n  tasks.push(newTask);\n  \n  res.status(201).json({ message: 'Task created', task: newTask });\n});\n\n// PUT /api/tasks/:id - Update\napp.put('/api/tasks/:id', (req, res) => {\n  let index = tasks.findIndex(t => t.id === parseInt(req.params.id));\n  if (index === -1) {\n    return res.status(404).json({ error: 'Task not found' });\n  }\n  \n  tasks[index] = {\n    id: parseInt(req.params.id),\n    title: req.body.title,\n    completed: req.body.completed\n  };\n  \n  res.json({ message: 'Task updated', task: tasks[index] });\n});\n\n// DELETE /api/tasks/:id - Delete\napp.delete('/api/tasks/:id', (req, res) => {\n  let index = tasks.findIndex(t => t.id === parseInt(req.params.id));\n  if (index === -1) {\n    return res.status(404).json({ error: 'Task not found' });\n  }\n  \n  let deleted = tasks.splice(index, 1)[0];\n  res.json({ message: 'Task deleted', task: deleted });\n});\n\n// Tests\nconsole.log('=== Task API Demo ===');\napp.simulateRequest('GET', '/api/tasks');\napp.simulateRequest('GET', '/api/tasks/1');\napp.simulateRequest('POST', '/api/tasks', { title: 'Deploy app' });\napp.simulateRequest('PUT', '/api/tasks/1', { title: 'Learn REST', completed: true });\napp.simulateRequest('DELETE', '/api/tasks/2');\napp.simulateRequest('GET', '/api/tasks');",
              "hints": [
                "Use tasks.find(t => t.id === parseInt(req.params.id)) to find tasks. Check for undefined and return 404."
              ],
              "testCases": [
                {
                  "description": "Should find task by id",
                  "input": "let tasks = [{ id: 1, title: 'Test' }]; tasks.find(t => t.id === 1).title",
                  "expectedOutput": "Test"
                },
                {
                  "description": "Should validate task has title",
                  "input": "let task = { title: 'Test' }; task.title ? true : false",
                  "expectedOutput": "true"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "module-11",
      "title": "Module 11: Storing Data - Databases & Prisma ORM",
      "description": "Learn how to persist data using databases, SQL basics, and Prisma ORM for type-safe database access",
      "difficulty": "advanced",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-11-11-1",
          "title": "What Are Databases? (The Filing Cabinet Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# What Are Databases? (The Filing Cabinet Analogy)\n\n## Understanding the Concept\n\nImagine storing customer information for a business:\n\nWithout a database (variables in memory):\n- Write customer data on sticky notes\n- Keep them on your desk\n- When you close the office (restart server), all notes are thrown away\n- No way to search through thousands of notes efficiently\n- Notes get lost, damaged, or mixed up\n\nWith a database (persistent storage):\n- Organized filing cabinet with labeled drawers\n- Customer files stay there even when office closes\n- Can quickly find any customer using the index\n- Multiple people can access files simultaneously\n- Backup copies exist for safety\n\nDatabases are like permanent, organized filing systems for your application's data. They persist information even when your server restarts!\n\n## Code Example\n\n```javascript\n// Understanding Databases - Concept Demo\n\n// PROBLEM: In-memory storage (data is temporary)\nlet users = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' }\n];\n\nconsole.log('Users in memory:', users.length); // 2\n\n// When server restarts... POOF! Data is gone!\n// users = [];  // Lost forever!\n\n// DATABASE CONCEPTS\n\n// 1. PERSISTENCE - Data survives server restarts\nconsole.log('Database benefit: Data persists across restarts');\n\n// 2. STRUCTURED DATA - Tables with columns\n/*\n  Users Table:\n  ┌────┬────────┬──────────────────────┐\n  │ id │ name   │ email                │\n  ├────┼────────┼──────────────────────┤\n  │ 1  │ Alice  │ alice@example.com    │\n  │ 2  │ Bob    │ bob@example.com      │\n  └────┴────────┴──────────────────────┘\n*/\n\n// 3. RELATIONSHIPS - Tables can connect to each other\n/*\n  Posts Table:\n  ┌────┬────────────────┬───────────┐\n  │ id │ title          │ userId    │\n  ├────┼────────────────┼───────────┤\n  │ 1  │ First Post     │ 1 (Alice) │\n  │ 2  │ Hello World    │ 2 (Bob)   │\n  └────┴────────────────┴───────────┘\n*/\n\nconsole.log('Database benefit: Relationships between data');\n\n// 4. QUERIES - Ask questions about your data\nlet sqlExamples = [\n  'SELECT * FROM users WHERE name = \"Alice\"',\n  'SELECT * FROM posts WHERE userId = 1',\n  'SELECT users.name, posts.title FROM users JOIN posts ON users.id = posts.userId'\n];\n\nconsole.log('SQL queries let you ask complex questions:');\nsqlExamples.forEach(sql => console.log('  -', sql));\n\n// 5. TRANSACTIONS - All-or-nothing operations\nconsole.log('Database benefit: Transactions ensure data integrity');\n/*\n  Example: Transferring money\n  - Subtract $100 from Account A\n  - Add $100 to Account B\n  \n  Either BOTH happen, or NEITHER happens!\n  No lost money!\n*/\n\n// TYPES OF DATABASES\n\nlet databaseTypes = {\n  'Relational (SQL)': {\n    examples: ['PostgreSQL', 'MySQL', 'SQLite'],\n    structure: 'Tables with rows and columns',\n    uses: 'Most applications, e-commerce, banking'\n  },\n  'NoSQL (Document)': {\n    examples: ['MongoDB', 'Firestore'],\n    structure: 'JSON-like documents',\n    uses: 'Flexible schemas, real-time apps'\n  },\n  'Key-Value': {\n    examples: ['Redis', 'DynamoDB'],\n    structure: 'Simple key-value pairs',\n    uses: 'Caching, sessions, real-time'\n  }\n};\n\nconsole.log('\\nTypes of databases:');\nfor (let [type, info] of Object.entries(databaseTypes)) {\n  console.log(`${type}: ${info.examples.join(', ')}`);\n}\n\n// WHY USE A DATABASE?\nlet benefits = [\n  'Persistence: Data survives restarts',\n  'Scalability: Handle millions of records',\n  'Concurrency: Multiple users at once',\n  'Query power: Complex data searches',\n  'Data integrity: Constraints and validation',\n  'Security: Access control and encryption',\n  'Backup: Restore data if something breaks'\n];\n\nconsole.log('\\nDatabase benefits:');\nbenefits.forEach(b => console.log(`  ✓ ${b}`));\n```\n\n## Breaking Down the Syntax\n\nDatabase fundamentals:\n\n1. **Database Types**:\n   - **SQL (Relational)**: Structured tables, relationships, strict schema\n     * PostgreSQL (powerful, feature-rich)\n     * MySQL (popular, web apps)\n     * SQLite (simple, file-based)\n   \n   - **NoSQL**: Flexible structure, JSON-like\n     * MongoDB (document-based)\n     * Redis (key-value, caching)\n\n2. **Key Database Concepts**:\n   - **Table**: Collection of similar data (like a spreadsheet)\n   - **Row**: Individual record (one user, one post)\n   - **Column**: Property/field (name, email, age)\n   - **Primary Key**: Unique identifier (usually `id`)\n   - **Foreign Key**: Reference to another table (userId references users table)\n\n3. **SQL Basics** (Structured Query Language):\n   ```sql\n   -- Create table\n   CREATE TABLE users (\n     id INTEGER PRIMARY KEY,\n     name TEXT NOT NULL,\n     email TEXT UNIQUE\n   );\n   \n   -- Insert data\n   INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');\n   \n   -- Read data\n   SELECT * FROM users WHERE name = 'Alice';\n   \n   -- Update data\n   UPDATE users SET email = 'newemail@example.com' WHERE id = 1;\n   \n   -- Delete data\n   DELETE FROM users WHERE id = 1;\n   ```\n\n4. **CRUD Operations**:\n   - **C**reate: INSERT\n   - **R**ead: SELECT\n   - **U**pdate: UPDATE\n   - **D**elete: DELETE\n\n5. **Relationships**:\n   - **One-to-Many**: One user has many posts\n   - **Many-to-Many**: Users can follow many users, users have many followers\n   - **One-to-One**: User has one profile\n\n6. **Choosing a Database**:\n   - **PostgreSQL**: Production apps, complex queries, reliability\n   - **SQLite**: Development, simple apps, mobile apps\n   - **MongoDB**: Flexible schemas, rapid prototyping\n   - **Redis**: Caching, sessions, real-time features\n\n## Common Mistakes & Tips\n\nCommon database misconceptions:\n\n1. **\"Databases are too complex for beginners\"**:\n   - Start simple with SQLite or Prisma\n   - You don't need to be a DBA to use databases\n   - ORMs (like Prisma) make it much easier\n\n2. **\"I can just use variables/files instead\"**:\n   ```javascript\n   // This seems easier but...\n   let users = [];  // Lost on restart!\n   \n   // Or\n   fs.writeFileSync('users.json', JSON.stringify(users));\n   // File corruption? Race conditions? Concurrent access?\n   ```\n   Databases solve these problems professionally\n\n3. **\"All databases are the same\"**:\n   - SQL databases: Structured, relations, ACID guarantees\n   - NoSQL databases: Flexible, scalable, eventual consistency\n   - Choose based on your needs!\n\n4. **\"I need to learn raw SQL first\"**:\n   - Modern ORMs (Prisma, TypeORM) abstract SQL\n   - You can learn SQL gradually\n   - Start with ORM, understand SQL over time\n\n5. **\"Databases are slow\"**:\n   - Modern databases are EXTREMELY fast\n   - Proper indexes make queries lightning quick\n   - Can handle millions of queries per second\n\n6. **\"I don't need relationships\"**:\n   - Even simple apps benefit from relationships\n   - User → Posts → Comments (natural hierarchy)\n   - Avoids data duplication\n\n7. **\"Development database vs Production database\"**:\n   - Use SQLite for development (simple, file-based)\n   - Use PostgreSQL for production (robust, scalable)\n   - Prisma makes switching databases easy!"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Simulate a simple database system:\n\n1. Create an array called `database` to store user objects\n2. Create a function `insertUser(name, email)` that:\n   - Generates a unique ID\n   - Adds user to database\n   - Returns the new user\n3. Create a function `findUserByEmail(email)` that:\n   - Searches the database\n   - Returns the user or null\n4. Create a function `updateUserEmail(id, newEmail)` that:\n   - Finds user by ID\n   - Updates their email\n   - Returns true/false for success\n\nTest all functions.",
              "starterCode": "// Simulated database (array of objects)\nlet database = [];\nlet nextId = 1;\n\n// Function to insert a user\nfunction insertUser(name, email) {\n  let user = {\n    id: nextId++,\n    name: name,\n    email: email\n  };\n  database.push(user);\n  return user;\n}\n\n// Function to find user by email\nfunction findUserByEmail(email) {\n  return database.find(user => user.email === email) || null;\n}\n\n// Function to update user email\nfunction updateUserEmail(id, newEmail) {\n  let user = database.find(u => u.id === id);\n  if (user) {\n    user.email = newEmail;\n    return true;\n  }\n  return false;\n}\n\n// Test the functions\nlet user1 = insertUser('Alice', 'alice@example.com');\nconsole.log('Inserted:', user1);\n\nlet found = findUserByEmail('alice@example.com');\nconsole.log('Found:', found);\n\nlet updated = updateUserEmail(1, 'alice.new@example.com');\nconsole.log('Updated:', updated);\nconsole.log('Database:', database);",
              "solution": "// Complete database simulation\nlet database = [];\nlet nextId = 1;\n\n// Insert user\nfunction insertUser(name, email) {\n  let user = {\n    id: nextId++,\n    name: name,\n    email: email,\n    createdAt: new Date().toISOString()\n  };\n  database.push(user);\n  console.log(`✓ Inserted user ID ${user.id}`);\n  return user;\n}\n\n// Find user by email\nfunction findUserByEmail(email) {\n  let user = database.find(u => u.email === email);\n  return user || null;\n}\n\n// Update user email\nfunction updateUserEmail(id, newEmail) {\n  let user = database.find(u => u.id === id);\n  if (user) {\n    let oldEmail = user.email;\n    user.email = newEmail;\n    console.log(`✓ Updated user ${id}: ${oldEmail} → ${newEmail}`);\n    return true;\n  }\n  console.log(`✗ User ${id} not found`);\n  return false;\n}\n\n// Delete user\nfunction deleteUser(id) {\n  let index = database.findIndex(u => u.id === id);\n  if (index !== -1) {\n    let deleted = database.splice(index, 1)[0];\n    console.log(`✓ Deleted user ${id}`);\n    return deleted;\n  }\n  return null;\n}\n\n// List all users\nfunction getAllUsers() {\n  return database;\n}\n\n// Test the database\nconsole.log('=== Database Simulation ===\\n');\n\nlet alice = insertUser('Alice', 'alice@example.com');\nlet bob = insertUser('Bob', 'bob@example.com');\nlet charlie = insertUser('Charlie', 'charlie@example.com');\n\nconsole.log('\\nAll users:', getAllUsers().length);\n\nlet found = findUserByEmail('bob@example.com');\nconsole.log('\\nFound Bob:', found ? found.name : 'Not found');\n\nupdateUserEmail(1, 'alice.new@example.com');\n\ndeleteUser(2);\n\nconsole.log('\\nFinal database:', database);",
              "hints": [
                "Use array methods: push() to add, find() to search, and direct property assignment to update."
              ],
              "testCases": [
                {
                  "description": "Should insert user with ID",
                  "input": "let db = []; let u = { id: 1, name: 'Test', email: 'test@example.com' }; db.push(u); db[0].id",
                  "expectedOutput": "1"
                },
                {
                  "description": "Should find user by email",
                  "input": "let db = [{ id: 1, name: 'Alice', email: 'alice@example.com' }]; db.find(u => u.email === 'alice@example.com').name",
                  "expectedOutput": "Alice"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-11-11-2",
          "title": "Introduction to Prisma ORM (The Translator Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Introduction to Prisma ORM (The Translator Analogy)\n\n## Understanding the Concept\n\nImagine you're traveling in a foreign country:\n\nWithout a translator (raw SQL):\n- You need to learn the local language fluently\n- Every conversation requires you to form sentences carefully\n- Easy to make grammar mistakes\n- Different regions have different dialects (MySQL vs PostgreSQL)\n- Stressful and error-prone\n\nWith a translator (Prisma ORM):\n- You speak in your native language (TypeScript/JavaScript)\n- Translator converts to local language (SQL)\n- Translator knows all the dialects\n- Type-safe: Translator stops you from saying nonsense\n- Confident communication!\n\nPrisma ORM (Object-Relational Mapping) is a translator between your JavaScript code and your database. You write TypeScript, Prisma generates the SQL!\n\n## Code Example\n\n```javascript\n// Prisma ORM Demonstration (Conceptual)\n// In real projects, Prisma generates TypeScript types automatically!\n\n// TRADITIONAL WAY: Raw SQL (error-prone)\nlet rawSQL = `\n  SELECT users.name, posts.title \n  FROM users \n  JOIN posts ON users.id = posts.userId \n  WHERE users.email = 'alice@example.com'\n`;\n\nconsole.log('Raw SQL (requires SQL knowledge):', rawSQL);\nconsole.log('Problems: SQL injection, typos, no type safety\\n');\n\n// PRISMA WAY: Type-safe JavaScript/TypeScript\n// (Simulated - real Prisma connects to actual database)\n\nclass PrismaClient {\n  constructor() {\n    this.user = {\n      create: async (data) => {\n        console.log('[Prisma] Creating user:', data.data);\n        return { id: 1, ...data.data, createdAt: new Date() };\n      },\n      findUnique: async (query) => {\n        console.log('[Prisma] Finding user where:', query.where);\n        return {\n          id: 1,\n          name: 'Alice',\n          email: 'alice@example.com',\n          posts: [\n            { id: 1, title: 'First Post', content: 'Hello!' }\n          ]\n        };\n      },\n      findMany: async (query) => {\n        console.log('[Prisma] Finding many users');\n        return [\n          { id: 1, name: 'Alice', email: 'alice@example.com' },\n          { id: 2, name: 'Bob', email: 'bob@example.com' }\n        ];\n      },\n      update: async (query) => {\n        console.log('[Prisma] Updating user:', query.where, 'with:', query.data);\n        return { id: 1, ...query.data };\n      },\n      delete: async (query) => {\n        console.log('[Prisma] Deleting user:', query.where);\n        return { id: 1, name: 'Alice' };\n      }\n    };\n    \n    this.post = {\n      create: async (data) => {\n        console.log('[Prisma] Creating post:', data.data);\n        return { id: 1, ...data.data };\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// PRISMA EXAMPLES (async/await pattern)\n\n// 1. CREATE a user\nasync function createUser() {\n  let user = await prisma.user.create({\n    data: {\n      name: 'Alice',\n      email: 'alice@example.com'\n    }\n  });\n  console.log('Created user:', user);\n  return user;\n}\n\n// 2. FIND a user by email\nasync function findUser() {\n  let user = await prisma.user.findUnique({\n    where: {\n      email: 'alice@example.com'\n    },\n    include: {\n      posts: true  // Include related posts!\n    }\n  });\n  console.log('Found user with posts:', user);\n  return user;\n}\n\n// 3. UPDATE a user\nasync function updateUser() {\n  let user = await prisma.user.update({\n    where: { id: 1 },\n    data: {\n      name: 'Alice Smith'\n    }\n  });\n  console.log('Updated user:', user);\n  return user;\n}\n\n// 4. DELETE a user\nasync function deleteUser() {\n  let user = await prisma.user.delete({\n    where: { id: 1 }\n  });\n  console.log('Deleted user:', user);\n  return user;\n}\n\n// 5. LIST all users\nasync function listUsers() {\n  let users = await prisma.user.findMany();\n  console.log('All users:', users);\n  return users;\n}\n\n// Run examples\nconsole.log('=== Prisma ORM Examples ===\\n');\n\ncreateUser();\nsetTimeout(() => findUser(), 100);\nsetTimeout(() => updateUser(), 200);\nsetTimeout(() => listUsers(), 300);\n\n// PRISMA BENEFITS\nconsole.log('\\n=== Prisma Benefits ===');\nlet benefits = [\n  '✓ Type-safe database queries (TypeScript)',\n  '✓ Auto-generated types from schema',\n  '✓ Database agnostic (PostgreSQL, MySQL, SQLite, etc.)',\n  '✓ Intuitive API (JavaScript objects, not SQL strings)',\n  '✓ Migrations built-in',\n  '✓ Prisma Studio (database GUI)',\n  '✓ Query builder prevents SQL injection',\n  '✓ Excellent autocomplete in IDE'\n];\n\nbenefits.forEach(b => console.log(b));\n```\n\n## Breaking Down the Syntax\n\nUnderstanding Prisma ORM:\n\n1. **What is Prisma?**\n   - Modern ORM (Object-Relational Mapping)\n   - Translates TypeScript ↔ SQL\n   - Type-safe database client\n   - Works with PostgreSQL, MySQL, SQLite, MongoDB, etc.\n\n2. **Prisma Setup** (typical workflow):\n   ```bash\n   # Install Prisma\n   npm install prisma --save-dev\n   npm install @prisma/client\n   \n   # Initialize Prisma\n   npx prisma init\n   \n   # This creates:\n   # - prisma/schema.prisma (database schema)\n   # - .env (database connection string)\n   ```\n\n3. **Prisma Schema** (schema.prisma):\n   ```prisma\n   model User {\n     id        Int      @id @default(autoincrement())\n     email     String   @unique\n     name      String\n     posts     Post[]\n     createdAt DateTime @default(now())\n   }\n   \n   model Post {\n     id        Int      @id @default(autoincrement())\n     title     String\n     content   String?\n     published Boolean  @default(false)\n     userId    Int\n     user      User     @relation(fields: [userId], references: [id])\n   }\n   ```\n\n4. **Prisma Client Usage**:\n   ```typescript\n   import { PrismaClient } from '@prisma/client';\n   const prisma = new PrismaClient();\n   \n   // All your database operations...\n   ```\n\n5. **CRUD Operations**:\n   - **Create**: `prisma.user.create({ data: {...} })`\n   - **Read**: `prisma.user.findUnique({ where: {...} })`\n   - **Update**: `prisma.user.update({ where: {...}, data: {...} })`\n   - **Delete**: `prisma.user.delete({ where: {...} })`\n\n6. **Relationships**:\n   ```typescript\n   // Get user with all their posts\n   const userWithPosts = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: { posts: true }\n   });\n   ```\n\n7. **Migrations** (database schema changes):\n   ```bash\n   # Create migration\n   npx prisma migrate dev --name add_users_table\n   \n   # Apply migrations to production\n   npx prisma migrate deploy\n   ```\n\n8. **Prisma Studio** (database GUI):\n   ```bash\n   npx prisma studio\n   # Opens visual database editor in browser\n   ```\n\n## Common Mistakes & Tips\n\nCommon Prisma mistakes:\n\n1. **Forgetting async/await**:\n   ```typescript\n   // Wrong!\n   let user = prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.name); // ERROR: user is a Promise!\n   \n   // Correct!\n   let user = await prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.name); // Works!\n   ```\n\n2. **Not running migrations**:\n   - After changing schema.prisma, run: `npx prisma migrate dev`\n   - Then: `npx prisma generate` to update TypeScript types\n   - Without this, your code won't match the database!\n\n3. **Prisma Client not initialized**:\n   ```typescript\n   // Create once, reuse everywhere\n   // prisma/client.ts\n   import { PrismaClient } from '@prisma/client';\n   export const prisma = new PrismaClient();\n   \n   // other files\n   import { prisma } from './prisma/client';\n   ```\n\n4. **Not handling null results**:\n   ```typescript\n   let user = await prisma.user.findUnique({ where: { id: 999 } });\n   console.log(user.name); // ERROR if user is null!\n   \n   // Better:\n   if (!user) {\n     throw new Error('User not found');\n   }\n   console.log(user.name);\n   ```\n\n5. **Forgetting to connect/disconnect**:\n   ```typescript\n   // Usually not needed in serverless\n   // But for long-running servers:\n   await prisma.$connect();\n   // ... use prisma ...\n   await prisma.$disconnect();\n   ```\n\n6. **Schema syntax errors**:\n   ```prisma\n   // Wrong!\n   model User {\n     id Int @id\n     name String\n     // Missing newline before }\n   }\n   \n   // Correct!\n   model User {\n     id   Int    @id @default(autoincrement())\n     name String\n   }\n   ```\n\n7. **Not using Prisma Studio**:\n   - Run `npx prisma studio` to see your data visually\n   - Great for debugging and understanding your database\n   - Much easier than writing SELECT queries!"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Simulate Prisma-style database operations:\n\n1. Create a mock Prisma client class with a `book` property\n2. Implement these methods on the `book` object:\n   - `create(data)` - Returns new book with generated ID\n   - `findMany()` - Returns all books array\n   - `findUnique(where)` - Finds book by ID\n   - `update(where, data)` - Updates book and returns it\n\n3. Create a books array to store data\n4. Test all CRUD operations\n\nMake it feel like Prisma's API!",
              "starterCode": "// Mock Prisma client\nclass PrismaClient {\n  constructor() {\n    this.booksData = [];\n    this.nextId = 1;\n    \n    this.book = {\n      create: async (options) => {\n        let book = {\n          id: this.nextId++,\n          ...options.data\n        };\n        this.booksData.push(book);\n        return book;\n      },\n      \n      findMany: async () => {\n        return this.booksData;\n      },\n      \n      findUnique: async (options) => {\n        return this.booksData.find(b => b.id === options.where.id) || null;\n      },\n      \n      update: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        if (book) {\n          Object.assign(book, options.data);\n          return book;\n        }\n        return null;\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// Test CRUD operations\nasync function testPrisma() {\n  // Create\n  let book1 = await prisma.book.create({\n    data: { title: '1984', author: 'George Orwell', pages: 328 }\n  });\n  console.log('Created:', book1);\n  \n  // Find all\n  let books = await prisma.book.findMany();\n  console.log('All books:', books);\n  \n  // Find one\n  let found = await prisma.book.findUnique({ where: { id: 1 } });\n  console.log('Found:', found);\n  \n  // Update\n  let updated = await prisma.book.update({\n    where: { id: 1 },\n    data: { pages: 330 }\n  });\n  console.log('Updated:', updated);\n}\n\ntestPrisma();",
              "solution": "// Complete Prisma-style mock client\nclass PrismaClient {\n  constructor() {\n    this.booksData = [];\n    this.nextId = 1;\n    \n    this.book = {\n      create: async (options) => {\n        let book = {\n          id: this.nextId++,\n          ...options.data,\n          createdAt: new Date()\n        };\n        this.booksData.push(book);\n        console.log(`✓ Created book ID ${book.id}`);\n        return book;\n      },\n      \n      findMany: async (options = {}) => {\n        let books = this.booksData;\n        \n        // Filter if where clause provided\n        if (options.where) {\n          books = books.filter(book => {\n            return Object.entries(options.where).every(([key, value]) => {\n              return book[key] === value;\n            });\n          });\n        }\n        \n        return books;\n      },\n      \n      findUnique: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        return book || null;\n      },\n      \n      update: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        if (book) {\n          Object.assign(book, options.data);\n          book.updatedAt = new Date();\n          console.log(`✓ Updated book ID ${book.id}`);\n          return book;\n        }\n        throw new Error(`Book with ID ${options.where.id} not found`);\n      },\n      \n      delete: async (options) => {\n        let index = this.booksData.findIndex(b => b.id === options.where.id);\n        if (index !== -1) {\n          let deleted = this.booksData.splice(index, 1)[0];\n          console.log(`✓ Deleted book ID ${deleted.id}`);\n          return deleted;\n        }\n        throw new Error(`Book with ID ${options.where.id} not found`);\n      },\n      \n      count: async () => {\n        return this.booksData.length;\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// Comprehensive test\nasync function testPrisma() {\n  console.log('=== Prisma-Style ORM Demo ===\\n');\n  \n  // Create books\n  await prisma.book.create({\n    data: { title: '1984', author: 'George Orwell', pages: 328 }\n  });\n  \n  await prisma.book.create({\n    data: { title: 'The Great Gatsby', author: 'F. Scott Fitzgerald', pages: 180 }\n  });\n  \n  // Find all\n  let allBooks = await prisma.book.findMany();\n  console.log('\\nAll books:', allBooks.length);\n  \n  // Find specific\n  let book = await prisma.book.findUnique({ where: { id: 1 } });\n  console.log('\\nFound book:', book.title);\n  \n  // Update\n  await prisma.book.update({\n    where: { id: 1 },\n    data: { pages: 330 }\n  });\n  \n  // Count\n  let count = await prisma.book.count();\n  console.log('\\nTotal books:', count);\n  \n  // Delete\n  await prisma.book.delete({ where: { id: 2 } });\n  \n  // Final state\n  let remaining = await prisma.book.findMany();\n  console.log('\\nRemaining books:', remaining);\n}\n\ntestPrisma();",
              "hints": [
                "Use async functions and make methods return promises. Store books in an array."
              ],
              "testCases": [
                {
                  "description": "Should create book with generated ID",
                  "input": "let books = []; let book = { id: 1, title: 'Test' }; books.push(book); books[0].id",
                  "expectedOutput": "1"
                },
                {
                  "description": "Should find book by id",
                  "input": "let books = [{ id: 1, title: 'Test' }]; books.find(b => b.id === 1).title",
                  "expectedOutput": "Test"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-11-11-3",
          "title": "Writing the Prisma Schema (The Blueprint Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Writing the Prisma Schema (The Blueprint Analogy)\n\n## Understanding the Concept\n\nImagine you're an architect designing a house:\n\nWithout a blueprint:\n- Builders have no clear plan\n- Everyone interprets requirements differently\n- Walls might not line up\n- No standard for room sizes\n- Chaos!\n\nWith a blueprint (Prisma schema):\n- Clear specification for every room\n- Exact measurements and connections\n- Everyone follows the same plan\n- Changes update the whole design\n- Professional and organized!\n\nThe Prisma schema file (schema.prisma) is your database blueprint. It defines your data models, their fields, types, and relationships. Prisma reads this file and:\n1. Creates the database tables for you\n2. Generates TypeScript types automatically\n3. Ensures your code and database always match!\n\nNo more writing SQL CREATE TABLE statements by hand!\n\n## Code Example\n\n```javascript\n// Understanding Prisma Schema (schema.prisma file)\n// This is NOT JavaScript - it's Prisma's special language!\n\n// CONCEPTUAL DEMO - showing schema structure in JavaScript comments\n\n/*\nPrisma Schema Structure:\n\n// 1. DATABASE CONNECTION\ndatasource db {\n  provider = \"postgresql\"  // or \"mysql\", \"sqlite\", \"mongodb\"\n  url      = env(\"DATABASE_URL\")  // Connection string from .env\n}\n\n// 2. PRISMA CLIENT GENERATOR\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\n// 3. DATA MODELS (Tables)\n\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  name      String\n  password  String\n  role      String   @default(\"user\")\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  \n  posts     Post[]   // Relationship: User has many Posts\n  profile   Profile? // Relationship: User has one optional Profile\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  viewCount Int      @default(0)\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  \n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n  \n  categories Category[]\n}\n\nmodel Profile {\n  id       Int    @id @default(autoincrement())\n  bio      String?\n  avatar   String?\n  \n  userId   Int    @unique\n  user     User   @relation(fields: [userId], references: [id])\n}\n\nmodel Category {\n  id    Int    @id @default(autoincrement())\n  name  String @unique\n  \n  posts Post[]\n}\n*/\n\n// SCHEMA CONCEPTS EXPLAINED\n\nlet schemaExplanation = {\n  'Field Types': {\n    'String': 'Text data (\"hello\", \"user@example.com\")',\n    'Int': 'Whole numbers (1, 42, 1000)',\n    'Float': 'Decimal numbers (3.14, 99.99)',\n    'Boolean': 'true or false',\n    'DateTime': 'Dates and times',\n    'Json': 'JSON objects (flexible data)'\n  },\n  \n  'Attributes': {\n    '@id': 'Primary key (unique identifier)',\n    '@unique': 'Value must be unique across all records',\n    '@default(value)': 'Default value if not provided',\n    '@updatedAt': 'Auto-updates to current time on changes',\n    '@relation': 'Defines relationships between models'\n  },\n  \n  'Type Modifiers': {\n    'field String': 'Required field (cannot be null)',\n    'field String?': 'Optional field (can be null)',\n    'field String[]': 'Array of strings'\n  },\n  \n  'Default Functions': {\n    'autoincrement()': 'Auto-increment integers (1, 2, 3...)',\n    'now()': 'Current timestamp',\n    'uuid()': 'Generate random UUID',\n    'cuid()': 'Generate random CUID (shorter than UUID)'\n  }\n};\n\nconsole.log('=== Prisma Schema Concepts ===\\n');\n\nfor (let [category, details] of Object.entries(schemaExplanation)) {\n  console.log(category + ':');\n  for (let [key, desc] of Object.entries(details)) {\n    console.log(`  ${key}: ${desc}`);\n  }\n  console.log('');\n}\n\n// EXAMPLE: What this schema creates\n\nlet exampleData = {\n  users: [\n    {\n      id: 1,\n      email: 'alice@example.com',\n      name: 'Alice',\n      password: 'hashed_password',\n      role: 'user',\n      createdAt: new Date('2025-01-01'),\n      updatedAt: new Date('2025-01-15')\n    }\n  ],\n  posts: [\n    {\n      id: 1,\n      title: 'My First Post',\n      content: 'Hello world!',\n      published: true,\n      viewCount: 42,\n      authorId: 1,  // References user with id 1\n      createdAt: new Date('2025-01-10')\n    }\n  ],\n  profiles: [\n    {\n      id: 1,\n      bio: 'Software developer',\n      avatar: 'https://example.com/avatar.jpg',\n      userId: 1  // References user with id 1\n    }\n  ]\n};\n\nconsole.log('Example database structure:');\nconsole.log(JSON.stringify(exampleData, null, 2));\n\n// WORKFLOW\nconsole.log('\\n=== Prisma Schema Workflow ===');\n\nlet workflow = [\n  '1. Write schema.prisma file (define your models)',\n  '2. Run: npx prisma migrate dev --name init',\n  '   → Creates database tables',\n  '   → Creates migration files',\n  '3. Run: npx prisma generate',\n  '   → Generates TypeScript types',\n  '   → Updates Prisma Client',\n  '4. Use in your code with full type safety!'\n];\n\nworkflow.forEach(step => console.log(step));\n```\n\n## Breaking Down the Syntax\n\nPrisma Schema Syntax Guide:\n\n1. **File Structure** (schema.prisma):\n   ```prisma\n   // Database connection\n   datasource db {\n     provider = \"postgresql\"\n     url      = env(\"DATABASE_URL\")\n   }\n   \n   // TypeScript client generator\n   generator client {\n     provider = \"prisma-client-js\"\n   }\n   \n   // Your data models\n   model ModelName {\n     // fields here\n   }\n   ```\n\n2. **Field Syntax**:\n   ```prisma\n   model User {\n     fieldName  FieldType  @attribute\n   }\n   ```\n\n3. **Common Field Types**:\n   - `String` - Text (VARCHAR)\n   - `Int` - Integer\n   - `Float` - Decimal number\n   - `Boolean` - true/false\n   - `DateTime` - Timestamp\n   - `Json` - JSON object\n   - `Bytes` - Binary data\n\n4. **Field Attributes**:\n   ```prisma\n   id        Int      @id @default(autoincrement())\n   email     String   @unique\n   name      String   @default(\"Anonymous\")\n   createdAt DateTime @default(now())\n   updatedAt DateTime @updatedAt\n   bio       String?  // ? makes it optional\n   tags      String[] // [] makes it an array\n   ```\n\n5. **Primary Key Options**:\n   ```prisma\n   // Auto-incrementing integer\n   id Int @id @default(autoincrement())\n   \n   // UUID (random unique string)\n   id String @id @default(uuid())\n   \n   // CUID (shorter unique string)\n   id String @id @default(cuid())\n   ```\n\n6. **Unique Constraints**:\n   ```prisma\n   email String @unique  // Single unique field\n   \n   // Compound unique (combination must be unique)\n   @@unique([email, username])\n   ```\n\n7. **Indexes for Performance**:\n   ```prisma\n   email String @unique  // Automatically indexed\n   \n   // Manual index\n   @@index([email])\n   \n   // Compound index\n   @@index([lastName, firstName])\n   ```\n\n8. **Database Providers**:\n   ```prisma\n   provider = \"postgresql\"  // Recommended for production\n   provider = \"mysql\"\n   provider = \"sqlite\"      // Good for development\n   provider = \"sqlserver\"\n   provider = \"mongodb\"\n   provider = \"cockroachdb\"\n   ```\n\n9. **Environment Variables**:\n   ```prisma\n   url = env(\"DATABASE_URL\")\n   ```\n   \n   In your .env file:\n   ```\n   DATABASE_URL=\"postgresql://user:password@localhost:5432/mydb\"\n   ```\n\n10. **Complete Example**:\n    ```prisma\n    datasource db {\n      provider = \"postgresql\"\n      url      = env(\"DATABASE_URL\")\n    }\n    \n    generator client {\n      provider = \"prisma-client-js\"\n    }\n    \n    model User {\n      id        Int      @id @default(autoincrement())\n      email     String   @unique\n      name      String\n      age       Int?\n      isActive  Boolean  @default(true)\n      createdAt DateTime @default(now())\n      updatedAt DateTime @updatedAt\n    }\n    ```\n\n## Common Mistakes & Tips\n\nCommon Prisma schema mistakes:\n\n1. **Forgetting semicolons or using wrong syntax**:\n   ```prisma\n   // Wrong! Prisma doesn't use semicolons\n   model User {\n     id Int @id;\n   }\n   \n   // Correct!\n   model User {\n     id Int @id\n   }\n   ```\n\n2. **Wrong field type capitalization**:\n   ```prisma\n   // Wrong!\n   name string  // lowercase\n   \n   // Correct!\n   name String  // Pascal case\n   ```\n\n3. **Forgetting @id attribute**:\n   ```prisma\n   // Wrong! Every model needs an @id\n   model User {\n     email String @unique\n     name  String\n   }\n   \n   // Correct!\n   model User {\n     id    Int    @id @default(autoincrement())\n     email String @unique\n     name  String\n   }\n   ```\n\n4. **Using JavaScript syntax in schema**:\n   ```prisma\n   // Wrong! This is not JavaScript\n   model User {\n     isActive: Boolean = true\n   }\n   \n   // Correct! This is Prisma schema language\n   model User {\n     isActive Boolean @default(true)\n   }\n   ```\n\n5. **Wrong default value syntax**:\n   ```prisma\n   // Wrong!\n   createdAt DateTime default(now())\n   \n   // Correct!\n   createdAt DateTime @default(now())\n   ```\n\n6. **Not running migrate after schema changes**:\n   - Changed schema.prisma?\n   - Run: `npx prisma migrate dev`\n   - Otherwise database won't match your schema!\n\n7. **Incorrect optional syntax**:\n   ```prisma\n   // Wrong!\n   bio String | null\n   \n   // Correct!\n   bio String?  // Question mark makes it optional\n   ```\n\n8. **Forgetting environment variables**:\n   - Schema uses: `url = env(\"DATABASE_URL\")`\n   - Must create .env file:\n   ```\n   DATABASE_URL=\"postgresql://user:pass@localhost:5432/db\"\n   ```\n\n9. **Using relations without foreign keys**:\n   ```prisma\n   // Incomplete! Missing authorId field\n   model Post {\n     id     Int  @id @default(autoincrement())\n     author User @relation(fields: [authorId], references: [id])\n   }\n   \n   // Correct!\n   model Post {\n     id       Int  @id @default(autoincrement())\n     authorId Int  // Foreign key field\n     author   User @relation(fields: [authorId], references: [id])\n   }\n   ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Simulate a Prisma schema structure in JavaScript:\n\n1. Create an object called `schema` with a `models` property\n2. Add a 'Product' model with these fields:\n   - id (integer, auto-increment)\n   - name (string, required)\n   - price (number, required)\n   - inStock (boolean, default true)\n   - description (string, optional)\n   - createdAt (date, default now)\n\n3. Create a function `generateModelSQL(model)` that simulates generating SQL\n4. Display the schema structure\n\nYou're simulating what Prisma does internally!",
              "starterCode": "// Simulated Prisma schema structure\nlet schema = {\n  models: {\n    Product: {\n      fields: {\n        id: { type: 'Int', primaryKey: true, autoIncrement: true },\n        name: { type: 'String', required: true },\n        price: { type: 'Float', required: true },\n        inStock: { type: 'Boolean', default: true },\n        description: { type: 'String', required: false },\n        createdAt: { type: 'DateTime', default: 'now()' }\n      }\n    }\n  }\n};\n\n// Function to generate SQL from model\nfunction generateModelSQL(modelName, model) {\n  let sql = `CREATE TABLE ${modelName} (\\n`;\n  \n  let fields = [];\n  for (let [fieldName, field] of Object.entries(model.fields)) {\n    let line = `  ${fieldName} `;\n    \n    // Type mapping\n    if (field.type === 'Int') line += 'INTEGER';\n    else if (field.type === 'String') line += 'TEXT';\n    else if (field.type === 'Float') line += 'REAL';\n    else if (field.type === 'Boolean') line += 'BOOLEAN';\n    else if (field.type === 'DateTime') line += 'TIMESTAMP';\n    \n    // Constraints\n    if (field.primaryKey) line += ' PRIMARY KEY';\n    if (field.autoIncrement) line += ' AUTOINCREMENT';\n    if (field.required) line += ' NOT NULL';\n    if (field.default !== undefined) {\n      if (field.default === 'now()') line += ' DEFAULT CURRENT_TIMESTAMP';\n      else if (typeof field.default === 'boolean') line += ` DEFAULT ${field.default ? 1 : 0}`;\n      else line += ` DEFAULT ${field.default}`;\n    }\n    \n    fields.push(line);\n  }\n  \n  sql += fields.join(',\\n');\n  sql += '\\n);';\n  \n  return sql;\n}\n\n// Generate SQL\nlet sql = generateModelSQL('Product', schema.models.Product);\nconsole.log('Generated SQL:\\n');\nconsole.log(sql);\n\n// Display schema\nconsole.log('\\nPrisma Schema Structure:');\nconsole.log(JSON.stringify(schema, null, 2));",
              "solution": "// Complete Prisma schema simulator\nlet schema = {\n  datasource: {\n    provider: 'postgresql',\n    url: 'env(\"DATABASE_URL\")'\n  },\n  generator: {\n    provider: 'prisma-client-js'\n  },\n  models: {\n    Product: {\n      fields: {\n        id: {\n          type: 'Int',\n          primaryKey: true,\n          autoIncrement: true\n        },\n        name: {\n          type: 'String',\n          required: true\n        },\n        price: {\n          type: 'Float',\n          required: true\n        },\n        inStock: {\n          type: 'Boolean',\n          default: true\n        },\n        description: {\n          type: 'String',\n          required: false\n        },\n        category: {\n          type: 'String',\n          default: 'General'\n        },\n        createdAt: {\n          type: 'DateTime',\n          default: 'now()'\n        },\n        updatedAt: {\n          type: 'DateTime',\n          updatedAt: true\n        }\n      }\n    },\n    Order: {\n      fields: {\n        id: {\n          type: 'Int',\n          primaryKey: true,\n          autoIncrement: true\n        },\n        productId: {\n          type: 'Int',\n          required: true\n        },\n        quantity: {\n          type: 'Int',\n          required: true,\n          default: 1\n        },\n        total: {\n          type: 'Float',\n          required: true\n        },\n        createdAt: {\n          type: 'DateTime',\n          default: 'now()'\n        }\n      }\n    }\n  }\n};\n\nfunction generateModelSQL(modelName, model) {\n  let sql = `CREATE TABLE ${modelName} (\\n`;\n  let fields = [];\n  \n  for (let [fieldName, field] of Object.entries(model.fields)) {\n    let line = `  ${fieldName} `;\n    \n    // Map Prisma types to SQL types\n    let typeMap = {\n      'Int': 'INTEGER',\n      'String': 'TEXT',\n      'Float': 'REAL',\n      'Boolean': 'BOOLEAN',\n      'DateTime': 'TIMESTAMP'\n    };\n    \n    line += typeMap[field.type] || 'TEXT';\n    \n    if (field.primaryKey) line += ' PRIMARY KEY';\n    if (field.autoIncrement) line += ' AUTOINCREMENT';\n    if (field.required) line += ' NOT NULL';\n    \n    if (field.default !== undefined) {\n      if (field.default === 'now()') {\n        line += ' DEFAULT CURRENT_TIMESTAMP';\n      } else if (typeof field.default === 'boolean') {\n        line += ` DEFAULT ${field.default ? 1 : 0}`;\n      } else if (typeof field.default === 'string') {\n        line += ` DEFAULT '${field.default}'`;\n      } else {\n        line += ` DEFAULT ${field.default}`;\n      }\n    }\n    \n    fields.push(line);\n  }\n  \n  sql += fields.join(',\\n');\n  sql += '\\n);';\n  return sql;\n}\n\nconsole.log('=== Prisma Schema Simulator ===\\n');\n\n// Generate SQL for all models\nfor (let [modelName, model] of Object.entries(schema.models)) {\n  console.log(`${modelName} Model SQL:\\n`);\n  console.log(generateModelSQL(modelName, model));\n  console.log('');\n}\n\n// Display schema structure\nconsole.log('Complete Prisma Schema:');\nconsole.log(`datasource: ${schema.datasource.provider}`);\nconsole.log(`generator: ${schema.generator.provider}`);\nconsole.log(`models: ${Object.keys(schema.models).join(', ')}`);\nconsole.log('\\nDetailed Schema:');\nconsole.log(JSON.stringify(schema, null, 2));",
              "hints": [
                "Create nested objects: schema → models → Product → fields → {id, name, price...}"
              ],
              "testCases": [
                {
                  "description": "Schema has Product model",
                  "input": "let schema = { models: { Product: { fields: { id: { type: 'Int' } } } } }; console.log('Product' in schema.models);",
                  "expectedOutput": "true"
                },
                {
                  "description": "Product has required name field",
                  "input": "let model = { fields: { name: { type: 'String', required: true } } }; console.log(model.fields.name.required);",
                  "expectedOutput": "true"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-11-11-4",
          "title": "Running Migrations (The Construction Log Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Running Migrations (The Construction Log Analogy)\n\n## Understanding the Concept\n\nImagine you're building a house over several months:\n\nWithout a construction log:\n- Workers forget what was done yesterday\n- No record of foundation changes\n- Can't rebuild if something breaks\n- No way to share changes with other teams\n- Every site does things differently\n\nWith a construction log (Prisma migrations):\n- Detailed record of every change\n- Day 1: Poured foundation\n- Day 5: Built first floor walls\n- Day 10: Added plumbing\n- Any worker can see the full history\n- Can replay changes to build identical houses\n\nPrisma migrations are a construction log for your database. Each migration file records ONE specific change (like adding a table or field). These files:\n1. Track database evolution over time\n2. Can be replayed on other computers\n3. Make it easy to update production databases\n4. Keep your team synchronized\n\nInstead of manually writing SQL to update your database, Prisma generates migration files automatically from your schema changes!\n\n## Code Example\n\n```javascript\n// Understanding Prisma Migrations\n// Migrations are SQL files that modify your database structure\n\n// SCENARIO: Building a blog app\n\n// Step 1: Initial schema (schema.prisma)\n/*\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String\n}\n*/\n\n// Run migration command:\n// npx prisma migrate dev --name init\n\n// Prisma generates:\n// migrations/20250114_init/migration.sql\n/*\nCREATE TABLE \"User\" (\n  \"id\" INTEGER PRIMARY KEY AUTOINCREMENT,\n  \"email\" TEXT UNIQUE NOT NULL,\n  \"name\" TEXT NOT NULL\n);\n*/\n\nconsole.log('Migration 1: Created User table');\n\n// Step 2: Add posts table\n// Update schema.prisma:\n/*\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String\n  posts Post[]  // NEW: Added relationship\n}\n\nmodel Post {  // NEW: Added entire model\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n}\n*/\n\n// Run migration:\n// npx prisma migrate dev --name add_posts\n\n// Prisma generates:\n// migrations/20250114_add_posts/migration.sql\n/*\nCREATE TABLE \"Post\" (\n  \"id\" INTEGER PRIMARY KEY AUTOINCREMENT,\n  \"title\" TEXT NOT NULL,\n  \"content\" TEXT,\n  \"published\" BOOLEAN NOT NULL DEFAULT 0,\n  \"authorId\" INTEGER NOT NULL,\n  FOREIGN KEY (\"authorId\") REFERENCES \"User\"(\"id\")\n);\n*/\n\nconsole.log('Migration 2: Created Post table with relationship to User');\n\n// Step 3: Add createdAt timestamps\n// Update schema.prisma:\n/*\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  name      String\n  createdAt DateTime @default(now())  // NEW\n  posts     Post[]\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  createdAt DateTime @default(now())  // NEW\n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n}\n*/\n\n// Run migration:\n// npx prisma migrate dev --name add_timestamps\n\n// Prisma generates:\n// migrations/20250114_add_timestamps/migration.sql\n/*\nALTER TABLE \"User\" ADD COLUMN \"createdAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;\nALTER TABLE \"Post\" ADD COLUMN \"createdAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;\n*/\n\nconsole.log('Migration 3: Added createdAt to User and Post tables');\n\n// MIGRATION COMMANDS EXPLAINED\n\nlet migrationCommands = {\n  'Development': {\n    'npx prisma migrate dev': 'Create and apply migrations in development',\n    'npx prisma migrate dev --name <name>': 'Create migration with descriptive name',\n    'npx prisma migrate reset': 'Reset database and replay all migrations',\n    'npx prisma db push': 'Quick prototype without creating migration file'\n  },\n  \n  'Production': {\n    'npx prisma migrate deploy': 'Apply pending migrations to production',\n    'npx prisma migrate resolve': 'Mark migration as applied/rolled back',\n    'npx prisma migrate status': 'Check which migrations are pending'\n  },\n  \n  'Inspection': {\n    'npx prisma migrate diff': 'Compare database to schema',\n    'npx prisma db pull': 'Introspect existing database to generate schema',\n    'npx prisma studio': 'Visual database browser'\n  }\n};\n\nconsole.log('\\n=== Prisma Migration Commands ===\\n');\n\nfor (let [category, commands] of Object.entries(migrationCommands)) {\n  console.log(category + ' Commands:');\n  for (let [cmd, desc] of Object.entries(commands)) {\n    console.log(`  ${cmd}`);\n    console.log(`    → ${desc}`);\n  }\n  console.log('');\n}\n\n// MIGRATION WORKFLOW SIMULATION\n\nlet migrationHistory = [\n  {\n    name: '20250114_init',\n    description: 'Initial database setup',\n    changes: ['Created User table']\n  },\n  {\n    name: '20250114_add_posts',\n    description: 'Add blog posts',\n    changes: ['Created Post table', 'Added User.posts relation']\n  },\n  {\n    name: '20250114_add_timestamps',\n    description: 'Add audit timestamps',\n    changes: ['Added User.createdAt', 'Added Post.createdAt']\n  }\n];\n\nconsole.log('Migration History:');\nmigrationHistory.forEach((migration, index) => {\n  console.log(`\\n${index + 1}. ${migration.name}`);\n  console.log(`   Description: ${migration.description}`);\n  console.log('   Changes:');\n  migration.changes.forEach(change => {\n    console.log(`     - ${change}`);\n  });\n});\n\n// BENEFITS OF MIGRATIONS\n\nlet benefits = [\n  'Version control: Track database changes like code',\n  'Reproducible: Same migrations = identical databases',\n  'Team sync: Everyone applies same changes',\n  'Rollback: Can undo changes if needed',\n  'Production safety: Test migrations before deploying',\n  'Documentation: Clear history of schema evolution',\n  'CI/CD: Automated database updates in pipelines'\n];\n\nconsole.log('\\nBenefits of Migrations:');\nbenefits.forEach(benefit => console.log(`  ✓ ${benefit}`));\n```\n\n## Breaking Down the Syntax\n\nPrisma Migration Commands Guide:\n\n1. **Creating Migrations** (Development):\n   ```bash\n   # Standard workflow\n   npx prisma migrate dev --name add_user_table\n   \n   # What this does:\n   # 1. Compares schema.prisma to current database\n   # 2. Generates SQL migration file\n   # 3. Applies migration to database\n   # 4. Runs prisma generate (updates Prisma Client)\n   ```\n\n2. **Migration File Structure**:\n   ```\n   prisma/\n   ├── schema.prisma\n   └── migrations/\n       ├── 20250114120000_init/\n       │   └── migration.sql\n       ├── 20250114130000_add_posts/\n       │   └── migration.sql\n       └── migration_lock.toml\n   ```\n\n3. **Example Migration File**:\n   ```sql\n   -- CreateTable\n   CREATE TABLE \"User\" (\n       \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n       \"email\" TEXT NOT NULL,\n       \"name\" TEXT NOT NULL\n   );\n   \n   -- CreateIndex\n   CREATE UNIQUE INDEX \"User_email_key\" ON \"User\"(\"email\");\n   ```\n\n4. **Common Migration Workflows**:\n\n   **First Migration**:\n   ```bash\n   # 1. Write schema.prisma\n   # 2. Create initial migration\n   npx prisma migrate dev --name init\n   ```\n\n   **Add New Table**:\n   ```bash\n   # 1. Add model to schema.prisma\n   # 2. Create migration\n   npx prisma migrate dev --name add_posts\n   ```\n\n   **Modify Existing Table**:\n   ```bash\n   # 1. Update model in schema.prisma\n   # 2. Create migration\n   npx prisma migrate dev --name add_user_bio\n   ```\n\n5. **Development vs Production**:\n\n   **Development** (migrate dev):\n   - Creates migration files\n   - Applies to local database\n   - Updates Prisma Client\n   - Can reset database easily\n   \n   ```bash\n   npx prisma migrate dev\n   ```\n\n   **Production** (migrate deploy):\n   - Only applies existing migrations\n   - Never creates new migrations\n   - Safe for production\n   - No schema changes\n   \n   ```bash\n   npx prisma migrate deploy\n   ```\n\n6. **Reset Database** (Development Only!):\n   ```bash\n   npx prisma migrate reset\n   \n   # This:\n   # 1. Drops entire database\n   # 2. Creates new database\n   # 3. Applies all migrations\n   # 4. Runs seed script (if exists)\n   ```\n\n7. **Prototyping Without Migrations**:\n   ```bash\n   npx prisma db push\n   \n   # Use when:\n   # - Early prototyping\n   # - Don't want migration files yet\n   # - Quick schema tests\n   \n   # DON'T use in production!\n   ```\n\n8. **Check Migration Status**:\n   ```bash\n   npx prisma migrate status\n   \n   # Shows:\n   # - Applied migrations\n   # - Pending migrations\n   # - Database drift (manual changes)\n   ```\n\n9. **Naming Conventions**:\n   ```bash\n   # Good names (descriptive):\n   npx prisma migrate dev --name init\n   npx prisma migrate dev --name add_user_profile\n   npx prisma migrate dev --name make_email_unique\n   npx prisma migrate dev --name add_post_comments\n   \n   # Bad names (not descriptive):\n   npx prisma migrate dev --name update\n   npx prisma migrate dev --name fix\n   npx prisma migrate dev --name changes\n   ```\n\n10. **Full Deployment Workflow**:\n    ```bash\n    # Development:\n    git checkout -b feature/add-comments\n    # Update schema.prisma\n    npx prisma migrate dev --name add_comments\n    git add prisma/\n    git commit -m \"Add comments table\"\n    git push\n    \n    # Production (CI/CD or manual):\n    git pull\n    npx prisma migrate deploy  # Apply pending migrations\n    npm run build\n    npm run start\n    ```\n\n## Common Mistakes & Tips\n\nCommon migration mistakes:\n\n1. **Forgetting to run migrations**:\n   ```bash\n   # Changed schema.prisma but database not updated!\n   \n   # Must run:\n   npx prisma migrate dev\n   ```\n\n2. **Using db push in production**:\n   ```bash\n   # NEVER do this in production:\n   npx prisma db push  # No migration history!\n   \n   # Use migrate deploy instead:\n   npx prisma migrate deploy\n   ```\n\n3. **Editing migration files manually**:\n   - Don't edit generated migrations unless absolutely necessary\n   - Prisma tracks checksums - manual edits can cause errors\n   - Better: create new migration to fix issues\n\n4. **Not committing migration files**:\n   ```bash\n   # WRONG: Ignoring migrations in .gitignore\n   prisma/migrations/  # Don't do this!\n   \n   # CORRECT: Commit migrations to git\n   git add prisma/migrations/\n   git commit -m \"Add user table migration\"\n   ```\n\n5. **Running migrate dev in production**:\n   ```bash\n   # Development:\n   npx prisma migrate dev  # Creates migrations\n   \n   # Production:\n   npx prisma migrate deploy  # Only applies existing migrations\n   ```\n\n6. **Schema drift (manual database changes)**:\n   ```bash\n   # Problem: Someone manually altered database\n   # Solution: Check drift\n   npx prisma migrate diff\n   \n   # Then either:\n   # - Revert manual changes\n   # - Create migration to match changes\n   ```\n\n7. **Migration conflicts in teams**:\n   ```bash\n   # Two developers create migrations at same time\n   # Git merge conflict in migrations folder\n   \n   # Resolution:\n   # 1. Pull latest changes\n   # 2. Reset local database\n   npx prisma migrate reset\n   # 3. Migrations will replay in correct order\n   ```\n\n8. **Forgetting to generate Prisma Client**:\n   ```bash\n   # After migration, types might be outdated\n   npx prisma generate\n   \n   # Or use migrate dev which does it automatically\n   npx prisma migrate dev\n   ```\n\n9. **Not testing migrations**:\n   ```bash\n   # Best practice:\n   # 1. Create migration in development\n   npx prisma migrate dev --name add_feature\n   \n   # 2. Test thoroughly\n   npm run test\n   \n   # 3. Deploy to staging\n   npx prisma migrate deploy\n   \n   # 4. Test staging\n   \n   # 5. Deploy to production\n   npx prisma migrate deploy\n   ```\n\n10. **Breaking changes without data migration**:\n    ```prisma\n    // Dangerous: Deleting field loses data!\n    model User {\n      id    Int    @id\n      email String\n      // name String  ← Deleted! Data lost!\n    }\n    \n    // Better: Make optional first, then remove later\n    model User {\n      id    Int     @id\n      email String\n      name  String? ← Made optional, can migrate data\n    }\n    ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Simulate a migration system:\n\n1. Create a `migrations` array to store migration records\n2. Create a function `createMigration(name, sql)` that:\n   - Generates a timestamp\n   - Creates migration object\n   - Adds to migrations array\n   - Returns the migration\n3. Create a function `applyMigrations()` that:\n   - Loops through all migrations\n   - Simulates executing SQL\n   - Tracks which are applied\n4. Simulate creating 3 migrations:\n   - 'init' (create users table)\n   - 'add_posts' (create posts table)\n   - 'add_timestamps' (add createdAt fields)\n5. Display migration history\n\nYou're simulating what Prisma does!",
              "starterCode": "// Migration system simulator\nlet migrations = [];\nlet appliedMigrations = new Set();\n\n// Create migration\nfunction createMigration(name, sql) {\n  let timestamp = Date.now();\n  let migration = {\n    id: `${timestamp}_${name}`,\n    name: name,\n    sql: sql,\n    createdAt: new Date().toISOString()\n  };\n  \n  migrations.push(migration);\n  console.log(`✓ Created migration: ${migration.id}`);\n  return migration;\n}\n\n// Apply migrations\nfunction applyMigrations() {\n  console.log('\\nApplying migrations...');\n  \n  for (let migration of migrations) {\n    if (!appliedMigrations.has(migration.id)) {\n      console.log(`  Running: ${migration.name}`);\n      console.log(`  SQL: ${migration.sql}`);\n      appliedMigrations.add(migration.id);\n      console.log(`  ✓ Applied: ${migration.id}\\n`);\n    } else {\n      console.log(`  ⊘ Skipped (already applied): ${migration.name}`);\n    }\n  }\n}\n\n// Get migration status\nfunction getMigrationStatus() {\n  console.log('=== Migration Status ===');\n  console.log(`Total migrations: ${migrations.length}`);\n  console.log(`Applied: ${appliedMigrations.size}`);\n  console.log(`Pending: ${migrations.length - appliedMigrations.size}`);\n}\n\n// Create migrations\nconsole.log('=== Creating Migrations ===\\n');\n\ncreateMigration('init', 'CREATE TABLE users (id INT, email TEXT, name TEXT);');\n\nsetTimeout(() => {\n  createMigration('add_posts', 'CREATE TABLE posts (id INT, title TEXT, author_id INT);');\n}, 100);\n\nsetTimeout(() => {\n  createMigration('add_timestamps', 'ALTER TABLE users ADD COLUMN created_at TIMESTAMP;');\n}, 200);\n\nsetTimeout(() => {\n  applyMigrations();\n  getMigrationStatus();\n  \n  console.log('\\n=== Migration History ===');\n  migrations.forEach((m, i) => {\n    let status = appliedMigrations.has(m.id) ? '✓ Applied' : '⏳ Pending';\n    console.log(`${i + 1}. ${m.name} - ${status}`);\n  });\n}, 400);",
              "solution": "// Complete migration system simulator\nlet migrations = [];\nlet appliedMigrations = new Set();\nlet database = {\n  tables: {},\n  indexes: []\n};\n\nfunction createMigration(name, description, sql) {\n  let timestamp = Date.now();\n  let migration = {\n    id: `${timestamp}_${name}`,\n    name: name,\n    description: description,\n    sql: sql,\n    createdAt: new Date().toISOString(),\n    applied: false\n  };\n  \n  migrations.push(migration);\n  console.log(`✓ Created migration: ${migration.id}`);\n  console.log(`  Description: ${description}`);\n  return migration;\n}\n\nfunction applyMigrations() {\n  console.log('\\n=== Applying Migrations ===\\n');\n  \n  let applied = 0;\n  for (let migration of migrations) {\n    if (!appliedMigrations.has(migration.id)) {\n      console.log(`Running: ${migration.name}`);\n      console.log(`SQL: ${migration.sql}`);\n      \n      // Simulate executing SQL\n      executeSQLSimulation(migration.sql);\n      \n      appliedMigrations.add(migration.id);\n      migration.applied = true;\n      applied++;\n      \n      console.log(`✓ Applied: ${migration.id}\\n`);\n    } else {\n      console.log(`⊘ Skipped (already applied): ${migration.name}\\n`);\n    }\n  }\n  \n  console.log(`Completed: ${applied} migration(s) applied`);\n}\n\nfunction executeSQLSimulation(sql) {\n  // Simulate SQL execution\n  if (sql.includes('CREATE TABLE')) {\n    let match = sql.match(/CREATE TABLE (\\w+)/);\n    if (match) {\n      let tableName = match[1];\n      database.tables[tableName] = { created: true };\n      console.log(`  → Created table: ${tableName}`);\n    }\n  } else if (sql.includes('ALTER TABLE')) {\n    console.log('  → Altered table structure');\n  }\n}\n\nfunction getMigrationStatus() {\n  console.log('\\n=== Migration Status ===');\n  console.log(`Total migrations: ${migrations.length}`);\n  console.log(`Applied: ${appliedMigrations.size}`);\n  console.log(`Pending: ${migrations.length - appliedMigrations.size}`);\n  console.log(`Database tables: ${Object.keys(database.tables).join(', ') || 'none'}`);\n}\n\nfunction rollbackLastMigration() {\n  let lastApplied = migrations.filter(m => m.applied).pop();\n  if (lastApplied) {\n    appliedMigrations.delete(lastApplied.id);\n    lastApplied.applied = false;\n    console.log(`\\n✓ Rolled back: ${lastApplied.name}`);\n  } else {\n    console.log('\\nNo migrations to roll back');\n  }\n}\n\nfunction listMigrations() {\n  console.log('\\n=== Migration History ===');\n  migrations.forEach((m, i) => {\n    let status = m.applied ? '✓ Applied' : '⏳ Pending';\n    console.log(`${i + 1}. ${m.name}`);\n    console.log(`   ID: ${m.id}`);\n    console.log(`   Status: ${status}`);\n    console.log(`   Created: ${m.createdAt}`);\n    console.log(`   Description: ${m.description}`);\n    console.log('');\n  });\n}\n\n// Create migrations\nconsole.log('=== Migration System Simulator ===\\n');\n\ncreateMigration(\n  'init',\n  'Initial database setup',\n  'CREATE TABLE users (id INT PRIMARY KEY, email TEXT UNIQUE, name TEXT);'\n);\n\nsetTimeout(() => {\n  createMigration(\n    'add_posts',\n    'Add blog posts table',\n    'CREATE TABLE posts (id INT PRIMARY KEY, title TEXT, content TEXT, author_id INT);'\n  );\n}, 100);\n\nsetTimeout(() => {\n  createMigration(\n    'add_timestamps',\n    'Add audit timestamps',\n    'ALTER TABLE users ADD COLUMN created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;'\n  );\n}, 200);\n\nsetTimeout(() => {\n  applyMigrations();\n  getMigrationStatus();\n  listMigrations();\n}, 400);",
              "hints": [
                "Use timestamps for unique IDs, Set to track applied migrations, loops to apply each one"
              ],
              "testCases": [
                {
                  "description": "Creates migration with timestamp",
                  "input": "let migrations = []; let m = { id: Date.now() + '_init', name: 'init' }; migrations.push(m); console.log(migrations.length);",
                  "expectedOutput": "1"
                },
                {
                  "description": "Tracks applied migrations",
                  "input": "let applied = new Set(); applied.add('123_init'); console.log(applied.has('123_init'));",
                  "expectedOutput": "true"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-11-11-5",
          "title": "Handling Relations (The Social Network Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Handling Relations (The Social Network Analogy)\n\n## Understanding the Concept\n\nImagine designing a social network:\n\nWithout relationships:\n- Each user's posts stored separately\n- No way to find who wrote which post\n- Comments disconnected from posts\n- Can't see friends list\n- Data duplication everywhere!\n\nWith relationships (Prisma relations):\n- Users ← many → Posts (one user has many posts)\n- Posts ← many → Comments (one post has many comments)\n- Users ← many ↔ many → Users (users can follow each other)\n- Data connected logically\n- No duplication!\n\nDatabase relations are like links between different entities. They mirror real-world connections:\n- A customer has many orders\n- A blog post has many comments\n- A student enrolls in many courses\n\nPrisma makes defining these relationships incredibly simple with its intuitive syntax!\n\n## Code Example\n\n```javascript\n// Understanding Prisma Relations\n\n// THREE TYPES OF RELATIONSHIPS:\n\n// 1. ONE-TO-MANY (Most common)\n// Example: One user has many posts\n/*\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String\n  \n  posts Post[]  // Array: User has many posts\n}\n\nmodel Post {\n  id       Int    @id @default(autoincrement())\n  title    String\n  content  String?\n  \n  authorId Int    // Foreign key\n  author   User   @relation(fields: [authorId], references: [id])\n}\n*/\n\nconsole.log('=== ONE-TO-MANY Relationship ===');\nconsole.log('One User → Many Posts');\nconsole.log('Schema: User.posts (array), Post.author (single)');\nconsole.log('');\n\n// Example data structure:\nlet oneToManyExample = {\n  user: {\n    id: 1,\n    email: 'alice@example.com',\n    name: 'Alice',\n    posts: [  // Array of posts\n      { id: 1, title: 'First Post', authorId: 1 },\n      { id: 2, title: 'Second Post', authorId: 1 },\n      { id: 3, title: 'Third Post', authorId: 1 }\n    ]\n  }\n};\n\nconsole.log('Example data:');\nconsole.log(JSON.stringify(oneToManyExample, null, 2));\nconsole.log('');\n\n// 2. ONE-TO-ONE (Less common)\n// Example: One user has one profile\n/*\nmodel User {\n  id      Int      @id @default(autoincrement())\n  email   String   @unique\n  name    String\n  \n  profile Profile? // Optional: User might not have profile yet\n}\n\nmodel Profile {\n  id     Int    @id @default(autoincrement())\n  bio    String?\n  avatar String?\n  \n  userId Int     @unique  // UNIQUE makes it one-to-one!\n  user   User    @relation(fields: [userId], references: [id])\n}\n*/\n\nconsole.log('=== ONE-TO-ONE Relationship ===');\nconsole.log('One User → One Profile');\nconsole.log('Schema: Profile.userId must be @unique');\nconsole.log('');\n\nlet oneToOneExample = {\n  user: {\n    id: 1,\n    email: 'alice@example.com',\n    name: 'Alice',\n    profile: {  // Single profile object\n      id: 1,\n      bio: 'Software developer',\n      avatar: 'https://example.com/alice.jpg',\n      userId: 1\n    }\n  }\n};\n\nconsole.log('Example data:');\nconsole.log(JSON.stringify(oneToOneExample, null, 2));\nconsole.log('');\n\n// 3. MANY-TO-MANY (Complex but powerful)\n// Example: Users can like many posts, posts can be liked by many users\n/*\nmodel User {\n  id        Int    @id @default(autoincrement())\n  email     String @unique\n  name      String\n  \n  likedPosts Post[] @relation(\"PostLikes\")\n}\n\nmodel Post {\n  id       Int      @id @default(autoincrement())\n  title    String\n  content  String?\n  \n  likedBy  User[]   @relation(\"PostLikes\")\n}\n\n// Prisma creates a join table automatically:\n// _PostLikes (userId, postId)\n*/\n\nconsole.log('=== MANY-TO-MANY Relationship ===');\nconsole.log('Many Users ↔ Many Posts (likes)');\nconsole.log('Schema: Both sides have arrays, named relation');\nconsole.log('Prisma auto-creates join table: _PostLikes');\nconsole.log('');\n\nlet manyToManyExample = {\n  user: {\n    id: 1,\n    name: 'Alice',\n    likedPosts: [  // Array of posts Alice liked\n      { id: 5, title: 'Cool Post' },\n      { id: 7, title: 'Amazing Article' }\n    ]\n  },\n  post: {\n    id: 5,\n    title: 'Cool Post',\n    likedBy: [  // Array of users who liked this post\n      { id: 1, name: 'Alice' },\n      { id: 2, name: 'Bob' },\n      { id: 3, name: 'Charlie' }\n    ]\n  }\n};\n\nconsole.log('Example data:');\nconsole.log(JSON.stringify(manyToManyExample, null, 2));\nconsole.log('');\n\n// EXPLICIT MANY-TO-MANY (when you need extra fields)\n// Example: User enrollments in courses (with enrollment date)\n/*\nmodel User {\n  id          Int          @id @default(autoincrement())\n  name        String\n  enrollments Enrollment[]\n}\n\nmodel Course {\n  id          Int          @id @default(autoincrement())\n  title       String\n  enrollments Enrollment[]\n}\n\nmodel Enrollment {\n  id         Int      @id @default(autoincrement())\n  enrolledAt DateTime @default(now())\n  grade      String?\n  \n  userId     Int\n  user       User     @relation(fields: [userId], references: [id])\n  \n  courseId   Int\n  course     Course   @relation(fields: [courseId], references: [id])\n  \n  @@unique([userId, courseId])  // Can't enroll in same course twice\n}\n*/\n\nconsole.log('=== EXPLICIT MANY-TO-MANY ===');\nconsole.log('When you need extra fields on the relationship');\nconsole.log('Example: Enrollment date, grade, status');\nconsole.log('');\n\n// QUERYING RELATIONS WITH PRISMA CLIENT\n\nlet queryExamples = [\n  '// Get user with all their posts',\n  'let user = await prisma.user.findUnique({',\n  '  where: { id: 1 },',\n  '  include: { posts: true }  // Include related posts',\n  '});',\n  '',\n  '// Get post with author info',\n  'let post = await prisma.post.findUnique({',\n  '  where: { id: 1 },',\n  '  include: { author: true }  // Include related user',\n  '});',\n  '',\n  '// Create post with author connection',\n  'let post = await prisma.post.create({',\n  '  data: {',\n  '    title: \"New Post\",',\n  '    content: \"Hello!\",',\n  '    author: {',\n  '      connect: { id: 1 }  // Connect to existing user',\n  '    }',\n  '  }',\n  '});',\n  '',\n  '// Create user with posts in one go',\n  'let user = await prisma.user.create({',\n  '  data: {',\n  '    email: \"bob@example.com\",',\n  '    name: \"Bob\",',\n  '    posts: {',\n  '      create: [  // Create posts at same time',\n  '        { title: \"First\", content: \"Content 1\" },',\n  '        { title: \"Second\", content: \"Content 2\" }',\n  '      ]',\n  '    }',\n  '  }',\n  '});'\n];\n\nconsole.log('Querying Relations:');\nqueryExamples.forEach(line => console.log(line));\n```\n\n## Breaking Down the Syntax\n\nPrisma Relations Syntax Guide:\n\n1. **ONE-TO-MANY Relationship**:\n   ```prisma\n   model User {\n     id    Int    @id @default(autoincrement())\n     posts Post[] // Relation field (no column in database)\n   }\n   \n   model Post {\n     id       Int  @id @default(autoincrement())\n     authorId Int  // Foreign key (actual column)\n     author   User @relation(fields: [authorId], references: [id])\n   }\n   ```\n   \n   Key points:\n   - \"Many\" side: array type (Post[])\n   - \"One\" side: singular type + @relation\n   - Foreign key: actual database column\n   - Relation field: virtual, not in database\n\n2. **ONE-TO-ONE Relationship**:\n   ```prisma\n   model User {\n     id      Int      @id\n     profile Profile? // Optional (user might not have profile)\n   }\n   \n   model Profile {\n     id     Int  @id\n     userId Int  @unique // UNIQUE makes it one-to-one!\n     user   User @relation(fields: [userId], references: [id])\n   }\n   ```\n   \n   Key points:\n   - Foreign key must be @unique\n   - One side usually optional (?)\n\n3. **MANY-TO-MANY (Implicit)**:\n   ```prisma\n   model User {\n     id    Int    @id\n     posts Post[] @relation(\"UserLikes\")\n   }\n   \n   model Post {\n     id     Int    @id\n     likedBy User[] @relation(\"UserLikes\")\n   }\n   ```\n   \n   Key points:\n   - Both sides are arrays\n   - Named relation (\"UserLikes\")\n   - Prisma auto-creates join table (_UserLikes)\n   - No foreign keys needed!\n\n4. **MANY-TO-MANY (Explicit)**:\n   ```prisma\n   model User {\n     id          Int          @id\n     enrollments Enrollment[]\n   }\n   \n   model Course {\n     id          Int          @id\n     enrollments Enrollment[]\n   }\n   \n   model Enrollment {\n     id       Int      @id\n     userId   Int\n     user     User     @relation(fields: [userId], references: [id])\n     courseId Int\n     course   Course   @relation(fields: [courseId], references: [id])\n     \n     enrolledAt DateTime @default(now())\n     grade      String?\n     \n     @@unique([userId, courseId])\n   }\n   ```\n   \n   Use when you need:\n   - Extra fields (enrolledAt, grade)\n   - Composite unique constraints\n   - More control over join table\n\n5. **Relation Attributes**:\n   ```prisma\n   @relation(fields: [authorId], references: [id])\n   ```\n   \n   - `fields`: Foreign key in this model\n   - `references`: Primary key in related model\n   - Both are arrays (can be composite keys)\n\n6. **Cascade Delete** (be careful!):\n   ```prisma\n   model User {\n     id    Int    @id\n     posts Post[]\n   }\n   \n   model Post {\n     id       Int  @id\n     authorId Int\n     author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)\n   }\n   ```\n   \n   Options:\n   - `Cascade`: Delete posts when user deleted\n   - `SetNull`: Set authorId to null\n   - `Restrict`: Prevent deletion if posts exist\n   - `NoAction`: Database default\n\n7. **Self-Relations** (like followers):\n   ```prisma\n   model User {\n     id         Int    @id\n     followers  User[] @relation(\"UserFollows\")\n     following  User[] @relation(\"UserFollows\")\n   }\n   ```\n\n8. **Querying Relations**:\n   ```typescript\n   // Include related data\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: {\n       posts: true,\n       profile: true\n     }\n   });\n   \n   // Select specific fields\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     select: {\n       name: true,\n       posts: {\n         select: {\n           title: true,\n           createdAt: true\n         }\n       }\n     }\n   });\n   \n   // Filter relations\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: {\n       posts: {\n         where: { published: true },\n         orderBy: { createdAt: 'desc' },\n         take: 5\n       }\n     }\n   });\n   ```\n\n9. **Creating with Relations**:\n   ```typescript\n   // Connect to existing\n   await prisma.post.create({\n     data: {\n       title: 'New Post',\n       author: { connect: { id: 1 } }\n     }\n   });\n   \n   // Create related\n   await prisma.user.create({\n     data: {\n       email: 'bob@example.com',\n       posts: {\n         create: [\n           { title: 'First Post' },\n           { title: 'Second Post' }\n         ]\n       }\n     }\n   });\n   \n   // Nested writes\n   await prisma.user.update({\n     where: { id: 1 },\n     data: {\n       posts: {\n         create: { title: 'Another Post' },\n         delete: { id: 5 },\n         update: {\n           where: { id: 3 },\n           data: { title: 'Updated Title' }\n         }\n       }\n     }\n   });\n   ```\n\n## Common Mistakes & Tips\n\nCommon relation mistakes:\n\n1. **Forgetting foreign key field**:\n   ```prisma\n   // WRONG! Missing authorId\n   model Post {\n     id     Int  @id\n     author User @relation(fields: [authorId], references: [id])\n   }\n   \n   // CORRECT!\n   model Post {\n     id       Int  @id\n     authorId Int  // Foreign key field\n     author   User @relation(fields: [authorId], references: [id])\n   }\n   ```\n\n2. **Wrong array syntax**:\n   ```prisma\n   // WRONG!\n   model User {\n     posts Post  // Missing brackets!\n   }\n   \n   // CORRECT!\n   model User {\n     posts Post[]  // Array of posts\n   }\n   ```\n\n3. **Missing @relation name for many-to-many**:\n   ```prisma\n   // WRONG! Ambiguous relation\n   model User {\n     posts Post[]\n   }\n   model Post {\n     users User[]\n   }\n   \n   // CORRECT!\n   model User {\n     posts Post[] @relation(\"UserPosts\")\n   }\n   model Post {\n     users User[] @relation(\"UserPosts\")\n   }\n   ```\n\n4. **Not using @unique for one-to-one**:\n   ```prisma\n   // WRONG! This is one-to-many without @unique\n   model Profile {\n     userId Int\n     user   User @relation(fields: [userId], references: [id])\n   }\n   \n   // CORRECT! @unique makes it one-to-one\n   model Profile {\n     userId Int  @unique\n     user   User @relation(fields: [userId], references: [id])\n   }\n   ```\n\n5. **Forgetting include in queries**:\n   ```typescript\n   // WRONG! This doesn't include posts\n   const user = await prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.posts);  // undefined!\n   \n   // CORRECT!\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: { posts: true }\n   });\n   console.log(user.posts);  // Array of posts\n   ```\n\n6. **Cascade delete pitfalls**:\n   ```prisma\n   // DANGEROUS! Deleting user deletes all posts\n   model Post {\n     authorId Int\n     author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)\n   }\n   \n   // Better: Prevent deletion if posts exist\n   model Post {\n     authorId Int\n     author   User @relation(fields: [authorId], references: [id], onDelete: Restrict)\n   }\n   ```\n\n7. **Creating without connecting**:\n   ```typescript\n   // WRONG! Post needs an author\n   await prisma.post.create({\n     data: {\n       title: 'New Post'\n       // Missing author connection!\n     }\n   });\n   \n   // CORRECT!\n   await prisma.post.create({\n     data: {\n       title: 'New Post',\n       author: { connect: { id: 1 } }\n     }\n   });\n   ```\n\n8. **Self-relation confusion**:\n   ```prisma\n   // WRONG! Ambiguous self-relation\n   model User {\n     followers User[]\n     following User[]\n   }\n   \n   // CORRECT! Named relation\n   model User {\n     followers User[] @relation(\"UserFollows\")\n     following User[] @relation(\"UserFollows\")\n   }\n   ```\n\n9. **Not understanding implicit vs explicit many-to-many**:\n   ```prisma\n   // Implicit: Prisma manages join table\n   model User {\n     posts Post[] @relation(\"Likes\")\n   }\n   model Post {\n     likedBy User[] @relation(\"Likes\")\n   }\n   \n   // Explicit: You control join table (when you need extra fields)\n   model User {\n     likes Like[]\n   }\n   model Post {\n     likes Like[]\n   }\n   model Like {\n     userId Int\n     user   User @relation(fields: [userId], references: [id])\n     postId Int\n     post   Post @relation(fields: [postId], references: [id])\n     likedAt DateTime @default(now())  // Extra field!\n   }\n   ```\n\n10. **Relation filtering mistakes**:\n    ```typescript\n    // WRONG! Can't filter like this\n    const users = await prisma.user.findMany({\n      where: { posts.published: true }  // Error!\n    });\n    \n    // CORRECT! Use relation filters\n    const users = await prisma.user.findMany({\n      where: {\n        posts: {\n          some: { published: true }  // Users with at least one published post\n        }\n      }\n    });\n    ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Simulate Prisma relations:\n\n1. Create a schema object with three models:\n   - Author (id, name, books array)\n   - Book (id, title, authorId, author)\n   - Category (id, name, books array)\n2. Set up a one-to-many relation: Author → Books\n3. Set up a many-to-many relation: Books ↔ Categories\n4. Create sample data showing:\n   - One author with multiple books\n   - Books connected to multiple categories\n5. Create a function `getAuthorWithBooks(authorId)` that returns author with their books\n6. Display the relational data\n\nYou're simulating Prisma's relation system!",
              "starterCode": "// Simulated Prisma relations\nlet database = {\n  authors: [\n    {\n      id: 1,\n      name: 'J.K. Rowling',\n      books: []  // Will populate\n    }\n  ],\n  books: [\n    {\n      id: 1,\n      title: 'Harry Potter',\n      authorId: 1,\n      categories: []  // Will populate\n    },\n    {\n      id: 2,\n      title: 'Fantastic Beasts',\n      authorId: 1,\n      categories: []\n    }\n  ],\n  categories: [\n    { id: 1, name: 'Fantasy', books: [] },\n    { id: 2, name: 'Adventure', books: [] }\n  ]\n};\n\n// Function to get author with books\nfunction getAuthorWithBooks(authorId) {\n  let author = database.authors.find(a => a.id === authorId);\n  if (!author) return null;\n  \n  // Find books by this author (one-to-many)\n  let books = database.books.filter(b => b.authorId === authorId);\n  \n  return {\n    ...author,\n    books: books\n  };\n}\n\n// Function to get book with categories\nfunction getBookWithCategories(bookId) {\n  let book = database.books.find(b => b.id === bookId);\n  if (!book) return null;\n  \n  // Many-to-many: find categories for this book\n  let categories = database.categories.filter(c => \n    c.books.includes(bookId)\n  );\n  \n  return {\n    ...book,\n    categories: categories\n  };\n}\n\n// Set up many-to-many relations\ndatabase.categories[0].books = [1, 2];  // Fantasy has both books\ndatabase.categories[1].books = [1];     // Adventure has HP only\n\ndatabase.books[0].categories = [1, 2];  // HP is Fantasy + Adventure\ndatabase.books[1].categories = [1];     // FB is Fantasy only\n\n// Test relations\nconsole.log('=== One-to-Many: Author → Books ===');\nlet authorWithBooks = getAuthorWithBooks(1);\nconsole.log(JSON.stringify(authorWithBooks, null, 2));\n\nconsole.log('\\n=== Many-to-Many: Book ↔ Categories ===');\nlet bookWithCategories = getBookWithCategories(1);\nconsole.log(JSON.stringify(bookWithCategories, null, 2));",
              "solution": "// Complete Prisma relations simulator\nlet database = {\n  authors: [\n    { id: 1, name: 'J.K. Rowling', bio: 'British author' },\n    { id: 2, name: 'George R.R. Martin', bio: 'American novelist' }\n  ],\n  books: [\n    { id: 1, title: 'Harry Potter and the Philosopher\\'s Stone', authorId: 1, published: true },\n    { id: 2, title: 'Harry Potter and the Chamber of Secrets', authorId: 1, published: true },\n    { id: 3, title: 'Fantastic Beasts', authorId: 1, published: true },\n    { id: 4, title: 'A Game of Thrones', authorId: 2, published: true },\n    { id: 5, title: 'A Clash of Kings', authorId: 2, published: true }\n  ],\n  categories: [\n    { id: 1, name: 'Fantasy' },\n    { id: 2, name: 'Adventure' },\n    { id: 3, name: 'Young Adult' },\n    { id: 4, name: 'Epic Fantasy' }\n  ],\n  // Many-to-many join table\n  bookCategories: [\n    { bookId: 1, categoryId: 1 },  // HP1 → Fantasy\n    { bookId: 1, categoryId: 2 },  // HP1 → Adventure\n    { bookId: 1, categoryId: 3 },  // HP1 → YA\n    { bookId: 2, categoryId: 1 },  // HP2 → Fantasy\n    { bookId: 2, categoryId: 3 },  // HP2 → YA\n    { bookId: 3, categoryId: 1 },  // FB → Fantasy\n    { bookId: 4, categoryId: 1 },  // GoT → Fantasy\n    { bookId: 4, categoryId: 4 },  // GoT → Epic Fantasy\n    { bookId: 5, categoryId: 1 },  // Clash → Fantasy\n    { bookId: 5, categoryId: 4 }   // Clash → Epic Fantasy\n  ]\n};\n\n// Prisma-style queries\n\nfunction findAuthorWithBooks(authorId) {\n  let author = database.authors.find(a => a.id === authorId);\n  if (!author) return null;\n  \n  // One-to-many: get all books by this author\n  let books = database.books.filter(b => b.authorId === authorId);\n  \n  // Include categories for each book\n  books = books.map(book => {\n    let categoryIds = database.bookCategories\n      .filter(bc => bc.bookId === book.id)\n      .map(bc => bc.categoryId);\n    \n    let categories = database.categories.filter(c => \n      categoryIds.includes(c.id)\n    );\n    \n    return { ...book, categories };\n  });\n  \n  return { ...author, books };\n}\n\nfunction findBookWithRelations(bookId) {\n  let book = database.books.find(b => b.id === bookId);\n  if (!book) return null;\n  \n  // Get author (many-to-one)\n  let author = database.authors.find(a => a.id === book.authorId);\n  \n  // Get categories (many-to-many)\n  let categoryIds = database.bookCategories\n    .filter(bc => bc.bookId === bookId)\n    .map(bc => bc.categoryId);\n  \n  let categories = database.categories.filter(c => \n    categoryIds.includes(c.id)\n  );\n  \n  return { ...book, author, categories };\n}\n\nfunction findCategoryWithBooks(categoryId) {\n  let category = database.categories.find(c => c.id === categoryId);\n  if (!category) return null;\n  \n  // Many-to-many: get all books in this category\n  let bookIds = database.bookCategories\n    .filter(bc => bc.categoryId === categoryId)\n    .map(bc => bc.bookId);\n  \n  let books = database.books.filter(b => bookIds.includes(b.id));\n  \n  // Include authors\n  books = books.map(book => {\n    let author = database.authors.find(a => a.id === book.authorId);\n    return { ...book, author };\n  });\n  \n  return { ...category, books };\n}\n\nfunction getStats() {\n  return {\n    totalAuthors: database.authors.length,\n    totalBooks: database.books.length,\n    totalCategories: database.categories.length,\n    averageBooksPerAuthor: (database.books.length / database.authors.length).toFixed(1)\n  };\n}\n\n// Test the relations\nconsole.log('=== Prisma Relations Simulator ===\\n');\n\nconsole.log('1. ONE-TO-MANY: Author with Books');\nconsole.log('Query: prisma.author.findUnique({ where: { id: 1 }, include: { books: true } })\\n');\nlet jkRowling = findAuthorWithBooks(1);\nconsole.log(JSON.stringify(jkRowling, null, 2));\n\nconsole.log('\\n2. MANY-TO-MANY: Book with Categories');\nconsole.log('Query: prisma.book.findUnique({ where: { id: 1 }, include: { categories: true } })\\n');\nlet hp1 = findBookWithRelations(1);\nconsole.log(JSON.stringify(hp1, null, 2));\n\nconsole.log('\\n3. MANY-TO-MANY REVERSE: Category with Books');\nconsole.log('Query: prisma.category.findUnique({ where: { id: 1 }, include: { books: true } })\\n');\nlet fantasy = findCategoryWithBooks(1);\nconsole.log(JSON.stringify(fantasy, null, 2));\n\nconsole.log('\\n4. Database Statistics');\nconsole.log(getStats());",
              "hints": [
                "Use filter() for one-to-many, arrays for many-to-many relationships"
              ],
              "testCases": [
                {
                  "description": "Author has multiple books",
                  "input": "let books = [{ id: 1, authorId: 1 }, { id: 2, authorId: 1 }]; let authorBooks = books.filter(b => b.authorId === 1); console.log(authorBooks.length);",
                  "expectedOutput": "2"
                },
                {
                  "description": "Many-to-many with arrays",
                  "input": "let book = { id: 1, categories: [1, 2] }; console.log(book.categories.length);",
                  "expectedOutput": "2"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "module-12",
      "title": "Module 12: Building Modern Front-End with React 19",
      "description": "Learn React 19's latest features including JSX, components, hooks (useState, useEffect), and the new React 19 hooks",
      "difficulty": "advanced",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-12-12-1",
          "title": "JSX - JavaScript Meets HTML (But It's NOT HTML!)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# JSX - JavaScript Meets HTML (But It's NOT HTML!)\n\n## Understanding the Concept\n\nImagine writing a recipe:\n\nPlain text recipe:\n- Hard to read\n- No structure\n- Easy to mess up\n\nFormatted recipe with sections:\n- Ingredients (like HTML tags)\n- Instructions (like JavaScript logic)\n- Combined in one document\n\nJSX is like having ingredients AND instructions in one file:\n- Looks like HTML (familiar and readable)\n- But it's actually JavaScript (gets compiled)\n- Can use JavaScript expressions inside {}\n\nJSX = JavaScript XML. It's JavaScript that LOOKS like HTML!\n\n## Code Example\n\n```javascript\n// JSX - The Syntax That Powers React\n\n// IMPORTANT: JSX compiles to JavaScript!\n// This JSX:\n// <h1>Hello World</h1>\n//\n// Becomes this JavaScript:\n// React.createElement('h1', null, 'Hello World')\n\nconsole.log('=== JSX Fundamentals ===\\n');\n\n// 1. JSX LOOKS LIKE HTML (but isn't!)\nlet jsxElement = '<h1>Hello, React!</h1>'; // This is just a string\nconsole.log('String:', jsxElement);\n\n// Real JSX (conceptual - won't run in plain JavaScript):\n// let jsxElement = <h1>Hello, React!</h1>;\n// This compiles to: React.createElement('h1', null, 'Hello, React!');\n\n// 2. EMBEDDING JAVASCRIPT WITH {}\nlet name = 'Alice';\nlet age = 25;\n\n// JSX allows JavaScript expressions inside curly braces\nlet greeting = `<h1>Hello, ${name}!</h1>`;  // Template literal (similar concept)\nconsole.log('\\nGreeting:', greeting);\n\n// In real JSX:\n// <h1>Hello, {name}!</h1>\n// <p>You are {age} years old</p>\n// <p>Next year: {age + 1}</p>\n\n// 3. JSX VS HTML - KEY DIFFERENCES\nconsole.log('\\n=== JSX vs HTML Differences ===\\n');\n\nlet differences = {\n  'class': {\n    html: '<div class=\"card\">',\n    jsx: '<div className=\"card\">',\n    reason: 'class is a JavaScript keyword'\n  },\n  'for': {\n    html: '<label for=\"name\">',\n    jsx: '<label htmlFor=\"name\">',\n    reason: 'for is a JavaScript keyword'\n  },\n  'style': {\n    html: '<div style=\"color: red; font-size: 16px\">',\n    jsx: '<div style={{ color: \"red\", fontSize: \"16px\" }}>',\n    reason: 'JSX style is a JavaScript object'\n  },\n  'onclick': {\n    html: '<button onclick=\"handleClick()\">',\n    jsx: '<button onClick={handleClick}>',\n    reason: 'camelCase in JSX, function reference not string'\n  },\n  'self-closing': {\n    html: '<img src=\"pic.jpg\">',\n    jsx: '<img src=\"pic.jpg\" />',\n    reason: 'JSX requires closing slash for void elements'\n  }\n};\n\nfor (let [feature, diff] of Object.entries(differences)) {\n  console.log(`${feature.toUpperCase()}:`);\n  console.log(`  HTML: ${diff.html}`);\n  console.log(`  JSX:  ${diff.jsx}`);\n  console.log(`  Why:  ${diff.reason}\\n`);\n}\n\n// 4. JAVASCRIPT EXPRESSIONS IN JSX\nconsole.log('=== JavaScript in JSX ===\\n');\n\nlet user = {\n  firstName: 'Bob',\n  lastName: 'Smith',\n  age: 30\n};\n\n// You can use ANY JavaScript expression inside {}\nlet examples = [\n  `{user.firstName}           → ${user.firstName}`,\n  `{user.firstName + ' ' + user.lastName} → ${user.firstName + ' ' + user.lastName}`,\n  `{age > 18 ? 'Adult' : 'Minor'} → ${user.age > 18 ? 'Adult' : 'Minor'}`,\n  `{[1,2,3].map(n => n * 2)}  → ${[1,2,3].map(n => n * 2).join(', ')}`\n];\n\nexamples.forEach(ex => console.log(ex));\n\n// 5. MUST RETURN SINGLE ROOT ELEMENT\nconsole.log('\\n=== JSX Rules ===\\n');\n\n// WRONG (in JSX - multiple roots):\n// return (\n//   <h1>Title</h1>\n//   <p>Text</p>\n// );\n\n// CORRECT - Wrapped in div:\n// return (\n//   <div>\n//     <h1>Title</h1>\n//     <p>Text</p>\n//   </div>\n// );\n\n// BETTER - React Fragment (no extra DOM node):\n// return (\n//   <>\n//     <h1>Title</h1>\n//     <p>Text</p>\n//   </>\n// );\n\nconsole.log('✓ JSX must have ONE root element');\nconsole.log('✓ Use <> </> (Fragment) to avoid extra divs');\nconsole.log('✓ All tags must be closed (including <img />, <br />)');\nconsole.log('✓ Use className not class');\nconsole.log('✓ Use camelCase for attributes (onClick, onChange)');\n\n// 6. WHY JSX?\nlet benefits = [\n  'Familiar HTML-like syntax',\n  'JavaScript power with {} expressions',\n  'Type checking and autocomplete',\n  'Prevents injection attacks (auto-escapes)',\n  'Easier to visualize component structure',\n  'Not required but highly recommended'\n];\n\nconsole.log('\\nWhy use JSX:');\nbenefits.forEach(b => console.log(`  ✓ ${b}`));\n```\n\n## Breaking Down the Syntax\n\nJSX syntax guide:\n\n1. **JSX is JavaScript, not HTML**:\n   ```jsx\n   // This JSX:\n   const element = <h1>Hello</h1>;\n   \n   // Compiles to:\n   const element = React.createElement('h1', null, 'Hello');\n   ```\n\n2. **Embedding Expressions** with {}:\n   ```jsx\n   const name = 'Alice';\n   const element = <h1>Hello, {name}!</h1>;\n   \n   // Any JavaScript expression works:\n   <p>{2 + 2}</p>                    // 4\n   <p>{user.name.toUpperCase()}</p>  // ALICE\n   <p>{isLoggedIn ? 'Hi' : 'Please login'}</p>\n   ```\n\n3. **Attributes in JSX**:\n   ```jsx\n   // className not class\n   <div className=\"container\"></div>\n   \n   // htmlFor not for\n   <label htmlFor=\"email\">Email:</label>\n   \n   // camelCase event handlers\n   <button onClick={handleClick}>Click</button>\n   \n   // Style as object\n   <div style={{ color: 'red', fontSize: 16 }}></div>\n   ```\n\n4. **Self-Closing Tags**:\n   ```jsx\n   // Must include /\n   <img src=\"logo.png\" />\n   <br />\n   <input type=\"text\" />\n   ```\n\n5. **Children**:\n   ```jsx\n   // String children\n   <h1>Title</h1>\n   \n   // Expression children\n   <p>{user.name}</p>\n   \n   // Component children\n   <div>\n     <Header />\n     <Main />\n     <Footer />\n   </div>\n   ```\n\n6. **Fragments** (avoid extra divs):\n   ```jsx\n   // Shorthand\n   return (\n     <>\n       <h1>Title</h1>\n       <p>Text</p>\n     </>\n   );\n   \n   // Full syntax (needed for keys)\n   return (\n     <React.Fragment>\n       <h1>Title</h1>\n       <p>Text</p>\n     </React.Fragment>\n   );\n   ```\n\n7. **Comments in JSX**:\n   ```jsx\n   return (\n     <div>\n       {/* This is a comment */}\n       <h1>Title</h1>\n     </div>\n   );\n   ```\n\n## Common Mistakes & Tips\n\nCommon JSX mistakes:\n\n1. **Using `class` instead of `className`**:\n   ```jsx\n   // Wrong!\n   <div class=\"container\">  // Error in JSX\n   \n   // Correct!\n   <div className=\"container\">\n   ```\n\n2. **Forgetting to close tags**:\n   ```jsx\n   // Wrong!\n   <img src=\"logo.png\">     // Error!\n   <br>                     // Error!\n   \n   // Correct!\n   <img src=\"logo.png\" />\n   <br />\n   ```\n\n3. **Quotes around JavaScript expressions**:\n   ```jsx\n   // Wrong!\n   <p>{\"userName\"}</p>       // Renders the string \"userName\"\n   <p>{age + 1}</p>         // Wrong quotes\n   \n   // Correct!\n   <p>{userName}</p>        // Uses the variable\n   <p>{age + 1}</p>         // No quotes for expressions\n   ```\n\n4. **Multiple root elements**:\n   ```jsx\n   // Wrong!\n   return (\n     <h1>Title</h1>\n     <p>Text</p>            // Error: Adjacent JSX elements\n   );\n   \n   // Correct!\n   return (\n     <>\n       <h1>Title</h1>\n       <p>Text</p>\n     </>\n   );\n   ```\n\n5. **Inline style as string**:\n   ```jsx\n   // Wrong! (HTML syntax)\n   <div style=\"color: red; font-size: 16px\">\n   \n   // Correct! (JSX object syntax)\n   <div style={{ color: 'red', fontSize: 16 }}>\n   //          ^^^^ object  ^^^^^ camelCase\n   ```\n\n6. **Event handler called immediately**:\n   ```jsx\n   // Wrong!\n   <button onClick={handleClick()}>  // Calls immediately!\n   \n   // Correct!\n   <button onClick={handleClick}>    // Passes function reference\n   <button onClick={() => handleClick()}>  // Arrow function wrapper\n   ```\n\n7. **Conditional rendering syntax**:\n   ```jsx\n   // Wrong!\n   <div>\n     if (isLoggedIn) {      // Can't use if in JSX!\n       <p>Welcome</p>\n     }\n   </div>\n   \n   // Correct!\n   <div>\n     {isLoggedIn && <p>Welcome</p>}           // && operator\n     {isLoggedIn ? <p>Hi</p> : <p>Login</p>}  // Ternary\n   </div>\n   ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Practice JSX concepts:\n\n1. Create variables for:\n   - `firstName` = your first name\n   - `lastName` = your last name\n   - `age` = your age\n\n2. Create a `getFullName()` function that returns first + last name\n\n3. Create a simulated JSX structure (as a string) that includes:\n   - An h1 with full name\n   - A p showing age\n   - A p showing if adult (age >= 18)\n\n4. Log the result\n\nNote: Since we're in plain JavaScript, use template literals to simulate JSX.",
              "starterCode": "// Simulate JSX with template literals\n\nlet firstName = 'Alice';\nlet lastName = 'Johnson';\nlet age = 25;\n\nfunction getFullName() {\n  return firstName + ' ' + lastName;\n}\n\n// Simulate JSX structure\nlet jsxOutput = `\n<div className=\"user-card\">\n  <h1>Name: ${getFullName()}</h1>\n  <p>Age: ${age}</p>\n  <p>Status: ${age >= 18 ? 'Adult' : 'Minor'}</p>\n</div>\n`;\n\nconsole.log('Simulated JSX:');\nconsole.log(jsxOutput);",
              "solution": "// Complete JSX simulation\n\nlet firstName = 'Alice';\nlet lastName = 'Johnson';\nlet age = 25;\nlet isStudent = true;\n\nfunction getFullName() {\n  return `${firstName} ${lastName}`;\n}\n\nfunction getStatus() {\n  if (age < 18) return 'Minor';\n  if (isStudent) return 'Adult Student';\n  return 'Adult';\n}\n\n// Simulated JSX with all features\nlet jsxOutput = `\n<div className=\"user-card\">\n  <h1>Welcome, ${getFullName()}!</h1>\n  <div className=\"user-info\">\n    <p>First Name: ${firstName}</p>\n    <p>Last Name: ${lastName}</p>\n    <p>Age: ${age}</p>\n    <p>Status: ${getStatus()}</p>\n    <p>Can Vote: ${age >= 18 ? 'Yes' : 'No'}</p>\n  </div>\n  ${isStudent ? '<p className=\"badge\">Student Discount Available!</p>' : ''}\n</div>\n`;\n\nconsole.log('=== Simulated JSX Output ===');\nconsole.log(jsxOutput);\n\n// Demonstrate JavaScript expressions\nconsole.log('\\n=== Expression Examples ===');\nconsole.log('Full name:', getFullName());\nconsole.log('Next year age:', age + 1);\nconsole.log('Name length:', getFullName().length);\nconsole.log('Uppercase:', getFullName().toUpperCase());\nconsole.log('Adult?', age >= 18);\n\n// Array mapping (common in JSX)\nlet hobbies = ['Reading', 'Coding', 'Gaming'];\nlet hobbiesList = hobbies.map(hobby => `<li>${hobby}</li>`).join('\\n');\nconsole.log('\\nHobbies list:');\nconsole.log('<ul>');\nconsole.log(hobbiesList);\nconsole.log('</ul>');",
              "hints": [
                "Use template literals with ${} to embed JavaScript expressions."
              ],
              "testCases": [
                {
                  "description": "Should concatenate names",
                  "input": "let first = 'John'; let last = 'Doe'; first + ' ' + last",
                  "expectedOutput": "John Doe"
                },
                {
                  "description": "Should check adult status",
                  "input": "let age = 20; age >= 18 ? 'Adult' : 'Minor'",
                  "expectedOutput": "Adult"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-12-12-2",
          "title": "Components and Props (The LEGO Blocks Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Components and Props (The LEGO Blocks Analogy)\n\n## Understanding the Concept\n\nThink of React components like LEGO blocks:\n\nBasic LEGO block:\n- Standard shape and size\n- Can connect to other blocks\n- Reusable - use the same piece many times\n- Different colors (props) make each one unique\n\nCustom LEGO creation (component):\n- Build a car from blocks\n- Want 5 cars? Use the same design 5 times\n- Each car can be different color (props)\n- Change the design once → All cars update\n\nReact components are reusable building blocks:\n- Define once, use many times\n- Pass props to customize each instance\n- Compose small components into bigger ones!\n\n## Code Example\n\n```javascript\n// React Components and Props\n\nconsole.log('=== React Components ===\\n');\n\n// COMPONENT = Reusable UI function\n// Props = Data passed to component (like function parameters)\n\n// 1. FUNCTION COMPONENT (modern React)\nfunction Greeting(props) {\n  return `<h1>Hello, ${props.name}!</h1>`;\n}\n\n// Use it multiple times with different props\nlet greeting1 = Greeting({ name: 'Alice' });\nlet greeting2 = Greeting({ name: 'Bob' });\nlet greeting3 = Greeting({ name: 'Charlie' });\n\nconsole.log('Same component, different props:');\nconsole.log(greeting1);  // Hello, Alice!\nconsole.log(greeting2);  // Hello, Bob!\nconsole.log(greeting3);  // Hello, Charlie!\n\n// 2. PROPS ARE READ-ONLY\nfunction UserCard(props) {\n  // props.name = 'Different'; // ERROR! Can't modify props!\n  \n  return `\n    <div className=\"user-card\">\n      <h2>${props.name}</h2>\n      <p>Email: ${props.email}</p>\n      <p>Role: ${props.role || 'User'}</p>\n    </div>\n  `;\n}\n\nlet user1 = UserCard({\n  name: 'Alice Johnson',\n  email: 'alice@example.com',\n  role: 'Admin'\n});\n\nlet user2 = UserCard({\n  name: 'Bob Smith',\n  email: 'bob@example.com'\n  // No role = uses default 'User'\n});\n\nconsole.log('\\nUser Cards:');\nconsole.log(user1);\nconsole.log(user2);\n\n// 3. DESTRUCTURING PROPS (cleaner syntax)\nfunction Button({ label, color, onClick }) {\n  // Instead of props.label, props.color, etc.\n  return `<button style=\"background: ${color}\" onClick=\"${onClick}\">${label}</button>`;\n}\n\nlet submitBtn = Button({\n  label: 'Submit',\n  color: 'blue',\n  onClick: 'handleSubmit()'\n});\n\nconsole.log('\\nButton:', submitBtn);\n\n// 4. PROPS WITH CHILDREN\nfunction Card({ title, children }) {\n  return `\n    <div className=\"card\">\n      <h3>${title}</h3>\n      <div className=\"card-body\">\n        ${children}\n      </div>\n    </div>\n  `;\n}\n\nlet card = Card({\n  title: 'My Card',\n  children: '<p>This is the card content</p><p>Multiple children!</p>'\n});\n\nconsole.log('\\nCard with children:');\nconsole.log(card);\n\n// 5. COMPONENT COMPOSITION\nfunction Header({ logo, title }) {\n  return `<header><img src=\"${logo}\" /><h1>${title}</h1></header>`;\n}\n\nfunction Footer({ year, company }) {\n  return `<footer><p>© ${year} ${company}</p></footer>`;\n}\n\nfunction App() {\n  return `\n    <div className=\"app\">\n      ${Header({ logo: 'logo.png', title: 'My App' })}\n      <main>\n        ${Card({ title: 'Welcome', children: '<p>Welcome to my app!</p>' })}\n      </main>\n      ${Footer({ year: 2025, company: 'My Company' })}\n    </div>\n  `;\n}\n\nconsole.log('\\nComplete App (composed of smaller components):');\nconsole.log(App());\n\n// 6. PROPS BEST PRACTICES\nconsole.log('\\n=== Props Best Practices ===\\n');\n\nlet practices = [\n  '✓ Props are read-only (immutable)',\n  '✓ Destructure props for cleaner code',\n  '✓ Provide default values: role || \"User\"',\n  '✓ Use clear, descriptive prop names',\n  '✓ Pass only what component needs',\n  '✓ Children prop for nested content',\n  '✓ Keep components focused and reusable'\n];\n\npractices.forEach(p => console.log(p));\n```\n\n## Breaking Down the Syntax\n\nComponents and Props explained:\n\n1. **Function Component** (modern standard):\n   ```jsx\n   function Welcome(props) {\n     return <h1>Hello, {props.name}!</h1>;\n   }\n   \n   // Use it:\n   <Welcome name=\"Alice\" />\n   ```\n\n2. **Props Object**:\n   ```jsx\n   function UserCard(props) {\n     // props = { name: 'Alice', age: 25, email: 'alice@...' }\n     return (\n       <div>\n         <h2>{props.name}</h2>\n         <p>Age: {props.age}</p>\n         <p>Email: {props.email}</p>\n       </div>\n     );\n   }\n   ```\n\n3. **Destructuring Props** (recommended):\n   ```jsx\n   // Instead of props.name, props.age...\n   function UserCard({ name, age, email }) {\n     return (\n       <div>\n         <h2>{name}</h2>\n         <p>Age: {age}</p>\n         <p>Email: {email}</p>\n       </div>\n     );\n   }\n   ```\n\n4. **Default Props**:\n   ```jsx\n   function Button({ label, color = 'blue', size = 'medium' }) {\n     return <button style={{ backgroundColor: color }}>{label}</button>;\n   }\n   \n   // Uses defaults:\n   <Button label=\"Click\" />  // blue, medium\n   \n   // Override defaults:\n   <Button label=\"Submit\" color=\"green\" size=\"large\" />\n   ```\n\n5. **Children Prop** (special):\n   ```jsx\n   function Card({ title, children }) {\n     return (\n       <div className=\"card\">\n         <h3>{title}</h3>\n         <div className=\"card-body\">\n           {children}\n         </div>\n       </div>\n     );\n   }\n   \n   // Use with children:\n   <Card title=\"My Card\">\n     <p>This is the content</p>\n     <button>Action</button>\n   </Card>\n   ```\n\n6. **Passing Functions as Props**:\n   ```jsx\n   function Button({ label, onClick }) {\n     return <button onClick={onClick}>{label}</button>;\n   }\n   \n   // Parent passes function:\n   function App() {\n     function handleClick() {\n       console.log('Clicked!');\n     }\n     \n     return <Button label=\"Click Me\" onClick={handleClick} />;\n   }\n   ```\n\n7. **Component Composition**:\n   ```jsx\n   function App() {\n     return (\n       <div>\n         <Header />\n         <Sidebar />\n         <MainContent>\n           <Article title=\"Hello\" />\n           <Article title=\"World\" />\n         </MainContent>\n         <Footer />\n       </div>\n     );\n   }\n   ```\n\n## Common Mistakes & Tips\n\nCommon component/props mistakes:\n\n1. **Modifying props (forbidden!)**:\n   ```jsx\n   function UserCard(props) {\n     props.name = 'Different';  // ERROR! Props are read-only!\n     return <h1>{props.name}</h1>;\n   }\n   ```\n   Props flow down (parent → child) and cannot be changed by child.\n\n2. **Forgetting to pass props**:\n   ```jsx\n   function Greeting({ name }) {\n     return <h1>Hello, {name}!</h1>;\n   }\n   \n   // Wrong!\n   <Greeting />  // name is undefined!\n   \n   // Correct!\n   <Greeting name=\"Alice\" />\n   ```\n\n3. **Component name not capitalized**:\n   ```jsx\n   // Wrong!\n   function greeting() {  // lowercase!\n     return <h1>Hello</h1>;\n   }\n   \n   // Correct!\n   function Greeting() {  // PascalCase!\n     return <h1>Hello</h1>;\n   }\n   ```\n   React treats lowercase as HTML tags, uppercase as components.\n\n4. **Not destructuring (verbose)**:\n   ```jsx\n   // Works but verbose:\n   function UserCard(props) {\n     return <div>{props.name} - {props.email} - {props.age}</div>;\n   }\n   \n   // Better (destructured):\n   function UserCard({ name, email, age }) {\n     return <div>{name} - {email} - {age}</div>;\n   }\n   ```\n\n5. **Missing key in lists**:\n   ```jsx\n   // Wrong!\n   {users.map(user => <UserCard {...user} />)}\n   \n   // Correct!\n   {users.map(user => <UserCard key={user.id} {...user} />)}\n   ```\n   React needs keys to track which items changed.\n\n6. **Passing strings incorrectly**:\n   ```jsx\n   // Wrong!\n   <UserCard age=\"25\" />     // age is string \"25\", not number!\n   \n   // Correct!\n   <UserCard age={25} />     // age is number 25\n   \n   // Strings don't need braces:\n   <UserCard name=\"Alice\" /> // OK\n   <UserCard name={'Alice'} /> // Also OK but unnecessary\n   ```\n\n7. **Inline object props (causes re-renders)**:\n   ```jsx\n   // Avoid (creates new object every render):\n   <UserCard style={{ color: 'red' }} />\n   \n   // Better (define outside):\n   const cardStyle = { color: 'red' };\n   <UserCard style={cardStyle} />\n   ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create reusable components with props:\n\n1. Create a `BlogPost` function that takes props:\n   - title\n   - author\n   - content\n   - Returns formatted HTML string\n\n2. Create an `AuthorBio` function that takes:\n   - name\n   - bio\n   - Returns formatted HTML string\n\n3. Create a `Blog` function that:\n   - Uses BlogPost twice with different data\n   - Uses AuthorBio once\n   - Returns complete blog page\n\nTest by calling Blog() and logging result.",
              "starterCode": "// Component functions\n\nfunction BlogPost({ title, author, content }) {\n  return `\n    <article className=\"blog-post\">\n      <h2>${title}</h2>\n      <p className=\"author\">By ${author}</p>\n      <p>${content}</p>\n    </article>\n  `;\n}\n\nfunction AuthorBio({ name, bio }) {\n  return `\n    <div className=\"author-bio\">\n      <h3>About ${name}</h3>\n      <p>${bio}</p>\n    </div>\n  `;\n}\n\nfunction Blog() {\n  return `\n    <div className=\"blog\">\n      <h1>My Blog</h1>\n      ${BlogPost({\n        title: 'Learning React',\n        author: 'Alice',\n        content: 'React is amazing for building UIs!'\n      })}\n      ${BlogPost({\n        title: 'Understanding Props',\n        author: 'Alice',\n        content: 'Props make components reusable.'\n      })}\n      ${AuthorBio({\n        name: 'Alice',\n        bio: 'Web developer and React enthusiast.'\n      })}\n    </div>\n  `;\n}\n\nconsole.log(Blog());",
              "solution": "// Complete component system with props\n\nfunction BlogPost({ title, author, content, date = 'Today' }) {\n  return `\n    <article className=\"blog-post\">\n      <h2>${title}</h2>\n      <div className=\"meta\">\n        <span className=\"author\">By ${author}</span>\n        <span className=\"date\">${date}</span>\n      </div>\n      <p className=\"content\">${content}</p>\n    </article>\n  `;\n}\n\nfunction AuthorBio({ name, bio, avatar = 'default-avatar.png' }) {\n  return `\n    <div className=\"author-bio\">\n      <img src=\"${avatar}\" alt=\"${name}\" className=\"avatar\" />\n      <h3>About ${name}</h3>\n      <p>${bio}</p>\n    </div>\n  `;\n}\n\nfunction CommentSection({ comments = [] }) {\n  if (comments.length === 0) {\n    return '<p>No comments yet.</p>';\n  }\n  \n  return `\n    <div className=\"comments\">\n      <h3>${comments.length} Comment${comments.length !== 1 ? 's' : ''}</h3>\n      ${comments.map(c => `\n        <div className=\"comment\">\n          <strong>${c.author}:</strong> ${c.text}\n        </div>\n      `).join('')}\n    </div>\n  `;\n}\n\nfunction Blog() {\n  let posts = [\n    {\n      title: 'Getting Started with React',\n      author: 'Alice Johnson',\n      content: 'React makes building user interfaces simple and enjoyable!',\n      date: 'Jan 15, 2025'\n    },\n    {\n      title: 'Understanding Props and Components',\n      author: 'Alice Johnson',\n      content: 'Props are the way we pass data between components.',\n      date: 'Jan 16, 2025'\n    }\n  ];\n  \n  let comments = [\n    { author: 'Bob', text: 'Great article!' },\n    { author: 'Charlie', text: 'Very helpful, thanks!' }\n  ];\n  \n  return `\n    <div className=\"blog\">\n      <header>\n        <h1>My React Blog</h1>\n      </header>\n      \n      <main>\n        ${posts.map(post => BlogPost(post)).join('\\n')}\n      </main>\n      \n      <aside>\n        ${AuthorBio({\n          name: 'Alice Johnson',\n          bio: 'Full-stack developer passionate about React and modern web development.',\n          avatar: 'alice-avatar.jpg'\n        })}\n      </aside>\n      \n      ${CommentSection({ comments })}\n    </div>\n  `;\n}\n\nconsole.log('=== Complete Blog Application ===\\n');\nconsole.log(Blog());\n\n// Demonstrate component reusability\nconsole.log('\\n=== Reusability Demo ===\\n');\nconsole.log('Creating 3 blog posts with same component:');\n\nfor (let i = 1; i <= 3; i++) {\n  console.log(BlogPost({\n    title: `Post ${i}`,\n    author: 'Demo Author',\n    content: `Content for post number ${i}`\n  }));\n}",
              "hints": [
                "Use destructuring in function parameters and template literals for HTML."
              ],
              "testCases": [
                {
                  "description": "Should use props in template",
                  "input": "let post = { title: 'Test', author: 'Bob' }; `<h2>${post.title}</h2><p>By ${post.author}</p>`",
                  "expectedOutput": "<h2>Test</h2><p>By Bob</p>"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-12-12-3",
          "title": "useState Hook - Giving Components Memory (The Light Switch Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# useState Hook - Giving Components Memory (The Light Switch Analogy)\n\n## Understanding the Concept\n\nThink of a light switch in your house:\n\nWithout state (broken switch):\n- You flip the switch up\n- Light turns on for a moment\n- Switch immediately resets to off\n- Light goes back off\n- Can't remember if it was on or off!\n\nWith state (working switch):\n- You flip switch up → light turns ON\n- Switch REMEMBERS it's on\n- Stays on until you flip it down\n- Switch REMEMBERS it's off\n- State = Current position of the switch\n\nReact useState is like giving your component a working switch:\n- Component can remember values between renders\n- When state changes → component re-renders\n- UI updates automatically to show new state\n- Perfect for: counters, form inputs, toggles, user data!\n\n## Code Example\n\n```javascript\n// useState Hook - Component Memory\n\nconsole.log('=== React useState Hook ===\\n');\n\n// WHY WE NEED STATE\nconsole.log('--- Without State (Doesn\\'t Work!) ---\\n');\n\nfunction simulateComponentWithoutState() {\n  let count = 0;  // Regular variable\n  \n  console.log('[Component] Initial render: count =', count);\n  \n  // User clicks button\n  console.log('[User] Clicks +1 button');\n  count = count + 1;\n  console.log('[Component] count =', count, '(but component doesn\\'t re-render!)');\n  \n  // Component renders again (for some reason)\n  count = 0;  // RESETS! Regular variables don't persist\n  console.log('[Component] Re-render: count =', count, '(LOST the value!)');\n}\n\nsimulateComponentWithoutState();\n\n// WITH STATE (Works!)\nconsole.log('\\n--- With useState (Works!) ---\\n');\n\nfunction simulateComponentWithState() {\n  // useState hook - PERSISTS between renders\n  let state = {\n    count: 0,\n    setCount: function(newValue) {\n      this.count = newValue;\n      console.log('[State Update] count changed to:', newValue);\n      console.log('[React] Re-rendering component...');\n    }\n  };\n  \n  console.log('[Component] Initial render: count =', state.count);\n  \n  // User clicks button\n  console.log('\\n[User] Clicks +1 button');\n  state.setCount(state.count + 1);\n  console.log('[Component] Re-render: count =', state.count, '(PERSISTED!)');\n  \n  // User clicks again\n  console.log('\\n[User] Clicks +1 button again');\n  state.setCount(state.count + 1);\n  console.log('[Component] Re-render: count =', state.count);\n}\n\nsimulateComponentWithState();\n\n// REAL useState SYNTAX\nconsole.log('\\n\\n=== useState Syntax ===\\n');\n\nconsole.log('// Import from React');\nconsole.log('import { useState } from \"react\";\\n');\n\nconsole.log('function Counter() {');\nconsole.log('  // useState returns [currentValue, setterFunction]');\nconsole.log('  const [count, setCount] = useState(0);');\nconsole.log('  //      ^^^^^  ^^^^^^^^          ^^^');\nconsole.log('  //      value  updater          initial value\\n');\n\nconsole.log('  function increment() {');\nconsole.log('    setCount(count + 1);  // Update state');\nconsole.log('  }\\n');\n\nconsole.log('  return (');\nconsole.log('    <div>');\nconsole.log('      <p>Count: {count}</p>');\nconsole.log('      <button onClick={increment}>+1</button>');\nconsole.log('    </div>');\nconsole.log('  );');\nconsole.log('}\\n');\n\n// MULTIPLE STATE VARIABLES\nconsole.log('=== Multiple State Variables ===\\n');\n\nconsole.log('function UserProfile() {');\nconsole.log('  const [name, setName] = useState(\"Alice\");');\nconsole.log('  const [age, setAge] = useState(25);');\nconsole.log('  const [isLoggedIn, setIsLoggedIn] = useState(false);\\n');\n\nconsole.log('  // Each state is independent!');\nconsole.log('  setName(\"Bob\");        // Only updates name');\nconsole.log('  setAge(30);           // Only updates age');\nconsole.log('  setIsLoggedIn(true);  // Only updates isLoggedIn');\nconsole.log('}\\n');\n\n// STATE WITH OBJECTS\nconsole.log('=== State with Objects ===\\n');\n\nlet userState = {\n  user: { name: 'Alice', age: 25, email: 'alice@example.com' },\n  setUser: function(newUser) {\n    // MUST create new object (don't mutate!)\n    this.user = { ...this.user, ...newUser };\n    console.log('[State] Updated user:', this.user);\n  }\n};\n\nconsole.log('Initial user:', userState.user);\n\nconsole.log('\\nUpdating age:');\nuserState.setUser({ age: 26 });  // Spread syntax preserves other fields\n\nconsole.log('\\n// WRONG way (mutation):');\nconsole.log('user.age = 26;        // ✗ Don\\'t mutate directly!');\nconsole.log('setUser(user);       // ✗ React won\\'t detect change!\\n');\n\nconsole.log('// CORRECT way (new object):');\nconsole.log('setUser({ ...user, age: 26 });  // ✓ Creates new object');\n\n// STATE WITH ARRAYS\nconsole.log('\\n\\n=== State with Arrays ===\\n');\n\nlet todosState = {\n  todos: ['Learn React', 'Build app'],\n  setTodos: function(newTodos) {\n    this.todos = newTodos;\n    console.log('[State] Updated todos:', this.todos);\n  }\n};\n\nconsole.log('Initial todos:', todosState.todos);\n\nconsole.log('\\nAdding todo:');\ntodosState.setTodos([...todosState.todos, 'Deploy app']);\n\nconsole.log('\\nRemoving first todo:');\ntodosState.setTodos(todosState.todos.slice(1));\n\nconsole.log('\\n--- Array State Patterns ---');\nconsole.log('Add item:    setTodos([...todos, newItem])');\nconsole.log('Remove item: setTodos(todos.filter(t => t.id !== id))');\nconsole.log('Update item: setTodos(todos.map(t => t.id === id ? updated : t))');\n```\n\n## Breaking Down the Syntax\n\nuseState Hook explained:\n\n1. **Basic useState**:\n   ```jsx\n   import { useState } from 'react';\n   \n   function Counter() {\n     const [count, setCount] = useState(0);\n     //      ^^^^^  ^^^^^^^^          ^^^\n     //      state  setter           initial value\n     \n     return (\n       <div>\n         <p>{count}</p>\n         <button onClick={() => setCount(count + 1)}>+1</button>\n       </div>\n     );\n   }\n   ```\n\n2. **Array Destructuring** (what [count, setCount] means):\n   ```jsx\n   // useState returns an array: [value, setter]\n   const stateArray = useState(0);  // [0, function]\n   const count = stateArray[0];     // Get value\n   const setCount = stateArray[1];  // Get setter\n   \n   // Shorthand (array destructuring):\n   const [count, setCount] = useState(0);  // Same thing!\n   ```\n\n3. **Initial Value**:\n   ```jsx\n   const [count, setCount] = useState(0);      // Number\n   const [name, setName] = useState('Alice');  // String\n   const [isOpen, setIsOpen] = useState(false); // Boolean\n   const [items, setItems] = useState([]);     // Array\n   const [user, setUser] = useState({ name: 'Alice' }); // Object\n   ```\n\n4. **Updating State**:\n   ```jsx\n   // Simple value\n   setCount(5);           // Set to 5\n   setCount(count + 1);   // Increment\n   \n   // Using previous value (safer)\n   setCount(prevCount => prevCount + 1);\n   ```\n\n5. **Multiple State Variables**:\n   ```jsx\n   function Form() {\n     const [name, setName] = useState('');\n     const [email, setEmail] = useState('');\n     const [age, setAge] = useState(0);\n     \n     // Each is independent\n   }\n   ```\n\n6. **State with Objects** (must spread!):\n   ```jsx\n   const [user, setUser] = useState({ name: 'Alice', age: 25 });\n   \n   // WRONG!\n   user.age = 26;         // Don't mutate!\n   setUser(user);         // React won't detect change\n   \n   // CORRECT!\n   setUser({ ...user, age: 26 });  // Create new object\n   ```\n\n7. **State with Arrays**:\n   ```jsx\n   const [items, setItems] = useState([1, 2, 3]);\n   \n   // Add item\n   setItems([...items, 4]);\n   setItems([newItem, ...items]);  // Add to beginning\n   \n   // Remove item\n   setItems(items.filter((item, index) => index !== 0));\n   \n   // Update item\n   setItems(items.map((item, i) => i === 1 ? newValue : item));\n   ```\n\n8. **Lazy Initial State** (expensive calculation):\n   ```jsx\n   // WRONG! (runs every render)\n   const [data, setData] = useState(expensiveCalculation());\n   \n   // CORRECT! (runs once)\n   const [data, setData] = useState(() => expensiveCalculation());\n   ```\n\n## Common Mistakes & Tips\n\nCommon useState mistakes:\n\n1. **Mutating state directly**:\n   ```jsx\n   // WRONG!\n   const [user, setUser] = useState({ name: 'Alice' });\n   user.name = 'Bob';     // Don't mutate!\n   setUser(user);         // React won't re-render\n   \n   // CORRECT!\n   setUser({ ...user, name: 'Bob' });  // New object\n   ```\n\n2. **Forgetting to use setter**:\n   ```jsx\n   const [count, setCount] = useState(0);\n   \n   // WRONG!\n   count = count + 1;     // Won't work!\n   \n   // CORRECT!\n   setCount(count + 1);   // Use setter\n   ```\n\n3. **Using state immediately after setting**:\n   ```jsx\n   const [count, setCount] = useState(0);\n   \n   function increment() {\n     setCount(count + 1);\n     console.log(count);    // Still 0! (state updates are async)\n   }\n   \n   // Use useEffect or callback to see new value:\n   setCount(prevCount => {\n     console.log('Will be:', prevCount + 1);\n     return prevCount + 1;\n   });\n   ```\n\n4. **Multiple setStates based on current state**:\n   ```jsx\n   // WRONG! (race condition)\n   setCount(count + 1);\n   setCount(count + 1);\n   setCount(count + 1);\n   // Count only increases by 1!\n   \n   // CORRECT!\n   setCount(c => c + 1);\n   setCount(c => c + 1);\n   setCount(c => c + 1);\n   // Count increases by 3!\n   ```\n\n5. **Mutating arrays**:\n   ```jsx\n   const [items, setItems] = useState([1, 2, 3]);\n   \n   // WRONG!\n   items.push(4);         // Mutates!\n   setItems(items);       // Won't re-render\n   \n   // CORRECT!\n   setItems([...items, 4]);  // New array\n   \n   // Other array operations:\n   setItems(items.filter(i => i !== 2));    // Remove\n   setItems(items.map(i => i === 2 ? 5 : i)); // Update\n   ```\n\n6. **Forgetting initial value**:\n   ```jsx\n   // WRONG!\n   const [count, setCount] = useState();  // undefined!\n   \n   // CORRECT!\n   const [count, setCount] = useState(0);  // Start at 0\n   ```\n\n7. **Using if/loops in component body with useState**:\n   ```jsx\n   // WRONG! (hooks must be at top level)\n   function MyComponent({ condition }) {\n     if (condition) {\n       const [state, setState] = useState(0);  // Error!\n     }\n   }\n   \n   // CORRECT!\n   function MyComponent({ condition }) {\n     const [state, setState] = useState(0);  // Always call\n     \n     if (condition) {\n       // Use state here\n     }\n   }\n   ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Simulate a counter component with state:\n\n1. Create a `Counter` object with:\n   - state: { count: 0 }\n   - setCount(newValue) method that updates count and logs it\n   - increment() method that calls setCount with count + 1\n   - decrement() method that calls setCount with count - 1\n   - reset() method that calls setCount with 0\n\n2. Test all methods and log the count after each operation",
              "starterCode": "// Counter with state\n\nlet Counter = {\n  state: { count: 0 },\n  \n  setCount(newValue) {\n    this.state.count = newValue;\n    console.log('[State] count =', this.state.count);\n  },\n  \n  increment() {\n    this.setCount(this.state.count + 1);\n  },\n  \n  decrement() {\n    this.setCount(this.state.count - 1);\n  },\n  \n  reset() {\n    this.setCount(0);\n  },\n  \n  getCount() {\n    return this.state.count;\n  }\n};\n\n// Test\nconsole.log('Initial count:', Counter.getCount());\n\nCounter.increment();\nCounter.increment();\nCounter.increment();\nCounter.decrement();\nCounter.reset();\n\nconsole.log('Final count:', Counter.getCount());",
              "solution": "// Complete state management simulation\n\nlet Counter = {\n  state: { count: 0 },\n  listeners: [],\n  \n  setCount(newValue) {\n    let oldValue = this.state.count;\n    this.state.count = newValue;\n    console.log(`[State Update] count: ${oldValue} → ${newValue}`);\n    console.log('[React] Re-rendering component...');\n    this.notifyListeners();\n  },\n  \n  increment() {\n    console.log('[Action] Increment');\n    this.setCount(this.state.count + 1);\n  },\n  \n  decrement() {\n    console.log('[Action] Decrement');\n    this.setCount(this.state.count - 1);\n  },\n  \n  incrementBy(amount) {\n    console.log(`[Action] Increment by ${amount}`);\n    this.setCount(this.state.count + amount);\n  },\n  \n  reset() {\n    console.log('[Action] Reset');\n    this.setCount(0);\n  },\n  \n  getCount() {\n    return this.state.count;\n  },\n  \n  // Subscribe to changes\n  onChange(callback) {\n    this.listeners.push(callback);\n  },\n  \n  notifyListeners() {\n    this.listeners.forEach(fn => fn(this.state.count));\n  },\n  \n  render() {\n    console.log('\\n[Render] Counter UI:');\n    console.log(`┌─────────────────┐`);\n    console.log(`│  Count: ${String(this.state.count).padEnd(6)} │`);\n    console.log(`├─────────────────┤`);\n    console.log(`│  [ - ] [ + ]    │`);\n    console.log(`│  [ Reset ]      │`);\n    console.log(`└─────────────────┘\\n`);\n  }\n};\n\n// Advanced: TodoList with state\nlet TodoList = {\n  state: {\n    todos: [],\n    nextId: 1\n  },\n  \n  setTodos(newTodos) {\n    this.state.todos = newTodos;\n    console.log('[State] todos updated:', newTodos.length, 'items');\n  },\n  \n  addTodo(text) {\n    console.log(`[Action] Add todo: \"${text}\"`);\n    let newTodo = {\n      id: this.state.nextId++,\n      text: text,\n      completed: false\n    };\n    // Must create NEW array (don't mutate!)\n    this.setTodos([...this.state.todos, newTodo]);\n  },\n  \n  toggleTodo(id) {\n    console.log(`[Action] Toggle todo ${id}`);\n    this.setTodos(\n      this.state.todos.map(todo =>\n        todo.id === id\n          ? { ...todo, completed: !todo.completed }  // New object\n          : todo\n      )\n    );\n  },\n  \n  deleteTodo(id) {\n    console.log(`[Action] Delete todo ${id}`);\n    this.setTodos(\n      this.state.todos.filter(todo => todo.id !== id)\n    );\n  },\n  \n  render() {\n    console.log('\\n[Render] Todo List:');\n    if (this.state.todos.length === 0) {\n      console.log('  No todos yet!');\n    } else {\n      this.state.todos.forEach(todo => {\n        let checkbox = todo.completed ? '[✓]' : '[ ]';\n        let text = todo.completed ? `(${todo.text})` : todo.text;\n        console.log(`  ${checkbox} ${text}`);\n      });\n    }\n    console.log('');\n  }\n};\n\n// Run simulations\nconsole.log('=== Counter Simulation ===\\n');\n\nCounter.render();\n\nconsole.log('User clicks +1 three times:');\nCounter.increment();\nCounter.increment();\nCounter.increment();\nCounter.render();\n\nconsole.log('User clicks -1:');\nCounter.decrement();\nCounter.render();\n\nconsole.log('User clicks reset:');\nCounter.reset();\nCounter.render();\n\nconsole.log('\\n=== TodoList Simulation ===\\n');\n\nTodoList.render();\n\nTodoList.addTodo('Learn useState');\nTodoList.addTodo('Build a counter app');\nTodoList.addTodo('Master React');\nTodoList.render();\n\nconsole.log('User completes first todo:');\nTodoList.toggleTodo(1);\nTodoList.render();\n\nconsole.log('User deletes second todo:');\nTodoList.deleteTodo(2);\nTodoList.render();\n\nconsole.log('=== Key Takeaways ===\\n');\nlet takeaways = [\n  '✓ useState gives components memory',\n  '✓ State updates trigger re-renders',\n  '✓ Never mutate state directly',\n  '✓ Always create new objects/arrays',\n  '✓ Use setCount(prev => prev + 1) for updates based on previous',\n  '✓ Can have multiple state variables',\n  '✓ Each state is independent'\n];\ntakeaways.forEach(t => console.log(t));",
              "hints": [
                "Use this.state.count to access current count, and this.setCount() to update it"
              ],
              "testCases": [
                {
                  "description": "Should increment count",
                  "input": "let count = 0; count = count + 1; count",
                  "expectedOutput": "1"
                },
                {
                  "description": "Should decrement count",
                  "input": "let count = 5; count = count - 1; count",
                  "expectedOutput": "4"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-12-12-4",
          "title": "Event Handling - Responding to User Actions (The Doorbell Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Event Handling - Responding to User Actions (The Doorbell Analogy)\n\n## Understanding the Concept\n\nImagine your house has a doorbell:\n\nPassive House (no doorbell):\n- Visitors knock\n- You don't hear them\n- Nothing happens\n- Frustrating for visitors!\n\nActive House (with doorbell):\n- Doorbell LISTENS for button press\n- Visitor presses button\n- Doorbell RESPONDS by ringing\n- You REACT by answering the door\n\nReact events work the same way:\n- Components LISTEN for events (onClick, onChange, etc.)\n- User performs action (click, type, submit)\n- Event handler RESPONDS\n- Component state updates → UI re-renders\n\nWithout event listeners → Your UI can't respond to users!\n\n## Code Example\n\n```javascript\n// React Event Handling\n\nconsole.log('=== Event Handling in React ===\\n');\n\n// CONCEPT: Event Listeners\nlet button = {\n  label: 'Click Me',\n  clickCount: 0,\n  \n  // Event handler function\n  handleClick: function() {\n    this.clickCount++;\n    console.log(`[Event] Button clicked! Total clicks: ${this.clickCount}`);\n  }\n};\n\n// Simulate user clicking button\nconsole.log('Button label:', button.label);\nconsole.log('\\nUser clicks button 3 times:\\n');\nbutton.handleClick();\nbutton.handleClick();\nbutton.handleClick();\n\n// COMMON EVENT TYPES\nconsole.log('\\n=== Common React Events ===\\n');\n\nlet events = {\n  'onClick': 'Button clicks, div clicks, any element click',\n  'onChange': 'Input field changes (text input, checkbox, select)',\n  'onSubmit': 'Form submission',\n  'onMouseEnter': 'Mouse cursor enters element',\n  'onMouseLeave': 'Mouse cursor leaves element',\n  'onKeyDown': 'Key pressed down',\n  'onKeyUp': 'Key released',\n  'onFocus': 'Element receives focus (clicked or tabbed to)',\n  'onBlur': 'Element loses focus'\n};\n\nfor (let [event, description] of Object.entries(events)) {\n  console.log(`${event.padEnd(15)} - ${description}`);\n}\n\n// REACT SYNTAX\nconsole.log('\\n\\n=== Event Handler Syntax ===\\n');\n\nconsole.log('// Method 1: Inline arrow function');\nconsole.log('<button onClick={() => console.log(\"Clicked!\")}>Click</button>\\n');\n\nconsole.log('// Method 2: Named function reference');\nconsole.log('function handleClick() {');\nconsole.log('  console.log(\"Clicked!\");');\nconsole.log('}');\nconsole.log('<button onClick={handleClick}>Click</button>\\n');\n\nconsole.log('// Method 3: With event object');\nconsole.log('function handleClick(event) {');\nconsole.log('  console.log(\"Button:\", event.target);');\nconsole.log('}');\nconsole.log('<button onClick={handleClick}>Click</button>\\n');\n\n// EVENT OBJECT\nconsole.log('=== The Event Object ===\\n');\n\nlet simulatedEvent = {\n  target: { tagName: 'BUTTON', textContent: 'Click Me', value: '' },\n  type: 'click',\n  preventDefault: function() {\n    console.log('[Event] Default action prevented');\n  },\n  stopPropagation: function() {\n    console.log('[Event] Event propagation stopped');\n  }\n};\n\nfunction handleEvent(event) {\n  console.log('Event type:', event.type);\n  console.log('Target element:', event.target.tagName);\n  console.log('Button text:', event.target.textContent);\n}\n\nconsole.log('Simulating click event:\\n');\nhandleEvent(simulatedEvent);\n\n// FORM HANDLING\nconsole.log('\\n\\n=== Form Event Handling ===\\n');\n\nlet form = {\n  state: { name: '', email: '' },\n  \n  handleNameChange: function(event) {\n    this.state.name = event.target.value;\n    console.log('[Input] Name:', this.state.name);\n  },\n  \n  handleEmailChange: function(event) {\n    this.state.email = event.target.value;\n    console.log('[Input] Email:', this.state.email);\n  },\n  \n  handleSubmit: function(event) {\n    event.preventDefault();\n    console.log('[Submit] Form data:', this.state);\n  }\n};\n\nconsole.log('User types in name field:');\nform.handleNameChange({ target: { value: 'Alice' } });\nform.handleNameChange({ target: { value: 'Alice J' } });\nform.handleNameChange({ target: { value: 'Alice Johnson' } });\n\nconsole.log('\\nUser types in email field:');\nform.handleEmailChange({ target: { value: 'alice@example.com' } });\n\nconsole.log('\\nUser submits form:');\nform.handleSubmit({ preventDefault: () => console.log('[Browser] Default submit prevented') });\n\n// REAL REACT EXAMPLE\nconsole.log('\\n\\n=== Complete React Example ===\\n');\n\nconsole.log('import { useState } from \"react\";\\n');\n\nconsole.log('function LoginForm() {');\nconsole.log('  const [email, setEmail] = useState(\"\");');\nconsole.log('  const [password, setPassword] = useState(\"\");\\n');\n\nconsole.log('  function handleSubmit(event) {');\nconsole.log('    event.preventDefault();  // Don\\'t reload page');\nconsole.log('    console.log(\"Login:\", email, password);');\nconsole.log('  }\\n');\n\nconsole.log('  return (');\nconsole.log('    <form onSubmit={handleSubmit}>');\nconsole.log('      <input');\nconsole.log('        type=\"email\"');\nconsole.log('        value={email}');\nconsole.log('        onChange={(e) => setEmail(e.target.value)}');\nconsole.log('      />');\nconsole.log('      <input');\nconsole.log('        type=\"password\"');\nconsole.log('        value={password}');\nconsole.log('        onChange={(e) => setPassword(e.target.value)}');\nconsole.log('      />');\nconsole.log('      <button type=\"submit\">Login</button>');\nconsole.log('    </form>');\nconsole.log('  );');\nconsole.log('}');\n\n// EVENT PATTERNS\nconsole.log('\\n\\n=== Common Event Patterns ===\\n');\n\nlet patterns = [\n  {    pattern: 'Button Click',\n    code: '<button onClick={handleClick}>Click</button>'\n  },\n  {\n    pattern: 'Input Change',\n    code: '<input onChange={(e) => setValue(e.target.value)} />'\n  },\n  {\n    pattern: 'Form Submit',\n    code: '<form onSubmit={handleSubmit}>...</form>'\n  },\n  {\n    pattern: 'Checkbox Toggle',\n    code: '<input type=\"checkbox\" onChange={(e) => setChecked(e.target.checked)} />'\n  },\n  {\n    pattern: 'Keyboard Event',\n    code: '<input onKeyDown={(e) => e.key === \"Enter\" && submit()} />'\n  },\n  {\n    pattern: 'Mouse Hover',\n    code: '<div onMouseEnter={handleEnter} onMouseLeave={handleLeave}>'\n  }\n];\n\npatterns.forEach(p => {\n  console.log(`${p.pattern}:`);\n  console.log(`  ${p.code}\\n`);\n});\n```\n\n## Breaking Down the Syntax\n\nEvent handling explained:\n\n1. **Basic onClick**:\n   ```jsx\n   function MyButton() {\n     function handleClick() {\n       console.log('Clicked!');\n     }\n     \n     return <button onClick={handleClick}>Click Me</button>;\n     //                      ^^^^^^^^^^^^\n     //                      Function REFERENCE (no parentheses!)\n   }\n   ```\n\n2. **Inline Arrow Function**:\n   ```jsx\n   <button onClick={() => console.log('Clicked!')}>Click</button>\n   \n   // With state update:\n   <button onClick={() => setCount(count + 1)}>+1</button>\n   ```\n\n3. **Event Object** (e or event):\n   ```jsx\n   function handleClick(event) {\n     console.log('Clicked element:', event.target);\n     console.log('Click position:', event.clientX, event.clientY);\n   }\n   \n   <button onClick={handleClick}>Click</button>\n   ```\n\n4. **Form Events** (onChange, onSubmit):\n   ```jsx\n   function Form() {\n     const [name, setName] = useState('');\n     \n     function handleSubmit(e) {\n       e.preventDefault();  // DON'T reload page!\n       console.log('Submitted:', name);\n     }\n     \n     return (\n       <form onSubmit={handleSubmit}>\n         <input\n           value={name}\n           onChange={(e) => setName(e.target.value)}\n           //                        ^^^^^^^^^^^^^\n           //                        Get input value\n         />\n         <button type=\"submit\">Submit</button>\n       </form>\n     );\n   }\n   ```\n\n5. **Passing Arguments** to event handlers:\n   ```jsx\n   // WRONG!\n   <button onClick={handleClick(id)}>  // Calls immediately!\n   \n   // CORRECT!\n   <button onClick={() => handleClick(id)}>  // Calls when clicked\n   <button onClick={handleClick.bind(null, id)}>  // Alternative\n   ```\n\n6. **Multiple Events**:\n   ```jsx\n   <div\n     onClick={handleClick}\n     onMouseEnter={handleEnter}\n     onMouseLeave={handleLeave}\n   >\n     Hover and click me!\n   </div>\n   ```\n\n7. **Controlled Inputs** (input value tied to state):\n   ```jsx\n   const [text, setText] = useState('');\n   \n   <input\n     value={text}              // Controlled by state\n     onChange={(e) => setText(e.target.value)}\n   />\n   ```\n\n8. **Checkbox Events**:\n   ```jsx\n   const [checked, setChecked] = useState(false);\n   \n   <input\n     type=\"checkbox\"\n     checked={checked}\n     onChange={(e) => setChecked(e.target.checked)}\n     //                            ^^^^^^^^^^^^^\n     //                            For checkboxes!\n   />\n   ```\n\n9. **Keyboard Events**:\n   ```jsx\n   function handleKeyDown(e) {\n     if (e.key === 'Enter') {\n       submit();\n     }\n     if (e.key === 'Escape') {\n       cancel();\n     }\n   }\n   \n   <input onKeyDown={handleKeyDown} />\n   ```\n\n10. **Prevent Default & Stop Propagation**:\n   ```jsx\n   function handleSubmit(e) {\n     e.preventDefault();     // Don't submit form\n     e.stopPropagation();    // Don't bubble up to parent\n     // Your code here\n   }\n   ```\n\n## Common Mistakes & Tips\n\nCommon event handling mistakes:\n\n1. **Calling function immediately instead of passing reference**:\n   ```jsx\n   // WRONG! (calls immediately on render)\n   <button onClick={handleClick()}>Click</button>\n   \n   // CORRECT! (passes function reference)\n   <button onClick={handleClick}>Click</button>\n   \n   // Or use arrow function:\n   <button onClick={() => handleClick()}>Click</button>\n   ```\n\n2. **Forgetting e.preventDefault() on forms**:\n   ```jsx\n   function handleSubmit(e) {\n     // WRONG! (page reloads)\n     console.log('Submitted');\n     \n     // CORRECT!\n     e.preventDefault();  // Stop page reload\n     console.log('Submitted');\n   }\n   ```\n\n3. **Wrong event property for inputs**:\n   ```jsx\n   // Text input\n   <input onChange={(e) => setValue(e.target.value)} />\n   //                                   ^^^^^ value for text\n   \n   // Checkbox\n   <input type=\"checkbox\" onChange={(e) => setChecked(e.target.checked)} />\n   //                                                   ^^^^^^^ checked for checkbox\n   ```\n\n4. **Not binding 'this' in class components**:\n   ```jsx\n   // Old class component issue (not relevant for function components)\n   class MyComponent extends React.Component {\n     handleClick() {\n       this.setState(...);  // 'this' is undefined!\n     }\n     \n     // Fix 1: Bind in constructor\n     constructor() {\n       this.handleClick = this.handleClick.bind(this);\n     }\n     \n     // Fix 2: Arrow function\n     handleClick = () => {\n       this.setState(...);\n     }\n   }\n   ```\n\n5. **Trying to pass arguments incorrectly**:\n   ```jsx\n   // WRONG!\n   <button onClick={handleClick(id)}>  // Calls immediately!\n   \n   // CORRECT!\n   <button onClick={() => handleClick(id)}>Delete</button>\n   \n   // Or:\n   <button onClick={handleClick.bind(null, id)}>Delete</button>\n   ```\n\n6. **Uncontrolled vs controlled inputs confusion**:\n   ```jsx\n   // Uncontrolled (React doesn't control value)\n   <input defaultValue=\"Initial\" />\n   \n   // Controlled (React controls value via state)\n   const [text, setText] = useState('Initial');\n   <input\n     value={text}                          // Must have value\n     onChange={(e) => setText(e.target.value)}  // Must have onChange\n   />\n   ```\n\n7. **Multiple handlers without arrow functions**:\n   ```jsx\n   // WRONG! (both call immediately)\n   <div\n     onMouseEnter={handleEnter()}\n     onMouseLeave={handleLeave()}\n   >\n   \n   // CORRECT!\n   <div\n     onMouseEnter={handleEnter}\n     onMouseLeave={handleLeave}\n   >\n   \n   // Or with arguments:\n   <div\n     onMouseEnter={() => handleEnter(id)}\n     onMouseLeave={() => handleLeave(id)}\n   >\n   ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create an interactive counter with event handling:\n\n1. Create a `CounterApp` object with:\n   - state: { count: 0, history: [] }\n   - handleIncrement() - increases count, adds to history\n   - handleDecrement() - decreases count, adds to history\n   - handleReset() - resets count to 0, clears history\n   - render() - displays current count and history\n\n2. Simulate user interactions and show the results",
              "starterCode": "// Interactive Counter App\n\nlet CounterApp = {\n  state: {\n    count: 0,\n    history: []\n  },\n  \n  handleIncrement() {\n    this.state.count++;\n    this.state.history.push('+1');\n    console.log('[Event] Increment → count:', this.state.count);\n  },\n  \n  handleDecrement() {\n    this.state.count--;\n    this.state.history.push('-1');\n    console.log('[Event] Decrement → count:', this.state.count);\n  },\n  \n  handleReset() {\n    this.state.count = 0;\n    this.state.history = [];\n    console.log('[Event] Reset → count:', this.state.count);\n  },\n  \n  render() {\n    console.log('\\n[Render]');\n    console.log('  Current Count:', this.state.count);\n    console.log('  History:', this.state.history.join(', ') || 'none');\n    console.log('');\n  }\n};\n\n// Simulate user interactions\nconsole.log('=== Counter App ===\\n');\n\nCounterApp.render();\n\nconsole.log('User clicks +1 button:');\nCounterApp.handleIncrement();\nCounterApp.render();\n\nconsole.log('User clicks +1 button again:');\nCounterApp.handleIncrement();\nCounterApp.render();\n\nconsole.log('User clicks -1 button:');\nCounterApp.handleDecrement();\nCounterApp.render();\n\nconsole.log('User clicks reset button:');\nCounterApp.handleReset();\nCounterApp.render();",
              "solution": "// Complete interactive app with event handling\n\nlet CounterApp = {\n  state: {\n    count: 0,\n    history: [],\n    lastAction: null\n  },\n  \n  handleIncrement() {\n    console.log('[Event] onClick={handleIncrement}');\n    this.state.count++;\n    this.state.history.push({ action: '+1', timestamp: Date.now() });\n    this.state.lastAction = 'increment';\n    this.render();\n  },\n  \n  handleDecrement() {\n    console.log('[Event] onClick={handleDecrement}');\n    this.state.count--;\n    this.state.history.push({ action: '-1', timestamp: Date.now() });\n    this.state.lastAction = 'decrement';\n    this.render();\n  },\n  \n  handleReset() {\n    console.log('[Event] onClick={handleReset}');\n    this.state.count = 0;\n    this.state.history = [];\n    this.state.lastAction = 'reset';\n    this.render();\n  },\n  \n  handleIncrementBy(amount) {\n    console.log(`[Event] onClick={() => handleIncrementBy(${amount})}`);\n    this.state.count += amount;\n    this.state.history.push({ action: `+${amount}`, timestamp: Date.now() });\n    this.render();\n  },\n  \n  render() {\n    console.log('\\n[React] Re-rendering component...');\n    console.log('┌────────────────────────────┐');\n    console.log(`│ Count: ${String(this.state.count).padEnd(19)} │`);\n    console.log('├────────────────────────────┤');\n    console.log('│ [ -1 ]  [ +1 ]  [ +5 ]     │');\n    console.log('│         [Reset]            │');\n    console.log('├────────────────────────────┤');\n    console.log(`│ Actions: ${String(this.state.history.length).padEnd(17)} │`);\n    if (this.state.history.length > 0) {\n      let recent = this.state.history.slice(-3).map(h => h.action).join(', ');\n      console.log(`│ Recent: ${recent.padEnd(18)} │`);\n    }\n    console.log('└────────────────────────────┘\\n');\n  }\n};\n\n// Form with event handling\nlet LoginForm = {\n  state: {\n    email: '',\n    password: '',\n    submitted: false,\n    errors: []\n  },\n  \n  handleEmailChange(event) {\n    console.log(`[Event] onChange={handleEmailChange}`);\n    this.state.email = event.target.value;\n    console.log(`  Email: \"${this.state.email}\"`);\n  },\n  \n  handlePasswordChange(event) {\n    console.log(`[Event] onChange={handlePasswordChange}`);\n    this.state.password = event.target.value;\n    console.log(`  Password: \"${'*'.repeat(this.state.password.length)}\"`);\n  },\n  \n  handleSubmit(event) {\n    console.log(`[Event] onSubmit={handleSubmit}`);\n    event.preventDefault();\n    \n    // Validation\n    this.state.errors = [];\n    if (!this.state.email.includes('@')) {\n      this.state.errors.push('Invalid email');\n    }\n    if (this.state.password.length < 6) {\n      this.state.errors.push('Password too short');\n    }\n    \n    if (this.state.errors.length === 0) {\n      this.state.submitted = true;\n      console.log('  ✓ Form valid! Logging in...');\n    } else {\n      console.log('  ✗ Form errors:', this.state.errors.join(', '));\n    }\n  },\n  \n  render() {\n    console.log('\\n[Render] Login Form');\n    console.log('  Email:', this.state.email || '(empty)');\n    console.log('  Password:', '*'.repeat(this.state.password.length) || '(empty)');\n    if (this.state.errors.length > 0) {\n      console.log('  Errors:', this.state.errors.join(', '));\n    }\n    if (this.state.submitted) {\n      console.log('  Status: ✓ Logged in!');\n    }\n    console.log('');\n  }\n};\n\n// Run simulations\nconsole.log('=== Counter App Simulation ===\\n');\n\nCounterApp.render();\n\nconsole.log('User clicks +1:');\nCounterApp.handleIncrement();\n\nconsole.log('User clicks +1 again:');\nCounterApp.handleIncrement();\n\nconsole.log('User clicks +5:');\nCounterApp.handleIncrementBy(5);\n\nconsole.log('User clicks -1:');\nCounterApp.handleDecrement();\n\nconsole.log('User clicks reset:');\nCounterApp.handleReset();\n\nconsole.log('\\n=== Login Form Simulation ===\\n');\n\nLoginForm.render();\n\nconsole.log('User types email:');\nLoginForm.handleEmailChange({ target: { value: 'a' } });\nLoginForm.handleEmailChange({ target: { value: 'al' } });\nLoginForm.handleEmailChange({ target: { value: 'alice@example.com' } });\nLoginForm.render();\n\nconsole.log('User types password:');\nLoginForm.handlePasswordChange({ target: { value: 'pass' } });\nLoginForm.render();\n\nconsole.log('User clicks submit (invalid):');\nLoginForm.handleSubmit({ preventDefault: () => {} });\nLoginForm.render();\n\nconsole.log('User fixes password:');\nLoginForm.handlePasswordChange({ target: { value: 'password123' } });\nLoginForm.render();\n\nconsole.log('User clicks submit (valid):');\nLoginForm.handleSubmit({ preventDefault: () => {} });\nLoginForm.render();\n\nconsole.log('=== Key Takeaways ===\\n');\nlet takeaways = [\n  '✓ Event handlers respond to user actions',\n  '✓ Use onClick, onChange, onSubmit, etc.',\n  '✓ Pass function reference, not call: onClick={handleClick}',\n  '✓ Access event with parameter: (e) => ...',\n  '✓ Use e.preventDefault() to prevent default behavior',\n  '✓ Controlled inputs: value={state} onChange={setState}',\n  '✓ Event updates state → state update triggers re-render'\n];\ntakeaways.forEach(t => console.log(t));",
              "hints": [
                "Update state in event handlers, then call render() to show changes"
              ],
              "testCases": [
                {
                  "description": "Should handle increment",
                  "input": "let count = 0; count++; count",
                  "expectedOutput": "1"
                },
                {
                  "description": "Should track history",
                  "input": "let history = []; history.push('+1'); history.length",
                  "expectedOutput": "1"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-12-12-5",
          "title": "Conditional Rendering - Showing Different UI Based on State (The Traffic Light Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Conditional Rendering - Showing Different UI Based on State (The Traffic Light Analogy)\n\n## Understanding the Concept\n\nThink of a traffic light at an intersection:\n\nStatic Display (no conditions):\n- Always shows green light\n- Never changes\n- Dangerous! Cars and pedestrians confused\n\nConditional Display (based on state):\n- If state = 'stop' → Show RED light\n- If state = 'caution' → Show YELLOW light\n- If state = 'go' → Show GREEN light\n- Changes based on current condition\n\nReact conditional rendering works the same:\n- Different UI based on state/props\n- Show login button if NOT logged in\n- Show profile if logged in\n- Show loading spinner while fetching\n- Show error message if failed\n\nOne component, many possible displays!\n\n## Code Example\n\n```javascript\n// Conditional Rendering in React\n\nconsole.log('=== Conditional Rendering ===\\n');\n\n// METHOD 1: if/else (outside JSX)\nfunction renderGreeting(isLoggedIn) {\n  if (isLoggedIn) {\n    return '<h1>Welcome back!</h1>';\n  } else {\n    return '<h1>Please log in.</h1>';\n  }\n}\n\nconsole.log('User logged in:');\nconsole.log(renderGreeting(true));\nconsole.log('\\nUser NOT logged in:');\nconsole.log(renderGreeting(false));\n\n// METHOD 2: Ternary operator (? :)\nfunction renderStatus(isOnline) {\n  return `<p>Status: ${isOnline ? 'Online' : 'Offline'}</p>`;\n}\n\nconsole.log('\\nTernary operator:');\nconsole.log(renderStatus(true));\nconsole.log(renderStatus(false));\n\n// METHOD 3: Logical AND (&&)\nfunction renderNotifications(hasNotifications, count) {\n  return `\n    <div>\n      <h2>Dashboard</h2>\n      ${hasNotifications && `<p>You have ${count} new notifications!</p>` || ''}\n    </div>\n  `;\n}\n\nconsole.log('\\nLogical AND (&&):');\nconsole.log(renderNotifications(true, 5));\nconsole.log(renderNotifications(false, 0));\n\n// REAL-WORLD EXAMPLE: Login/Logout Button\nlet app = {\n  state: { isLoggedIn: false, username: null },\n  \n  render() {\n    console.log('\\n[Render] App UI:\\n');\n    \n    if (this.state.isLoggedIn) {\n      console.log(`Welcome, ${this.state.username}!`);\n      console.log('[Logout Button]');\n    } else {\n      console.log('Welcome, Guest!');\n      console.log('[Login Button]');\n    }\n  },\n  \n  login(username) {\n    this.state.isLoggedIn = true;\n    this.state.username = username;\n    this.render();\n  },\n  \n  logout() {\n    this.state.isLoggedIn = false;\n    this.state.username = null;\n    this.render();\n  }\n};\n\nconsole.log('\\n=== Login/Logout Example ===');\napp.render();\n\nconsole.log('\\nUser clicks login:');\napp.login('Alice');\n\nconsole.log('\\nUser clicks logout:');\napp.logout();\n\n// LOADING STATES\nlet dataFetcher = {\n  state: { loading: true, data: null, error: null },\n  \n  render() {\n    console.log('\\n[Render] Data View:\\n');\n    \n    if (this.state.loading) {\n      console.log('⏳ Loading...');\n    } else if (this.state.error) {\n      console.log(`❌ Error: ${this.state.error}`);\n    } else if (this.state.data) {\n      console.log('✓ Data:', this.state.data);\n    } else {\n      console.log('No data yet.');\n    }\n  },\n  \n  async simulateFetch(shouldFail = false) {\n    this.state.loading = true;\n    this.state.error = null;\n    this.state.data = null;\n    this.render();\n    \n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    if (shouldFail) {\n      this.state.loading = false;\n      this.state.error = 'Network error';\n    } else {\n      this.state.loading = false;\n      this.state.data = { users: ['Alice', 'Bob', 'Charlie'] };\n    }\n    this.render();\n  }\n};\n\nconsole.log('\\n=== Loading State Example ===');\nsetTimeout(async () => {\n  dataFetcher.render();\n  \n  console.log('\\nFetching data (success):');\n  await dataFetcher.simulateFetch(false);\n  \n  console.log('\\nFetching data (failure):');\n  await dataFetcher.simulateFetch(true);\n}, 100);\n\n// CONDITIONAL CSS CLASSES\nsetTimeout(() => {\n  console.log('\\n\\n=== Conditional Styling ===\\n');\n  \n  function renderButton(isActive) {\n    let className = isActive ? 'btn-active' : 'btn-inactive';\n    let text = isActive ? 'Active' : 'Inactive';\n    return `<button class=\"${className}\">${text}</button>`;\n  }\n  \n  console.log('Active button:');\n  console.log(renderButton(true));\n  console.log('\\nInactive button:');\n  console.log(renderButton(false));\n  \n  // Multiple conditions\n  function renderAlert(type, message) {\n    let className = type === 'success' ? 'alert-success' :\n                    type === 'error' ? 'alert-error' :\n                    type === 'warning' ? 'alert-warning' :\n                    'alert-info';\n    \n    let icon = type === 'success' ? '✓' :\n               type === 'error' ? '✗' :\n               type === 'warning' ? '⚠' :\n               'ℹ';\n    \n    return `<div class=\"${className}\">${icon} ${message}</div>`;\n  }\n  \n  console.log('\\nConditional alerts:');\n  console.log(renderAlert('success', 'Saved successfully!'));\n  console.log(renderAlert('error', 'Failed to save!'));\n  console.log(renderAlert('warning', 'Are you sure?'));\n  console.log(renderAlert('info', 'New update available'));\n}, 1200);\n\n// LIST RENDERING WITH CONDITIONS\nsetTimeout(() => {\n  console.log('\\n\\n=== Conditional List Rendering ===\\n');\n  \n  let todos = [\n    { id: 1, text: 'Learn React', completed: true },\n    { id: 2, text: 'Build app', completed: false },\n    { id: 3, text: 'Deploy', completed: false }\n  ];\n  \n  console.log('All todos:');\n  todos.forEach(todo => {\n    let checkbox = todo.completed ? '[✓]' : '[ ]';\n    let style = todo.completed ? '(completed)' : '';\n    console.log(`${checkbox} ${todo.text} ${style}`);\n  });\n  \n  console.log('\\nCompleted only:');\n  todos.filter(todo => todo.completed).forEach(todo => {\n    console.log(`[✓] ${todo.text}`);\n  });\n  \n  console.log('\\nIncomplete only:');\n  todos.filter(todo => !todo.completed).forEach(todo => {\n    console.log(`[ ] ${todo.text}`);\n  });\n}, 1300);\n\n// REACT SYNTAX PATTERNS\nsetTimeout(() => {\n  console.log('\\n\\n=== React Conditional Rendering Patterns ===\\n');\n  \n  console.log('// Pattern 1: Ternary operator');\n  console.log('{isLoggedIn ? <Dashboard /> : <Login />}\\n');\n  \n  console.log('// Pattern 2: Logical AND (show/hide)');\n  console.log('{hasError && <ErrorMessage />}');\n  console.log('{count > 0 && <p>You have {count} items</p>}\\n');\n  \n  console.log('// Pattern 3: If/else (before return)');\n  console.log('if (loading) return <Spinner />;');\n  console.log('if (error) return <Error message={error} />;');\n  console.log('return <Data data={data} />;\\n');\n  \n  console.log('// Pattern 4: Switch for multiple conditions');\n  console.log('switch(status) {');\n  console.log('  case \"loading\": return <Spinner />;');\n  console.log('  case \"error\": return <Error />;');\n  console.log('  case \"success\": return <Data />;');\n  console.log('  default: return null;');\n  console.log('}\\n');\n  \n  console.log('// Pattern 5: Null for hiding');\n  console.log('{!shouldShow && null}  // Renders nothing');\n  console.log('{shouldShow ? <Component /> : null}');\n}, 1400);\n```\n\n## Breaking Down the Syntax\n\nConditional rendering patterns:\n\n1. **Ternary Operator** (? :):\n   ```jsx\n   function Greeting({ isLoggedIn }) {\n     return (\n       <div>\n         {isLoggedIn ? (\n           <h1>Welcome back!</h1>\n         ) : (\n           <h1>Please log in</h1>\n         )}\n       </div>\n     );\n   }\n   ```\n\n2. **Logical AND** (&&):\n   ```jsx\n   function Notifications({ count }) {\n     return (\n       <div>\n         <h2>Dashboard</h2>\n         {count > 0 && <p>You have {count} notifications</p>}\n       </div>\n     );\n   }\n   // Shows paragraph ONLY if count > 0\n   ```\n\n3. **Early Return**:\n   ```jsx\n   function UserProfile({ user }) {\n     if (!user) {\n       return <p>Loading...</p>;\n     }\n     \n     if (user.error) {\n       return <p>Error: {user.error}</p>;\n     }\n     \n     return (\n       <div>\n         <h1>{user.name}</h1>\n         <p>{user.email}</p>\n       </div>\n     );\n   }\n   ```\n\n4. **Variable Assignment**:\n   ```jsx\n   function Dashboard({ isLoggedIn }) {\n     let content;\n     \n     if (isLoggedIn) {\n       content = <UserDashboard />;\n     } else {\n       content = <LoginPrompt />;\n     }\n     \n     return <div>{content}</div>;\n   }\n   ```\n\n5. **Null for Hiding**:\n   ```jsx\n   function Alert({ message, show }) {\n     if (!show) return null;  // Render nothing\n     \n     return <div className=\"alert\">{message}</div>;\n   }\n   ```\n\n6. **Conditional CSS Classes**:\n   ```jsx\n   function Button({ isActive }) {\n     return (\n       <button className={isActive ? 'btn-active' : 'btn-inactive'}>\n         {isActive ? 'Active' : 'Inactive'}\n       </button>\n     );\n   }\n   ```\n\n7. **Multiple Conditions (Switch)**:\n   ```jsx\n   function StatusDisplay({ status }) {\n     switch(status) {\n       case 'loading':\n         return <Spinner />;\n       case 'error':\n         return <ErrorMessage />;\n       case 'success':\n         return <SuccessMessage />;\n       default:\n         return null;\n     }\n   }\n   ```\n\n8. **Conditional Props**:\n   ```jsx\n   <button\n     className={isActive ? 'active' : 'inactive'}\n     disabled={isLoading}\n     style={{ color: hasError ? 'red' : 'black' }}\n   >\n     {isLoading ? 'Loading...' : 'Submit'}\n   </button>\n   ```\n\n9. **List Filtering**:\n   ```jsx\n   function TodoList({ todos, filter }) {\n     const filteredTodos = filter === 'completed'\n       ? todos.filter(t => t.completed)\n       : filter === 'active'\n       ? todos.filter(t => !t.completed)\n       : todos;\n     \n     return (\n       <ul>\n         {filteredTodos.map(todo => <li key={todo.id}>{todo.text}</li>)}\n       </ul>\n     );\n   }\n   ```\n\n## Common Mistakes & Tips\n\nCommon conditional rendering mistakes:\n\n1. **Using if statement inside JSX**:\n   ```jsx\n   // WRONG! Can't use if in JSX\n   return (\n     <div>\n       {if (isLoggedIn) { <p>Welcome</p> }}  // Syntax error!\n     </div>\n   );\n   \n   // CORRECT! Use ternary\n   return (\n     <div>\n       {isLoggedIn ? <p>Welcome</p> : <p>Login</p>}\n     </div>\n   );\n   \n   // Or if/else before return:\n   if (isLoggedIn) {\n     return <div><p>Welcome</p></div>;\n   }\n   return <div><p>Login</p></div>;\n   ```\n\n2. **Wrong use of && operator**:\n   ```jsx\n   // WRONG! Renders \"0\" when count is 0\n   {count && <p>You have {count} items</p>}\n   \n   // CORRECT! Use explicit boolean\n   {count > 0 && <p>You have {count} items</p>}\n   ```\n\n3. **Forgetting the else in ternary**:\n   ```jsx\n   // WRONG!\n   {isLoggedIn ? <Dashboard /> }  // Syntax error!\n   \n   // CORRECT!\n   {isLoggedIn ? <Dashboard /> : null}\n   {isLoggedIn ? <Dashboard /> : <Login />}\n   \n   // Or use &&:\n   {isLoggedIn && <Dashboard />}\n   ```\n\n4. **Nested ternaries (hard to read)**:\n   ```jsx\n   // WRONG! (too complex)\n   {isLoading ? <Spinner /> : hasError ? <Error /> : hasData ? <Data /> : <Empty />}\n   \n   // BETTER! Use if/else before return\n   if (isLoading) return <Spinner />;\n   if (hasError) return <Error />;\n   if (hasData) return <Data />;\n   return <Empty />;\n   ```\n\n5. **Rendering undefined or false**:\n   ```jsx\n   // WRONG! Renders \"false\" or \"undefined\" as text\n   <div>{isLoggedIn}</div>  // Renders \"true\" or \"false\"\n   <div>{userData}</div>    // Might render \"undefined\"\n   \n   // CORRECT!\n   <div>{isLoggedIn ? 'Yes' : 'No'}</div>\n   <div>{userData?.name || 'N/A'}</div>\n   ```\n\n6. **String conditions** (always truthy!):\n   ```jsx\n   // WRONG! String \"false\" is truthy!\n   const showBanner = \"false\";  // String, not boolean\n   {showBanner && <Banner />}   // Always shows!\n   \n   // CORRECT!\n   const showBanner = false;    // Boolean\n   {showBanner && <Banner />}   // Works correctly\n   ```\n\n7. **Not handling all states** (loading, error, data):\n   ```jsx\n   // WRONG! Missing loading and error states\n   function UserProfile({ user }) {\n     return <div>{user.name}</div>;  // Crashes if user is null!\n   }\n   \n   // CORRECT!\n   function UserProfile({ user, loading, error }) {\n     if (loading) return <Spinner />;\n     if (error) return <Error message={error} />;\n     if (!user) return <p>No user found</p>;\n     return <div>{user.name}</div>;\n   }\n   ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a user authentication UI with conditional rendering:\n\n1. Create an `AuthApp` object with:\n   - state: { isLoggedIn: false, user: null, loading: false }\n   - login(username) method\n   - logout() method\n   - render() method that shows different UI based on state\n\n2. Show:\n   - Loading message when loading = true\n   - Login button when not logged in\n   - Welcome message + Logout button when logged in\n\n3. Test all states",
              "starterCode": "// Authentication App with Conditional Rendering\n\nlet AuthApp = {\n  state: {\n    isLoggedIn: false,\n    user: null,\n    loading: false\n  },\n  \n  render() {\n    console.log('\\n[Render] Auth UI:');\n    console.log('─'.repeat(40));\n    \n    if (this.state.loading) {\n      console.log('⏳ Loading...');\n    } else if (this.state.isLoggedIn) {\n      console.log(`Welcome, ${this.state.user}!`);\n      console.log('[Logout Button]');\n    } else {\n      console.log('Please log in to continue');\n      console.log('[Login Button]');\n    }\n    \n    console.log('─'.repeat(40) + '\\n');\n  },\n  \n  async login(username) {\n    console.log(`[Action] Login as ${username}`);\n    this.state.loading = true;\n    this.render();\n    \n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    this.state.loading = false;\n    this.state.isLoggedIn = true;\n    this.state.user = username;\n    this.render();\n  },\n  \n  logout() {\n    console.log('[Action] Logout');\n    this.state.isLoggedIn = false;\n    this.state.user = null;\n    this.render();\n  }\n};\n\n// Test all states\nasync function testAuthApp() {\n  console.log('=== Auth App Test ===');\n  \n  AuthApp.render();\n  \n  await AuthApp.login('Alice');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  AuthApp.logout();\n}\n\ntestAuthApp();",
              "solution": "// Complete solution with all conditional rendering patterns\n\nlet AuthApp = {\n  state: {\n    isLoggedIn: false,\n    user: null,\n    loading: false,\n    error: null\n  },\n  \n  render() {\n    console.log('\\n┌────────────────────────────────────────┐');\n    console.log('│          Authentication App            │');\n    console.log('├────────────────────────────────────────┤');\n    \n    // Loading state\n    if (this.state.loading) {\n      console.log('│  ⏳ Loading...                         │');\n      console.log('└────────────────────────────────────────┘\\n');\n      return;\n    }\n    \n    // Error state\n    if (this.state.error) {\n      console.log(`│  ❌ Error: ${this.state.error.padEnd(25)} │`);\n      console.log('│  [Try Again]                           │');\n      console.log('└────────────────────────────────────────┘\\n');\n      return;\n    }\n    \n    // Logged in state\n    if (this.state.isLoggedIn) {\n      console.log(`│  Welcome, ${this.state.user}! ${' '.repeat(26 - this.state.user.length)} │`);\n      console.log('│  ─────────────────────────────────────│');\n      console.log('│  Dashboard                             │');\n      console.log('│  Profile                               │');\n      console.log('│  Settings                              │');\n      console.log('│  ─────────────────────────────────────│');\n      console.log('│  [Logout]                              │');\n    } else {\n      // Logged out state\n      console.log('│  Please log in to continue            │');\n      console.log('│  ─────────────────────────────────────│');\n      console.log('│  [Login]                               │');\n      console.log('│  [Sign Up]                             │');\n    }\n    \n    console.log('└────────────────────────────────────────┘\\n');\n  },\n  \n  async login(username, password) {\n    console.log(`[Action] Login as \"${username}\"`);\n    this.state.loading = true;\n    this.state.error = null;\n    this.render();\n    \n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 800));\n    \n    // Simulate authentication\n    if (password === 'wrong') {\n      this.state.loading = false;\n      this.state.error = 'Invalid credentials';\n      this.render();\n      return;\n    }\n    \n    this.state.loading = false;\n    this.state.isLoggedIn = true;\n    this.state.user = username;\n    this.render();\n  },\n  \n  logout() {\n    console.log('[Action] Logout');\n    this.state.isLoggedIn = false;\n    this.state.user = null;\n    this.state.error = null;\n    this.render();\n  }\n};\n\n// Todo List with conditional rendering\nlet TodoApp = {\n  state: {\n    todos: [\n      { id: 1, text: 'Learn conditional rendering', completed: true },\n      { id: 2, text: 'Build a todo app', completed: false },\n      { id: 3, text: 'Master React', completed: false }\n    ],\n    filter: 'all'  // 'all', 'active', 'completed'\n  },\n  \n  render() {\n    console.log('\\n┌────────────────────────────────────────┐');\n    console.log('│             Todo List                  │');\n    console.log('├────────────────────────────────────────┤');\n    \n    // Filter todos based on current filter\n    let filteredTodos;\n    if (this.state.filter === 'completed') {\n      filteredTodos = this.state.todos.filter(t => t.completed);\n    } else if (this.state.filter === 'active') {\n      filteredTodos = this.state.todos.filter(t => !t.completed);\n    } else {\n      filteredTodos = this.state.todos;\n    }\n    \n    // Empty state\n    if (filteredTodos.length === 0) {\n      console.log('│  No todos to show                      │');\n    } else {\n      filteredTodos.forEach(todo => {\n        let checkbox = todo.completed ? '[✓]' : '[ ]';\n        let text = todo.completed ? `${todo.text} (done)` : todo.text;\n        let line = `│  ${checkbox} ${text}`.padEnd(41) + '│';\n        console.log(line);\n      });\n    }\n    \n    console.log('├────────────────────────────────────────┤');\n    \n    // Filter buttons with active state\n    let allActive = this.state.filter === 'all' ? '*' : ' ';\n    let activeActive = this.state.filter === 'active' ? '*' : ' ';\n    let completedActive = this.state.filter === 'completed' ? '*' : ' ';\n    \n    console.log(`│  [${allActive}]All [${activeActive}]Active [${completedActive}]Completed      │`);\n    console.log('└────────────────────────────────────────┘\\n');\n  },\n  \n  setFilter(filter) {\n    console.log(`[Action] Set filter: ${filter}`);\n    this.state.filter = filter;\n    this.render();\n  }\n};\n\n// Run demonstrations\nasync function runDemo() {\n  console.log('=== Authentication Demo ===\\n');\n  \n  AuthApp.render();\n  \n  console.log('User attempts login with wrong password:');\n  await AuthApp.login('Alice', 'wrong');\n  \n  await new Promise(resolve => setTimeout(resolve, 1000));\n  \n  console.log('User attempts login with correct password:');\n  await AuthApp.login('Alice', 'correct');\n  \n  await new Promise(resolve => setTimeout(resolve, 1000));\n  \n  console.log('User logs out:');\n  AuthApp.logout();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  console.log('\\n=== Todo List Demo ===\\n');\n  \n  TodoApp.render();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  console.log('Show only active todos:');\n  TodoApp.setFilter('active');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  console.log('Show only completed todos:');\n  TodoApp.setFilter('completed');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  console.log('Show all todos:');\n  TodoApp.setFilter('all');\n}\n\nrunDemo();",
              "hints": [
                "Use if/else in render() to show different UI based on state"
              ],
              "testCases": [
                {
                  "description": "Should show different UI when logged in",
                  "input": "let isLoggedIn = true; isLoggedIn ? 'Welcome' : 'Login'",
                  "expectedOutput": "Welcome"
                },
                {
                  "description": "Should show login when logged out",
                  "input": "let isLoggedIn = false; isLoggedIn ? 'Welcome' : 'Login'",
                  "expectedOutput": "Login"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-12-12-6",
          "title": "useEffect Hook - Side Effects & Component Lifecycle (The Security Guard Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# useEffect Hook - Side Effects & Component Lifecycle (The Security Guard Analogy)\n\n## Understanding the Concept\n\nImagine a security guard at a building entrance:\n\nWithout security guard:\n- People come and go\n- No one tracks entrances/exits\n- No one locks doors at night\n- No cleanup when building closes\n\nWith security guard (useEffect):\n- WHEN people arrive (component mounts) → Check them in\n- WHEN visitor badge expires (dependency changes) → Issue new badge\n- WHEN building closes (component unmounts) → Lock doors, cleanup\n- Guard watches specific things (dependencies)\n- Guard performs actions automatically\n\nReact useEffect is your component's security guard:\n- Runs code AFTER render (side effects)\n- Runs when component mounts\n- Runs when specific values change\n- Cleanup when component unmounts\n- Perfect for: API calls, timers, subscriptions, document title changes!\n\n## Code Example\n\n```javascript\n// useEffect Hook - Side Effects\n\nconsole.log('=== useEffect Hook ===\\n');\n\n// SIDE EFFECT = Code that affects something outside the component\n// Examples: API calls, timers, DOM manipulation, subscriptions\n\n// Simulating component lifecycle\nclass Component {\n  constructor(name) {\n    this.name = name;\n    this.effects = [];\n    this.mounted = false;\n  }\n  \n  useEffect(effect, dependencies) {\n    this.effects.push({ effect, dependencies });\n  }\n  \n  mount() {\n    console.log(`[${this.name}] Mounting...`);\n    this.mounted = true;\n    \n    // Run all effects\n    this.effects.forEach(({ effect, dependencies }) => {\n      console.log(`[${this.name}] Running effect (dependencies: ${dependencies || 'none'})`);\n      let cleanup = effect();\n      if (cleanup) {\n        console.log(`[${this.name}] Effect registered cleanup function`);\n      }\n    });\n  }\n  \n  unmount() {\n    console.log(`\\n[${this.name}] Unmounting...`);\n    console.log(`[${this.name}] Running cleanup functions`);\n    this.mounted = false;\n  }\n}\n\n// Example 1: Effect runs once on mount\nlet TitleComponent = new Component('TitleComponent');\n\nTitleComponent.useEffect(() => {\n  console.log('  Setting document title to: \"My React App\"');\n  // In real React: document.title = 'My React App';\n}, []); // Empty array = run once on mount\n\nTitleComponent.mount();\n\n// Example 2: Effect with cleanup\nconsole.log('\\n--- Timer Component ---');\nlet TimerComponent = new Component('TimerComponent');\n\nTimerComponent.useEffect(() => {\n  console.log('  Starting timer (setInterval)');\n  let intervalId = 123;\n  \n  // Cleanup function (returned)\n  return () => {\n    console.log('  Stopping timer (clearInterval)');\n  };\n}, []);\n\nTimerComponent.mount();\nsetTimeout(() => TimerComponent.unmount(), 1000);\n\n// Example 3: Effect runs when dependency changes\nsetTimeout(() => {\n  console.log('\\n--- User Profile Component ---');\n  \n  let ProfileComponent = new Component('ProfileComponent');\n  let userId = 1;\n  \n  ProfileComponent.useEffect(() => {\n    console.log(`  Fetching data for user ${userId}...`);\n    console.log(`  fetch('/api/users/${userId}')`);\n  }, [userId]); // Re-run when userId changes\n  \n  ProfileComponent.mount();\n  \n  // Simulate prop change\n  setTimeout(() => {\n    console.log('\\n[Props Changed] userId: 1 → 2');\n    userId = 2;\n    console.log('[ProfileComponent] Re-running effects with new userId');\n    console.log(`  Fetching data for user ${userId}...`);\n  }, 500);\n}, 1500);\n\n// DEPENDENCY ARRAY PATTERNS\nsetTimeout(() => {\n  console.log('\\n\\n=== useEffect Dependency Patterns ===\\n');\n  \n  let patterns = [\n    {\n      code: 'useEffect(() => { ... });',\n      deps: 'NO array',\n      runs: 'Every render (usually a mistake!)'\n    },\n    {\n      code: 'useEffect(() => { ... }, []);',\n      deps: 'Empty []',\n      runs: 'Once on mount only'\n    },\n    {\n      code: 'useEffect(() => { ... }, [count]);',\n      deps: '[count]',\n      runs: 'On mount + when count changes'\n    },\n    {\n      code: 'useEffect(() => { ... }, [a, b, c]);',\n      deps: '[a, b, c]',\n      runs: 'On mount + when a, b, OR c changes'\n    }\n  ];\n  \n  patterns.forEach(p => {\n    console.log(`${p.code}`);\n    console.log(`  Dependencies: ${p.deps}`);\n    console.log(`  Runs: ${p.runs}\\n`);\n  });\n}, 2500);\n\n// COMMON USE CASES\nsetTimeout(() => {\n  console.log('=== Common useEffect Use Cases ===\\n');\n  \n  console.log('1. FETCHING DATA:');\n  console.log('useEffect(() => {');\n  console.log('  fetch(\"/api/users\")');\n  console.log('    .then(res => res.json())');\n  console.log('    .then(data => setUsers(data));');\n  console.log('}, []); // Fetch once on mount\\n');\n  \n  console.log('2. SETTING DOCUMENT TITLE:');\n  console.log('useEffect(() => {');\n  console.log('  document.title = `Count: ${count}`;');\n  console.log('}, [count]); // Update when count changes\\n');\n  \n  console.log('3. SUBSCRIBING TO EVENTS:');\n  console.log('useEffect(() => {');\n  console.log('  function handleResize() {');\n  console.log('    setWidth(window.innerWidth);');\n  console.log('  }');\n  console.log('  ');\n  console.log('  window.addEventListener(\"resize\", handleResize);');\n  console.log('  ');\n  console.log('  return () => {  // Cleanup!');\n  console.log('    window.removeEventListener(\"resize\", handleResize);');\n  console.log('  };');\n  console.log('}, []); // Set up once\\n');\n  \n  console.log('4. TIMERS:');\n  console.log('useEffect(() => {');\n  console.log('  const timer = setInterval(() => {');\n  console.log('    setCount(c => c + 1);');\n  console.log('  }, 1000);');\n  console.log('  ');\n  console.log('  return () => clearInterval(timer); // Cleanup!');\n  console.log('}, []); // Start timer once\\n');\n  \n  console.log('5. LOCAL STORAGE:');\n  console.log('useEffect(() => {');\n  console.log('  localStorage.setItem(\"theme\", theme);');\n  console.log('}, [theme]); // Save when theme changes');\n}, 2600);\n```\n\n## Breaking Down the Syntax\n\nuseEffect Hook explained:\n\n1. **Basic useEffect** (runs after every render):\n   ```jsx\n   import { useEffect } from 'react';\n   \n   function MyComponent() {\n     useEffect(() => {\n       console.log('Component rendered!');\n     });\n     // NO dependency array = runs after EVERY render\n   }\n   ```\n\n2. **Run once on mount** (empty dependency array):\n   ```jsx\n   useEffect(() => {\n     console.log('Component mounted!');\n   }, []);  // Empty array = run ONCE on mount\n   ```\n\n3. **Run when specific values change**:\n   ```jsx\n   useEffect(() => {\n     console.log('Count changed:', count);\n   }, [count]);  // Runs when count changes\n   ```\n\n4. **Cleanup function** (returned from effect):\n   ```jsx\n   useEffect(() => {\n     // Setup\n     const timer = setInterval(() => {\n       console.log('Tick');\n     }, 1000);\n     \n     // Cleanup (runs before next effect OR on unmount)\n     return () => {\n       clearInterval(timer);\n       console.log('Timer cleaned up');\n     };\n   }, []);\n   ```\n\n5. **Fetching data**:\n   ```jsx\n   useEffect(() => {\n     async function fetchData() {\n       const res = await fetch('/api/users');\n       const data = await res.json();\n       setUsers(data);\n     }\n     \n     fetchData();\n   }, []);  // Fetch once on mount\n   ```\n\n6. **Multiple dependencies**:\n   ```jsx\n   useEffect(() => {\n     // Runs when userId OR filter changes\n     fetchUserPosts(userId, filter);\n   }, [userId, filter]);\n   ```\n\n7. **Event listeners**:\n   ```jsx\n   useEffect(() => {\n     function handleScroll() {\n       setScrollY(window.scrollY);\n     }\n     \n     window.addEventListener('scroll', handleScroll);\n     \n     return () => {\n       window.removeEventListener('scroll', handleScroll);\n     };\n   }, []);\n   ```\n\n8. **Local Storage**:\n   ```jsx\n   useEffect(() => {\n     localStorage.setItem('user', JSON.stringify(user));\n   }, [user]);  // Save when user changes\n   ```\n\n9. **Document Title**:\n   ```jsx\n   useEffect(() => {\n     document.title = `Messages (${unreadCount})`;\n   }, [unreadCount]);\n   ```\n\n10. **Conditional Effect**:\n   ```jsx\n   useEffect(() => {\n     if (isLoggedIn) {\n       // Only run if logged in\n       connectToChat();\n       \n       return () => disconnectFromChat();\n     }\n   }, [isLoggedIn]);\n   ```\n\n## Common Mistakes & Tips\n\nCommon useEffect mistakes:\n\n1. **Forgetting dependency array**:\n   ```jsx\n   // WRONG! Runs after EVERY render\n   useEffect(() => {\n     fetchData();  // Infinite loop if it updates state!\n   });\n   \n   // CORRECT!\n   useEffect(() => {\n     fetchData();\n   }, []);  // Run once on mount\n   ```\n\n2. **Using async directly in useEffect**:\n   ```jsx\n   // WRONG!\n   useEffect(async () => {  // Can't make effect async!\n     const data = await fetch('/api/users');\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     async function fetchData() {\n       const data = await fetch('/api/users');\n     }\n     fetchData();\n   }, []);\n   ```\n\n3. **Missing dependencies**:\n   ```jsx\n   // WRONG! (missing 'count' in dependencies)\n   useEffect(() => {\n     console.log('Count is:', count);\n   }, []);  // Should include [count]!\n   \n   // CORRECT!\n   useEffect(() => {\n     console.log('Count is:', count);\n   }, [count]);  // Re-run when count changes\n   ```\n\n4. **Not cleaning up**:\n   ```jsx\n   // WRONG! (memory leak)\n   useEffect(() => {\n     const timer = setInterval(() => setCount(c => c + 1), 1000);\n     // No cleanup!\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     const timer = setInterval(() => setCount(c => c + 1), 1000);\n     return () => clearInterval(timer);  // Cleanup!\n   }, []);\n   ```\n\n5. **Infinite loops**:\n   ```jsx\n   // WRONG! Infinite loop\n   useEffect(() => {\n     setCount(count + 1);  // Updates state → re-render → effect runs → updates state...\n   }, [count]);  // Depends on count!\n   \n   // CORRECT! (if you really need this pattern)\n   useEffect(() => {\n     if (count < 10) {  // Add condition\n       setCount(count + 1);\n     }\n   }, [count]);\n   ```\n\n6. **Stale closures**:\n   ```jsx\n   // WRONG! (captures old 'count')\n   useEffect(() => {\n     const timer = setInterval(() => {\n       setCount(count + 1);  // Always uses initial count!\n     }, 1000);\n     return () => clearInterval(timer);\n   }, []);  // Empty deps = count never updates\n   \n   // CORRECT!\n   useEffect(() => {\n     const timer = setInterval(() => {\n       setCount(c => c + 1);  // Use functional update\n     }, 1000);\n     return () => clearInterval(timer);\n   }, []);  // No dependency on count needed\n   ```\n\n7. **Multiple effects for unrelated logic** (good practice!):\n   ```jsx\n   // WRONG! (mixing concerns)\n   useEffect(() => {\n     fetchUsers();  // Unrelated\n     document.title = 'Users';  // to\n     window.addEventListener('resize', handleResize);  // each other\n   }, []);\n   \n   // CORRECT! (separate effects)\n   useEffect(() => {\n     fetchUsers();\n   }, []);\n   \n   useEffect(() => {\n     document.title = 'Users';\n   }, []);\n   \n   useEffect(() => {\n     window.addEventListener('resize', handleResize);\n     return () => window.removeEventListener('resize', handleResize);\n   }, []);\n   ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a clock component with useEffect:\n\n1. Create a `ClockComponent` object with:\n   - state: { time: current time string }\n   - mount() - simulates component mounting\n   - unmount() - simulates component unmounting\n   - Use effect to update time every second\n   - Cleanup timer on unmount\n\n2. Test by mounting, waiting 3 seconds, then unmounting",
              "starterCode": "// Clock Component with useEffect\n\nlet ClockComponent = {\n  state: { time: new Date().toLocaleTimeString() },\n  timerId: null,\n  \n  mount() {\n    console.log('[Clock] Mounting...');\n    console.log('[Clock] useEffect(() => { ... }, [])');\n    \n    // Effect: Start timer\n    this.timerId = setInterval(() => {\n      this.state.time = new Date().toLocaleTimeString();\n      console.log('[Clock] Tick:', this.state.time);\n    }, 1000);\n    \n    console.log('[Clock] Timer started (ID:', this.timerId, ')');\n    console.log('[Clock] Registered cleanup function\\n');\n  },\n  \n  unmount() {\n    console.log('\\n[Clock] Unmounting...');\n    console.log('[Clock] Running cleanup function');\n    \n    // Cleanup: Stop timer\n    if (this.timerId) {\n      clearInterval(this.timerId);\n      console.log('[Clock] Timer stopped');\n    }\n  }\n};\n\n// Test\nasync function testClock() {\n  console.log('=== Clock Component Test ===\\n');\n  \n  ClockComponent.mount();\n  \n  // Wait 3 seconds\n  await new Promise(resolve => setTimeout(resolve, 3000));\n  \n  ClockComponent.unmount();\n}\n\ntestClock();",
              "solution": "// Complete useEffect simulation\n\nlet ClockComponent = {\n  state: { time: new Date().toLocaleTimeString(), ticks: 0 },\n  timerId: null,\n  mounted: false,\n  \n  mount() {\n    console.log('┌────────────────────────────────┐');\n    console.log('│     Clock Component Mount      │');\n    console.log('└────────────────────────────────┘\\n');\n    \n    this.mounted = true;\n    \n    console.log('[useEffect] Starting side effects...');\n    console.log('[Effect 1] Setting document title');\n    // document.title = 'Clock App';\n    \n    console.log('[Effect 2] Starting interval timer\\n');\n    this.timerId = setInterval(() => {\n      if (this.mounted) {\n        this.state.time = new Date().toLocaleTimeString();\n        this.state.ticks++;\n        console.log(`⏰ ${this.state.time} (tick #${this.state.ticks})`);\n      }\n    }, 1000);\n    \n    console.log(`✓ Timer ID: ${this.timerId}`);\n    console.log('✓ Cleanup function registered\\n');\n  },\n  \n  unmount() {\n    console.log('\\n┌────────────────────────────────┐');\n    console.log('│    Clock Component Unmount     │');\n    console.log('└────────────────────────────────┘\\n');\n    \n    this.mounted = false;\n    \n    console.log('[Cleanup] Running effect cleanup...');\n    \n    if (this.timerId) {\n      clearInterval(this.timerId);\n      console.log(`✓ Timer ${this.timerId} cleared`);\n      this.timerId = null;\n    }\n    \n    console.log(`✓ Total ticks: ${this.state.ticks}`);\n    console.log('✓ Component unmounted cleanly\\n');\n  }\n};\n\n// Fetch component with cleanup\nlet DataFetcher = {\n  state: { data: null, loading: false },\n  controller: null,\n  \n  async mount(userId) {\n    console.log('┌────────────────────────────────┐');\n    console.log('│   DataFetcher Mount (user:${userId})   │'.replace('${userId}', userId));\n    console.log('└────────────────────────────────┘\\n');\n    \n    console.log('[useEffect] Running with [userId] dependency');\n    console.log(`  userId = ${userId}\\n`);\n    \n    // Simulate AbortController for fetch cancellation\n    this.controller = { aborted: false };\n    \n    this.state.loading = true;\n    console.log('[Fetch] Starting request...');\n    \n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    if (!this.controller.aborted) {\n      this.state.data = { id: userId, name: `User ${userId}` };\n      this.state.loading = false;\n      console.log('[Fetch] Success:', this.state.data);\n    } else {\n      console.log('[Fetch] Aborted');\n    }\n    \n    console.log('\\n✓ Cleanup function registered');\n  },\n  \n  unmount() {\n    console.log('\\n[Cleanup] Aborting fetch if in progress...');\n    if (this.controller) {\n      this.controller.aborted = true;\n      console.log('✓ Fetch aborted');\n    }\n  }\n};\n\n// Run demonstrations\nasync function runDemo() {\n  console.log('═══ useEffect Demo ═══\\n');\n  \n  // Demo 1: Clock\n  console.log('DEMO 1: Clock with Timer\\n');\n  ClockComponent.mount();\n  \n  await new Promise(resolve => setTimeout(resolve, 3500));\n  \n  ClockComponent.unmount();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // Demo 2: Data fetching\n  console.log('\\nDEMO 2: Data Fetching with Cleanup\\n');\n  console.log('Fetching user 1...');\n  let fetch1 = DataFetcher.mount(1);\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  console.log('\\n[Props Change] userId: 1 → 2');\n  console.log('Cleaning up old effect...');\n  DataFetcher.unmount();\n  \n  console.log('\\nFetching user 2...');\n  await DataFetcher.mount(2);\n  \n  console.log('\\n\\n=== useEffect Best Practices ===\\n');\n  let practices = [\n    '✓ Always include dependency array ([], [dep], etc.)',\n    '✓ Return cleanup function when needed',\n    '✓ Don\\'t call async functions directly in useEffect',\n    '✓ Clean up timers, subscriptions, event listeners',\n    '✓ Use separate useEffect for unrelated logic',\n    '✓ Put all dependencies in the array',\n    '✓ Cleanup prevents memory leaks'\n  ];\n  \n  practices.forEach(p => console.log(p));\n}\n\nrunDemo();",
              "hints": [
                "Use setInterval in mount(), clearInterval in unmount()"
              ],
              "testCases": [
                {
                  "description": "Should set up interval",
                  "input": "let id = setInterval(() => {}, 1000); typeof id",
                  "expectedOutput": "number"
                },
                {
                  "description": "Should clean up interval",
                  "input": "let id = setInterval(() => {}, 1000); clearInterval(id); 'cleaned'",
                  "expectedOutput": "cleaned"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "module-13",
      "title": "Module 13: Full-Stack Integration - Connecting Front-End & Back-End",
      "description": "Build complete full-stack applications by connecting React front-ends with Node.js/Express backends and Prisma databases",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-13-13-1",
          "title": "Full-Stack Architecture (The Restaurant Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Full-Stack Architecture (The Restaurant Analogy)\n\n## Understanding the Concept\n\nA restaurant has three main areas:\n\nDining Room (Front-End - React):\n- Where customers sit and interact\n- Beautiful presentation, easy to use\n- Menus, ordering interface, displays\n\nKitchen (Back-End - Node.js/Express):\n- Where the real work happens\n- Receives orders, processes them\n- Business logic, data processing\n\nStorage Room (Database - Prisma/PostgreSQL):\n- Where ingredients are stored\n- Organized, persistent, reliable\n- Data that survives shutdowns\n\nWaiter (API):\n- Carries messages between dining room and kitchen\n- Takes orders from customers to chefs\n- Brings food from kitchen to customers\n\nFull-stack development means building ALL THREE parts and making them work together seamlessly!\n\n## Code Example\n\n```javascript\n// Full-Stack Architecture Overview (MERN/PERN Stack)\n\n// FRONTEND (React) - What users see\nlet frontEnd = {\n  technology: 'React 19',\n  responsibilities: [\n    'User interface (buttons, forms, displays)',\n    'User interactions (clicks, typing)',\n    'API calls to backend',\n    'Display data from backend'\n  ],\n  example: 'Login form, dashboard, user profile page'\n};\n\nconsole.log('Frontend:', frontEnd);\n\n// BACKEND (Node.js + Express) - Business logic\nlet backEnd = {\n  technology: 'Node.js 24 + Express 5.1',\n  responsibilities: [\n    'API endpoints (routes)',\n    'Authentication & authorization',\n    'Business logic (validation, calculations)',\n    'Database operations',\n    'Security'\n  ],\n  example: 'POST /api/login, GET /api/users, PUT /api/profile'\n};\n\nconsole.log('\\nBackend:', backEnd);\n\n// DATABASE (PostgreSQL + Prisma) - Data storage\nlet database = {\n  technology: 'PostgreSQL + Prisma ORM',\n  responsibilities: [\n    'Store data persistently',\n    'Relationships between data',\n    'Query optimization',\n    'Data integrity'\n  ],\n  example: 'Users table, Posts table, Comments table'\n};\n\nconsole.log('\\nDatabase:', database);\n\n// HOW THEY COMMUNICATE (Example flow)\nconsole.log('\\n=== Full-Stack Data Flow ===\\n');\n\nfunction simulateFullStackFlow() {\n  console.log('1. USER ACTION: User clicks \"Login\" button in React');\n  console.log('   Frontend: <button onClick={handleLogin}>Login</button>');\n  \n  console.log('\\n2. FRONTEND: React sends HTTP request to backend');\n  console.log('   fetch(\"/api/login\", { method: \"POST\", body: { email, password } })');\n  \n  console.log('\\n3. BACKEND: Express receives request at route');\n  console.log('   app.post(\"/api/login\", async (req, res) => { ... })');\n  \n  console.log('\\n4. BACKEND: Queries database via Prisma');\n  console.log('   const user = await prisma.user.findUnique({ where: { email } });');\n  \n  console.log('\\n5. DATABASE: Returns user data to backend');\n  console.log('   { id: 1, email: \"user@example.com\", name: \"Alice\" }');\n  \n  console.log('\\n6. BACKEND: Sends JSON response to frontend');\n  console.log('   res.json({ success: true, user: { id: 1, name: \"Alice\" } });');\n  \n  console.log('\\n7. FRONTEND: React receives data and updates UI');\n  console.log('   setUser(data.user); // State update triggers re-render');\n  \n  console.log('\\n8. USER SEES: Dashboard with their name displayed');\n  console.log('   <h1>Welcome, {user.name}!</h1>');\n}\n\nsimulateFullStackFlow();\n\n// TECH STACK OPTIONS\nlet stacks = {\n  MERN: 'MongoDB + Express + React + Node.js',\n  PERN: 'PostgreSQL + Express + React + Node.js (recommended)',\n  MEAN: 'MongoDB + Express + Angular + Node.js',\n  'T3 Stack': 'TypeScript + tRPC + Tailwind + Prisma + Next.js'\n};\n\nconsole.log('\\nPopular Full-Stack Combinations:');\nfor (let [name, stack] of Object.entries(stacks)) {\n  console.log(`${name}: ${stack}`);\n}\n\nconsole.log('\\nWe\\'ll use: PERN + TypeScript + Prisma (modern, type-safe)');\n```\n\n## Breaking Down the Syntax\n\nFull-Stack architecture explained:\n\n1. **Frontend (Client-Side)**:\n   - Runs in user's browser\n   - React components, HTML, CSS, JavaScript\n   - Makes HTTP requests to backend\n   - Port 3000 (development)\n\n2. **Backend (Server-Side)**:\n   - Runs on server (Node.js)\n   - Express routes handle requests\n   - Connects to database\n   - Port 4000 or 5000 (development)\n\n3. **Database**:\n   - PostgreSQL server\n   - Stores all application data\n   - Accessed via Prisma ORM\n   - Port 5432 (default)\n\n4. **Communication (HTTP/REST)**:\n   ```javascript\n   // Frontend makes request\n   fetch('http://localhost:4000/api/users')\n     .then(res => res.json())\n     .then(users => setUsers(users));\n   \n   // Backend handles request\n   app.get('/api/users', async (req, res) => {\n     const users = await prisma.user.findMany();\n     res.json(users);\n   });\n   ```\n\n5. **CORS** (Cross-Origin Resource Sharing):\n   - Frontend and backend on different ports = different origins\n   - Need to enable CORS on backend:\n   ```javascript\n   import cors from 'cors';\n   app.use(cors());\n   ```\n\n6. **Environment Variables**:\n   - Frontend: VITE_API_URL=http://localhost:4000\n   - Backend: DATABASE_URL=postgresql://...\n   - Never commit secrets to Git!\n\n## Common Mistakes & Tips\n\nCommon full-stack mistakes:\n\n1. **CORS errors**:\n   ```\n   Error: Access to fetch at 'http://localhost:4000/api/users' from origin 'http://localhost:3000' \n   has been blocked by CORS policy\n   ```\n   Solution: Enable CORS on backend:\n   ```javascript\n   import cors from 'cors';\n   app.use(cors());\n   ```\n\n2. **Wrong API URLs**:\n   ```javascript\n   // Wrong! (missing http://)\n   fetch('localhost:4000/api/users')\n   \n   // Correct!\n   fetch('http://localhost:4000/api/users')\n   \n   // Better! (use environment variable)\n   fetch(`${import.meta.env.VITE_API_URL}/api/users`)\n   ```\n\n3. **Frontend and backend not running**:\n   - Need TWO terminal windows:\n     * Terminal 1: `cd frontend && npm run dev` (port 3000)\n     * Terminal 2: `cd backend && npm run dev` (port 4000)\n\n4. **Not handling async properly**:\n   ```javascript\n   // Wrong!\n   let users = fetch('/api/users'); // Returns Promise!\n   console.log(users); // Promise, not data\n   \n   // Correct!\n   let response = await fetch('/api/users');\n   let users = await response.json();\n   console.log(users); // Actual data\n   ```\n\n5. **Hardcoded URLs**:\n   - Don't hardcode: `http://localhost:4000`\n   - Use env variables: `process.env.API_URL`\n   - Different in dev vs production!\n\n6. **Not validating data**:\n   - Validate on frontend (UX)\n   - ALSO validate on backend (security)\n   - Never trust client data!\n\n7. **Mixing up req.body, req.params, req.query**:\n   ```javascript\n   // Backend route\n   app.post('/api/users/:id', (req, res) => {\n     req.params.id   // From URL: /api/users/123\n     req.query.name  // From query: ?name=alice\n     req.body.email  // From POST body: { email: '...' }\n   });\n   ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Simulate a full-stack data flow:\n\n1. Create a `frontend` object with a method `fetchUsers()` that:\n   - Logs \"Sending GET request to /api/users\"\n   - Calls backend.handleGetUsers()\n   - Logs the result\n\n2. Create a `backend` object with method `handleGetUsers()` that:\n   - Logs \"Backend received request\"\n   - Calls database.getUsers()\n   - Returns the result\n\n3. Create a `database` object with method `getUsers()` that:\n   - Returns array of mock users\n\nTest the complete flow.",
              "starterCode": "// Database layer\nlet database = {\n  users: [\n    { id: 1, name: 'Alice', email: 'alice@example.com' },\n    { id: 2, name: 'Bob', email: 'bob@example.com' }\n  ],\n  \n  getUsers() {\n    console.log('[Database] Querying users table');\n    return this.users;\n  }\n};\n\n// Backend layer\nlet backend = {\n  handleGetUsers() {\n    console.log('[Backend] Received GET /api/users');\n    let users = database.getUsers();\n    console.log('[Backend] Sending response:', users.length, 'users');\n    return users;\n  }\n};\n\n// Frontend layer  \nlet frontend = {\n  fetchUsers() {\n    console.log('[Frontend] Fetching users from API');\n    let users = backend.handleGetUsers();\n    console.log('[Frontend] Received users:', users);\n    return users;\n  }\n};\n\n// Test the full stack\nconsole.log('=== Full-Stack Simulation ===\\n');\nfrontend.fetchUsers();",
              "solution": "// Complete full-stack simulation\n\n// Database layer\nlet database = {\n  users: [\n    { id: 1, name: 'Alice', email: 'alice@example.com' },\n    { id: 2, name: 'Bob', email: 'bob@example.com' },\n    { id: 3, name: 'Charlie', email: 'charlie@example.com' }\n  ],\n  \n  getUsers() {\n    console.log('[Database] Executing: SELECT * FROM users');\n    return this.users;\n  },\n  \n  getUserById(id) {\n    console.log(`[Database] Executing: SELECT * FROM users WHERE id = ${id}`);\n    return this.users.find(u => u.id === id);\n  },\n  \n  createUser(name, email) {\n    console.log(`[Database] Executing: INSERT INTO users (name, email) VALUES ('${name}', '${email}')`);\n    let newUser = { id: this.users.length + 1, name, email };\n    this.users.push(newUser);\n    return newUser;\n  }\n};\n\n// Backend layer\nlet backend = {\n  handleGetUsers() {\n    console.log('[Backend] GET /api/users');\n    let users = database.getUsers();\n    console.log(`[Backend] Response: 200 OK (${users.length} users)`);\n    return { status: 200, data: users };\n  },\n  \n  handleGetUser(id) {\n    console.log(`[Backend] GET /api/users/${id}`);\n    let user = database.getUserById(id);\n    if (user) {\n      console.log('[Backend] Response: 200 OK');\n      return { status: 200, data: user };\n    } else {\n      console.log('[Backend] Response: 404 Not Found');\n      return { status: 404, error: 'User not found' };\n    }\n  },\n  \n  handleCreateUser(name, email) {\n    console.log(`[Backend] POST /api/users`);\n    let newUser = database.createUser(name, email);\n    console.log('[Backend] Response: 201 Created');\n    return { status: 201, data: newUser };\n  }\n};\n\n// Frontend layer\nlet frontend = {\n  state: { users: [], currentUser: null },\n  \n  async fetchUsers() {\n    console.log('[Frontend] User clicked \"View Users\" button');\n    console.log('[Frontend] fetch(\"http://localhost:4000/api/users\")');\n    \n    let response = backend.handleGetUsers();\n    \n    if (response.status === 200) {\n      this.state.users = response.data;\n      console.log('[Frontend] State updated, re-rendering UI');\n      console.log('[Frontend] Displaying:', this.state.users.length, 'users');\n    }\n    \n    return this.state.users;\n  },\n  \n  async fetchUser(id) {\n    console.log(`[Frontend] User clicked on user ${id}`);\n    console.log(`[Frontend] fetch(\"http://localhost:4000/api/users/${id}\")`);\n    \n    let response = backend.handleGetUser(id);\n    \n    if (response.status === 200) {\n      this.state.currentUser = response.data;\n      console.log('[Frontend] Displaying user profile:', response.data.name);\n    } else {\n      console.log('[Frontend] Showing error: User not found');\n    }\n  },\n  \n  async createUser(name, email) {\n    console.log('[Frontend] User submitted \"Create User\" form');\n    console.log(`[Frontend] fetch(\"http://localhost:4000/api/users\", { method: \"POST\", body: { name, email } })`);\n    \n    let response = backend.handleCreateUser(name, email);\n    \n    if (response.status === 201) {\n      console.log('[Frontend] Success! Refreshing user list...');\n      this.fetchUsers();\n    }\n  }\n};\n\n// Simulate full-stack application\nconsole.log('=== Full-Stack Application Flow ===\\n');\n\nconsole.log('--- Scenario 1: List all users ---');\nfrontend.fetchUsers();\n\nconsole.log('\\n--- Scenario 2: View specific user ---');\nfrontend.fetchUser(1);\n\nconsole.log('\\n--- Scenario 3: Create new user ---');\nfrontend.createUser('Diana', 'diana@example.com');\n\nconsole.log('\\n--- Final database state ---');\nconsole.log('Total users:', database.users.length);\nconsole.log('Users:', database.users.map(u => u.name).join(', '));",
              "hints": [
                "Chain the method calls: frontend → backend → database → backend → frontend"
              ],
              "testCases": [
                {
                  "description": "Should simulate complete flow",
                  "input": "let users = [{ id: 1, name: 'Test' }]; users.length",
                  "expectedOutput": "1"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-13-13-2",
          "title": "CORS - The #1 Error You'll Encounter (The Bouncer Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# CORS - The #1 Error You'll Encounter (The Bouncer Analogy)\n\n## Understanding the Concept\n\nImagine a nightclub with a strict bouncer:\n\nClub Rules:\n- Only people from the guest list can enter\n- The bouncer checks your ID and origin\n- If you're not on the list → DENIED!\n\nWeb Browser:\n- Your React app runs on http://localhost:3000 (origin A)\n- Your Express API runs on http://localhost:4000 (origin B)\n- Browser: 'These are DIFFERENT addresses!'\n- Browser acts as bouncer: 'Can origin A talk to origin B?'\n\nCORS = Cross-Origin Resource Sharing:\n- Security feature built into ALL browsers\n- Prevents malicious websites from stealing data\n- By default: BLOCKS all cross-origin requests\n- You must EXPLICITLY allow your frontend to talk to your backend\n\nThe Fix:\n- Backend says: 'Yes, localhost:3000 is on the guest list'\n- Uses CORS headers to tell browser: 'This is allowed'\n- One line of code: app.use(cors())\n\nWithout CORS configuration → Every API call FAILS!\n\n## Code Example\n\n```javascript\n// CORS - The #1 Full-Stack Error (and how to fix it!)\n\nconsole.log('=== CORS Error Simulation ===\\n');\n\n// THE PROBLEM: Different origins\nlet origins = {\n  frontend: 'http://localhost:3000',\n  backend: 'http://localhost:4000'\n};\n\nconsole.log('Frontend origin:', origins.frontend);\nconsole.log('Backend origin:', origins.backend);\nconsole.log('\\nAre these the same origin?', origins.frontend === origins.backend);\nconsole.log('Result: DIFFERENT ORIGINS → Browser blocks by default!\\n');\n\n// What makes origins different?\nfunction analyzeOrigins() {\n  let examples = [\n    {\n      url1: 'http://localhost:3000',\n      url2: 'http://localhost:4000',\n      same: false,\n      reason: 'Different PORT'\n    },\n    {\n      url1: 'http://example.com',\n      url2: 'https://example.com',\n      same: false,\n      reason: 'Different PROTOCOL (http vs https)'\n    },\n    {\n      url1: 'http://example.com',\n      url2: 'http://api.example.com',\n      same: false,\n      reason: 'Different SUBDOMAIN'\n    },\n    {\n      url1: 'http://localhost:3000/page1',\n      url2: 'http://localhost:3000/page2',\n      same: true,\n      reason: 'Same protocol, domain, port (path doesn\\'t matter)'\n    }\n  ];\n  \n  console.log('=== What Makes Origins Different? ===\\n');\n  examples.forEach(ex => {\n    console.log(`${ex.url1}`);\n    console.log(`${ex.url2}`);\n    console.log(`Same origin? ${ex.same ? 'YES' : 'NO'}`);\n    console.log(`Reason: ${ex.reason}\\n`);\n  });\n}\n\nanalyzeOrigins();\n\n// THE ERROR students will see\nfunction simulateCORSError() {\n  console.log('=== The Error Message ===\\n');\n  console.log('❌ Access to fetch at \\'http://localhost:4000/api/users\\' from origin');\n  console.log('   \\'http://localhost:3000\\' has been blocked by CORS policy:');\n  console.log('   No \\'Access-Control-Allow-Origin\\' header is present on the');\n  console.log('   requested resource.\\n');\n  console.log('Translation: Your backend didn\\'t give permission!\\n');\n}\n\nsimulateCORSError();\n\n// THE SOLUTION\nconsole.log('=== The Fix (Backend Code) ===\\n');\nconsole.log('// Step 1: Install CORS package');\nconsole.log('// npm install cors\\n');\n\nconsole.log('// Step 2: Import and use it');\nconsole.log('import express from \"express\";');\nconsole.log('import cors from \"cors\";  // ← Import CORS middleware\\n');\n\nconsole.log('const app = express();\\n');\n\nconsole.log('// THIS ONE LINE FIXES THE ERROR!');\nconsole.log('app.use(cors());  // ← Allows ALL origins (dev only!)\\n');\n\nconsole.log('// Now your routes work');\nconsole.log('app.get(\"/api/users\", (req, res) => {');\nconsole.log('  res.json([{ id: 1, name: \"Alice\" }]);');\nconsole.log('});\\n');\n\n// More secure CORS configuration\nconsole.log('=== Production CORS (More Secure) ===\\n');\nconsole.log('// Only allow specific origin');\nconsole.log('app.use(cors({');\nconsole.log('  origin: \"https://myapp.com\",  // Only this domain allowed');\nconsole.log('  credentials: true,             // Allow cookies');\nconsole.log('  methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"]  // Allowed HTTP methods');\nconsole.log('}));\\n');\n\nconsole.log('// Multiple allowed origins');\nconsole.log('const allowedOrigins = [');\nconsole.log('  \"http://localhost:3000\",  // Dev');\nconsole.log('  \"https://myapp.com\",      // Production');\nconsole.log('  \"https://staging.myapp.com\"  // Staging');\nconsole.log('];\\n');\n\nconsole.log('app.use(cors({');\nconsole.log('  origin: function(origin, callback) {');\nconsole.log('    if (allowedOrigins.includes(origin) || !origin) {');\nconsole.log('      callback(null, true);');\nconsole.log('    } else {');\nconsole.log('      callback(new Error(\"Not allowed by CORS\"));');\nconsole.log('    }');\nconsole.log('  }');\nconsole.log('}));\\n');\n\n// What CORS actually does\nconsole.log('=== What CORS Does (Under the Hood) ===\\n');\nconsole.log('When you use app.use(cors()), it adds these headers:\\n');\n\nlet corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization'\n};\n\nfor (let [header, value] of Object.entries(corsHeaders)) {\n  console.log(`${header}: ${value}`);\n}\n\nconsole.log('\\nThese headers tell the browser: \"It\\'s OK, I allow this!\"\\n');\n\n// Common CORS scenarios\nconsole.log('=== Common CORS Scenarios ===\\n');\n\nlet scenarios = [\n  {\n    scenario: 'React dev server calling Express API',\n    frontend: 'http://localhost:3000',\n    backend: 'http://localhost:4000',\n    needsCORS: true,\n    solution: 'app.use(cors())'\n  },\n  {\n    scenario: 'Production frontend calling production API',\n    frontend: 'https://myapp.com',\n    backend: 'https://api.myapp.com',\n    needsCORS: true,\n    solution: 'app.use(cors({ origin: \"https://myapp.com\" }))'\n  },\n  {\n    scenario: 'React and API on same domain (proxy)',\n    frontend: 'https://myapp.com',\n    backend: 'https://myapp.com/api',\n    needsCORS: false,\n    solution: 'No CORS needed - same origin!'\n  }\n];\n\nscenarios.forEach((s, i) => {\n  console.log(`Scenario ${i + 1}: ${s.scenario}`);\n  console.log(`  Frontend: ${s.frontend}`);\n  console.log(`  Backend:  ${s.backend}`);\n  console.log(`  CORS needed? ${s.needsCORS ? 'YES' : 'NO'}`);\n  console.log(`  Solution: ${s.solution}\\n`);\n});\n\n// Debugging CORS\nconsole.log('=== Debugging CORS Errors ===\\n');\nlet debugSteps = [\n  '1. Check if both frontend and backend are running',\n  '2. Verify the URLs match (no typos)',\n  '3. Check backend has app.use(cors()) BEFORE routes',\n  '4. Look in browser Network tab → Response headers',\n  '5. Should see: Access-Control-Allow-Origin header',\n  '6. Try curl or Postman (they bypass CORS) to test API',\n  '7. Clear browser cache and restart dev servers'\n];\n\ndebugSteps.forEach(step => console.log(step));\n```\n\n## Breaking Down the Syntax\n\nCORS configuration explained:\n\n1. **Install CORS package**:\n   ```bash\n   npm install cors\n   ```\n\n2. **Basic CORS (allows all origins)**:\n   ```javascript\n   import cors from 'cors';\n   \n   app.use(cors());  // Must be BEFORE routes!\n   ```\n\n3. **Specific origin only** (recommended for production):\n   ```javascript\n   app.use(cors({\n     origin: 'https://myapp.com'\n   }));\n   ```\n\n4. **Multiple origins**:\n   ```javascript\n   const allowedOrigins = [\n     'http://localhost:3000',\n     'https://myapp.com'\n   ];\n   \n   app.use(cors({\n     origin: function(origin, callback) {\n       if (allowedOrigins.includes(origin)) {\n         callback(null, true);\n       } else {\n         callback(new Error('Not allowed by CORS'));\n       }\n     }\n   }));\n   ```\n\n5. **With credentials** (cookies, auth headers):\n   ```javascript\n   app.use(cors({\n     origin: 'http://localhost:3000',\n     credentials: true  // Allow cookies\n   }));\n   \n   // Frontend must also set:\n   fetch('http://localhost:4000/api/users', {\n     credentials: 'include'  // Send cookies\n   });\n   ```\n\n6. **Environment-based CORS**:\n   ```javascript\n   const corsOptions = {\n     origin: process.env.NODE_ENV === 'production'\n       ? 'https://myapp.com'\n       : 'http://localhost:3000'\n   };\n   \n   app.use(cors(corsOptions));\n   ```\n\n7. **Preflight requests** (OPTIONS):\n   - Browser sends OPTIONS request first for PUT/DELETE/custom headers\n   - CORS middleware handles this automatically\n   ```javascript\n   // This happens automatically with app.use(cors())\n   // No extra code needed!\n   ```\n\n8. **Manual CORS headers** (if not using package):\n   ```javascript\n   app.use((req, res, next) => {\n     res.header('Access-Control-Allow-Origin', '*');\n     res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n     res.header('Access-Control-Allow-Headers', 'Content-Type');\n     next();\n   });\n   ```\n\n## Common Mistakes & Tips\n\nCommon CORS mistakes:\n\n1. **CORS middleware placed AFTER routes**:\n   ```javascript\n   // WRONG!\n   app.get('/api/users', (req, res) => { ... });\n   app.use(cors());  // Too late! Routes already defined\n   \n   // CORRECT!\n   app.use(cors());  // BEFORE routes!\n   app.get('/api/users', (req, res) => { ... });\n   ```\n\n2. **Forgot to install cors package**:\n   ```bash\n   # Error: Cannot find module 'cors'\n   npm install cors\n   ```\n\n3. **Using wrong origin in production**:\n   ```javascript\n   // WRONG in production!\n   app.use(cors({ origin: 'http://localhost:3000' }));\n   \n   // CORRECT - use environment variable\n   app.use(cors({ \n     origin: process.env.FRONTEND_URL  // https://myapp.com\n   }));\n   ```\n\n4. **Allowing all origins in production** (security risk!):\n   ```javascript\n   // WRONG in production!\n   app.use(cors({ origin: '*' }));  // Any site can call your API!\n   \n   // CORRECT - be specific\n   app.use(cors({ origin: 'https://myapp.com' }));\n   ```\n\n5. **Credentials without specific origin**:\n   ```javascript\n   // WRONG!\n   app.use(cors({\n     origin: '*',\n     credentials: true  // Error! Can't use * with credentials\n   }));\n   \n   // CORRECT!\n   app.use(cors({\n     origin: 'http://localhost:3000',  // Specific origin required\n     credentials: true\n   }));\n   ```\n\n6. **Frontend not sending credentials**:\n   ```javascript\n   // Backend allows credentials\n   app.use(cors({ origin: '...', credentials: true }));\n   \n   // But frontend doesn't send them (cookies won't work!)\n   fetch('/api/users');  // WRONG!\n   \n   // CORRECT!\n   fetch('/api/users', { credentials: 'include' });\n   ```\n\n7. **Testing with curl/Postman and thinking CORS works**:\n   - curl and Postman BYPASS CORS (they're not browsers)\n   - Must test in actual browser!\n   ```bash\n   # This works even without CORS (not a browser!)\n   curl http://localhost:4000/api/users\n   \n   # But browser will still block it\n   ```\n\n8. **Different protocols (http vs https)**:\n   ```javascript\n   // Frontend: https://myapp.com\n   // Backend:  http://api.myapp.com\n   // DIFFERENT protocols → CORS error!\n   \n   // Both must be https in production\n   ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Simulate CORS checking:\n\n1. Create a `browser` object with method `checkCORS(frontendOrigin, backendOrigin)` that:\n   - Compares the two origins\n   - Returns true if same origin (protocol + domain + port match)\n   - Returns false if different origins\n\n2. Create a `backend` object with:\n   - `corsEnabled` property (boolean)\n   - `allowedOrigins` array\n   - `handleRequest(origin)` method that:\n     - If corsEnabled is false → returns 'CORS Error: Blocked!'\n     - If origin is in allowedOrigins → returns 'Request allowed'\n     - Otherwise → returns 'CORS Error: Origin not allowed'\n\n3. Test various scenarios",
              "starterCode": "// CORS Simulation\n\nfunction parseOrigin(url) {\n  // Extract protocol, domain, port\n  let match = url.match(/(https?):\\/\\/([^:\\/]+)(?::(\\d+))?/);\n  return {\n    protocol: match[1],\n    domain: match[2],\n    port: match[3] || (match[1] === 'https' ? '443' : '80')\n  };\n}\n\nlet browser = {\n  checkCORS(frontendOrigin, backendOrigin) {\n    let f = parseOrigin(frontendOrigin);\n    let b = parseOrigin(backendOrigin);\n    \n    let sameOrigin = f.protocol === b.protocol &&\n                     f.domain === b.domain &&\n                     f.port === b.port;\n    \n    return sameOrigin;\n  }\n};\n\nlet backend = {\n  corsEnabled: true,\n  allowedOrigins: ['http://localhost:3000', 'https://myapp.com'],\n  \n  handleRequest(origin) {\n    if (!this.corsEnabled) {\n      return 'CORS Error: Blocked!';\n    }\n    \n    if (this.allowedOrigins.includes(origin)) {\n      return 'Request allowed';\n    }\n    \n    return 'CORS Error: Origin not allowed';\n  }\n};\n\n// Test scenarios\nconsole.log('=== CORS Tests ===\\n');\n\nlet tests = [\n  ['http://localhost:3000', 'http://localhost:4000'],\n  ['http://localhost:3000', 'http://localhost:3000'],\n  ['https://myapp.com', 'https://api.myapp.com']\n];\n\ntests.forEach(([frontend, api]) => {\n  console.log(`Frontend: ${frontend}`);\n  console.log(`Backend:  ${api}`);\n  console.log(`Same origin? ${browser.checkCORS(frontend, api)}`);\n  console.log(`Backend says: ${backend.handleRequest(frontend)}\\n`);\n});",
              "solution": "// Complete CORS simulation\n\nfunction parseOrigin(url) {\n  let match = url.match(/(https?):\\/\\/([^:\\/]+)(?::(\\d+))?/);\n  return {\n    protocol: match[1],\n    domain: match[2],\n    port: match[3] || (match[1] === 'https' ? '443' : '80'),\n    full: `${match[1]}://${match[2]}:${match[3] || (match[1] === 'https' ? '443' : '80')}`\n  };\n}\n\nlet browser = {\n  checkCORS(frontendOrigin, backendOrigin) {\n    let f = parseOrigin(frontendOrigin);\n    let b = parseOrigin(backendOrigin);\n    \n    let sameOrigin = f.protocol === b.protocol &&\n                     f.domain === b.domain &&\n                     f.port === b.port;\n    \n    console.log(`[Browser] Checking origins...`);\n    console.log(`  Frontend: ${f.protocol}://${f.domain}:${f.port}`);\n    console.log(`  Backend:  ${b.protocol}://${b.domain}:${b.port}`);\n    console.log(`  Same origin? ${sameOrigin}`);\n    \n    return sameOrigin;\n  },\n  \n  makeRequest(frontendOrigin, backendOrigin, backendObj) {\n    let sameOrigin = this.checkCORS(frontendOrigin, backendOrigin);\n    \n    if (sameOrigin) {\n      console.log('[Browser] Same origin - request allowed!\\n');\n      return { allowed: true, reason: 'Same origin' };\n    }\n    \n    console.log('[Browser] Different origin - checking CORS headers...');\n    let result = backendObj.handleRequest(frontendOrigin);\n    console.log(`[Browser] ${result}\\n`);\n    \n    return { allowed: result.includes('allowed'), reason: result };\n  }\n};\n\nlet backend = {\n  corsEnabled: true,\n  allowedOrigins: ['http://localhost:3000', 'https://myapp.com'],\n  allowCredentials: false,\n  \n  handleRequest(origin) {\n    console.log(`[Backend] Received request from: ${origin}`);\n    \n    if (!this.corsEnabled) {\n      console.log('[Backend] CORS is disabled - blocking all cross-origin requests');\n      return 'CORS Error: No Access-Control-Allow-Origin header';\n    }\n    \n    if (this.allowedOrigins.includes('*')) {\n      console.log('[Backend] CORS allows all origins (*)');  \n      return 'Request allowed (all origins)';\n    }\n    \n    if (this.allowedOrigins.includes(origin)) {\n      console.log(`[Backend] Origin ${origin} is in allowed list`);\n      console.log('[Backend] Adding header: Access-Control-Allow-Origin:', origin);\n      return 'Request allowed';\n    }\n    \n    console.log(`[Backend] Origin ${origin} is NOT in allowed list`);\n    console.log('[Backend] Blocking request');\n    return 'CORS Error: Origin not allowed';\n  },\n  \n  enableCORS(options = {}) {\n    this.corsEnabled = true;\n    if (options.origins) {\n      this.allowedOrigins = options.origins;\n    }\n    if (options.credentials) {\n      this.allowCredentials = options.credentials;\n    }\n    console.log('[Backend] CORS configured:', {\n      enabled: this.corsEnabled,\n      allowedOrigins: this.allowedOrigins,\n      credentials: this.allowCredentials\n    });\n  }\n};\n\n// Simulate different scenarios\nconsole.log('=== Scenario 1: React dev → Express API (CORS enabled) ===\\n');\nbackend.enableCORS({ origins: ['http://localhost:3000'] });\nbrowser.makeRequest('http://localhost:3000', 'http://localhost:4000', backend);\n\nconsole.log('=== Scenario 2: Same origin (no CORS needed) ===\\n');\nbrowser.makeRequest('http://localhost:3000', 'http://localhost:3000', backend);\n\nconsole.log('=== Scenario 3: Unauthorized origin (CORS blocks) ===\\n');\nbrowser.makeRequest('http://evil-site.com', 'http://localhost:4000', backend);\n\nconsole.log('=== Scenario 4: CORS disabled (everything blocked) ===\\n');\nbackend.corsEnabled = false;\nbrowser.makeRequest('http://localhost:3000', 'http://localhost:4000', backend);\n\nconsole.log('=== Scenario 5: Allow all origins (*) ===\\n');\nbackend.enableCORS({ origins: ['*'] });\nbrowser.makeRequest('http://any-site.com', 'http://localhost:4000', backend);\n\n// Summary\nconsole.log('\\n=== CORS Summary ===\\n');\nconsole.log('✓ Same origin = No CORS needed');\nconsole.log('✓ Different origin + CORS enabled + origin in list = Allowed');\nconsole.log('✗ Different origin + CORS disabled = Blocked');\nconsole.log('✗ Different origin + origin not in list = Blocked');\nconsole.log('\\n💡 Fix: Add app.use(cors()) to your Express backend!');",
              "hints": [
                "Origins are same if protocol, domain, AND port all match"
              ],
              "testCases": [
                {
                  "description": "Should detect same origin",
                  "input": "let same = 'http://localhost:3000'; same === same",
                  "expectedOutput": "true"
                },
                {
                  "description": "Should detect different ports",
                  "input": "'http://localhost:3000' === 'http://localhost:4000'",
                  "expectedOutput": "false"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-13-13-3",
          "title": "Fetching Data with useEffect (The Automated Assistant Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Fetching Data with useEffect (The Automated Assistant Analogy)\n\n## Understanding the Concept\n\nImagine hiring an assistant for your office:\n\nManual Way (without useEffect):\n- Every morning YOU must remember to check the mailbox\n- YOU must remember to water the plants\n- YOU might forget → tasks don't get done\n\nAutomated Way (with useEffect):\n- Tell assistant: \"When you arrive (component mounts), check mail\"\n- Tell assistant: \"Every hour (dependency changes), water plants\"\n- Tell assistant: \"When you leave (component unmounts), lock doors\"\n- Assistant does these automatically → you don't have to remember!\n\nReact useEffect is your automated assistant:\n- Runs code automatically when component mounts\n- Runs code when specific values change\n- Cleanup when component unmounts\n- Perfect for fetching data from APIs!\n\n## Code Example\n\n```javascript\n// useEffect + fetch - Getting data from APIs\n\nconsole.log('=== useEffect for Data Fetching ===\\n');\n\n// Simulate React component lifecycle\nclass ComponentLifecycle {\n  constructor(name) {\n    this.name = name;\n    this.effects = [];\n    this.state = {};\n  }\n  \n  // Simulate useEffect\n  useEffect(callback, dependencies) {\n    console.log(`[${this.name}] Registering effect with dependencies:`, dependencies || 'none');\n    this.effects.push({ callback, dependencies });\n  }\n  \n  // Simulate component mount\n  mount() {\n    console.log(`\\n[${this.name}] Component mounting...`);\n    this.effects.forEach(effect => {\n      if (!effect.dependencies || effect.dependencies.length === 0) {\n        console.log(`[${this.name}] Running effect (runs on mount)`);\n        effect.callback();\n      }\n    });\n  }\n  \n  // Simulate state update\n  setState(newState) {\n    console.log(`\\n[${this.name}] State updating:`, newState);\n    let oldState = { ...this.state };\n    this.state = { ...this.state, ...newState };\n    \n    this.effects.forEach(effect => {\n      if (effect.dependencies) {\n        let changed = effect.dependencies.some(dep => {\n          return oldState[dep] !== this.state[dep];\n        });\n        if (changed) {\n          console.log(`[${this.name}] Dependency changed, re-running effect`);\n          effect.callback();\n        }\n      }\n    });\n  }\n}\n\n// Example 1: Fetch data on component mount\nconsole.log('=== Example 1: Fetch Users on Mount ===');\n\nlet UserList = new ComponentLifecycle('UserList');\n\nUserList.useEffect(() => {\n  console.log('[UserList] Fetching users from API...');\n  console.log('[UserList] fetch(\"http://localhost:4000/api/users\")');\n  \n  // Simulate API response\n  setTimeout(() => {\n    let users = [\n      { id: 1, name: 'Alice' },\n      { id: 2, name: 'Bob' }\n    ];\n    console.log('[UserList] Received:', users.length, 'users');\n    console.log('[UserList] setUsers(data) → triggers re-render');\n  }, 100);\n}, []); // Empty array = run once on mount\n\nUserList.mount();\n\n// Example 2: Fetch when dependency changes\nsetTimeout(() => {\n  console.log('\\n\\n=== Example 2: Fetch User Details When ID Changes ===');\n  \n  let UserProfile = new ComponentLifecycle('UserProfile');\n  UserProfile.state = { userId: null };\n  \n  UserProfile.useEffect(() => {\n    if (UserProfile.state.userId) {\n      console.log(`[UserProfile] Fetching user ${UserProfile.state.userId}...`);\n      console.log(`[UserProfile] fetch(\"http://localhost:4000/api/users/${UserProfile.state.userId}\")`);\n      \n      setTimeout(() => {\n        let user = { id: UserProfile.state.userId, name: 'Alice', email: 'alice@example.com' };\n        console.log('[UserProfile] Received:', user);\n      }, 100);\n    }\n  }, ['userId']); // Re-run when userId changes\n  \n  UserProfile.mount();\n  \n  // Simulate user clicking different profiles\n  setTimeout(() => {\n    console.log('\\n[User] Clicks on user 1');\n    UserProfile.setState({ userId: 1 });\n  }, 200);\n  \n  setTimeout(() => {\n    console.log('\\n[User] Clicks on user 2');\n    UserProfile.setState({ userId: 2 });\n  }, 400);\n}, 300);\n\n// Example 3: Real fetch pattern\nsetTimeout(() => {\n  console.log('\\n\\n=== Example 3: Complete Fetch Pattern ===\\n');\n  \n  console.log('// React component with useEffect\\n');\n  console.log('function UserList() {');\n  console.log('  const [users, setUsers] = useState([]);');\n  console.log('  const [loading, setLoading] = useState(true);');\n  console.log('  const [error, setError] = useState(null);\\n');\n  \n  console.log('  useEffect(() => {');\n  console.log('    async function fetchUsers() {');\n  console.log('      try {');\n  console.log('        setLoading(true);');\n  console.log('        const response = await fetch(\"http://localhost:4000/api/users\");');\n  console.log('        ');\n  console.log('        if (!response.ok) {');\n  console.log('          throw new Error(`HTTP error! status: ${response.status}`);');\n  console.log('        }');\n  console.log('        ');\n  console.log('        const data = await response.json();');\n  console.log('        setUsers(data);');\n  console.log('      } catch (err) {');\n  console.log('        setError(err.message);');\n  console.log('      } finally {');\n  console.log('        setLoading(false);');\n  console.log('      }');\n  console.log('    }\\n');\n  console.log('    fetchUsers();');\n  console.log('  }, []); // Run once on mount\\n');\n  \n  console.log('  if (loading) return <div>Loading...</div>;');\n  console.log('  if (error) return <div>Error: {error}</div>;');\n  \n  console.log('  return (');\n  console.log('    <ul>');\n  console.log('      {users.map(user => (');\n  console.log('        <li key={user.id}>{user.name}</li>');\n  console.log('      ))}');\n  console.log('    </ul>');\n  console.log('  );');\n  console.log('}');\n}, 800);\n\n// Dependency array explanation\nsetTimeout(() => {\n  console.log('\\n\\n=== useEffect Dependency Array ===\\n');\n  \n  let cases = [\n    {\n      code: 'useEffect(() => { ... });',\n      dependencies: 'NONE',\n      when: 'Every render (usually a mistake!)'\n    },\n    {\n      code: 'useEffect(() => { ... }, []);',\n      dependencies: '[] (empty)',\n      when: 'Once on mount only'\n    },\n    {\n      code: 'useEffect(() => { ... }, [userId]);',\n      dependencies: '[userId]',\n      when: 'On mount + whenever userId changes'\n    },\n    {\n      code: 'useEffect(() => { ... }, [userId, page]);',\n      dependencies: '[userId, page]',\n      when: 'On mount + when userId OR page changes'\n    }\n  ];\n  \n  cases.forEach(c => {\n    console.log(`${c.code}`);\n    console.log(`  Dependencies: ${c.dependencies}`);\n    console.log(`  Runs: ${c.when}\\n`);\n  });\n}, 1100);\n```\n\n## Breaking Down the Syntax\n\nuseEffect with fetch explained:\n\n1. **Basic useEffect with fetch**:\n   ```jsx\n   import { useEffect, useState } from 'react';\n   \n   function UserList() {\n     const [users, setUsers] = useState([]);\n     \n     useEffect(() => {\n       fetch('http://localhost:4000/api/users')\n         .then(res => res.json())\n         .then(data => setUsers(data));\n     }, []); // Empty array = run once on mount\n     \n     return <div>{users.map(u => <div key={u.id}>{u.name}</div>)}</div>;\n   }\n   ```\n\n2. **With async/await** (recommended):\n   ```jsx\n   useEffect(() => {\n     async function fetchUsers() {\n       const response = await fetch('http://localhost:4000/api/users');\n       const data = await response.json();\n       setUsers(data);\n     }\n     \n     fetchUsers();\n   }, []);\n   ```\n\n3. **With loading and error states** (best practice):\n   ```jsx\n   const [users, setUsers] = useState([]);\n   const [loading, setLoading] = useState(true);\n   const [error, setError] = useState(null);\n   \n   useEffect(() => {\n     async function fetchUsers() {\n       try {\n         setLoading(true);\n         const res = await fetch('http://localhost:4000/api/users');\n         \n         if (!res.ok) {\n           throw new Error(`HTTP ${res.status}`);\n         }\n         \n         const data = await res.json();\n         setUsers(data);\n       } catch (err) {\n         setError(err.message);\n       } finally {\n         setLoading(false);\n       }\n     }\n     \n     fetchUsers();\n   }, []);\n   \n   if (loading) return <div>Loading...</div>;\n   if (error) return <div>Error: {error}</div>;\n   return <div>...</div>;\n   ```\n\n4. **Dependency array - fetch when value changes**:\n   ```jsx\n   const [userId, setUserId] = useState(1);\n   const [user, setUser] = useState(null);\n   \n   useEffect(() => {\n     fetch(`http://localhost:4000/api/users/${userId}`)\n       .then(res => res.json())\n       .then(data => setUser(data));\n   }, [userId]); // Re-fetch when userId changes\n   ```\n\n5. **Cleanup function** (abort requests):\n   ```jsx\n   useEffect(() => {\n     const controller = new AbortController();\n     \n     fetch('http://localhost:4000/api/users', {\n       signal: controller.signal\n     })\n       .then(res => res.json())\n       .then(data => setUsers(data))\n       .catch(err => {\n         if (err.name !== 'AbortError') {\n           setError(err.message);\n         }\n       });\n     \n     // Cleanup: abort fetch if component unmounts\n     return () => controller.abort();\n   }, []);\n   ```\n\n6. **POST request in useEffect**:\n   ```jsx\n   useEffect(() => {\n     async function createUser() {\n       const res = await fetch('http://localhost:4000/api/users', {\n         method: 'POST',\n         headers: { 'Content-Type': 'application/json' },\n         body: JSON.stringify({ name: 'Alice', email: 'alice@example.com' })\n       });\n       const newUser = await res.json();\n       console.log('Created:', newUser);\n     }\n     \n     createUser();\n   }, []);\n   ```\n\n## Common Mistakes & Tips\n\nCommon useEffect + fetch mistakes:\n\n1. **Forgetting dependency array**:\n   ```jsx\n   // WRONG! Infinite loop!\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data)); // State update triggers re-render\n   }); // No dependency array → runs every render → infinite loop!\n   \n   // CORRECT!\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data));\n   }, []); // Empty array → run once\n   ```\n\n2. **Using async directly in useEffect**:\n   ```jsx\n   // WRONG!\n   useEffect(async () => {  // ← Can't do this!\n     const res = await fetch('/api/users');\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     async function fetchData() {  // Define async function inside\n       const res = await fetch('/api/users');\n     }\n     fetchData();  // Call it\n   }, []);\n   ```\n\n3. **Not handling loading/error states**:\n   ```jsx\n   // WRONG! (bad UX)\n   const [users, setUsers] = useState([]);\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data));\n   }, []);\n   return <div>{users.map(...)}</div>; // Empty while loading!\n   \n   // CORRECT!\n   const [users, setUsers] = useState([]);\n   const [loading, setLoading] = useState(true);\n   \n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => {\n         setUsers(data);\n         setLoading(false);\n       });\n   }, []);\n   \n   if (loading) return <div>Loading...</div>;\n   return <div>{users.map(...)}</div>;\n   ```\n\n4. **Not checking response.ok**:\n   ```jsx\n   // WRONG! (doesn't catch HTTP errors)\n   const res = await fetch('/api/users');\n   const data = await res.json(); // Fails if 404/500!\n   \n   // CORRECT!\n   const res = await fetch('/api/users');\n   if (!res.ok) {\n     throw new Error(`HTTP ${res.status}: ${res.statusText}`);\n   }\n   const data = await res.json();\n   ```\n\n5. **Missing cleanup (memory leaks)**:\n   ```jsx\n   // WRONG! (can cause \"Can't perform state update on unmounted component\")\n   useEffect(() => {\n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => setUsers(data)); // Component might unmount before this!\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     let cancelled = false;\n     \n     fetch('/api/users')\n       .then(res => res.json())\n       .then(data => {\n         if (!cancelled) {  // Only update if still mounted\n           setUsers(data);\n         }\n       });\n     \n     return () => {\n       cancelled = true;  // Cleanup\n     };\n   }, []);\n   ```\n\n6. **Wrong dependencies**:\n   ```jsx\n   function UserProfile({ userId }) {\n     const [user, setUser] = useState(null);\n     \n     // WRONG! (doesn't re-fetch when userId changes)\n     useEffect(() => {\n       fetch(`/api/users/${userId}`)\n         .then(res => res.json())\n         .then(data => setUser(data));\n     }, []); // Should include userId!\n     \n     // CORRECT!\n     useEffect(() => {\n       fetch(`/api/users/${userId}`)\n         .then(res => res.json())\n         .then(data => setUser(data));\n     }, [userId]); // Re-fetch when userId changes\n   }\n   ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Build a complete data fetching flow:\n\n1. Create a `fetchUsers()` function that:\n   - Returns a Promise\n   - Simulates 1 second delay\n   - Resolves with array of mock users\n\n2. Create a `UserListComponent` object that:\n   - Has `state` with: users (array), loading (boolean), error (string|null)\n   - Has `mount()` method that simulates useEffect running\n   - In mount: sets loading true, calls fetchUsers, updates state\n\n3. Test by calling mount() and logging state changes",
              "starterCode": "// Simulate API\nfunction fetchUsers() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve([\n        { id: 1, name: 'Alice', email: 'alice@example.com' },\n        { id: 2, name: 'Bob', email: 'bob@example.com' },\n        { id: 3, name: 'Charlie', email: 'charlie@example.com' }\n      ]);\n    }, 1000);\n  });\n}\n\n// Simulate React component\nlet UserListComponent = {\n  state: {\n    users: [],\n    loading: false,\n    error: null\n  },\n  \n  setState(updates) {\n    this.state = { ...this.state, ...updates };\n    console.log('[State Updated]', this.state);\n  },\n  \n  async mount() {\n    console.log('[Component] Mounting...');\n    console.log('[useEffect] Running effect (fetch users)');\n    \n    this.setState({ loading: true });\n    \n    try {\n      console.log('[Fetch] Calling API...');\n      let users = await fetchUsers();\n      console.log('[Fetch] Received', users.length, 'users');\n      this.setState({ users, loading: false });\n    } catch (err) {\n      console.log('[Fetch] Error:', err.message);\n      this.setState({ error: err.message, loading: false });\n    }\n  }\n};\n\n// Test\nconsole.log('=== UserList Component ===\\n');\nUserListComponent.mount();",
              "solution": "// Complete data fetching simulation\n\n// Mock API with various endpoints\nlet mockAPI = {\n  users: [\n    { id: 1, name: 'Alice', email: 'alice@example.com', role: 'Admin' },\n    { id: 2, name: 'Bob', email: 'bob@example.com', role: 'User' },\n    { id: 3, name: 'Charlie', email: 'charlie@example.com', role: 'User' }\n  ],\n  \n  fetchUsers(delay = 1000) {\n    console.log(`[API] GET /api/users (simulating ${delay}ms network delay)`);\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        console.log('[API] Responding with', this.users.length, 'users');\n        resolve([...this.users]);\n      }, delay);\n    });\n  },\n  \n  fetchUserById(id, delay = 800) {\n    console.log(`[API] GET /api/users/${id}`);\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        let user = this.users.find(u => u.id === id);\n        if (user) {\n          console.log('[API] Found user:', user.name);\n          resolve({ ...user });\n        } else {\n          console.log('[API] 404 Not Found');\n          reject(new Error('User not found'));\n        }\n      }, delay);\n    });\n  },\n  \n  createUser(userData, delay = 1000) {\n    console.log('[API] POST /api/users', userData);\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        let newUser = {\n          id: this.users.length + 1,\n          ...userData\n        };\n        this.users.push(newUser);\n        console.log('[API] Created user:', newUser);\n        resolve(newUser);\n      }, delay);\n    });\n  }\n};\n\n// Component 1: UserList (fetch all users on mount)\nlet UserListComponent = {\n  state: { users: [], loading: false, error: null },\n  \n  setState(updates) {\n    this.state = { ...this.state, ...updates };\n    console.log('[UserList State]', this.state);\n  },\n  \n  async mount() {\n    console.log('[UserList] Component mounting...');\n    console.log('[UserList] useEffect(() => { fetchUsers() }, [])');\n    \n    try {\n      this.setState({ loading: true, error: null });\n      let users = await mockAPI.fetchUsers();\n      this.setState({ users, loading: false });\n      console.log('[UserList] Render with', users.length, 'users\\n');\n    } catch (err) {\n      this.setState({ error: err.message, loading: false });\n      console.log('[UserList] Render error state\\n');\n    }\n  }\n};\n\n// Component 2: UserProfile (fetch user when ID changes)\nlet UserProfileComponent = {\n  state: { userId: null, user: null, loading: false, error: null },\n  \n  setState(updates) {\n    let oldUserId = this.state.userId;\n    this.state = { ...this.state, ...updates };\n    console.log('[UserProfile State]', this.state);\n    \n    // Simulate useEffect with [userId] dependency\n    if ('userId' in updates && updates.userId !== oldUserId) {\n      console.log('[UserProfile] userId changed → running effect');\n      this.fetchUser();\n    }\n  },\n  \n  async fetchUser() {\n    if (!this.state.userId) {\n      console.log('[UserProfile] No userId, skipping fetch');\n      return;\n    }\n    \n    console.log(`[UserProfile] useEffect(() => { fetchUser(${this.state.userId}) }, [userId])`);\n    \n    try {\n      this.state.loading = true;\n      this.state.error = null;\n      let user = await mockAPI.fetchUserById(this.state.userId);\n      this.state.user = user;\n      this.state.loading = false;\n      console.log('[UserProfile] Render with user:', user.name, '\\n');\n    } catch (err) {\n      this.state.error = err.message;\n      this.state.loading = false;\n      console.log('[UserProfile] Render error\\n');\n    }\n  },\n  \n  mount() {\n    console.log('[UserProfile] Component mounting...');\n    console.log('[UserProfile] useEffect registered with [userId] dependency\\n');\n  }\n};\n\n// Run simulation\nasync function runSimulation() {\n  console.log('=== Full-Stack Data Fetching Simulation ===\\n');\n  \n  // Scenario 1: Fetch all users on mount\n  console.log('--- Scenario 1: UserList Component ---\\n');\n  await UserListComponent.mount();\n  \n  // Scenario 2: Fetch specific user when ID changes\n  console.log('--- Scenario 2: UserProfile Component ---\\n');\n  UserProfileComponent.mount();\n  \n  await new Promise(resolve => setTimeout(resolve, 100));\n  console.log('[User Action] Clicks on user 1');\n  UserProfileComponent.setState({ userId: 1 });\n  \n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log('[User Action] Clicks on user 2');\n  UserProfileComponent.setState({ userId: 2 });\n  \n  // Scenario 3: Create new user\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log('\\n--- Scenario 3: Create User ---\\n');\n  let newUser = await mockAPI.createUser({ \n    name: 'Diana', \n    email: 'diana@example.com',\n    role: 'User'\n  });\n  \n  console.log('\\n--- Final State ---');\n  console.log('Total users in database:', mockAPI.users.length);\n  console.log('Users:', mockAPI.users.map(u => u.name).join(', '));\n}\n\nrunSimulation();",
              "hints": [
                "Use async/await and try/catch/finally for clean error handling"
              ],
              "testCases": [
                {
                  "description": "Should fetch and return users",
                  "input": "await fetchUsers(); // Returns array",
                  "expectedOutput": "Array of 3 users"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-13-13-4",
          "title": "Complete Full-Stack Example - Todo App with React + Express + Prisma",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Complete Full-Stack Example - Todo App with React + Express + Prisma\n\n## Understanding the Concept\n\nBuilding a full-stack app is like building a house:\n\nFoundation (Database - Prisma/PostgreSQL):\n- Permanent storage for all data\n- Structured (schema)\n- Reliable\n\nPlumbing & Electrical (Backend - Express):\n- Hidden from view\n- Does the real work\n- Connects everything together\n\nInterior & Facade (Frontend - React):\n- What users see and interact with\n- Beautiful and intuitive\n- Makes requests to backend for functionality\n\nInspector (CORS):\n- Ensures everything is safe and connected properly\n- Allows frontend and backend to communicate\n\nA complete full-stack app needs ALL these parts working together!\n\n## Code Example\n\n```javascript\n// Complete Full-Stack Todo App Simulation\n\nconsole.log('=== Full-Stack Todo Application ===\\n');\n\n// DATABASE LAYER (Prisma + PostgreSQL)\nlet database = {\n  todos: [\n    { id: 1, title: 'Learn React', completed: false, userId: 1 },\n    { id: 2, title: 'Build API', completed: true, userId: 1 },\n    { id: 3, title: 'Deploy app', completed: false, userId: 1 }\n  ],\n  \n  // Simulate Prisma queries\n  async findMany(filter = {}) {\n    console.log('[Database] SELECT * FROM todos WHERE userId =', filter.userId || 'ALL');\n    let results = filter.userId \n      ? this.todos.filter(t => t.userId === filter.userId)\n      : this.todos;\n    return results;\n  },\n  \n  async create(data) {\n    console.log('[Database] INSERT INTO todos', data);\n    let newTodo = {\n      id: this.todos.length + 1,\n      completed: false,\n      ...data\n    };\n    this.todos.push(newTodo);\n    return newTodo;\n  },\n  \n  async update(id, data) {\n    console.log(`[Database] UPDATE todos SET ... WHERE id = ${id}`);\n    let todo = this.todos.find(t => t.id === id);\n    if (todo) {\n      Object.assign(todo, data);\n      return todo;\n    }\n    return null;\n  },\n  \n  async delete(id) {\n    console.log(`[Database] DELETE FROM todos WHERE id = ${id}`);\n    let index = this.todos.findIndex(t => t.id === id);\n    if (index !== -1) {\n      let deleted = this.todos.splice(index, 1)[0];\n      return deleted;\n    }\n    return null;\n  }\n};\n\n// BACKEND LAYER (Express API)\nlet backend = {\n  corsEnabled: true,\n  \n  async handleGetTodos(userId) {\n    console.log('[Backend] GET /api/todos');\n    console.log('[Backend] Checking CORS... ' + (this.corsEnabled ? '✓ Allowed' : '✗ Blocked'));\n    \n    if (!this.corsEnabled) {\n      return { status: 403, error: 'CORS error' };\n    }\n    \n    let todos = await database.findMany({ userId });\n    console.log(`[Backend] Found ${todos.length} todos`);\n    return { status: 200, data: todos };\n  },\n  \n  async handleCreateTodo(title, userId) {\n    console.log('[Backend] POST /api/todos', { title, userId });\n    \n    // Validation\n    if (!title || title.trim().length === 0) {\n      console.log('[Backend] Validation failed: title required');\n      return { status: 400, error: 'Title is required' };\n    }\n    \n    let newTodo = await database.create({ title, userId });\n    console.log('[Backend] Created todo:', newTodo.id);\n    return { status: 201, data: newTodo };\n  },\n  \n  async handleUpdateTodo(id, updates) {\n    console.log(`[Backend] PATCH /api/todos/${id}`, updates);\n    let updated = await database.update(id, updates);\n    \n    if (!updated) {\n      console.log('[Backend] Todo not found');\n      return { status: 404, error: 'Todo not found' };\n    }\n    \n    console.log('[Backend] Updated todo:', updated);\n    return { status: 200, data: updated };\n  },\n  \n  async handleDeleteTodo(id) {\n    console.log(`[Backend] DELETE /api/todos/${id}`);\n    let deleted = await database.delete(id);\n    \n    if (!deleted) {\n      return { status: 404, error: 'Todo not found' };\n    }\n    \n    console.log('[Backend] Deleted todo');\n    return { status: 200, data: { message: 'Deleted successfully' } };\n  }\n};\n\n// FRONTEND LAYER (React Component)\nlet TodoApp = {\n  state: {\n    todos: [],\n    loading: false,\n    error: null,\n    newTodoTitle: '',\n    currentUserId: 1\n  },\n  \n  setState(updates) {\n    this.state = { ...this.state, ...updates };\n    console.log('[TodoApp State]', {\n      todos: this.state.todos.length + ' todos',\n      loading: this.state.loading,\n      error: this.state.error\n    });\n  },\n  \n  // useEffect - fetch todos on mount\n  async componentDidMount() {\n    console.log('\\n[TodoApp] Component mounted');\n    console.log('[TodoApp] useEffect(() => { fetchTodos() }, [])');\n    await this.fetchTodos();\n  },\n  \n  async fetchTodos() {\n    console.log('[TodoApp] Fetching todos from API...');\n    console.log('[TodoApp] fetch(\"http://localhost:4000/api/todos\")');\n    \n    this.setState({ loading: true, error: null });\n    \n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 300));\n    \n    let response = await backend.handleGetTodos(this.state.currentUserId);\n    \n    if (response.status === 200) {\n      this.setState({ todos: response.data, loading: false });\n      console.log('[TodoApp] Rendering', response.data.length, 'todos');\n    } else {\n      this.setState({ error: response.error, loading: false });\n    }\n  },\n  \n  async addTodo(title) {\n    console.log(`\\n[TodoApp] User types \"${title}\" and clicks Add`);\n    console.log('[TodoApp] handleAddTodo()');\n    console.log('[TodoApp] fetch(\"http://localhost:4000/api/todos\", { method: \"POST\", ... })');\n    \n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    let response = await backend.handleCreateTodo(title, this.state.currentUserId);\n    \n    if (response.status === 201) {\n      console.log('[TodoApp] Todo created! Refreshing list...');\n      await this.fetchTodos();\n    } else {\n      this.setState({ error: response.error });\n    }\n  },\n  \n  async toggleTodo(id) {\n    console.log(`\\n[TodoApp] User clicks checkbox for todo ${id}`);\n    let todo = this.state.todos.find(t => t.id === id);\n    console.log(`[TodoApp] Toggling completed: ${todo.completed} → ${!todo.completed}`);\n    console.log(`[TodoApp] fetch(\"http://localhost:4000/api/todos/${id}\", { method: \"PATCH\", ... })`);\n    \n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    let response = await backend.handleUpdateTodo(id, { completed: !todo.completed });\n    \n    if (response.status === 200) {\n      console.log('[TodoApp] Updated! Refreshing...');\n      await this.fetchTodos();\n    }\n  },\n  \n  async deleteTodo(id) {\n    console.log(`\\n[TodoApp] User clicks delete for todo ${id}`);\n    console.log(`[TodoApp] fetch(\"http://localhost:4000/api/todos/${id}\", { method: \"DELETE\" })`);\n    \n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    let response = await backend.handleDeleteTodo(id);\n    \n    if (response.status === 200) {\n      console.log('[TodoApp] Deleted! Refreshing...');\n      await this.fetchTodos();\n    }\n  }\n};\n\n// RUN SIMULATION\nasync function runFullStackSimulation() {\n  console.log('=== Simulating Full-Stack Todo App ===\\n');\n  \n  // 1. App loads\n  await TodoApp.componentDidMount();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // 2. User adds new todo\n  await TodoApp.addTodo('Master full-stack development');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // 3. User toggles todo\n  await TodoApp.toggleTodo(1);\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // 4. User deletes todo\n  await TodoApp.deleteTodo(2);\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // 5. Final state\n  console.log('\\n=== Final Application State ===');\n  console.log('\\nDatabase:');\n  database.todos.forEach(todo => {\n    console.log(`  [${todo.completed ? '✓' : ' '}] ${todo.id}. ${todo.title}`);\n  });\n  \n  console.log('\\nFrontend State:');\n  console.log('  Todos displayed:', TodoApp.state.todos.length);\n  console.log('  Loading:', TodoApp.state.loading);\n  console.log('  Error:', TodoApp.state.error || 'none');\n}\n\nrunFullStackSimulation();\n```\n\n## Breaking Down the Syntax\n\nComplete full-stack implementation:\n\n**1. Database (Prisma Schema)**:\n```prisma\n// schema.prisma\nmodel Todo {\n  id        Int      @id @default(autoincrement())\n  title     String\n  completed Boolean  @default(false)\n  userId    Int\n  createdAt DateTime @default(now())\n}\n```\n\n**2. Backend (Express + Prisma)**:\n```javascript\n// server.js\nimport express from 'express';\nimport cors from 'cors';\nimport { PrismaClient } from '@prisma/client';\n\nconst app = express();\nconst prisma = new PrismaClient();\n\napp.use(cors());  // Enable CORS!\napp.use(express.json());\n\n// GET all todos\napp.get('/api/todos', async (req, res) => {\n  const todos = await prisma.todo.findMany({\n    where: { userId: req.user.id },\n    orderBy: { createdAt: 'desc' }\n  });\n  res.json(todos);\n});\n\n// POST new todo\napp.post('/api/todos', async (req, res) => {\n  const { title } = req.body;\n  \n  if (!title) {\n    return res.status(400).json({ error: 'Title required' });\n  }\n  \n  const todo = await prisma.todo.create({\n    data: { title, userId: req.user.id }\n  });\n  \n  res.status(201).json(todo);\n});\n\n// PATCH update todo\napp.patch('/api/todos/:id', async (req, res) => {\n  const { id } = req.params;\n  const { completed, title } = req.body;\n  \n  const todo = await prisma.todo.update({\n    where: { id: parseInt(id) },\n    data: { completed, title }\n  });\n  \n  res.json(todo);\n});\n\n// DELETE todo\napp.delete('/api/todos/:id', async (req, res) => {\n  const { id } = req.params;\n  \n  await prisma.todo.delete({\n    where: { id: parseInt(id) }\n  });\n  \n  res.json({ message: 'Deleted' });\n});\n\napp.listen(4000, () => {\n  console.log('API running on http://localhost:4000');\n});\n```\n\n**3. Frontend (React)**:\n```jsx\n// TodoApp.jsx\nimport { useState, useEffect } from 'react';\n\nconst API_URL = 'http://localhost:4000';\n\nfunction TodoApp() {\n  const [todos, setTodos] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [newTitle, setNewTitle] = useState('');\n  \n  // Fetch todos on mount\n  useEffect(() => {\n    fetchTodos();\n  }, []);\n  \n  async function fetchTodos() {\n    const res = await fetch(`${API_URL}/api/todos`);\n    const data = await res.json();\n    setTodos(data);\n    setLoading(false);\n  }\n  \n  async function addTodo(e) {\n    e.preventDefault();\n    \n    await fetch(`${API_URL}/api/todos`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ title: newTitle })\n    });\n    \n    setNewTitle('');\n    fetchTodos();\n  }\n  \n  async function toggleTodo(id, completed) {\n    await fetch(`${API_URL}/api/todos/${id}`, {\n      method: 'PATCH',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ completed: !completed })\n    });\n    \n    fetchTodos();\n  }\n  \n  async function deleteTodo(id) {\n    await fetch(`${API_URL}/api/todos/${id}`, {\n      method: 'DELETE'\n    });\n    \n    fetchTodos();\n  }\n  \n  if (loading) return <div>Loading...</div>;\n  \n  return (\n    <div>\n      <h1>My Todos</h1>\n      \n      <form onSubmit={addTodo}>\n        <input\n          value={newTitle}\n          onChange={(e) => setNewTitle(e.target.value)}\n          placeholder=\"New todo...\"\n        />\n        <button type=\"submit\">Add</button>\n      </form>\n      \n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id}>\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => toggleTodo(todo.id, todo.completed)}\n            />\n            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n              {todo.title}\n            </span>\n            <button onClick={() => deleteTodo(todo.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## Common Mistakes & Tips\n\nCommon full-stack integration mistakes:\n\n1. **Forgetting to enable CORS**:\n   ```javascript\n   // Backend missing:\n   app.use(cors());  // ← Add this!\n   ```\n\n2. **Wrong API URL**:\n   ```jsx\n   // Wrong!\n   fetch('localhost:4000/api/todos')  // Missing http://\n   \n   // Correct!\n   fetch('http://localhost:4000/api/todos')\n   \n   // Best!\n   const API_URL = import.meta.env.VITE_API_URL;\n   fetch(`${API_URL}/api/todos`);\n   ```\n\n3. **Not refreshing data after mutations**:\n   ```jsx\n   // Wrong! (UI doesn't update)\n   async function addTodo() {\n     await fetch('/api/todos', { method: 'POST', ... });\n     // Forgot to refresh!\n   }\n   \n   // Correct!\n   async function addTodo() {\n     await fetch('/api/todos', { method: 'POST', ... });\n     fetchTodos();  // Refresh the list!\n   }\n   ```\n\n4. **Not validating on backend**:\n   ```javascript\n   // NEVER trust frontend data!\n   app.post('/api/todos', async (req, res) => {\n     const { title } = req.body;\n     \n     // Validate!\n     if (!title || title.trim().length === 0) {\n       return res.status(400).json({ error: 'Title required' });\n     }\n     \n     // Now safe to create\n     const todo = await prisma.todo.create({ data: { title } });\n     res.json(todo);\n   });\n   ```\n\n5. **Hardcoded user IDs** (security issue!):\n   ```javascript\n   // Wrong! (any user can access any todo)\n   app.get('/api/todos', async (req, res) => {\n     const todos = await prisma.todo.findMany();\n     res.json(todos);\n   });\n   \n   // Correct! (filter by authenticated user)\n   app.get('/api/todos', async (req, res) => {\n     const todos = await prisma.todo.findMany({\n       where: { userId: req.user.id }  // From auth middleware\n     });\n     res.json(todos);\n   });\n   ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Build a simplified full-stack blog:\n\n1. Create a `database` object with:\n   - posts array with sample posts (id, title, content)\n   - findAll() method\n   - create(data) method\n\n2. Create a `backend` object with:\n   - handleGetPosts() - returns all posts\n   - handleCreatePost(title, content) - creates post\n\n3. Create a `BlogApp` object with:\n   - state: posts, loading\n   - fetchPosts() - calls backend\n   - createPost(title, content) - calls backend and refreshes\n\n4. Test the flow",
              "starterCode": "// Simplified blog system\n\nlet database = {\n  posts: [\n    { id: 1, title: 'First Post', content: 'Hello world!' },\n    { id: 2, title: 'Second Post', content: 'Learning full-stack!' }\n  ],\n  \n  findAll() {\n    console.log('[DB] SELECT * FROM posts');\n    return [...this.posts];\n  },\n  \n  create(data) {\n    console.log('[DB] INSERT INTO posts', data);\n    let post = { id: this.posts.length + 1, ...data };\n    this.posts.push(post);\n    return post;\n  }\n};\n\nlet backend = {\n  handleGetPosts() {\n    console.log('[API] GET /api/posts');\n    let posts = database.findAll();\n    return { status: 200, data: posts };\n  },\n  \n  handleCreatePost(title, content) {\n    console.log('[API] POST /api/posts');\n    let post = database.create({ title, content });\n    return { status: 201, data: post };\n  }\n};\n\nlet BlogApp = {\n  state: { posts: [], loading: false },\n  \n  setState(updates) {\n    this.state = { ...this.state, ...updates };\n    console.log('[App State]', this.state);\n  },\n  \n  async mount() {\n    console.log('[App] Mounting...');\n    await this.fetchPosts();\n  },\n  \n  async fetchPosts() {\n    console.log('[App] Fetching posts...');\n    this.setState({ loading: true });\n    \n    let response = backend.handleGetPosts();\n    this.setState({ posts: response.data, loading: false });\n  },\n  \n  async createPost(title, content) {\n    console.log(`[App] Creating post: ${title}`);\n    let response = backend.handleCreatePost(title, content);\n    console.log('[App] Post created, refreshing...');\n    await this.fetchPosts();\n  }\n};\n\n// Test\nconsole.log('=== Blog App Test ===\\n');\nBlogApp.mount().then(() => {\n  console.log('\\n[User] Clicks \"New Post\"');\n  BlogApp.createPost('Third Post', 'Full-stack is awesome!');\n});",
              "solution": "// See the codeExample above for complete solution with full CRUD operations",
              "hints": [
                "Follow the pattern: Frontend → Backend → Database → Backend → Frontend"
              ],
              "testCases": [
                {
                  "description": "Should fetch posts",
                  "input": "database.findAll().length",
                  "expectedOutput": "2"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "module-14",
      "title": "Module 14: Deployment & Professional Tools",
      "description": "Deploy your applications to production, use Git for version control, and adopt professional development practices",
      "difficulty": "advanced",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "lesson-14-14-1",
          "title": "Version Control with Git (The Time Machine Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Version Control with Git (The Time Machine Analogy)\n\n## Understanding the Concept\n\nImagine writing a book:\n\nWithout version control:\n- Save as: book_final.docx\n- Save as: book_final_v2.docx\n- Save as: book_final_v2_ACTUALLY_FINAL.docx\n- Save as: book_final_v2_ACTUALLY_FINAL_fixed.docx\n- Which one is the real final version?!\n- Want to go back to Tuesday's version? Good luck finding it!\n- Working with co-author? Email files back and forth (nightmare!)\n\nWith Git (version control):\n- One file: book.docx\n- Every save creates a snapshot (commit)\n- Can jump to ANY previous version instantly\n- See exactly what changed and when\n- Multiple authors work simultaneously\n- Automatic merging of changes\n- Complete history preserved forever\n\nGit is like a time machine for your code. It tracks every change, lets you experiment safely, and makes collaboration seamless!\n\n## Code Example\n\n```javascript\n// Git Concepts (Simulated)\n// Git is a command-line tool, not JavaScript, but let's understand the concepts!\n\nconsole.log('=== Git Version Control ===\\n');\n\n// CONCEPT 1: REPOSITORY - Project history\nlet repository = {\n  name: 'my-awesome-app',\n  commits: [],\n  currentBranch: 'main',\n  branches: ['main']\n};\n\nconsole.log('Repository:', repository.name);\n\n// CONCEPT 2: COMMIT - Snapshot of your code\nfunction commit(message, files) {\n  let snapshot = {\n    id: Math.random().toString(36).substr(2, 7),\n    message: message,\n    files: files,\n    timestamp: new Date().toISOString(),\n    author: 'You'\n  };\n  \n  repository.commits.push(snapshot);\n  console.log(`✓ Committed: \"${message}\" (${snapshot.id})`);\n  return snapshot;\n}\n\n// CONCEPT 3: BRANCH - Parallel version of code\nfunction createBranch(name) {\n  repository.branches.push(name);\n  console.log(`✓ Created branch: ${name}`);\n}\n\nfunction switchBranch(name) {\n  if (repository.branches.includes(name)) {\n    repository.currentBranch = name;\n    console.log(`✓ Switched to branch: ${name}`);\n  }\n}\n\n// SIMULATE GIT WORKFLOW\nconsole.log('\\n--- Simulating Git Workflow ---\\n');\n\n// 1. Initial commit\ncommit('Initial commit', ['index.html', 'app.js', 'styles.css']);\n\n// 2. Add feature\ncommit('Add user authentication', ['auth.js', 'login.html']);\n\n// 3. Fix bug\ncommit('Fix login button styling', ['styles.css']);\n\n// 4. Create feature branch\ncreate Branch('feature/dark-mode');\nswitchBranch('feature/dark-mode');\n\n// 5. Work on feature\ncommit('Add dark mode toggle', ['darkMode.js', 'styles.css']);\n\n// 6. Switch back to main\nswitchBranch('main');\n\nconsole.log('\\n--- Repository State ---');\nconsole.log('Total commits:', repository.commits.length);\nconsole.log('Branches:', repository.branches.join(', '));\nconsole.log('Current branch:', repository.currentBranch);\n\nconsole.log('\\n--- Commit History ---');\nrepository.commits.forEach((c, i) => {\n  console.log(`${i + 1}. [${c.id}] ${c.message}`);\n});\n\n// GIT COMMANDS REFERENCE\nconsole.log('\\n=== Essential Git Commands ===\\n');\n\nlet gitCommands = {\n  'git init': 'Create new Git repository',\n  'git clone <url>': 'Download existing repository',\n  'git status': 'See which files changed',\n  'git add <file>': 'Stage file for commit',\n  'git add .': 'Stage all changed files',\n  'git commit -m \"message\"': 'Save snapshot with message',\n  'git log': 'View commit history',\n  'git branch <name>': 'Create new branch',\n  'git checkout <branch>': 'Switch to branch',\n  'git merge <branch>': 'Merge branch into current',\n  'git pull': 'Download latest changes from remote',\n  'git push': 'Upload your commits to remote',\n  'git diff': 'See what changed in files'\n};\n\nfor (let [command, description] of Object.entries(gitCommands)) {\n  console.log(`${command.padEnd(30)} - ${description}`);\n}\n\n// TYPICAL WORKFLOW\nconsole.log('\\n=== Typical Git Workflow ===\\n');\n\nlet workflow = [\n  '1. Make changes to your code',\n  '2. git status               (see what changed)',\n  '3. git add .                (stage all changes)',\n  '4. git commit -m \"Add feature X\"  (save snapshot)',\n  '5. git push                 (upload to GitHub)',\n  '',\n  'Repeat for every feature/fix!'\n];\n\nworkflow.forEach(step => console.log(step));\n\nconsole.log('\\n--- Why Use Git? ---');\nlet benefits = [\n  '✓ Never lose code (complete history)',\n  '✓ Experiment safely (branches)',\n  '✓ Collaborate easily (merge changes)',\n  '✓ See who changed what and when',\n  '✓ Revert mistakes instantly',\n  '✓ Required by all professional teams',\n  '✓ Works with GitHub (code hosting)'\n];\n\nbenefits.forEach(b => console.log(b));\n```\n\n## Breaking Down the Syntax\n\nGit fundamentals:\n\n1. **Setting Up Git**:\n   ```bash\n   # Configure Git (one time)\n   git config --global user.name \"Your Name\"\n   git config --global user.email \"you@example.com\"\n   \n   # Create new repository\n   git init\n   \n   # Or clone existing\n   git clone https://github.com/username/repo.git\n   ```\n\n2. **Basic Workflow**:\n   ```bash\n   # 1. Check status\n   git status\n   \n   # 2. Stage changes\n   git add filename.js      # Single file\n   git add .                # All files\n   \n   # 3. Commit\n   git commit -m \"Add user login feature\"\n   \n   # 4. Push to remote (GitHub)\n   git push\n   ```\n\n3. **Branches**:\n   ```bash\n   # Create and switch to new branch\n   git checkout -b feature/new-feature\n   \n   # Switch between branches\n   git checkout main\n   git checkout feature/new-feature\n   \n   # Merge branch into current\n   git checkout main\n   git merge feature/new-feature\n   \n   # Delete branch\n   git branch -d feature/new-feature\n   ```\n\n4. **Viewing History**:\n   ```bash\n   # See commits\n   git log\n   git log --oneline    # Compact view\n   \n   # See changes\n   git diff             # Unstaged changes\n   git diff --staged    # Staged changes\n   ```\n\n5. **.gitignore** - Files to never commit:\n   ```\n   node_modules/\n   .env\n   .DS_Store\n   dist/\n   build/\n   *.log\n   ```\n\n6. **GitHub Workflow**:\n   ```bash\n   # First time setup\n   git remote add origin https://github.com/username/repo.git\n   git push -u origin main\n   \n   # Regular updates\n   git pull    # Download changes\n   git push    # Upload changes\n   ```\n\n7. **Commit Messages** (best practices):\n   - Start with verb: \"Add\", \"Fix\", \"Update\", \"Remove\"\n   - Be specific: \"Fix login button alignment\"\n   - Not vague: \"Fixed stuff\" or \"Changes\"\n   - Present tense: \"Add feature\" not \"Added feature\"\n\n## Common Mistakes & Tips\n\nCommon Git mistakes:\n\n1. **Forgetting to commit**:\n   ```bash\n   # Made lots of changes, forgot to commit\n   # Now have 50 files changed\n   # Hard to write one commit message!\n   \n   # Better: Commit after each feature\n   git add .\n   git commit -m \"Add user login\"\n   # Then continue coding\n   ```\n\n2. **Committing secrets**:\n   ```bash\n   # NEVER commit .env files!\n   # Add to .gitignore:\n   .env\n   .env.local\n   config/secrets.js\n   ```\n\n3. **Not using .gitignore**:\n   ```bash\n   # Don't commit node_modules!\n   # Create .gitignore file:\n   node_modules/\n   .DS_Store\n   dist/\n   *.log\n   ```\n\n4. **Merge conflicts** (scary but normal!):\n   ```\n   <<<<<<< HEAD\n   const API_URL = 'http://localhost:3000';\n   =======\n   const API_URL = 'https://api.production.com';\n   >>>>>>> feature-branch\n   ```\n   - Choose which version to keep\n   - Delete conflict markers (<<<<, ====, >>>>)\n   - Commit the resolved file\n\n5. **Wrong branch**:\n   ```bash\n   # Check current branch BEFORE committing!\n   git branch        # Shows all branches\n   git status        # Shows current branch\n   \n   # If on wrong branch:\n   git stash         # Save changes temporarily\n   git checkout correct-branch\n   git stash pop     # Apply changes here\n   ```\n\n6. **Push without pull**:\n   ```bash\n   # Error: Updates were rejected\n   # Someone else pushed while you were working\n   \n   # Fix:\n   git pull          # Get their changes\n   # Resolve conflicts if any\n   git push          # Now it works\n   ```\n\n7. **Vague commit messages**:\n   ```bash\n   # Bad:\n   git commit -m \"fixes\"\n   git commit -m \"stuff\"\n   git commit -m \"asdf\"\n   \n   # Good:\n   git commit -m \"Fix login button alignment on mobile\"\n   git commit -m \"Add password reset functionality\"\n   git commit -m \"Update dependencies to latest versions\"\n   ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Simulate a Git repository:\n\n1. Create a `repo` object with:\n   - commits array\n   - branches array (start with 'main')\n   - currentBranch property\n\n2. Create function `makeCommit(message)` that:\n   - Adds commit to commits array\n   - Returns commit object with: id, message, timestamp\n\n3. Create function `createBranch(name)` that:\n   - Adds branch to branches array\n\n4. Test by making 3 commits and creating 1 branch",
              "starterCode": "// Git repository simulation\nlet repo = {\n  commits: [],\n  branches: ['main'],\n  currentBranch: 'main'\n};\n\nfunction makeCommit(message) {\n  let commit = {\n    id: Math.random().toString(36).substr(2, 7),\n    message: message,\n    timestamp: new Date().toISOString()\n  };\n  repo.commits.push(commit);\n  console.log(`Committed: ${message} (${commit.id})`);\n  return commit;\n}\n\nfunction createBranch(name) {\n  repo.branches.push(name);\n  console.log(`Created branch: ${name}`);\n}\n\n// Test\nmakeCommit('Initial commit');\nmakeCommit('Add homepage');\nmakeCommit('Fix CSS');\ncreateBranch('feature/login');\n\nconsole.log('\\nRepository state:');\nconsole.log('Commits:', repo.commits.length);\nconsole.log('Branches:', repo.branches);",
              "solution": "// Complete Git simulation\nlet repo = {\n  commits: [],\n  branches: ['main'],\n  currentBranch: 'main',\n  files: {}\n};\n\nfunction makeCommit(message, files = []) {\n  let commit = {\n    id: Math.random().toString(36).substr(2, 7),\n    message: message,\n    branch: repo.currentBranch,\n    files: files,\n    timestamp: new Date().toISOString(),\n    author: 'Developer'\n  };\n  \n  repo.commits.push(commit);\n  console.log(`✓ [${commit.id}] ${message}`);\n  return commit;\n}\n\nfunction createBranch(name) {\n  if (repo.branches.includes(name)) {\n    console.log(`✗ Branch ${name} already exists`);\n    return false;\n  }\n  repo.branches.push(name);\n  console.log(`✓ Created branch: ${name}`);\n  return true;\n}\n\nfunction switchBranch(name) {\n  if (!repo.branches.includes(name)) {\n    console.log(`✗ Branch ${name} does not exist`);\n    return false;\n  }\n  repo.currentBranch = name;\n  console.log(`✓ Switched to branch: ${name}`);\n  return true;\n}\n\nfunction showLog() {\n  console.log('\\n=== Commit History ===');\n  repo.commits.forEach((c, i) => {\n    console.log(`${i + 1}. [${c.id}] (${c.branch}) ${c.message}`);\n    if (c.files.length > 0) {\n      console.log(`   Files: ${c.files.join(', ')}`);\n    }\n  });\n}\n\nfunction showStatus() {\n  console.log('\\n=== Repository Status ===');\n  console.log(`Current branch: ${repo.currentBranch}`);\n  console.log(`Total branches: ${repo.branches.join(', ')}`);\n  console.log(`Total commits: ${repo.commits.length}`);\n}\n\n// Simulate development workflow\nconsole.log('=== Git Workflow Simulation ===\\n');\n\nmakeCommit('Initial commit', ['README.md', 'package.json']);\nmakeCommit('Add Express server', ['server.js']);\nmakeCommit('Add database connection', ['db.js', 'prisma/schema.prisma']);\n\ncreateBranch('feature/authentication');\nswitchBranch('feature/authentication');\n\nmakeCommit('Add login route', ['routes/auth.js']);\nmakeCommit('Add JWT middleware', ['middleware/auth.js']);\n\nswitchBranch('main');\nmakeCommit('Update README', ['README.md']);\n\nshowLog();\nshowStatus();\n\nconsole.log('\\n--- Git Best Practices ---');\nlet practices = [\n  '✓ Commit often (small, focused commits)',\n  '✓ Write clear commit messages',\n  '✓ Use branches for features',\n  '✓ Never commit secrets (.env files)',\n  '✓ Pull before you push',\n  '✓ Review changes before committing (git diff)',\n  '✓ Use .gitignore for node_modules, etc.'\n];\npractices.forEach(p => console.log(p));",
              "hints": [
                "Use array push() to add commits and branches."
              ],
              "testCases": [
                {
                  "description": "Should track commits",
                  "input": "let commits = []; commits.push({ id: 1, msg: 'Test' }); commits.length",
                  "expectedOutput": "1"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-14-14-2",
          "title": "Deploying Express Backend to Render (The Restaurant Going Live Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Deploying Express Backend to Render (The Restaurant Going Live Analogy)\n\n## Understanding the Concept\n\nImagine opening a restaurant:\n\nDevelopment (your kitchen at home):\n- Cook and test recipes\n- Only you and friends eat the food\n- localhost:3000 (your home address)\n- Turn off stove → restaurant closes\n\nProduction (real restaurant):\n- Open to the public!\n- Anyone can visit and order\n- https://my-restaurant.com (real address)\n- Stays open 24/7 (even when you sleep)\n- Professional kitchen staff (hosting servers)\n\nDeploying your Express API is the same:\n- Move from localhost to real internet\n- Get a public URL (like render.com/yourapp)\n- Runs on powerful servers 24/7\n- Anyone can make requests to your API!\n\nPopular platforms: Render (free!), Railway, Heroku\n\n## Code Example\n\n```javascript\n// Deploying Express API - Concepts\n\nconsole.log('=== Express API Deployment ===\\n');\n\n// CONCEPT: Environment-aware server\nconst PORT = process.env.PORT || 3000;  // Use hosting platform's port\nconst NODE_ENV = process.env.NODE_ENV || 'development';\n\nconsole.log('Environment:', NODE_ENV);\nconsole.log('Port:', PORT);\n\n// Simulating Express app ready for deployment\nconst app = {\n  routes: [\n    { method: 'GET', path: '/api/users', handler: 'getUsers' },\n    { method: 'POST', path: '/api/users', handler: 'createUser' },\n    { method: 'GET', path: '/health', handler: 'healthCheck' }\n  ],\n  \n  config: {\n    cors: true,\n    port: PORT,\n    database: process.env.DATABASE_URL,\n    env: NODE_ENV\n  },\n  \n  listen(port) {\n    console.log(`\\n[Server] Listening on port ${port}`);\n    console.log(`[Server] Environment: ${this.config.env}`);\n    console.log(`[Server] CORS enabled: ${this.config.cors}`);\n    \n    if (this.config.env === 'production') {\n      console.log('\\n[Production Mode]');\n      console.log('  - Using DATABASE_URL from environment');\n      console.log('  - Detailed errors hidden from clients');\n      console.log('  - Compression enabled');\n      console.log('  - Security headers added');\n    } else {\n      console.log('\\n[Development Mode]');\n      console.log('  - Using local database');\n      console.log('  - Full error stack traces shown');\n      console.log('  - Hot reload enabled');\n    }\n  }\n};\n\napp.listen(PORT);\n\n// DEPLOYMENT STEPS SIMULATION\nconsole.log('\\n\\n=== Deployment Process ===\\n');\n\nconst deploymentSteps = [\n  {\n    step: 1,\n    title: 'Prepare Your Code',\n    tasks: [\n      'Add \"start\" script to package.json',\n      'Use environment variables (process.env)',\n      'Add .env to .gitignore',\n      'Commit and push to GitHub'\n    ]\n  },\n  {\n    step: 2,\n    title: 'Create Render Account',\n    tasks: [\n      'Go to render.com',\n      'Sign up with GitHub',\n      'Click \"New +\" → \"Web Service\"'\n    ]\n  },\n  {\n    step: 3,\n    title: 'Configure Service',\n    tasks: [\n      'Connect your GitHub repo',\n      'Name: my-api',\n      'Build Command: npm install',\n      'Start Command: npm start',\n      'Select Free plan'\n    ]\n  },\n  {\n    step: 4,\n    title: 'Add Environment Variables',\n    tasks: [\n      'Click \"Environment\"',\n      'Add DATABASE_URL',\n      'Add JWT_SECRET',\n      'Add other secrets from .env'\n    ]\n  },\n  {\n    step: 5,\n    title: 'Deploy!',\n    tasks: [\n      'Click \"Create Web Service\"',\n      'Wait for build (~2 minutes)',\n      'Get your URL: https://my-api.onrender.com',\n      'Test: https://my-api.onrender.com/health'\n    ]\n  }\n];\n\ndeploymentSteps.forEach(({ step, title, tasks }) => {\n  console.log(`Step ${step}: ${title}`);\n  tasks.forEach(task => console.log(`  - ${task}`));\n  console.log('');\n});\n\n// PACKAGE.JSON FOR DEPLOYMENT\nconsole.log('=== package.json Configuration ===\\n');\n\nconst packageJson = {\n  name: 'my-express-api',\n  version: '1.0.0',\n  scripts: {\n    start: 'node server.js',  // Production start command\n    dev: 'nodemon server.js',  // Development with auto-reload\n    build: 'echo \"No build needed for Express\"'\n  },\n  engines: {\n    node: '>=18.0.0'  // Specify Node version\n  },\n  dependencies: {\n    express: '^4.18.0',\n    cors: '^2.8.5',\n    dotenv: '^16.0.0'\n  }\n};\n\nconsole.log(JSON.stringify(packageJson, null, 2));\n\n// HEALTH CHECK ENDPOINT (important!)\nconsole.log('\\n\\n=== Health Check Endpoint ===\\n');\n\nconsole.log('// Add this to your server:');\nconsole.log(\"app.get('/health', (req, res) => {\");\nconsole.log(\"  res.json({\");\nconsole.log(\"    status: 'ok',\");\nconsole.log(\"    timestamp: new Date(),\");\nconsole.log(\"    uptime: process.uptime()\");\nconsole.log(\"  });\");\nconsole.log(\"});\\n\");\n\nconsole.log('Why? Hosting platforms ping /health to check if app is running!');\n\n// TESTING DEPLOYMENT\nconsole.log('\\n\\n=== Testing Your Deployed API ===\\n');\n\nconst tests = [\n  {\n    test: 'Health Check',\n    command: 'curl https://my-api.onrender.com/health',\n    expected: '{ status: \"ok\" }'\n  },\n  {\n    test: 'GET Request',\n    command: 'curl https://my-api.onrender.com/api/users',\n    expected: '[{ id: 1, name: \"Alice\" }, ...]'\n  },\n  {\n    test: 'POST Request',\n    command: 'curl -X POST https://my-api.onrender.com/api/users -d {\"name\":\"Bob\"}',\n    expected: '{ id: 2, name: \"Bob\" }'\n  }\n];\n\ntests.forEach(({ test, command, expected }) => {\n  console.log(`${test}:`);\n  console.log(`  $ ${command}`);\n  console.log(`  Expected: ${expected}\\n`);\n});\n```\n\n## Breaking Down the Syntax\n\nExpress deployment checklist:\n\n1. **Environment Variables** (CRITICAL!):\n   ```javascript\n   // server.js\n   import 'dotenv/config';  // Load .env file\n   \n   const PORT = process.env.PORT || 3000;\n   const DATABASE_URL = process.env.DATABASE_URL;\n   const JWT_SECRET = process.env.JWT_SECRET;\n   \n   // NEVER hardcode secrets!\n   // WRONG: const secret = 'my-secret-key';\n   // RIGHT: const secret = process.env.JWT_SECRET;\n   ```\n\n2. **package.json Scripts**:\n   ```json\n   {\n     \"scripts\": {\n       \"start\": \"node server.js\",\n       \"dev\": \"nodemon server.js\"\n     },\n     \"engines\": {\n       \"node\": \">=18.0.0\"\n     }\n   }\n   ```\n\n3. **Server Listen** (use process.env.PORT):\n   ```javascript\n   const PORT = process.env.PORT || 3000;\n   \n   app.listen(PORT, () => {\n     console.log(`Server running on port ${PORT}`);\n   });\n   ```\n\n4. **CORS Configuration** (allow frontend):\n   ```javascript\n   import cors from 'cors';\n   \n   const allowedOrigins = [\n     'https://my-frontend.vercel.app',\n     'http://localhost:5173'  // For local dev\n   ];\n   \n   app.use(cors({\n     origin: allowedOrigins,\n     credentials: true\n   }));\n   ```\n\n5. **Health Check Endpoint**:\n   ```javascript\n   app.get('/health', (req, res) => {\n     res.json({ status: 'ok', timestamp: new Date() });\n   });\n   ```\n\n6. **.gitignore** (don't commit secrets!):\n   ```\n   node_modules/\n   .env\n   .env.local\n   .env.production\n   dist/\n   *.log\n   ```\n\n7. **Database Connection** (production-ready):\n   ```javascript\n   import { PrismaClient } from '@prisma/client';\n   \n   const prisma = new PrismaClient({\n     datasources: {\n       db: {\n         url: process.env.DATABASE_URL  // From Render env vars\n       }\n     }\n   });\n   ```\n\n8. **Error Handling** (hide details in production):\n   ```javascript\n   app.use((err, req, res, next) => {\n     console.error(err.stack);\n     \n     if (process.env.NODE_ENV === 'production') {\n       res.status(500).json({ error: 'Internal server error' });\n     } else {\n       res.status(500).json({ error: err.message, stack: err.stack });\n     }\n   });\n   ```\n\n## Common Mistakes & Tips\n\nCommon deployment mistakes:\n\n1. **Hardcoded PORT** (will crash!):\n   ```javascript\n   // WRONG! Render assigns random port\n   app.listen(3000);  // ✗ Will fail on Render\n   \n   // CORRECT!\n   const PORT = process.env.PORT || 3000;\n   app.listen(PORT);  // ✓ Works everywhere\n   ```\n\n2. **Committed .env file** (security risk!):\n   ```bash\n   # .gitignore MUST include:\n   .env\n   .env.local\n   .env.production\n   \n   # Check if accidentally committed:\n   git ls-files | grep .env  # Should be empty!\n   ```\n\n3. **Missing start script**:\n   ```json\n   // WRONG! (package.json)\n   {\n     \"scripts\": {\n       \"dev\": \"nodemon server.js\"\n       // No \"start\" script!\n     }\n   }\n   \n   // CORRECT!\n   {\n     \"scripts\": {\n       \"start\": \"node server.js\",\n       \"dev\": \"nodemon server.js\"\n     }\n   }\n   ```\n\n4. **CORS not configured for production frontend**:\n   ```javascript\n   // WRONG! Blocks your frontend\n   app.use(cors({\n     origin: 'http://localhost:5173'  // Only allows local!\n   }));\n   \n   // CORRECT!\n   const allowedOrigins = [\n     'https://my-app.vercel.app',  // Production frontend\n     'http://localhost:5173'       // Local development\n   ];\n   \n   app.use(cors({\n     origin: (origin, callback) => {\n       if (!origin || allowedOrigins.includes(origin)) {\n         callback(null, true);\n       } else {\n         callback(new Error('Not allowed by CORS'));\n       }\n     }\n   }));\n   ```\n\n5. **Database URL not from environment**:\n   ```javascript\n   // WRONG! Won't work in production\n   const db = 'postgresql://localhost/mydb';\n   \n   // CORRECT!\n   const db = process.env.DATABASE_URL || 'postgresql://localhost/mydb';\n   ```\n\n6. **Missing health check** (Render needs this!):\n   ```javascript\n   // Add this route:\n   app.get('/health', (req, res) => {\n     res.json({ status: 'ok' });\n   });\n   \n   // Render pings this to check if server is alive\n   ```\n\n7. **Exposing secrets in errors**:\n   ```javascript\n   // WRONG! Leaks sensitive info\n   app.use((err, req, res, next) => {\n     res.status(500).json({ error: err.stack });  // Shows DB passwords!\n   });\n   \n   // CORRECT!\n   app.use((err, req, res, next) => {\n     console.error(err.stack);  // Log server-side only\n     \n     if (process.env.NODE_ENV === 'production') {\n       res.status(500).json({ error: 'Internal server error' });\n     } else {\n       res.status(500).json({ error: err.message });\n     }\n   });\n   ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Prepare an Express server for deployment:\n\n1. Create a `server` object that:\n   - Uses process.env.PORT with fallback to 3000\n   - Has a /health route\n   - Logs startup info\n   - Shows different behavior for production vs development\n\n2. Simulate starting the server in both environments",
              "starterCode": "// Express server ready for deployment\n\nconst server = {\n  port: process.env.PORT || 3000,\n  env: process.env.NODE_ENV || 'development',\n  \n  routes: {\n    '/health': function() {\n      return { status: 'ok', timestamp: new Date() };\n    },\n    '/api/users': function() {\n      return [{ id: 1, name: 'Alice' }];\n    }\n  },\n  \n  start() {\n    console.log(`\\n[Server] Starting...`);\n    console.log(`[Server] Environment: ${this.env}`);\n    console.log(`[Server] Port: ${this.port}`);\n    \n    if (this.env === 'production') {\n      console.log('[Server] Running in PRODUCTION mode');\n      console.log('  - Detailed errors hidden');\n      console.log('  - Using production database');\n    } else {\n      console.log('[Server] Running in DEVELOPMENT mode');\n      console.log('  - Full error traces enabled');\n      console.log('  - Using local database');\n    }\n    \n    console.log(`\\n✓ Server ready on port ${this.port}`);\n    console.log(`\\nAvailable routes:`);\n    Object.keys(this.routes).forEach(route => {\n      console.log(`  - ${route}`);\n    });\n  }\n};\n\n// Test\nserver.start();\n\n// Simulate health check\nconsole.log('\\n[Test] GET /health');\nconsole.log('Response:', server.routes['/health']());",
              "solution": "// Complete production-ready Express server\n\nconst server = {\n  port: process.env.PORT || 3000,\n  env: process.env.NODE_ENV || 'development',\n  databaseUrl: process.env.DATABASE_URL || 'postgres://localhost/mydb',\n  jwtSecret: process.env.JWT_SECRET || 'dev-secret',\n  \n  routes: {\n    '/health': function() {\n      return {\n        status: 'ok',\n        timestamp: new Date(),\n        uptime: process.uptime(),\n        environment: server.env\n      };\n    },\n    '/api/users': function() {\n      return [\n        { id: 1, name: 'Alice', email: 'alice@example.com' },\n        { id: 2, name: 'Bob', email: 'bob@example.com' }\n      ];\n    },\n    '/api/status': function() {\n      return {\n        server: 'Express API',\n        version: '1.0.0',\n        environment: server.env,\n        database: server.databaseUrl ? 'Connected' : 'Disconnected'\n      };\n    }\n  },\n  \n  middleware: {\n    cors: function() {\n      console.log('[Middleware] CORS enabled');\n      console.log('  Allowed origins: https://my-app.vercel.app, http://localhost:5173');\n    },\n    \n    compression: function() {\n      if (server.env === 'production') {\n        console.log('[Middleware] Compression enabled (gzip)');\n      }\n    },\n    \n    security: function() {\n      if (server.env === 'production') {\n        console.log('[Middleware] Security headers added:');\n        console.log('  - helmet (security headers)');\n        console.log('  - rate limiting');\n        console.log('  - XSS protection');\n      }\n    }\n  },\n  \n  start() {\n    console.log('┌─────────────────────────────────────┐');\n    console.log('│       Express Server Starting       │');\n    console.log('└─────────────────────────────────────┘\\n');\n    \n    console.log(`Environment: ${this.env}`);\n    console.log(`Port: ${this.port}`);\n    console.log(`Database: ${this.databaseUrl}\\n`);\n    \n    // Load middleware\n    console.log('Loading middleware:');\n    this.middleware.cors();\n    this.middleware.compression();\n    this.middleware.security();\n    \n    console.log('\\n' + '─'.repeat(39));\n    \n    if (this.env === 'production') {\n      console.log('\\n🚀 PRODUCTION MODE');\n      console.log('  ✓ Using production database');\n      console.log('  ✓ Errors hidden from clients');\n      console.log('  ✓ Compression enabled');\n      console.log('  ✓ Security headers active');\n      console.log('  ✓ Rate limiting enabled');\n    } else {\n      console.log('\\n🔧 DEVELOPMENT MODE');\n      console.log('  ⚠ Using local database');\n      console.log('  ⚠ Full error stack traces');\n      console.log('  ⚠ No compression');\n      console.log('  ⚠ Hot reload enabled');\n    }\n    \n    console.log('\\n' + '─'.repeat(39));\n    console.log(`\\n✓ Server ready at http://localhost:${this.port}`);\n    \n    if (this.env === 'production') {\n      console.log(`✓ Public URL: https://my-api.onrender.com`);\n    }\n    \n    console.log('\\nAvailable Endpoints:');\n    Object.keys(this.routes).forEach(route => {\n      console.log(`  - ${route}`);\n    });\n    \n    console.log('\\n' + '═'.repeat(39) + '\\n');\n  },\n  \n  handleRequest(path) {\n    console.log(`\\n[Request] GET ${path}`);\n    \n    if (this.routes[path]) {\n      const response = this.routes[path]();\n      console.log('[Response] 200 OK');\n      console.log(JSON.stringify(response, null, 2));\n      return response;\n    } else {\n      console.log('[Response] 404 Not Found');\n      return { error: 'Route not found' };\n    }\n  }\n};\n\n// Simulate deployment\nconsole.log('=== Simulating Deployment ===\\n');\n\n// Development\nconsole.log('1. LOCAL DEVELOPMENT:\\n');\nprocess.env.NODE_ENV = 'development';\nserver.start();\n\nserver.handleRequest('/health');\nserver.handleRequest('/api/users');\n\n// Production\nconsole.log('\\n\\n2. PRODUCTION DEPLOYMENT:\\n');\nprocess.env.NODE_ENV = 'production';\nprocess.env.PORT = 10000;\nprocess.env.DATABASE_URL = 'postgres://render.com/prod-db';\nserver.port = process.env.PORT;\nserver.env = process.env.NODE_ENV;\nserver.databaseUrl = process.env.DATABASE_URL;\n\nserver.start();\n\nserver.handleRequest('/health');\nserver.handleRequest('/api/status');\n\nconsole.log('\\n=== Deployment Checklist ===\\n');\n\nconst checklist = [\n  '✓ Set NODE_ENV=production',\n  '✓ Use process.env.PORT',\n  '✓ Add health check endpoint',\n  '✓ Configure CORS for frontend URL',\n  '✓ Add environment variables in Render',\n  '✓ Never commit .env files',\n  '✓ Add \"start\" script to package.json',\n  '✓ Test deployed API with curl/Postman'\n];\n\nchecklist.forEach(item => console.log(item));",
              "hints": [
                "Use process.env.PORT and process.env.NODE_ENV"
              ],
              "testCases": [
                {
                  "description": "Should use PORT from environment",
                  "input": "process.env.PORT = 8080; process.env.PORT || 3000",
                  "expectedOutput": "8080"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-14-14-3",
          "title": "Deploying React Frontend to Vercel (The Storefront Going Live Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Deploying React Frontend to Vercel (The Storefront Going Live Analogy)\n\n## Understanding the Concept\n\nImagine opening a physical store:\n\nDevelopment (building in your garage):\n- Test the store layout\n- Only you can see it\n- localhost:5173 (your garage address)\n- Close garage door → store disappears\n\nProduction (real storefront on Main Street):\n- Open to the public!\n- Anyone can visit from anywhere\n- https://my-store.vercel.app (real address)\n- Open 24/7 (never closes)\n- Professional hosting (like a shopping mall)\n\nDeploying your React app is the same:\n- Move from localhost to real internet\n- Build optimized version (Vite build)\n- Get a public URL (vercel.app or netlify.app)\n- Hosted on fast servers worldwide (CDN)\n- Connects to your deployed API!\n\nPopular platforms: Vercel (made by Next.js creators, free!), Netlify, Cloudflare Pages\n\n## Code Example\n\n```javascript\n// Deploying React Frontend - Concepts\n\nconsole.log('=== React Frontend Deployment ===\\n');\n\n// CONCEPT: Build Process\nconst buildProcess = {\n  name: 'Vite Build',\n  \n  steps: [\n    'Read all your React components',\n    'Bundle JavaScript into optimized files',\n    'Minify code (remove whitespace, shorten names)',\n    'Optimize images and assets',\n    'Generate index.html',\n    'Output to dist/ folder'\n  ],\n  \n  before: {\n    files: ['src/App.jsx', 'src/components/*.jsx', 'src/main.jsx'],\n    size: '2.5 MB (readable code)'\n  },\n  \n  after: {\n    files: ['dist/index.html', 'dist/assets/index-a3b4c5d6.js', 'dist/assets/index-e7f8g9h0.css'],\n    size: '150 KB (minified and optimized!)'\n  },\n  \n  run() {\n    console.log('🔨 Building React app...\\n');\n    this.steps.forEach((step, i) => {\n      console.log(`  ${i + 1}. ${step}`);\n    });\n    console.log('\\n📦 Before build:');\n    console.log(`  Files: ${this.before.files.join(', ')}`);\n    console.log(`  Size: ${this.before.size}`);\n    console.log('\\n✅ After build:');\n    console.log(`  Files: ${this.after.files.join(', ')}`);\n    console.log(`  Size: ${this.after.size}`);\n    console.log('\\n✓ Build complete! Ready to deploy.');\n  }\n};\n\nbuildProcess.run();\n\n// CONCEPT: Environment Variables\nconsole.log('\\n\\n=== Environment Variables ===\\n');\n\nconst environmentConfig = {\n  development: {\n    API_URL: 'http://localhost:3000',\n    DEBUG: 'true'\n  },\n  \n  production: {\n    API_URL: 'https://my-api.onrender.com',\n    DEBUG: 'false'\n  },\n  \n  showConfig(env) {\n    console.log(`${env.toUpperCase()} Environment:`);\n    const config = this[env];\n    for (let [key, value] of Object.entries(config)) {\n      console.log(`  VITE_${key} = \"${value}\"`);\n    }\n  }\n};\n\nconsole.log('Local development:');\nenvironmentConfig.showConfig('development');\n\nconsole.log('\\nProduction deployment:');\nenvironmentConfig.showConfig('production');\n\nconsole.log('\\nIn your React code:');\nconsole.log(\"const API_URL = import.meta.env.VITE_API_URL;\");\nconsole.log(\"fetch(`${API_URL}/api/users`);\\n\");\n\n// DEPLOYMENT STEPS SIMULATION\nconsole.log('\\n=== Deployment Process (Vercel) ===\\n');\n\nconst deploymentSteps = [\n  {\n    step: 1,\n    title: 'Prepare Your React App',\n    tasks: [\n      'Update API URL to use environment variable',\n      'Test build locally: npm run build',\n      'Add .env to .gitignore',\n      'Commit and push to GitHub'\n    ]\n  },\n  {\n    step: 2,\n    title: 'Create Vercel Account',\n    tasks: [\n      'Go to vercel.com',\n      'Sign up with GitHub',\n      'Click \"Add New\" → \"Project\"'\n    ]\n  },\n  {\n    step: 3,\n    title: 'Import Repository',\n    tasks: [\n      'Select your GitHub repo',\n      'Framework Preset: Vite (auto-detected)',\n      'Root Directory: ./ (or your frontend folder)',\n      'Build Command: npm run build',\n      'Output Directory: dist'\n    ]\n  },\n  {\n    step: 4,\n    title: 'Configure Environment Variables',\n    tasks: [\n      'Click \"Environment Variables\"',\n      'Add: VITE_API_URL = https://my-api.onrender.com',\n      'Add any other VITE_ prefixed variables'\n    ]\n  },\n  {\n    step: 5,\n    title: 'Deploy!',\n    tasks: [\n      'Click \"Deploy\"',\n      'Wait for build (~1 minute)',\n      'Get your URL: https://my-app.vercel.app',\n      'Test: Open URL and check if it connects to API'\n    ]\n  },\n  {\n    step: 6,\n    title: 'Update Backend CORS',\n    tasks: [\n      'Add your Vercel URL to backend CORS',\n      \"In Express: allowedOrigins.push('https://my-app.vercel.app')\",\n      'Redeploy backend',\n      'Test frontend → backend connection'\n    ]\n  }\n];\n\ndeploymentSteps.forEach(({ step, title, tasks }) => {\n  console.log(`Step ${step}: ${title}`);\n  tasks.forEach(task => console.log(`  - ${task}`));\n  console.log('');\n});\n\n// SIMULATING DEPLOYMENT\nconsole.log('=== Simulating Frontend Deployment ===\\n');\n\nconst deployment = {\n  platform: 'Vercel',\n  project: 'my-react-app',\n  url: 'https://my-react-app.vercel.app',\n  status: 'Building',\n  \n  logs: [\n    '[1/6] Cloning repository from GitHub...',\n    '[2/6] Installing dependencies (npm install)...',\n    '[3/6] Building project (npm run build)...',\n    '  ✓ 1247 modules transformed',\n    '  ✓ Built in 8.3s',\n    '[4/6] Optimizing assets...',\n    '  ✓ Images optimized: 12 files',\n    '  ✓ JavaScript minified: 145 KB → 48 KB',\n    '[5/6] Deploying to global CDN...',\n    '[6/6] Assigning domains...',\n    '',\n    '✅ Deployment successful!',\n    '🌐 https://my-react-app.vercel.app',\n    '⚡ Served from 100+ edge locations worldwide'\n  ],\n  \n  deploy() {\n    console.log(`Deploying ${this.project} to ${this.platform}...\\n`);\n    this.logs.forEach(log => {\n      console.log(log);\n    });\n    console.log(`\\n✓ Live at: ${this.url}`);\n    this.status = 'Live';\n  },\n  \n  stats() {\n    console.log('\\n=== Deployment Stats ===\\n');\n    console.log('Status:', this.status);\n    console.log('Platform:', this.platform);\n    console.log('Build time: 8.3 seconds');\n    console.log('Deploy time: 12 seconds');\n    console.log('Total size: 48 KB (gzipped)');\n    console.log('CDN locations: 100+');\n    console.log('SSL: Enabled (HTTPS)');\n    console.log('Auto-deploy: Enabled (push to main → auto deploy)');\n  }\n};\n\ndeployment.deploy();\ndeployment.stats();\n\n// AUTO-DEPLOYMENT\nconsole.log('\\n\\n=== Auto-Deployment Workflow ===\\n');\n\nconst autoDeploySteps = [\n  '1. You push code to GitHub (git push)',\n  '2. Vercel detects the push',\n  '3. Automatically runs build',\n  '4. Deploys new version',\n  '5. Updates live site',\n  '',\n  '⚡ Total time: ~1 minute from push to live!'\n];\n\nautoDeploySteps.forEach(step => console.log(step));\n```\n\n## Breaking Down the Syntax\n\nReact deployment configuration:\n\n1. **Environment Variables** (VITE_ prefix required!):\n   ```javascript\n   // .env.local (development)\n   VITE_API_URL=http://localhost:3000\n   VITE_DEBUG=true\n   \n   // In Vercel dashboard (production)\n   VITE_API_URL=https://my-api.onrender.com\n   VITE_DEBUG=false\n   ```\n   \n   ```javascript\n   // Using in React code\n   const API_URL = import.meta.env.VITE_API_URL;\n   \n   fetch(`${API_URL}/api/users`)\n     .then(res => res.json())\n     .then(data => console.log(data));\n   ```\n\n2. **vite.config.js** (usually default is fine):\n   ```javascript\n   import { defineConfig } from 'vite';\n   import react from '@vitejs/plugin-react';\n   \n   export default defineConfig({\n     plugins: [react()],\n     build: {\n       outDir: 'dist',  // Output folder\n       sourcemap: false  // Don't include source maps in production\n     }\n   });\n   ```\n\n3. **Build Command**:\n   ```bash\n   # Test build locally first!\n   npm run build\n   \n   # Creates dist/ folder with:\n   # - index.html\n   # - assets/index-[hash].js\n   # - assets/index-[hash].css\n   \n   # Preview build locally\n   npm run preview\n   # Opens http://localhost:4173\n   ```\n\n4. **package.json Scripts**:\n   ```json\n   {\n     \"scripts\": {\n       \"dev\": \"vite\",\n       \"build\": \"vite build\",\n       \"preview\": \"vite preview\"\n     }\n   }\n   ```\n\n5. **Connecting to Backend API**:\n   ```javascript\n   // src/config/api.js\n   const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000';\n   \n   export async function fetchUsers() {\n     const response = await fetch(`${API_URL}/api/users`);\n     return response.json();\n   }\n   \n   export async function createUser(userData) {\n     const response = await fetch(`${API_URL}/api/users`, {\n       method: 'POST',\n       headers: { 'Content-Type': 'application/json' },\n       body: JSON.stringify(userData)\n     });\n     return response.json();\n   }\n   ```\n\n6. **Update Backend CORS** (CRITICAL!):\n   ```javascript\n   // Express backend server.js\n   const allowedOrigins = [\n     'https://my-app.vercel.app',      // Your Vercel URL\n     'https://my-app-git-*.vercel.app', // Preview deployments\n     'http://localhost:5173'            // Local dev\n   ];\n   \n   app.use(cors({\n     origin: allowedOrigins,\n     credentials: true\n   }));\n   ```\n\n7. **Vercel Configuration** (optional vercel.json):\n   ```json\n   {\n     \"buildCommand\": \"npm run build\",\n     \"outputDirectory\": \"dist\",\n     \"rewrites\": [\n       {\n         \"source\": \"/(.*)\",\n         \"destination\": \"/index.html\"\n       }\n     ]\n   }\n   ```\n   The `rewrites` rule handles client-side routing (React Router).\n\n8. **.gitignore** (don't commit build folder!):\n   ```\n   node_modules/\n   dist/\n   .env\n   .env.local\n   .env.production\n   .vercel\n   ```\n\n## Common Mistakes & Tips\n\nCommon React deployment mistakes:\n\n1. **Wrong environment variable prefix**:\n   ```javascript\n   // WRONG! Won't work in Vite\n   const API_URL = process.env.REACT_APP_API_URL;  // ✗\n   const API_URL = process.env.API_URL;             // ✗\n   \n   // CORRECT for Vite!\n   const API_URL = import.meta.env.VITE_API_URL;   // ✓\n   ```\n\n2. **Hardcoded API URL**:\n   ```javascript\n   // WRONG! Won't work after deployment\n   fetch('http://localhost:3000/api/users');  // ✗\n   \n   // CORRECT!\n   const API_URL = import.meta.env.VITE_API_URL;\n   fetch(`${API_URL}/api/users`);  // ✓\n   ```\n\n3. **Forgot to add env vars in Vercel dashboard**:\n   ```\n   Error: import.meta.env.VITE_API_URL is undefined\n   \n   Fix:\n   1. Go to Vercel project settings\n   2. Environment Variables\n   3. Add: VITE_API_URL = https://my-api.onrender.com\n   4. Redeploy\n   ```\n\n4. **Backend CORS not updated**:\n   ```javascript\n   // Error in browser console:\n   // \"Access to fetch at 'https://api.com' from origin 'https://my-app.vercel.app' \n   // has been blocked by CORS policy\"\n   \n   // Fix in Express backend:\n   const allowedOrigins = [\n     'https://my-app.vercel.app',  // Add this!\n     'http://localhost:5173'\n   ];\n   \n   app.use(cors({ origin: allowedOrigins }));\n   ```\n\n5. **Build folder committed to Git**:\n   ```bash\n   # .gitignore should include:\n   dist/\n   build/\n   .vercel/\n   \n   # If accidentally committed:\n   git rm -r --cached dist\n   git commit -m \"Remove dist folder\"\n   ```\n\n6. **Wrong build output directory**:\n   ```\n   # Vercel settings:\n   Build Command: npm run build\n   Output Directory: dist    ← Must match Vite's output!\n   \n   # Vite outputs to dist/ by default\n   # If you changed it in vite.config.js, update Vercel settings\n   ```\n\n7. **Client-side routing 404 errors**:\n   ```\n   Problem: Refreshing /about gives 404 error\n   \n   Solution: Add vercel.json:\n   {\n     \"rewrites\": [\n       { \"source\": \"/(.*)\", \"destination\": \"/index.html\" }\n     ]\n   }\n   \n   This tells Vercel to serve index.html for all routes\n   (React Router handles routing on the client)\n   ```\n\n8. **Mixed content warning (HTTP/HTTPS)**:\n   ```javascript\n   // WRONG! Frontend is HTTPS, API is HTTP\n   VITE_API_URL=http://my-api.com  // ✗ Browser blocks this!\n   \n   // CORRECT! Both must be HTTPS\n   VITE_API_URL=https://my-api.com  // ✓\n   ```\n\n9. **Environment variables not rebuilding**:\n   ```\n   Changed VITE_API_URL but still seeing old value?\n   \n   Fix:\n   1. Environment vars are baked into build at build time\n   2. Must trigger new deployment after changing them\n   3. In Vercel: Deployments → Redeploy\n   ```\n\n10. **Forgot to test production build locally**:\n    ```bash\n    # Always test before deploying!\n    npm run build      # Build for production\n    npm run preview    # Preview the build locally\n    \n    # Open http://localhost:4173 and test everything\n    # Make sure API calls work!\n    ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Prepare a React app for deployment:\n\n1. Create a `frontendApp` object that:\n   - Has development and production API URLs\n   - Simulates build process\n   - Shows environment-specific configuration\n\n2. Create a `buildApp()` function that:\n   - Shows build steps\n   - Outputs stats (file size, optimization)\n\n3. Test building for both environments",
              "starterCode": "// React app deployment simulation\n\nconst frontendApp = {\n  name: 'My React App',\n  \n  env: {\n    development: {\n      API_URL: 'http://localhost:3000',\n      NODE_ENV: 'development'\n    },\n    production: {\n      API_URL: 'https://my-api.onrender.com',\n      NODE_ENV: 'production'\n    }\n  },\n  \n  build(environment) {\n    console.log(`\\n🔨 Building for ${environment}...\\n`);\n    \n    const config = this.env[environment];\n    console.log('Environment variables:');\n    console.log(`  VITE_API_URL=${config.API_URL}`);\n    console.log(`  NODE_ENV=${config.NODE_ENV}\\n`);\n    \n    console.log('Build steps:');\n    console.log('  1. Bundling React components');\n    console.log('  2. Minifying JavaScript');\n    console.log('  3. Optimizing assets');\n    console.log('  4. Generating index.html\\n');\n    \n    if (environment === 'production') {\n      console.log('✓ Production optimizations applied');\n      console.log('  - Code minified');\n      console.log('  - Source maps removed');\n      console.log('  - Tree-shaking applied\\n');\n    }\n    \n    console.log('✅ Build complete!');\n    console.log(`   Output: dist/`);\n    console.log(`   Ready to deploy to Vercel\\n`);\n  }\n};\n\n// Test\nfrontendApp.build('development');\nfrontendApp.build('production');",
              "solution": "// Complete React deployment simulation\n\nconst frontendApp = {\n  name: 'My React App',\n  version: '1.0.0',\n  \n  env: {\n    development: {\n      VITE_API_URL: 'http://localhost:3000',\n      VITE_DEBUG: 'true',\n      NODE_ENV: 'development'\n    },\n    production: {\n      VITE_API_URL: 'https://my-api.onrender.com',\n      VITE_DEBUG: 'false',\n      NODE_ENV: 'production'\n    }\n  },\n  \n  files: {\n    source: [\n      'src/App.jsx',\n      'src/components/UserList.jsx',\n      'src/components/LoginForm.jsx',\n      'src/main.jsx',\n      'src/styles.css'\n    ],\n    sourceSize: 2500,  // KB\n    \n    built: [\n      'dist/index.html',\n      'dist/assets/index-a3b4c5d6.js',\n      'dist/assets/index-e7f8g9h0.css'\n    ],\n    builtSize: 145  // KB after optimization\n  },\n  \n  build(environment) {\n    console.log('┌─────────────────────────────────────┐');\n    console.log('│       Building React App            │');\n    console.log('└─────────────────────────────────────┘\\n');\n    \n    console.log(`Environment: ${environment}`);\n    console.log(`Version: ${this.version}\\n`);\n    \n    const config = this.env[environment];\n    console.log('Environment Variables:');\n    Object.entries(config).forEach(([key, value]) => {\n      if (key.startsWith('VITE_')) {\n        console.log(`  ${key}=${value}`);\n      }\n    });\n    \n    console.log('\\n' + '─'.repeat(39));\n    console.log('\\nBuild Process:\\n');\n    \n    const steps = [\n      { name: 'Analyzing dependencies', time: 0.5 },\n      { name: 'Bundling React components', time: 2.1 },\n      { name: 'Transpiling JSX to JavaScript', time: 1.3 },\n      { name: 'Minifying JavaScript', time: 1.8 },\n      { name: 'Optimizing CSS', time: 0.7 },\n      { name: 'Compressing images', time: 0.9 },\n      { name: 'Generating index.html', time: 0.2 }\n    ];\n    \n    steps.forEach((step, i) => {\n      console.log(`  ${i + 1}. ${step.name.padEnd(35)} ${step.time}s`);\n    });\n    \n    const totalTime = steps.reduce((sum, s) => sum + s.time, 0);\n    console.log(`\\n  Total build time: ${totalTime.toFixed(1)}s`);\n    \n    console.log('\\n' + '─'.repeat(39));\n    \n    if (environment === 'production') {\n      console.log('\\n🚀 Production Optimizations:\\n');\n      const optimizations = [\n        'Code splitting enabled',\n        'Tree-shaking applied (removed unused code)',\n        'Minification: 2500 KB → 145 KB',\n        'Gzip compression ready',\n        'Source maps removed',\n        'Image optimization: 85% quality',\n        'CSS purged (unused styles removed)'\n      ];\n      optimizations.forEach(opt => console.log(`  ✓ ${opt}`));\n    } else {\n      console.log('\\n🔧 Development Build:\\n');\n      const devFeatures = [\n        'Source maps included',\n        'Hot module replacement enabled',\n        'Readable code (not minified)',\n        'Detailed error messages'\n      ];\n      devFeatures.forEach(feat => console.log(`  ✓ ${feat}`));\n    }\n    \n    console.log('\\n' + '─'.repeat(39));\n    console.log('\\n✅ Build Complete!\\n');\n    console.log('Output Directory: dist/');\n    console.log('Files generated:');\n    this.files.built.forEach(file => {\n      console.log(`  - ${file}`);\n    });\n    console.log(`\\nTotal size: ${this.files.builtSize} KB`);\n    \n    if (environment === 'production') {\n      console.log(`Compression: ${this.files.sourceSize} KB → ${this.files.builtSize} KB (${Math.round((1 - this.files.builtSize / this.files.sourceSize) * 100)}% smaller)\\n`);\n    }\n    \n    console.log('═'.repeat(39) + '\\n');\n  },\n  \n  deploy(platform) {\n    console.log(`\\n🚀 Deploying to ${platform}...\\n`);\n    \n    const deploySteps = [\n      'Uploading dist/ folder',\n      'Distributing to global CDN',\n      'Configuring SSL certificate',\n      'Assigning domain',\n      'Running health checks'\n    ];\n    \n    deploySteps.forEach((step, i) => {\n      console.log(`  ${i + 1}. ${step}...`);\n    });\n    \n    const url = `https://${this.name.toLowerCase().replace(/\\s+/g, '-')}.vercel.app`;\n    \n    console.log(`\\n✅ Deployment successful!\\n`);\n    console.log(`🌐 Live at: ${url}`);\n    console.log(`⚡ Served from 100+ edge locations worldwide\\n`);\n    \n    return url;\n  },\n  \n  testConnection(apiUrl) {\n    console.log(`\\n🧪 Testing connection to backend...\\n`);\n    console.log(`Frontend: https://my-app.vercel.app`);\n    console.log(`Backend:  ${apiUrl}\\n`);\n    \n    console.log('Testing endpoints:');\n    const tests = [\n      { endpoint: '/health', status: 200, result: 'OK' },\n      { endpoint: '/api/users', status: 200, result: '[2 users]' },\n      { endpoint: '/api/login', status: 200, result: 'OK' }\n    ];\n    \n    tests.forEach(test => {\n      console.log(`  GET ${apiUrl}${test.endpoint}`);\n      console.log(`    → ${test.status} ${test.result}`);\n    });\n    \n    console.log('\\n✅ All endpoints responding correctly!\\n');\n  }\n};\n\n// Simulate complete deployment workflow\nconsole.log('=== Complete Deployment Workflow ===\\n');\n\n// 1. Development build\nconsole.log('Step 1: Test build locally\\n');\nfrontendApp.build('development');\n\n// 2. Production build\nconsole.log('\\nStep 2: Production build\\n');\nfrontendApp.build('production');\n\n// 3. Deploy\nconsole.log('\\nStep 3: Deploy to Vercel\\n');\nconst liveUrl = frontendApp.deploy('Vercel');\n\n// 4. Test backend connection\nconsole.log('Step 4: Test API connection\\n');\nfrontendApp.testConnection(frontendApp.env.production.VITE_API_URL);\n\n// 5. Final checklist\nconsole.log('\\n=== Deployment Checklist ===\\n');\nconst checklist = [\n  '✓ Environment variables configured in Vercel',\n  '✓ API URL points to production backend',\n  '✓ Backend CORS allows Vercel domain',\n  '✓ Build completes without errors',\n  '✓ All API endpoints responding',\n  '✓ SSL certificate active (HTTPS)',\n  '✓ Auto-deploy enabled on git push',\n  '✓ .env files not committed to git'\n];\n\nchecklist.forEach(item => console.log(item));\n\nconsole.log('\\n🎉 Deployment complete! Your app is live!\\n');",
              "hints": [
                "Use import.meta.env.VITE_* for environment variables in Vite/React"
              ],
              "testCases": [
                {
                  "description": "Should use correct API URL for environment",
                  "input": "const API = import.meta.env.VITE_API_URL; API",
                  "expectedOutput": "https://my-api.onrender.com (in production)"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-14-14-4",
          "title": "Environment Variables in Production (The Secret Recipe Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Environment Variables in Production (The Secret Recipe Analogy)\n\n## Understanding the Concept\n\nImagine you own a restaurant chain:\n\nBad approach (hardcoded secrets):\n- Write secret sauce recipe directly in the cookbook\n- Every employee gets a copy\n- Recipe is in every branch location\n- Employee leaves → they have your secrets!\n- Want to change recipe → reprint all cookbooks!\n\nGood approach (environment variables):\n- Cookbook says: \"Use the secret sauce (see manager)\"\n- Each location stores recipe in a safe\n- Only managers have the combination\n- Employee leaves → recipe stays safe\n- Change recipe → just update the safe\n\nEnvironment variables work the same way:\n- Code says: process.env.DATABASE_PASSWORD\n- Secret stored separately (not in code!)\n- Different value per environment (dev vs prod)\n- Change secrets without changing code\n- Never committed to Git (safe!)\n\nThink of env vars as a safe for your app's secrets!\n\n## Code Example\n\n```javascript\n// Environment Variables - Concepts\n\nconsole.log('=== Environment Variables ===\\n');\n\n// CONCEPT: Separating Code from Configuration\n\n// BAD: Hardcoded secrets (NEVER DO THIS!)\nconst badExample = {\n  database: 'postgres://admin:super_secret_password@db.com/prod',\n  jwtSecret: 'my-secret-key-12345',\n  stripeKey: 'sk_live_abc123xyz',\n  apiKey: 'secret-api-key-do-not-share'\n};\n\nconsole.log('❌ WRONG - Hardcoded Secrets:\\n');\nObject.entries(badExample).forEach(([key, value]) => {\n  console.log(`const ${key} = '${value}';`);\n});\n\nconsole.log('\\nProblems:');\nconst problems = [\n  '✗ Secrets visible in Git history forever',\n  '✗ Everyone with code access sees secrets',\n  '✗ Different environments need different values',\n  '✗ Changing secrets requires code changes',\n  '✗ Accidental public repository = leaked secrets!'\n];\nproblems.forEach(p => console.log(`  ${p}`));\n\n// GOOD: Environment variables\nconsole.log('\\n\\n✅ CORRECT - Environment Variables:\\n');\n\nconst goodExample = {\n  database: process.env.DATABASE_URL,\n  jwtSecret: process.env.JWT_SECRET,\n  stripeKey: process.env.STRIPE_SECRET_KEY,\n  apiKey: process.env.API_KEY\n};\n\nObject.entries(goodExample).forEach(([key, value]) => {\n  console.log(`const ${key} = process.env.${value.replace('process.env.', '')};`);\n});\n\nconsole.log('\\nBenefits:');\nconst benefits = [\n  '✓ Secrets never in code or Git',\n  '✓ Different values per environment',\n  '✓ Change secrets without code changes',\n  '✓ Secure storage on hosting platforms',\n  '✓ Easy to rotate credentials'\n];\nbenefits.forEach(b => console.log(`  ${b}`));\n\n// CONCEPT: Different Environments\nconsole.log('\\n\\n=== Multi-Environment Setup ===\\n');\n\nconst environments = {\n  development: {\n    NODE_ENV: 'development',\n    DATABASE_URL: 'postgres://localhost/myapp_dev',\n    API_URL: 'http://localhost:3000',\n    JWT_SECRET: 'dev-secret-ok-to-be-simple',\n    DEBUG: 'true',\n    LOG_LEVEL: 'debug'\n  },\n  \n  staging: {\n    NODE_ENV: 'staging',\n    DATABASE_URL: 'postgres://staging-db.internal/myapp_staging',\n    API_URL: 'https://staging-api.myapp.com',\n    JWT_SECRET: 'complex-staging-secret-xyz789',\n    DEBUG: 'false',\n    LOG_LEVEL: 'info'\n  },\n  \n  production: {\n    NODE_ENV: 'production',\n    DATABASE_URL: 'postgres://prod-db.aws.com/myapp_prod',\n    API_URL: 'https://api.myapp.com',\n    JWT_SECRET: 'super-complex-production-secret-abc123xyz',\n    DEBUG: 'false',\n    LOG_LEVEL: 'error'\n  }\n};\n\nObject.entries(environments).forEach(([env, vars]) => {\n  console.log(`${env.toUpperCase()} Environment:`);\n  Object.entries(vars).forEach(([key, value]) => {\n    // Mask secrets\n    let displayValue = value;\n    if (key.includes('SECRET') || key.includes('PASSWORD')) {\n      displayValue = value.substring(0, 8) + '...[hidden]';\n    }\n    console.log(`  ${key}=${displayValue}`);\n  });\n  console.log('');\n});\n\n// SIMULATING ENVIRONMENT VARIABLE USAGE\nconsole.log('=== Using Environment Variables ===\\n');\n\nclass AppConfig {\n  constructor() {\n    // Simulate process.env\n    this.env = process.env;\n    \n    // Required variables\n    this.requiredVars = [\n      'DATABASE_URL',\n      'JWT_SECRET',\n      'NODE_ENV'\n    ];\n  }\n  \n  validate() {\n    console.log('Validating environment variables...\\n');\n    \n    const missing = [];\n    \n    this.requiredVars.forEach(varName => {\n      if (!this.env[varName]) {\n        missing.push(varName);\n      }\n    });\n    \n    if (missing.length > 0) {\n      console.log('❌ Missing required environment variables:');\n      missing.forEach(v => console.log(`  - ${v}`));\n      console.log('\\nApp cannot start without these variables!\\n');\n      return false;\n    } else {\n      console.log('✅ All required environment variables present\\n');\n      return true;\n    }\n  }\n  \n  get(key, fallback = null) {\n    const value = this.env[key];\n    if (!value && fallback !== null) {\n      console.log(`⚠ ${key} not set, using fallback: ${fallback}`);\n      return fallback;\n    }\n    return value;\n  }\n  \n  showConfig() {\n    console.log('Current Configuration:');\n    console.log(`  Environment: ${this.get('NODE_ENV', 'development')}`);\n    console.log(`  Database: ${this.maskSecret(this.get('DATABASE_URL', 'Not set'))}`);\n    console.log(`  JWT Secret: ${this.maskSecret(this.get('JWT_SECRET', 'Not set'))}`);\n    console.log(`  Port: ${this.get('PORT', '3000')}`);\n    console.log(`  Debug: ${this.get('DEBUG', 'false')}\\n`);\n  }\n  \n  maskSecret(value) {\n    if (!value || value === 'Not set') return value;\n    if (value.length < 10) return '***';\n    return value.substring(0, 10) + '...[hidden]';\n  }\n}\n\n// Test with development environment\nprocess.env.NODE_ENV = 'development';\nprocess.env.DATABASE_URL = 'postgres://localhost/myapp_dev';\nprocess.env.JWT_SECRET = 'dev-secret';\nprocess.env.PORT = '3000';\n\nconst config = new AppConfig();\nconfig.validate();\nconfig.showConfig();\n\n// BEST PRACTICES\nconsole.log('=== Environment Variable Best Practices ===\\n');\n\nconst bestPractices = [\n  {\n    rule: '1. Never commit secrets to Git',\n    example: 'Add .env to .gitignore immediately!'\n  },\n  {\n    rule: '2. Use descriptive names',\n    example: 'DATABASE_URL (good) vs DB (bad)'\n  },\n  {\n    rule: '3. Provide .env.example',\n    example: 'Template showing what vars are needed (no real values!)'\n  },\n  {\n    rule: '4. Validate on startup',\n    example: 'Crash early if required vars missing'\n  },\n  {\n    rule: '5. Use different values per environment',\n    example: 'dev-simple-secret vs prod-complex-secret-xyz789'\n  },\n  {\n    rule: '6. Rotate secrets regularly',\n    example: 'Change JWT_SECRET every few months'\n  },\n  {\n    rule: '7. Document all variables',\n    example: 'README lists all env vars and what they do'\n  }\n];\n\nbestPractices.forEach(({ rule, example }) => {\n  console.log(rule);\n  console.log(`   → ${example}\\n`);\n});\n\n// COMMON VARIABLES\nconsole.log('=== Common Environment Variables ===\\n');\n\nconst commonVars = {\n  'NODE_ENV': 'development | production | test',\n  'PORT': 'Server port (3000, 8080, etc.)',\n  'DATABASE_URL': 'Full database connection string',\n  'JWT_SECRET': 'Secret key for signing tokens',\n  'API_KEY': 'Third-party API keys',\n  'STRIPE_SECRET_KEY': 'Payment processing key',\n  'AWS_ACCESS_KEY_ID': 'AWS credentials',\n  'SMTP_HOST': 'Email server settings',\n  'CORS_ORIGIN': 'Allowed frontend URLs',\n  'LOG_LEVEL': 'debug | info | warn | error'\n};\n\nObject.entries(commonVars).forEach(([name, description]) => {\n  console.log(`${name.padEnd(20)} - ${description}`);\n});\n```\n\n## Breaking Down the Syntax\n\nEnvironment variables in practice:\n\n1. **Development (.env file)**:\n   ```bash\n   # .env (local development only, never commit!)\n   NODE_ENV=development\n   PORT=3000\n   DATABASE_URL=postgres://localhost/myapp_dev\n   JWT_SECRET=dev-secret-simple-is-ok\n   STRIPE_SECRET_KEY=sk_test_abc123\n   FRONTEND_URL=http://localhost:5173\n   ```\n\n2. **Loading .env file** (using dotenv):\n   ```javascript\n   // At the very top of server.js\n   import 'dotenv/config';\n   // or\n   require('dotenv').config();\n   \n   // Now process.env has your variables!\n   console.log(process.env.DATABASE_URL);\n   ```\n\n3. **Using environment variables**:\n   ```javascript\n   // Good pattern with fallbacks\n   const PORT = process.env.PORT || 3000;\n   const NODE_ENV = process.env.NODE_ENV || 'development';\n   \n   // Required variables (no fallback)\n   const DATABASE_URL = process.env.DATABASE_URL;\n   if (!DATABASE_URL) {\n     throw new Error('DATABASE_URL environment variable is required!');\n   }\n   \n   // Type conversion\n   const MAX_CONNECTIONS = parseInt(process.env.MAX_CONNECTIONS || '10', 10);\n   const ENABLE_DEBUG = process.env.ENABLE_DEBUG === 'true';\n   ```\n\n4. **Validation helper**:\n   ```javascript\n   function requireEnv(name) {\n     const value = process.env[name];\n     if (!value) {\n       throw new Error(`Missing required environment variable: ${name}`);\n     }\n     return value;\n   }\n   \n   // Usage\n   const DATABASE_URL = requireEnv('DATABASE_URL');\n   const JWT_SECRET = requireEnv('JWT_SECRET');\n   ```\n\n5. **.env.example** (commit this!):\n   ```bash\n   # .env.example - Template for other developers\n   # Copy this to .env and fill in real values\n   \n   NODE_ENV=development\n   PORT=3000\n   DATABASE_URL=postgres://localhost/myapp_dev\n   JWT_SECRET=your-secret-here\n   STRIPE_SECRET_KEY=sk_test_your-key\n   ```\n\n6. **.gitignore** (CRITICAL!):\n   ```\n   # Never commit these!\n   .env\n   .env.local\n   .env.development\n   .env.production\n   .env.test\n   \n   # DO commit this:\n   # .env.example\n   ```\n\n7. **Setting in Render (Backend)**:\n   ```\n   Render Dashboard:\n   1. Go to your web service\n   2. Click \"Environment\"\n   3. Add variables:\n      DATABASE_URL = postgres://...\n      JWT_SECRET = your-production-secret\n      NODE_ENV = production\n   4. Save (triggers redeploy)\n   ```\n\n8. **Setting in Vercel (Frontend)**:\n   ```\n   Vercel Dashboard:\n   1. Project Settings → Environment Variables\n   2. Add variables (must start with VITE_):\n      VITE_API_URL = https://api.myapp.com\n      VITE_STRIPE_PUBLIC_KEY = pk_live_...\n   3. Redeploy to apply changes\n   ```\n\n9. **Environment-specific logic**:\n   ```javascript\n   const isDevelopment = process.env.NODE_ENV === 'development';\n   const isProduction = process.env.NODE_ENV === 'production';\n   \n   if (isDevelopment) {\n     // Detailed logging\n     console.log('Full error:', error.stack);\n     \n     // Allow all CORS in dev\n     app.use(cors({ origin: '*' }));\n   }\n   \n   if (isProduction) {\n     // Hide error details\n     console.log('Error occurred');\n     \n     // Strict CORS\n     app.use(cors({ origin: process.env.FRONTEND_URL }));\n   }\n   ```\n\n10. **Configuration module pattern**:\n    ```javascript\n    // config/index.js\n    export const config = {\n      env: process.env.NODE_ENV || 'development',\n      port: parseInt(process.env.PORT || '3000', 10),\n      \n      database: {\n        url: process.env.DATABASE_URL,\n        poolSize: parseInt(process.env.DB_POOL_SIZE || '10', 10)\n      },\n      \n      jwt: {\n        secret: process.env.JWT_SECRET,\n        expiresIn: process.env.JWT_EXPIRES || '7d'\n      },\n      \n      stripe: {\n        secretKey: process.env.STRIPE_SECRET_KEY,\n        webhookSecret: process.env.STRIPE_WEBHOOK_SECRET\n      },\n      \n      cors: {\n        origin: process.env.CORS_ORIGIN || 'http://localhost:5173'\n      }\n    };\n    \n    // Validate on import\n    const required = ['DATABASE_URL', 'JWT_SECRET'];\n    required.forEach(key => {\n      if (!process.env[key]) {\n        throw new Error(`Missing required env var: ${key}`);\n      }\n    });\n    ```\n\n## Common Mistakes & Tips\n\nCommon environment variable mistakes:\n\n1. **Committing .env to Git** (MAJOR security issue!):\n   ```bash\n   # Check if .env is tracked:\n   git ls-files | grep .env\n   \n   # If it returns .env, you've committed secrets!\n   # Fix immediately:\n   git rm --cached .env\n   echo \".env\" >> .gitignore\n   git commit -m \"Remove .env from git\"\n   \n   # If already pushed to GitHub:\n   # 1. Rotate all secrets immediately!\n   # 2. Consider the secrets compromised\n   ```\n\n2. **Forgot to load dotenv**:\n   ```javascript\n   // Error: process.env.DATABASE_URL is undefined\n   \n   // Fix: Load dotenv at the very top\n   import 'dotenv/config';  // Must be first!\n   import express from 'express';\n   \n   // or\n   require('dotenv').config();  // Must be first!\n   const express = require('express');\n   ```\n\n3. **Wrong variable names** (typos):\n   ```javascript\n   // .env\n   DATABASE_URL=postgres://...\n   \n   // server.js\n   const db = process.env.DATABSE_URL;  // ✗ Typo! Returns undefined\n   const db = process.env.DATABASE_URL;  // ✓ Correct\n   \n   // Tip: Use constants to avoid typos\n   const REQUIRED_VARS = ['DATABASE_URL', 'JWT_SECRET'];\n   ```\n\n4. **Not updating production env vars**:\n   ```\n   Changed .env locally but forgot to update Render!\n   \n   Fix:\n   1. Update .env → works locally\n   2. Update Render Environment Variables → works in production\n   3. Must update BOTH places!\n   ```\n\n5. **Hardcoded fallbacks for secrets**:\n   ```javascript\n   // WRONG! Production will use insecure fallback\n   const JWT_SECRET = process.env.JWT_SECRET || 'default-secret';  // ✗\n   \n   // CORRECT! Fail if secret is missing\n   const JWT_SECRET = process.env.JWT_SECRET;\n   if (!JWT_SECRET) {\n     throw new Error('JWT_SECRET environment variable is required!');\n   }\n   ```\n\n6. **Type confusion** (everything is a string!):\n   ```javascript\n   // WRONG! process.env values are always strings\n   const PORT = process.env.PORT;  // \"3000\" (string)\n   app.listen(PORT);  // Works but technically wrong type\n   \n   const MAX = process.env.MAX_ITEMS;  // \"10\" (string)\n   if (items.length > MAX) // ✗ String comparison!\n   \n   // CORRECT! Convert types explicitly\n   const PORT = parseInt(process.env.PORT || '3000', 10);  // number\n   const MAX = parseInt(process.env.MAX_ITEMS || '10', 10);  // number\n   const DEBUG = process.env.DEBUG === 'true';  // boolean\n   ```\n\n7. **Exposing env vars in frontend** (React/Vite):\n   ```javascript\n   // Backend (.env) - These are SECRET!\n   DATABASE_URL=postgres://...\n   JWT_SECRET=super-secret\n   STRIPE_SECRET_KEY=sk_live_...\n   \n   // Frontend (.env) - These are PUBLIC!\n   VITE_API_URL=https://api.com\n   VITE_STRIPE_PUBLIC_KEY=pk_live_...  // Note: PUBLIC key\n   \n   // Remember: VITE_ vars are bundled into JavaScript\n   // Anyone can see them in browser!\n   // NEVER put secrets in VITE_ variables!\n   ```\n\n8. **Missing .env.example**:\n   ```bash\n   # Create .env.example (commit this!)\n   # Other developers copy this to .env\n   \n   # .env.example\n   NODE_ENV=development\n   PORT=3000\n   DATABASE_URL=postgres://localhost/myapp_dev\n   JWT_SECRET=your-secret-here\n   STRIPE_SECRET_KEY=sk_test_your-key\n   \n   # Instructions for new developers:\n   # 1. Copy .env.example to .env\n   # 2. Fill in real values\n   # 3. Never commit .env!\n   ```\n\n9. **Environment variables not rebuilding**:\n   ```\n   React/Vite issue:\n   - Changed VITE_API_URL in Vercel\n   - Still seeing old value!\n   \n   Why: Env vars are baked into build at build time\n   \n   Fix:\n   1. Change env var in Vercel dashboard\n   2. Trigger new deployment (Deployments → Redeploy)\n   3. Env vars from build time are used, not runtime!\n   ```\n\n10. **Different formats on different platforms**:\n    ```bash\n    # .env file format (local)\n    DATABASE_URL=postgres://localhost/db\n    NODE_ENV=development\n    \n    # Render format (same!)\n    DATABASE_URL = postgres://render.com/db\n    NODE_ENV = production\n    \n    # Note: Render adds spaces around =, both work fine\n    # Just be consistent in your .env file\n    ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create an environment configuration system:\n\n1. Create a `Config` class that:\n   - Loads variables from process.env\n   - Validates required variables\n   - Provides get() method with fallbacks\n   - Masks secrets when displaying\n\n2. Test with sample environment variables",
              "starterCode": "// Environment configuration manager\n\nclass Config {\n  constructor() {\n    this.required = ['DATABASE_URL', 'JWT_SECRET'];\n  }\n  \n  validate() {\n    const missing = this.required.filter(key => !process.env[key]);\n    \n    if (missing.length > 0) {\n      console.log('❌ Missing required variables:');\n      missing.forEach(v => console.log(`  - ${v}`));\n      return false;\n    }\n    \n    console.log('✅ All required variables present');\n    return true;\n  }\n  \n  get(key, fallback = null) {\n    return process.env[key] || fallback;\n  }\n  \n  maskSecret(value) {\n    if (!value || value.length < 8) return '***';\n    return value.substring(0, 8) + '...';\n  }\n  \n  show() {\n    console.log('\\nConfiguration:');\n    console.log(`  NODE_ENV: ${this.get('NODE_ENV', 'development')}`);\n    console.log(`  PORT: ${this.get('PORT', '3000')}`);\n    console.log(`  DATABASE: ${this.maskSecret(this.get('DATABASE_URL', 'not set'))}`);\n    console.log(`  JWT_SECRET: ${this.maskSecret(this.get('JWT_SECRET', 'not set'))}`);\n  }\n}\n\n// Test\nprocess.env.NODE_ENV = 'production';\nprocess.env.PORT = '8080';\nprocess.env.DATABASE_URL = 'postgres://prod-db.com/myapp';\nprocess.env.JWT_SECRET = 'super-secret-key-xyz';\n\nconst config = new Config();\nconfig.validate();\nconfig.show();",
              "solution": "// Complete environment configuration system\n\nclass Config {\n  constructor() {\n    // Define required variables\n    this.required = [\n      'NODE_ENV',\n      'DATABASE_URL',\n      'JWT_SECRET'\n    ];\n    \n    // Define optional variables with defaults\n    this.defaults = {\n      PORT: '3000',\n      LOG_LEVEL: 'info',\n      CORS_ORIGIN: 'http://localhost:5173',\n      JWT_EXPIRES: '7d'\n    };\n    \n    this.env = process.env;\n  }\n  \n  validate() {\n    console.log('🔍 Validating environment configuration...\\n');\n    \n    const missing = [];\n    const present = [];\n    \n    this.required.forEach(key => {\n      if (!this.env[key]) {\n        missing.push(key);\n      } else {\n        present.push(key);\n      }\n    });\n    \n    if (present.length > 0) {\n      console.log('✅ Found required variables:');\n      present.forEach(v => console.log(`  ✓ ${v}`));\n      console.log('');\n    }\n    \n    if (missing.length > 0) {\n      console.log('❌ Missing required variables:');\n      missing.forEach(v => console.log(`  ✗ ${v}`));\n      console.log('\\n⚠ Application cannot start without these variables!\\n');\n      return false;\n    }\n    \n    console.log('✅ All required environment variables present!\\n');\n    return true;\n  }\n  \n  get(key, fallback = null) {\n    let value = this.env[key];\n    \n    // Use default if available\n    if (!value && this.defaults[key]) {\n      value = this.defaults[key];\n    }\n    \n    // Use provided fallback\n    if (!value && fallback !== null) {\n      value = fallback;\n    }\n    \n    return value;\n  }\n  \n  getInt(key, fallback = 0) {\n    const value = this.get(key, fallback.toString());\n    return parseInt(value, 10);\n  }\n  \n  getBool(key, fallback = false) {\n    const value = this.get(key, fallback.toString());\n    return value === 'true' || value === '1';\n  }\n  \n  isProduction() {\n    return this.get('NODE_ENV') === 'production';\n  }\n  \n  isDevelopment() {\n    return this.get('NODE_ENV') === 'development';\n  }\n  \n  maskSecret(value) {\n    if (!value || value === 'not set') return value;\n    if (value.length < 8) return '***';\n    return value.substring(0, 8) + '...[hidden]';\n  }\n  \n  show() {\n    console.log('┌─────────────────────────────────────┐');\n    console.log('│     Environment Configuration        │');\n    console.log('└─────────────────────────────────────┘\\n');\n    \n    console.log('General:');\n    console.log(`  NODE_ENV:     ${this.get('NODE_ENV')}`);\n    console.log(`  PORT:         ${this.get('PORT')}`);\n    console.log(`  LOG_LEVEL:    ${this.get('LOG_LEVEL')}\\n`);\n    \n    console.log('Database:');\n    console.log(`  DATABASE_URL: ${this.maskSecret(this.get('DATABASE_URL', 'not set'))}\\n`);\n    \n    console.log('Security:');\n    console.log(`  JWT_SECRET:   ${this.maskSecret(this.get('JWT_SECRET', 'not set'))}`);\n    console.log(`  JWT_EXPIRES:  ${this.get('JWT_EXPIRES')}\\n`);\n    \n    console.log('CORS:');\n    console.log(`  CORS_ORIGIN:  ${this.get('CORS_ORIGIN')}\\n`);\n    \n    if (this.isProduction()) {\n      console.log('🚀 Running in PRODUCTION mode');\n    } else {\n      console.log('🔧 Running in DEVELOPMENT mode');\n    }\n    \n    console.log('\\n' + '═'.repeat(39) + '\\n');\n  }\n  \n  toObject() {\n    return {\n      env: this.get('NODE_ENV'),\n      port: this.getInt('PORT'),\n      logLevel: this.get('LOG_LEVEL'),\n      \n      database: {\n        url: this.get('DATABASE_URL')\n      },\n      \n      jwt: {\n        secret: this.get('JWT_SECRET'),\n        expiresIn: this.get('JWT_EXPIRES')\n      },\n      \n      cors: {\n        origin: this.get('CORS_ORIGIN')\n      }\n    };\n  }\n}\n\n// Simulate different environments\nconsole.log('=== Testing Environment Configurations ===\\n');\n\n// Test 1: Development\nconsole.log('Test 1: Development Environment\\n');\nprocess.env.NODE_ENV = 'development';\nprocess.env.PORT = '3000';\nprocess.env.DATABASE_URL = 'postgres://localhost/myapp_dev';\nprocess.env.JWT_SECRET = 'dev-secret-simple';\n\nlet config = new Config();\nconfig.validate();\nconfig.show();\n\n// Test 2: Production\nconsole.log('\\nTest 2: Production Environment\\n');\nprocess.env.NODE_ENV = 'production';\nprocess.env.PORT = '8080';\nprocess.env.DATABASE_URL = 'postgres://prod.aws.com/myapp';\nprocess.env.JWT_SECRET = 'super-complex-prod-secret-xyz789';\nprocess.env.LOG_LEVEL = 'error';\nprocess.env.CORS_ORIGIN = 'https://myapp.com';\n\nconfig = new Config();\nconfig.validate();\nconfig.show();\n\n// Test 3: Missing required variable\nconsole.log('\\nTest 3: Missing Required Variable\\n');\ndelete process.env.JWT_SECRET;\n\nconfig = new Config();\nconst isValid = config.validate();\n\nif (!isValid) {\n  console.log('Cannot start application. Please set missing variables.\\n');\n}\n\n// Best practices guide\nconsole.log('\\n=== Environment Variable Best Practices ===\\n');\n\nconst guide = [\n  {\n    do: '✓ Use .env for local development',\n    dont: '✗ Commit .env to Git'\n  },\n  {\n    do: '✓ Provide .env.example template',\n    dont: '✗ Put real secrets in .env.example'\n  },\n  {\n    do: '✓ Validate required vars on startup',\n    dont: \"✗ Let app crash with 'undefined' errors\"\n  },\n  {\n    do: '✓ Use descriptive variable names',\n    dont: '✗ Use vague names like SECRET or KEY'\n  },\n  {\n    do: '✓ Different secrets per environment',\n    dont: '✗ Reuse dev secrets in production'\n  },\n  {\n    do: '✓ Document all variables in README',\n    dont: '✗ Leave developers guessing'\n  }\n];\n\nguide.forEach(({ do: good, dont: bad }) => {\n  console.log(good);\n  console.log(bad);\n  console.log('');\n});",
              "hints": [
                "Use process.env to access environment variables"
              ],
              "testCases": [
                {
                  "description": "Should detect missing required variables",
                  "input": "delete process.env.JWT_SECRET; config.validate()",
                  "expectedOutput": "false (missing JWT_SECRET)"
                }
              ]
            }
          ]
        },
        {
          "id": "lesson-14-14-5",
          "title": "Production Best Practices (The Professional Kitchen Analogy)",
          "type": "exercise",
          "estimatedMinutes": 15,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Production Best Practices (The Professional Kitchen Analogy)\n\n## Understanding the Concept\n\nImagine running a professional restaurant kitchen:\n\nAmateur kitchen (bad practices):\n- No temperature monitoring → food safety issues\n- No backup ingredients → run out during dinner rush\n- No security cameras → theft happens\n- No health inspector → violations pile up\n- No cleaning schedule → kitchen becomes disaster\n- No documentation → new cooks can't follow recipes\n\nProfessional kitchen (best practices):\n- Temperature sensors everywhere → instant alerts\n- Backup suppliers → never run out\n- Security system → track everything\n- Regular inspections → always compliant\n- Daily cleaning checklist → spotless kitchen\n- Recipe book + training videos → easy onboarding\n- Fire suppression system → handle emergencies\n\nProduction applications need the same professionalism:\n- Monitoring (know what's happening)\n- Backups (recover from disasters)\n- Security (protect user data)\n- Testing (catch bugs before users do)\n- Documentation (help future developers)\n- Error tracking (fix issues quickly)\n- Performance optimization (fast = happy users)\n\nThink of production best practices as running a professional operation!\n\n## Code Example\n\n```javascript\n// Production Best Practices - Concepts\n\nconsole.log('=== Production Best Practices ===\\n');\n\n// CONCEPT 1: Health Checks\nconsole.log('1. HEALTH CHECKS & UPTIME MONITORING\\n');\n\nconst healthCheck = {\n  endpoint: '/health',\n  \n  check() {\n    console.log('Health check running...');\n    \n    const checks = [\n      { name: 'Database', status: this.checkDatabase() },\n      { name: 'API Server', status: 'healthy' },\n      { name: 'Memory Usage', status: this.checkMemory() },\n      { name: 'Disk Space', status: 'healthy' }\n    ];\n    \n    const allHealthy = checks.every(c => c.status === 'healthy');\n    \n    console.log('\\nHealth Status:');\n    checks.forEach(({ name, status }) => {\n      const icon = status === 'healthy' ? '✓' : '✗';\n      console.log(`  ${icon} ${name}: ${status}`);\n    });\n    \n    return {\n      status: allHealthy ? 'healthy' : 'unhealthy',\n      timestamp: new Date(),\n      checks: checks\n    };\n  },\n  \n  checkDatabase() {\n    // Simulate database ping\n    const latency = Math.random() * 100;\n    return latency < 80 ? 'healthy' : 'slow';\n  },\n  \n  checkMemory() {\n    // Simulate memory check\n    const usagePercent = Math.random() * 100;\n    return usagePercent < 90 ? 'healthy' : 'high';\n  }\n};\n\nconst health = healthCheck.check();\nconsole.log(`\\nOverall: ${health.status}\\n`);\n\n// CONCEPT 2: Error Tracking\nconsole.log('\\n2. ERROR TRACKING & LOGGING\\n');\n\nclass ErrorTracker {\n  constructor() {\n    this.errors = [];\n    this.logLevel = process.env.LOG_LEVEL || 'info';\n  }\n  \n  captureError(error, context = {}) {\n    const errorReport = {\n      message: error.message,\n      stack: error.stack,\n      timestamp: new Date(),\n      environment: process.env.NODE_ENV,\n      user: context.userId || 'anonymous',\n      url: context.url || 'unknown',\n      severity: 'error'\n    };\n    \n    this.errors.push(errorReport);\n    \n    console.log('🚨 Error Captured:');\n    console.log(`  Message: ${errorReport.message}`);\n    console.log(`  User: ${errorReport.user}`);\n    console.log(`  URL: ${errorReport.url}`);\n    console.log(`  Time: ${errorReport.timestamp}\\n`);\n    \n    // In production, send to Sentry/LogRocket/etc.\n    this.sendToMonitoring(errorReport);\n  }\n  \n  sendToMonitoring(report) {\n    console.log('  → Sent to error tracking service (Sentry)\\n');\n  }\n  \n  log(level, message) {\n    const levels = ['debug', 'info', 'warn', 'error'];\n    const currentLevel = levels.indexOf(this.logLevel);\n    const messageLevel = levels.indexOf(level);\n    \n    if (messageLevel >= currentLevel) {\n      console.log(`[${level.toUpperCase()}] ${message}`);\n    }\n  }\n}\n\nconst tracker = new ErrorTracker();\n\ntry {\n  // Simulate error\n  throw new Error('Database connection failed');\n} catch (error) {\n  tracker.captureError(error, {\n    userId: 'user_123',\n    url: '/api/users'\n  });\n}\n\n// CONCEPT 3: Performance Monitoring\nconsole.log('\\n3. PERFORMANCE MONITORING\\n');\n\nclass PerformanceMonitor {\n  constructor() {\n    this.metrics = [];\n  }\n  \n  trackRequest(endpoint, duration) {\n    this.metrics.push({\n      endpoint,\n      duration,\n      timestamp: new Date()\n    });\n    \n    if (duration > 1000) {\n      console.log(`⚠ SLOW REQUEST: ${endpoint} took ${duration}ms`);\n    } else {\n      console.log(`✓ ${endpoint}: ${duration}ms`);\n    }\n  }\n  \n  getStats() {\n    if (this.metrics.length === 0) return null;\n    \n    const durations = this.metrics.map(m => m.duration);\n    const avg = durations.reduce((a, b) => a + b, 0) / durations.length;\n    const max = Math.max(...durations);\n    const min = Math.min(...durations);\n    \n    return {\n      average: Math.round(avg),\n      max: max,\n      min: min,\n      total: this.metrics.length\n    };\n  }\n  \n  showReport() {\n    console.log('\\n=== Performance Report ===\\n');\n    const stats = this.getStats();\n    if (stats) {\n      console.log(`Total Requests: ${stats.total}`);\n      console.log(`Average Time: ${stats.average}ms`);\n      console.log(`Fastest: ${stats.min}ms`);\n      console.log(`Slowest: ${stats.max}ms\\n`);\n    }\n  }\n}\n\nconst monitor = new PerformanceMonitor();\nmonitor.trackRequest('/api/users', 45);\nmonitor.trackRequest('/api/products', 1200);\nmonitor.trackRequest('/api/orders', 89);\nmonitor.showReport();\n\n// CONCEPT 4: Security Best Practices\nconsole.log('\\n4. SECURITY CHECKLIST\\n');\n\nconst securityChecklist = [\n  {\n    practice: 'Use HTTPS everywhere',\n    why: 'Encrypt data in transit',\n    how: 'SSL certificates (free from Let\\'s Encrypt)'\n  },\n  {\n    practice: 'Validate all input',\n    why: 'Prevent SQL injection, XSS',\n    how: 'Use validation libraries (Zod, Joi)'\n  },\n  {\n    practice: 'Rate limit API endpoints',\n    why: 'Prevent abuse and DDoS',\n    how: 'express-rate-limit middleware'\n  },\n  {\n    practice: 'Use security headers',\n    why: 'Protect against common attacks',\n    how: 'helmet middleware for Express'\n  },\n  {\n    practice: 'Keep dependencies updated',\n    why: 'Patch security vulnerabilities',\n    how: 'npm audit, Dependabot'\n  },\n  {\n    practice: 'Store passwords hashed',\n    why: 'Never store plaintext passwords',\n    how: 'bcrypt library'\n  }\n];\n\nsecurityChecklist.forEach(({ practice, why, how }) => {\n  console.log(`✓ ${practice}`);\n  console.log(`  Why: ${why}`);\n  console.log(`  How: ${how}\\n`);\n});\n\n// CONCEPT 5: Deployment Checklist\nconsole.log('\\n5. PRE-DEPLOYMENT CHECKLIST\\n');\n\nconst deploymentChecklist = [\n  { task: 'Run all tests', command: 'npm test', critical: true },\n  { task: 'Check for console.logs', command: 'grep -r \"console.log\" src/', critical: false },\n  { task: 'Build succeeds', command: 'npm run build', critical: true },\n  { task: 'Environment variables set', command: 'Check Render/Vercel dashboard', critical: true },\n  { task: 'Database migrations run', command: 'npx prisma migrate deploy', critical: true },\n  { task: 'CORS configured correctly', command: 'Test from production frontend', critical: true },\n  { task: 'Error tracking enabled', command: 'Verify Sentry DSN', critical: false },\n  { task: 'Monitoring alerts set up', command: 'Configure UptimeRobot/etc', critical: false }\n];\n\nconsole.log('Before deploying, verify:\\n');\ndeploymentChecklist.forEach(({ task, command, critical }) => {\n  const icon = critical ? '🔴' : '🟡';\n  console.log(`${icon} ${task}`);\n  console.log(`   Command: ${command}\\n`);\n});\n\n// BEST PRACTICES SUMMARY\nconsole.log('\\n=== Production Best Practices Summary ===\\n');\n\nconst bestPractices = [\n  '1. Monitoring: Know when things break (before users complain!)',\n  '2. Logging: Track what happened (debug production issues)',\n  '3. Backups: Regular database backups (recover from disasters)',\n  '4. Security: HTTPS, rate limiting, input validation',\n  '5. Performance: Monitor response times, optimize slow queries',\n  '6. Error Tracking: Sentry/LogRocket to catch errors',\n  '7. Testing: Write tests, run before deploy',\n  '8. Documentation: README, API docs, deployment guide',\n  '9. Alerts: Get notified when app goes down',\n  '10. Graceful Degradation: Handle third-party service failures'\n];\n\nbestPractices.forEach(practice => console.log(practice));\n```\n\n## Breaking Down the Syntax\n\nProduction best practices in code:\n\n1. **Health Check Endpoint**:\n   ```javascript\n   // server.js\n   app.get('/health', async (req, res) => {\n     try {\n       // Test database\n       await prisma.$queryRaw`SELECT 1`;\n       \n       res.json({\n         status: 'healthy',\n         timestamp: new Date(),\n         uptime: process.uptime(),\n         memory: process.memoryUsage()\n       });\n     } catch (error) {\n       res.status(503).json({\n         status: 'unhealthy',\n         error: 'Database connection failed'\n       });\n     }\n   });\n   ```\n\n2. **Error Tracking (Sentry)**:\n   ```javascript\n   import * as Sentry from '@sentry/node';\n   \n   Sentry.init({\n     dsn: process.env.SENTRY_DSN,\n     environment: process.env.NODE_ENV\n   });\n   \n   // Error handler\n   app.use((err, req, res, next) => {\n     // Log to Sentry\n     Sentry.captureException(err);\n     \n     console.error(err.stack);\n     \n     if (process.env.NODE_ENV === 'production') {\n       res.status(500).json({ error: 'Internal server error' });\n     } else {\n       res.status(500).json({ error: err.message, stack: err.stack });\n     }\n   });\n   ```\n\n3. **Request Logging (Morgan)**:\n   ```javascript\n   import morgan from 'morgan';\n   \n   if (process.env.NODE_ENV === 'production') {\n     app.use(morgan('combined'));  // Standard Apache format\n   } else {\n     app.use(morgan('dev'));  // Colored, concise output\n   }\n   ```\n\n4. **Rate Limiting**:\n   ```javascript\n   import rateLimit from 'express-rate-limit';\n   \n   const limiter = rateLimit({\n     windowMs: 15 * 60 * 1000,  // 15 minutes\n     max: 100,  // Limit each IP to 100 requests per window\n     message: 'Too many requests, please try again later'\n   });\n   \n   app.use('/api/', limiter);\n   ```\n\n5. **Security Headers (Helmet)**:\n   ```javascript\n   import helmet from 'helmet';\n   \n   app.use(helmet());\n   // Adds:\n   // - X-Content-Type-Options\n   // - X-Frame-Options\n   // - X-XSS-Protection\n   // - And more...\n   ```\n\n6. **Graceful Shutdown**:\n   ```javascript\n   const server = app.listen(PORT);\n   \n   process.on('SIGTERM', () => {\n     console.log('SIGTERM received, shutting down gracefully');\n     \n     server.close(() => {\n       console.log('HTTP server closed');\n       \n       // Close database connections\n       prisma.$disconnect();\n       \n       process.exit(0);\n     });\n   });\n   ```\n\n7. **Input Validation (Zod)**:\n   ```javascript\n   import { z } from 'zod';\n   \n   const userSchema = z.object({\n     email: z.string().email(),\n     password: z.string().min(8),\n     age: z.number().int().positive()\n   });\n   \n   app.post('/api/users', (req, res) => {\n     try {\n       const validData = userSchema.parse(req.body);\n       // Use validData safely\n     } catch (error) {\n       res.status(400).json({ error: error.errors });\n     }\n   });\n   ```\n\n8. **Database Connection Pooling**:\n   ```javascript\n   // Prisma handles this automatically!\n   const prisma = new PrismaClient({\n     log: process.env.NODE_ENV === 'development' ? ['query'] : [],\n     datasources: {\n       db: { url: process.env.DATABASE_URL }\n     }\n   });\n   ```\n\n9. **Compression**:\n   ```javascript\n   import compression from 'compression';\n   \n   app.use(compression());  // Gzip responses\n   ```\n\n10. **Environment-based Configuration**:\n    ```javascript\n    const config = {\n      development: {\n        logLevel: 'debug',\n        cacheEnabled: false,\n        detailedErrors: true\n      },\n      production: {\n        logLevel: 'error',\n        cacheEnabled: true,\n        detailedErrors: false\n      }\n    };\n    \n    export default config[process.env.NODE_ENV || 'development'];\n    ```\n\n## Common Mistakes & Tips\n\nCommon production mistakes:\n\n1. **No error tracking**:\n   ```javascript\n   // WRONG! Errors disappear into the void\n   app.use((err, req, res, next) => {\n     console.log(err);  // Only logs to server console!\n     res.status(500).send('Error');\n   });\n   \n   // CORRECT! Track errors properly\n   import * as Sentry from '@sentry/node';\n   \n   Sentry.init({ dsn: process.env.SENTRY_DSN });\n   \n   app.use((err, req, res, next) => {\n     Sentry.captureException(err);  // Tracked forever!\n     res.status(500).json({ error: 'Internal error' });\n   });\n   ```\n\n2. **No health check endpoint**:\n   ```javascript\n   // Add this!\n   app.get('/health', async (req, res) => {\n     try {\n       await prisma.$queryRaw`SELECT 1`;  // Test DB\n       res.json({ status: 'healthy' });\n     } catch (error) {\n       res.status(503).json({ status: 'unhealthy' });\n     }\n   });\n   \n   // Configure Render to ping /health every 5 minutes\n   ```\n\n3. **Exposing detailed errors in production**:\n   ```javascript\n   // WRONG! Leaks sensitive info\n   res.status(500).json({ error: err.stack });  // ✗\n   \n   // CORRECT! Hide details in production\n   if (process.env.NODE_ENV === 'production') {\n     res.status(500).json({ error: 'Internal server error' });\n   } else {\n     res.status(500).json({ error: err.message, stack: err.stack });\n   }\n   ```\n\n4. **No rate limiting**:\n   ```javascript\n   import rateLimit from 'express-rate-limit';\n   \n   const limiter = rateLimit({\n     windowMs: 15 * 60 * 1000,  // 15 min\n     max: 100  // Max 100 requests per IP\n   });\n   \n   app.use('/api/', limiter);\n   ```\n\n5. **Missing security headers**:\n   ```javascript\n   import helmet from 'helmet';\n   \n   app.use(helmet());  // Adds 11+ security headers!\n   ```\n\n6. **No input validation**:\n   ```javascript\n   // WRONG! Trust user input = disaster\n   app.post('/api/users', (req, res) => {\n     const user = req.body;  // Could be anything!\n     await prisma.user.create({ data: user });\n   });\n   \n   // CORRECT! Validate everything\n   import { z } from 'zod';\n   \n   const userSchema = z.object({\n     email: z.string().email(),\n     password: z.string().min(8)\n   });\n   \n   app.post('/api/users', (req, res) => {\n     const validData = userSchema.parse(req.body);\n     // Now safe to use\n   });\n   ```\n\n7. **No database backups**:\n   ```\n   Render dashboard:\n   1. Go to your database\n   2. Enable automatic backups\n   3. Set schedule (daily recommended)\n   4. Test restore process!\n   ```\n\n8. **No uptime monitoring**:\n   ```\n   Use free services:\n   - UptimeRobot (free, monitors every 5 min)\n   - Pingdom\n   - StatusCake\n   \n   Monitor:\n   - Main app URL\n   - /health endpoint\n   - Database\n   \n   Get alerts via:\n   - Email\n   - SMS\n   - Slack\n   ```\n\n9. **Deploying without testing**:\n   ```bash\n   # ALWAYS run before deploying:\n   npm test              # Run all tests\n   npm run build         # Test build\n   npm audit             # Check vulnerabilities\n   \n   # If any fail, FIX FIRST, then deploy!\n   ```\n\n10. **No graceful shutdown**:\n    ```javascript\n    const server = app.listen(PORT);\n    \n    process.on('SIGTERM', () => {\n      console.log('Shutting down gracefully...');\n      \n      server.close(() => {\n        prisma.$disconnect();\n        process.exit(0);\n      });\n    });\n    \n    // Prevents cutting off active requests during deploy\n    ```\n\n11. **Committing console.logs**:\n    ```javascript\n    // WRONG! Clutters production logs\n    console.log('User data:', user);  // ✗\n    \n    // CORRECT! Use proper logging\n    import winston from 'winston';\n    \n    const logger = winston.createLogger({\n      level: process.env.LOG_LEVEL || 'info',\n      format: winston.format.json()\n    });\n    \n    logger.info('User created', { userId: user.id });\n    ```\n\n12. **No monitoring of slow queries**:\n    ```javascript\n    // Log slow database queries\n    const prisma = new PrismaClient({\n      log: [\n        { emit: 'event', level: 'query' }\n      ]\n    });\n    \n    prisma.$on('query', (e) => {\n      if (e.duration > 1000) {  // Slower than 1 second\n        console.warn(`SLOW QUERY: ${e.duration}ms - ${e.query}`);\n      }\n    });\n    ```"
          },
          "exercises": [
            {
              "type": "coding",
              "title": "Practice Exercise",
              "instructions": "Create a production monitoring system:\n\n1. Create a `ProductionMonitor` class that:\n   - Tracks health checks\n   - Logs errors\n   - Monitors performance\n   - Generates reports\n\n2. Simulate a production environment with various checks",
              "starterCode": "// Production monitoring system\n\nclass ProductionMonitor {\n  constructor() {\n    this.errors = [];\n    this.metrics = [];\n  }\n  \n  healthCheck() {\n    const checks = {\n      database: Math.random() > 0.1 ? 'healthy' : 'down',\n      api: 'healthy',\n      memory: Math.random() * 100 < 90 ? 'healthy' : 'high'\n    };\n    \n    console.log('Health Check:');\n    Object.entries(checks).forEach(([name, status]) => {\n      console.log(`  ${name}: ${status}`);\n    });\n    \n    return checks;\n  }\n  \n  logError(error, context) {\n    this.errors.push({ error: error.message, context, time: new Date() });\n    console.log(`\\n🚨 Error: ${error.message}`);\n  }\n  \n  trackMetric(name, value) {\n    this.metrics.push({ name, value, time: new Date() });\n    console.log(`📊 ${name}: ${value}`);\n  }\n  \n  report() {\n    console.log('\\n=== Production Report ===');\n    console.log(`Errors: ${this.errors.length}`);\n    console.log(`Metrics: ${this.metrics.length}`);\n  }\n}\n\n// Test\nconst monitor = new ProductionMonitor();\nmonitor.healthCheck();\nmonitor.trackMetric('response_time', 145);\nmonitor.logError(new Error('DB timeout'), { user: 'user_123' });\nmonitor.report();",
              "solution": "// Complete production monitoring system\n\nclass ProductionMonitor {\n  constructor() {\n    this.errors = [];\n    this.metrics = [];\n    this.healthHistory = [];\n    this.alerts = [];\n    this.startTime = Date.now();\n  }\n  \n  healthCheck() {\n    console.log('🏥 Running Health Check...\\n');\n    \n    const checks = {\n      database: this.checkDatabase(),\n      api: this.checkAPI(),\n      memory: this.checkMemory(),\n      diskSpace: this.checkDisk(),\n      uptime: this.getUptime()\n    };\n    \n    const allHealthy = Object.values(checks).every(c => \n      c.status === 'healthy' || c.status === 'ok'\n    );\n    \n    const healthReport = {\n      timestamp: new Date(),\n      overall: allHealthy ? 'healthy' : 'unhealthy',\n      checks: checks\n    };\n    \n    this.healthHistory.push(healthReport);\n    \n    console.log('Health Status:');\n    Object.entries(checks).forEach(([name, check]) => {\n      const icon = check.status === 'healthy' || check.status === 'ok' ? '✅' : '❌';\n      console.log(`  ${icon} ${name}: ${check.status} ${check.details || ''}`);\n    });\n    \n    console.log(`\\nOverall: ${healthReport.overall.toUpperCase()}\\n`);\n    \n    if (!allHealthy) {\n      this.createAlert('Health check failed', healthReport);\n    }\n    \n    return healthReport;\n  }\n  \n  checkDatabase() {\n    const latency = Math.random() * 150;\n    if (latency > 100) {\n      return { status: 'slow', details: `(${Math.round(latency)}ms)` };\n    }\n    return { status: 'healthy', details: `(${Math.round(latency)}ms)` };\n  }\n  \n  checkAPI() {\n    return { status: 'healthy', details: '(responding)' };\n  }\n  \n  checkMemory() {\n    const usage = Math.random() * 100;\n    if (usage > 90) {\n      return { status: 'critical', details: `(${Math.round(usage)}%)` };\n    } else if (usage > 75) {\n      return { status: 'warning', details: `(${Math.round(usage)}%)` };\n    }\n    return { status: 'healthy', details: `(${Math.round(usage)}%)` };\n  }\n  \n  checkDisk() {\n    return { status: 'healthy', details: '(45% used)' };\n  }\n  \n  getUptime() {\n    const seconds = Math.floor((Date.now() - this.startTime) / 1000);\n    return { status: 'ok', details: `(${seconds}s)` };\n  }\n  \n  logError(error, context = {}) {\n    const errorReport = {\n      message: error.message,\n      stack: error.stack,\n      timestamp: new Date(),\n      severity: context.severity || 'error',\n      user: context.userId || 'anonymous',\n      endpoint: context.endpoint || 'unknown',\n      environment: process.env.NODE_ENV || 'development'\n    };\n    \n    this.errors.push(errorReport);\n    \n    console.log('\\n🚨 ERROR CAPTURED:');\n    console.log('─'.repeat(40));\n    console.log(`Time: ${errorReport.timestamp.toISOString()}`);\n    console.log(`Severity: ${errorReport.severity}`);\n    console.log(`Message: ${errorReport.message}`);\n    console.log(`User: ${errorReport.user}`);\n    console.log(`Endpoint: ${errorReport.endpoint}`);\n    \n    if (process.env.NODE_ENV !== 'production') {\n      console.log(`\\nStack Trace:\\n${errorReport.stack}`);\n    }\n    \n    console.log('─'.repeat(40) + '\\n');\n    \n    // Simulate sending to error tracking service\n    this.sendToSentry(errorReport);\n    \n    if (errorReport.severity === 'critical') {\n      this.createAlert('Critical error occurred', errorReport);\n    }\n  }\n  \n  sendToSentry(error) {\n    console.log('  → Sent to Sentry for tracking\\n');\n  }\n  \n  trackMetric(name, value, unit = '') {\n    const metric = {\n      name,\n      value,\n      unit,\n      timestamp: new Date()\n    };\n    \n    this.metrics.push(metric);\n    \n    // Check for performance issues\n    if (name === 'response_time' && value > 1000) {\n      console.log(`⚠️  SLOW: ${name} = ${value}${unit} (threshold: 1000ms)`);\n      this.createAlert('Slow response time', metric);\n    } else {\n      console.log(`📊 ${name}: ${value}${unit}`);\n    }\n  }\n  \n  createAlert(title, data) {\n    const alert = {\n      title,\n      data,\n      timestamp: new Date(),\n      resolved: false\n    };\n    \n    this.alerts.push(alert);\n    \n    console.log(`\\n🔔 ALERT: ${title}`);\n    console.log(`   Time: ${alert.timestamp.toISOString()}\\n`);\n  }\n  \n  getMetricStats(metricName) {\n    const metricData = this.metrics\n      .filter(m => m.name === metricName)\n      .map(m => m.value);\n    \n    if (metricData.length === 0) return null;\n    \n    const sum = metricData.reduce((a, b) => a + b, 0);\n    const avg = sum / metricData.length;\n    const max = Math.max(...metricData);\n    const min = Math.min(...metricData);\n    \n    return {\n      count: metricData.length,\n      average: Math.round(avg * 100) / 100,\n      max,\n      min\n    };\n  }\n  \n  generateReport() {\n    console.log('\\n┌─────────────────────────────────────┐');\n    console.log('│     Production Monitor Report       │');\n    console.log('└─────────────────────────────────────┘\\n');\n    \n    console.log('UPTIME:');\n    const uptimeSeconds = Math.floor((Date.now() - this.startTime) / 1000);\n    console.log(`  ${uptimeSeconds} seconds\\n`);\n    \n    console.log('ERRORS:');\n    console.log(`  Total: ${this.errors.length}`);\n    if (this.errors.length > 0) {\n      const lastError = this.errors[this.errors.length - 1];\n      console.log(`  Last: ${lastError.message}`);\n      console.log(`  Time: ${lastError.timestamp.toISOString()}`);\n    }\n    console.log('');\n    \n    console.log('PERFORMANCE:');\n    const responseStats = this.getMetricStats('response_time');\n    if (responseStats) {\n      console.log(`  Requests: ${responseStats.count}`);\n      console.log(`  Avg Response: ${responseStats.average}ms`);\n      console.log(`  Fastest: ${responseStats.min}ms`);\n      console.log(`  Slowest: ${responseStats.max}ms`);\n    } else {\n      console.log('  No metrics recorded yet');\n    }\n    console.log('');\n    \n    console.log('HEALTH CHECKS:');\n    console.log(`  Total: ${this.healthHistory.length}`);\n    if (this.healthHistory.length > 0) {\n      const latest = this.healthHistory[this.healthHistory.length - 1];\n      console.log(`  Latest: ${latest.overall}`);\n      console.log(`  Time: ${latest.timestamp.toISOString()}`);\n    }\n    console.log('');\n    \n    console.log('ALERTS:');\n    const unresolvedAlerts = this.alerts.filter(a => !a.resolved);\n    console.log(`  Total: ${this.alerts.length}`);\n    console.log(`  Unresolved: ${unresolvedAlerts.length}`);\n    if (unresolvedAlerts.length > 0) {\n      console.log('\\n  Recent unresolved alerts:');\n      unresolvedAlerts.slice(-3).forEach(alert => {\n        console.log(`    - ${alert.title} (${alert.timestamp.toISOString()})`);\n      });\n    }\n    \n    console.log('\\n' + '═'.repeat(39) + '\\n');\n  }\n}\n\n// Simulate production environment\nconsole.log('=== Simulating Production Environment ===\\n');\n\nconst monitor = new ProductionMonitor();\n\n// Health check\nmonitor.healthCheck();\n\n// Track some metrics\nconsole.log('Recording API metrics:\\n');\nmonitor.trackMetric('response_time', 45, 'ms');\nmonitor.trackMetric('response_time', 1200, 'ms');  // Slow!\nmonitor.trackMetric('response_time', 89, 'ms');\nmonitor.trackMetric('active_users', 1547, '');\nmonitor.trackMetric('database_queries', 234, '/min');\n\nconsole.log('');\n\n// Log some errors\ntry {\n  throw new Error('Database connection timeout');\n} catch (error) {\n  monitor.logError(error, {\n    userId: 'user_456',\n    endpoint: '/api/users',\n    severity: 'error'\n  });\n}\n\ntry {\n  throw new Error('Payment processing failed');\n} catch (error) {\n  monitor.logError(error, {\n    userId: 'user_789',\n    endpoint: '/api/checkout',\n    severity: 'critical'\n  });\n}\n\n// Another health check\nmonitor.healthCheck();\n\n// Generate comprehensive report\nmonitor.generateReport();\n\n// Best practices summary\nconsole.log('=== Production Best Practices Checklist ===\\n');\n\nconst checklist = [\n  '✅ Health check endpoint implemented',\n  '✅ Error tracking configured (Sentry)',\n  '✅ Request logging enabled (Morgan)',\n  '✅ Rate limiting active',\n  '✅ Security headers added (Helmet)',\n  '✅ HTTPS enforced',\n  '✅ Database backups scheduled',\n  '✅ Uptime monitoring set up',\n  '✅ Performance metrics tracked',\n  '✅ Graceful shutdown handling',\n  '✅ Input validation on all endpoints',\n  '✅ Environment variables secured',\n  '✅ Dependencies up to date',\n  '✅ Tests passing before deploy',\n  '✅ Documentation complete'\n];\n\nchecklist.forEach(item => console.log(item));\n\nconsole.log('\\n🎉 Production-ready application!\\n');",
              "hints": [
                "Track health, errors, and metrics in separate arrays"
              ],
              "testCases": [
                {
                  "description": "Should track errors",
                  "input": "monitor.logError(new Error('Test')); monitor.errors.length",
                  "expectedOutput": "1"
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "metadata": {
    "version": "1.0.0",
    "lastUpdated": "2025-11-14",
    "author": "Code Tutor"
  }
}