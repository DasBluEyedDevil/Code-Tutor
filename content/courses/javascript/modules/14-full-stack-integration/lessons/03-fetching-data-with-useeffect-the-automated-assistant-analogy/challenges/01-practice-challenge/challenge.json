{
  "type": "FREE_CODING",
  "id": "13.3-challenge",
  "title": "Practice Challenge",
  "description": "Build a complete data fetching flow:\n\n1. Create a `fetchUsers()` function that:\n   - Returns a Promise\n   - Simulates 1 second delay\n   - Resolves with array of mock users\n\n2. Create a `UserListComponent` object that:\n   - Has `state` with: users (array), loading (boolean), error (string|null)\n   - Has `mount()` method that simulates useEffect running\n   - In mount: sets loading true, calls fetchUsers, updates state\n\n3. Test by calling mount() and logging state changes",
  "instructions": "Build a complete data fetching flow:\n\n1. Create a `fetchUsers()` function that:\n   - Returns a Promise\n   - Simulates 1 second delay\n   - Resolves with array of mock users\n\n2. Create a `UserListComponent` object that:\n   - Has `state` with: users (array), loading (boolean), error (string|null)\n   - Has `mount()` method that simulates useEffect running\n   - In mount: sets loading true, calls fetchUsers, updates state\n\n3. Test by calling mount() and logging state changes",
  "language": "javascript",
  "testCases": [
    {
      "id": "test-1",
      "description": "Should fetch and return users",
      "expectedOutput": "Array of 3 users",
      "isVisible": true
    }
  ],
  "hints": [
    {
      "level": 1,
      "text": "Use async/await and try/catch/finally for clean error handling"
    }
  ],
  "commonMistakes": [
    {
      "mistake": "Forgetting dependency array in useEffect",
      "consequence": "Effect runs after every render, causing infinite loops when updating state.",
      "correction": "Add [] to run once, or [dep] to run when dependency changes."
    },
    {
      "mistake": "Using async directly in useEffect",
      "consequence": "useEffect can't be async directly; it breaks cleanup function handling.",
      "correction": "Define async function inside effect and call it: const fetchData = async () => {...}; fetchData();"
    }
  ],
  "difficulty": "beginner"
}