{
  "type": "FREE_CODING",
  "id": "10.10-challenge-2",
  "title": "Configuration Builder",
  "description": "Use Record, Readonly, and Required to build a type-safe configuration system. Create environment-specific configs, status mappings, and frozen settings that prevent accidental mutations.",
  "instructions": "1. Create Environment type ('development' | 'staging' | 'production')\n2. Create EnvironmentConfig interface with optional properties (apiUrl, debug, logLevel)\n3. Use Record to map each Environment to its EnvironmentConfig\n4. Create a Required version for validated configs\n5. Create a Readonly frozen config type\n6. Implement getConfig function that returns frozen, fully-populated config\n7. Test with all three environments",
  "language": "typescript",
  "testCases": [
    {
      "id": "test-1",
      "description": "Record type covers all environments",
      "expectedOutput": "development, staging, production all defined",
      "isVisible": true
    },
    {
      "id": "test-2",
      "description": "Missing properties filled with defaults",
      "expectedOutput": "timeout: 5000, maxRetries: 3",
      "isVisible": true
    },
    {
      "id": "test-3",
      "description": "Returned config is readonly",
      "expectedOutput": "assignment to readonly property fails",
      "isVisible": true
    }
  ],
  "hints": [
    {
      "level": 1,
      "text": "Record<Environment, EnvironmentConfig> ensures every environment has a config entry"
    },
    {
      "level": 2,
      "text": "Use nullish coalescing (??) to fill missing values: envConfig.timeout ?? defaults.timeout"
    },
    {
      "level": 3,
      "text": "Readonly<Required<T>> first makes all properties required, then makes them readonly"
    }
  ],
  "commonMistakes": [
    {
      "mistake": "Using || instead of ?? for defaults",
      "consequence": "false and 0 are falsy, so debug: false would be replaced with default",
      "correction": "Use ?? which only falls back for null/undefined"
    },
    {
      "mistake": "Applying Readonly before Required",
      "consequence": "Both work, but Readonly<Required<T>> is more common pattern",
      "correction": "Order doesn't matter here, but Required first is conventional"
    }
  ],
  "difficulty": "intermediate"
}