{
  "type": "FREE_CODING",
  "id": "17.4-challenge-1",
  "title": "Implement a Kill Switch System",
  "description": "Create a kill switch service that can instantly disable features in production with proper fallback behavior.",
  "instructions": "Create a KillSwitchService class that:\n\n1. Uses singleton pattern with FirebaseRemoteConfig.instance\n2. Has an isKilled(feature) method that checks if 'kill_switch_{feature}' is true\n3. Has specific kill switch getters: isPaymentsKilled, isRegistrationKilled\n4. Has isMaintenanceMode and maintenanceMessage getters\n5. Supports listeners that are notified when kill switch status changes (use onConfigUpdated)\n6. Has addListener(callback) and removeListener(callback) methods",
  "language": "dart",
  "testCases": [],
  "hints": [
    {
      "level": 1,
      "text": "Use string interpolation to build the kill switch key: 'kill_switch_$feature'"
    },
    {
      "level": 2,
      "text": "Use _remoteConfig.onConfigUpdated to listen for real-time changes"
    },
    {
      "level": 3,
      "text": "Remember to call _remoteConfig.activate() after receiving an update before notifying listeners"
    }
  ],
  "commonMistakes": [
    {
      "mistake": "Forgetting to activate after receiving real-time update",
      "consequence": "Listeners are notified but flag values haven't changed yet",
      "correction": "Always await _remoteConfig.activate() before calling _notifyListeners()"
    },
    {
      "mistake": "Not canceling the subscription in dispose",
      "consequence": "Memory leak and potential callbacks after disposal",
      "correction": "Store the subscription and cancel it in dispose()"
    }
  ],
  "difficulty": "intermediate"
}