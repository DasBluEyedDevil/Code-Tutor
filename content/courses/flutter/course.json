{
  "id": "flutter",
  "language": "dart",
  "title": "Flutter Complete Development Course",
  "description": "Master Flutter from basics to advanced with 87+ interactive lessons, hands-on challenges, and experiments.",
  "difficulty": "beginner",
  "estimatedHours": 77,
  "prerequisites": [
    "Basic programming knowledge recommended"
  ],
  "modules": [
    {
      "id": "module-00",
      "title": "Module 0: Flutter Development",
      "description": "Learn Flutter development - Module 0",
      "difficulty": "beginner",
      "estimatedHours": 5,
      "lessons": [
        {
          "id": "0.1",
          "title": "Module 0, Lesson 1: Installing Flutter & Dart SDK",
          "moduleId": "module-00",
          "order": 1,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What Are We Doing Here?",
              "content": "\nImagine you want to build a treehouse. Before you start nailing boards together, you need tools: a hammer, nails, wood, a saw. You can't build anything without your tools ready.\n\nBuilding phone apps is the same. Before we write a single line of code, we need to install our \"toolbox\" on your computer. This toolbox contains everything we need to:\n- Write instructions for your app (the code)\n- Turn those instructions into something a phone can understand\n- Test your app on a fake phone on your computer (before putting it on a real phone)\n\n**The Big Picture**: Right now, your computer doesn't know how to build phone apps. We're going to teach it. Once we're done with this lesson, your computer will be ready to build apps for Android phones, iPhones, and even websites‚Äîall from the same code.\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Technical Names",
              "content": "\nThe toolbox we're installing has two main parts:\n\n1. **Flutter**: This is the main toolkit. It's like the instruction manual and the assembly line for building apps. Flutter was created by Google and lets you build apps for phones, tablets, computers, and websites‚Äîall at once.\n\n2. **Dart SDK**: SDK stands for \"Software Development Kit\" (don't worry about memorizing that). Dart is the *language* we'll use to write our instructions. Think of it like this: if Flutter is the kitchen, Dart is the language of the recipes.\n\nWhen we \"install Flutter,\" we're actually getting both Flutter and Dart together. They're best friends and always come as a package.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Installation Instructions",
              "content": "\n### **FOR WINDOWS USERS:**\n\n**Step 1: Download Flutter**\n1. Open your web browser and go to: `https://docs.flutter.dev/get-started/install/windows`\n2. Click the blue \"Download Flutter SDK\" button\n3. A file called something like `flutter_windows_3.x.x-stable.zip` will download\n\n**Step 2: Extract the Files**\n1. Once downloaded, find the ZIP file (probably in your Downloads folder)\n2. Right-click on it ‚Üí Choose \"Extract All\"\n3. Extract it to a simple location like `C:\\src\\flutter`\n   - ‚ö†Ô∏è **Important**: Do NOT put it in a folder like `C:\\Program Files`\n\n**Step 3: Add Flutter to Your PATH**\n\n*What's PATH? It's like your computer's phonebook. When you type \"flutter\" in a terminal, your computer looks through its PATH to find where the flutter program lives. We're adding Flutter's location to that phonebook.*\n\nOpen PowerShell (search for \"PowerShell\" in the Start menu) and run:\n\n\n**Step 4: Verify Installation**\n\nClose and reopen PowerShell, then run:\n\n\n",
              "code": "flutter doctor",
              "language": "powershell"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### **FOR MAC USERS:**\n\n**Step 1: Download Flutter**\n1. Open Safari and go to: `https://docs.flutter.dev/get-started/install/macos`\n2. Choose your Mac type:\n   - **Intel Mac**: Download \"Intel Chip\" version\n   - **Apple Silicon (M1/M2/M3)**: Download \"Apple Silicon\" version\n\n**Step 2: Extract and Move the Files**\n\nOpen Terminal (press `Cmd + Space`, type \"Terminal\", press Enter):\n\n\n**Step 3: Add Flutter to Your PATH**\n\n\n**Step 4: Verify Installation**\n\n\n",
              "code": "flutter doctor",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### **FOR LINUX USERS:**\n\nOpen Terminal:\n\n\n**Verify Installation**:\n\n\n",
              "code": "flutter doctor",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nOnce you've successfully installed Flutter, you're ready to move on to **Lesson 2: Setting Up Your Editor**. In the next lesson, we'll install VS Code and configure it to work perfectly with Flutter.\n\nGreat job completing your first lesson! üéâ\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Flutter's Rendering Engine: Impeller",
              "content": "\n**What is Impeller?**\n\nImpeller is Flutter's next-generation rendering engine that replaced Skia. Think of it as the \"graphics card driver\" that draws everything you see on screen.\n\n**Why Impeller Matters:**\n- **No more shader jank**: Impeller pre-compiles shaders, eliminating first-frame stutters\n- **Predictable performance**: Consistent 60/120fps frame rates\n- **Native GPU acceleration**: Uses Metal (iOS) and Vulkan (Android)\n\n**When was it enabled?**\n- iOS: Default since Flutter 3.10 (May 2023)\n- Android: Default since Flutter 3.16 (November 2023)\n\nYou don't need to do anything to enable Impeller‚Äîit's automatic! This is why Flutter apps feel smoother than ever in 2025.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "0.1-challenge-0",
              "title": "Practice Challenge",
              "description": "1. Open your terminal (PowerShell on Windows, Terminal on Mac/Linux) 2. Run this command:    ```bash    flutter --version    ``` 3. You should see something like:    ```    Flutter 3.24.0 ‚Ä¢ channel stable    Tools ‚Ä¢ Dart 3.5.0    ``` 4. Now run:    ```bash    flutter doctor    ``` 5. You'll probably see:    - ‚úÖ Green checkmarks (Flutter, Dart)    - ‚ùå Red X marks (Android Studio, Chrome, Xcode) ---",
              "instructions": "1. Open your terminal (PowerShell on Windows, Terminal on Mac/Linux) 2. Run this command:    ```bash    flutter --version    ``` 3. You should see something like:    ```    Flutter 3.24.0 ‚Ä¢ channel stable    Tools ‚Ä¢ Dart 3.5.0    ``` 4. Now run:    ```bash    flutter doctor    ``` 5. You'll probably see:    - ‚úÖ Green checkmarks (Flutter, Dart)    - ‚ùå Red X marks (Android Studio, Chrome, Xcode) ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Flutter Installation Verification\n// This challenge is about running terminal commands.\n// The expected terminal commands are:\n//\n// Step 1: Check Flutter version\n// flutter --version\n//\n// Step 2: Run Flutter doctor\n// flutter doctor\n//\n// Expected output should show:\n// - Flutter SDK version (e.g., 3.24.0)\n// - Dart version (e.g., 3.5.0)\n// - Green checkmarks for installed components\n//\n// In Dart code, you could verify installation like this:\n\nvoid main() {\n  // This is a setup exercise - the actual work\n  // is done in the terminal, not in code.\n  //\n  // Commands to run:\n  // 1. flutter --version\n  // 2. flutter doctor\n  //\n  // After running flutter doctor, you should see:\n  // [‚úì] Flutter (installed)\n  // [‚úì] Dart (installed)\n  //\n  // Some items may show [!] or [‚úó] for optional\n  // components like Android Studio or Xcode.\n  \n  print('Flutter installation verified!');\n  print('Run these commands in your terminal:');\n  print('  flutter --version');\n  print('  flutter doctor');\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Program prints Flutter verification message",
                  "expectedOutput": "Flutter installation verified!",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Program includes terminal command instructions",
                  "expectedOutput": "flutter --version",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Program mentions flutter doctor command",
                  "expectedOutput": "flutter doctor",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "0.2",
          "title": "Module 0, Lesson 2: Setting Up Your Editor",
          "moduleId": "module-00",
          "order": 2,
          "estimatedMinutes": 45,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What's an Editor?",
              "content": "\nThink of writing code like writing a book. You *could* use Notepad or TextEdit, but professional writers use Microsoft Word or Google Docs because they have spell-check, grammar suggestions, and formatting tools.\n\nFor programming, we use a special kind of text editor called an **IDE** (Integrated Development Environment) or **code editor**. These tools:\n- Highlight your code with colors (making it easier to read)\n- Catch mistakes as you type (like spell-check)\n- Auto-complete your code (like text predictions on your phone)\n- Let you run and test your app with one click\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Technical Names",
              "content": "\nFor Flutter development, we recommend **Visual Studio Code** (VS Code for short). Don't confuse this with \"Visual Studio\" - they're different programs!\n\n**Why VS Code?**\n- It's **free** and works on Windows, Mac, and Linux\n- It's **lightweight** (doesn't slow down your computer)\n- It has **amazing Flutter support** through extensions\n- It's what most Flutter developers use\n\n"
            },
            {
              "type": "THEORY",
              "title": "Installation Steps",
              "content": "\n### Step 1: Download VS Code\n\n1. Go to: `https://code.visualstudio.com`\n2. Click the big download button (it auto-detects your operating system)\n3. Install it like any other program:\n   - **Windows**: Run the `.exe` file\n   - **Mac**: Drag the `.app` to your Applications folder\n   - **Linux**: Follow the instructions for your distribution\n\n### Step 2: Install the Flutter Extension\n\nOnce VS Code is installed:\n\n1. **Open VS Code**\n2. Click the **Extensions** icon on the left sidebar (it looks like four squares)\n3. In the search bar, type: `Flutter`\n4. Find the extension called **\"Flutter\"** by Dart Code\n5. Click **Install**\n\nThis will automatically install two extensions:\n- **Flutter**: Adds Flutter-specific features\n- **Dart**: Adds support for the Dart language\n\n"
            },
            {
              "type": "THEORY",
              "title": "Step 3: Verify Everything Works",
              "content": "\nLet's make sure VS Code can talk to Flutter!\n\n1. **Open the Command Palette**:\n   - Windows/Linux: Press `Ctrl + Shift + P`\n   - Mac: Press `Cmd + Shift + P`\n\n2. Type: `Flutter: Run Flutter Doctor`\n\n3. Press Enter\n\n4. You should see a terminal open showing the `flutter doctor` output\n\nIf you see green checkmarks for Flutter and Dart, you're all set! ‚úÖ\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Understanding the VS Code Interface",
              "content": "\nHere's a quick tour of what you'll see:\n\n\n**Key Parts:**\n- **Side Bar** (left): File explorer, search, source control, extensions\n- **Main Editor** (center): Where you write code\n- **Terminal** (bottom): Where you run commands and see output\n\n",
              "code": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Menu Bar                                ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ      ‚îÇ                                  ‚îÇ\n‚îÇ Side ‚îÇ    Main Editor                   ‚îÇ\n‚îÇ Bar  ‚îÇ    (Your code goes here)         ‚îÇ\n‚îÇ      ‚îÇ                                  ‚îÇ\n‚îÇ      ‚îÇ                                  ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ Terminal / Debug Console                ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Useful VS Code Shortcuts",
              "content": "\nLearn these - they'll save you tons of time:\n\n| Shortcut | What It Does |\n|----------|--------------|\n| `Ctrl/Cmd + P` | Quick file search |\n| `Ctrl/Cmd + Shift + P` | Command palette |\n| `Ctrl/Cmd + B` | Toggle sidebar |\n| `Ctrl/Cmd + J` | Toggle terminal |\n| `Ctrl/Cmd + S` | Save file |\n| `Ctrl/Cmd + /` | Comment/uncomment code |\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn the next lesson, we'll actually create and run your very first Flutter app! We'll see \"Hello World\" running on a simulated phone right on your computer.\n\nYou're making great progress! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "0.2-challenge-0",
              "title": "Practice Challenge",
              "description": "1. **Change the theme** (optional, but fun!):    - Press `Ctrl/Cmd + K`, then `Ctrl/Cmd + T`    - Browse through themes and pick one you like    - Popular choices: \"Dark+ (default)\", \"Monokai\", \"Dracula\" 2. **Adjust font size**:    - Press `Ctrl/Cmd + ,` to open Settings    - Search for \"font size\"    - Try different sizes until it's comfortable (14-16 is common) 3. **Test the Flutter extension**:    - Press `Ctrl/Cmd + Shift + P`    - Type \"Flutter: New Project\"    - See if the command appears (don't run it yet!) ---",
              "instructions": "1. **Change the theme** (optional, but fun!):    - Press `Ctrl/Cmd + K`, then `Ctrl/Cmd + T`    - Browse through themes and pick one you like    - Popular choices: \"Dark+ (default)\", \"Monokai\", \"Dracula\" 2. **Adjust font size**:    - Press `Ctrl/Cmd + ,` to open Settings    - Search for \"font size\"    - Try different sizes until it's comfortable (14-16 is common) 3. **Test the Flutter extension**:    - Press `Ctrl/Cmd + Shift + P`    - Type \"Flutter: New Project\"    - See if the command appears (don't run it yet!) ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: VS Code Editor Setup\n// This challenge is about configuring VS Code.\n//\n// The hands-on steps are:\n// 1. Theme: Ctrl/Cmd + K, then Ctrl/Cmd + T to change theme\n// 2. Font Size: Ctrl/Cmd + , to open Settings, search 'font size'\n// 3. Flutter Extension: Ctrl/Cmd + Shift + P, type 'Flutter: New Project'\n//\n// Here's a simple Dart program to verify your setup works:\n\nvoid main() {\n  // This is a comment - your editor should color it differently!\n  \n  // Variables - should be highlighted as keywords\n  final String editorName = 'VS Code';\n  const int recommendedFontSize = 14;\n  \n  // Print statements to test your setup\n  print('Welcome to Flutter development!');\n  print('Editor: $editorName');\n  print('Recommended font size: $recommendedFontSize-16px');\n  \n  // If you can see syntax highlighting and run this,\n  // your editor is set up correctly!\n  print('Setup complete! Your editor is ready.');\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Program prints welcome message",
                  "expectedOutput": "Welcome to Flutter development!",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Program displays editor name",
                  "expectedOutput": "Editor: VS Code",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Program confirms setup complete",
                  "expectedOutput": "Setup complete! Your editor is ready.",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "0.3",
          "title": "Module 0, Lesson 3: Running Your First \"Hello World\"",
          "moduleId": "module-00",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Moment of Truth",
              "content": "\nRemember all that setup we did? The Flutter installation, the editor configuration? This is where it all comes together. You're about to create and run your very first Flutter app!\n\nThink of this like turning on a new toy for the first time. We don't need to understand how all the wires and circuits work inside - we just want to see the lights turn on and know everything is working.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What is \"Hello World\"?",
              "content": "\nIn programming, \"Hello World\" is a tradition. It's the simplest possible program that just displays the text \"Hello World\" on the screen. It's used to verify that:\n- Your tools are installed correctly\n- You can create a new project\n- You can run code\n- You can see the result\n\nOnce you see \"Hello World\" running, you'll know your development environment is ready for real work!\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Creating Your First Project",
              "content": "\n### Step 1: Open VS Code\n\nLaunch Visual Studio Code (the editor we installed in the previous lesson).\n\n### Step 2: Create a New Flutter Project\n\n1. Press `Ctrl/Cmd + Shift + P` to open the command palette\n2. Type: `Flutter: New Project`\n3. Select **Application**\n4. Choose a location on your computer (like a folder called \"FlutterProjects\")\n5. Name your project: `hello_world` (must be lowercase with underscores, no spaces!)\n6. Press Enter\n\nVS Code will now create your project. This takes 30-60 seconds. You'll see a progress indicator.\n\n### Step 3: Explore What Was Created\n\nLook at the **Explorer** panel (left sidebar). You'll see a folder structure:\n\n\n**The only file you need to know about right now is `lib/main.dart`**. This is where your app's code lives.\n\n",
              "code": "hello_world/\n‚îú‚îÄ‚îÄ lib/\n‚îÇ   ‚îî‚îÄ‚îÄ main.dart        ‚Üê This is YOUR code file\n‚îú‚îÄ‚îÄ android/             ‚Üê Android-specific files\n‚îú‚îÄ‚îÄ ios/                 ‚Üê iOS-specific files\n‚îú‚îÄ‚îÄ web/                 ‚Üê Web-specific files\n‚îú‚îÄ‚îÄ test/                ‚Üê Testing files\n‚îî‚îÄ‚îÄ pubspec.yaml         ‚Üê Project configuration",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "üìÅ What's the test/ Folder For?",
              "content": "\nYou might be wondering about that `test/` folder. This is where you'll put **Widget Tests** - automated checks that verify your app works correctly!\n\n### Widget Testing: A Quick Preview\n\nThink of it like having a robot that clicks buttons and checks results for you:\n\n```dart\n// test/counter_test.dart\ntestWidgets('Counter increments when + is tapped', (tester) async {\n  // 1. BUILD: Create the widget\n  await tester.pumpWidget(MyApp());\n  \n  // 2. FIND: Locate the counter text\n  expect(find.text('0'), findsOneWidget);  // Starts at 0\n  \n  // 3. ACT: Tap the + button\n  await tester.tap(find.byIcon(Icons.add));\n  await tester.pump();  // Rebuild after state change\n  \n  // 4. VERIFY: Check the counter increased\n  expect(find.text('1'), findsOneWidget);  // Now shows 1!\n});\n```\n\n**Key concepts** (we'll learn these in Module 10):\n- `testWidgets()` - Runs a widget test\n- `tester.pumpWidget()` - Builds your widget\n- `find.text('0')` - Locates text on screen\n- `tester.tap()` - Simulates a tap\n- `expect()` - Checks if something is true\n\n**Run tests with:** `flutter test`\n\n**Don't worry!** You don't need to write tests now. Just know that the `test/` folder exists for automated quality checks. We cover testing in depth in Module 10!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Running Your App",
              "content": "\n### Step 1: Choose a Device\n\nAt the bottom-right of VS Code, you should see a device selector. Click it and choose one of:\n- **Chrome** (easiest for beginners - runs in a web browser)\n- **Windows** / **macOS** / **Linux** (if available)\n- **Android Emulator** (if you have one set up)\n- **iOS Simulator** (Mac only, if set up)\n\nFor this lesson, **choose Chrome** - it's the simplest option.\n\n### Step 2: Run the App\n\nThere are three ways to run your app:\n\n**Option 1**: Press `F5`\n\n**Option 2**: Press `Ctrl/Cmd + Shift + P`, type \"Flutter: Run\", press Enter\n\n**Option 3**: Click the \"Run\" button in the top-right corner\n\nChoose any method. You'll see:\n1. A terminal opens at the bottom\n2. Text scrolling by (this is Flutter building your app)\n3. After 10-30 seconds, a window opens showing your app!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You're Seeing",
              "content": "\nCongratulations! You're running a Flutter app! üéâ\n\nYou should see:\n- A blue app bar at the top with \"hello_world\" as the title\n- A counter showing \"0\"\n- A button with a \"+\" icon at the bottom-right\n\n**Try clicking the + button!** The counter increases. You just interacted with a real, working app!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Understanding the Magic (Just a Peek)",
              "content": "\nOpen the file `lib/main.dart`. You'll see about 110 lines of code. Don't worry - we're not going to understand all of it yet.\n\nBut notice around line 94, you'll see:\n\n\nThis is the line that displays the counter! When you press the + button, the number `_counter` changes, and the screen updates.\n\n**Don't try to understand this code yet.** We'll learn every single piece in the upcoming lessons. For now, just know: *this is what makes the number appear*.\n\n",
              "code": "Text(\n  '$_counter',\n  style: Theme.of(context).textTheme.headlineMedium,\n),",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Making Your First Change",
              "content": "Let's personalize this app! Find line 31 in main.dart and change the title. After saving, the app instantly updates. This is Hot Reload - Flutter's superpower that lets you see changes instantly without restarting!",
              "code": "// BEFORE (line 31 in main.dart):\ntitle: 'Flutter Demo',\n\n// AFTER:\ntitle: 'My First App',\n\n// Steps:\n// 1. Find line 31 in main.dart\n// 2. Change 'Flutter Demo' to 'My First App'\n// 3. Save file (Ctrl/Cmd + S)\n// 4. Watch your app update instantly!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Understanding Hot Reload vs Hot Restart",
              "content": "\nThese are two important concepts:\n\n- **Hot Reload** (`Ctrl/Cmd + S` or the lightning bolt icon):\n  - Injects your code changes into the running app\n  - Keeps the app's current state (counter stays at 10)\n  - Takes 1-2 seconds\n  - Use this 95% of the time\n\n- **Hot Restart** (`Ctrl/Cmd + Shift + F5` or circular arrow icon):\n  - Restarts the app from scratch\n  - Resets all state (counter goes back to 0)\n  - Takes a few seconds\n  - Use this when something seems broken\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap what you just did:\n- ‚úÖ Created a brand new Flutter project\n- ‚úÖ Ran the app on Chrome/your device\n- ‚úÖ Interacted with a real, working app\n- ‚úÖ Made code changes and saw them update instantly\n- ‚úÖ Experienced Hot Reload (Flutter's superpower!)\n\n**This is a huge milestone!** You now have a working development environment and you've run your first app.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn the next module, we're going to slow down and learn the Dart programming language from scratch. We'll start with the absolute basics:\n- How to store information (variables)\n- How to make decisions (if/else)\n- How to repeat actions (loops)\n\nAll taught interactively, with lots of practice!\n\nSee you in Module 1! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "0.3-challenge-0",
              "title": "Practice Challenge",
              "description": "1. **Change the title** (you just did this!) 2. **Change the button text**:    - Find line 96: `Text('You have pushed the button this many times:'),`    - Change it to something fun like: `Text('Button presses:'),`    - Save and watch it update! 3. **Click the button 10 times**    - Get that counter to at least 10! 4. **Try Hot Restart**:    - Notice the counter stays at 10    - Press `Ctrl/Cmd + Shift + F5` (or click the circular arrow icon)    - This is \"Hot Restart\" - the counter resets to 0! ---",
              "instructions": "1. **Change the title** (you just did this!) 2. **Change the button text**:    - Find line 96: `Text('You have pushed the button this many times:'),`    - Change it to something fun like: `Text('Button presses:'),`    - Save and watch it update! 3. **Click the button 10 times**    - Get that counter to at least 10! 4. **Try Hot Restart**:    - Notice the counter stays at 10    - Press `Ctrl/Cmd + Shift + F5` (or click the circular arrow icon)    - This is \"Hot Restart\" - the counter resets to 0! ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Your First Flutter App with Hot Reload\n// This shows a modified counter app with custom text\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      // Step 1: Changed the title\n      title: 'My First Flutter App',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n      ),\n      home: const MyHomePage(title: 'My Awesome App'),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  const MyHomePage({super.key, required this.title});\n  final String title;\n\n  @override\n  State<MyHomePage> createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n        title: Text(widget.title),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 2: Changed the button text\n            const Text('Button presses:'),\n            Text(\n              '$_counter',\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _incrementCounter,\n        tooltip: 'Increment',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n// Hot Reload: Save file (Ctrl/Cmd + S) to see changes instantly\n// Hot Restart: Press Ctrl/Cmd + Shift + F5 to reset state",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Flutter app builds and runs successfully",
                  "expectedOutput": "App displays counter widget with increment button",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Counter increments on button press",
                  "expectedOutput": "Counter value increases from 0 to 1 when FloatingActionButton is pressed",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Hot reload updates UI instantly",
                  "expectedOutput": "Text changes are reflected without losing counter state",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "0.4",
          "title": "Module 0, Lesson 4: Understanding the Emulator vs Physical Device",
          "moduleId": "module-00",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Where Will Your App Run?",
              "content": "\nYou've installed Flutter and created your first app. But where does it actually run? You have several options, and each has its purpose.\n\nThink of it like testing a new board game:\n- **Playing solo at home** = Running on your computer (easiest, fastest)\n- **Playing on a practice board** = Using an emulator (simulates a real phone)\n- **Playing the actual game** = Using a real phone (most accurate)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Your Options for Running Flutter Apps",
              "content": "\nFlutter can run your app in multiple places:\n\n### 1. **Web Browser (Chrome/Edge/Safari)**\n- **Best for**: Quick testing, beginners\n- **Speed**: Fastest to start\n- **Limitations**: Can't test phone-specific features (camera, GPS, etc.)\n\n### 2. **Desktop (Windows/Mac/Linux)**\n- **Best for**: Apps that work on computers too\n- **Speed**: Very fast\n- **Limitations**: Different screen sizes and interactions than phones\n\n### 3. **Emulator/Simulator**\n- **Best for**: Testing on virtual phones without owning one\n- **Speed**: Slower to start (2-5 minutes first time)\n- **Limitations**: Uses more computer resources (RAM, CPU)\n\n### 4. **Physical Device**\n- **Best for**: Final testing, real-world performance\n- **Speed**: Fast once connected\n- **Limitations**: Requires a real phone and USB cable\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up the Android Emulator",
              "content": "\nThis is like having a virtual phone inside your computer.\n\n### Step 1: Install Android Studio\n\nEven though we're using VS Code, we need Android Studio for the emulator.\n\n1. Download from: `https://developer.android.com/studio`\n2. Install it (this will take 5-10 minutes)\n3. Open Android Studio\n4. Click \"More Actions\" ‚Üí \"SDK Manager\"\n5. Make sure these are checked:\n   - Android SDK Platform-Tools\n   - Android SDK Build-Tools\n   - Android SDK Command-line Tools\n\n### Step 2: Create a Virtual Device\n\n1. In Android Studio, click \"More Actions\" ‚Üí \"Virtual Device Manager\"\n2. Click \"Create Device\"\n3. Choose a phone model (Pixel 6 is a good default)\n4. Click \"Next\"\n5. Download a system image (recommended: latest stable release)\n6. Click \"Next\" ‚Üí \"Finish\"\n\n### Step 3: Start the Emulator\n\n1. In the Virtual Device Manager, click the ‚ñ∂ play button next to your device\n2. Wait 1-2 minutes for it to boot up\n3. You'll see a virtual phone appear on your screen!\n\n### Step 4: Verify in VS Code\n\n1. Open VS Code\n2. Look at the bottom-right corner\n3. Click where it shows the device\n4. You should see your new emulator listed!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "üíæ LIGHTWEIGHT ALTERNATIVE: Skip Android Studio (Save 5GB+)",
              "content": "\n**Want to save disk space?** You can install ONLY the Command Line Tools instead of the full Android Studio IDE (which is 5-10GB). This is for advanced users comfortable with the terminal.\n\n### Option B: Command Line Tools Only\n\n**Step 1: Download Command Line Tools**\n\nGo to: `https://developer.android.com/studio#command-tools`\n\nDownload \"Command line tools only\" for your OS (~150MB instead of 1GB+).\n\n**Step 2: Set Up Directory Structure**\n\n```bash\n# Create Android SDK directory\nmkdir -p ~/Android/Sdk/cmdline-tools\n\n# Extract downloaded zip to:\n~/Android/Sdk/cmdline-tools/latest/\n```\n\n**Step 3: Set Environment Variables**\n\n```bash\n# Add to ~/.bashrc, ~/.zshrc, or PowerShell profile\nexport ANDROID_SDK_ROOT=$HOME/Android/Sdk\nexport PATH=$PATH:$ANDROID_SDK_ROOT/cmdline-tools/latest/bin\nexport PATH=$PATH:$ANDROID_SDK_ROOT/platform-tools\nexport PATH=$PATH:$ANDROID_SDK_ROOT/emulator\n```\n\n**Step 4: Install Required Components**\n\n```bash\n# Accept licenses\nsdkmanager --licenses\n\n# Install essential components\nsdkmanager \"platform-tools\"\nsdkmanager \"emulator\"\nsdkmanager \"platforms;android-34\"\nsdkmanager \"system-images;android-34;google_apis;x86_64\"\nsdkmanager \"build-tools;34.0.0\"\n```\n\n**Step 5: Create and Run Emulator**\n\n```bash\n# Create virtual device\navdmanager create avd -n pixel6 -k \"system-images;android-34;google_apis;x86_64\"\n\n# Start emulator\nemulator -avd pixel6\n```\n\n**Step 6: Verify Flutter Sees It**\n\n```bash\nflutter doctor\nflutter devices\n```\n\n### Which Should You Choose?\n\n| Option | Disk Space | Ease of Use | Recommended For |\n|--------|------------|-------------|------------------|\n| Android Studio (Full) | ~10GB | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Easy | Beginners |\n| Command Line Tools | ~2GB | ‚≠ê‚≠ê Advanced | Experienced devs |\n\n**Our Recommendation**: If you're learning Flutter, install the full Android Studio - it's easier and has helpful visual tools. The command line approach is great if you're experienced or have limited disk space.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up a Physical Android Device",
              "content": "\n### Step 1: Enable Developer Mode\n\nOn your Android phone:\n\n1. Go to **Settings** ‚Üí **About Phone**\n2. Find \"Build Number\"\n3. Tap it **7 times** (yes, really!)\n4. You'll see \"You are now a developer!\"\n\n### Step 2: Enable USB Debugging\n\n1. Go to **Settings** ‚Üí **Developer Options**\n2. Turn on **USB Debugging**\n3. Connect your phone to your computer with a USB cable\n\n### Step 3: Trust Your Computer\n\nWhen you connect:\n- Your phone will show \"Allow USB debugging?\"\n- Check \"Always allow from this computer\"\n- Tap \"OK\"\n\n### Step 4: Verify Connection\n\nIn your terminal/PowerShell:\n\n\nYou should see your phone listed!\n\n",
              "code": "flutter devices",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Setting Up iOS Simulator (Mac Only)",
              "content": "\nIf you're on a Mac, you can test iOS apps too!\n\n### Step 1: Install Xcode\n\n1. Open the **App Store**\n2. Search for \"Xcode\"\n3. Click \"Get\" (this is a large download - 10GB+)\n4. Wait for installation (15-30 minutes)\n\n### Step 2: Install Command Line Tools\n\nOpen Terminal:\n\n\n### Step 3: Open the Simulator\n\n\nAn iPhone simulator will appear!\n\n### Step 4: Verify in VS Code\n\nYou should now see iOS simulators in the device selector.\n\n",
              "code": "open -a Simulator",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Which Should You Use?",
              "content": "\nHere's a practical guide:\n\n| Stage | Recommended Device |\n|-------|-------------------|\n| **Learning basics** | Chrome (web) - fastest |\n| **Building UI** | Android Emulator or iOS Simulator |\n| **Testing features** | Physical device |\n| **Final testing** | Multiple physical devices |\n\n**Pro Tip**: Start with Chrome for quick iterations. Once your app looks good, test on an emulator. Before releasing, always test on a real phone!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Running Your App on Different Devices",
              "content": "\n### Option 1: Using the VS Code GUI\n\n1. Click the device selector (bottom-right)\n2. Choose your target device\n3. Press F5 or click \"Run\"\n\n### Option 2: Using the Terminal\n\n\n",
              "code": "# List available devices\nflutter devices\n\n# Run on a specific device\nflutter run -d <device-id>\n\n# Run on Chrome\nflutter run -d chrome\n\n# Run on all connected devices\nflutter run -d all",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Common Issues and Fixes",
              "content": "\n### \"No devices found\"\n\n**Solution**: Make sure at least one is running:\n- Start Chrome\n- Start an emulator\n- Connect a physical device\n\n### Emulator is very slow\n\n**Solutions**:\n- Enable hardware acceleration in BIOS (Intel VT-x or AMD-V)\n- Increase RAM allocated to emulator (in Android Studio)\n- Use a physical device instead\n\n### \"Waiting for another flutter command to release the startup lock\"\n\n**Solution**:\n\n### iOS Simulator not showing\n\n**Mac Only Solution**:\n\n",
              "code": "sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Hot Reload Across Devices",
              "content": "\nHere's something cool: **Hot Reload works on all devices!**\n\nTry this:\n1. Run your app on any device\n2. Change some text in your code\n3. Save the file (Ctrl/Cmd + S)\n4. Watch it update instantly!\n\nThis works whether you're on Chrome, emulator, or physical device.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Understanding Device IDs",
              "content": "\nWhen you run `flutter devices`, you see output like:\n\n\nEach line shows:\n- **Device name**: What it's called\n- **Device ID**: How Flutter identifies it (`chrome`, `emulator-5554`, etc.)\n- **Platform**: web, android, ios\n- **Version**: OS version\n\n",
              "code": "Chrome (web) ‚Ä¢ chrome ‚Ä¢ web-javascript ‚Ä¢ Google Chrome 119.0\nsdk gphone64 arm64 (mobile) ‚Ä¢ emulator-5554 ‚Ä¢ android-arm64 ‚Ä¢ Android 13\niPhone 14 Pro (mobile) ‚Ä¢ 12345-ABCD ‚Ä¢ ios ‚Ä¢ iOS 16.0",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ Flutter apps can run on web, desktop, emulators, and physical devices\n- ‚úÖ Each has trade-offs (speed vs accuracy)\n- ‚úÖ Chrome is fastest for quick testing\n- ‚úÖ Emulators simulate real phones\n- ‚úÖ Physical devices give the most accurate results\n- ‚úÖ Hot reload works everywhere!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nNow that you know where your apps can run, what happens when something goes wrong?\n\nIn the next lesson, we'll learn **Troubleshooting Common Setup Issues** - how to fix the most common problems developers face when getting started.\n\nSee you there! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "0.4-challenge-0",
              "title": "Practice Challenge",
              "description": "1. **Run on Chrome**:    - Select Chrome from device list    - Run your hello_world app    - Take a screenshot 2. **Run on Emulator or Physical Device**:    - Set up an Android emulator OR connect your phone    - Select it from device list    - Run the same app    - Notice any differences? 3. **Compare**:    - Does the app look the same?    - Does it run at the same speed?    - Which feels better? ---",
              "instructions": "1. **Run on Chrome**:    - Select Chrome from device list    - Run your hello_world app    - Take a screenshot 2. **Run on Emulator or Physical Device**:    - Set up an Android emulator OR connect your phone    - Select it from device list    - Run the same app    - Notice any differences? 3. **Compare**:    - Does the app look the same?    - Does it run at the same speed?    - Which feels better? ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Running on Different Devices\n// This challenge is about testing your app on multiple platforms.\n//\n// Terminal commands to run your app:\n//\n// 1. List available devices:\n//    flutter devices\n//\n// 2. Run on Chrome (web):\n//    flutter run -d chrome\n//\n// 3. Run on Android emulator:\n//    flutter run -d emulator-5554\n//\n// 4. Run on connected physical device:\n//    flutter run -d <device-id>\n//\n// Here's a sample app that works on all platforms:\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MultiPlatformApp());\n}\n\nclass MultiPlatformApp extends StatelessWidget {\n  const MultiPlatformApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Multi-Platform Demo',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),\n        useMaterial3: true,\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Hello Flutter!'),\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            const Icon(Icons.devices, size: 64),\n            const SizedBox(height: 16),\n            Text(\n              'Running on Flutter!',\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n            const SizedBox(height: 8),\n            const Text('This app works on Web, Android, iOS, and Desktop'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Key observations:\n// - Chrome: Fastest to start, good for quick testing\n// - Emulator: More accurate representation of mobile\n// - Physical device: Best for real performance testing",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "App runs successfully on multiple platforms",
                  "expectedOutput": "App displays 'Running on Flutter!' message with devices icon",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "flutter devices command lists available targets",
                  "expectedOutput": "At least one device (Chrome, emulator, or physical) is available",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "App adapts to different screen sizes",
                  "expectedOutput": "UI renders correctly on web, mobile emulator, and physical device",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "0.5",
          "title": "Module 0, Lesson 5: Troubleshooting Common Setup Issues",
          "moduleId": "module-00",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "When Things Go Wrong",
              "content": "\nEven experienced developers encounter setup issues. The good news? Most problems have simple solutions, and you're not alone!\n\nThink of troubleshooting like being a detective:\n- **The crime**: Your app won't run\n- **The clues**: Error messages\n- **The solution**: Following the evidence\n\nThis lesson teaches you how to solve the most common problems you'll face.\n\n"
            },
            {
              "type": "THEORY",
              "title": "The #1 Troubleshooting Tool: flutter doctor",
              "content": "\nThis command checks your entire setup and tells you what's wrong.\n\n\n**What it checks**:\n- ‚úÖ Is Flutter installed?\n- ‚úÖ Is Dart available?\n- ‚úÖ Are Android tools installed?\n- ‚úÖ Is Xcode available? (Mac)\n- ‚úÖ Are there any missing dependencies?\n\n**How to read the output**:\n\n\n- **[‚úì]**: Working perfectly\n- **[!]**: Working but with warnings\n- **[‚úó]**: Not working, needs fixing\n\n",
              "code": "[‚úì] Flutter (Channel stable, 3.24.0)\n[‚úó] Android toolchain - develop for Android devices\n    ‚úó Android SDK not found\n[!] Xcode - develop for iOS and macOS (Xcode 15.0)\n    ‚úó CocoaPods not installed\n[‚úì] Chrome - develop for the web\n[‚úì] VS Code (version 1.85.0)",
              "language": "dart"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 1: \"flutter: command not found\"",
              "content": "\n### What it means:\nYour computer doesn't know where Flutter is installed.\n\n### Solution (Windows):\n\n\n### Solution (Mac/Linux):\n\n\n",
              "code": "# Find where you installed Flutter\nls ~/flutter/bin/flutter\n\n# Add to PATH (Mac with zsh)\necho 'export PATH=\"$PATH:$HOME/flutter/bin\"' >> ~/.zshrc\nsource ~/.zshrc\n\n# Or for bash\necho 'export PATH=\"$PATH:$HOME/flutter/bin\"' >> ~/.bashrc\nsource ~/.bashrc\n\n# Test\nflutter --version",
              "language": "bash"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 2: Android License Not Accepted",
              "content": "\n### Error message:\n\n### Solution:\n\n\nIf this doesn't work:\n\n1. Open Android Studio\n2. Go to **Settings** ‚Üí **Appearance & Behavior** ‚Üí **System Settings** ‚Üí **Android SDK**\n3. Click **SDK Tools** tab\n4. Check **Android SDK Command-line Tools**\n5. Click **Apply**\n\nThen run `flutter doctor --android-licenses` again.\n\n",
              "code": "# Accept all Android licenses\nflutter doctor --android-licenses\n\n# Type 'y' and press Enter for each license",
              "language": "bash"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 3: \"Waiting for another flutter command...\"",
              "content": "\n### Error message:\n\n### What happened:\nA previous Flutter command didn't finish properly and left a lock file.\n\n### Solution:\n\n\n",
              "code": "# Kill the lock file\ncd <your-flutter-installation>\nrm -f bin/cache/lockfile\n\n# Windows PowerShell:\nRemove-Item -Force bin/cache/lockfile\n\n# Or just restart your computer (easiest)",
              "language": "bash"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 4: Emulator Won't Start",
              "content": "\n### Symptom:\nEmulator starts but shows a black screen or crashes.\n\n### Solution 1: Enable Hardware Acceleration\n\n**Windows**:\n1. Open **Task Manager** ‚Üí **Performance**\n2. Check if \"Virtualization\" is enabled\n3. If not, enable Intel VT-x or AMD-V in BIOS\n\n**Mac**:\nHardware acceleration is enabled by default.\n\n**Linux**:\n\n### Solution 2: Allocate More RAM\n\n1. Open Android Studio\n2. **Tools** ‚Üí **Device Manager**\n3. Click the pencil icon (Edit) on your emulator\n4. Click **Show Advanced Settings**\n5. Increase RAM to at least 2048 MB\n6. Click **Finish**\n\n### Solution 3: Use a Different System Image\n\nSome system images work better than others:\n- Try **API 33** (Android 13) instead of the latest\n- Use **x86_64** images (faster than ARM)\n\n",
              "code": "# Install KVM\nsudo apt-get install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils\n\n# Add yourself to the kvm group\nsudo adduser $USER kvm",
              "language": "bash"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 5: App Builds But Crashes Immediately",
              "content": "\n### Check 1: Clean and Rebuild\n\n\n### Check 2: Check for Errors in Code\n\nLook at the terminal output. Common errors:\n\n‚Ü≥ Missing semicolon\n\n‚Ü≥ Missing import: `import 'package:flutter/material.dart';`\n\n‚Ü≥ Type mismatch - check your variables\n\n",
              "code": "Error: The argument type 'int' can't be assigned to 'String'",
              "language": "dart"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 6: Hot Reload Doesn't Work",
              "content": "\n### Symptoms:\n- You save changes but nothing updates\n- App needs full restart every time\n\n### Solutions:\n\n**1. Make sure you're editing the right file**\n- Are you editing `lib/main.dart`?\n- Not a file in `android/` or `ios/`?\n\n**2. Try Hot Restart instead**\n- Press `Ctrl/Cmd + Shift + F5`\n- Or click the circular arrow icon\n\n**3. Check for errors**\n- Look at the terminal for error messages\n- Fix any syntax errors\n\n**4. Full restart**\n\n",
              "code": "# Stop the app\nq (in terminal)\n\n# Clean\nflutter clean\n\n# Run again\nflutter run",
              "language": "bash"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 7: VS Code Not Finding Flutter",
              "content": "\n### Symptoms:\n- \"Dart\" or \"Flutter\" commands not available\n- No syntax highlighting\n- Can't run apps from VS Code\n\n### Solution:\n\n1. **Install Flutter Extension**:\n   - Press `Ctrl/Cmd + Shift + X`\n   - Search \"Flutter\"\n   - Install the official Flutter extension\n\n2. **Set Flutter SDK Path**:\n   - Press `Ctrl/Cmd + Shift + P`\n   - Type \"Flutter: Change SDK\"\n   - Select your Flutter installation path\n\n3. **Restart VS Code**:\n   - Close and reopen VS Code\n   - Check if Flutter commands work\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 8: Gradle Build Fails (Android)",
              "content": "\n### Error message:\n\n### Solution 1: Update Gradle\n\nEdit `android/build.gradle`:\n\n\n### Solution 2: Clear Gradle Cache\n\n\n### Solution 3: Update Java Version\n\nFlutter requires Java 11 or higher:\n\n\n",
              "code": "# Check Java version\njava -version\n\n# If it's older than 11, download from:\n# https://adoptium.net/",
              "language": "bash"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 9: Pod Install Fails (iOS/Mac)",
              "content": "\n### Error message:\n\n### Solution:\n\n\n",
              "code": "# Install CocoaPods\nsudo gem install cocoapods\n\n# Set up pods\npod setup\n\n# Then from your project:\ncd ios\npod install\ncd ..\n\n# Try running again\nflutter run",
              "language": "bash"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 10: \"Version Solving Failed\"",
              "content": "\n### Error message:\n\n### Solution:\n\n\n",
              "code": "# Update all packages\nflutter pub upgrade\n\n# If that doesn't work, delete lock file\nrm pubspec.lock\n\n# Get fresh dependencies\nflutter pub get",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "The Nuclear Option: Complete Reset",
              "content": "\nIf nothing else works, start fresh:\n\n\n",
              "code": "# 1. Clean everything\nflutter clean\n\n# 2. Delete build files\nrm -rf build/\nrm -rf .dart_tool/\n\n# 3. Reset pub cache\nflutter pub cache repair\n\n# 4. Get dependencies\nflutter pub get\n\n# 5. Run\nflutter run",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Getting Help When Stuck",
              "content": "\n### Official Resources:\n- **Flutter Docs**: https://docs.flutter.dev\n- **Flutter GitHub Issues**: https://github.com/flutter/flutter/issues\n- **Stack Overflow**: Tag your question with `[flutter]`\n\n### Search Strategy:\n1. Copy the exact error message\n2. Google: \"flutter [your error message]\"\n3. Look for recent results (last 1-2 years)\n4. Try the top 3 solutions\n\n### Ask for Help:\nWhen asking questions, include:\n- Exact error message (full output)\n- Output of `flutter doctor -v`\n- What you've already tried\n- Code snippet (if relevant)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Common Error Patterns",
              "content": "\n| If you see... | It usually means... |\n|---------------|---------------------|\n| `command not found` | PATH not set correctly |\n| `licenses not accepted` | Run `flutter doctor --android-licenses` |\n| `version solving failed` | Package conflict - run `flutter pub upgrade` |\n| `gradle build failed` | Android build issue - clean and rebuild |\n| `pod install failed` | iOS/Mac dependency issue - reinstall CocoaPods |\n| `waiting for lock` | Previous Flutter command stuck - restart |\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ `flutter doctor` is your best friend\n- ‚úÖ Most errors have simple solutions\n- ‚úÖ Clean and rebuild fixes many issues\n- ‚úÖ Error messages tell you what's wrong\n- ‚úÖ Google is your ally\n- ‚úÖ The Flutter community is helpful!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "üõ†Ô∏è Flutter DevTools - Your Advanced Debugging Suite",
              "content": "\nFlutter comes with powerful debugging tools called **Flutter DevTools**. Think of it as X-ray vision for your app!\n\n### What is DevTools?\n\nDevTools is a browser-based suite of debugging and profiling tools built specifically for Flutter and Dart.\n\n### Launching DevTools\n\n**Option 1: From VS Code**\n1. Run your app (`F5` or `flutter run`)\n2. Open Command Palette (`Ctrl/Cmd + Shift + P`)\n3. Type \"Dart: Open DevTools\"\n4. Choose which tool to open\n\n**Option 2: From Terminal**\n```bash\n# Run app and get observatory URL\nflutter run\n\n# In another terminal:\nflutter pub global activate devtools\nflutter pub global run devtools\n```\n\n**Option 3: From Browser**\nWhen running `flutter run`, look for:\n```\nFlutter DevTools: http://127.0.0.1:9100?uri=...\n```\n\n### DevTools Tabs Explained\n\n#### 1. üîç Widget Inspector (Most Important!)\n\nSee your entire widget tree visually:\n\n```\nüå≥ Widget Tree View:\n\nMaterialApp\n ‚îî‚îÄ Scaffold\n     ‚îú‚îÄ AppBar\n     ‚îÇ   ‚îî‚îÄ Text: \"My App\"\n     ‚îî‚îÄ Center\n         ‚îî‚îÄ Column\n             ‚îú‚îÄ Text: \"Hello\"\n             ‚îî‚îÄ ElevatedButton\n```\n\n**What you can do:**\n- Click any widget to see its properties\n- See padding, margins, and constraints\n- Find layout issues (overflow, wrong sizes)\n- Select widgets directly on the device/emulator\n\n**Pro Tip**: Click the \"Select Widget Mode\" button, then tap any widget in your app to jump directly to it in the tree!\n\n#### 2. üìä Performance Overlay\n\nMonitor your app's performance in real-time:\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ UI Thread:  ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë  16ms    ‚îÇ ‚Üê Should be under 16ms\n‚îÇ GPU Thread: ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  8ms     ‚îÇ ‚Üê Should be under 16ms\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Enable from code:**\n```dart\nMaterialApp(\n  showPerformanceOverlay: true,  // üëà Add this!\n  home: MyHomePage(),\n)\n```\n\n**What to look for:**\n- Green bars = Good (under 16ms = 60 FPS)\n- Red bars = Bad (frame dropped, causes jank)\n- Spikes = Potential performance issue\n\n#### 3. üß† Memory Tab\n\nTrack memory usage and find leaks:\n\n- See live memory graph\n- Detect memory leaks\n- Take heap snapshots\n- Compare allocations\n\n**Warning signs:**\n- Memory constantly increasing = potential leak\n- Spikes during specific actions = heavy operations\n\n#### 4. üåê Network Tab\n\nMonitor all HTTP requests:\n\n```\nMethod | URL                    | Status | Time\n-------+------------------------+--------+------\nGET    | api.example.com/users  | 200    | 120ms\nPOST   | api.example.com/login  | 401    | 85ms ‚ùå\nGET    | api.example.com/posts  | 200    | 95ms\n```\n\n**What you can inspect:**\n- Request headers and body\n- Response data\n- Timing (how long each request takes)\n- Failed requests\n\n#### 5. üêõ Debugger\n\nSet breakpoints and step through code:\n- Pause at any line\n- Inspect variables\n- Step in/out/over functions\n- Watch expressions\n\n#### 6. üìù Logging\n\nView all logs from your app:\n\n```dart\nimport 'dart:developer' as developer;\n\n// These show in DevTools Logging tab\ndeveloper.log('User logged in', name: 'Auth');\ndeveloper.log('Fetched 10 items', name: 'API');\n```\n\n### Quick Debugging Shortcuts (VS Code)\n\n| Shortcut | Action |\n|----------|--------|\n| `F5` | Start debugging |\n| `F9` | Toggle breakpoint |\n| `F10` | Step over |\n| `F11` | Step into |\n| `Shift+F11` | Step out |\n| `Ctrl+Shift+D` | Open Debug panel |\n\n### Debugging Layout Issues with Inspector\n\n**Problem**: Your widget is in the wrong place or the wrong size.\n\n**Solution**:\n1. Open Widget Inspector\n2. Click \"Select Widget Mode\" (crosshair icon)\n3. Tap the problematic widget in your app\n4. In DevTools, look at:\n   - **Constraints**: What size was it told it can be?\n   - **Size**: What size did it actually choose?\n   - **Parent**: Who gave it those constraints?\n\n```\nConstraints: BoxConstraints(0.0<=w<=400.0, 0.0<=h<=600.0)\nActual Size: Size(200.0, 50.0)\nParent: Center ‚Üí gives tight constraints from parent\n```\n\n### Performance Debugging Workflow\n\n1. **Enable Performance Overlay**\n2. **Use your app normally**\n3. **Watch for red bars** (dropped frames)\n4. **Open Timeline View** in DevTools\n5. **Record** the problematic action\n6. **Analyze** what's taking too long:\n   - Build? ‚Üí Too many widgets rebuilding\n   - Layout? ‚Üí Expensive layout calculations\n   - Paint? ‚Üí Complex graphics\n\n**Common fixes:**\n- Add `const` constructors\n- Use `ListView.builder` instead of `ListView`\n- Cache expensive calculations\n- Use `RepaintBoundary` for complex animations\n\n### DevTools Cheat Sheet\n\n| I want to... | Use... |\n|--------------|--------|\n| Find why layout is wrong | Widget Inspector |\n| Fix slow animations | Performance tab |\n| Find memory leaks | Memory tab |\n| Debug API calls | Network tab |\n| Set breakpoints | Debugger tab |\n| View logs | Logging tab |\n| Profile CPU usage | CPU Profiler tab |\n\n**Bookmark this**: https://docs.flutter.dev/tools/devtools\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\n**Congratulations!** You've completed Module 0! Your development environment is set up, and you know how to troubleshoot problems.\n\nIn **Module 1**, we'll dive into the Dart programming language. You'll learn:\n- How to store information (variables)\n- How to make decisions (if/else)\n- How to repeat actions (loops)\n- How to organize code (functions)\n\nAll taught interactively with lots of hands-on practice!\n\nReady to start coding? Let's go! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "0.5-challenge-0",
              "title": "Practice Challenge",
              "description": "1. **Run flutter doctor**:    ```bash    flutter doctor -v    ```    The `-v` flag shows more details. Take a screenshot! 2. **Check Flutter version**:    ```bash    flutter --version    ``` 3. **List connected devices**:    ```bash    flutter devices    ``` 4. **Intentionally break something**:    - Open your hello_world app    - Delete a semicolon `;` somewhere    - Try to run it    - Read the error message    - Fix it! ---",
              "instructions": "1. **Run flutter doctor**:    ```bash    flutter doctor -v    ```    The `-v` flag shows more details. Take a screenshot! 2. **Check Flutter version**:    ```bash    flutter --version    ``` 3. **List connected devices**:    ```bash    flutter devices    ``` 4. **Intentionally break something**:    - Open your hello_world app    - Delete a semicolon `;` somewhere    - Try to run it    - Read the error message    - Fix it! ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Troubleshooting and Debugging\n// This challenge teaches you to use diagnostic commands and read errors.\n//\n// Terminal commands covered:\n//\n// 1. Detailed doctor output:\n//    flutter doctor -v\n//\n// 2. Version check:\n//    flutter --version\n//\n// 3. List devices:\n//    flutter devices\n//\n// 4. Clean rebuild (useful for fixing issues):\n//    flutter clean && flutter pub get\n//\n// Example of code WITH an error (missing semicolon):\n\n// BROKEN CODE (will cause error):\n// void main() {\n//   print('Hello')  // <- Missing semicolon!\n// }\n//\n// Error message you'll see:\n// Error: Expected ';' after this.\n//   print('Hello')\n//                 ^\n\n// FIXED CODE:\nvoid main() {\n  print('Hello');  // <- Semicolon added!\n  \n  // Common syntax errors and fixes:\n  \n  // 1. Missing semicolon\n  // Error: Expected ';' after this\n  // Fix: Add ; at end of statement\n  \n  // 2. Mismatched brackets\n  // Error: Expected ')' or 'identifier'\n  // Fix: Check all opening brackets have closing ones\n  \n  // 3. Undefined variable\n  // Error: Undefined name 'variableName'\n  // Fix: Declare the variable before using it\n  \n  // 4. Type mismatch\n  // Error: A value of type 'X' can't be assigned to 'Y'\n  // Fix: Use correct types or add type conversion\n  \n  print('Troubleshooting complete!');\n  print('Remember: Error messages tell you WHAT is wrong and WHERE!');\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Program prints hello message",
                  "expectedOutput": "Hello",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Program confirms troubleshooting complete",
                  "expectedOutput": "Troubleshooting complete!",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Program explains error messages",
                  "expectedOutput": "Remember: Error messages tell you WHAT is wrong and WHERE!",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-01",
      "title": "Module 1: Flutter Development",
      "description": "Learn Flutter development - Module 1",
      "difficulty": "beginner",
      "estimatedHours": 7,
      "lessons": [
        {
          "id": "1.1",
          "title": "Module 1, Lesson 1: What is Code?",
          "moduleId": "module-01",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Welcome to Programming!",
              "content": "\nCongratulations on completing Module 0! You've got Flutter installed, your editor set up, and you've even run your first app. Now it's time to understand what's actually happening when you write code.\n\nThis is where your journey as a *real* programmer begins.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Recipe Analogy",
              "content": "\nImagine you're teaching a robot to make a sandwich. The robot is very literal - it only does *exactly* what you tell it to do.\n\nYou can't just say \"make me a sandwich.\" You need to give step-by-step instructions:\n\n\n**This is what code is**: A series of precise instructions that a computer follows, step by step.\n\n",
              "code": "1. Get two slices of bread\n2. Open the peanut butter jar\n3. Spread peanut butter on one slice\n4. Open the jelly jar\n5. Spread jelly on the other slice\n6. Put the two slices together\n7. Close both jars",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Code is Just Instructions",
              "content": "\nWhen you write code, you're writing instructions for a computer. The computer:\n- Reads your instructions from top to bottom (usually)\n- Executes them exactly as written\n- Doesn't make assumptions or \"guess\" what you meant\n- Will do exactly what you say, even if it's wrong!\n\nThis is both powerful and dangerous:\n- **Powerful**: You have complete control\n- **Dangerous**: Small mistakes (like forgetting a step) cause errors\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Line of Code",
              "content": "\nLet's write the simplest possible code. Open VS Code and create a new file called `first_code.dart`.\n\nType this exactly:\n\n\nNow run it:\n1. Press `Ctrl/Cmd + Shift + P`\n2. Type \"Dart: Run\"\n3. Press Enter\n\nYou should see in the terminal:\n\n\n**Congratulations!** You just wrote and executed your first program! üéâ\n\n",
              "code": "Hello, World!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Breaking It Down (Conceptual First)",
              "content": "\nLet's understand what each part does, *in plain English first*:\n\n\nThink of this like a play with actors on a stage:\n\n1. **The stage**: `main()` is the main stage where your program starts. Every Dart program must have a `main()`. It's the starting point.\n\n2. **The action**: Inside the curly braces `{ }` is what happens on that stage.\n\n3. **The dialogue**: `print('Hello, World!');` is like an actor saying a line. It displays text.\n\n",
              "code": "void main() {\n  print('Hello, World!');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Now the Technical Terms",
              "content": "\nNow that you understand the *concept*, here are the official programming terms:\n\n- **`void`**: This means \"doesn't give back any information.\" Don't worry about this yet.\n\n- **`main()`**: This is called a **function**. It's a container for instructions. The `main` function is special - it's where every program begins.\n\n- **`{ }`**: These curly braces define the **body** of the function. Everything inside them is part of `main`.\n\n- **`print()`**: This is also a function, but one that's already built into Dart. It displays text in the terminal.\n\n- **`'Hello, World!'`**: This is a **string** - programmer-speak for \"text.\" Strings always go in quotes.\n\n- **`;`**: The semicolon tells Dart \"this instruction is complete.\" It's like a period at the end of a sentence.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "The Golden Rule of Learning Code",
              "content": "\n**Don't memorize syntax. Understand concepts.**\n\nYou might forget whether to use `print()` or `display()`. That's okay! You can always look it up.\n\nWhat matters is understanding:\n- Programs run instructions in order\n- You need a starting point (`main`)\n- You can tell the computer to display text\n\nThe exact spelling and punctuation will become natural with practice.\n\n"
            },
            {
              "type": "EXPERIMENT",
              "title": "Let's Experiment!",
              "content": "\n### Experiment 1: Multiple Lines\n\nTry this:\n\n\nRun it. What do you see? Three lines of output!\n\n**Takeaway**: Instructions execute one after another, from top to bottom.\n\n### Experiment 2: What Happens If...?\n\nTry this (intentionally wrong):\n\n\nRun it. You get an error! Something like:\n\n\n**Takeaway**: Computers are picky. Every detail matters. Semicolons are required.\n\n### Experiment 3: Inside the Quotes\n\nTry this:\n\n\n**Takeaway**: Anything inside quotes is treated as text - numbers, symbols, emojis, everything!\n\n",
              "code": "void main() {\n  print('I can print numbers: 123');\n  print('I can print symbols: !@#$%');\n  print('I can even print emojis: üéâüöÄ');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Beginner Mistakes",
              "content": "\nHere are mistakes everyone makes at first:\n\n| Mistake | What Happens |\n|---------|--------------|\n| Forgetting `;` | Error: \"Expected ';'\" |\n| Mismatched quotes `'Hello\"` | Error: \"Unexpected character\" |\n| Forgetting `()` after `main` | Error: \"Expected '('\" |\n| Typing `Main` instead of `main` | Error: \"Expected 'main'\" |\n| Forgetting closing `}` | Error: \"Expected '}'\" |\n\n**These are normal!** Every programmer makes these mistakes. The computer will always tell you exactly what's wrong.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ Code is just step-by-step instructions\n- ‚úÖ Programs start at `main()`\n- ‚úÖ `print()` displays text\n- ‚úÖ Strings (text) go in quotes\n- ‚úÖ Semicolons end statements\n- ‚úÖ Computers are very literal and precise\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nRight now, we can only display pre-written text. What if we want to store information and reuse it?\n\nIn the next lesson, we'll learn about **variables** - how to store and work with information in your programs. Think of them as labeled boxes that hold data!\n\nSee you in the next lesson! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.1-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a file called `introduction.dart` and write a program that prints: ---",
              "instructions": "Create a file called `introduction.dart` and write a program that prints: ---",
              "starterCode": "My name is Alex\nI'm from New York\nI'm learning Flutter because I want to build my own apps!",
              "solution": "My name is Alex\nI'm from New York\nI'm learning Flutter because I want to build my own apps!",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Program prints name introduction",
                  "expectedOutput": "My name is Alex",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Program prints location",
                  "expectedOutput": "I'm from New York",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Program prints motivation for learning Flutter",
                  "expectedOutput": "I'm learning Flutter because I want to build my own apps!",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.2",
          "title": "Module 1, Lesson 2: Storing Information (Variables)",
          "moduleId": "module-01",
          "order": 2,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Box Analogy",
              "content": "\nImagine you're organizing your room. You have different boxes:\n- A box labeled \"TOYS\" containing your toys\n- A box labeled \"BOOKS\" containing your books\n- A box labeled \"CLOTHES\" containing your clothes\n\nEach box has:\n1. A **label** (so you know what's inside)\n2. **Contents** (the actual stuff)\n\nIn programming, we call these boxes **variables**. They let us store information and give it a name so we can use it later.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why Do We Need Variables?",
              "content": "\nLook at this code:\n\n\nWhat if we want to change the name from \"Sarah\" to \"John\"? We'd have to change it in 3 places!\n\nNow look at this:\n\n\nNow if we want to use a different name, we only change it in **one place**! That's the power of variables.\n\n",
              "code": "void main() {\n  var name = 'Sarah';\n  print('Hello, $name!');\n  print('Welcome back, $name!');\n  print('$name, you have 3 new messages.');\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Creating Your First Variable",
              "content": "\nThe basic syntax is:\n\n\nLet's break this down:\n\n**Conceptual Explanation**:\n- We're creating a box\n- The box is labeled `name`\n- We're putting the text `'Sarah'` inside it\n\n**Technical Terms**:\n- `var`: This keyword tells Dart \"I'm about to create a variable\"\n- `name`: This is the variable name (the label on the box)\n- `=`: This is the assignment operator (putting something in the box)\n- `'Sarah'`: This is the value (the contents of the box)\n\n",
              "code": "var name = 'Sarah';",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Different Types of Boxes",
              "content": "\nJust like in real life, we need different types of containers for different things. You wouldn't store milk in a cardboard box!\n\nIn Dart, variables have **types**:\n\n### 1. Text (Strings)\n\nFor storing words and sentences:\n\n\n### 2. Numbers (Integers)\n\nFor storing whole numbers:\n\n\n### 3. Decimal Numbers (Doubles)\n\nFor storing numbers with decimals:\n\n\n### 4. True/False (Booleans)\n\nFor storing yes/no, true/false values:\n\n\n",
              "code": "var isLoggedIn = true;\nvar hasNewMessages = false;\nvar isWeekend = true;",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Using Variables",
              "content": "\nOnce you create a variable, you can use it anywhere in your code:\n\n\n**Output**:\n\nNotice the `$` symbol? That's how we insert variables into strings. It's called **string interpolation**.\n\n",
              "code": "My name is Alex\nI am 28 years old\nI live in New York",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Changing Variable Contents",
              "content": "\nVariables aren't permanent - you can change what's inside the box:\n\n\nNotice: The second time, we don't use `var` - we already created the variable!\n\n",
              "code": "void main() {\n  var mood = 'happy';\n  print('I am feeling $mood');  // Output: I am feeling happy\n\n  mood = 'excited';  // Change the contents\n  print('Now I am feeling $mood');  // Output: Now I am feeling excited\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Variable Naming Rules",
              "content": "\nYou can't just name variables anything you want. There are rules:\n\n**‚úÖ Valid Names**:\n\n**‚ùå Invalid Names**:\n\n**Naming Convention (Best Practice)**:\n- Use camelCase: `firstName`, `myAge`, `isLoggedIn`\n- First word lowercase, subsequent words capitalized\n- Be descriptive: `userName` is better than `un`\n\n",
              "code": "var 2age = 25;           // Can't start with a number\nvar first-name = 'Alex'; // Can't use hyphens\nvar my age = 25;         // Can't have spaces\nvar class = 'Math';      // 'class' is a reserved word",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Explicit Types (Being More Specific)",
              "content": "\nInstead of using `var` (where Dart guesses the type), you can be explicit:\n\n\n**When to use `var` vs explicit types?**\n- `var`: When the type is obvious from the value\n- Explicit (`String`, `int`, etc.): When you want to be extra clear\n\nBoth work! It's mostly personal preference.\n\n",
              "code": "void main() {\n  String name = 'Sarah';      // This box only holds text\n  int age = 25;               // This box only holds integers\n  double price = 19.99;       // This box only holds decimals\n  bool isActive = true;       // This box only holds true/false\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Sound Null Safety: String vs String? Are DIFFERENT Types!",
              "content": "\nDart 3 has **sound null safety**, which prevents crashes from null values. Here's the key insight:\n\n### `String` and `String?` Are Completely Different Types!\n\n```dart\nString name = 'Alice';    // MUST have a value, NEVER null\nString? nickname = null;  // CAN be null (the ? makes it optional)\n```\n\n**Think of it like boxes:**\n- `String` = A box that MUST contain text (never empty)\n- `String?` = A box that MIGHT contain text OR be empty (null)\n\n### Why This Matters\n\n```dart\nvoid main() {\n  String name = 'Bob';     // ‚úÖ OK - has a value\n  // String name2 = null;  // ‚ùå ERROR! String can't be null\n  \n  String? nickname = null; // ‚úÖ OK - String? allows null\n  nickname = 'Bobby';      // ‚úÖ Can also hold a value\n}\n```\n\n### Working With Nullable Types\n\n```dart\nvoid main() {\n  String? userName = getUserName(); // Might be null\n  \n  // ‚ùå This WON'T work:\n  // print(userName.length);  // Error! userName might be null\n  \n  // ‚úÖ Option 1: Null check\n  if (userName != null) {\n    print(userName.length);  // Safe - we checked!\n  }\n  \n  // ‚úÖ Option 2: Elvis operator (provide default)\n  print(userName ?? 'Guest');  // If null, use 'Guest'\n  \n  // ‚úÖ Option 3: Safe navigation\n  print(userName?.length);  // Returns null if userName is null\n  \n  // ‚ö†Ô∏è Option 4: Force unwrap (DANGEROUS!)\n  // print(userName!.length);  // Crashes if null!\n}\n```\n\n### Quick Reference\n\n| Type | Can Be Null? | Example |\n|------|--------------|--------|\n| `String` | ‚ùå No | Must have text |\n| `String?` | ‚úÖ Yes | Can be null |\n| `int` | ‚ùå No | Must have number |\n| `int?` | ‚úÖ Yes | Can be null |\n| `List<String>` | ‚ùå No | Must have list |\n| `List<String>?` | ‚úÖ Yes | List or null |\n\n**Rule of Thumb**: Only use `?` when something truly might not exist. Prefer non-nullable types!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Math with Variables",
              "content": "\nYou can do math with number variables:\n\n\n**Note**: To print an actual `$` symbol, you need to escape it with `\\$`.\n\n",
              "code": "void main() {\n  var apples = 5;\n  var oranges = 3;\n  var totalFruit = apples + oranges;\n\n  print('Total fruit: $totalFruit');  // Output: Total fruit: 8\n\n  var price = 10.50;\n  var tax = 2.15;\n  var total = price + tax;\n\n  print('Total with tax: \\$${total}');  // Output: Total with tax: $12.65\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Beginner Mistakes",
              "content": "\n| Mistake | What Happens |\n|---------|--------------|\n| `var Name = 'Alex';` | Works, but should be `name` (lowercase first letter) |\n| `name = 'Alex';` without `var` first | Error: Variable not declared |\n| `var age = '25';` then trying to do math | Wrong! '25' is text, not a number |\n| `var age = 25; var age = 30;` | Error: Variable already declared |\n| Using a variable before creating it | Error: Undefined name |\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ Variables are like labeled boxes that store information\n- ‚úÖ Use `var` or explicit types (`String`, `int`, `double`, `bool`)\n- ‚úÖ Use `$variableName` to insert variables into strings\n- ‚úÖ Variables can be changed after creation\n- ‚úÖ We can do math with number variables\n- ‚úÖ Variable names follow specific rules\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nNow we can store information. But what if we want our program to make decisions?\n\n\"If the user is logged in, show the dashboard. Otherwise, show the login page.\"\n\n\"If the age is under 18, show 'You're a minor'. Otherwise, show 'You're an adult'.\"\n\nIn the next lesson, we'll learn about **conditionals** (if/else statements) - how to make your program smart enough to make decisions!\n\nSee you there! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.2-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a file called `my_profile.dart` with: 1. Variables for:    - Your full name (String)    - Your age (int)    - Your favorite food (String)    - Whether you like programming (bool - true or false)    - Your height in feet (double) 2. Print out all this information in a nice format --- ## Bonus Challenge: Do Some Math Add these variables and calculations: Does it match your age variable? ---",
              "instructions": "Create a file called `my_profile.dart` with: 1. Variables for:    - Your full name (String)    - Your age (int)    - Your favorite food (String)    - Whether you like programming (bool - true or false)    - Your height in feet (double) 2. Print out all this information in a nice format --- ## Bonus Challenge: Do Some Math Add these variables and calculations: Does it match your age variable? ---",
              "starterCode": "=== My Profile ===\nName: Alex Johnson\nAge: 28\nFavorite Food: Pizza\nLikes Programming: true\nHeight: 5.9 feet",
              "solution": "var currentYear = 2024;\nvar birthYear = 1996;  // Use your actual birth year\nvar calculatedAge = currentYear - birthYear;\n\nprint('Calculated age: $calculatedAge');",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Program displays profile header",
                  "expectedOutput": "=== My Profile ===",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Program displays name with variable",
                  "expectedOutput": "Name: Alex Johnson",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Program calculates age correctly",
                  "expectedOutput": "Calculated age: 28",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In dart, use appropriate syntax."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.3",
          "title": "Module 1, Lesson 3: Making Decisions (if/else)",
          "moduleId": "module-01",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Choose Your Own Adventure",
              "content": "\nRemember those \"Choose Your Own Adventure\" books?\n\n> You're standing at a fork in the road.\n> - If you go left, turn to page 42\n> - If you go right, turn to page 67\n\nPrograms need to make decisions like this all the time:\n- If the password is correct, log the user in. Otherwise, show an error.\n- If it's raining, bring an umbrella. Otherwise, leave it home.\n- If the score is above 90, show an \"A\". Otherwise, show a different grade.\n\nThis is what **conditionals** do - they let your program choose different paths based on conditions.\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Basic Pattern: if",
              "content": "\nHere's the simplest decision:\n\n\n**Conceptual Explanation**:\n- We check a condition: \"Is age greater than or equal to 18?\"\n- If the answer is YES (true), we run the code inside the `{ }`\n- If the answer is NO (false), we skip that code\n\n**Output**: `You are an adult!` (because 20 is >= 18)\n\n",
              "code": "void main() {\n  var age = 20;\n\n  if (age >= 18) {\n    print('You are an adult!');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Now the Technical Terms",
              "content": "\n\n- **`if`**: Keyword that starts a conditional\n- **`(condition)`**: The test we're checking (must be true or false)\n- **`{ }`**: The block of code to run if the condition is true\n\n",
              "code": "if (condition) {\n  // Code to run if condition is true\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Adding an \"Otherwise\": else",
              "content": "\nWhat if we want to do something when the condition is false?\n\n\n**Output**: `You are a minor.` (because 15 is not >= 18)\n\nThink of it like:\n- **IF** the condition is true, do the first thing\n- **OTHERWISE** (else), do the second thing\n\n",
              "code": "void main() {\n  var age = 15;\n\n  if (age >= 18) {\n    print('You are an adult!');\n  } else {\n    print('You are a minor.');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Multiple Choices: else if",
              "content": "\nWhat if you have more than two options?\n\n\n**Output**: `Grade: B`\n\nThe program:\n1. Checks if score >= 90 (NO, 85 is not >= 90)\n2. Checks if score >= 80 (YES! ‚Üí runs this block)\n3. Stops checking (once one condition is true, it skips the rest)\n\n",
              "code": "void main() {\n  var score = 85;\n\n  if (score >= 90) {\n    print('Grade: A');\n  } else if (score >= 80) {\n    print('Grade: B');\n  } else if (score >= 70) {\n    print('Grade: C');\n  } else if (score >= 60) {\n    print('Grade: D');\n  } else {\n    print('Grade: F');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Comparison Operators",
              "content": "\nThese are the symbols we use to compare things:\n\n| Operator | Meaning | Example |\n|----------|---------|---------|\n| `==` | Equal to | `age == 18` |\n| `!=` | Not equal to | `age != 18` |\n| `>` | Greater than | `age > 18` |\n| `<` | Less than | `age < 18` |\n| `>=` | Greater than or equal | `age >= 18` |\n| `<=` | Less than or equal | `age <= 18` |\n\n**Common Mistake**: Using `=` instead of `==`\n- `=` means \"assign a value\" (putting something in a box)\n- `==` means \"compare for equality\" (checking if two things are equal)\n\n\n",
              "code": "var age = 18;      // ‚úÖ Assignment (setting age to 18)\nif (age == 18) {   // ‚úÖ Comparison (checking if age equals 18)\n  print('Age is 18');\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Real-World Examples",
              "content": "\n### Example 1: Login Check\n\n\n### Example 2: Weather Advice\n\n\n**Note**: `\\'` lets you put an apostrophe inside a single-quoted string.\n\n### Example 3: Shopping Cart\n\n\n**Output**: `You need $5.0 more.`\n\n",
              "code": "void main() {\n  var itemPrice = 50.00;\n  var walletMoney = 45.00;\n\n  if (walletMoney >= itemPrice) {\n    print('Purchase successful!');\n  } else {\n    var shortage = itemPrice - walletMoney;\n    print('You need \\$$shortage more.');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Combining Conditions: AND / OR",
              "content": "\nSometimes you need to check multiple things at once.\n\n### AND (&&) - Both must be true\n\n\n### OR (||) - At least one must be true\n\n\n### NOT (!) - Flips true/false\n\n\n",
              "code": "void main() {\n  var isRaining = false;\n\n  if (!isRaining) {\n    print('It\\'s not raining. Let\\'s go outside!');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Patterns",
              "content": "\n### Pattern 1: Range Checking\n\n\n### Pattern 2: Eligibility Checking\n\n\n### Pattern 3: Validation\n\n\n",
              "code": "var username = '';\n\nif (username == '') {\n  print('Error: Username cannot be empty');\n} else {\n  print('Username: $username');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Beginner Mistakes",
              "content": "\n| Mistake | What Happens |\n|---------|--------------|\n| `if (age = 18)` instead of `if (age == 18)` | Syntax error or unexpected behavior |\n| Forgetting `{ }` around code blocks | Only the first line is conditional |\n| `if (age > 18 && < 30)` | Syntax error - need `age < 30` |\n| Not covering all cases with else | Some inputs might not do anything |\n| Checking conditions in wrong order | Wrong condition might match first |\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ `if` lets programs make decisions\n- ‚úÖ `else` handles the \"otherwise\" case\n- ‚úÖ `else if` handles multiple options\n- ‚úÖ Comparison operators: `==`, `!=`, `>`, `<`, `>=`, `<=`\n- ‚úÖ Logical operators: `&&` (AND), `||` (OR), `!` (NOT)\n- ‚úÖ Conditions must evaluate to true or false\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nNow we can store information (variables) and make decisions (if/else). But what if we need to do something many times?\n\nFor example:\n- Print numbers 1 through 100\n- Process every item in a shopping cart\n- Repeat a game until the player wants to quit\n\nIn the next lesson, we'll learn about **loops** - how to repeat actions without copying and pasting code!\n\nSee you there! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.3-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a file called `age_advice.dart` that: 1. Has a variable `age` set to your age (or any age) 2. Uses if/else if/else to print different messages:    - If age < 13: \"You're a child! Enjoy playing!\"    - If age >= 13 and < 20: \"You're a teenager! Study hard!\"    - If age >= 20 and < 65: \"You're an adult! Work hard, but enjoy life!\"    - If age >= 65: \"You're a senior! Time to relax and enjoy retirement!\" --- ## Bonus Challenge: Grade Calculator Create a program that takes a score (0-100) and:   - 93-100: A   - 90-92: A-   - 87-89: B+   - And so on... This is tricky! You'll need nested conditions or multiple checks. ---",
              "instructions": "Create a file called `age_advice.dart` that: 1. Has a variable `age` set to your age (or any age) 2. Uses if/else if/else to print different messages:    - If age < 13: \"You're a child! Enjoy playing!\"    - If age >= 13 and < 20: \"You're a teenager! Study hard!\"    - If age >= 20 and < 65: \"You're an adult! Work hard, but enjoy life!\"    - If age >= 65: \"You're a senior! Time to relax and enjoy retirement!\" --- ## Bonus Challenge: Grade Calculator Create a program that takes a score (0-100) and:   - 93-100: A   - 90-92: A-   - 87-89: B+   - And so on... This is tricky! You'll need nested conditions or multiple checks. ---",
              "starterCode": "You're an adult! Work hard, but enjoy life!",
              "solution": "You're an adult! Work hard, but enjoy life!",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Adult age (25) displays correct message",
                  "expectedOutput": "You're an adult! Work hard, but enjoy life!",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Child age (10) displays correct message",
                  "expectedOutput": "You're a child! Enjoy playing!",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Senior age (70) displays correct message",
                  "expectedOutput": "You're a senior! Time to relax and enjoy retirement!",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In dart, use appropriate syntax."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.4",
          "title": "Module 1, Lesson 4: Repeating Actions (Loops)",
          "moduleId": "module-01",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Chore Analogy",
              "content": "\nImagine your parent tells you: \"Wash all 10 dishes in the sink.\"\n\nYou wouldn't write:\n\nYou'd think: \"**Repeat** washing until all dishes are done.\"\n\nThat's exactly what **loops** do in programming - they repeat actions without you having to write the same code over and over.\n\n",
              "code": "Wash dish 1\nWash dish 2\nWash dish 3\nWash dish 4\nWash dish 5\nWash dish 6\nWash dish 7\nWash dish 8\nWash dish 9\nWash dish 10",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Why Do We Need Loops?",
              "content": "\nLook at this code:\n\n\nWhat if you have 100 users? Or 1000? You can't write 1000 lines!\n\nWith a loop:\n\n\n**Output**:\n\nSame result, way less code!\n\n",
              "code": "Welcome user 1!\nWelcome user 2!\nWelcome user 3!\nWelcome user 4!\nWelcome user 5!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "The \"for\" Loop - Counting Repetitions",
              "content": "\nWhen you know **exactly how many times** to repeat something, use a `for` loop.\n\n**Conceptual Explanation**:\nThink of it like counting:\n- **Start** at 1\n- **Keep going** while less than or equal to 5\n- **Count up** by 1 each time\n\n**The Pattern**:\n\n\n**Real Example**:\n\n\n**Output**:\n\n",
              "code": "This is repetition number 1\nThis is repetition number 2\nThis is repetition number 3",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the \"for\" Loop",
              "content": "\n\n**The Three Parts**:\n\n1. **`var i = 1`** - **Start**: Create a counter starting at 1\n2. **`i <= 3`** - **Condition**: Keep looping while i is ‚â§ 3\n3. **`i++`** - **Increment**: Add 1 to i after each loop\n\n**`i++` is shorthand for `i = i + 1`**\n\n**What Happens**:\n- First time: i = 1, prints \"Count: 1\", then i becomes 2\n- Second time: i = 2, prints \"Count: 2\", then i becomes 3\n- Third time: i = 3, prints \"Count: 3\", then i becomes 4\n- Fourth time: i = 4, but 4 is not ‚â§ 3, so STOP\n\n",
              "code": "for (var i = 1; i <= 3; i++) {\n  print('Count: $i');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Different Counting Patterns",
              "content": "\n### Counting Down\n\n\n**Output**:\n\n**Note**: `i--` means \"subtract 1\" (shorthand for `i = i - 1`)\n\n### Counting by 2s\n\n\n**Output**:\n\n**Note**: `i += 2` means \"add 2\" (shorthand for `i = i + 2`)\n\n### Starting from Any Number\n\n\n",
              "code": "void main() {\n  for (var age = 18; age <= 21; age++) {\n    print('At age $age, you can...');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "The \"while\" Loop - Repeat Until...",
              "content": "\nWhen you **don't know how many times** you'll repeat, but you know **when to stop**, use a `while` loop.\n\n**Conceptual Explanation**:\nThink of it like: \"**While** it's raining, stay inside.\"\n- You don't know how long it will rain\n- But you know the condition to check\n\n**The Pattern**:\n\n\n**Real Example**:\n\n\n**Output**:\n\n**‚ö†Ô∏è Warning**: If you forget `count++`, the loop runs FOREVER (infinite loop)!\n\n",
              "code": "Count is 1\nCount is 2\nCount is 3\nCount is 4\nCount is 5",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Real-World Examples",
              "content": "\n### Example 1: Multiplication Table\n\n\n**Output**:\n\n### Example 2: Password Attempts\n\n\n### Example 3: Sum of Numbers\n\n\n",
              "code": "void main() {\n  var sum = 0;\n\n  for (var i = 1; i <= 10; i++) {\n    sum += i;  // Same as: sum = sum + i\n  }\n\n  print('Sum of 1 to 10 is: $sum');  // Output: 55\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "The \"break\" Keyword - Exit Early",
              "content": "\nSometimes you want to **stop a loop** before it naturally ends:\n\n\n**Output**:\n\n**Use case**: Searching for something - once you find it, stop looking!\n\n",
              "code": "1\n2\n3\n4\n5\nLoop stopped",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "The \"continue\" Keyword - Skip to Next",
              "content": "\nSometimes you want to **skip the current iteration** and continue with the next:\n\n\n**Output**:\n\n**Notice**: 3 is missing because we skipped it!\n\n**Use case**: Filtering - process items that match a condition, skip others.\n\n",
              "code": "1\n2\n4\n5",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Nested Loops - Loops Inside Loops",
              "content": "\nYou can put loops inside loops!\n\n\n**Output**:\n\n**Use case**: Grid patterns, tables, 2D games (rows and columns).\n\n",
              "code": "Row 1, Column 1\nRow 1, Column 2\nRow 1, Column 3\nRow 2, Column 1\nRow 2, Column 2\nRow 2, Column 3\nRow 3, Column 1\nRow 3, Column 2\nRow 3, Column 3",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Beginner Mistakes",
              "content": "\n| Mistake | What Happens |\n|---------|--------------|\n| Forgetting `i++` in while loop | Infinite loop! |\n| Using `=` instead of `==` in condition | Always true or syntax error |\n| Starting at wrong number | Loop runs wrong number of times |\n| Off-by-one error (`< 5` vs `<= 5`) | Loop runs one too few or too many times |\n| Forgetting `var` before `i` | Error: i not defined |\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ Loops let us repeat code without copy-pasting\n- ‚úÖ `for` loops are for known repetitions\n- ‚úÖ `while` loops run until a condition is false\n- ‚úÖ `i++` increments, `i--` decrements\n- ‚úÖ `break` exits a loop early\n- ‚úÖ `continue` skips to the next iteration\n- ‚úÖ Nested loops create patterns and grids\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nNow we can store data (variables), make decisions (if/else), and repeat actions (loops). But what if we want to **organize** our code into reusable pieces?\n\nIn the next lesson, we'll learn about **Functions** - how to create your own custom commands that you can use over and over!\n\nThink of them as creating your own recipes that you can follow anytime.\n\nSee you there! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.4-challenge-0",
              "title": "Practice Challenge",
              "description": "Print this pattern using nested loops: --- ## Bonus Challenge: FizzBuzz This is a classic programming interview question! ---",
              "instructions": "Print this pattern using nested loops: --- ## Bonus Challenge: FizzBuzz This is a classic programming interview question! ---",
              "starterCode": "*\n**\n***\n****\n*****",
              "solution": "1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n...",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Pattern starts with single asterisk",
                  "expectedOutput": "*",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Pattern includes five asterisks on last row",
                  "expectedOutput": "*****",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "FizzBuzz prints Fizz for multiples of 3",
                  "expectedOutput": "Fizz",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 2,
                  "text": "Use a for loop or while loop to repeat the operation."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.5",
          "title": "Module 1, Lesson 5: Reusable Instructions (Functions)",
          "moduleId": "module-01",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Recipe Analogy",
              "content": "\nImagine you love making peanut butter sandwiches. Instead of remembering all the steps every time, you have a recipe card:\n\n\nNow, whenever you want a sandwich, you just say \"Make PB&J Sandwich\" and follow the recipe!\n\n**Functions are exactly like this** - they're named sets of instructions you can use over and over.\n\n",
              "code": "Recipe: Make PB&J Sandwich\n1. Get two slices of bread\n2. Spread peanut butter on one slice\n3. Spread jelly on the other slice\n4. Put the slices together\n5. Cut in half",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Why Do We Need Functions?",
              "content": "\nLook at this repetitive code:\n\n\nWe're printing those equals signs multiple times. With a function:\n\n\n**Same output, cleaner code!**\n\n",
              "code": "void printBorder() {\n  print('==========');\n}\n\nvoid main() {\n  printBorder();\n  print('Welcome!');\n  printBorder();\n\n  print('Processing...');\n\n  printBorder();\n  print('Done!');\n  printBorder();\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Creating Your First Function",
              "content": "\n**Conceptual Explanation**:\nA function is like creating your own command. Once you define it, you can use it anywhere!\n\n**The Pattern**:\n\n\n**Real Example**:\n\n\n**Output**:\n\n",
              "code": "Hello!\nWelcome to Flutter!\nHave a great day!\nHello!\nWelcome to Flutter!\nHave a great day!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down a Function",
              "content": "\n\n**The Parts**:\n\n1. **`void`** - This means \"doesn't give anything back\" (we'll learn about returning values soon)\n2. **`sayHello`** - The function name (use camelCase)\n3. **`()`** - Parameters go here (empty for now)\n4. **`{ }`** - The function body (code to run)\n\n",
              "code": "void sayHello() {\n  print('Hello!');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Functions with Parameters - Making Them Flexible",
              "content": "\nWhat if you want to greet different people?\n\n**Without parameters** (rigid):\n\n**With parameters** (flexible):\n\n**Conceptual Explanation**:\nParameters are like **placeholders** or **blank spaces** in your recipe that you fill in when you use it.\n\n",
              "code": "void greet(String name) {\n  print('Hello, $name!');\n}\n\nvoid main() {\n  greet('Alice');  // Output: Hello, Alice!\n  greet('Bob');    // Output: Hello, Bob!\n  greet('Charlie'); // Output: Hello, Charlie!\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Multiple Parameters",
              "content": "\nYou can have multiple parameters:\n\n\n**Output**:\n\n**Order matters!** The values you pass must match the parameter order.\n\n",
              "code": "Hi! My name is Sarah.\nI am 25 years old.\nI live in New York.\nHi! My name is Mike.\nI am 30 years old.\nI live in Los Angeles.",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Functions That Return Values",
              "content": "\nSometimes you want a function to **give you back** a result.\n\n**Conceptual Explanation**:\nThink of a vending machine:\n- You put in money and press a button (call the function)\n- It **returns** a snack to you (the return value)\n\n**The Pattern**:\n\n\n**Real Example**:\n\n\n**Notice**:\n- **`int`** instead of `void` - this function returns an integer\n- **`return`** keyword sends the value back\n\n",
              "code": "int add(int a, int b) {\n  return a + b;\n}\n\nvoid main() {\n  var result = add(5, 3);\n  print('5 + 3 = $result');  // Output: 5 + 3 = 8\n\n  var another = add(10, 20);\n  print('10 + 20 = $another'); // Output: 10 + 20 = 30\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "More Return Examples",
              "content": "\n### Calculate Area of Rectangle\n\n\n### Check if Adult\n\n\n### Get Greeting Based on Time\n\n\n",
              "code": "String getGreeting(int hour) {\n  if (hour < 12) {\n    return 'Good morning!';\n  } else if (hour < 18) {\n    return 'Good afternoon!';\n  } else {\n    return 'Good evening!';\n  }\n}\n\nvoid main() {\n  print(getGreeting(9));   // Output: Good morning!\n  print(getGreeting(14));  // Output: Good afternoon!\n  print(getGreeting(20));  // Output: Good evening!\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Optional Parameters",
              "content": "\nSometimes you want parameters to be **optional**:\n\n\n**Square brackets `[]`** make a parameter optional with a default value.\n\n",
              "code": "void greet(String name, [String greeting = 'Hello']) {\n  print('$greeting, $name!');\n}\n\nvoid main() {\n  greet('Alice');              // Output: Hello, Alice!\n  greet('Bob', 'Hi');          // Output: Hi, Bob!\n  greet('Charlie', 'Hey');     // Output: Hey, Charlie!\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Named Parameters",
              "content": "\nNamed parameters make your code more readable:\n\n\n**Benefits**:\n- **Clear**: You can see what each value is for\n- **Flexible**: Order doesn't matter\n- **`required`**: Makes sure important parameters aren't forgotten\n\n",
              "code": "void createUser({required String name, required int age, String country = 'USA'}) {\n  print('Name: $name');\n  print('Age: $age');\n  print('Country: $country');\n}\n\nvoid main() {\n  createUser(name: 'Alice', age: 25);\n  createUser(name: 'Bob', age: 30, country: 'Canada');\n  createUser(age: 28, name: 'Charlie');  // Order doesn't matter!\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Arrow Functions (Shorthand)",
              "content": "\nFor simple, one-line functions:\n\n**Long way**:\n\n**Short way** (arrow function):\n\n**More examples**:\n\n\n",
              "code": "String shout(String text) => text.toUpperCase();\nbool isEven(int number) => number % 2 == 0;\nint square(int x) => x * x;\n\nvoid main() {\n  print(shout('hello'));    // Output: HELLO\n  print(isEven(4));         // Output: true\n  print(square(5));         // Output: 25\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Real-World Examples",
              "content": "\n### Temperature Converter\n\n\n### Discount Calculator\n\n\n### Password Validator\n\n\n",
              "code": "bool isPasswordStrong(String password) {\n  if (password.length < 8) {\n    return false;\n  }\n  if (!password.contains(RegExp(r'[0-9]'))) {\n    return false;  // Must have a number\n  }\n  return true;\n}\n\nvoid main() {\n  print(isPasswordStrong('weak'));          // Output: false\n  print(isPasswordStrong('strong123'));     // Output: true\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Function Scope - Variable Visibility",
              "content": "\nVariables inside a function can't be seen outside:\n\n\n**Global vs Local**:\n\n\n",
              "code": "var globalVar = 'I am global';\n\nvoid myFunction() {\n  var localVar = 'I am local';\n  print(globalVar);  // ‚úÖ Can access global\n  print(localVar);   // ‚úÖ Can access local\n}\n\nvoid main() {\n  print(globalVar);  // ‚úÖ Can access global\n  // print(localVar);  // ‚ùå Error: localVar only exists inside myFunction\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Beginner Mistakes",
              "content": "\n| Mistake | What Happens |\n|---------|--------------|\n| Forgetting `()` when calling | Function isn't called |\n| Wrong number of arguments | Error: Expected X arguments |\n| Wrong type of argument | Type error |\n| Forgetting `return` | Function returns null |\n| Returning from `void` function | Error: can't return value |\n| Calling function before defining it | Error: function not found |\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ Functions organize code into reusable pieces\n- ‚úÖ Parameters make functions flexible\n- ‚úÖ `return` sends values back\n- ‚úÖ Return type must match what you return\n- ‚úÖ Named parameters improve readability\n- ‚úÖ Arrow functions are shorthand for simple functions\n- ‚úÖ Variables inside functions are local (scoped)\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nNow we can:\n- Store data (variables)\n- Make decisions (if/else)\n- Repeat actions (loops)\n- Organize code (functions)\n\nBut what if we need to store **multiple related items**? Like a shopping list with many items?\n\nIn the next lesson, we'll learn about **Lists and Maps** - how to organize collections of data!\n\nSee you there! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.5-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a file called `calculator.dart`: ### Bonus Challenge 1: Make it Interactive Add a function that takes an operation name: ### Bonus Challenge 2: Add More Operations Add these functions: ---",
              "instructions": "Create a file called `calculator.dart`: ### Bonus Challenge 1: Make it Interactive Add a function that takes an operation name: ### Bonus Challenge 2: Add More Operations Add these functions: ---",
              "starterCode": "// TODO: Create these functions\n\nint add(int a, int b) {\n  // Your code here\n}\n\nint subtract(int a, int b) {\n  // Your code here\n}\n\nint multiply(int a, int b) {\n  // Your code here\n}\n\ndouble divide(int a, int b) {\n  // Your code here\n}\n\nvoid main() {\n  print('10 + 5 = ${add(10, 5)}');\n  print('10 - 5 = ${subtract(10, 5)}');\n  print('10 * 5 = ${multiply(10, 5)}');\n  print('10 / 5 = ${divide(10, 5)}');\n}",
              "solution": "10 + 5 = 15\n10 - 5 = 5\n10 * 5 = 50\n10 / 5 = 2.0",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Addition function returns correct result",
                  "expectedOutput": "10 + 5 = 15",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Subtraction function returns correct result",
                  "expectedOutput": "10 - 5 = 5",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Division function returns correct decimal result",
                  "expectedOutput": "10 / 5 = 2.0",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the dart syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.6",
          "title": "Module 1, Lesson 6: Organizing Collections (Lists and Maps)",
          "moduleId": "module-01",
          "order": 6,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Shopping List Analogy",
              "content": "\nImagine you're going grocery shopping. You could create separate variables:\n\n\nBut that's clunky! What if you have 20 items? Or 100?\n\nInstead, you'd write a **list**:\n\n**Lists in programming work the same way** - they store multiple related items in one place.\n\n",
              "code": "Shopping List:\n1. Milk\n2. Bread\n3. Eggs\n4. Butter",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What is a List?",
              "content": "\n**Conceptual Explanation**:\nA List is like a numbered container with multiple compartments, each holding one item.\n\n\n**Note**: Lists start counting at **0**, not 1! This is called \"zero-indexing.\"\n\n",
              "code": "List of fruits:\n[0] Apple\n[1] Banana\n[2] Orange\n[3] Mango",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Creating Your First List",
              "content": "\n\n**The Parts**:\n- **`var fruits`** - Variable name for the list\n- **`[]`** - Square brackets indicate a list\n- **`'Apple', 'Banana', 'Orange'`** - Items separated by commas\n\n",
              "code": "void main() {\n  var fruits = ['Apple', 'Banana', 'Orange'];\n\n  print(fruits);  // Output: [Apple, Banana, Orange]\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Accessing List Items",
              "content": "\nUse the index (position number) to access items:\n\n\n**Remember**: The first item is at index 0!\n\n\n",
              "code": "Index:  0        1         2\nList:  [Apple | Banana | Orange]",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "List Length",
              "content": "\nHow many items are in a list?\n\n\n**Useful pattern**: The last item is always at index `length - 1`:\n\n\n",
              "code": "void main() {\n  var fruits = ['Apple', 'Banana', 'Orange'];\n\n  var lastIndex = fruits.length - 1;\n  print('Last fruit: ${fruits[lastIndex]}');  // Output: Orange\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Adding Items to a List",
              "content": "\n\n**`.add()`** adds an item to the **end** of the list.\n\n",
              "code": "void main() {\n  var fruits = ['Apple', 'Banana'];\n\n  print(fruits);  // Output: [Apple, Banana]\n\n  fruits.add('Orange');\n  print(fruits);  // Output: [Apple, Banana, Orange]\n\n  fruits.add('Mango');\n  print(fruits);  // Output: [Apple, Banana, Orange, Mango]\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Removing Items",
              "content": "\n\n**Two ways to remove**:\n- **`remove('value')`** - Remove specific item\n- **`removeAt(index)`** - Remove by position\n\n",
              "code": "void main() {\n  var fruits = ['Apple', 'Banana', 'Orange'];\n\n  fruits.remove('Banana');\n  print(fruits);  // Output: [Apple, Orange]\n\n  fruits.removeAt(0);  // Remove by index\n  print(fruits);  // Output: [Orange]\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Looping Through Lists",
              "content": "\n**This is super common!** You'll do this all the time in Flutter.\n\n### Method 1: For-each Loop\n\n\n**Output**:\n\n**Read as**: \"For each fruit in fruits, print...\"\n\n### Method 2: Traditional For Loop\n\n\n**Output**:\n\n",
              "code": "Fruit 1: Apple\nFruit 2: Banana\nFruit 3: Orange",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Different Types of Lists",
              "content": "\n### List of Numbers\n\n\n### List of Booleans\n\n\n### Mixed Type List (not recommended)\n\n\n**Best Practice**: Keep lists to one type.\n\n",
              "code": "var mixed = [1, 'hello', true, 3.14];  // Works, but confusing!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Typed Lists (Recommended)",
              "content": "\nBe explicit about what type of items your list holds:\n\n\n",
              "code": "void main() {\n  List<String> fruits = ['Apple', 'Banana'];\n  List<int> numbers = [1, 2, 3];\n  List<double> prices = [19.99, 24.50];\n\n  // fruits.add(123);  // ‚ùå Error: can't add int to List<String>\n  fruits.add('Orange');  // ‚úÖ Works!\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction to Maps",
              "content": "\n**Conceptual Explanation**:\nThink of a dictionary - you look up a **word** (key) to find its **meaning** (value).\n\nMaps work the same way: they store **key-value pairs**.\n\n**Real-world example**: A phone book\n- **Key**: Person's name\n- **Value**: Phone number\n\n\n",
              "code": "\"Alice\" ‚Üí \"555-1234\"\n\"Bob\"   ‚Üí \"555-5678\"\n\"Carol\" ‚Üí \"555-9012\"",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Creating Your First Map",
              "content": "\n\n**The Parts**:\n- **`{}`** - Curly braces indicate a Map\n- **`'Alice':`** - The key\n- **`'555-1234'`** - The value\n- **`,`** - Separates pairs\n\n",
              "code": "void main() {\n  var phoneBook = {\n    'Alice': '555-1234',\n    'Bob': '555-5678',\n    'Carol': '555-9012'\n  };\n\n  print(phoneBook);\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Accessing Map Values",
              "content": "\nUse the key to get the value:\n\n\n",
              "code": "void main() {\n  var phoneBook = {\n    'Alice': '555-1234',\n    'Bob': '555-5678',\n  };\n\n  print(phoneBook['Alice']);  // Output: 555-1234\n  print(phoneBook['Bob']);    // Output: 555-5678\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Looping Through Maps",
              "content": "\n\n**Output**:\n\n**Or using entries**:\n\n\n",
              "code": "void main() {\n  var scores = {'Alice': 95, 'Bob': 87};\n\n  for (var entry in scores.entries) {\n    print('${entry.key} scored ${entry.value}');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Typed Maps (Recommended)",
              "content": "\n\n**`Map<KeyType, ValueType>`** specifies both types.\n\n",
              "code": "void main() {\n  Map<String, int> ages = {\n    'Alice': 25,\n    'Bob': 30\n  };\n\n  Map<String, double> prices = {\n    'Apple': 1.99,\n    'Banana': 0.59\n  };\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Real-World Examples",
              "content": "\n### User Profile\n\n\n### Product Inventory\n\n\n### Shopping Cart\n\n\n",
              "code": "void main() {\n  List<Map<String, dynamic>> cart = [\n    {'name': 'Laptop', 'price': 999.99, 'quantity': 1},\n    {'name': 'Mouse', 'price': 29.99, 'quantity': 2},\n  ];\n\n  var total = 0.0;\n  for (var item in cart) {\n    total += item['price'] * item['quantity'];\n  }\n\n  print('Total: \\$$total');  // Output: Total: $1059.97\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ Lists store multiple items in order\n- ‚úÖ Lists use zero-based indexing [0, 1, 2...]\n- ‚úÖ Use `add()`, `remove()`, `length` with Lists\n- ‚úÖ Maps store key-value pairs\n- ‚úÖ Use keys to access values: `map[key]`\n- ‚úÖ Loop through both Lists and Maps\n- ‚úÖ Type your collections: `List<String>`, `Map<String, int>`\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've now learned all the **fundamental building blocks** of programming:\n- ‚úÖ Variables (storing data)\n- ‚úÖ Conditionals (making decisions)\n- ‚úÖ Loops (repeating actions)\n- ‚úÖ Functions (organizing code)\n- ‚úÖ Lists and Maps (managing collections)\n\nIn the next lessons, we'll do a **mini-project** to put it all together, and then we'll move into **Flutter** and start building actual user interfaces!\n\nGet ready to build something cool! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.6-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a file called `contacts.dart`: --- ## Bonus Challenge: Grade Calculator Create a program that: 1. Stores student names and grades in a Map 2. Calculates the average grade 3. Finds the highest and lowest grades 4. Prints a report ---",
              "instructions": "Create a file called `contacts.dart`: --- ## Bonus Challenge: Grade Calculator Create a program that: 1. Stores student names and grades in a Map 2. Calculates the average grade 3. Finds the highest and lowest grades 4. Prints a report ---",
              "starterCode": "void main() {\n  // TODO: Create a list of contact maps\n  List<Map<String, String>> contacts = [];\n\n  // TODO: Add 3 contacts (each should have name, phone, email)\n\n  // TODO: Print all contacts in a nice format\n\n  // TODO: Find and print a specific contact by name\n\n  // TODO: Remove one contact\n\n  // TODO: Print remaining contacts\n}",
              "solution": "=== All Contacts ===\nName: Alice\nPhone: 555-1234\nEmail: alice@email.com\n\nName: Bob\nPhone: 555-5678\nEmail: bob@email.com\n\n=== Finding Alice ===\nFound: Alice, 555-1234\n\n=== After removing Bob ===\nRemaining contacts: 1",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays contacts header",
                  "expectedOutput": "=== All Contacts ===",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Finds specific contact by name",
                  "expectedOutput": "Found: Alice, 555-1234",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Shows remaining contacts count after removal",
                  "expectedOutput": "Remaining contacts: 1",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In dart, use appropriate syntax."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.7",
          "title": "Module 1, Lesson 7: Mini-Project - Number Guessing Game",
          "moduleId": "module-01",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Putting It All Together",
              "content": "\nCongratulations on making it this far! You've learned all the Dart fundamentals:\n- ‚úÖ Variables\n- ‚úÖ Conditionals (if/else)\n- ‚úÖ Loops\n- ‚úÖ Functions\n- ‚úÖ Lists and Maps\n\nNow it's time to **combine everything** into a real project!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What We're Building",
              "content": "\nA **Number Guessing Game** that:\n- Picks a random number between 1 and 100\n- Lets the player guess the number\n- Gives hints (\"too high\" or \"too low\")\n- Tracks the number of guesses\n- Allows playing multiple rounds\n\n**Skills you'll practice**:\n- Using variables to track game state\n- Using conditionals to check guesses\n- Using loops for multiple attempts\n- Using functions to organize code\n- Using lists to track guess history\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Structure",
              "content": "\nWe'll build this in steps:\n\n1. **Version 1**: Basic game with hardcoded number\n2. **Version 2**: Add random number generation\n3. **Version 3**: Add attempt counter and guess history\n4. **Version 4**: Add multi-round support\n5. **Version 5**: Add difficulty levels\n\n"
            },
            {
              "type": "THEORY",
              "title": "Version 1: The Foundation",
              "content": "\nLet's start simple - player tries to guess a specific number.\n\nCreate a file called `guessing_game.dart`:\n\n\n**Run it!** You should see:\n\n\n**What's happening**:\n- We have a secret number (42)\n- We loop through guesses\n- For each guess, we give feedback\n- When correct, we celebrate and exit\n\n",
              "code": "=== Number Guessing Game ===\nI'm thinking of a number between 1 and 100...\n\nYou guessed: 50\nüìâ Too high! Try again.\n\nYou guessed: 30\nüìà Too low! Try again.\n\nYou guessed: 40\nüìà Too low! Try again.\n\nYou guessed: 42\nüéâ Correct! You win!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Version 2: Adding Random Numbers",
              "content": "\nInstead of always guessing 42, let's make it random!\n\n**First, import the Random library** at the top of your file:\n\n\n**Understanding `random.nextInt(100) + 1`**:\n- `random.nextInt(100)` gives 0-99\n- `+ 1` shifts it to 1-100\n\n**Try running it multiple times** - you'll get different numbers!\n\n",
              "code": "import 'dart:math';\n\nvoid main() {\n  // Generate random number between 1 and 100\n  var random = Random();\n  var secretNumber = random.nextInt(100) + 1;\n\n  print('=== Number Guessing Game ===');\n  print('I\\'m thinking of a number between 1 and 100...');\n  print('(Psst... it\\'s $secretNumber - but pretend you don\\'t know!)');\n\n  // Rest of code...\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Version 3: Tracking Attempts and History",
              "content": "\nLet's count how many guesses it takes and remember all guesses:\n\n\n**New features**:\n- `attemptCount` tracks number of tries\n- `guessHistory` remembers all guesses\n- We show a summary at the end\n\n",
              "code": "import 'dart:math';\n\nvoid main() {\n  var random = Random();\n  var secretNumber = random.nextInt(100) + 1;\n  var guesses = [50, 30, 40, 45, 42];  // Simulated guesses\n  var attemptCount = 0;\n  List<int> guessHistory = [];\n\n  print('=== Number Guessing Game ===');\n  print('I\\'m thinking of a number between 1 and 100...');\n\n  for (var guess in guesses) {\n    attemptCount++;\n    guessHistory.add(guess);\n\n    print('\\n--- Attempt $attemptCount ---');\n    print('You guessed: $guess');\n\n    if (guess == secretNumber) {\n      print('üéâ Correct! You win!');\n      print('It took you $attemptCount attempts.');\n      print('Your guesses: $guessHistory');\n      break;\n    } else if (guess > secretNumber) {\n      print('üìâ Too high! Try again.');\n    } else {\n      print('üìà Too low! Try again.');\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Version 4: Organizing with Functions",
              "content": "\nOur code is getting messy. Let's use functions to organize it:\n\n\n**Much better!** Each function has one job:\n- `generateSecretNumber()` - creates random number\n- `checkGuess()` - compares guess to secret\n- `printHeader()` - shows game title\n- `printSummary()` - shows final stats\n\n",
              "code": "import 'dart:math';\n\n// Function to generate random number\nint generateSecretNumber() {\n  var random = Random();\n  return random.nextInt(100) + 1;\n}\n\n// Function to check a guess\nString checkGuess(int guess, int secret) {\n  if (guess == secret) {\n    return 'correct';\n  } else if (guess > secret) {\n    return 'high';\n  } else {\n    return 'low';\n  }\n}\n\n// Function to print game header\nvoid printHeader() {\n  print('=== Number Guessing Game ===');\n  print('I\\'m thinking of a number between 1 and 100...\\n');\n}\n\n// Function to print game summary\nvoid printSummary(int attempts, List<int> history) {\n  print('\\nüéâ You win!');\n  print('It took you $attempts attempts.');\n  print('Your guesses: $history');\n}\n\nvoid main() {\n  var secretNumber = generateSecretNumber();\n  var guesses = [50, 30, 70, 60, 55, 52, 51];  // Simulated\n  var attemptCount = 0;\n  List<int> guessHistory = [];\n\n  printHeader();\n\n  for (var guess in guesses) {\n    attemptCount++;\n    guessHistory.add(guess);\n\n    print('Attempt $attemptCount: You guessed $guess');\n\n    var result = checkGuess(guess, secretNumber);\n\n    if (result == 'correct') {\n      printSummary(attemptCount, guessHistory);\n      break;\n    } else if (result == 'high') {\n      print('üìâ Too high! Try again.\\n');\n    } else {\n      print('üìà Too low! Try again.\\n');\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Version 5: Adding Difficulty Levels",
              "content": "\nLet's add difficulty levels with different ranges:\n\n\n",
              "code": "import 'dart:math';\n\nint generateSecretNumber(String difficulty) {\n  var random = Random();\n\n  if (difficulty == 'easy') {\n    return random.nextInt(50) + 1;  // 1-50\n  } else if (difficulty == 'medium') {\n    return random.nextInt(100) + 1;  // 1-100\n  } else {  // hard\n    return random.nextInt(500) + 1;  // 1-500\n  }\n}\n\nvoid printHeader(String difficulty) {\n  print('=== Number Guessing Game ===');\n  print('Difficulty: ${difficulty.toUpperCase()}');\n\n  if (difficulty == 'easy') {\n    print('I\\'m thinking of a number between 1 and 50...\\n');\n  } else if (difficulty == 'medium') {\n    print('I\\'m thinking of a number between 1 and 100...\\n');\n  } else {\n    print('I\\'m thinking of a number between 1 and 500...\\n');\n  }\n}\n\nvoid main() {\n  var difficulty = 'easy';  // Try: 'easy', 'medium', 'hard'\n  var secretNumber = generateSecretNumber(difficulty);\n\n  printHeader(difficulty);\n\n  // Rest of game logic...\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Full Game with All Features",
              "content": "\nHere's the complete, polished version:\n\n\n",
              "code": "import 'dart:math';\n\n// ========== GAME CONFIGURATION ==========\n\nclass GameConfig {\n  static const Map<String, int> ranges = {\n    'easy': 50,\n    'medium': 100,\n    'hard': 500,\n  };\n\n  static const Map<String, int> maxAttempts = {\n    'easy': 10,\n    'medium': 7,\n    'hard': 12,\n  };\n}\n\n// ========== GAME FUNCTIONS ==========\n\nint generateSecretNumber(String difficulty) {\n  var random = Random();\n  var range = GameConfig.ranges[difficulty] ?? 100;\n  return random.nextInt(range) + 1;\n}\n\nvoid printHeader(String difficulty) {\n  print('\\n' + '=' * 40);\n  print('   NUMBER GUESSING GAME');\n  print('=' * 40);\n  print('Difficulty: ${difficulty.toUpperCase()}');\n  var range = GameConfig.ranges[difficulty] ?? 100;\n  print('Guess a number between 1 and $range');\n  var maxAttempts = GameConfig.maxAttempts[difficulty] ?? 7;\n  print('You have $maxAttempts attempts. Good luck!\\n');\n}\n\nString checkGuess(int guess, int secret) {\n  if (guess == secret) return 'correct';\n  if (guess > secret) return 'high';\n  return 'low';\n}\n\nvoid printAttempt(int attemptNum, int guess, String result) {\n  print('--- Attempt $attemptNum ---');\n  print('You guessed: $guess');\n\n  if (result == 'correct') {\n    print('üéâ CORRECT! You found it!');\n  } else if (result == 'high') {\n    var diff = guess - (guess * 0.1).toInt();  // Give a hint\n    print('üìâ Too high! Try something lower...');\n  } else {\n    print('üìà Too low! Try something higher...');\n  }\n  print('');\n}\n\nvoid printWinSummary(int attempts, List<int> history, String difficulty) {\n  print('=' * 40);\n  print('   üéä VICTORY! üéä');\n  print('=' * 40);\n  print('Difficulty: ${difficulty.toUpperCase()}');\n  print('Attempts used: $attempts');\n  print('Your guessing strategy: $history');\n\n  if (attempts <= 3) {\n    print('Rating: ‚≠ê‚≠ê‚≠ê Amazing! Lucky or skilled?');\n  } else if (attempts <= 5) {\n    print('Rating: ‚≠ê‚≠ê Great job!');\n  } else {\n    print('Rating: ‚≠ê You made it!');\n  }\n  print('=' * 40 + '\\n');\n}\n\nvoid printLossSummary(int secret, List<int> history) {\n  print('=' * 40);\n  print('   üò¢ GAME OVER');\n  print('=' * 40);\n  print('The number was: $secret');\n  print('Your guesses: $history');\n  print('Better luck next time!');\n  print('=' * 40 + '\\n');\n}\n\n// ========== MAIN GAME LOGIC ==========\n\nvoid playGame(String difficulty) {\n  var secretNumber = generateSecretNumber(difficulty);\n  var maxAttempts = GameConfig.maxAttempts[difficulty] ?? 7;\n  var attemptCount = 0;\n  List<int> guessHistory = [];\n\n  printHeader(difficulty);\n\n  // Simulate guesses (in real game, this would be user input)\n  var simulatedGuesses = [50, 25, 37, 31, 28, 29, 30];\n\n  for (var guess in simulatedGuesses) {\n    if (attemptCount >= maxAttempts) {\n      printLossSummary(secretNumber, guessHistory);\n      return;\n    }\n\n    attemptCount++;\n    guessHistory.add(guess);\n\n    var result = checkGuess(guess, secretNumber);\n    printAttempt(attemptCount, guess, result);\n\n    if (result == 'correct') {\n      printWinSummary(attemptCount, guessHistory, difficulty);\n      return;\n    }\n  }\n\n  // If loop ends without finding number\n  printLossSummary(secretNumber, guessHistory);\n}\n\nvoid main() {\n  print('\\nüéÆ Welcome to the Number Guessing Game! üéÆ\\n');\n\n  // Play different difficulties\n  playGame('easy');\n  playGame('medium');\n  playGame('hard');\n\n  print('Thanks for playing! üëã');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What You've Accomplished",
              "content": "\nLook at what you just built:\n- ‚úÖ A complete, working game\n- ‚úÖ Multiple functions for organization\n- ‚úÖ Variables tracking state\n- ‚úÖ Conditionals for game logic\n- ‚úÖ Loops for gameplay\n- ‚úÖ Lists storing history\n- ‚úÖ Maps for configuration\n\n**You're not a beginner anymore!** You can write real programs!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap this module:\n- ‚úÖ How to structure a complete program\n- ‚úÖ Breaking problems into functions\n- ‚úÖ Combining all Dart fundamentals\n- ‚úÖ Simulating game logic\n- ‚úÖ Organizing code for readability\n- ‚úÖ Using constants and configuration\n- ‚úÖ Providing good user feedback\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\n**Module 1 Complete!** üéâ\n\nYou now have a solid foundation in Dart programming. You can:\n- Store and manipulate data\n- Make decisions\n- Create loops\n- Write functions\n- Manage collections\n- Build complete programs\n\nIn **Module 2**, we'll take these skills and start building **actual Flutter apps** with visual interfaces!\n\nYou'll learn:\n- How Flutter apps are structured\n- What widgets are and how to use them\n- How to display text, images, and buttons\n- How to arrange elements on screen\n\nGet ready to see your code come to life on screen! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.7-challenge-0",
              "title": "Practice Challenge",
              "description": "After each guess, show the narrowed range: ---",
              "instructions": "After each guess, show the narrowed range: ---",
              "starterCode": "You guessed: 50\nToo high! The number is between 1 and 49",
              "solution": "You guessed: 50\nToo high! The number is between 1 and 49",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Game shows narrowed range after high guess",
                  "expectedOutput": "Too high! The number is between 1 and 49",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Game displays guess value",
                  "expectedOutput": "You guessed: 50",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Game narrows range after low guess",
                  "expectedOutput": "Too low! The number is between 26 and 100",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.8",
          "title": "Module 1, Lesson 8: Dart 3 Modern Features",
          "moduleId": "module-01",
          "order": 8,
          "estimatedMinutes": 75,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Welcome to Modern Dart!",
              "content": "\nDart 3 (released in 2023) introduced powerful new features that make your code cleaner, safer, and more expressive. In this lesson, you'll learn three game-changing features:\n\n- **Records**: Group multiple values together without creating a class\n- **Pattern Matching**: Destructure data and match complex conditions elegantly\n- **Sealed Classes**: Create type-safe hierarchies with exhaustive switching\n\nThese features work together to make Dart feel more modern and reduce boilerplate code.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Records - Lightweight Data Grouping",
              "content": "\n### What Are Records?\n\n**Conceptual First:**\nImagine you want to return two values from a function - like a person's name AND their age. Before Dart 3, you had to either:\n- Create a whole class just for two values (overkill!)\n- Use a List or Map (loses type safety)\n- Return multiple values awkwardly\n\n**Records** solve this elegantly! They're like lightweight, immutable containers for multiple values.\n\n**Jargon:**\n- **Record**: A fixed-size, immutable collection of values\n- **Positional fields**: Fields accessed by position ($1, $2, etc.)\n- **Named fields**: Fields accessed by name\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Anonymous Records (Positional Fields)",
              "content": "Anonymous records group multiple values in parentheses. Access fields using $1, $2, etc. (1-indexed). Records are immutable - once created, values cannot be changed.",
              "code": "void main() {\n  // Create a record with two values\n  (String, int) person = ('Alice', 30);\n  \n  // Access by position (1-indexed with $ prefix)\n  print('Name: ${person.$1}');  // Alice\n  print('Age: ${person.$2}');   // 30\n  \n  // Records with more values\n  (String, String, int, bool) employee = ('Bob', 'Engineering', 5, true);\n  print('${employee.$1} works in ${employee.$2}');\n  print('Years: ${employee.$3}, Active: ${employee.$4}');\n  \n  // Records are immutable - this won't compile:\n  // person.$1 = 'Charlie';  // Error!\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Named Records (Named Fields)",
              "content": "Named records use field names instead of positions for clarity. Access fields by name (person.name) rather than index. You can mix positional and named fields in the same record.",
              "code": "void main() {\n  // Named fields for clarity\n  ({String name, int age}) person = (name: 'Alice', age: 30);\n  \n  // Access by name - much more readable!\n  print('Name: ${person.name}');\n  print('Age: ${person.age}');\n  \n  // Mix positional and named fields\n  (String, {int age, String city}) profile = (\n    'Charlie',\n    age: 25,\n    city: 'New York',\n  );\n  \n  print('${profile.$1} is ${profile.age} years old');\n  print('Lives in ${profile.city}');\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Records as Function Return Types",
              "content": "Records elegantly solve the multiple-return-value problem. Declare the record type as the return type, then return values in parentheses. Named fields make the API self-documenting.",
              "code": "// Return multiple values elegantly!\n(String, int) getUserInfo() {\n  // Imagine fetching from database\n  return ('Alice', 30);\n}\n\n// Named fields version - even clearer\n({String name, int age, String email}) fetchUser() {\n  return (\n    name: 'Bob',\n    age: 25,\n    email: 'bob@example.com',\n  );\n}\n\n// Return success/error with data\n(bool success, String? data, String? error) fetchData() {\n  try {\n    // Simulate API call\n    return (true, 'Data loaded!', null);\n  } catch (e) {\n    return (false, null, e.toString());\n  }\n}\n\nvoid main() {\n  // Using positional record\n  var info = getUserInfo();\n  print('${info.$1} is ${info.$2} years old');\n  \n  // Using named record\n  var user = fetchUser();\n  print('${user.name}: ${user.email}');\n  \n  // Handling result record\n  var result = fetchData();\n  if (result.$1) {\n    print('Success: ${result.$2}');\n  } else {\n    print('Error: ${result.$3}');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Pattern Matching - Destructuring Made Easy",
              "content": "\n### What Is Pattern Matching?\n\n**Conceptual First:**\nImagine opening a gift box. Instead of saying \"get the box, then look inside, then check what's there,\" you just say \"if it's a book, read it; if it's a toy, play with it.\"\n\n**Pattern matching** lets you inspect data structure and extract values in one elegant step. It's like X-ray vision for your data!\n\n**Jargon:**\n- **Destructuring**: Breaking apart a data structure into its components\n- **Pattern**: A template that data is matched against\n- **Guard clause**: An additional condition with `when`\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Destructuring Records",
              "content": "Destructuring extracts record values into individual variables in one step. Use var (a, b) for positional records, or var (:name, :age) shorthand for named records. The underscore (_) ignores unwanted values.",
              "code": "void main() {\n  // Create a record\n  var person = ('Alice', 30);\n  \n  // Destructure into variables - no more $1, $2!\n  var (name, age) = person;\n  print('Name: $name, Age: $age');\n  \n  // Named record destructuring\n  var user = (name: 'Bob', age: 25, city: 'NYC');\n  var (:name, :age, :city) = user;  // Shorthand!\n  print('$name ($age) from $city');\n  \n  // Swap values elegantly\n  var a = 1;\n  var b = 2;\n  (a, b) = (b, a);  // Swap!\n  print('a: $a, b: $b');  // a: 2, b: 1\n  \n  // Ignore values with _\n  var data = ('important', 'skip this', 42);\n  var (important, _, number) = data;\n  print('$important: $number');\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Destructuring Lists and Maps",
              "content": "Pattern matching works on lists and maps too. Use [...rest] to capture remaining elements, [...] to skip middle elements, and {'key': variable} for maps. Patterns can be nested for complex structures.",
              "code": "void main() {\n  // List destructuring\n  var numbers = [1, 2, 3, 4, 5];\n  var [first, second, ...rest] = numbers;\n  print('First: $first');       // 1\n  print('Second: $second');     // 2\n  print('Rest: $rest');         // [3, 4, 5]\n  \n  // Get first and last\n  var [head, ..., tail] = numbers;\n  print('Head: $head, Tail: $tail');  // 1, 5\n  \n  // Map destructuring\n  var person = {'name': 'Alice', 'age': 30};\n  var {'name': userName, 'age': userAge} = person;\n  print('$userName is $userAge');\n  \n  // Nested destructuring\n  var nested = [1, [2, 3], 4];\n  var [a, [b, c], d] = nested;\n  print('$a, $b, $c, $d');  // 1, 2, 3, 4\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Switch with Patterns",
              "content": "Dart 3 switch expressions combine type checking, value extraction, and conditional logic. Use 'when' for guard clauses. Patterns match types, extract values, and bind them to variables in one concise expression.",
              "code": "String describeValue(Object value) {\n  return switch (value) {\n    // Match specific values\n    0 => 'zero',\n    1 => 'one',\n    \n    // Match types with binding\n    int n when n < 0 => 'negative integer: $n',\n    int n when n > 100 => 'large integer: $n',\n    int n => 'integer: $n',\n    \n    // Match strings\n    String s when s.isEmpty => 'empty string',\n    String s when s.length > 10 => 'long string',\n    String s => 'string: $s',\n    \n    // Match lists\n    [] => 'empty list',\n    [var single] => 'single element: $single',\n    [var first, ...var rest] => 'list starting with $first',\n    \n    // Match records\n    (int x, int y) => 'point at ($x, $y)',\n    \n    // Catch-all\n    _ => 'something else: $value',\n  };\n}\n\nvoid main() {\n  print(describeValue(0));           // zero\n  print(describeValue(-5));          // negative integer: -5\n  print(describeValue(150));         // large integer: 150\n  print(describeValue('hello'));     // string: hello\n  print(describeValue([]));          // empty list\n  print(describeValue([1, 2, 3]));   // list starting with 1\n  print(describeValue((10, 20)));    // point at (10, 20)\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "If-Case Pattern Matching",
              "content": "If-case statements combine pattern matching with conditional execution. The pattern must match AND the optional 'when' guard must be true for the block to execute. Great for handling specific data shapes.",
              "code": "void processData(Object data) {\n  // If-case for conditional pattern matching\n  if (data case int n when n > 0) {\n    print('Positive integer: $n');\n  }\n  \n  if (data case String s when s.startsWith('Hello')) {\n    print('Greeting: $s');\n  }\n  \n  // Match and extract from records\n  if (data case (String name, int age) when age >= 18) {\n    print('$name is an adult');\n  }\n  \n  // Match list patterns\n  if (data case [var first, _, var last]) {\n    print('Three elements: first=$first, last=$last');\n  }\n}\n\nvoid main() {\n  processData(42);                    // Positive integer: 42\n  processData('Hello, World!');       // Greeting: Hello, World!\n  processData(('Alice', 25));         // Alice is an adult\n  processData([1, 2, 3]);             // Three elements: first=1, last=3\n  processData(-5);                    // (no output - doesn't match)\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 3: Sealed Classes - Exhaustive Type Hierarchies",
              "content": "\n### What Are Sealed Classes?\n\n**Conceptual First:**\nImagine a traffic light. It can ONLY be red, yellow, or green - nothing else. If you handle all three cases, you've covered everything possible.\n\n**Sealed classes** let you define a closed set of types. The compiler then ensures you handle ALL cases - no more forgotten edge cases!\n\n**Jargon:**\n- **Sealed class**: A class that can only be extended within the same file\n- **Exhaustive switch**: A switch that handles all possible subtypes\n- **Algebraic data types (ADTs)**: Types representing one of several possible variants\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Sealed Class Basics",
              "content": "Sealed classes define a closed set of subtypes that can only be extended in the same file. The compiler knows all possible subtypes, enabling exhaustive switch statements without a default case.",
              "code": "// Define a sealed class hierarchy\nsealed class Shape {}\n\nclass Circle extends Shape {\n  final double radius;\n  Circle(this.radius);\n}\n\nclass Rectangle extends Shape {\n  final double width;\n  final double height;\n  Rectangle(this.width, this.height);\n}\n\nclass Triangle extends Shape {\n  final double base;\n  final double height;\n  Triangle(this.base, this.height);\n}\n\n// The compiler KNOWS all possible shapes!\ndouble calculateArea(Shape shape) {\n  // Exhaustive switch - compiler ensures all cases covered\n  return switch (shape) {\n    Circle(radius: var r) => 3.14159 * r * r,\n    Rectangle(width: var w, height: var h) => w * h,\n    Triangle(base: var b, height: var h) => 0.5 * b * h,\n    // No default needed - all cases covered!\n  };\n}\n\nvoid main() {\n  var shapes = [\n    Circle(5),\n    Rectangle(4, 6),\n    Triangle(3, 4),\n  ];\n  \n  for (var shape in shapes) {\n    print('Area: ${calculateArea(shape).toStringAsFixed(2)}');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Sealed Classes for State Management",
              "content": "Sealed classes are perfect for UI state management. Define all possible states (loading, success, error) as subclasses. The compiler ensures every state is handled, preventing forgotten edge cases in your UI.",
              "code": "// Perfect for representing UI states!\nsealed class AuthState {}\n\nclass AuthInitial extends AuthState {}\n\nclass AuthLoading extends AuthState {}\n\nclass AuthSuccess extends AuthState {\n  final String userName;\n  final String token;\n  AuthSuccess({required this.userName, required this.token});\n}\n\nclass AuthError extends AuthState {\n  final String message;\n  AuthError(this.message);\n}\n\n// Build UI based on state - compiler checks all cases!\nString buildUI(AuthState state) {\n  return switch (state) {\n    AuthInitial() => 'Welcome! Please log in.',\n    AuthLoading() => 'Loading... Please wait.',\n    AuthSuccess(userName: var name) => 'Welcome back, $name!',\n    AuthError(message: var msg) => 'Error: $msg',\n  };\n}\n\nvoid main() {\n  var states = [\n    AuthInitial(),\n    AuthLoading(),\n    AuthSuccess(userName: 'Alice', token: 'abc123'),\n    AuthError('Invalid password'),\n  ];\n  \n  for (var state in states) {\n    print(buildUI(state));\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Sealed Classes for API Results",
              "content": "Model API responses with sealed classes for type-safe result handling. Generic type parameters let you reuse the pattern across different data types. Exhaustive switches ensure all outcomes are handled.",
              "code": "// Model API responses safely\nsealed class ApiResult<T> {}\n\nclass ApiSuccess<T> extends ApiResult<T> {\n  final T data;\n  ApiSuccess(this.data);\n}\n\nclass ApiError<T> extends ApiResult<T> {\n  final int statusCode;\n  final String message;\n  ApiError(this.statusCode, this.message);\n}\n\nclass ApiLoading<T> extends ApiResult<T> {}\n\n// Simulate API call\nApiResult<List<String>> fetchUsers() {\n  // Simulate different outcomes\n  var random = DateTime.now().second % 3;\n  \n  return switch (random) {\n    0 => ApiSuccess(['Alice', 'Bob', 'Charlie']),\n    1 => ApiError(404, 'Users not found'),\n    _ => ApiLoading(),\n  };\n}\n\n// Handle all cases exhaustively\nvoid displayResult(ApiResult<List<String>> result) {\n  switch (result) {\n    case ApiSuccess(data: var users):\n      print('Found ${users.length} users:');\n      for (var user in users) {\n        print('  - $user');\n      }\n    case ApiError(statusCode: var code, message: var msg):\n      print('Error $code: $msg');\n    case ApiLoading():\n      print('Loading...');\n  }\n}\n\nvoid main() {\n  var result = fetchUsers();\n  displayResult(result);\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Combining All Three Features",
              "content": "Records, pattern matching, and sealed classes work beautifully together. Use sealed classes for operation types, records for results, and pattern matching for exhaustive handling with guard clauses.",
              "code": "import 'dart:math';\n\n// Sealed class for operations\nsealed class MathOperation {}\n\nclass Add extends MathOperation {\n  final num a, b;\n  Add(this.a, this.b);\n}\n\nclass Subtract extends MathOperation {\n  final num a, b;\n  Subtract(this.a, this.b);\n}\n\nclass Multiply extends MathOperation {\n  final num a, b;\n  Multiply(this.a, this.b);\n}\n\nclass Divide extends MathOperation {\n  final num a, b;\n  Divide(this.a, this.b);\n}\n\n// Record for results\ntypedef CalcResult = ({num result, String description});\n\n// Pattern matching with sealed classes\nCalcResult calculate(MathOperation op) {\n  return switch (op) {\n    Add(a: var x, b: var y) => (\n      result: x + y,\n      description: '$x + $y',\n    ),\n    Subtract(a: var x, b: var y) => (\n      result: x - y,\n      description: '$x - $y',\n    ),\n    Multiply(a: var x, b: var y) => (\n      result: x * y,\n      description: '$x * $y',\n    ),\n    Divide(a: var x, b: var y) when y != 0 => (\n      result: x / y,\n      description: '$x / $y',\n    ),\n    Divide(a: var x, b: _) => (\n      result: double.nan,\n      description: '$x / 0 (undefined)',\n    ),\n  };\n}\n\nvoid main() {\n  var operations = [\n    Add(10, 5),\n    Subtract(10, 3),\n    Multiply(4, 7),\n    Divide(20, 4),\n    Divide(10, 0),  // Edge case!\n  ];\n  \n  for (var op in operations) {\n    // Destructure the result record\n    var (:result, :description) = calculate(op);\n    print('$description = $result');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "When to Use Each Feature",
              "content": "\n### Records\n- **Use when**: Returning multiple values from functions\n- **Use when**: Grouping related data without creating a class\n- **Use when**: Creating lightweight, immutable data structures\n\n### Pattern Matching\n- **Use when**: Extracting values from complex data structures\n- **Use when**: Replacing verbose if-else chains\n- **Use when**: Type-checking and casting in one step\n\n### Sealed Classes\n- **Use when**: Modeling a fixed set of states (UI state, API results)\n- **Use when**: You want exhaustive switch checking\n- **Use when**: Creating type-safe state machines\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n### Question 1\nWhat is the correct way to access the second field of an anonymous record?\n\nA) `record[1]`\nB) `record.$2`\nC) `record.second`\nD) `record[2]`\n\n### Question 2\nWhat does the `when` keyword do in pattern matching?\n\nA) Creates a new variable\nB) Adds a guard condition to the pattern\nC) Matches any value\nD) Defines a default case\n\n### Question 3\nWhat makes sealed classes special?\n\nA) They can be extended from anywhere\nB) They enable exhaustive switch statements\nC) They are always abstract\nD) They cannot have constructors\n\n### Question 4\nHow do you destructure a named record `(name: 'Alice', age: 30)`?\n\nA) `var (name, age) = record;`\nB) `var {name, age} = record;`\nC) `var (:name, :age) = record;`\nD) `var [name, age] = record;`\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Question 1: B** - Anonymous record fields are accessed with `$1`, `$2`, etc. (1-indexed with $ prefix).\n\n**Question 2: B** - The `when` keyword adds a guard condition that must be true for the pattern to match.\n\n**Question 3: B** - Sealed classes can only be extended in the same library, enabling the compiler to ensure switch statements handle all cases.\n\n**Question 4: C** - Named record fields are destructured with `:name` syntax, which creates a variable with the same name as the field.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nIn this lesson, you learned Dart 3's modern features:\n\n**Records:**\n- Create lightweight, immutable data groupings\n- Access positional fields with `$1`, `$2`\n- Access named fields by name\n- Perfect for returning multiple values from functions\n\n**Pattern Matching:**\n- Destructure records, lists, and maps elegantly\n- Use `switch` expressions with pattern cases\n- Add guard clauses with `when`\n- Use `if-case` for conditional matching\n\n**Sealed Classes:**\n- Define closed type hierarchies\n- Enable exhaustive switch statements\n- Perfect for state management\n- Compiler catches missing cases\n\nThese features work together to make your Dart code cleaner, safer, and more expressive!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nCongratulations on completing **Module 1**! You now have a comprehensive understanding of modern Dart programming, including:\n\n- Variables and data types\n- Control flow (if/else, loops)\n- Functions\n- Collections (Lists, Maps)\n- Mini-project experience\n- **Dart 3 modern features**\n\nIn **Module 2**, you'll apply all this knowledge to build actual Flutter apps with visual user interfaces!\n\nYou're ready to create beautiful, modern Flutter applications!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.8-challenge-0",
              "title": "Records Practice",
              "description": "Create a function that returns a person's full details as a named record and destructure it.",
              "instructions": "1. Create a function `getPersonDetails()` that returns a named record with name, age, and email fields\n2. Call the function and destructure the result\n3. Print each field on a separate line",
              "starterCode": "// Dart 3 Records Practice\n// Create a function that returns a named record\n\nvoid main() {\n  // TODO: Call getPersonDetails() and destructure the result\n  // TODO: Print each field\n}",
              "solution": "// Solution: Records Practice\n\n// Function returning a named record\n({String name, int age, String email}) getPersonDetails() {\n  return (\n    name: 'Alice Johnson',\n    age: 28,\n    email: 'alice@example.com',\n  );\n}\n\nvoid main() {\n  // Call and destructure the record\n  var (:name, :age, :email) = getPersonDetails();\n  \n  // Print each field\n  print('Name: $name');\n  print('Age: $age');\n  print('Email: $email');\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Function returns a named record with correct fields",
                  "expectedOutput": "Name: Alice Johnson",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Age field is correctly destructured",
                  "expectedOutput": "Age: 28",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Email field is correctly destructured",
                  "expectedOutput": "Email: alice@example.com",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use ({Type field1, Type field2}) syntax for named record types."
                },
                {
                  "level": 2,
                  "text": "Destructure named records with var (:field1, :field2) = record;"
                },
                {
                  "level": 3,
                  "text": "Return the record as (field1: value1, field2: value2)"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using $1, $2 with named records",
                  "consequence": "Compilation error - named fields use their names",
                  "correction": "Access named fields by name: record.name, not record.$1"
                },
                {
                  "mistake": "Forgetting the colon in destructuring",
                  "consequence": "Creates new variables instead of matching fields",
                  "correction": "Use (:name, :age) not (name, age) for named records"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "1.8-challenge-1",
              "title": "Pattern Matching with Switch",
              "description": "Create a function that uses pattern matching to describe different data types.",
              "instructions": "1. Create a function `describe(Object value)` that returns a String\n2. Use switch expression with patterns to handle: integers (positive/negative/zero), strings (empty/short/long), lists (empty/single/multiple), and a default case\n3. Test with various inputs",
              "starterCode": "// Pattern Matching Practice\n\nString describe(Object value) {\n  // TODO: Use switch expression with patterns\n  return '';\n}\n\nvoid main() {\n  print(describe(42));\n  print(describe(-5));\n  print(describe('hello'));\n  print(describe([1, 2, 3]));\n}",
              "solution": "// Solution: Pattern Matching with Switch\n\nString describe(Object value) {\n  return switch (value) {\n    // Integer patterns\n    0 => 'zero',\n    int n when n < 0 => 'negative: $n',\n    int n => 'positive: $n',\n    \n    // String patterns\n    String s when s.isEmpty => 'empty string',\n    String s when s.length <= 5 => 'short string: $s',\n    String s => 'long string: $s',\n    \n    // List patterns\n    [] => 'empty list',\n    [var single] => 'single element: $single',\n    [var first, ...] => 'list starting with: $first',\n    \n    // Default\n    _ => 'unknown: $value',\n  };\n}\n\nvoid main() {\n  print(describe(42));          // positive: 42\n  print(describe(-5));          // negative: -5\n  print(describe(0));           // zero\n  print(describe('hello'));     // short string: hello\n  print(describe(''));          // empty string\n  print(describe([1, 2, 3]));   // list starting with: 1\n  print(describe([]));          // empty list\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Correctly identifies positive integers",
                  "expectedOutput": "positive: 42",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Correctly identifies negative integers",
                  "expectedOutput": "negative: -5",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Correctly handles list patterns",
                  "expectedOutput": "list starting with: 1",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'when' for guard conditions in patterns"
                },
                {
                  "level": 2,
                  "text": "Order matters - put specific cases before general ones"
                },
                {
                  "level": 3,
                  "text": "Use '...' for rest patterns in lists"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Putting general patterns before specific ones",
                  "consequence": "Specific patterns never match",
                  "correction": "Put 'int n when n < 0' before 'int n'"
                },
                {
                  "mistake": "Forgetting the => in switch expressions",
                  "consequence": "Syntax error",
                  "correction": "Use => for expression bodies in switch expressions"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "1.8-challenge-2",
              "title": "Sealed Classes for Weather States",
              "description": "Create a sealed class hierarchy for weather conditions and a function to get weather advice.",
              "instructions": "1. Create a sealed class `Weather` with subclasses: Sunny (temperature), Rainy (intensity), Snowy (inches)\n2. Create a function `getAdvice(Weather weather)` using exhaustive switch\n3. Return appropriate advice for each weather type",
              "starterCode": "// Sealed Classes Practice\n\n// TODO: Define sealed class Weather and its subclasses\n\nString getAdvice(Weather weather) {\n  // TODO: Use exhaustive switch\n  return '';\n}\n\nvoid main() {\n  var conditions = [\n    Sunny(85),\n    Rainy('heavy'),\n    Snowy(6),\n  ];\n  \n  for (var weather in conditions) {\n    print(getAdvice(weather));\n  }\n}",
              "solution": "// Solution: Sealed Classes for Weather States\n\nsealed class Weather {}\n\nclass Sunny extends Weather {\n  final int temperature;\n  Sunny(this.temperature);\n}\n\nclass Rainy extends Weather {\n  final String intensity;  // 'light', 'moderate', 'heavy'\n  Rainy(this.intensity);\n}\n\nclass Snowy extends Weather {\n  final int inches;\n  Snowy(this.inches);\n}\n\nString getAdvice(Weather weather) {\n  return switch (weather) {\n    Sunny(temperature: var temp) when temp > 90 => \n      'Very hot ($temp F)! Stay hydrated and seek shade.',\n    Sunny(temperature: var temp) when temp > 70 => \n      'Nice day ($temp F)! Perfect for outdoor activities.',\n    Sunny(temperature: var temp) => \n      'Cool but sunny ($temp F). Bring a light jacket.',\n    Rainy(intensity: 'heavy') => \n      'Heavy rain! Stay indoors or bring an umbrella.',\n    Rainy(intensity: 'light') => \n      'Light rain. A jacket should be enough.',\n    Rainy(intensity: var i) => \n      '$i rain. Consider an umbrella.',\n    Snowy(inches: var in) when in > 6 => \n      'Heavy snow ($in inches)! Roads may be dangerous.',\n    Snowy(inches: var in) => \n      'Light snow ($in inches). Drive carefully.',\n  };\n}\n\nvoid main() {\n  var conditions = [\n    Sunny(85),\n    Sunny(95),\n    Rainy('heavy'),\n    Rainy('light'),\n    Snowy(6),\n    Snowy(12),\n  ];\n  \n  for (var weather in conditions) {\n    print(getAdvice(weather));\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Sunny weather returns temperature-based advice",
                  "expectedOutput": "Nice day (85 F)! Perfect for outdoor activities.",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Heavy rain returns umbrella advice",
                  "expectedOutput": "Heavy rain! Stay indoors or bring an umbrella.",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Heavy snow returns driving warning",
                  "expectedOutput": "Heavy snow (12 inches)! Roads may be dangerous.",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'sealed class' to define the base class"
                },
                {
                  "level": 2,
                  "text": "Subclasses use 'extends' just like regular inheritance"
                },
                {
                  "level": 3,
                  "text": "Destructure properties in switch cases: Sunny(temperature: var temp)"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Adding a default case to sealed class switch",
                  "consequence": "Defeats the purpose of exhaustive checking",
                  "correction": "Handle all subclasses explicitly instead"
                },
                {
                  "mistake": "Forgetting to handle all cases",
                  "consequence": "Compiler error due to non-exhaustive switch",
                  "correction": "Add cases for all subclasses of the sealed class"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-02",
      "title": "Module 2: Flutter Development",
      "description": "Learn Flutter development - Module 2",
      "difficulty": "beginner",
      "estimatedHours": 7,
      "lessons": [
        {
          "id": "2.1",
          "title": "Module 2, Lesson 1: What Happens When You Run an App?",
          "moduleId": "module-02",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Welcome to Flutter!",
              "content": "\nCongratulations on completing Module 1! You now understand:\n- How to write basic code (instructions)\n- How to store information (variables)\n- How to make decisions (if/else)\n\nNow we're ready to start building actual Flutter apps!\n\nBut first, we need to understand: **What happens when you run a Flutter app?**\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Starting Point",
              "content": "\nRemember when we created our first app and saw all that code in `main.dart`? Let's simplify it and understand what's actually happening.\n\nEvery Flutter app starts with this:\n\n\nThat's it! This is the **entry point** of every Flutter app.\n\n",
              "code": "void main() {\n  runApp(MyApp());\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "The \"main()\" Function - Your App's Starting Point",
              "content": "\nThink of `main()` like the \"Start\" button on a video game.\n\nWhen you press \"Run\" in VS Code:\n1. Flutter looks for the `main()` function\n2. Executes whatever code is inside it\n3. Your app comes to life!\n\n**Every Dart and Flutter program must have a `main()` function.** Without it, the program doesn't know where to begin.\n\n"
            },
            {
              "type": "THEORY",
              "title": "The \"runApp()\" Function - Showing Something on Screen",
              "content": "\nNow look at what's *inside* the `main()` function:\n\n\n**Conceptual Explanation**:\n- `runApp()` is a special Flutter function that says \"Put this on the screen\"\n- `MyApp()` is what we want to show\n- Together they mean: \"Take MyApp and display it\"\n\n**The Technical Term**: `runApp()` is the function that tells Flutter to inflate your app's widget tree and attach it to the screen.\n\n(Don't worry about \"widget tree\" yet - we'll get there!)\n\n",
              "code": "runApp(MyApp());",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Minimal Flutter App",
              "content": "\nLet's create the simplest possible Flutter app. Create a new file called `minimal_app.dart`:\n\n\nLet's run this! You should see a screen with \"Hello, Flutter!\" in the middle.\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    MaterialApp(\n      home: Center(\n        child: Text('Hello, Flutter!'),\n      ),\n    ),\n  );\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Breaking It Down",
              "content": "\nLet's understand each piece:\n\n### 1. The Import Statement\n\n\n**Conceptual**: Think of this like adding tools to your toolbox. The `material.dart` package contains all the visual components (buttons, text, etc.) that Flutter provides.\n\n**Technical**: This imports Flutter's Material Design widgets, which give us access to ready-made UI components.\n\n### 2. The Main Function\n\n\nWe know this one! It's the starting point.\n\n### 3. MaterialApp\n\n\n**Conceptual**: `MaterialApp` is like the foundation of a house. It provides the basic structure that all Flutter apps need.\n\n**Technical**: `MaterialApp` is a widget that wraps your entire app and provides Material Design styling, navigation, and theme support.\n\n### 4. The Home\n\n\n**Conceptual**: The `home` is the first screen the user sees - like the homepage of a website.\n\n**Technical**: `home` is a property that takes a widget. This widget becomes the default route (screen) of your app.\n\n### 5. Center\n\n\n**Conceptual**: `Center` is like putting something in the middle of a page. Whatever is inside it gets centered on the screen.\n\n**Technical**: `Center` is a layout widget that positions its child in the center of the available space.\n\n### 6. Text\n\n\n**Conceptual**: This displays text on the screen, just like `print()` displays text in the terminal!\n\n**Technical**: `Text` is a widget that displays a string of text with styling.\n\n",
              "code": "Text('Hello, Flutter!')",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introducing: Widgets",
              "content": "\nYou've now seen your first **widgets**!\n\n**Conceptual First**: Think of widgets as LEGO pieces. Each piece is a building block:\n- A `Text` widget is like a LEGO piece with letters on it\n- A `Center` widget is like a LEGO baseplate that centers other pieces\n- A `MaterialApp` widget is like the LEGO box that holds everything together\n\nYou snap these pieces together to build your app!\n\n**Now the Technical Term**: Widgets are the building blocks of Flutter apps. Everything you see on the screen is a widget - text, buttons, images, layouts, everything.\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Widget Tree (Simplified)",
              "content": "\nLook at how our widgets are nested:\n\n\nThis is called a **widget tree**. Each widget can have children (widgets inside it), creating a tree structure.\n\nThink of it like:\n- **MaterialApp** is the trunk\n- **Center** is a branch\n- **Text** is a leaf\n\n",
              "code": "MaterialApp\n  ‚îî‚îÄ Center\n      ‚îî‚îÄ Text",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Customizing Your First App",
              "content": "\nLet's make changes to see how widgets work!\n\n### Change 1: Bigger Text\n\n\nSave and see the text get bigger!\n\n### Change 2: Add Color\n\n\nThe text is now blue!\n\n### Change 3: Multiple Style Properties\n\n\nNow it's big, blue, and bold!\n\n",
              "code": "Text(\n  'Hello, Flutter!',\n  style: TextStyle(\n    fontSize: 48,\n    color: Colors.blue,\n    fontWeight: FontWeight.bold,\n  ),\n),",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Understanding the Pattern",
              "content": "\nNotice the pattern:\n\n1. Every widget has **properties** (like `home`, `child`, `style`)\n2. Properties are set using a **colon** (`:`)\n3. Some properties take other widgets (like `child`)\n4. Some properties take values (like `fontSize`)\n\nThis is how all Flutter code is structured!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Common Beginner Questions",
              "content": "\n**Q: Why do we need both `MaterialApp` and `Center`?**\nA: `MaterialApp` sets up the app foundation. `Center` positions the content. They serve different purposes!\n\n**Q: What if I forget the `import` statement?**\nA: You'll get errors like \"Undefined name 'MaterialApp'\". The import brings in the tools you need.\n\n**Q: Can I have multiple `main()` functions?**\nA: No! Each program has exactly one `main()` function as the entry point.\n\n**Q: Why all the commas?**\nA: Commas separate properties and parameters. It's how Dart knows where one thing ends and another begins.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ Every Flutter app starts with `main()`\n- ‚úÖ `runApp()` puts your app on the screen\n- ‚úÖ Widgets are LEGO-like building blocks\n- ‚úÖ Everything in Flutter is a widget\n- ‚úÖ Widgets nest inside each other (widget tree)\n- ‚úÖ We can customize widgets with properties\n- ‚úÖ `import` statements bring in the tools we need\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nRight now, we can display text. But real apps need layouts - multiple pieces of content arranged on screen.\n\nIn the next lesson, we'll learn about **layout widgets**:\n- How to stack things vertically (like a to-do list)\n- How to arrange things horizontally (like a row of buttons)\n- How to create complex arrangements\n\nGet ready to build real app screens! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.1-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a file called `my_greeting_app.dart` that: 1. Displays your name in large text 2. Centers it on the screen 3. Makes the text a color of your choice 4. Makes the text bold --- ## Bonus Challenge: Add Background Color Try adding a background color to your app: This introduces the `Container` widget - another LEGO piece that can have a background color! ---",
              "instructions": "Create a file called `my_greeting_app.dart` that: 1. Displays your name in large text 2. Centers it on the screen 3. Makes the text a color of your choice 4. Makes the text bold --- ## Bonus Challenge: Add Background Color Try adding a background color to your app: This introduces the `Container` widget - another LEGO piece that can have a background color! ---",
              "starterCode": "MaterialApp(\n  home: Container(\n    color: Colors.lightBlue,\n    child: Center(\n      child: Text(\n        'Your text here',\n        style: TextStyle(...),\n      ),\n    ),\n  ),\n)",
              "solution": "MaterialApp(\n  home: Container(\n    color: Colors.lightBlue,\n    child: Center(\n      child: Text(\n        'Your text here',\n        style: TextStyle(...),\n      ),\n    ),\n  ),\n)",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "App displays centered text with styling",
                  "expectedOutput": "Text widget is centered on screen with custom color and bold font",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Container has background color applied",
                  "expectedOutput": "Container widget has Colors.lightBlue background",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Widget tree structure is correct",
                  "expectedOutput": "MaterialApp > Container > Center > Text hierarchy established",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.2",
          "title": "Module 2, Lesson 2: Building Blocks (Widgets)",
          "moduleId": "module-02",
          "order": 2,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The LEGO Analogy",
              "content": "\nRemember playing with LEGO bricks? Each brick is a simple piece, but when you combine them, you can build amazing things - houses, cars, spaceships!\n\n**Flutter widgets work exactly the same way!**\n- Each widget is a building block\n- You snap widgets together\n- Complex UIs are made from simple widgets combined\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Exactly is a Widget?",
              "content": "\n**Conceptual First**: A widget is anything you see on screen:\n- Text? That's a widget.\n- Button? That's a widget.\n- Image? That's a widget.\n- The layout that arranges them? Also a widget!\n\n**Technical Term**: In Flutter, **everything is a widget**. Widgets are the building blocks of your app's user interface.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Two Types of Widgets",
              "content": "\n### 1. StatelessWidget - Doesn't Change\n\nThink of a street sign - it always shows the same information.\n\n\n**When to use**: Static content that doesn't change.\n\n### 2. StatefulWidget - Can Change\n\nThink of a digital clock - it updates every second.\n\n\n**When to use**: Dynamic content that changes (we'll cover this in detail later).\n\n",
              "code": "class Counter extends StatefulWidget {\n  @override\n  _CounterState createState() => _CounterState();\n}\n\nclass _CounterState extends State<Counter> {\n  int count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Count: $count');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Why 'const' Constructors Make Your App FASTER",
              "content": "\nYou'll see `const` everywhere in Flutter code. Here's WHY it matters for performance:\n\n### The Problem: Flutter Rebuilds Widgets\n\nWhen state changes, Flutter rebuilds your widget tree. Every widget gets recreated:\n\n```\nüì± User taps button\n    ‚Üì\nüîÑ setState() called\n    ‚Üì\nüèóÔ∏è build() runs again\n    ‚Üì\nüß± Every widget is recreated\n    ‚Üì\nüí° Flutter compares old vs new\n    ‚Üì\nüñºÔ∏è Only changed parts actually repaint\n```\n\n**Without const**, Flutter creates new widget objects EVERY rebuild:\n\n```dart\n// ‚ùå Creates NEW Text object every rebuild\nText('Hello')  // Object A (rebuild 1)\nText('Hello')  // Object B (rebuild 2) - DIFFERENT object!\n```\n\n**With const**, Flutter REUSES the same object:\n\n```dart\n// ‚úÖ Same object is reused across rebuilds\nconst Text('Hello')  // Object A (rebuild 1)\nconst Text('Hello')  // Object A (rebuild 2) - SAME object!\n```\n\n### Visual: Widget Tree Rebuilds\n\n```\nüî¥ = Rebuilds every time (expensive)\nüü¢ = Reused (free!)\n\nWithout const:        With const:\n                      \n   App üî¥                App üî¥\n    ‚îÇ                     ‚îÇ\n Scaffold üî¥          Scaffold üî¥\n    ‚îÇ                     ‚îÇ\n  Column üî¥            Column üî¥\n  ‚îå‚îÄ‚î¥‚îÄ‚îê               ‚îå‚îÄ‚î¥‚îÄ‚îê\nTextüî¥ Textüî¥      Textüü¢ Textüü¢\n\nResult: 6 objects    Result: 4 objects\n        recreated           (2 reused!)\n```\n\n### When Can You Use const?\n\n**‚úÖ CAN use const:**\n- Widget with all constant values\n- No variables or dynamic data\n- Lists where all items are const\n\n```dart\n// ‚úÖ All values are known at compile time\nconst Text('Hello')\nconst Icon(Icons.star)\nconst SizedBox(height: 16)\nconst EdgeInsets.all(8)\nconst [1, 2, 3]  // const list\n```\n\n**‚ùå CANNOT use const:**\n- Widget uses variables\n- Values computed at runtime\n- Dynamic data\n\n```dart\n// ‚ùå Uses variable - can't be const\nText(userName)  // userName changes\n\n// ‚ùå Calculated at runtime\nText('Count: $count')  // count changes\n\n// ‚ùå Uses method call\nText(DateTime.now().toString())  // changes every call\n```\n\n### Real Example: const Optimization\n\n```dart\nclass MyHomePage extends StatefulWidget {\n  @override\n  State<MyHomePage> createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  int counter = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        const Text('Welcome!'),       // üü¢ REUSED - never changes\n        const Icon(Icons.star),       // üü¢ REUSED - never changes\n        const SizedBox(height: 16),   // üü¢ REUSED - never changes\n        Text('Count: $counter'),      // üî¥ REBUILDS - uses variable\n        ElevatedButton(\n          onPressed: () => setState(() => counter++),\n          child: const Text('Add'),   // üü¢ REUSED - text is constant\n        ),\n      ],\n    );\n  }\n}\n```\n\n### Rule of Thumb\n\n1. **Add `const` wherever possible** - VS Code will hint when you can\n2. **Extract constant widgets** into `const` constructor classes\n3. **Use `const` constructors** in your custom widgets\n\n```dart\n// Custom widget with const constructor\nclass WelcomeCard extends StatelessWidget {\n  const WelcomeCard({super.key});  // üëà const constructor!\n\n  @override\n  Widget build(BuildContext context) {\n    return const Card(\n      child: Text('Welcome!'),\n    );\n  }\n}\n\n// Now you can use it as const:\nconst WelcomeCard()  // üü¢ Reused across rebuilds!\n```\n\n**Performance Impact**: In complex apps with frequent rebuilds, const widgets can reduce frame drops and improve smoothness significantly!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Common Built-in Widgets",
              "content": "\nFlutter provides many ready-to-use widgets:\n\n| Widget | Purpose |\n|--------|---------|\n| `Text` | Display text |\n| `Image` | Show images |\n| `Icon` | Display icons |\n| `Container` | Box for layout and styling |\n| `Row` | Arrange widgets horizontally |\n| `Column` | Arrange widgets vertically |\n| `Stack` | Overlay widgets |\n| `ListView` | Scrollable list |\n| `Button` | Clickable button |\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Widget Tree",
              "content": "\nWidgets nest inside each other, forming a tree:\n\n\n**Think of it like nesting dolls** - each widget contains other widgets.\n\n",
              "code": "MaterialApp\n ‚îî‚îÄ Scaffold\n     ‚îî‚îÄ Center\n         ‚îî‚îÄ Text",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nNow let's explore the most common widget - **Text** - and learn how to style it!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.2-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a simple app with at least 3 different widgets nested together. ---",
              "instructions": "Create a simple app with at least 3 different widgets nested together. ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Nested Widgets Demo\n// This demonstrates widget nesting with 5+ different widgets\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const NestedWidgetsApp());\n}\n\nclass NestedWidgetsApp extends StatelessWidget {\n  const NestedWidgetsApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Widget Tree Structure:\n    // MaterialApp (Widget 1)\n    //   -> Scaffold (Widget 2)\n    //        -> Center (Widget 3)\n    //             -> Card (Widget 4)\n    //                  -> Padding (Widget 5)\n    //                       -> Column (Widget 6)\n    //                            -> Icon, Text, SizedBox (Widgets 7-9)\n    \n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Nested Widgets'),\n        ),\n        body: Center(\n          child: Card(\n            elevation: 4,\n            child: Padding(\n              padding: const EdgeInsets.all(24),\n              child: Column(\n                mainAxisSize: MainAxisSize.min,\n                children: const [\n                  Icon(\n                    Icons.flutter_dash,\n                    size: 64,\n                    color: Colors.blue,\n                  ),\n                  SizedBox(height: 16),\n                  Text(\n                    'Hello Flutter!',\n                    style: TextStyle(\n                      fontSize: 24,\n                      fontWeight: FontWeight.bold,\n                    ),\n                  ),\n                  SizedBox(height: 8),\n                  Text(\n                    'Widgets nest inside each other',\n                    style: TextStyle(color: Colors.grey),\n                  ),\n                ],\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - Widgets nest inside each other like Russian dolls\n// - Each widget has a specific purpose (layout, styling, content)\n// - The 'child' property connects widgets together",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget tree contains at least 3 nested widgets",
                  "expectedOutput": "MaterialApp > Scaffold > Center > Card hierarchy present",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "App displays Flutter icon",
                  "expectedOutput": "Icon widget with Icons.flutter_dash rendered",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Text displays with correct styling",
                  "expectedOutput": "Hello Flutter! text with bold style visible",
                  "isVisible": false
                }
              ],
              "language": "dart",
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.3",
          "title": "Module 2, Lesson 3: Displaying and Styling Text",
          "moduleId": "module-02",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Your First Widget Deep Dive",
              "content": "\nYou've seen the `Text` widget briefly. Now let's master it! Text is the most common widget you'll use - every app shows text somewhere.\n\nThink of the Text widget like a word processor:\n- You can change the **font size**\n- You can change the **color**\n- You can make it **bold** or *italic*\n- You can **align** it\n\nAll of this is possible with Flutter's Text widget!\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Basic Text Widget",
              "content": "\nThe simplest form:\n\n\nThis displays plain text in the center of the screen.\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Text('Hello, Flutter!'),\n        ),\n      ),\n    ),\n  );\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introducing TextStyle",
              "content": "\nTo style text, we use the `style` property with a `TextStyle`:\n\n\n**Conceptual**: Think of `TextStyle` as the formatting toolbar in Word or Google Docs.\n\n",
              "code": "Text(\n  'Hello, Flutter!',\n  style: TextStyle(\n    fontSize: 24,\n    color: Colors.blue,\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Text Styling Options",
              "content": "\n### Font Size\n\n\n### Text Color\n\n\n**Note**: `Color(0xFF6200EA)` is a hex color. `0xFF` means fully opaque.\n\n### Font Weight (Bold)\n\n\n### Font Style (Italic)\n\n\n### Combining Multiple Styles\n\n\n",
              "code": "Text(\n  'Fancy Text!',\n  style: TextStyle(\n    fontSize: 28,\n    color: Colors.purple,\n    fontWeight: FontWeight.bold,\n    fontStyle: FontStyle.italic,\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Text Alignment",
              "content": "\nUse the `textAlign` property:\n\n\n",
              "code": "Text(\n  'Left Aligned',\n  textAlign: TextAlign.left,\n)\n\nText(\n  'Center Aligned',\n  textAlign: TextAlign.center,\n)\n\nText(\n  'Right Aligned',\n  textAlign: TextAlign.right,\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Multi-line Text",
              "content": "\n### Line Breaks with \\n\n\n\n### Multi-line Strings\n\n\n### Max Lines\n\nLimit how many lines to show:\n\n\n",
              "code": "Text(\n  'This is a very long text that might wrap to multiple lines',\n  maxLines: 2,\n  overflow: TextOverflow.ellipsis,  // Shows ... if text is cut off\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Text Decoration",
              "content": "\n### Underline\n\n\n### Strikethrough\n\n\n### Overline\n\n\n",
              "code": "Text(\n  'Overlined Text',\n  style: TextStyle(\n    decoration: TextDecoration.overline,\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Custom Fonts",
              "content": "\nWhile we won't dive deep now, you can use custom fonts:\n\n\n**Note**: You need to add font files to your project first.\n\n",
              "code": "Text(\n  'Custom Font',\n  style: TextStyle(\n    fontFamily: 'Roboto',\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Text widget displays text\n- ‚úÖ TextStyle controls appearance\n- ‚úÖ fontSize, color, fontWeight are common properties\n- ‚úÖ textAlign controls alignment\n- ‚úÖ Can combine multiple styles\n- ‚úÖ Decorations add underlines, strikethrough\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nText is great, but apps need images too! In the next lesson, we'll learn how to display images from the internet and from your app's assets.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.3-challenge-0",
              "title": "Practice Challenge",
              "description": "Create an app that displays your profile with various text styles: 1. Your name in large, bold text 2. Your age in medium, colored text 3. Your favorite quote in italic text 4. A fun fact about you in underlined text 5. Use at least 4 different colors ---",
              "instructions": "Create an app that displays your profile with various text styles: 1. Your name in large, bold text 2. Your age in medium, colored text 3. Your favorite quote in italic text 4. A fun fact about you in underlined text 5. Use at least 4 different colors ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Text Styling Profile Card\n// Demonstrates various TextStyle properties\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ProfileApp());\n}\n\nclass ProfileApp extends StatelessWidget {\n  const ProfileApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('My Profile')),\n        body: Center(\n          child: Padding(\n            padding: const EdgeInsets.all(24),\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                // 1. Name - Large, bold text (Color 1: Deep Purple)\n                const Text(\n                  'Jane Developer',\n                  style: TextStyle(\n                    fontSize: 32,\n                    fontWeight: FontWeight.bold,\n                    color: Colors.deepPurple,\n                  ),\n                ),\n                const SizedBox(height: 16),\n                \n                // 2. Age - Medium, colored text (Color 2: Teal)\n                const Text(\n                  'Age: 28',\n                  style: TextStyle(\n                    fontSize: 20,\n                    color: Colors.teal,\n                  ),\n                ),\n                const SizedBox(height: 24),\n                \n                // 3. Quote - Italic text (Color 3: Grey)\n                const Text(\n                  '\"Code is poetry written for machines\"',\n                  style: TextStyle(\n                    fontSize: 18,\n                    fontStyle: FontStyle.italic,\n                    color: Colors.grey,\n                  ),\n                  textAlign: TextAlign.center,\n                ),\n                const SizedBox(height: 24),\n                \n                // 4. Fun fact - Underlined text (Color 4: Orange)\n                const Text(\n                  'Fun fact: I love building Flutter apps!',\n                  style: TextStyle(\n                    fontSize: 16,\n                    color: Colors.orange,\n                    decoration: TextDecoration.underline,\n                    decorationColor: Colors.orange,\n                  ),\n                ),\n                const SizedBox(height: 16),\n                \n                // Bonus: Combining multiple styles\n                const Text(\n                  'Flutter Developer',\n                  style: TextStyle(\n                    fontSize: 14,\n                    color: Colors.blue,\n                    fontWeight: FontWeight.w500,\n                    letterSpacing: 2,\n                  ),\n                ),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// TextStyle properties used:\n// - fontSize: Size of text\n// - fontWeight: Bold/light/normal\n// - fontStyle: Italic/normal\n// - color: Text color\n// - decoration: Underline/strikethrough\n// - letterSpacing: Space between letters",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Profile displays name with bold styling",
                  "expectedOutput": "Text widget with fontSize: 32, fontWeight: bold, color: deepPurple",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Quote text displays with italic style",
                  "expectedOutput": "Text widget with fontStyle: italic rendered",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Fun fact displays with underline decoration",
                  "expectedOutput": "Text widget with TextDecoration.underline visible",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.4",
          "title": "Module 2, Lesson 4: Displaying Images",
          "moduleId": "module-02",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Images Matter",
              "content": "\nA picture is worth a thousand words! Images make apps come alive:\n- **Icons** for buttons and navigation\n- **Photos** for social media\n- **Logos** for branding\n- **Illustrations** for instructions\n\nFlutter makes it easy to display images from different sources.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Two Types of Images",
              "content": "\n### 1. Network Images (from the internet)\n\nLike linking to a photo on the web.\n\n### 2. Asset Images (bundled with your app)\n\nLike photos you pack in your suitcase - they're always with you.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Network Images - The Easy Way",
              "content": "\nDisplay an image from a URL:\n\n\n**That's it!** The image loads from the internet and displays.\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('Network Image')),\n        body: Center(\n          child: Image.network(\n            'https://picsum.photos/200/300',\n          ),\n        ),\n      ),\n    ),\n  );\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Controlling Image Size",
              "content": "\n### Fixed Width and Height\n\n\n### Using fit Property\n\n\n**Common fit values**:\n- `BoxFit.cover` - Fill space, may crop\n- `BoxFit.contain` - Fit entirely, may have empty space\n- `BoxFit.fill` - Stretch to fill (may distort)\n- `BoxFit.fitWidth` - Fit width, height adjusts\n- `BoxFit.fitHeight` - Fit height, width adjusts\n\n",
              "code": "Image.network(\n  'https://picsum.photos/200/300',\n  width: 300,\n  height: 200,\n  fit: BoxFit.cover,  // Fills the space, may crop\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Asset Images - Images in Your App",
              "content": "\n### Step 1: Create an assets folder\n\n\n### Step 2: Add images\n\nPut your image files (like `logo.png`) in `assets/images/`\n\n### Step 3: Register in pubspec.yaml\n\nEdit `pubspec.yaml`:\n\n\n**Important**: Indentation matters in YAML!\n\n### Step 4: Use in code\n\n\n",
              "code": "Image.asset('assets/images/logo.png')",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Circular Images",
              "content": "\nUse `CircleAvatar`:\n\n\nOr use `ClipOval`:\n\n\n",
              "code": "ClipOval(\n  child: Image.network(\n    'https://picsum.photos/200',\n    width: 100,\n    height: 100,\n    fit: BoxFit.cover,\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Loading Indicator",
              "content": "\nShow a loading spinner while image loads:\n\n\n",
              "code": "Image.network(\n  'https://picsum.photos/200/300',\n  loadingBuilder: (context, child, progress) {\n    if (progress == null) return child;\n    return CircularProgressIndicator();\n  },\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Error Handling",
              "content": "\nWhat if the image fails to load?\n\n\n",
              "code": "Image.network(\n  'https://invalid-url.com/image.jpg',\n  errorBuilder: (context, error, stackTrace) {\n    return Text('Failed to load image');\n  },\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Icons - Special Images",
              "content": "\nFlutter has tons of built-in icons:\n\n\n**Explore all icons**: https://api.flutter.dev/flutter/material/Icons-class.html\n\n",
              "code": "Icon(\n  Icons.favorite,\n  color: Colors.red,\n  size: 50,\n)\n\nIcon(Icons.star)\nIcon(Icons.home)\nIcon(Icons.settings)\nIcon(Icons.person)\nIcon(Icons.search)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ `Image.network()` loads from URLs\n- ‚úÖ `Image.asset()` loads bundled images\n- ‚úÖ `BoxFit` controls how images fill space\n- ‚úÖ `CircleAvatar` creates circular images\n- ‚úÖ `Icon` widget for built-in icons\n- ‚úÖ Loading and error handling\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou can display text and images! Next, we'll learn about **Container** - the Swiss Army knife widget for layout and decoration. It's like a box you can style however you want!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.4-challenge-0",
              "title": "Practice Challenge",
              "description": "Create an app with: 1. At least 3 network images 2. Different sizes 3. At least one circular image 4. Text labels under each image ---",
              "instructions": "Create an app with: 1. At least 3 network images 2. Different sizes 3. At least one circular image 4. Text labels under each image ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Image Gallery with Labels\n// Shows network images with different sizes and shapes\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ImageGalleryApp());\n}\n\nclass ImageGalleryApp extends StatelessWidget {\n  const ImageGalleryApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Image Gallery')),\n        body: SingleChildScrollView(\n          padding: const EdgeInsets.all(16),\n          child: Column(\n            children: [\n              // Image 1: Large rectangular image\n              _buildImageCard(\n                imageUrl: 'https://picsum.photos/400/200',\n                label: 'Landscape Photo',\n                width: double.infinity,\n                height: 200,\n              ),\n              const SizedBox(height: 16),\n              \n              // Row with two smaller images\n              Row(\n                children: [\n                  // Image 2: Medium square image\n                  Expanded(\n                    child: _buildImageCard(\n                      imageUrl: 'https://picsum.photos/200/200',\n                      label: 'Square Photo',\n                      height: 150,\n                    ),\n                  ),\n                  const SizedBox(width: 16),\n                  \n                  // Image 3: Circular profile image\n                  Column(\n                    children: [\n                      const CircleAvatar(\n                        radius: 60,\n                        backgroundImage: NetworkImage(\n                          'https://picsum.photos/150/150',\n                        ),\n                      ),\n                      const SizedBox(height: 8),\n                      const Text(\n                        'Profile Photo',\n                        style: TextStyle(fontWeight: FontWeight.w500),\n                      ),\n                    ],\n                  ),\n                ],\n              ),\n              const SizedBox(height: 16),\n              \n              // Image 4: Small thumbnail\n              _buildImageCard(\n                imageUrl: 'https://picsum.photos/300/150',\n                label: 'Thumbnail',\n                width: 200,\n                height: 100,\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _buildImageCard({\n    required String imageUrl,\n    required String label,\n    double? width,\n    double? height,\n  }) {\n    return Column(\n      children: [\n        ClipRRect(\n          borderRadius: BorderRadius.circular(8),\n          child: Image.network(\n            imageUrl,\n            width: width,\n            height: height,\n            fit: BoxFit.cover,\n            loadingBuilder: (context, child, loadingProgress) {\n              if (loadingProgress == null) return child;\n              return SizedBox(\n                width: width,\n                height: height,\n                child: const Center(child: CircularProgressIndicator()),\n              );\n            },\n            errorBuilder: (context, error, stackTrace) {\n              return SizedBox(\n                width: width,\n                height: height,\n                child: const Center(child: Icon(Icons.error)),\n              );\n            },\n          ),\n        ),\n        const SizedBox(height: 8),\n        Text(label, style: const TextStyle(fontWeight: FontWeight.w500)),\n      ],\n    );\n  }\n}\n\n// Key concepts:\n// - Image.network() loads images from URLs\n// - CircleAvatar for circular profile images\n// - ClipRRect for rounded corners\n// - loadingBuilder shows progress\n// - errorBuilder handles failed loads",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Gallery displays network images",
                  "expectedOutput": "Image.network widgets loading from picsum.photos URLs",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Circular profile image displays correctly",
                  "expectedOutput": "CircleAvatar with radius 60 and NetworkImage",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Text labels appear below images",
                  "expectedOutput": "Landscape Photo, Square Photo, Profile Photo labels visible",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.5",
          "title": "Module 2, Lesson 5: The Container Widget",
          "moduleId": "module-02",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Swiss Army Knife of Widgets",
              "content": "\nIf widgets were tools, `Container` would be a Swiss Army knife - it does MANY things:\n- Acts as a **box** to hold other widgets\n- Adds **padding** (breathing room inside)\n- Adds **margin** (spacing outside)\n- Sets **background color**\n- Adds **borders**\n- Makes **rounded corners**\n- Sets **width and height**\n\n**Container is the most versatile widget you'll use!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Empty Container",
              "content": "\nThe simplest container:\n\n\nYou can't see it because it's invisible and empty! Let's give it color:\n\n\nNow you have a blue square!\n\n",
              "code": "Container(\n  color: Colors.blue,\n  width: 100,\n  height: 100,\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Container with a Child",
              "content": "\nContainers can hold other widgets:\n\n\n",
              "code": "Container(\n  color: Colors.blue,\n  padding: EdgeInsets.all(20),\n  child: Text(\n    'Hello!',\n    style: TextStyle(color: Colors.white),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Padding - Space Inside",
              "content": "\n**Conceptual**: Padding is like bubble wrap inside a box.\n\n\n",
              "code": "// Padding on all sides\nContainer(\n  color: Colors.blue,\n  padding: EdgeInsets.all(20),\n  child: Text('Padded'),\n)\n\n// Different padding per side\nContainer(\n  padding: EdgeInsets.only(\n    left: 10,\n    right: 10,\n    top: 20,\n    bottom: 20,\n  ),\n  child: Text('Custom Padding'),\n)\n\n// Symmetric padding\nContainer(\n  padding: EdgeInsets.symmetric(\n    horizontal: 20,  // left and right\n    vertical: 10,    // top and bottom\n  ),\n  child: Text('Symmetric'),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Margin - Space Outside",
              "content": "\n**Conceptual**: Margin is like the space between boxes on a shelf.\n\n\n**Margin vs Padding**:\n- **Padding**: Space between container edge and its child (inside)\n- **Margin**: Space between container and other widgets (outside)\n\n",
              "code": "Container(\n  margin: EdgeInsets.all(20),\n  color: Colors.red,\n  child: Text('Has margin'),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Width and Height",
              "content": "\n\n**Special sizes**:\n\n",
              "code": "// Take up all available width\nContainer(\n  width: double.infinity,\n  height: 100,\n  color: Colors.orange,\n)\n\n// Take up all available height\nContainer(\n  width: 100,\n  height: double.infinity,\n  color: Colors.purple,\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "BoxDecoration - Advanced Styling",
              "content": "\nFor more complex styling, use `decoration`:\n\n\n**Note**: When using `decoration`, put `color` inside `BoxDecoration`, not directly on Container!\n\n",
              "code": "Container(\n  width: 200,\n  height: 100,\n  decoration: BoxDecoration(\n    color: Colors.blue,\n    borderRadius: BorderRadius.circular(20),  // Rounded corners\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Rounded Corners",
              "content": "\n\n**Different corner radii**:\n\n",
              "code": "decoration: BoxDecoration(\n  color: Colors.blue,\n  borderRadius: BorderRadius.only(\n    topLeft: Radius.circular(20),\n    topRight: Radius.circular(20),\n    bottomLeft: Radius.circular(0),\n    bottomRight: Radius.circular(0),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Card Example",
              "content": "\nLet's combine everything to create a nice card:\n\n\n",
              "code": "Container(\n  margin: EdgeInsets.all(20),\n  padding: EdgeInsets.all(20),\n  decoration: BoxDecoration(\n    color: Colors.white,\n    borderRadius: BorderRadius.circular(15),\n    boxShadow: [\n      BoxShadow(\n        color: Colors.grey.withOpacity(0.5),\n        blurRadius: 10,\n        offset: Offset(0, 3),\n      ),\n    ],\n  ),\n  child: Column(\n    mainAxisSize: MainAxisSize.min,\n    children: [\n      Text(\n        'Card Title',\n        style: TextStyle(\n          fontSize: 20,\n          fontWeight: FontWeight.bold,\n        ),\n      ),\n      SizedBox(height: 10),\n      Text(\n        'This is a nice card with shadow and rounded corners!',\n        textAlign: TextAlign.center,\n      ),\n    ],\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Alignment Inside Container",
              "content": "\n\n**Alignment options**:\n- `Alignment.topLeft`\n- `Alignment.topCenter`\n- `Alignment.topRight`\n- `Alignment.centerLeft`\n- `Alignment.center`\n- `Alignment.centerRight`\n- `Alignment.bottomLeft`\n- `Alignment.bottomCenter`\n- `Alignment.bottomRight`\n\n",
              "code": "Container(\n  width: 200,\n  height: 200,\n  color: Colors.blue,\n  alignment: Alignment.center,  // Center the child\n  child: Text('Centered'),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Container is the Swiss Army knife widget\n- ‚úÖ `padding` adds space inside\n- ‚úÖ `margin` adds space outside\n- ‚úÖ `width` and `height` control size\n- ‚úÖ `BoxDecoration` for advanced styling\n- ‚úÖ Borders, shadows, gradients, rounded corners\n- ‚úÖ `alignment` positions child inside\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've learned individual widgets (Text, Image, Container). Now it's time to learn how to **arrange multiple widgets** on screen! In the next lesson, we'll explore **Column and Row** - the building blocks of layouts.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.5-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a business card using Container with: 1. Rounded corners 2. A nice color or gradient 3. Shadow 4. Padding 5. Your name and title ---",
              "instructions": "Create a business card using Container with: 1. Rounded corners 2. A nice color or gradient 3. Shadow 4. Padding 5. Your name and title ---",
              "starterCode": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                          ‚îÇ\n‚îÇ      Your Name           ‚îÇ\n‚îÇ      Your Title          ‚îÇ\n‚îÇ      your@email.com      ‚îÇ\n‚îÇ                          ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
              "solution": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                          ‚îÇ\n‚îÇ      Your Name           ‚îÇ\n‚îÇ      Your Title          ‚îÇ\n‚îÇ      your@email.com      ‚îÇ\n‚îÇ                          ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Business card has rounded corners",
                  "expectedOutput": "Container with BoxDecoration and BorderRadius.circular",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Card has shadow effect",
                  "expectedOutput": "BoxShadow with blur and offset applied",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Card displays name, title, and email",
                  "expectedOutput": "Text widgets for name, title, and email visible",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.6",
          "title": "Module 2, Lesson 6: Arranging Widgets (Column & Row)",
          "moduleId": "module-02",
          "order": 6,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Layout Problem",
              "content": "\nYou know how to create individual widgets (Text, Image, Container). But real apps have MANY widgets on screen:\n- A profile screen: photo + name + bio + buttons\n- A login screen: logo + text fields + button\n- A feed: many posts stacked vertically\n\n**How do we arrange multiple widgets?** Enter `Column` and `Row`!\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Stack of Pancakes (Column)",
              "content": "\n**Conceptual First**: Imagine stacking pancakes on a plate. Each pancake sits on top of the previous one.\n\n**Column does the same** - it stacks widgets vertically (top to bottom).\n\n\nOutput:\n\n",
              "code": "First widget\nSecond widget\nThird widget",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Main Axis Alignment (Vertical)",
              "content": "\nControl how children are spaced vertically:\n\n\n**Options**:\n- `MainAxisAlignment.start` - At the top\n- `MainAxisAlignment.center` - Centered vertically\n- `MainAxisAlignment.end` - At the bottom\n- `MainAxisAlignment.spaceBetween` - Space between items\n- `MainAxisAlignment.spaceAround` - Space around items\n- `MainAxisAlignment.spaceEvenly` - Equal spacing\n\n",
              "code": "Column(\n  mainAxisAlignment: MainAxisAlignment.start,  // Default: top\n  children: [\n    Text('Item 1'),\n    Text('Item 2'),\n    Text('Item 3'),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Cross Axis Alignment (Horizontal)",
              "content": "\nControl how children are aligned horizontally:\n\n\n**Options**:\n- `CrossAxisAlignment.start` - Left edge\n- `CrossAxisAlignment.center` - Centered (default)\n- `CrossAxisAlignment.end` - Right edge\n- `CrossAxisAlignment.stretch` - Fill width\n\n",
              "code": "Column(\n  crossAxisAlignment: CrossAxisAlignment.start,  // Left-aligned\n  children: [\n    Text('Short'),\n    Text('Medium text'),\n    Text('Very long text here'),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Books on a Shelf (Row)",
              "content": "\n**Conceptual First**: Imagine books lined up on a shelf, side by side.\n\n**Row does the same** - it arranges widgets horizontally (left to right).\n\n\nOutput:\n\n",
              "code": "First  Second  Third",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Combining Column and Row",
              "content": "\nThis is where it gets powerful!\n\n\n",
              "code": "Column(\n  children: [\n    Text('Header'),\n    Row(\n      mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n      children: [\n        Icon(Icons.favorite),\n        Icon(Icons.star),\n        Icon(Icons.share),\n      ],\n    ),\n    Text('Footer'),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Spacing Between Children",
              "content": "\n### Using SizedBox\n\n\nFor Row:\n\n",
              "code": "Row(\n  children: [\n    Icon(Icons.home),\n    SizedBox(width: 30),  // 30 pixels of space\n    Icon(Icons.search),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Expanded - Taking Up Available Space",
              "content": "\nSometimes you want a child to take up all remaining space:\n\n\n",
              "code": "Row(\n  children: [\n    Icon(Icons.menu),\n    Expanded(\n      child: Text('This takes up remaining space'),\n    ),\n    Icon(Icons.search),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n### 1. Column without Constrained Height\n\n\n### 2. Row/Column Overflow\n\n\n",
              "code": "// If children are too wide/tall, wrap in SingleChildScrollView:\nSingleChildScrollView(\n  child: Column(\n    children: [\n      // Many children...\n    ],\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ `Column` arranges widgets vertically\n- ‚úÖ `Row` arranges widgets horizontally\n- ‚úÖ `mainAxisAlignment` controls spacing along main axis\n- ‚úÖ `crossAxisAlignment` controls alignment on cross axis\n- ‚úÖ `SizedBox` creates spacing\n- ‚úÖ `Expanded` takes remaining space\n- ‚úÖ Combine Row and Column for complex layouts\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou now know the fundamentals of Flutter! You can display text, images, use containers, and arrange widgets in rows and columns.\n\nIn the next lesson, we'll build a **mini-project** that combines everything you've learned to create a complete app screen!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.6-challenge-0",
              "title": "Practice Challenge",
              "description": "Build a social media post layout: 1. Top row: profile photo + name 2. Middle: post text 3. Bottom row: like button + comment button + share button Use Column for vertical arrangement, Row for horizontal. ---",
              "instructions": "Build a social media post layout: 1. Top row: profile photo + name 2. Middle: post text 3. Bottom row: like button + comment button + share button Use Column for vertical arrangement, Row for horizontal. ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Social Media Post Layout\n// Uses Column for vertical and Row for horizontal arrangement\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const SocialMediaApp());\n}\n\nclass SocialMediaApp extends StatelessWidget {\n  const SocialMediaApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Social Feed')),\n        body: const SocialMediaPost(),\n      ),\n    );\n  }\n}\n\nclass SocialMediaPost extends StatelessWidget {\n  const SocialMediaPost({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      margin: const EdgeInsets.all(16),\n      child: Padding(\n        padding: const EdgeInsets.all(16),\n        // Main Column: arranges sections vertically\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            // 1. Top Row: Profile photo + name\n            Row(\n              children: [\n                const CircleAvatar(\n                  radius: 24,\n                  backgroundImage: NetworkImage(\n                    'https://picsum.photos/100/100',\n                  ),\n                ),\n                const SizedBox(width: 12),\n                Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: const [\n                    Text(\n                      'Jane Developer',\n                      style: TextStyle(\n                        fontWeight: FontWeight.bold,\n                        fontSize: 16,\n                      ),\n                    ),\n                    Text(\n                      '2 hours ago',\n                      style: TextStyle(color: Colors.grey, fontSize: 12),\n                    ),\n                  ],\n                ),\n              ],\n            ),\n            const SizedBox(height: 16),\n            \n            // 2. Middle: Post text\n            const Text(\n              'Just finished building my first Flutter app! The widget system is amazing - everything just clicks together like LEGO blocks.',\n              style: TextStyle(fontSize: 15),\n            ),\n            const SizedBox(height: 16),\n            \n            // 3. Bottom Row: Action buttons\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: [\n                _buildActionButton(Icons.thumb_up_outlined, 'Like', '42'),\n                _buildActionButton(Icons.comment_outlined, 'Comment', '8'),\n                _buildActionButton(Icons.share_outlined, 'Share', ''),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildActionButton(IconData icon, String label, String count) {\n    return TextButton.icon(\n      onPressed: () {},\n      icon: Icon(icon, size: 20),\n      label: Text(count.isNotEmpty ? '$label ($count)' : label),\n    );\n  }\n}\n\n// Layout structure:\n// Column (vertical)\n//   -> Row (horizontal): Avatar + Name\n//   -> Text: Post content\n//   -> Row (horizontal): Action buttons",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Top row contains profile photo and name",
                  "expectedOutput": "Row with CircleAvatar and Text for name visible",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Bottom row contains action buttons",
                  "expectedOutput": "Like, Comment, Share buttons in Row with spaceAround alignment",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Column arranges sections vertically",
                  "expectedOutput": "Main Column contains profile Row, post Text, and buttons Row",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.7",
          "title": "Module 2, Lesson 7: Mini-Project - Business Card App",
          "moduleId": "module-02",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Putting It All Together!",
              "content": "\nCongratulations on making it through Module 2! You've learned:\n- ‚úÖ How Flutter apps start (main, runApp)\n- ‚úÖ Widgets are building blocks\n- ‚úÖ Styling text\n- ‚úÖ Displaying images\n- ‚úÖ Using containers for decoration\n- ‚úÖ Arranging widgets with Column and Row\n\nNow let's combine EVERYTHING into a real project!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What We're Building",
              "content": "\nA **digital business card app** that shows:\n- Your name\n- Your title/profession\n- Your photo\n- Contact information (email, phone)\n- Social media icons\n- A professional design with colors, shadows, and spacing\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Final Result",
              "content": "\nYour app will look something like this:\n\n\n",
              "code": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                                 ‚îÇ\n‚îÇ         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ\n‚îÇ         ‚îÇ  Photo   ‚îÇ            ‚îÇ\n‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ\n‚îÇ                                 ‚îÇ\n‚îÇ         Your Name               ‚îÇ\n‚îÇ         Your Title              ‚îÇ\n‚îÇ                                 ‚îÇ\n‚îÇ    ‚úâ email@example.com          ‚îÇ\n‚îÇ    ‚òé +1 234 567 8900            ‚îÇ\n‚îÇ                                 ‚îÇ\n‚îÇ    üîó  üíº  üì∑  üê¶               ‚îÇ\n‚îÇ                                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 1: Create the Project",
              "content": "\n\nOpen `lib/main.dart` and let's start coding!\n\n",
              "code": "flutter create business_card\ncd business_card",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 2: Basic Structure",
              "content": "\nReplace everything in `main.dart`:\n\n\nRun it! You should see a teal screen with text.\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(BusinessCardApp());\n}\n\nclass BusinessCardApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Business Card',\n      home: BusinessCardScreen(),\n    );\n  }\n}\n\nclass BusinessCardScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      backgroundColor: Colors.teal,\n      body: SafeArea(\n        child: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              Text('Your card will go here'),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 3: Add the Profile Photo",
              "content": "\n\n**Tip**: Replace `Icon(Icons.person...)` with `backgroundImage: NetworkImage('YOUR_PHOTO_URL')` to use a real photo!\n\n",
              "code": "class BusinessCardScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      backgroundColor: Colors.teal,\n      body: SafeArea(\n        child: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              CircleAvatar(\n                radius: 50,\n                backgroundColor: Colors.white,\n                child: Icon(\n                  Icons.person,\n                  size: 60,\n                  color: Colors.teal,\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 6: Create Contact Info Cards",
              "content": "\nLet's create a reusable widget for contact info:\n\n\n",
              "code": "// Add this widget outside BusinessCardScreen class\nclass ContactCard extends StatelessWidget {\n  final IconData icon;\n  final String text;\n\n  ContactCard({required this.icon, required this.text});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      margin: EdgeInsets.symmetric(vertical: 10, horizontal: 25),\n      padding: EdgeInsets.all(10),\n      decoration: BoxDecoration(\n        color: Colors.white,\n        borderRadius: BorderRadius.circular(5),\n      ),\n      child: Row(\n        children: [\n          Icon(icon, color: Colors.teal),\n          SizedBox(width: 10),\n          Text(\n            text,\n            style: TextStyle(\n              color: Colors.teal[900],\n              fontSize: 16,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 7: Use Contact Cards",
              "content": "\nIn your Column, after the divider:\n\n\n",
              "code": "ContactCard(\n  icon: Icons.phone,\n  text: '+1 234 567 8900',\n),\nContactCard(\n  icon: Icons.email,\n  text: 'your.email@example.com',\n),",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap Module 2:\n- ‚úÖ Created a complete Flutter app from scratch\n- ‚úÖ Used multiple widgets together\n- ‚úÖ Created custom widgets (ContactCard)\n- ‚úÖ Applied styling (colors, fonts, spacing)\n- ‚úÖ Used Column for vertical layout\n- ‚úÖ Used Row for horizontal layout\n- ‚úÖ Added images, icons, and text\n- ‚úÖ Made a real, shareable project\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\n**Module 2 Complete!** üéâ\n\nYou can now build static Flutter apps with beautiful layouts!\n\nIn **Module 3**, we'll learn advanced layout techniques:\n- ListView for scrollable lists\n- GridView for grids\n- Stack for overlaying widgets\n- Responsive layouts\n\nGet ready to build more complex UIs! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.7-challenge-0",
              "title": "Practice Challenge",
              "description": "Test on different device sizes and adjust spacing. ---",
              "instructions": "Test on different device sizes and adjust spacing. ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Responsive Spacing Demo\n// Adjusts padding and spacing based on screen size\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ResponsiveApp());\n}\n\nclass ResponsiveApp extends StatelessWidget {\n  const ResponsiveApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Responsive Layout')),\n        body: const ResponsiveContent(),\n      ),\n    );\n  }\n}\n\nclass ResponsiveContent extends StatelessWidget {\n  const ResponsiveContent({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Get screen dimensions\n    final screenWidth = MediaQuery.of(context).size.width;\n    final screenHeight = MediaQuery.of(context).size.height;\n    \n    // Calculate responsive values\n    final isSmallScreen = screenWidth < 600;\n    final horizontalPadding = screenWidth * 0.05; // 5% of screen width\n    final verticalSpacing = isSmallScreen ? 12.0 : 24.0;\n    final fontSize = isSmallScreen ? 16.0 : 20.0;\n    \n    return SingleChildScrollView(\n      padding: EdgeInsets.symmetric(\n        horizontal: horizontalPadding,\n        vertical: 16,\n      ),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          // Display screen info\n          Card(\n            child: Padding(\n              padding: const EdgeInsets.all(16),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text(\n                    'Screen Info',\n                    style: TextStyle(\n                      fontSize: fontSize,\n                      fontWeight: FontWeight.bold,\n                    ),\n                  ),\n                  SizedBox(height: verticalSpacing),\n                  Text('Width: ${screenWidth.toStringAsFixed(0)}px'),\n                  Text('Height: ${screenHeight.toStringAsFixed(0)}px'),\n                  Text('Device: ${isSmallScreen ? \"Mobile\" : \"Tablet/Desktop\"}'),\n                ],\n              ),\n            ),\n          ),\n          SizedBox(height: verticalSpacing),\n          \n          // Responsive grid\n          Text(\n            'Responsive Cards',\n            style: TextStyle(fontSize: fontSize, fontWeight: FontWeight.bold),\n          ),\n          SizedBox(height: verticalSpacing),\n          \n          // Use Wrap for responsive grid behavior\n          Wrap(\n            spacing: verticalSpacing,\n            runSpacing: verticalSpacing,\n            children: List.generate(6, (index) {\n              return SizedBox(\n                width: isSmallScreen\n                    ? (screenWidth - horizontalPadding * 2 - verticalSpacing) / 2\n                    : (screenWidth - horizontalPadding * 2 - verticalSpacing * 2) / 3,\n                child: Card(\n                  child: Padding(\n                    padding: EdgeInsets.all(isSmallScreen ? 12 : 20),\n                    child: Column(\n                      children: [\n                        Icon(Icons.widgets, size: isSmallScreen ? 32 : 48),\n                        SizedBox(height: verticalSpacing / 2),\n                        Text('Card ${index + 1}'),\n                      ],\n                    ),\n                  ),\n                ),\n              );\n            }),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Responsive techniques:\n// - MediaQuery for screen dimensions\n// - Conditional values based on screen size\n// - Percentage-based padding\n// - Wrap widget for flexible grid",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "App uses MediaQuery for responsive sizing",
                  "expectedOutput": "MediaQuery.of(context).size used to determine screen dimensions",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Layout adapts to different screen sizes",
                  "expectedOutput": "Different padding and spacing for mobile vs tablet/desktop",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Wrap widget creates responsive grid",
                  "expectedOutput": "Cards rearrange from 2 to 3 columns based on screen width",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-03",
      "title": "Module 3: Flutter Development",
      "description": "Learn Flutter development - Module 3",
      "difficulty": "beginner",
      "estimatedHours": 5,
      "lessons": [
        {
          "id": "3.1",
          "title": "Module 3, Lesson 1: Scrollable Lists (ListView)",
          "moduleId": "module-03",
          "order": 1,
          "estimatedMinutes": 45,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Scrolling Problem",
              "content": "\nImagine a news app with 100 articles. You can't fit them all on one screen! You need **scrolling**.\n\n**Column** doesn't scroll by default. If content is too long, it overflows and you get an error.\n\n**ListView** solves this - it creates a scrollable list of widgets!\n\n"
            },
            {
              "type": "THEORY",
              "title": "When to Use ListView",
              "content": "\nUse ListView when you have:\n- A list of items (emails, messages, products)\n- Content that might be longer than the screen\n- Repeated items with similar structure\n\n**Think**: Instagram feed, WhatsApp chat list, shopping cart\n\n"
            },
            {
              "type": "THEORY",
              "title": "ListTile - The Perfect List Item",
              "content": "\n`ListTile` is a pre-built widget perfect for lists:\n\n\n",
              "code": "ListTile(\n  leading: Icon(Icons.person),  // Left side\n  title: Text('John Doe'),      // Main text\n  subtitle: Text('Software Engineer'),  // Secondary text\n  trailing: Icon(Icons.arrow_forward),  // Right side\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "ListView.builder - For Dynamic Lists",
              "content": "\nWhen you have many items (especially from data), use `ListView.builder`:\n\n\n**Why builder?** It only creates widgets for visible items - much more efficient!\n\n",
              "code": "ListView.builder(\n  itemCount: 100,  // Number of items\n  itemBuilder: (context, index) {\n    return ListTile(\n      title: Text('Item $index'),\n    );\n  },\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "ListView.separated - With Dividers",
              "content": "\nAdd dividers between items:\n\n\n",
              "code": "ListView.separated(\n  itemCount: contacts.length,\n  itemBuilder: (context, index) {\n    return ListTile(title: Text(contacts[index]));\n  },\n  separatorBuilder: (context, index) {\n    return Divider();\n  },\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Horizontal ListView",
              "content": "\nLists can scroll horizontally too:\n\n\n",
              "code": "ListView(\n  scrollDirection: Axis.horizontal,\n  children: [\n    Container(width: 160, color: Colors.red),\n    Container(width: 160, color: Colors.blue),\n    Container(width: 160, color: Colors.green),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nLists are one way to show multiple items. What about **grids** like a photo gallery? That's next!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.1-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a todo list with: 1. At least 5 todos 2. Use ListView.builder 3. Each todo has a checkbox icon 4. Bonus: Add dividers ---",
              "instructions": "Create a todo list with: 1. At least 5 todos 2. Use ListView.builder 3. Each todo has a checkbox icon 4. Bonus: Add dividers ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Todo List with ListView.builder\n// Shows a scrollable todo list with checkboxes and dividers\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const TodoApp());\n}\n\nclass TodoApp extends StatelessWidget {\n  const TodoApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('My Todo List')),\n        body: const TodoList(),\n      ),\n    );\n  }\n}\n\nclass TodoList extends StatefulWidget {\n  const TodoList({super.key});\n\n  @override\n  State<TodoList> createState() => _TodoListState();\n}\n\nclass _TodoListState extends State<TodoList> {\n  // List of todo items with completion status\n  final List<Map<String, dynamic>> todos = [\n    {'title': 'Learn Flutter basics', 'completed': true},\n    {'title': 'Build a todo app', 'completed': false},\n    {'title': 'Study ListView.builder', 'completed': true},\n    {'title': 'Practice widget nesting', 'completed': false},\n    {'title': 'Create a beautiful UI', 'completed': false},\n    {'title': 'Deploy to app store', 'completed': false},\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    // ListView.builder efficiently builds items on demand\n    return ListView.builder(\n      itemCount: todos.length,\n      itemBuilder: (context, index) {\n        final todo = todos[index];\n        return Column(\n          children: [\n            ListTile(\n              // Checkbox icon based on completion\n              leading: Icon(\n                todo['completed']\n                    ? Icons.check_box\n                    : Icons.check_box_outline_blank,\n                color: todo['completed'] ? Colors.green : Colors.grey,\n              ),\n              // Todo title with strikethrough if completed\n              title: Text(\n                todo['title'],\n                style: TextStyle(\n                  decoration: todo['completed']\n                      ? TextDecoration.lineThrough\n                      : TextDecoration.none,\n                  color: todo['completed'] ? Colors.grey : Colors.black,\n                ),\n              ),\n              // Tap to toggle completion\n              onTap: () {\n                setState(() {\n                  todos[index]['completed'] = !todo['completed'];\n                });\n              },\n            ),\n            // Divider between items (bonus)\n            if (index < todos.length - 1) const Divider(height: 1),\n          ],\n        );\n      },\n    );\n  }\n}\n\n// Key concepts:\n// - ListView.builder: Efficient for long lists\n// - itemCount: Total number of items\n// - itemBuilder: Function called for each visible item\n// - StatefulWidget: Allows updating todo completion\n// - Divider: Visual separator between items",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "ListView.builder used with itemCount",
                  "expectedOutput": "ListView.builder creates items dynamically with itemCount: 6",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Checkbox icons toggle with completion",
                  "expectedOutput": "Icons.check_box for completed, Icons.check_box_outline_blank for pending",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Dividers separate todo items",
                  "expectedOutput": "Divider widget rendered between each ListTile",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.2",
          "title": "Module 3, Lesson 2: Photo Grids (GridView)",
          "moduleId": "module-03",
          "order": 2,
          "estimatedMinutes": 30,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "When ListView Isn't Enough",
              "content": "\nLists are great for vertical scrolling, but what about a **photo gallery** or **product catalog**? You need items arranged in a **grid** - multiple columns!\n\nThink: Instagram explore page, Pinterest, app store icons.\n\n**GridView** creates scrollable grids of widgets!\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First GridView",
              "content": "\n\nCreates a 2-column grid!\n\n",
              "code": "GridView.count(\n  crossAxisCount: 2,  // 2 columns\n  children: [\n    Container(color: Colors.red),\n    Container(color: Colors.blue),\n    Container(color: Colors.green),\n    Container(color: Colors.yellow),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "GridView.extent - Maximum Item Size",
              "content": "\nInstead of specifying columns, specify max width per item:\n\n\nAutomatically adjusts columns based on screen size - **responsive**!\n\n",
              "code": "GridView.extent(\n  maxCrossAxisExtent: 150,  // Max 150px per item\n  children: [\n    // Items adjust to fit screen width\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nGrids arrange items in 2D. But what about **overlaying** widgets on top of each other? That's **Stack**!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.2-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a product grid with: 1. At least 9 items 2. 3 columns 3. Each item shows image and name 4. Add spacing between items ---",
              "instructions": "Create a product grid with: 1. At least 9 items 2. 3 columns 3. Each item shows image and name 4. Add spacing between items ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Product Grid with GridView\n// Shows a 3-column grid of products with images and names\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ProductGridApp());\n}\n\nclass ProductGridApp extends StatelessWidget {\n  const ProductGridApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Product Grid')),\n        body: const ProductGrid(),\n      ),\n    );\n  }\n}\n\nclass ProductGrid extends StatelessWidget {\n  const ProductGrid({super.key});\n\n  // Sample product data\n  static const List<Map<String, String>> products = [\n    {'name': 'Laptop', 'image': 'https://picsum.photos/200?1'},\n    {'name': 'Phone', 'image': 'https://picsum.photos/200?2'},\n    {'name': 'Headphones', 'image': 'https://picsum.photos/200?3'},\n    {'name': 'Watch', 'image': 'https://picsum.photos/200?4'},\n    {'name': 'Camera', 'image': 'https://picsum.photos/200?5'},\n    {'name': 'Tablet', 'image': 'https://picsum.photos/200?6'},\n    {'name': 'Speaker', 'image': 'https://picsum.photos/200?7'},\n    {'name': 'Keyboard', 'image': 'https://picsum.photos/200?8'},\n    {'name': 'Mouse', 'image': 'https://picsum.photos/200?9'},\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(8),\n      child: GridView.builder(\n        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(\n          crossAxisCount: 3,       // 3 columns\n          crossAxisSpacing: 8,     // Horizontal spacing\n          mainAxisSpacing: 8,      // Vertical spacing\n          childAspectRatio: 0.75,  // Height = width / 0.75\n        ),\n        itemCount: products.length,\n        itemBuilder: (context, index) {\n          final product = products[index];\n          return ProductCard(\n            name: product['name']!,\n            imageUrl: product['image']!,\n          );\n        },\n      ),\n    );\n  }\n}\n\nclass ProductCard extends StatelessWidget {\n  final String name;\n  final String imageUrl;\n\n  const ProductCard({\n    super.key,\n    required this.name,\n    required this.imageUrl,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      clipBehavior: Clip.antiAlias,\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.stretch,\n        children: [\n          // Product image\n          Expanded(\n            child: Image.network(\n              imageUrl,\n              fit: BoxFit.cover,\n              errorBuilder: (_, __, ___) => const Center(\n                child: Icon(Icons.image_not_supported),\n              ),\n            ),\n          ),\n          // Product name\n          Padding(\n            padding: const EdgeInsets.all(8),\n            child: Text(\n              name,\n              textAlign: TextAlign.center,\n              style: const TextStyle(fontWeight: FontWeight.w500),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - GridView.builder: Efficient grid for many items\n// - SliverGridDelegateWithFixedCrossAxisCount: Fixed columns\n// - crossAxisSpacing/mainAxisSpacing: Spacing between items\n// - childAspectRatio: Controls item height relative to width",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "GridView displays 3 columns",
                  "expectedOutput": "crossAxisCount: 3 creates 3-column grid layout",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Grid items show product images and names",
                  "expectedOutput": "Image.network and Text widget in each ProductCard",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Spacing applied between grid items",
                  "expectedOutput": "crossAxisSpacing: 8 and mainAxisSpacing: 8 configured",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.3",
          "title": "Module 3, Lesson 3: Layering Widgets (Stack)",
          "moduleId": "module-03",
          "order": 3,
          "estimatedMinutes": 20,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Layer Cake Concept",
              "content": "\nSometimes you need widgets **on top** of each other:\n- Text on an image\n- Badge on an icon\n- Floating button over content\n\n**Stack** lets you layer widgets like a cake!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou can now arrange widgets vertically (Column), horizontally (Row), in lists (ListView), grids (GridView), and layers (Stack)! Next: making layouts **responsive** to different screen sizes!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.3-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a profile header with: 1. Background image 2. Profile photo overlaid 3. Name overlay at bottom ---",
              "instructions": "Create a profile header with: 1. Background image 2. Profile photo overlaid 3. Name overlay at bottom ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Profile Header with Stack\n// Uses Stack to overlay profile photo and name on background\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ProfileHeaderApp());\n}\n\nclass ProfileHeaderApp extends StatelessWidget {\n  const ProfileHeaderApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Column(\n          children: const [\n            ProfileHeader(),\n            Expanded(\n              child: Center(\n                child: Text('Profile Content'),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass ProfileHeader extends StatelessWidget {\n  const ProfileHeader({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      height: 250,\n      child: Stack(\n        clipBehavior: Clip.none,\n        children: [\n          // 1. Background image (fills entire Stack)\n          Positioned.fill(\n            child: Image.network(\n              'https://picsum.photos/800/400',\n              fit: BoxFit.cover,\n            ),\n          ),\n          \n          // Gradient overlay for better text visibility\n          Positioned.fill(\n            child: Container(\n              decoration: BoxDecoration(\n                gradient: LinearGradient(\n                  begin: Alignment.topCenter,\n                  end: Alignment.bottomCenter,\n                  colors: [\n                    Colors.transparent,\n                    Colors.black.withOpacity(0.7),\n                  ],\n                ),\n              ),\n            ),\n          ),\n          \n          // 2. Profile photo (centered, overlapping bottom)\n          Positioned(\n            bottom: -50, // Extends below the header\n            left: 0,\n            right: 0,\n            child: Center(\n              child: Container(\n                decoration: BoxDecoration(\n                  shape: BoxShape.circle,\n                  border: Border.all(color: Colors.white, width: 4),\n                ),\n                child: const CircleAvatar(\n                  radius: 50,\n                  backgroundImage: NetworkImage(\n                    'https://picsum.photos/200/200',\n                  ),\n                ),\n              ),\n            ),\n          ),\n          \n          // 3. Name overlay at bottom\n          Positioned(\n            bottom: 60,\n            left: 0,\n            right: 0,\n            child: Column(\n              children: const [\n                Text(\n                  'Jane Developer',\n                  style: TextStyle(\n                    color: Colors.white,\n                    fontSize: 24,\n                    fontWeight: FontWeight.bold,\n                  ),\n                ),\n                SizedBox(height: 4),\n                Text(\n                  'Flutter Enthusiast',\n                  style: TextStyle(\n                    color: Colors.white70,\n                    fontSize: 14,\n                  ),\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - Stack: Overlays widgets on top of each other\n// - Positioned: Places widgets at specific locations\n// - Positioned.fill: Fills entire Stack\n// - clipBehavior: Allows content to overflow",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.4",
          "title": "Module 3, Lesson 4: Responsive Layouts",
          "moduleId": "module-03",
          "order": 4,
          "estimatedMinutes": 30,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Multi-Screen Challenge",
              "content": "\nYour app runs on:\n- Small phones (320px wide)\n- Large phones (400px+)  \n- Tablets (600px+)\n- Desktop (1200px+)\n\n**One layout doesn't fit all!** You need **responsive** design.\n\n"
            },
            {
              "type": "THEORY",
              "title": "MediaQuery - Screen Information",
              "content": "\nGet device screen info:\n\n\n",
              "code": "double screenWidth = MediaQuery.of(context).size.width;\ndouble screenHeight = MediaQuery.of(context).size.height;",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Flexible Columns with GridView",
              "content": "\n\nOn 400px screen: 2 columns\nOn 800px screen: 4 columns\nAuto-responsive!\n\n",
              "code": "GridView.extent(\n  maxCrossAxisExtent: 200,  // Adjusts columns automatically!\n  children: items,\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou can now build responsive layouts! Next: creating **custom, reusable widgets** to organize your code!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.4-challenge-0",
              "title": "Practice Challenge",
              "description": "Create an app that shows: Use MediaQuery or GridView.extent! ---",
              "instructions": "Create an app that shows: Use MediaQuery or GridView.extent! ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Responsive Grid with GridView.extent\n// Automatically adjusts columns based on screen width\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ResponsiveGridApp());\n}\n\nclass ResponsiveGridApp extends StatelessWidget {\n  const ResponsiveGridApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Responsive Grid')),\n        body: const ResponsiveGrid(),\n      ),\n    );\n  }\n}\n\nclass ResponsiveGrid extends StatelessWidget {\n  const ResponsiveGrid({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Get screen width using MediaQuery\n    final screenWidth = MediaQuery.of(context).size.width;\n    \n    return Column(\n      children: [\n        // Display screen info\n        Container(\n          padding: const EdgeInsets.all(16),\n          color: Colors.blue.shade50,\n          width: double.infinity,\n          child: Text(\n            'Screen width: ${screenWidth.toStringAsFixed(0)}px',\n            style: const TextStyle(fontWeight: FontWeight.bold),\n          ),\n        ),\n        \n        // GridView.extent: Auto-adjusts columns based on item size\n        Expanded(\n          child: GridView.extent(\n            maxCrossAxisExtent: 150, // Max width of each item\n            padding: const EdgeInsets.all(8),\n            crossAxisSpacing: 8,\n            mainAxisSpacing: 8,\n            children: List.generate(12, (index) {\n              return Card(\n                color: Colors.primaries[index % Colors.primaries.length],\n                child: Center(\n                  child: Column(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    children: [\n                      Icon(\n                        Icons.widgets,\n                        color: Colors.white,\n                        size: 32,\n                      ),\n                      const SizedBox(height: 8),\n                      Text(\n                        'Item ${index + 1}',\n                        style: const TextStyle(\n                          color: Colors.white,\n                          fontWeight: FontWeight.bold,\n                        ),\n                      ),\n                    ],\n                  ),\n                ),\n              );\n            }),\n          ),\n        ),\n      ],\n    );\n  }\n}\n\n// Alternative: Using MediaQuery for manual control\nclass MediaQueryGrid extends StatelessWidget {\n  const MediaQueryGrid({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final width = MediaQuery.of(context).size.width;\n    // Calculate columns based on screen width\n    final columns = width < 400 ? 2 : (width < 800 ? 3 : 4);\n    \n    return GridView.builder(\n      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(\n        crossAxisCount: columns,\n        crossAxisSpacing: 8,\n        mainAxisSpacing: 8,\n      ),\n      itemCount: 12,\n      itemBuilder: (context, index) => Card(\n        child: Center(child: Text('Item ${index + 1}')),\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - GridView.extent: Auto columns based on maxCrossAxisExtent\n// - MediaQuery: Manual control over layout based on screen size\n// - Responsive design: Adapts to any screen width",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.5",
          "title": "Module 3, Lesson 5: Creating Custom Widgets",
          "moduleId": "module-03",
          "order": 5,
          "estimatedMinutes": 35,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Custom Widgets?",
              "content": "\nYou keep writing the same code over and over:\n- Product cards\n- List items\n- Buttons with icons\n\n**Solution**: Create **custom widgets** - reusable components!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Extracting a Widget",
              "content": "\n**Before**: Messy code with repetition\n\n\n**After**: Clean custom widget\n\n\n",
              "code": "// Define once\nclass CustomCard extends StatelessWidget {\n  final String text;\n  \n  CustomCard({required this.text});\n  \n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(16),\n      decoration: BoxDecoration(\n        color: Colors.white,\n        borderRadius: BorderRadius.circular(8),\n        boxShadow: [BoxShadow(color: Colors.grey, blurRadius: 4)],\n      ),\n      child: Text(text),\n    );\n  }\n}\n\n// Use many times\nCustomCard(text: 'Hello'),\nCustomCard(text: 'World'),",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Passing Callbacks",
              "content": "\nMake widgets interactive:\n\n\n",
              "code": "class CustomButton extends StatelessWidget {\n  final String label;\n  final VoidCallback onPressed;  // Function parameter!\n  \n  CustomButton({required this.label, required this.onPressed});\n  \n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      onPressed: onPressed,\n      child: Text(label),\n    );\n  }\n}\n\n// Usage:\nCustomButton(\n  label: 'Click Me',\n  onPressed: () {\n    print('Button clicked!');\n  },\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Widget Organization",
              "content": "\n**Project structure:**\n\n\n**Import and use:**\n\n\n",
              "code": "import 'widgets/product_card.dart';\n\n// Now use ProductCard anywhere",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou can now build and organize custom widgets! In the final Module 3 lessons, we'll cover **scrolling techniques** and build a complete **mini-project** combining everything!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.5-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a `CommentWidget` with: Use it to display 5 comments in a ListView! ---",
              "instructions": "Create a `CommentWidget` with: Use it to display 5 comments in a ListView! ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Reusable CommentWidget in ListView\n// Creates a reusable comment widget and displays 5 comments\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const CommentsApp());\n}\n\nclass CommentsApp extends StatelessWidget {\n  const CommentsApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Comments')),\n        body: const CommentsList(),\n      ),\n    );\n  }\n}\n\n// Reusable CommentWidget\nclass CommentWidget extends StatelessWidget {\n  final String authorName;\n  final String authorAvatar;\n  final String commentText;\n  final String timestamp;\n  final int likes;\n\n  const CommentWidget({\n    super.key,\n    required this.authorName,\n    required this.authorAvatar,\n    required this.commentText,\n    required this.timestamp,\n    this.likes = 0,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\n      child: Row(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          // Author avatar\n          CircleAvatar(\n            radius: 20,\n            backgroundImage: NetworkImage(authorAvatar),\n          ),\n          const SizedBox(width: 12),\n          \n          // Comment content\n          Expanded(\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                // Author name and timestamp\n                Row(\n                  children: [\n                    Text(\n                      authorName,\n                      style: const TextStyle(fontWeight: FontWeight.bold),\n                    ),\n                    const SizedBox(width: 8),\n                    Text(\n                      timestamp,\n                      style: TextStyle(color: Colors.grey.shade600, fontSize: 12),\n                    ),\n                  ],\n                ),\n                const SizedBox(height: 4),\n                \n                // Comment text\n                Text(commentText),\n                const SizedBox(height: 8),\n                \n                // Like button\n                Row(\n                  children: [\n                    Icon(Icons.thumb_up_outlined, size: 16, color: Colors.grey),\n                    const SizedBox(width: 4),\n                    Text('$likes', style: TextStyle(color: Colors.grey)),\n                    const SizedBox(width: 16),\n                    Text('Reply', style: TextStyle(color: Colors.blue)),\n                  ],\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Display 5 comments using ListView\nclass CommentsList extends StatelessWidget {\n  const CommentsList({super.key});\n\n  static const List<Map<String, dynamic>> comments = [\n    {'name': 'Alice', 'text': 'Great article! Very helpful.', 'time': '2h ago', 'likes': 12},\n    {'name': 'Bob', 'text': 'I learned a lot from this. Thanks!', 'time': '3h ago', 'likes': 8},\n    {'name': 'Carol', 'text': 'Can you explain the Stack widget more?', 'time': '5h ago', 'likes': 3},\n    {'name': 'David', 'text': 'Flutter is amazing!', 'time': '1d ago', 'likes': 25},\n    {'name': 'Eve', 'text': 'Following for more content like this.', 'time': '2d ago', 'likes': 5},\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.separated(\n      itemCount: comments.length,\n      separatorBuilder: (_, __) => const Divider(),\n      itemBuilder: (context, index) {\n        final comment = comments[index];\n        return CommentWidget(\n          authorName: comment['name'],\n          authorAvatar: 'https://picsum.photos/100?${index + 1}',\n          commentText: comment['text'],\n          timestamp: comment['time'],\n          likes: comment['likes'],\n        );\n      },\n    );\n  }\n}\n\n// Key concepts:\n// - Reusable widget with constructor parameters\n// - ListView.separated for dividers between items\n// - Flexible layout with Row and Expanded",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.6",
          "title": "Module 3, Lesson 6: Advanced Scrolling Techniques",
          "moduleId": "module-03",
          "order": 6,
          "estimatedMinutes": 45,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Beyond Basic Lists",
              "content": "\nYou've learned ListView for simple scrolling. But what about:\n- Horizontal scrolling\n- Mixing scrolling directions\n- Scrolling only when needed\n\nLet's master advanced scrolling!\n\n"
            },
            {
              "type": "THEORY",
              "title": "SingleChildScrollView",
              "content": "\nMakes ANY widget scrollable:\n\n\n**Use case**: Forms, long content that might overflow.\n\n",
              "code": "SingleChildScrollView(\n  child: Column(\n    children: [\n      Container(height: 200, color: Colors.red),\n      Container(height: 200, color: Colors.blue),\n      Container(height: 200, color: Colors.green),\n      Container(height: 200, color: Colors.yellow),\n      // If total height > screen, it scrolls!\n    ],\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Horizontal Scrolling",
              "content": "\n\n**Use case**: Image galleries, category chips.\n\n",
              "code": "SingleChildScrollView(\n  scrollDirection: Axis.horizontal,\n  child: Row(\n    children: [\n      Container(width: 200, color: Colors.red),\n      Container(width: 200, color: Colors.blue),\n      Container(width: 200, color: Colors.green),\n    ],\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "PageView - Swipeable Pages",
              "content": "\nLike Instagram stories:\n\n\nSwipe to navigate!\n\n",
              "code": "PageView(\n  children: [\n    Container(color: Colors.red, child: Center(child: Text('Page 1'))),\n    Container(color: Colors.blue, child: Center(child: Text('Page 2'))),\n    Container(color: Colors.green, child: Center(child: Text('Page 3'))),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Wrap - Auto-wrapping",
              "content": "\nLike word wrap, but for widgets:\n\n\n**Use case**: Tags, filter chips, buttons that wrap.\n\n",
              "code": "Wrap(\n  spacing: 8,  // Horizontal spacing\n  runSpacing: 8,  // Vertical spacing\n  children: [\n    Chip(label: Text('Flutter')),\n    Chip(label: Text('Dart')),\n    Chip(label: Text('Mobile')),\n    Chip(label: Text('Development')),\n    Chip(label: Text('UI')),\n    // Auto-wraps to next line when needed!\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "NestedScrollView",
              "content": "\nScroll a header away:\n\n\n",
              "code": "NestedScrollView(\n  headerSliverBuilder: (context, innerBoxIsScrolled) {\n    return [\n      SliverAppBar(\n        expandedHeight: 200,\n        floating: false,\n        pinned: true,\n        flexibleSpace: FlexibleSpaceBar(\n          title: Text('My App'),\n          background: Image.network('url', fit: BoxFit.cover),\n        ),\n      ),\n    ];\n  },\n  body: ListView.builder(\n    itemCount: 50,\n    itemBuilder: (context, index) {\n      return ListTile(title: Text('Item $index'));\n    },\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nFinal Module 3 lesson: **Mini-project** combining all layout techniques!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.6-challenge-0",
              "title": "Practice Challenge",
              "description": "Create: 1. Horizontal scrolling category chips (Wrap or Row) 2. Vertical product list 3. Pull-to-refresh functionality ---",
              "instructions": "Create: 1. Horizontal scrolling category chips (Wrap or Row) 2. Vertical product list 3. Pull-to-refresh functionality ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Categories with Pull-to-Refresh Product List\n// Horizontal chips, vertical list, and RefreshIndicator\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ShopApp());\n}\n\nclass ShopApp extends StatelessWidget {\n  const ShopApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Shop')),\n        body: const ShopScreen(),\n      ),\n    );\n  }\n}\n\nclass ShopScreen extends StatefulWidget {\n  const ShopScreen({super.key});\n\n  @override\n  State<ShopScreen> createState() => _ShopScreenState();\n}\n\nclass _ShopScreenState extends State<ShopScreen> {\n  String selectedCategory = 'All';\n  final categories = ['All', 'Electronics', 'Clothing', 'Books', 'Home', 'Sports'];\n  \n  final products = List.generate(\n    10,\n    (i) => {'name': 'Product ${i + 1}', 'price': (i + 1) * 9.99},\n  );\n\n  Future<void> _handleRefresh() async {\n    // Simulate network delay\n    await Future.delayed(const Duration(seconds: 1));\n    // In real app, fetch new data here\n    setState(() {});\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // 1. Horizontal scrolling category chips\n        SizedBox(\n          height: 50,\n          child: ListView.builder(\n            scrollDirection: Axis.horizontal,\n            padding: const EdgeInsets.symmetric(horizontal: 8),\n            itemCount: categories.length,\n            itemBuilder: (context, index) {\n              final category = categories[index];\n              final isSelected = category == selectedCategory;\n              return Padding(\n                padding: const EdgeInsets.symmetric(horizontal: 4),\n                child: FilterChip(\n                  label: Text(category),\n                  selected: isSelected,\n                  onSelected: (_) => setState(() => selectedCategory = category),\n                  backgroundColor: Colors.grey.shade200,\n                  selectedColor: Colors.blue.shade100,\n                ),\n              );\n            },\n          ),\n        ),\n        const Divider(),\n        \n        // 2 & 3. Vertical product list with pull-to-refresh\n        Expanded(\n          child: RefreshIndicator(\n            onRefresh: _handleRefresh,\n            child: ListView.builder(\n              itemCount: products.length,\n              itemBuilder: (context, index) {\n                final product = products[index];\n                return ListTile(\n                  leading: Container(\n                    width: 50,\n                    height: 50,\n                    color: Colors.grey.shade300,\n                    child: const Icon(Icons.shopping_bag),\n                  ),\n                  title: Text(product['name'] as String),\n                  subtitle: Text('\\$${(product['price'] as double).toStringAsFixed(2)}'),\n                  trailing: IconButton(\n                    icon: const Icon(Icons.add_shopping_cart),\n                    onPressed: () {},\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n\n// Key concepts:\n// - Horizontal ListView with scrollDirection: Axis.horizontal\n// - FilterChip for selectable category pills\n// - RefreshIndicator wraps scrollable for pull-to-refresh\n// - onRefresh must return a Future (async function)",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the dart syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.7",
          "title": "App Theming with Material 3",
          "moduleId": "module-03",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Learning Objectives",
              "content": "By the end of this lesson, you will be able to:\n- Understand Flutter's theming system with Material 3\n- Create a custom theme using ColorScheme.fromSeed\n- Implement light and dark themes\n- Customize TextTheme for consistent typography\n- Apply component-specific themes\n- Switch between themes dynamically\n- Use theme data throughout your app\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\n### What is App Theming?\n\n**Concept First:**\nImagine you're decorating a house. Without a theme, each room has random colors, different furniture styles, and mismatched lighting. It looks chaotic and unprofessional.\n\nWith a design theme, every room follows consistent colors, matching furniture styles, and coordinated lighting. The house feels cohesive and well-designed.\n\n**App theming** is the same idea: defining a consistent visual style (colors, fonts, button styles, etc.) that applies automatically throughout your entire app.\n\n**Real-world analogy:** Starbucks has a consistent theme‚Äîgreen colors, sans-serif fonts, rounded corners. You recognize it instantly. Your app needs the same consistency!\n\n**Jargon:**\n- **ThemeData**: Flutter's object containing all theme information\n- **ColorScheme**: A set of 30+ colors defining your app's color palette\n- **TextTheme**: A set of text styles for different purposes (headlines, body, captions)\n- **Material 3**: Google's latest design system (default in Flutter 3.16+)\n- **Seed Color**: A single color that generates an entire color palette\n\n### Why This Matters\n\n**Without theming:**\n\n**With theming:**\n\n",
              "code": "// Styled automatically from theme!\nElevatedButton(\n  child: Text('Submit'),\n  onPressed: () {},\n)\n\n// Change your theme's primary color once ‚Üí all buttons update! ‚ú®",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 1: Understanding Material 3 Theming",
              "content": "\n### Material 3 Color System\n\nMaterial 3 generates a complete color palette from a **single seed color**:\n\n\n**Analogy:** Give an interior designer your favorite color. They create an entire palette‚Äîwall colors, furniture, accents‚Äîall coordinated automatically!\n\n### Material 3 is Default (Flutter 3.16+)\n\nAs of Flutter 3.16, Material 3 is enabled by default. You don't need to set `useMaterial3: true` anymore!\n\n",
              "code": "Seed Color (e.g., Blue #2196F3)\n    ‚Üì\nGenerates:\n- Primary (Main brand color)\n- Secondary (Accent color)\n- Tertiary (Complementary color)\n- Error (Error states)\n- Surface (Backgrounds)\n- OnPrimary (Text on primary color)\n- OnSecondary (Text on secondary color)\n... (30+ colors total!)",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Section 2: Creating Your First Theme",
              "content": "\n### Basic Theme Setup\n\n\n**What happens:**\n1. `ColorScheme.fromSeed` generates 30+ coordinated colors from `Colors.deepPurple`\n2. All Material widgets (buttons, app bars, cards) use these colors automatically\n3. Change `seedColor` to `Colors.teal` ‚Üí entire app changes instantly!\n\n",
              "code": "// main.dart\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(const MyApp());\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Themed App',\n\n      // Define your theme here\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(\n          seedColor: Colors.deepPurple,\n        ),\n      ),\n\n      home: const HomeScreen(),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('My Themed App'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // These widgets automatically use theme colors!\n            ElevatedButton(\n              onPressed: () {},\n              child: const Text('Primary Button'),\n            ),\n            const SizedBox(height: 16),\n            FilledButton(\n              onPressed: () {},\n              child: const Text('Filled Button'),\n            ),\n            const SizedBox(height: 16),\n            OutlinedButton(\n              onPressed: () {},\n              child: const Text('Outlined Button'),\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {},\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 3: Light and Dark Themes",
              "content": "\n### Implementing Theme Switching\n\n\n**ThemeMode options:**\n- `ThemeMode.light` - Always use light theme\n- `ThemeMode.dark` - Always use dark theme\n- `ThemeMode.system` - Follow device setting (recommended)\n\n### Manual Theme Switching\n\n\n",
              "code": "class MyApp extends StatefulWidget {\n  const MyApp({super.key});\n\n  @override\n  State<MyApp> createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  ThemeMode _themeMode = ThemeMode.system;\n\n  void _toggleTheme() {\n    setState(() {\n      _themeMode = _themeMode == ThemeMode.light\n          ? ThemeMode.dark\n          : ThemeMode.light;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(\n          seedColor: Colors.blue,\n          brightness: Brightness.light,\n        ),\n      ),\n      darkTheme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(\n          seedColor: Colors.blue,\n          brightness: Brightness.dark,\n        ),\n      ),\n      themeMode: _themeMode,\n      home: HomeScreen(onToggleTheme: _toggleTheme),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  final VoidCallback onToggleTheme;\n\n  const HomeScreen({super.key, required this.onToggleTheme});\n\n  @override\n  Widget build(BuildContext context) {\n    final isDark = Theme.of(context).brightness == Brightness.dark;\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Theme Switcher'),\n        actions: [\n          IconButton(\n            icon: Icon(isDark ? Icons.light_mode : Icons.dark_mode),\n            onPressed: onToggleTheme,\n          ),\n        ],\n      ),\n      body: const Center(\n        child: Text('Toggle theme with the icon button'),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 4: Customizing TextTheme",
              "content": "\n### Understanding TextTheme Styles\n\nTextTheme provides predefined styles for different text purposes:\n\n| Style | Purpose | Example |\n|-------|---------|---------|\n| `displayLarge` | Very large headlines | \"Welcome\" on splash screen |\n| `headlineLarge` | Section headers | \"Settings\" title |\n| `titleLarge` | Card titles | \"New Message\" dialog title |\n| `bodyLarge` | Main content | Article text |\n| `bodyMedium` | Default body text | Paragraph text |\n| `labelLarge` | Button text | \"SUBMIT\" button |\n\n### Custom TextTheme Example\n\n\n### Using Custom Fonts\n\n\n\n",
              "code": "ThemeData(\n  colorScheme: ColorScheme.fromSeed(seedColor: Colors.purple),\n\n  textTheme: const TextTheme(\n    headlineLarge: TextStyle(\n      fontFamily: 'Poppins',\n      fontSize: 32,\n      fontWeight: FontWeight.bold,\n    ),\n    bodyLarge: TextStyle(\n      fontFamily: 'Poppins',\n      fontSize: 16,\n    ),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 5: Component-Specific Theming",
              "content": "\n### Customizing Button Themes\n\n\n### Customizing AppBar Theme\n\n\n### Customizing Input Decoration Theme\n\n\n### Customizing Card Theme\n\n\n",
              "code": "ThemeData(\n  colorScheme: ColorScheme.fromSeed(seedColor: Colors.purple),\n\n  cardTheme: CardTheme(\n    elevation: 4,\n    shape: RoundedRectangleBorder(\n      borderRadius: BorderRadius.circular(16),\n    ),\n    margin: const EdgeInsets.all(8),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 6: Accessing Theme Data",
              "content": "\n### Using Theme.of(context)\n\n\n### Common Theme Properties\n\n\n",
              "code": "// Colors\nTheme.of(context).colorScheme.primary\nTheme.of(context).colorScheme.secondary\nTheme.of(context).colorScheme.surface\nTheme.of(context).colorScheme.error\nTheme.of(context).colorScheme.onPrimary  // Text color on primary background\n\n// Text styles\nTheme.of(context).textTheme.headlineLarge\nTheme.of(context).textTheme.bodyLarge\nTheme.of(context).textTheme.labelLarge\n\n// Check if dark mode\nTheme.of(context).brightness == Brightness.dark",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Section 7: Complete Theming Example",
              "content": "\n### Comprehensive App Theme\n\n\n### Using the Theme\n\n\n",
              "code": "// lib/main.dart\nimport 'package:flutter/material.dart';\nimport 'theme/app_theme.dart';\n\nvoid main() => runApp(const MyApp());\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Themed App',\n      theme: AppTheme.lightTheme,\n      darkTheme: AppTheme.darkTheme,\n      themeMode: ThemeMode.system,\n      home: const HomeScreen(),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Material 3 Theme'),\n      ),\n      body: ListView(\n        padding: const EdgeInsets.all(16),\n        children: [\n          // Headline\n          Text(\n            'Welcome!',\n            style: Theme.of(context).textTheme.headlineLarge,\n          ),\n          const SizedBox(height: 16),\n\n          // Body text\n          Text(\n            'This app uses a custom Material 3 theme with consistent colors, typography, and component styling.',\n            style: Theme.of(context).textTheme.bodyLarge,\n          ),\n          const SizedBox(height: 24),\n\n          // Buttons\n          ElevatedButton(\n            onPressed: () {},\n            child: const Text('Elevated Button'),\n          ),\n          const SizedBox(height: 16),\n\n          FilledButton(\n            onPressed: () {},\n            child: const Text('Filled Button'),\n          ),\n          const SizedBox(height: 16),\n\n          OutlinedButton(\n            onPressed: () {},\n            child: const Text('Outlined Button'),\n          ),\n          const SizedBox(height: 24),\n\n          // Card\n          Card(\n            child: Padding(\n              padding: const EdgeInsets.all(16),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text(\n                    'Themed Card',\n                    style: Theme.of(context).textTheme.titleLarge,\n                  ),\n                  const SizedBox(height: 8),\n                  Text(\n                    'This card automatically uses the theme\\'s card styling.',\n                    style: Theme.of(context).textTheme.bodyMedium,\n                  ),\n                ],\n              ),\n            ),\n          ),\n          const SizedBox(height: 24),\n\n          // Input field\n          const TextField(\n            decoration: InputDecoration(\n              labelText: 'Username',\n              hintText: 'Enter your username',\n              prefixIcon: Icon(Icons.person),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Section 8: Best Practices",
              "content": "\n### 1. Use One Seed Color for Consistency\n\n**Good:**\n\n### 2. Extract Theme to Separate File\n\n\n### 3. Always Use Theme Colors, Never Hardcode\n\n**Bad:**\n\n**Good:**\n\n### 4. Use Material 3 Color Roles\n\nMaterial 3 provides semantic color roles:\n- `primary` - Main brand actions\n- `secondary` - Less prominent actions\n- `tertiary` - Complementary accents\n- `error` - Errors and warnings\n- `surface` - Card and sheet backgrounds\n- `onPrimary`, `onSecondary`, etc. - Text on those colors\n\nUse these instead of arbitrary colors!\n\n### 5. Test Both Light and Dark Themes\n\nAlways test your app in both themes:\n\n",
              "code": "// In main.dart, temporarily force dark mode for testing\nthemeMode: ThemeMode.dark,  // Change to test",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\nTest your understanding of app theming:\n\n### Question 1\nWhat is the recommended way to create a color scheme in Material 3?\n\nA) Define 30 colors manually\nB) Use `ColorScheme.fromSeed()` with a single seed color\nC) Use hexadecimal color codes throughout your app\nD) Copy colors from another app\n\n### Question 2\nWhat does `Theme.of(context)` do?\n\nA) Creates a new theme\nB) Returns the current theme applied to the widget tree\nC) Switches between light and dark themes\nD) Deletes the current theme\n\n### Question 3\nWhich TextTheme style should you use for button text?\n\nA) `displayLarge`\nB) `headlineLarge`\nC) `bodyLarge`\nD) `labelLarge`\n\n### Question 4\nWhat is the correct way to make an app support both light and dark themes?\n\nA) Create two separate apps\nB) Define both `theme` and `darkTheme` in MaterialApp\nC) Use only dark colors\nD) Themes can't be switched\n\n### Question 5\nWhen should you hardcode colors like `Colors.red` in your widgets?\n\nA) Always, for precision\nB) For important elements only\nC) Rarely‚Äîuse theme colors instead for consistency\nD) Never, even for semantic colors like error states\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Question 1: B** - `ColorScheme.fromSeed()` is the Material 3 way. It generates a complete, harmonious 30-color palette from a single seed color automatically.\n\n**Question 2: B** - `Theme.of(context)` returns the nearest ThemeData in the widget tree, allowing you to access theme colors, text styles, and other styling information.\n\n**Question 3: D** - `labelLarge` is specifically designed for button text in Material 3. It has appropriate sizing and weight for button labels.\n\n**Question 4: B** - Define both `theme` (light) and `darkTheme` (dark) in MaterialApp, then use `themeMode` to control which is active. Flutter handles the switching automatically.\n\n**Question 5: C** - Use theme colors for consistency. Hardcoded colors should be rare exceptions. For error states, use `Theme.of(context).colorScheme.error` instead of `Colors.red`.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nIn this lesson, you learned:\n\n‚úÖ **ThemeData** defines your app's visual style in one place\n‚úÖ **ColorScheme.fromSeed()** generates a complete color palette from one seed color\n‚úÖ **Material 3** is the default in Flutter 3.16+ with 30+ coordinated colors\n‚úÖ **Light and dark themes** can be implemented with `theme` and `darkTheme`\n‚úÖ **TextTheme** provides predefined styles for different text purposes\n‚úÖ **Component themes** customize specific widgets (buttons, cards, inputs)\n‚úÖ **Theme.of(context)** accesses theme data anywhere in your widget tree\n‚úÖ Using theme colors ensures **consistency** across your entire app\n\n**Key Takeaway:** Theming is essential for professional apps. Define your theme once, and every widget automatically follows your design system. Change your seed color, and your entire app updates instantly. This saves time, ensures consistency, and makes your app look polished!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn **Lesson 3.8: Mini-Project - Instagram-Style Feed** (previously Lesson 3.7), you'll apply everything you've learned about layouts AND theming to build a beautiful, themed social media feed with custom styling!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "3.8",
          "title": "Module 3, Lesson 7: Mini-Project - Instagram-Style Feed",
          "moduleId": "module-03",
          "order": 8,
          "estimatedMinutes": 30,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Putting It All Together!",
              "content": "\nYou've mastered layouts! Now build a complete Instagram-style feed combining:\n- ListView for scrolling posts\n- GridView for photo galleries\n- Stack for overlays\n- Custom widgets for posts\n- Responsive design\n\n"
            },
            {
              "type": "THEORY",
              "title": "What We're Building",
              "content": "\nAn Instagram-like feed with:\n- Posts with images\n- Like/comment/share buttons\n- Profile avatars\n- Stories section (horizontal scroll)\n- Responsive grid for explore page\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nModule 3 complete! You can now:\n- ‚úÖ Create scrollable lists (ListView)\n- ‚úÖ Build grids (GridView)\n- ‚úÖ Layer widgets (Stack)\n- ‚úÖ Make responsive layouts (MediaQuery, LayoutBuilder)\n- ‚úÖ Create custom widgets\n- ‚úÖ Use advanced scrolling (PageView, Wrap)\n- ‚úÖ Build complex UI layouts\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\n**Module 4: User Interaction!**\n\nYou can build beautiful layouts, but they don't DO anything yet! Next, you'll learn:\n- Handling button presses\n- Getting user input from text fields\n- Managing state (making your app interactive)\n- Building forms\n\nGet ready to make your apps come alive! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.8-challenge-0",
              "title": "Practice Challenge",
              "description": "Adjust grid columns based on screen width. ---",
              "instructions": "Adjust grid columns based on screen width. ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Adaptive Grid Columns\n// Changes column count based on screen width breakpoints\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const AdaptiveGridApp());\n}\n\nclass AdaptiveGridApp extends StatelessWidget {\n  const AdaptiveGridApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Adaptive Grid')),\n        body: const AdaptiveGrid(),\n      ),\n    );\n  }\n}\n\nclass AdaptiveGrid extends StatelessWidget {\n  const AdaptiveGrid({super.key});\n\n  // Determine column count based on screen width\n  int _getColumnCount(double width) {\n    if (width < 400) return 2;       // Mobile portrait\n    if (width < 600) return 3;       // Mobile landscape / small tablet\n    if (width < 900) return 4;       // Tablet\n    return 5;                         // Desktop\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n      builder: (context, constraints) {\n        final width = constraints.maxWidth;\n        final columns = _getColumnCount(width);\n        \n        return Column(\n          children: [\n            // Info bar showing current layout\n            Container(\n              width: double.infinity,\n              padding: const EdgeInsets.all(12),\n              color: Colors.blue.shade50,\n              child: Text(\n                'Width: ${width.toStringAsFixed(0)}px | Columns: $columns',\n                style: const TextStyle(fontWeight: FontWeight.bold),\n                textAlign: TextAlign.center,\n              ),\n            ),\n            \n            // Adaptive grid\n            Expanded(\n              child: GridView.builder(\n                padding: const EdgeInsets.all(8),\n                gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(\n                  crossAxisCount: columns,\n                  crossAxisSpacing: 8,\n                  mainAxisSpacing: 8,\n                  childAspectRatio: 1,\n                ),\n                itemCount: 20,\n                itemBuilder: (context, index) {\n                  return Card(\n                    color: Colors.primaries[index % Colors.primaries.length].shade100,\n                    child: Center(\n                      child: Column(\n                        mainAxisAlignment: MainAxisAlignment.center,\n                        children: [\n                          Icon(\n                            Icons.grid_view,\n                            size: 32,\n                            color: Colors.primaries[index % Colors.primaries.length],\n                          ),\n                          const SizedBox(height: 8),\n                          Text(\n                            'Item ${index + 1}',\n                            style: const TextStyle(fontWeight: FontWeight.w500),\n                          ),\n                        ],\n                      ),\n                    ),\n                  );\n                },\n              ),\n            ),\n          ],\n        );\n      },\n    );\n  }\n}\n\n// Key concepts:\n// - LayoutBuilder provides parent constraints\n// - Breakpoints define column count for different widths\n// - SliverGridDelegateWithFixedCrossAxisCount for fixed columns\n// - Resize window to see columns change dynamically",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-04",
      "title": "Module 4: Flutter Development",
      "description": "Learn Flutter development - Module 4",
      "difficulty": "beginner",
      "estimatedHours": 4,
      "lessons": [
        {
          "id": "4.1",
          "title": "Module 4, Lesson 1: Making Things Clickable (Buttons)",
          "moduleId": "module-04",
          "order": 1,
          "estimatedMinutes": 45,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "From Static to Interactive!",
              "content": "\nBeautiful UIs are great, but **real apps respond** to user actions!\n\nThink about every app you use:\n- Tap to like a post\n- Click to submit a form\n- Press to send a message\n\n**Buttons make apps interactive!**\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Button",
              "content": "\n\nRun this and click the button - check the console!\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () {\n              print('Button pressed!');\n            },\n            child: Text('Click Me'),\n          ),\n        ),\n      ),\n    ),\n  );\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Button Types in Flutter",
              "content": "\n### 1. ElevatedButton - Raised with shadow\n\n\n### 2. TextButton - Flat, no background\n\n\n### 3. OutlinedButton - Border, no fill\n\n\n### 4. IconButton - Just an icon\n\n\n### 5. FloatingActionButton - Circular, floating\n\n\n",
              "code": "FloatingActionButton(\n  onPressed: () {\n    print('FAB pressed');\n  },\n  child: Icon(Icons.add),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Styling Buttons",
              "content": "\n### Colors\n\n\n### Size\n\n\n### Rounded Corners\n\n\n",
              "code": "ElevatedButton(\n  style: ElevatedButton.styleFrom(\n    shape: RoundedRectangleBorder(\n      borderRadius: BorderRadius.circular(30),\n    ),\n  ),\n  onPressed: () {},\n  child: Text('Rounded'),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Disabled Buttons",
              "content": "\n\nThe button appears grayed out and doesn't respond!\n\n",
              "code": "ElevatedButton(\n  onPressed: null,  // null = disabled\n  child: Text('Disabled'),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "InkWell - Make Anything Clickable",
              "content": "\nTurn ANY widget into a button:\n\n\n",
              "code": "InkWell(\n  onTap: () {\n    print('Container tapped!');\n  },\n  child: Container(\n    padding: EdgeInsets.all(20),\n    color: Colors.blue,\n    child: Text('Tap me', style: TextStyle(color: Colors.white)),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nButtons let users trigger actions. But what about **getting INPUT** from users? Next: Text fields!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.1-challenge-0",
              "title": "Practice Challenge",
              "description": "Create an app with: 1. At least 5 different button types 2. Each button with different styling 3. Buttons that print different messages 4. One disabled button ---",
              "instructions": "Create an app with: 1. At least 5 different button types 2. Each button with different styling 3. Buttons that print different messages 4. One disabled button ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Button Showcase App\n// Demonstrates 5+ button types with different styles\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ButtonShowcaseApp());\n}\n\nclass ButtonShowcaseApp extends StatelessWidget {\n  const ButtonShowcaseApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Button Types')),\n        body: const ButtonShowcase(),\n      ),\n    );\n  }\n}\n\nclass ButtonShowcase extends StatelessWidget {\n  const ButtonShowcase({super.key});\n\n  void _showMessage(BuildContext context, String message) {\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text(message), duration: const Duration(seconds: 1)),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SingleChildScrollView(\n      padding: const EdgeInsets.all(16),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.stretch,\n        children: [\n          // 1. ElevatedButton - Primary action\n          ElevatedButton(\n            onPressed: () => _showMessage(context, 'ElevatedButton pressed!'),\n            style: ElevatedButton.styleFrom(\n              backgroundColor: Colors.blue,\n              foregroundColor: Colors.white,\n              padding: const EdgeInsets.all(16),\n            ),\n            child: const Text('Elevated Button'),\n          ),\n          const SizedBox(height: 16),\n          \n          // 2. TextButton - Secondary action\n          TextButton(\n            onPressed: () => _showMessage(context, 'TextButton pressed!'),\n            style: TextButton.styleFrom(\n              foregroundColor: Colors.purple,\n            ),\n            child: const Text('Text Button'),\n          ),\n          const SizedBox(height: 16),\n          \n          // 3. OutlinedButton - Tertiary action\n          OutlinedButton(\n            onPressed: () => _showMessage(context, 'OutlinedButton pressed!'),\n            style: OutlinedButton.styleFrom(\n              side: const BorderSide(color: Colors.green, width: 2),\n              foregroundColor: Colors.green,\n            ),\n            child: const Text('Outlined Button'),\n          ),\n          const SizedBox(height: 16),\n          \n          // 4. IconButton - Icon-only action\n          Row(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              IconButton(\n                onPressed: () => _showMessage(context, 'Favorite pressed!'),\n                icon: const Icon(Icons.favorite),\n                color: Colors.red,\n                iconSize: 32,\n              ),\n              IconButton(\n                onPressed: () => _showMessage(context, 'Share pressed!'),\n                icon: const Icon(Icons.share),\n                color: Colors.blue,\n                iconSize: 32,\n              ),\n            ],\n          ),\n          const SizedBox(height: 16),\n          \n          // 5. FloatingActionButton style\n          Center(\n            child: FloatingActionButton.extended(\n              onPressed: () => _showMessage(context, 'FAB pressed!'),\n              icon: const Icon(Icons.add),\n              label: const Text('Add Item'),\n            ),\n          ),\n          const SizedBox(height: 16),\n          \n          // 6. Disabled button\n          ElevatedButton(\n            onPressed: null, // null makes it disabled\n            style: ElevatedButton.styleFrom(\n              disabledBackgroundColor: Colors.grey.shade300,\n            ),\n            child: const Text('Disabled Button'),\n          ),\n          const SizedBox(height: 16),\n          \n          // 7. Custom styled button\n          ElevatedButton(\n            onPressed: () => _showMessage(context, 'Custom button pressed!'),\n            style: ElevatedButton.styleFrom(\n              backgroundColor: Colors.orange,\n              foregroundColor: Colors.white,\n              shape: RoundedRectangleBorder(\n                borderRadius: BorderRadius.circular(20),\n              ),\n              elevation: 8,\n            ),\n            child: const Text('Custom Styled'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - ElevatedButton: Primary actions with elevation\n// - TextButton: Low-emphasis actions\n// - OutlinedButton: Medium-emphasis with border\n// - IconButton: Icon-only actions\n// - onPressed: null makes button disabled",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "4.2",
          "title": "Module 4, Lessons 2-3: Text Input and Forms",
          "moduleId": "module-04",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Getting User Input",
              "content": "\nButtons trigger actions, but how do we get TEXT from users?\n- Login forms (username/password)\n- Search bars\n- Comments and messages\n- Registration forms\n\n**TextField** is the answer!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Reading TextField Value",
              "content": "\nUse a **TextEditingController**:\n\n\n",
              "code": "class TextFieldDemo extends StatefulWidget {\n  @override\n  _TextFieldDemoState createState() => _TextFieldDemoState();\n}\n\nclass _TextFieldDemoState extends State<TextFieldDemo> {\n  TextEditingController nameController = TextEditingController();\n  \n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TextField(\n          controller: nameController,\n          decoration: InputDecoration(labelText: 'Name'),\n        ),\n        ElevatedButton(\n          onPressed: () {\n            String name = nameController.text;\n            print('Name: $name');\n          },\n          child: Text('Submit'),\n        ),\n      ],\n    );\n  }\n  \n  @override\n  void dispose() {\n    nameController.dispose();  // Clean up!\n    super.dispose();\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou can now get input from users! But how do we make the UI UPDATE when data changes? Next: **StatefulWidget and setState**!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.2-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a search TextField with search icon that filters a list. ---",
              "instructions": "Create a search TextField with search icon that filters a list. ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Search TextField with Filtering\n// Real-time search that filters a list of items\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const SearchApp());\n}\n\nclass SearchApp extends StatelessWidget {\n  const SearchApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Search Demo')),\n        body: const SearchScreen(),\n      ),\n    );\n  }\n}\n\nclass SearchScreen extends StatefulWidget {\n  const SearchScreen({super.key});\n\n  @override\n  State<SearchScreen> createState() => _SearchScreenState();\n}\n\nclass _SearchScreenState extends State<SearchScreen> {\n  final TextEditingController _searchController = TextEditingController();\n  \n  // Sample data\n  final List<String> allItems = [\n    'Apple', 'Banana', 'Cherry', 'Date', 'Elderberry',\n    'Fig', 'Grape', 'Honeydew', 'Kiwi', 'Lemon',\n    'Mango', 'Nectarine', 'Orange', 'Papaya', 'Quince',\n  ];\n  \n  List<String> filteredItems = [];\n  \n  @override\n  void initState() {\n    super.initState();\n    filteredItems = allItems; // Start with all items\n    _searchController.addListener(_onSearchChanged);\n  }\n  \n  @override\n  void dispose() {\n    _searchController.dispose();\n    super.dispose();\n  }\n  \n  void _onSearchChanged() {\n    final query = _searchController.text.toLowerCase();\n    setState(() {\n      if (query.isEmpty) {\n        filteredItems = allItems;\n      } else {\n        filteredItems = allItems\n            .where((item) => item.toLowerCase().contains(query))\n            .toList();\n      }\n    });\n  }\n  \n  void _clearSearch() {\n    _searchController.clear();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // Search TextField with icon\n        Padding(\n          padding: const EdgeInsets.all(16),\n          child: TextField(\n            controller: _searchController,\n            decoration: InputDecoration(\n              hintText: 'Search fruits...',\n              prefixIcon: const Icon(Icons.search),\n              suffixIcon: _searchController.text.isNotEmpty\n                  ? IconButton(\n                      icon: const Icon(Icons.clear),\n                      onPressed: _clearSearch,\n                    )\n                  : null,\n              border: OutlineInputBorder(\n                borderRadius: BorderRadius.circular(12),\n              ),\n              filled: true,\n              fillColor: Colors.grey.shade100,\n            ),\n          ),\n        ),\n        \n        // Results count\n        Padding(\n          padding: const EdgeInsets.symmetric(horizontal: 16),\n          child: Text(\n            'Found ${filteredItems.length} items',\n            style: TextStyle(color: Colors.grey.shade600),\n          ),\n        ),\n        const SizedBox(height: 8),\n        \n        // Filtered list\n        Expanded(\n          child: filteredItems.isEmpty\n              ? const Center(child: Text('No items found'))\n              : ListView.builder(\n                  itemCount: filteredItems.length,\n                  itemBuilder: (context, index) {\n                    return ListTile(\n                      leading: const Icon(Icons.local_grocery_store),\n                      title: Text(filteredItems[index]),\n                    );\n                  },\n                ),\n        ),\n      ],\n    );\n  }\n}\n\n// Key concepts:\n// - TextEditingController: Manages text input\n// - addListener: Responds to text changes\n// - where + contains: Filter list by search query\n// - prefixIcon/suffixIcon: Icons inside TextField\n// - dispose: Clean up controller",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "4.3",
          "title": "Module 4, Lesson 3: Gestures and Touch Interactions",
          "moduleId": "module-04",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Beyond Buttons",
              "content": "\nButtons are great, but apps need richer interactions:\n- **Swipe** to delete items\n- **Long press** for context menus\n- **Drag** items around\n- **Pinch** to zoom\n- **Double tap** to like\n\n**Flutter makes this easy with GestureDetector!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "The GestureDetector Widget",
              "content": "\nWrap ANY widget to make it detect gestures:\n\n\n",
              "code": "GestureDetector(\n  onTap: () {\n    print('Tapped!');\n  },\n  child: Container(\n    width: 200,\n    height: 200,\n    color: Colors.blue,\n    child: Center(child: Text('Tap Me')),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Tap vs InkWell",
              "content": "\n**GestureDetector**: No visual feedback\n**InkWell**: Material ripple effect\n\n\n**Best Practice**: Use InkWell for Material Design apps!\n\n",
              "code": "// No visual feedback\nGestureDetector(\n  onTap: () => print('Tap'),\n  child: Container(\n    color: Colors.blue,\n    padding: EdgeInsets.all(20),\n    child: Text('Tap Me'),\n  ),\n)\n\n// With ripple effect\nInkWell(\n  onTap: () => print('Tap'),\n  child: Container(\n    padding: EdgeInsets.all(20),\n    child: Text('Tap Me'),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Double Tap Example (Like Button)",
              "content": "\n\n**Instagram-style double-tap to like!**\n\n",
              "code": "class LikeableImage extends StatefulWidget {\n  @override\n  _LikeableImageState createState() => _LikeableImageState();\n}\n\nclass _LikeableImageState extends State<LikeableImage> {\n  bool isLiked = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onDoubleTap: () {\n        setState(() {\n          isLiked = !isLiked;\n        });\n      },\n      child: Stack(\n        alignment: Alignment.center,\n        children: [\n          Image.network(\n            'https://picsum.photos/400',\n            width: 400,\n            height: 400,\n            fit: BoxFit.cover,\n          ),\n          if (isLiked)\n            Icon(\n              Icons.favorite,\n              size: 100,\n              color: Colors.red.withOpacity(0.7),\n            ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Swipe to Dismiss",
              "content": "\n\n**Swipe left to delete - like iOS Mail!**\n\n",
              "code": "class SwipeableTodo extends StatelessWidget {\n  final List<String> todos = ['Buy milk', 'Walk dog', 'Code Flutter'];\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      itemCount: todos.length,\n      itemBuilder: (context, index) {\n        return Dismissible(\n          key: Key(todos[index]),\n          background: Container(\n            color: Colors.red,\n            alignment: Alignment.centerRight,\n            padding: EdgeInsets.only(right: 20),\n            child: Icon(Icons.delete, color: Colors.white),\n          ),\n          direction: DismissDirection.endToStart,\n          onDismissed: (direction) {\n            ScaffoldMessenger.of(context).showSnackBar(\n              SnackBar(content: Text('${todos[index]} deleted')),\n            );\n          },\n          child: ListTile(\n            leading: Icon(Icons.check_box_outline_blank),\n            title: Text(todos[index]),\n          ),\n        );\n      },\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Haptic Feedback",
              "content": "\nAdd tactile feedback for better UX:\n\n\n",
              "code": "import 'package:flutter/services.dart';\n\nGestureDetector(\n  onTap: () {\n    HapticFeedback.lightImpact();  // Subtle vibration\n    print('Tapped!');\n  },\n  onLongPress: () {\n    HapticFeedback.heavyImpact();  // Stronger vibration\n    print('Long pressed!');\n  },\n  child: YourWidget(),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Gesture Priority",
              "content": "\n**Problem**: What if you have overlapping gestures?\n\n\n**Result**: Only \"Child tap\" prints (child wins)\n\nTo allow parent to handle: Use `behavior: HitTestBehavior.translucent`\n\n",
              "code": "GestureDetector(\n  onTap: () => print('Parent tap'),\n  child: Container(\n    color: Colors.blue,\n    padding: EdgeInsets.all(50),\n    child: GestureDetector(\n      onTap: () => print('Child tap'),\n      child: Container(\n        color: Colors.red,\n        width: 100,\n        height: 100,\n      ),\n    ),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: No visual feedback\n\n‚úÖ **Fix**: Use InkWell or change colors on tap\n\n‚ùå **Mistake 2**: Forgetting setState in gesture handlers\n\n‚úÖ **Fix**: Always use setState\n\n",
              "code": "onTap: () {\n  setState(() {\n    isLiked = !isLiked;\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ GestureDetector for custom touch handling\n- ‚úÖ Tap, double tap, long press, drag gestures\n- ‚úÖ InkWell for Material ripple effects\n- ‚úÖ Dismissible for swipe-to-delete\n- ‚úÖ Haptic feedback for better UX\n- ‚úÖ Building Instagram-style interactions\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've mastered buttons, forms, state, and gestures! Next up: **Navigation and Routing** - how to build multi-screen apps!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.3-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a 3x3 grid where tiles can be dragged to reorder. ---",
              "instructions": "Create a 3x3 grid where tiles can be dragged to reorder. ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Draggable 3x3 Grid\n// Tiles can be dragged and dropped to reorder\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const DraggableGridApp());\n}\n\nclass DraggableGridApp extends StatelessWidget {\n  const DraggableGridApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Drag to Reorder')),\n        body: const DraggableGrid(),\n      ),\n    );\n  }\n}\n\nclass DraggableGrid extends StatefulWidget {\n  const DraggableGrid({super.key});\n\n  @override\n  State<DraggableGrid> createState() => _DraggableGridState();\n}\n\nclass _DraggableGridState extends State<DraggableGrid> {\n  // 9 tiles for 3x3 grid\n  List<int> tiles = List.generate(9, (i) => i + 1);\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(16),\n      child: GridView.builder(\n        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(\n          crossAxisCount: 3,\n          crossAxisSpacing: 8,\n          mainAxisSpacing: 8,\n        ),\n        itemCount: tiles.length,\n        itemBuilder: (context, index) {\n          final tile = tiles[index];\n          return DragTarget<int>(\n            onAcceptWithDetails: (details) {\n              setState(() {\n                final draggedIndex = tiles.indexOf(details.data);\n                tiles.removeAt(draggedIndex);\n                tiles.insert(index, details.data);\n              });\n            },\n            builder: (context, candidateData, rejectedData) {\n              final isHighlighted = candidateData.isNotEmpty;\n              return Draggable<int>(\n                data: tile,\n                feedback: Material(\n                  elevation: 8,\n                  borderRadius: BorderRadius.circular(12),\n                  child: _buildTile(tile, isDragging: true),\n                ),\n                childWhenDragging: Container(\n                  decoration: BoxDecoration(\n                    color: Colors.grey.shade200,\n                    borderRadius: BorderRadius.circular(12),\n                    border: Border.all(color: Colors.grey, style: BorderStyle.solid),\n                  ),\n                ),\n                child: AnimatedContainer(\n                  duration: const Duration(milliseconds: 200),\n                  decoration: BoxDecoration(\n                    color: isHighlighted ? Colors.blue.shade100 : null,\n                    borderRadius: BorderRadius.circular(12),\n                  ),\n                  child: _buildTile(tile),\n                ),\n              );\n            },\n          );\n        },\n      ),\n    );\n  }\n\n  Widget _buildTile(int number, {bool isDragging = false}) {\n    return Container(\n      width: 100,\n      height: 100,\n      decoration: BoxDecoration(\n        color: Colors.primaries[number % Colors.primaries.length],\n        borderRadius: BorderRadius.circular(12),\n        boxShadow: isDragging\n            ? [BoxShadow(color: Colors.black26, blurRadius: 10)]\n            : null,\n      ),\n      child: Center(\n        child: Text(\n          '$number',\n          style: const TextStyle(\n            color: Colors.white,\n            fontSize: 32,\n            fontWeight: FontWeight.bold,\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - Draggable: Makes widget draggable\n// - DragTarget: Accepts dropped items\n// - feedback: Widget shown while dragging\n// - childWhenDragging: Placeholder at original position\n// - onAcceptWithDetails: Handle drop and reorder list",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "4.4",
          "title": "Module 4, Lessons 4-5: StatefulWidget and Managing State",
          "moduleId": "module-04",
          "order": 4,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Update Problem",
              "content": "\nRight now, your apps are **static**. When you click a button, nothing changes on screen!\n\nTry this - it WON'T work:\n\n\n**Problem**: The screen doesn't know to rebuild!\n\n**Solution**: **StatefulWidget** and **setState()**!\n\n",
              "code": "class CounterBroken extends StatelessWidget {\n  int counter = 0;  // This won't update the UI!\n  \n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text('Count: $counter'),\n        ElevatedButton(\n          onPressed: () {\n            counter++;  // Changes variable but UI doesn't rebuild!\n            print(counter);  // Console shows it changes\n          },\n          child: Text('Increment'),\n        ),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First StatefulWidget",
              "content": "\n\n**Now it works!** Click the button and the number updates!\n\n",
              "code": "class Counter extends StatefulWidget {\n  @override\n  _CounterState createState() => _CounterState();\n}\n\nclass _CounterState extends State<Counter> {\n  int counter = 0;\n  \n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text('Count: $counter', style: TextStyle(fontSize: 48)),\n        ElevatedButton(\n          onPressed: () {\n            setState(() {\n              counter++;  // setState tells Flutter to rebuild!\n            });\n          },\n          child: Text('Increment'),\n        ),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Understanding StatefulWidget",
              "content": "\n**Two classes work together:**\n\n1. **Widget class** (`Counter`) - Immutable configuration\n2. **State class** (`_CounterState`) - Mutable state\n\n**Why?** Widgets rebuild often. State persists across rebuilds.\n\n"
            },
            {
              "type": "THEORY",
              "title": "The setState() Magic",
              "content": "\n\n**What setState does:**\n1. Runs the code inside  \n2. Marks widget as \"dirty\"\n3. Schedules a rebuild\n4. Calls `build()` again with new values\n\n",
              "code": "setState(() {\n  // Make changes here\n  counter++;\n  name = 'New Name';\n  isVisible = !isVisible;\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ StatelessWidget for static content\n- ‚úÖ StatefulWidget for dynamic content\n- ‚úÖ setState() triggers rebuilds\n- ‚úÖ State persists across rebuilds\n- ‚úÖ Lifecycle methods (initState, dispose)\n- ‚úÖ Managing lists, toggles, counters\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\n**Module 5: State Management!**\n\nsetState works great for simple apps. But what about:\n- Sharing data between screens?\n- Complex app state?\n- Better organization?\n\nNext module: **Provider, Riverpod, and professional state management**!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.4-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a contact form that shows/hides error messages. ---",
              "instructions": "Create a contact form that shows/hides error messages. ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Contact Form with Validation\n// Shows/hides error messages based on input validation\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ContactFormApp());\n}\n\nclass ContactFormApp extends StatelessWidget {\n  const ContactFormApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Contact Form')),\n        body: const ContactForm(),\n      ),\n    );\n  }\n}\n\nclass ContactForm extends StatefulWidget {\n  const ContactForm({super.key});\n\n  @override\n  State<ContactForm> createState() => _ContactFormState();\n}\n\nclass _ContactFormState extends State<ContactForm> {\n  final _formKey = GlobalKey<FormState>();\n  final _nameController = TextEditingController();\n  final _emailController = TextEditingController();\n  final _messageController = TextEditingController();\n\n  @override\n  void dispose() {\n    _nameController.dispose();\n    _emailController.dispose();\n    _messageController.dispose();\n    super.dispose();\n  }\n\n  String? _validateName(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Please enter your name';\n    }\n    if (value.length < 2) {\n      return 'Name must be at least 2 characters';\n    }\n    return null;\n  }\n\n  String? _validateEmail(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Please enter your email';\n    }\n    final emailRegex = RegExp(r'^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$');\n    if (!emailRegex.hasMatch(value)) {\n      return 'Please enter a valid email';\n    }\n    return null;\n  }\n\n  String? _validateMessage(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Please enter a message';\n    }\n    if (value.length < 10) {\n      return 'Message must be at least 10 characters';\n    }\n    return null;\n  }\n\n  void _submitForm() {\n    if (_formKey.currentState!.validate()) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(\n          content: Text('Form submitted successfully!'),\n          backgroundColor: Colors.green,\n        ),\n      );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SingleChildScrollView(\n      padding: const EdgeInsets.all(16),\n      child: Form(\n        key: _formKey,\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // Name field\n            TextFormField(\n              controller: _nameController,\n              decoration: const InputDecoration(\n                labelText: 'Name',\n                prefixIcon: Icon(Icons.person),\n                border: OutlineInputBorder(),\n              ),\n              validator: _validateName,\n              autovalidateMode: AutovalidateMode.onUserInteraction,\n            ),\n            const SizedBox(height: 16),\n            \n            // Email field\n            TextFormField(\n              controller: _emailController,\n              decoration: const InputDecoration(\n                labelText: 'Email',\n                prefixIcon: Icon(Icons.email),\n                border: OutlineInputBorder(),\n              ),\n              keyboardType: TextInputType.emailAddress,\n              validator: _validateEmail,\n              autovalidateMode: AutovalidateMode.onUserInteraction,\n            ),\n            const SizedBox(height: 16),\n            \n            // Message field\n            TextFormField(\n              controller: _messageController,\n              decoration: const InputDecoration(\n                labelText: 'Message',\n                prefixIcon: Icon(Icons.message),\n                border: OutlineInputBorder(),\n                alignLabelWithHint: true,\n              ),\n              maxLines: 4,\n              validator: _validateMessage,\n              autovalidateMode: AutovalidateMode.onUserInteraction,\n            ),\n            const SizedBox(height: 24),\n            \n            // Submit button\n            ElevatedButton(\n              onPressed: _submitForm,\n              style: ElevatedButton.styleFrom(\n                padding: const EdgeInsets.all(16),\n              ),\n              child: const Text('Submit'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - Form + GlobalKey: Manages form state\n// - TextFormField: Input with built-in validation\n// - validator: Returns error message or null\n// - autovalidateMode: When to show errors\n// - validate(): Checks all fields and shows errors",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "4.5",
          "title": "Module 4, Mini-Project: Interactive Notes App",
          "moduleId": "module-04",
          "order": 5,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\nBuild a complete **Notes App** with all Module 4 concepts:\n- ‚úÖ Buttons (FAB, IconButton, ElevatedButton)\n- ‚úÖ Forms and text input\n- ‚úÖ StatefulWidget and setState\n- ‚úÖ Gestures (swipe to delete, long press menu)\n\n**You'll build a real, production-quality app!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Features",
              "content": "\n1. **Add notes** with title and content\n2. **Edit existing notes**\n3. **Delete notes** with swipe gesture\n4. **Color-code notes**\n5. **Long press** for quick actions\n6. **Search notes**\n7. **Persistent state** (data survives app restart)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Features Walkthrough",
              "content": "\n### 1. Search Notes\n- Real-time filtering as you type\n- Searches both title and content\n\n### 2. Swipe to Delete\n- Swipe left on any note\n- Shows red delete background\n- Includes UNDO option\n\n### 3. Long Press Menu\n- Long press any note\n- Shows bottom sheet with options:\n  - Edit\n  - Change Color\n  - Share\n  - Delete\n\n### 4. Color Coding\n- 7 different colors\n- Visual organization\n- Tap to change\n\n### 5. Empty State\n- Beautiful placeholder when no notes\n- Clear call-to-action\n\n"
            },
            {
              "type": "THEORY",
              "title": "Enhancement Ideas",
              "content": "\nWant to make it even better? Add these:\n\n### 1. Persistent Storage\n\n### 2. Categories/Tags\nAdd a category field to Note model and filter by category.\n\n### 3. Voice Input\nUse speech_to_text package for voice notes.\n\n### 4. Rich Text Formatting\nBold, italic, bullet points using a rich text editor package.\n\n### 5. Pin Important Notes\nAdd a `isPinned` field and show pinned notes at top.\n\n",
              "code": "import 'package:shared_preferences/shared_preferences.dart';\n\nFuture<void> _saveNotes() async {\n  final prefs = await SharedPreferences.getInstance();\n  final notesJson = notes.map((n) => n.toJson()).toList();\n  await prefs.setString('notes', jsonEncode(notesJson));\n}\n\nFuture<void> _loadNotes() async {\n  final prefs = await SharedPreferences.getInstance();\n  final notesString = prefs.getString('notes');\n  if (notesString != null) {\n    final List<dynamic> notesJson = jsonDecode(notesString);\n    notes = notesJson.map((json) => Note.fromJson(json)).toList();\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nThis project combined EVERYTHING from Module 4:\n- ‚úÖ Multiple button types (FAB, IconButton)\n- ‚úÖ Text input with TextEditingController\n- ‚úÖ Forms and validation\n- ‚úÖ StatefulWidget with complex state\n- ‚úÖ Gestures (tap, long press, swipe)\n- ‚úÖ Navigation between screens\n- ‚úÖ Material Design components\n- ‚úÖ Real-world app architecture\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\n**Module 5: State Management**\n\nYour notes app works, but what if you want to:\n- Share data between screens more elegantly?\n- Separate business logic from UI?\n- Make state management scalable?\n\nNext module: **Provider, Riverpod, and professional state management patterns!**\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.5-challenge-0",
              "title": "Practice Challenge",
              "description": "Show total notes count, character count, and most recent update. ---",
              "instructions": "Show total notes count, character count, and most recent update. ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Notes App with Statistics\n// Displays note count, character count, and last update time\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const NotesApp());\n}\n\nclass NotesApp extends StatelessWidget {\n  const NotesApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Notes')),\n        body: const NotesScreen(),\n      ),\n    );\n  }\n}\n\nclass Note {\n  final String id;\n  final String title;\n  final String content;\n  final DateTime updatedAt;\n\n  Note({\n    required this.id,\n    required this.title,\n    required this.content,\n    required this.updatedAt,\n  });\n}\n\nclass NotesScreen extends StatefulWidget {\n  const NotesScreen({super.key});\n\n  @override\n  State<NotesScreen> createState() => _NotesScreenState();\n}\n\nclass _NotesScreenState extends State<NotesScreen> {\n  final List<Note> notes = [\n    Note(id: '1', title: 'Shopping List', content: 'Milk, eggs, bread, butter', updatedAt: DateTime.now().subtract(const Duration(hours: 2))),\n    Note(id: '2', title: 'Meeting Notes', content: 'Discuss Q4 goals and project timeline', updatedAt: DateTime.now().subtract(const Duration(days: 1))),\n    Note(id: '3', title: 'Ideas', content: 'Build a Flutter app with notes and todos', updatedAt: DateTime.now()),\n  ];\n\n  // Calculate statistics\n  int get totalNotes => notes.length;\n  \n  int get totalCharacters => notes.fold(0, (sum, note) => sum + note.title.length + note.content.length);\n  \n  String get mostRecentUpdate {\n    if (notes.isEmpty) return 'No notes';\n    final latest = notes.reduce((a, b) => a.updatedAt.isAfter(b.updatedAt) ? a : b);\n    final diff = DateTime.now().difference(latest.updatedAt);\n    if (diff.inMinutes < 1) return 'Just now';\n    if (diff.inHours < 1) return '${diff.inMinutes}m ago';\n    if (diff.inDays < 1) return '${diff.inHours}h ago';\n    return '${diff.inDays}d ago';\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // Statistics Card\n        Card(\n          margin: const EdgeInsets.all(16),\n          child: Padding(\n            padding: const EdgeInsets.all(16),\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: [\n                _buildStat('Notes', '$totalNotes', Icons.note),\n                _buildStat('Characters', '$totalCharacters', Icons.text_fields),\n                _buildStat('Updated', mostRecentUpdate, Icons.access_time),\n              ],\n            ),\n          ),\n        ),\n        \n        // Notes List\n        Expanded(\n          child: ListView.builder(\n            itemCount: notes.length,\n            itemBuilder: (context, index) {\n              final note = notes[index];\n              return ListTile(\n                title: Text(note.title),\n                subtitle: Text(\n                  note.content,\n                  maxLines: 1,\n                  overflow: TextOverflow.ellipsis,\n                ),\n                trailing: Text(\n                  _formatTime(note.updatedAt),\n                  style: TextStyle(color: Colors.grey.shade600, fontSize: 12),\n                ),\n              );\n            },\n          ),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildStat(String label, String value, IconData icon) {\n    return Column(\n      children: [\n        Icon(icon, color: Colors.blue),\n        const SizedBox(height: 4),\n        Text(value, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18)),\n        Text(label, style: TextStyle(color: Colors.grey.shade600, fontSize: 12)),\n      ],\n    );\n  }\n\n  String _formatTime(DateTime dt) {\n    return '${dt.hour}:${dt.minute.toString().padLeft(2, '0')}';\n  }\n}\n\n// Key concepts:\n// - Computed properties (getters) for statistics\n// - fold: Aggregate values across list\n// - reduce: Find max/min in list\n// - Duration: Calculate time differences\n// - DateTime: Work with dates and times",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-05",
      "title": "Module 5: Flutter Development",
      "description": "Learn Flutter development - Module 5",
      "difficulty": "beginner",
      "estimatedHours": 5,
      "lessons": [
        {
          "id": "5.1",
          "title": "Module 5, Lesson 1: Understanding State Management",
          "moduleId": "module-05",
          "order": 1,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The setState Limitation",
              "content": "\nsetState() works great for simple apps. But imagine:\n- Shopping cart visible on multiple screens\n- User profile needed everywhere\n- Theme that affects entire app\n\n**Passing data through many widgets = nightmare!**\n\nThis is called \"**prop drilling**\":\n\n\n**Solution**: **State Management** - making data available app-wide!\n\n",
              "code": "HomeScreen\n  ‚îî‚îÄ ProductList\n      ‚îî‚îÄ ProductCard\n          ‚îî‚îÄ AddToCartButton\n              // Need cart data from way up top!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What is State Management?",
              "content": "\n**Concept**: A central place to store and manage app data.\n\nThink of it like:\n- **setState**: Your wallet (keep money on you)\n- **State Management**: Your bank account (access from anywhere)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Popular Solutions",
              "content": "\n1. **Provider** - Flutter team's recommendation, simple\n2. **Riverpod** - Newer, more powerful\n3. **Bloc** - Enterprise apps\n4. **GetX** - All-in-one solution\n\n**We'll learn Provider (easiest to start)!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "When to Use State Management?",
              "content": "\n### Use setState when:\n- Data used in ONE widget\n- Simple toggles/counters\n- Temporary UI state\n\n### Use Provider when:\n- Data shared across multiple widgets\n- App-wide state (theme, auth)\n- Shopping carts, favorites, etc.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Provider Basics",
              "content": "\n**Step 1**: Add to `pubspec.yaml`:\n\n\nRun: `flutter pub get`\n\n**Step 2**: Create a model:\n\n\n**Step 3**: Provide it:\n\n\n**Step 4**: Consume it:\n\n\n",
              "code": "class CounterDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final counter = Provider.of<Counter>(context);\n    \n    return Text('${counter.count}');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou now understand state management basics! Next lessons cover:\n- Complex state patterns\n- Riverpod (modern alternative)\n- Best practices\n- Real-world patterns\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.1-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a todo app using Provider: 1. TodoModel with add/remove/toggle methods 2. Multiple screens showing same data 3. Persist count across screens ---",
              "instructions": "Create a todo app using Provider: 1. TodoModel with add/remove/toggle methods 2. Multiple screens showing same data 3. Persist count across screens ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Todo App with Provider\n// Shared state across multiple screens using ChangeNotifier\n// Note: Add provider package to pubspec.yaml\n\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => TodoModel(),\n      child: const TodoApp(),\n    ),\n  );\n}\n\n// Todo item model\nclass Todo {\n  final String id;\n  final String title;\n  bool isCompleted;\n\n  Todo({required this.id, required this.title, this.isCompleted = false});\n}\n\n// TodoModel with ChangeNotifier for state management\nclass TodoModel extends ChangeNotifier {\n  final List<Todo> _todos = [];\n\n  List<Todo> get todos => List.unmodifiable(_todos);\n  int get count => _todos.length;\n  int get completedCount => _todos.where((t) => t.isCompleted).length;\n\n  void add(String title) {\n    _todos.add(Todo(\n      id: DateTime.now().millisecondsSinceEpoch.toString(),\n      title: title,\n    ));\n    notifyListeners();\n  }\n\n  void remove(String id) {\n    _todos.removeWhere((t) => t.id == id);\n    notifyListeners();\n  }\n\n  void toggle(String id) {\n    final todo = _todos.firstWhere((t) => t.id == id);\n    todo.isCompleted = !todo.isCompleted;\n    notifyListeners();\n  }\n}\n\nclass TodoApp extends StatelessWidget {\n  const TodoApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: const TodoListScreen(),\n    );\n  }\n}\n\n// Screen 1: Todo List\nclass TodoListScreen extends StatelessWidget {\n  const TodoListScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Consumer<TodoModel>(\n          builder: (_, model, __) => Text('Todos (${model.count})'),\n        ),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.analytics),\n            onPressed: () => Navigator.push(\n              context,\n              MaterialPageRoute(builder: (_) => const StatsScreen()),\n            ),\n          ),\n        ],\n      ),\n      body: Consumer<TodoModel>(\n        builder: (_, model, __) {\n          if (model.todos.isEmpty) {\n            return const Center(child: Text('No todos yet!'));\n          }\n          return ListView.builder(\n            itemCount: model.todos.length,\n            itemBuilder: (_, index) {\n              final todo = model.todos[index];\n              return ListTile(\n                leading: Checkbox(\n                  value: todo.isCompleted,\n                  onChanged: (_) => model.toggle(todo.id),\n                ),\n                title: Text(\n                  todo.title,\n                  style: TextStyle(\n                    decoration: todo.isCompleted ? TextDecoration.lineThrough : null,\n                  ),\n                ),\n                trailing: IconButton(\n                  icon: const Icon(Icons.delete),\n                  onPressed: () => model.remove(todo.id),\n                ),\n              );\n            },\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => _showAddDialog(context),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n\n  void _showAddDialog(BuildContext context) {\n    final controller = TextEditingController();\n    showDialog(\n      context: context,\n      builder: (_) => AlertDialog(\n        title: const Text('Add Todo'),\n        content: TextField(controller: controller, autofocus: true),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(context),\n            child: const Text('Cancel'),\n          ),\n          TextButton(\n            onPressed: () {\n              if (controller.text.isNotEmpty) {\n                context.read<TodoModel>().add(controller.text);\n                Navigator.pop(context);\n              }\n            },\n            child: const Text('Add'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Screen 2: Stats (same data, different view)\nclass StatsScreen extends StatelessWidget {\n  const StatsScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Statistics')),\n      body: Consumer<TodoModel>(\n        builder: (_, model, __) => Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              Text('Total: ${model.count}', style: const TextStyle(fontSize: 24)),\n              Text('Completed: ${model.completedCount}', style: const TextStyle(fontSize: 24)),\n              Text('Pending: ${model.count - model.completedCount}', style: const TextStyle(fontSize: 24)),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - ChangeNotifier: Notifies listeners of state changes\n// - ChangeNotifierProvider: Provides model to widget tree\n// - Consumer: Rebuilds when model changes\n// - context.read: Access model without listening\n// - notifyListeners(): Triggers UI updates",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the dart syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.2",
          "title": "Module 5, Lesson 2: Provider Deep Dive",
          "moduleId": "module-05",
          "order": 2,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Beyond the Basics",
              "content": "\nYou learned Provider basics. Now let's master it with real-world patterns!\n\n**This lesson covers:**\n- Multiple providers\n- ProxyProvider (providers that depend on others)\n- FutureProvider & StreamProvider\n- Best practices and patterns\n\n"
            },
            {
              "type": "THEORY",
              "title": "Multiple Providers Pattern",
              "content": "\nReal apps need multiple state objects:\n\n\n",
              "code": "void main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => CartModel()),\n        ChangeNotifierProvider(create: (_) => UserModel()),\n        ChangeNotifierProvider(create: (_) => ThemeModel()),\n        ChangeNotifierProvider(create: (_) => NotificationModel()),\n      ],\n      child: MyApp(),\n    ),\n  );\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "FutureProvider for Async Data",
              "content": "\nLoad data once and provide it:\n\n\n",
              "code": "// providers/products_provider.dart\nFuture<List<Product>> fetchProducts() async {\n  await Future.delayed(Duration(seconds: 2));  // Simulate API call\n  return [\n    Product(id: '1', name: 'Laptop', price: 999.99, imageUrl: 'url1'),\n    Product(id: '2', name: 'Mouse', price: 29.99, imageUrl: 'url2'),\n  ];\n}\n\n// In main.dart\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        FutureProvider<List<Product>>(\n          create: (_) => fetchProducts(),\n          initialData: [],\n        ),\n        ChangeNotifierProvider(create: (_) => CartProvider()),\n      ],\n      child: MyApp(),\n    ),\n  );\n}\n\n// Usage in widget\nclass ProductList extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final products = context.watch<List<Product>>();\n\n    if (products.isEmpty) {\n      return Center(child: CircularProgressIndicator());\n    }\n\n    return ListView.builder(\n      itemCount: products.length,\n      itemBuilder: (context, index) => ProductCard(product: products[index]),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### 1. Keep Providers Focused\n‚ùå **Bad**: One giant provider for everything\n\n‚úÖ **Good**: Separate concerns\n\n### 2. Use listen: false for Actions\n\n### 3. Consumer for Partial Rebuilds\n\n",
              "code": "// Only rebuilds the Text, not entire Column\nColumn(\n  children: [\n    Text('Static text'),\n    Consumer<Counter>(\n      builder: (context, counter, child) {\n        return Text('${counter.count}');\n      },\n    ),\n    Text('More static text'),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ MultiProvider for multiple state objects\n- ‚úÖ FutureProvider for async data\n- ‚úÖ StreamProvider for real-time data\n- ‚úÖ ProxyProvider for dependent providers\n- ‚úÖ Production-ready shopping cart\n- ‚úÖ Best practices and patterns\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nProvider is powerful, but there's a newer, better way: **Riverpod**!\n\nNext lesson: **Introduction to Riverpod** - Provider's successor with compile-time safety!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.2-challenge-0",
              "title": "Practice Challenge",
              "description": "Build a complete e-commerce app with: 1. **ProductsProvider**: Manages product list 2. **CartProvider**: Shopping cart with add/remove/quantity 3. **FavoritesProvider**: Save favorite products 4. **AuthProvider**: Simple login/logout Screens: ---",
              "instructions": "Build a complete e-commerce app with: 1. **ProductsProvider**: Manages product list 2. **CartProvider**: Shopping cart with add/remove/quantity 3. **FavoritesProvider**: Save favorite products 4. **AuthProvider**: Simple login/logout Screens: ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: E-Commerce App with Multiple Providers\n// Note: Add provider package to pubspec.yaml\n\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => AuthProvider()),\n        ChangeNotifierProvider(create: (_) => ProductsProvider()),\n        ChangeNotifierProvider(create: (_) => CartProvider()),\n        ChangeNotifierProvider(create: (_) => FavoritesProvider()),\n      ],\n      child: const ECommerceApp(),\n    ),\n  );\n}\n\n// Product Model\nclass Product {\n  final String id;\n  final String name;\n  final double price;\n  final String image;\n\n  Product({required this.id, required this.name, required this.price, this.image = ''});\n}\n\n// 1. AuthProvider\nclass AuthProvider extends ChangeNotifier {\n  bool _isLoggedIn = false;\n  String _username = '';\n\n  bool get isLoggedIn => _isLoggedIn;\n  String get username => _username;\n\n  void login(String user) {\n    _isLoggedIn = true;\n    _username = user;\n    notifyListeners();\n  }\n\n  void logout() {\n    _isLoggedIn = false;\n    _username = '';\n    notifyListeners();\n  }\n}\n\n// 2. ProductsProvider\nclass ProductsProvider extends ChangeNotifier {\n  final List<Product> _products = [\n    Product(id: '1', name: 'Laptop', price: 999.99),\n    Product(id: '2', name: 'Phone', price: 599.99),\n    Product(id: '3', name: 'Headphones', price: 149.99),\n    Product(id: '4', name: 'Watch', price: 299.99),\n  ];\n\n  List<Product> get products => List.unmodifiable(_products);\n}\n\n// 3. CartProvider\nclass CartProvider extends ChangeNotifier {\n  final Map<String, int> _items = {}; // productId -> quantity\n\n  Map<String, int> get items => Map.unmodifiable(_items);\n  int get itemCount => _items.values.fold(0, (sum, qty) => sum + qty);\n\n  void add(String productId) {\n    _items[productId] = (_items[productId] ?? 0) + 1;\n    notifyListeners();\n  }\n\n  void remove(String productId) {\n    if (_items.containsKey(productId)) {\n      if (_items[productId]! > 1) {\n        _items[productId] = _items[productId]! - 1;\n      } else {\n        _items.remove(productId);\n      }\n      notifyListeners();\n    }\n  }\n\n  void clear() {\n    _items.clear();\n    notifyListeners();\n  }\n}\n\n// 4. FavoritesProvider\nclass FavoritesProvider extends ChangeNotifier {\n  final Set<String> _favorites = {};\n\n  Set<String> get favorites => Set.unmodifiable(_favorites);\n  bool isFavorite(String id) => _favorites.contains(id);\n\n  void toggle(String productId) {\n    if (_favorites.contains(productId)) {\n      _favorites.remove(productId);\n    } else {\n      _favorites.add(productId);\n    }\n    notifyListeners();\n  }\n}\n\nclass ECommerceApp extends StatelessWidget {\n  const ECommerceApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: const ProductListScreen(),\n    );\n  }\n}\n\nclass ProductListScreen extends StatelessWidget {\n  const ProductListScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final products = context.watch<ProductsProvider>().products;\n    final cart = context.watch<CartProvider>();\n    final favorites = context.watch<FavoritesProvider>();\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Shop'),\n        actions: [\n          Stack(\n            children: [\n              IconButton(\n                icon: const Icon(Icons.shopping_cart),\n                onPressed: () {},\n              ),\n              if (cart.itemCount > 0)\n                Positioned(\n                  right: 0,\n                  child: CircleAvatar(\n                    radius: 10,\n                    backgroundColor: Colors.red,\n                    child: Text('${cart.itemCount}', style: const TextStyle(fontSize: 12)),\n                  ),\n                ),\n            ],\n          ),\n        ],\n      ),\n      body: ListView.builder(\n        itemCount: products.length,\n        itemBuilder: (_, index) {\n          final product = products[index];\n          return ListTile(\n            title: Text(product.name),\n            subtitle: Text('\\$${product.price}'),\n            trailing: Row(\n              mainAxisSize: MainAxisSize.min,\n              children: [\n                IconButton(\n                  icon: Icon(\n                    favorites.isFavorite(product.id) ? Icons.favorite : Icons.favorite_border,\n                    color: favorites.isFavorite(product.id) ? Colors.red : null,\n                  ),\n                  onPressed: () => favorites.toggle(product.id),\n                ),\n                IconButton(\n                  icon: const Icon(Icons.add_shopping_cart),\n                  onPressed: () => cart.add(product.id),\n                ),\n              ],\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - MultiProvider: Multiple providers in one place\n// - Separate providers for different concerns\n// - context.watch: Listen and rebuild\n// - context.read: Access without listening\n// - Unmodifiable collections for immutability",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.3",
          "title": "Module 5, Lesson 3: Introduction to Riverpod",
          "moduleId": "module-05",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Riverpod?",
              "content": "\nProvider is great, but has limitations:\n- Runtime errors (easy to forget providers)\n- Hard to test\n- Context required everywhere\n- No compile-time safety\n\n**Riverpod solves all of these!**\n\nThink of it as \"Provider 2.0\" - same author, better design.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Advantages",
              "content": "\n1. **No BuildContext needed** - access state from anywhere\n2. **Compile-time safe** - errors caught before runtime\n3. **Easy testing** - no widget tree needed\n4. **Better performance** - automatic disposal\n5. **DevTools integration** - amazing debugging\n\n"
            },
            {
              "type": "THEORY",
              "title": "Installation",
              "content": "\n\nRun: `flutter pub get`\n\n",
              "code": "# pubspec.yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_riverpod: ^2.5.1",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Setup Difference",
              "content": "\n**Provider:**\n\n**Riverpod:**\n\n**Much cleaner!** One `ProviderScope` at the root, done.\n\n",
              "code": "void main() {\n  runApp(\n    ProviderScope(  // One wrapper for ALL providers!\n      child: MyApp(),\n    ),\n  );\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Riverpod Provider",
              "content": "\n\n**Key difference**: Providers are global constants, not widget tree dependencies.\n\n",
              "code": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Define provider OUTSIDE the widget tree\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\n// Now ANY widget can access it!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Reading State",
              "content": "\n**Provider way:**\n\n**Riverpod way:**\n\n",
              "code": "class CounterDisplay extends ConsumerWidget {  // Note: ConsumerWidget\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {  // Note: WidgetRef\n    final count = ref.watch(counterProvider);\n    return Text('$count');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Provider Types in Riverpod",
              "content": "\n### 1. StateProvider (Simple Values)\n\n\n### 2. StateNotifierProvider (Complex State)\n\n\n### 3. FutureProvider (Async Data)\n\n\n### 4. StreamProvider (Real-Time Data)\n\n\n",
              "code": "// Real-time updates\nfinal messagesProvider = StreamProvider<List<Message>>((ref) {\n  return FirebaseFirestore.instance\n      .collection('messages')\n      .snapshots()\n      .map((snapshot) => snapshot.docs.map((doc) => Message.fromDoc(doc)).toList());\n});\n\n// Usage\nfinal messagesAsync = ref.watch(messagesProvider);\n\nmessagesAsync.when(\n  data: (messages) => ListView.builder(\n    itemCount: messages.length,\n    itemBuilder: (context, index) => MessageTile(messages[index]),\n  ),\n  loading: () => CircularProgressIndicator(),\n  error: (error, stack) => Text('Error: $error'),\n);",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Differences: Provider vs Riverpod",
              "content": "\n| Feature | Provider | Riverpod |\n|---------|----------|----------|\n| **Setup** | Wrap with providers | One ProviderScope |\n| **Context** | Required | Not required |\n| **Widget Type** | StatelessWidget | ConsumerWidget |\n| **Read State** | `context.watch()` | `ref.watch()` |\n| **Update State** | `context.read()` | `ref.read()` |\n| **Safety** | Runtime errors | Compile-time safe |\n| **Testing** | Need widget tree | Direct access |\n| **Provider Location** | Widget tree | Global constants |\n\n"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Forgetting ProviderScope\n\n‚úÖ **Fix**: Always wrap with ProviderScope\n\n‚ùå **Mistake 2**: Using StatelessWidget instead of ConsumerWidget\n\n‚úÖ **Fix**: Use ConsumerWidget\n\n",
              "code": "class MyWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Text('$count');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Riverpod setup with ProviderScope\n- ‚úÖ ConsumerWidget for accessing state\n- ‚úÖ StateProvider for simple values\n- ‚úÖ StateNotifierProvider for complex state\n- ‚úÖ FutureProvider and StreamProvider\n- ‚úÖ Computed providers\n- ‚úÖ ref.watch vs ref.read vs ref.listen\n- ‚úÖ Complete todo app with filtering\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've learned Riverpod basics! Next: **Advanced Riverpod patterns** - family modifiers, autoDispose, combining providers, and more!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.3-challenge-0",
              "title": "Practice Challenge",
              "description": "Convert the Provider shopping cart from Lesson 2 to Riverpod: 1. Use StateNotifierProvider for cart 2. FutureProvider for products 3. Computed provider for totals 4. Filter provider for categories ---",
              "instructions": "Convert the Provider shopping cart from Lesson 2 to Riverpod: 1. Use StateNotifierProvider for cart 2. FutureProvider for products 3. Computed provider for totals 4. Filter provider for categories ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Shopping Cart with Riverpod\n// Note: Add flutter_riverpod package to pubspec.yaml\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  runApp(const ProviderScope(child: ShoppingApp()));\n}\n\n// Product Model\nclass Product {\n  final String id;\n  final String name;\n  final double price;\n  final String category;\n\n  Product({required this.id, required this.name, required this.price, required this.category});\n}\n\n// Cart Item Model\nclass CartItem {\n  final Product product;\n  final int quantity;\n\n  CartItem({required this.product, this.quantity = 1});\n\n  CartItem copyWith({int? quantity}) => CartItem(product: product, quantity: quantity ?? this.quantity);\n}\n\n// 1. FutureProvider for products (simulates API call)\nfinal productsProvider = FutureProvider<List<Product>>((ref) async {\n  await Future.delayed(const Duration(seconds: 1));\n  return [\n    Product(id: '1', name: 'Laptop', price: 999.99, category: 'Electronics'),\n    Product(id: '2', name: 'Phone', price: 599.99, category: 'Electronics'),\n    Product(id: '3', name: 'Shirt', price: 29.99, category: 'Clothing'),\n    Product(id: '4', name: 'Pants', price: 49.99, category: 'Clothing'),\n  ];\n});\n\n// 2. StateNotifierProvider for cart\nclass CartNotifier extends StateNotifier<List<CartItem>> {\n  CartNotifier() : super([]);\n\n  void add(Product product) {\n    final index = state.indexWhere((item) => item.product.id == product.id);\n    if (index >= 0) {\n      state = [\n        ...state.sublist(0, index),\n        state[index].copyWith(quantity: state[index].quantity + 1),\n        ...state.sublist(index + 1),\n      ];\n    } else {\n      state = [...state, CartItem(product: product)];\n    }\n  }\n\n  void remove(String productId) {\n    state = state.where((item) => item.product.id != productId).toList();\n  }\n\n  void clear() => state = [];\n}\n\nfinal cartProvider = StateNotifierProvider<CartNotifier, List<CartItem>>((ref) => CartNotifier());\n\n// 3. Computed provider for totals\nfinal cartTotalProvider = Provider<double>((ref) {\n  final cart = ref.watch(cartProvider);\n  return cart.fold(0, (sum, item) => sum + (item.product.price * item.quantity));\n});\n\nfinal cartCountProvider = Provider<int>((ref) {\n  final cart = ref.watch(cartProvider);\n  return cart.fold(0, (sum, item) => sum + item.quantity);\n});\n\n// 4. Filter provider for categories\nfinal selectedCategoryProvider = StateProvider<String?>((ref) => null);\n\nfinal filteredProductsProvider = Provider<AsyncValue<List<Product>>>((ref) {\n  final productsAsync = ref.watch(productsProvider);\n  final selectedCategory = ref.watch(selectedCategoryProvider);\n  \n  return productsAsync.whenData((products) {\n    if (selectedCategory == null) return products;\n    return products.where((p) => p.category == selectedCategory).toList();\n  });\n});\n\nclass ShoppingApp extends StatelessWidget {\n  const ShoppingApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(home: const ShoppingScreen());\n  }\n}\n\nclass ShoppingScreen extends ConsumerWidget {\n  const ShoppingScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final productsAsync = ref.watch(filteredProductsProvider);\n    final cartCount = ref.watch(cartCountProvider);\n    final total = ref.watch(cartTotalProvider);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Shop - Total: \\$${total.toStringAsFixed(2)}'),\n        actions: [\n          Badge(\n            label: Text('$cartCount'),\n            child: IconButton(icon: const Icon(Icons.shopping_cart), onPressed: () {}),\n          ),\n        ],\n      ),\n      body: productsAsync.when(\n        loading: () => const Center(child: CircularProgressIndicator()),\n        error: (err, _) => Center(child: Text('Error: $err')),\n        data: (products) => ListView.builder(\n          itemCount: products.length,\n          itemBuilder: (_, index) {\n            final product = products[index];\n            return ListTile(\n              title: Text(product.name),\n              subtitle: Text('\\$${product.price} - ${product.category}'),\n              trailing: IconButton(\n                icon: const Icon(Icons.add_shopping_cart),\n                onPressed: () => ref.read(cartProvider.notifier).add(product),\n              ),\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - ProviderScope: Root for all providers\n// - FutureProvider: Async data loading\n// - StateNotifierProvider: Complex state with methods\n// - Provider: Computed/derived values\n// - StateProvider: Simple reactive state\n// - ref.watch: Listen to changes\n// - ref.read: One-time access for actions",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.4",
          "title": "Module 5, Lesson 4: Advanced Riverpod Patterns",
          "moduleId": "module-05",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Beyond the Basics",
              "content": "\nYou know Riverpod fundamentals. Now let's master advanced patterns for production apps!\n\n**This lesson covers:**\n- Family modifiers (parameterized providers)\n- AutoDispose for memory management\n- Combining providers\n- AsyncValue handling\n- Code generation (Riverpod 2.0+)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Family Modifier - Parameterized Providers",
              "content": "\n**Problem**: You need a provider for EACH user/post/item\n\n**Solution**: `.family` modifier!\n\n\n",
              "code": "// Without family - need separate provider for each user\nfinal user1Provider = FutureProvider<User>((ref) => fetchUser('1'));\nfinal user2Provider = FutureProvider<User>((ref) => fetchUser('2'));\n// This doesn't scale!\n\n// With family - ONE provider, multiple instances\nfinal userProvider = FutureProvider.family<User, String>((ref, userId) async {\n  final response = await http.get('https://api.example.com/users/$userId');\n  return User.fromJson(jsonDecode(response.body));\n});\n\n// Usage\nclass UserProfile extends ConsumerWidget {\n  final String userId;\n\n  UserProfile({required this.userId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userProvider(userId));  // Pass parameter!\n\n    return userAsync.when(\n      data: (user) => Text(user.name),\n      loading: () => CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}\n\n// Different parameters = different instances\nUserProfile(userId: '1'),  // Fetches user 1\nUserProfile(userId: '2'),  // Fetches user 2",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "AutoDispose - Automatic Cleanup",
              "content": "\n**Problem**: Providers stay in memory even when not used\n\n**Solution**: `.autoDispose` modifier!\n\n\n**When to use:**\n- ‚úÖ Data that's screen-specific\n- ‚úÖ Temporary states\n- ‚úÖ API calls for detail views\n\n**When NOT to use:**\n- ‚ùå Global app state (theme, auth)\n- ‚ùå Data shared across app\n- ‚ùå Expensive computations you want to cache\n\n",
              "code": "// Without autoDispose - stays in memory forever\nfinal userProvider = FutureProvider<User>((ref) => fetchUser());\n\n// With autoDispose - disposed when no longer watched\nfinal userProvider = FutureProvider.autoDispose<User>((ref) => fetchUser());",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Keeping Alive When Needed",
              "content": "\nSometimes you want autoDispose but with exceptions:\n\n\n",
              "code": "final cacheProvider = FutureProvider.autoDispose.family<Data, String>((ref, id) async {\n  // Keep alive for 5 minutes even if no one is watching\n  final keepAlive = ref.keepAlive();\n\n  Timer(Duration(minutes: 5), () {\n    keepAlive.close();  // Now it can be disposed\n  });\n\n  return await fetchData(id);\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Combining Providers",
              "content": "\nProviders can watch OTHER providers!\n\n\n",
              "code": "// User authentication\nfinal authProvider = StateProvider<String?>((ref) => null);\n\n// User profile (depends on auth)\nfinal userProfileProvider = FutureProvider<UserProfile?>((ref) async {\n  final userId = ref.watch(authProvider);\n\n  if (userId == null) return null;\n\n  final response = await http.get('https://api.example.com/profile/$userId');\n  return UserProfile.fromJson(jsonDecode(response.body));\n});\n\n// User posts (depends on auth)\nfinal userPostsProvider = FutureProvider<List<Post>>((ref) async {\n  final userId = ref.watch(authProvider);\n\n  if (userId == null) return [];\n\n  final response = await http.get('https://api.example.com/users/$userId/posts');\n  return (jsonDecode(response.body) as List)\n      .map((json) => Post.fromJson(json))\n      .toList();\n});\n\n// When authProvider changes, both userProfileProvider and userPostsProvider\n// automatically refetch!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "AsyncValue - Handling Loading/Error/Data",
              "content": "\nWhen working with async providers, use `.when()`:\n\n\n",
              "code": "final dataAsync = ref.watch(dataProvider);\n\n// Option 1: when (rebuild for all states)\ndataAsync.when(\n  data: (data) => Text('Data: $data'),\n  loading: () => CircularProgressIndicator(),\n  error: (error, stack) => Text('Error: $error'),\n);\n\n// Option 2: maybeWhen (default for unhandled states)\ndataAsync.maybeWhen(\n  data: (data) => Text('Data: $data'),\n  orElse: () => Text('Loading or error'),\n);\n\n// Option 3: map (more control)\ndataAsync.map(\n  data: (data) => Text('Success: ${data.value}'),\n  loading: (_) => CircularProgressIndicator(),\n  error: (error) => Text('Error: ${error.error}'),\n);\n\n// Option 4: Direct access (careful!)\nif (dataAsync.hasValue) {\n  final data = dataAsync.value!;\n  return Text('$data');\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Code Generation (Riverpod 2.0+)",
              "content": "\nModern Riverpod uses annotations and code generation:\n\n\n**Benefits:**\n- Type-safe\n- Less boilerplate\n- Better autocomplete\n- Compile-time errors\n\n**Setup:**\n\nRun: `flutter pub run build_runner watch`\n\n",
              "code": "dev_dependencies:\n  build_runner: ^2.4.0\n  riverpod_generator: ^2.4.0",
              "language": "yaml"
            },
            {
              "type": "KEY_POINT",
              "title": "Best Practices Summary",
              "content": "\n### 1. Use autoDispose for Screen-Specific Data\n\n### 2. Combine Providers for Derived State\n\n### 3. Use ref.listen for Side Effects\n\n### 4. Family for Parameterized Providers\n\n",
              "code": "final itemProvider = Provider.family<Item, String>((ref, itemId) {\n  final items = ref.watch(itemsProvider);\n  return items.firstWhere((item) => item.id == itemId);\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Patterns",
              "content": "\n### Pattern 1: Search with Debounce\n\n### Pattern 2: Pagination\n\n",
              "code": "final pageProvider = StateProvider<int>((ref) => 1);\n\nfinal itemsProvider = FutureProvider<List<Item>>((ref) async {\n  final page = ref.watch(pageProvider);\n  return fetchItems(page);\n});\n\n// Load more\nref.read(pageProvider.notifier).state++;",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Family modifier for parameterized providers\n- ‚úÖ AutoDispose for automatic cleanup\n- ‚úÖ Combining providers for derived state\n- ‚úÖ AsyncValue handling with when/map\n- ‚úÖ Refreshing and invalidating providers\n- ‚úÖ Code generation (modern approach)\n- ‚úÖ Real-world patterns (search, pagination, auth)\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've mastered Riverpod! Next: **State Management Best Practices** - architecture patterns, testing, and choosing the right solution for your app!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.4-challenge-0",
              "title": "Practice Challenge",
              "description": "Build a social media feed with: 1. **Auth provider** - User login state 2. **Posts provider (.family)** - Fetch posts by user 3. **Comments provider (.family + .autoDispose)** - Comments per post 4. **Like provider (.family)** - Like status per post 5. **Combined provider** - Feed with liked posts highlighted Features: ---",
              "instructions": "Build a social media feed with: 1. **Auth provider** - User login state 2. **Posts provider (.family)** - Fetch posts by user 3. **Comments provider (.family + .autoDispose)** - Comments per post 4. **Like provider (.family)** - Like status per post 5. **Combined provider** - Feed with liked posts highlighted Features: ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Social Media Feed with Riverpod\n// Advanced provider patterns with .family and .autoDispose\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  runApp(const ProviderScope(child: SocialApp()));\n}\n\n// Models\nclass User {\n  final String id;\n  final String name;\n  User({required this.id, required this.name});\n}\n\nclass Post {\n  final String id;\n  final String userId;\n  final String content;\n  final DateTime createdAt;\n  Post({required this.id, required this.userId, required this.content, required this.createdAt});\n}\n\nclass Comment {\n  final String id;\n  final String postId;\n  final String text;\n  Comment({required this.id, required this.postId, required this.text});\n}\n\n// 1. Auth Provider\nclass AuthNotifier extends StateNotifier<User?> {\n  AuthNotifier() : super(null);\n  \n  void login(String name) => state = User(id: '1', name: name);\n  void logout() => state = null;\n}\n\nfinal authProvider = StateNotifierProvider<AuthNotifier, User?>((ref) => AuthNotifier());\n\n// 2. Posts Provider with .family (parameterized)\nfinal postsProvider = FutureProvider.family<List<Post>, String>((ref, userId) async {\n  await Future.delayed(const Duration(milliseconds: 500));\n  return [\n    Post(id: '1', userId: userId, content: 'Hello Flutter!', createdAt: DateTime.now()),\n    Post(id: '2', userId: userId, content: 'Riverpod is amazing!', createdAt: DateTime.now()),\n  ];\n});\n\n// 3. Comments Provider with .family + .autoDispose\nfinal commentsProvider = FutureProvider.autoDispose.family<List<Comment>, String>((ref, postId) async {\n  await Future.delayed(const Duration(milliseconds: 300));\n  return [\n    Comment(id: '1', postId: postId, text: 'Great post!'),\n    Comment(id: '2', postId: postId, text: 'Thanks for sharing!'),\n  ];\n});\n\n// 4. Like Provider with .family\nclass LikeNotifier extends StateNotifier<Set<String>> {\n  LikeNotifier() : super({});\n  \n  void toggle(String postId) {\n    if (state.contains(postId)) {\n      state = {...state}..remove(postId);\n    } else {\n      state = {...state, postId};\n    }\n  }\n  \n  bool isLiked(String postId) => state.contains(postId);\n}\n\nfinal likesProvider = StateNotifierProvider<LikeNotifier, Set<String>>((ref) => LikeNotifier());\n\n// 5. Combined Provider - Feed with like status\nclass FeedItem {\n  final Post post;\n  final bool isLiked;\n  FeedItem({required this.post, required this.isLiked});\n}\n\nfinal feedProvider = Provider.family<AsyncValue<List<FeedItem>>, String>((ref, userId) {\n  final postsAsync = ref.watch(postsProvider(userId));\n  final likes = ref.watch(likesProvider);\n  \n  return postsAsync.whenData((posts) {\n    return posts.map((post) => FeedItem(\n      post: post,\n      isLiked: likes.contains(post.id),\n    )).toList();\n  });\n});\n\nclass SocialApp extends StatelessWidget {\n  const SocialApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(home: const FeedScreen());\n  }\n}\n\nclass FeedScreen extends ConsumerWidget {\n  const FeedScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final user = ref.watch(authProvider);\n    \n    if (user == null) {\n      return Scaffold(\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () => ref.read(authProvider.notifier).login('Demo User'),\n            child: const Text('Login'),\n          ),\n        ),\n      );\n    }\n    \n    final feedAsync = ref.watch(feedProvider(user.id));\n    \n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Feed - ${user.name}'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.logout),\n            onPressed: () => ref.read(authProvider.notifier).logout(),\n          ),\n        ],\n      ),\n      body: feedAsync.when(\n        loading: () => const Center(child: CircularProgressIndicator()),\n        error: (e, _) => Center(child: Text('Error: $e')),\n        data: (items) => ListView.builder(\n          itemCount: items.length,\n          itemBuilder: (_, index) {\n            final item = items[index];\n            return Card(\n              margin: const EdgeInsets.all(8),\n              child: ListTile(\n                title: Text(item.post.content),\n                trailing: IconButton(\n                  icon: Icon(\n                    item.isLiked ? Icons.favorite : Icons.favorite_border,\n                    color: item.isLiked ? Colors.red : null,\n                  ),\n                  onPressed: () => ref.read(likesProvider.notifier).toggle(item.post.id),\n                ),\n              ),\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - .family: Parameterized providers\n// - .autoDispose: Auto-cleanup when not watched\n// - Combined providers: Derive state from multiple sources\n// - StateNotifier with Set: Efficient membership tracking",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.5",
          "title": "Module 5, Lesson 5: State Management Best Practices",
          "moduleId": "module-05",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Big Picture",
              "content": "\nYou've learned setState, Provider, and Riverpod. But which one should you use? **It depends!**\n\nThis lesson covers:\n- When to use each approach\n- Architecture patterns\n- Common pitfalls\n- Testing strategies\n- Real-world decision making\n\n"
            },
            {
              "type": "THEORY",
              "title": "The State Management Ladder",
              "content": "\nThink of state management as a ladder - climb as high as you need:\n\n### Level 1: setState (Local State)\n**Use for:**\n- Single widget state\n- UI-only state (toggles, animations)\n- Temporary state\n\n**Example:** Expanding/collapsing a card, show/hide password\n\n\n‚úÖ **Perfect for this!** State doesn't need to be shared.\n\n",
              "code": "class ExpandableCard extends StatefulWidget {\n  @override\n  _ExpandableCardState createState() => _ExpandableCardState();\n}\n\nclass _ExpandableCardState extends State<ExpandableCard> {\n  bool isExpanded = false;  // Local to this widget only\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      child: Column(\n        children: [\n          ListTile(\n            title: Text('Title'),\n            trailing: IconButton(\n              icon: Icon(isExpanded ? Icons.expand_less : Icons.expand_more),\n              onPressed: () {\n                setState(() {\n                  isExpanded = !isExpanded;\n                });\n              },\n            ),\n          ),\n          if (isExpanded) Text('Expanded content'),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Level 2: InheritedWidget (Prop Drilling Solution)\n**Use for:**\n- Passing data down the tree\n- Avoiding constructor parameters through many levels\n\n**Flutter's built-in examples:**\n- `Theme.of(context)`\n- `MediaQuery.of(context)`\n- `Navigator.of(context)`\n\n‚ùå **You probably won't create these manually** - Provider/Riverpod do this for you!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Level 3: Provider (Shared State)\n**Use for:**\n- State shared across multiple screens\n- Shopping cart, favorites, user preferences\n- Medium-sized apps\n- When you need ChangeNotifier patterns\n\n\n‚úÖ **Great for:** Medium apps, teams familiar with Provider, gradual migration\n\n",
              "code": "class CartProvider with ChangeNotifier {\n  List<Item> _items = [];\n\n  void addItem(Item item) {\n    _items.add(item);\n    notifyListeners();\n  }\n}\n\n// Access anywhere in the app\nfinal cart = context.watch<CartProvider>();",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Level 4: Riverpod (Modern State Management)\n**Use for:**\n- Large apps with complex state\n- Apps requiring testability\n- When you want compile-time safety\n- New projects (best modern choice)\n\n\n‚úÖ **Great for:** New apps, large codebases, teams wanting best practices\n\n",
              "code": "final cartProvider = StateNotifierProvider<CartNotifier, List<Item>>((ref) {\n  return CartNotifier();\n});\n\n// Access from anywhere, no context needed\nfinal cart = ref.watch(cartProvider);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Level 5: BLoC (Business Logic Component)\n**Use for:**\n- Enterprise apps\n- Strict separation of business logic and UI\n- Complex event-driven flows\n- When required by company standards\n\n\n‚úÖ **Great for:** Large enterprise apps, teams with BLoC experience, event-driven architecture\n\n",
              "code": "class CartBloc extends Bloc<CartEvent, CartState> {\n  CartBloc() : super(CartInitial()) {\n    on<AddToCart>(_onAddToCart);\n  }\n\n  void _onAddToCart(AddToCart event, Emitter<CartState> emit) {\n    emit(CartUpdated(items: [...state.items, event.item]));\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Real-World Examples",
              "content": "\n### Example 1: E-Commerce App\n\n**Problem:** Shopping cart, user auth, product catalog, favorites\n\n**Solution:**\n\n**Why Riverpod?**\n- Multiple state objects that interact\n- Need testability\n- FutureProvider for async data\n- Clean separation of concerns\n\n",
              "code": "// Riverpod approach\nfinal authProvider = StateNotifierProvider<AuthNotifier, AuthState>(...);\nfinal cartProvider = StateNotifierProvider<CartNotifier, CartState>(...);\nfinal productsProvider = FutureProvider<List<Product>>(...);\nfinal favoritesProvider = StateNotifierProvider<FavoritesNotifier, Set<String>>(...);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Example 2: Todo App\n\n**Problem:** List of todos, filtering, persistence\n\n**Solution (Small app):**\n\n**Why Provider?**\n- Simple app with one main state object\n- Quick to set up\n- Easy to understand for beginners\n\n",
              "code": "// Provider approach\nclass TodoProvider with ChangeNotifier {\n  List<Todo> _todos = [];\n  TodoFilter _filter = TodoFilter.all;\n\n  List<Todo> get filteredTodos { /* ... */ }\n\n  void addTodo(Todo todo) {\n    _todos.add(todo);\n    notifyListeners();\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Example 3: Social Media Feed\n\n**Problem:** Posts, comments, likes, users, real-time updates\n\n**Solution:**\n\n**Why Riverpod?**\n- Real-time data with StreamProvider\n- Parameterized providers with .family\n- Complex dependencies between providers\n- Automatic disposal with .autoDispose\n\n",
              "code": "// Riverpod with StreamProvider\nfinal postsStreamProvider = StreamProvider<List<Post>>((ref) {\n  return FirebaseFirestore.instance\n      .collection('posts')\n      .snapshots()\n      .map((snapshot) => /* parse */);\n});\n\nfinal commentsProvider = StreamProvider.family<List<Comment>, String>((ref, postId) {\n  return FirebaseFirestore.instance\n      .collection('posts')\n      .doc(postId)\n      .collection('comments')\n      .snapshots()\n      .map((snapshot) => /* parse */);\n});\n\nfinal likesProvider = StateNotifierProvider.family<LikesNotifier, bool, String>((ref, postId) {\n  return LikesNotifier(postId);\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Architecture Patterns",
              "content": "\n### Pattern 1: MVVM (Model-View-ViewModel)\n\n**Model**: Data classes\n\n**View**: UI widgets\n\n**ViewModel**: Business logic (Provider/Riverpod)\n\n",
              "code": "final userViewModelProvider = FutureProvider<User>((ref) async {\n  final userId = ref.watch(authProvider);\n  return await fetchUser(userId);\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Pattern 2: Repository Pattern\n\nSeparate data sources from business logic:\n\n\n**Benefits:**\n- Easy to swap data sources (API ‚Üí local DB)\n- Testable (mock repository)\n- Clean separation\n\n",
              "code": "// Data layer\nclass UserRepository {\n  Future<User> getUser(String id) async {\n    final response = await http.get('api.example.com/users/$id');\n    return User.fromJson(jsonDecode(response.body));\n  }\n\n  Future<void> updateUser(User user) async {\n    await http.put('api.example.com/users/${user.id}', body: user.toJson());\n  }\n}\n\n// Providers\nfinal userRepositoryProvider = Provider<UserRepository>((ref) {\n  return UserRepository();\n});\n\nfinal userProvider = FutureProvider.family<User, String>((ref, userId) async {\n  final repository = ref.read(userRepositoryProvider);\n  return await repository.getUser(userId);\n});\n\n// UI\nclass UserWidget extends ConsumerWidget {\n  final String userId;\n\n  UserWidget({required this.userId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userProvider(userId));\n    return userAsync.when(\n      data: (user) => Text(user.name),\n      loading: () => CircularProgressIndicator(),\n      error: (err, stack) => Text('Error: $err'),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "\n### Pitfall 1: Over-Engineering\n\n‚ùå **Bad**: Using Riverpod for a simple counter\n\n‚úÖ **Good**: Just use setState!\n\n**Rule**: Use the simplest solution that works!\n\n",
              "code": "class Counter extends StatefulWidget {\n  @override\n  _CounterState createState() => _CounterState();\n}\n\nclass _CounterState extends State<Counter> {\n  int count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text('$count'),\n        ElevatedButton(\n          onPressed: () => setState(() => count++),\n          child: Text('Increment'),\n        ),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Pitfall 2: Not Using Computed State\n\n‚ùå **Bad**: Duplicating state logic everywhere\n\n‚úÖ **Good**: Create a computed provider\n\n",
              "code": "final cartTotalProvider = Provider<double>((ref) {\n  final cart = ref.watch(cartProvider);\n  return cart.items.fold(0.0, (sum, item) => sum + item.price * item.quantity);\n});\n\n// Usage\nfinal total = ref.watch(cartTotalProvider);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Pitfall 3: Storing UI State in Global Provider\n\n‚ùå **Bad**: Storing temporary UI state globally\n\n‚úÖ **Good**: Use local state\n\n**Rule**: Global state for global data, local state for local UI!\n\n",
              "code": "class MyWidget extends StatefulWidget {\n  @override\n  _MyWidgetState createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  bool isMenuOpen = false;\n\n  @override\n  Widget build(BuildContext context) {\n    // Menu state is local to this widget\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Testing State Management",
              "content": "\n### Testing setState\n\n### Testing Riverpod\n\n**Riverpod advantage**: No widget tree needed for tests!\n\n",
              "code": "test('Cart adds items correctly', () {\n  final container = ProviderContainer();\n  addTearDown(container.dispose);\n\n  final cartNotifier = container.read(cartProvider.notifier);\n\n  cartNotifier.addItem(Item(name: 'Laptop', price: 999));\n\n  expect(container.read(cartProvider).length, 1);\n  expect(container.read(cartTotalProvider), 999);\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Performance Tips",
              "content": "\n### 1. Use Consumer Wisely\n\n### 2. Select Specific Fields\n\n",
              "code": "// Bad: Rebuilds when ANY cart field changes\nfinal cart = ref.watch(cartProvider);\n\n// Good: Only rebuilds when item count changes\nfinal itemCount = ref.watch(cartProvider.select((cart) => cart.items.length));",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Migration Strategy",
              "content": "\n### Moving from setState to Provider\n\n**Step 1**: Identify shared state\n\n**Step 2**: Wrap app with provider\n\n**Step 3**: Replace setState calls\n\n",
              "code": "// Before\nsetState(() {\n  items.add(item);\n});\n\n// After\ncontext.read<CartProvider>().addItem(item);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Choosing Your Stack",
              "content": "\n### For Learning:\n- Start with **setState**\n- Move to **Provider** when you need shared state\n- Learn **Riverpod** for modern practices\n\n### For Small Projects (< 20 screens):\n- **setState** + occasional Provider\n\n### For Medium Projects (20-50 screens):\n- **Provider** or **Riverpod**\n\n### For Large Projects (50+ screens):\n- **Riverpod** (recommended)\n- **BLoC** (if team has experience)\n\n### For Enterprise:\n- **BLoC** (common in enterprise)\n- **Riverpod** (modern choice)\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ When to use each state management approach\n- ‚úÖ Decision tree for choosing solutions\n- ‚úÖ Architecture patterns (MVVM, Repository)\n- ‚úÖ Common pitfalls and how to avoid them\n- ‚úÖ Testing strategies\n- ‚úÖ Performance optimization\n- ‚úÖ Migration strategies\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nTheory is great, but practice is better! Next: **Module 5 Mini-Project** - Build a complete app using modern state management with all the patterns you've learned!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.5-challenge-0",
              "title": "Practice Challenge",
              "description": "Take your Notes App from Module 4 and: 1. Identify which state is local vs global 2. Refactor global state to Riverpod 3. Keep local UI state in setState 4. Add computed providers for derived state 5. Write tests for business logic ---",
              "instructions": "Take your Notes App from Module 4 and: 1. Identify which state is local vs global 2. Refactor global state to Riverpod 3. Keep local UI state in setState 4. Add computed providers for derived state 5. Write tests for business logic ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Notes App with Proper State Separation\n// Global state in Riverpod, local UI state in setState\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  runApp(const ProviderScope(child: NotesApp()));\n}\n\n// Note Model\nclass Note {\n  final String id;\n  final String title;\n  final String content;\n  final DateTime updatedAt;\n\n  Note({required this.id, required this.title, required this.content, required this.updatedAt});\n\n  Note copyWith({String? title, String? content, DateTime? updatedAt}) => Note(\n    id: id,\n    title: title ?? this.title,\n    content: content ?? this.content,\n    updatedAt: updatedAt ?? this.updatedAt,\n  );\n}\n\n// GLOBAL STATE: Notes collection (shared across screens)\nclass NotesNotifier extends StateNotifier<List<Note>> {\n  NotesNotifier() : super([]);\n\n  void add(String title, String content) {\n    state = [...state, Note(\n      id: DateTime.now().millisecondsSinceEpoch.toString(),\n      title: title,\n      content: content,\n      updatedAt: DateTime.now(),\n    )];\n  }\n\n  void update(String id, String title, String content) {\n    state = state.map((note) {\n      if (note.id == id) {\n        return note.copyWith(title: title, content: content, updatedAt: DateTime.now());\n      }\n      return note;\n    }).toList();\n  }\n\n  void delete(String id) {\n    state = state.where((note) => note.id != id).toList();\n  }\n}\n\nfinal notesProvider = StateNotifierProvider<NotesNotifier, List<Note>>((ref) => NotesNotifier());\n\n// COMPUTED STATE: Derived values\nfinal noteCountProvider = Provider<int>((ref) => ref.watch(notesProvider).length);\n\nfinal totalCharactersProvider = Provider<int>((ref) {\n  final notes = ref.watch(notesProvider);\n  return notes.fold(0, (sum, note) => sum + note.title.length + note.content.length);\n});\n\nfinal sortedNotesProvider = Provider<List<Note>>((ref) {\n  final notes = ref.watch(notesProvider);\n  return [...notes]..sort((a, b) => b.updatedAt.compareTo(a.updatedAt));\n});\n\nclass NotesApp extends StatelessWidget {\n  const NotesApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(home: const NotesListScreen());\n  }\n}\n\nclass NotesListScreen extends ConsumerWidget {\n  const NotesListScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final notes = ref.watch(sortedNotesProvider);\n    final count = ref.watch(noteCountProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: Text('Notes ($count)')),\n      body: notes.isEmpty\n          ? const Center(child: Text('No notes yet'))\n          : ListView.builder(\n              itemCount: notes.length,\n              itemBuilder: (_, index) {\n                final note = notes[index];\n                return ListTile(\n                  title: Text(note.title),\n                  subtitle: Text(note.content, maxLines: 1, overflow: TextOverflow.ellipsis),\n                  onTap: () => Navigator.push(\n                    context,\n                    MaterialPageRoute(builder: (_) => NoteEditScreen(note: note)),\n                  ),\n                  trailing: IconButton(\n                    icon: const Icon(Icons.delete),\n                    onPressed: () => ref.read(notesProvider.notifier).delete(note.id),\n                  ),\n                );\n              },\n            ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => Navigator.push(\n          context,\n          MaterialPageRoute(builder: (_) => const NoteEditScreen()),\n        ),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n// LOCAL UI STATE: Form inputs (only needed in this screen)\nclass NoteEditScreen extends ConsumerStatefulWidget {\n  final Note? note;\n  const NoteEditScreen({super.key, this.note});\n\n  @override\n  ConsumerState<NoteEditScreen> createState() => _NoteEditScreenState();\n}\n\nclass _NoteEditScreenState extends ConsumerState<NoteEditScreen> {\n  // LOCAL STATE: Form controllers, validation state\n  late final TextEditingController _titleController;\n  late final TextEditingController _contentController;\n  bool _isValid = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _titleController = TextEditingController(text: widget.note?.title ?? '');\n    _contentController = TextEditingController(text: widget.note?.content ?? '');\n    _validateForm();\n  }\n\n  void _validateForm() {\n    setState(() {\n      _isValid = _titleController.text.isNotEmpty;\n    });\n  }\n\n  void _save() {\n    final notifier = ref.read(notesProvider.notifier);\n    if (widget.note != null) {\n      notifier.update(widget.note!.id, _titleController.text, _contentController.text);\n    } else {\n      notifier.add(_titleController.text, _contentController.text);\n    }\n    Navigator.pop(context);\n  }\n\n  @override\n  void dispose() {\n    _titleController.dispose();\n    _contentController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.note != null ? 'Edit Note' : 'New Note'),\n        actions: [\n          IconButton(\n            onPressed: _isValid ? _save : null,\n            icon: const Icon(Icons.save),\n          ),\n        ],\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          children: [\n            TextField(\n              controller: _titleController,\n              decoration: const InputDecoration(labelText: 'Title'),\n              onChanged: (_) => _validateForm(),\n            ),\n            const SizedBox(height: 16),\n            Expanded(\n              child: TextField(\n                controller: _contentController,\n                decoration: const InputDecoration(labelText: 'Content'),\n                maxLines: null,\n                expands: true,\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - Global state (notes list): Riverpod StateNotifierProvider\n// - Local UI state (form inputs): StatefulWidget + setState\n// - Computed state: Provider watching other providers\n// - ConsumerStatefulWidget: Combines Riverpod + local state",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.6",
          "title": "Module 5, Mini-Project: Task Management App with Riverpod",
          "moduleId": "module-05",
          "order": 6,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\nBuild a **complete task management app** with Riverpod that demonstrates:\n- ‚úÖ Multiple providers with dependencies\n- ‚úÖ Family and autoDispose modifiers\n- ‚úÖ Repository pattern\n- ‚úÖ Computed state\n- ‚úÖ AsyncValue handling\n- ‚úÖ Real-world architecture\n\n**Features:**\n- User authentication\n- Multiple projects\n- Tasks with categories\n- Filtering and sorting\n- Statistics dashboard\n- Pull to refresh\n- Offline support\n\n"
            },
            {
              "type": "THEORY",
              "title": "Step 5: Home Screen (Project List)",
              "content": "\n\nDue to length, I'll create a separate continuation message with the remaining screens...\n\n",
              "code": "// lib/screens/home_screen.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport '../providers/auth_provider.dart';\nimport '../providers/projects_provider.dart';\nimport '../models/project.dart';\nimport '../repositories/task_repository.dart';\nimport 'project_detail_screen.dart';\nimport 'login_screen.dart';\n\nclass HomeScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final projectsAsync = ref.watch(projectsProvider);\n    final authAsync = ref.watch(authStateProvider);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Projects'),\n        actions: [\n          authAsync.whenData((user) {\n            return user != null\n                ? IconButton(\n                    icon: Icon(Icons.logout),\n                    onPressed: () async {\n                      await ref.read(authStateProvider.notifier).logout();\n                      Navigator.pushReplacement(\n                        context,\n                        MaterialPageRoute(builder: (_) => LoginScreen()),\n                      );\n                    },\n                  )\n                : SizedBox.shrink();\n          }).value ?? SizedBox.shrink(),\n        ],\n      ),\n      body: projectsAsync.when(\n        data: (projects) {\n          if (projects.isEmpty) {\n            return Center(\n              child: Text('No projects yet. Tap + to create one!'),\n            );\n          }\n\n          return RefreshIndicator(\n            onRefresh: () async {\n              ref.invalidate(projectsProvider);\n            },\n            child: ListView.builder(\n              itemCount: projects.length,\n              itemBuilder: (context, index) {\n                final project = projects[index];\n                return ProjectCard(project: project);\n              },\n            ),\n          );\n        },\n        loading: () => Center(child: CircularProgressIndicator()),\n        error: (err, stack) => Center(child: Text('Error: $err')),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => _showCreateProjectDialog(context, ref),\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n\n  void _showCreateProjectDialog(BuildContext context, WidgetRef ref) {\n    final nameController = TextEditingController();\n    final descController = TextEditingController();\n\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: Text('New Project'),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            TextField(\n              controller: nameController,\n              decoration: InputDecoration(labelText: 'Project Name'),\n            ),\n            SizedBox(height: 8),\n            TextField(\n              controller: descController,\n              decoration: InputDecoration(labelText: 'Description'),\n              maxLines: 3,\n            ),\n          ],\n        ),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(context),\n            child: Text('Cancel'),\n          ),\n          ElevatedButton(\n            onPressed: () async {\n              final authAsync = ref.read(authStateProvider);\n              final user = authAsync.value;\n\n              if (user != null && nameController.text.isNotEmpty) {\n                final project = Project(\n                  id: 'proj_${DateTime.now().millisecondsSinceEpoch}',\n                  name: nameController.text,\n                  description: descController.text,\n                  userId: user.id,\n                  createdAt: DateTime.now(),\n                );\n\n                await ref.read(taskRepositoryProvider).createProject(project);\n                ref.invalidate(projectsProvider);\n\n                Navigator.pop(context);\n              }\n            },\n            child: Text('Create'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass ProjectCard extends ConsumerWidget {\n  final Project project;\n\n  ProjectCard({required this.project});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final statsAsync = ref.watch(projectStatsProvider(project.id));\n\n    return Card(\n      margin: EdgeInsets.symmetric(horizontal: 16, vertical: 8),\n      child: InkWell(\n        onTap: () {\n          Navigator.push(\n            context,\n            MaterialPageRoute(\n              builder: (_) => ProjectDetailScreen(projectId: project.id),\n            ),\n          );\n        },\n        child: Padding(\n          padding: EdgeInsets.all(16),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              Row(\n                mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                children: [\n                  Expanded(\n                    child: Text(\n                      project.name,\n                      style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n                    ),\n                  ),\n                  statsAsync.when(\n                    data: (stats) => Container(\n                      padding: EdgeInsets.symmetric(horizontal: 12, vertical: 6),\n                      decoration: BoxDecoration(\n                        color: Colors.blue,\n                        borderRadius: BorderRadius.circular(20),\n                      ),\n                      child: Text(\n                        '${stats['done']}/${stats['total']}',\n                        style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),\n                      ),\n                    ),\n                    loading: () => SizedBox(\n                      width: 20,\n                      height: 20,\n                      child: CircularProgressIndicator(strokeWidth: 2),\n                    ),\n                    error: (_, __) => SizedBox.shrink(),\n                  ),\n                ],\n              ),\n              SizedBox(height: 8),\n              Text(\n                project.description,\n                style: TextStyle(color: Colors.grey[600]),\n                maxLines: 2,\n                overflow: TextOverflow.ellipsis,\n              ),\n              SizedBox(height: 12),\n              statsAsync.when(\n                data: (stats) => Row(\n                  children: [\n                    _StatChip(label: 'To Do', count: stats['todo'] ?? 0, color: Colors.grey),\n                    SizedBox(width: 8),\n                    _StatChip(label: 'In Progress', count: stats['inProgress'] ?? 0, color: Colors.orange),\n                    SizedBox(width: 8),\n                    _StatChip(label: 'Done', count: stats['done'] ?? 0, color: Colors.green),\n                  ],\n                ),\n                loading: () => SizedBox.shrink(),\n                error: (_, __) => SizedBox.shrink(),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass _StatChip extends StatelessWidget {\n  final String label;\n  final int count;\n  final Color color;\n\n  _StatChip({required this.label, required this.count, required this.color});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),\n      decoration: BoxDecoration(\n        color: color.withOpacity(0.1),\n        borderRadius: BorderRadius.circular(8),\n        border: Border.all(color: color),\n      ),\n      child: Text(\n        '$label: $count',\n        style: TextStyle(fontSize: 12, color: color, fontWeight: FontWeight.bold),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What This Project Teaches",
              "content": "\n**Riverpod Concepts:**\n- ‚úÖ StateNotifierProvider for auth\n- ‚úÖ FutureProvider for async data\n- ‚úÖ .family for parameterized providers\n- ‚úÖ .autoDispose for memory management\n- ‚úÖ Computed providers (stats, filtering)\n- ‚úÖ Provider dependencies (auth ‚Üí projects ‚Üí tasks)\n- ‚úÖ ref.listen for navigation\n- ‚úÖ ref.invalidate for refreshing\n\n**Architecture:**\n- ‚úÖ Repository pattern\n- ‚úÖ Clean separation of concerns\n- ‚úÖ Model-Provider-View layers\n- ‚úÖ Reusable widgets\n\n**Flutter Features:**\n- ‚úÖ Navigation\n- ‚úÖ Forms and validation\n- ‚úÖ Pull to refresh\n- ‚úÖ Dialogs\n- ‚úÖ Lists and cards\n\n"
            },
            {
              "type": "THEORY",
              "title": "Enhancement Ideas",
              "content": "\n1. **Persistence**: Add SharedPreferences or SQLite\n2. **Search**: Add task search functionality\n3. **Calendar View**: Show tasks by due date\n4. **Notifications**: Remind about due tasks\n5. **Collaboration**: Share projects with other users\n6. **Themes**: Dark mode support\n7. **Analytics**: Charts showing progress over time\n\n"
            },
            {
              "type": "THEORY",
              "title": "Success Condition",
              "content": "\nBuild this app and you've mastered:\n- ‚úÖ Complex Riverpod patterns\n- ‚úÖ Production-ready architecture\n- ‚úÖ State management best practices\n- ‚úÖ Real-world Flutter development\n\n**Congratulations! You're ready for Module 6: Navigation & Routing!** üéâ\n\n"
            }
          ],
          "challenges": []
        }
      ]
    },
    {
      "id": "module-06",
      "title": "Module 6: Flutter Development",
      "description": "Learn Flutter development - Module 6",
      "difficulty": "intermediate",
      "estimatedHours": 8,
      "lessons": [
        {
          "id": "6.1",
          "title": "Module 6, Lesson 1: Basic Navigation",
          "moduleId": "module-06",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Multi-Screen Problem",
              "content": "\nSo far, all your apps have been single-screen. But real apps need **multiple screens**:\n- Home ‚Üí Detail ‚Üí Settings\n- Login ‚Üí Dashboard ‚Üí Profile\n- List ‚Üí Edit ‚Üí Confirm\n\n**How do you move between screens in Flutter?**\n\n**Navigator** is the answer!\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Think of Navigation as a Stack of Cards",
              "content": "\nImagine a deck of cards:\n- **Push**: Add a card on top (new screen covers current)\n- **Pop**: Remove top card (go back to previous screen)\n\n\nThis is called a **navigation stack**!\n\n",
              "code": "[Home Screen]\n[Home Screen] ‚Üí Push ‚Üí [Home Screen, Detail Screen]\n[Home Screen, Detail Screen] ‚Üí Pop ‚Üí [Home Screen]",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Understanding Navigator.push",
              "content": "\n\n**MaterialPageRoute** creates a platform-specific transition:\n- **iOS**: Slide from right\n- **Android**: Slide up\n\n",
              "code": "Navigator.push(\n  context,                                      // Where we are\n  MaterialPageRoute(builder: (context) => DetailScreen()),  // Where we're going\n);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Understanding Navigator.pop",
              "content": "\n\nRemoves the top screen from the stack and returns to the previous one.\n\n**Automatic back button**: Android phones and iOS get a back arrow automatically! You only need `Navigator.pop()` for custom buttons.\n\n",
              "code": "Navigator.pop(context);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Passing Data to New Screen",
              "content": "\nPass data via constructor:\n\n\n",
              "code": "class DetailScreen extends StatelessWidget {\n  final String title;\n  final int id;\n\n  DetailScreen({required this.title, required this.id});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text(title)),\n      body: Center(\n        child: Text('Item ID: $id', style: TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}\n\n// Navigate with data\nElevatedButton(\n  onPressed: () {\n    Navigator.push(\n      context,\n      MaterialPageRoute(\n        builder: (context) => DetailScreen(\n          title: 'Product Detail',\n          id: 42,\n        ),\n      ),\n    );\n  },\n  child: Text('View Product'),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Receiving Data Back from Screen",
              "content": "\nUse `await` with `Navigator.push`:\n\n\n**Pattern**: `Navigator.pop(context, dataToReturn)`\n\n",
              "code": "// Screen 1: Get result from Screen 2\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Home')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () async {\n            // Wait for result\n            final result = await Navigator.push(\n              context,\n              MaterialPageRoute(builder: (context) => SelectColorScreen()),\n            );\n\n            if (result != null) {\n              ScaffoldMessenger.of(context).showSnackBar(\n                SnackBar(content: Text('Selected: $result')),\n              );\n            }\n          },\n          child: Text('Select Color'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 2: Return result\nclass SelectColorScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Select Color')),\n      body: Column(\n        children: [\n          ListTile(\n            leading: CircleAvatar(backgroundColor: Colors.red),\n            title: Text('Red'),\n            onTap: () {\n              Navigator.pop(context, 'Red');  // Return data!\n            },\n          ),\n          ListTile(\n            leading: CircleAvatar(backgroundColor: Colors.blue),\n            title: Text('Blue'),\n            onTap: () {\n              Navigator.pop(context, 'Blue');\n            },\n          ),\n          ListTile(\n            leading: CircleAvatar(backgroundColor: Colors.green),\n            title: Text('Green'),\n            onTap: () {\n              Navigator.pop(context, 'Green');\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Custom Page Transitions",
              "content": "\nChange how screens transition:\n\n\n",
              "code": "// Fade transition\nNavigator.push(\n  context,\n  PageRouteBuilder(\n    pageBuilder: (context, animation, secondaryAnimation) => DetailScreen(),\n    transitionsBuilder: (context, animation, secondaryAnimation, child) {\n      return FadeTransition(\n        opacity: animation,\n        child: child,\n      );\n    },\n  ),\n);\n\n// Scale transition\nNavigator.push(\n  context,\n  PageRouteBuilder(\n    pageBuilder: (context, animation, secondaryAnimation) => DetailScreen(),\n    transitionsBuilder: (context, animation, secondaryAnimation, child) {\n      return ScaleTransition(\n        scale: animation,\n        child: child,\n      );\n    },\n  ),\n);\n\n// Slide from bottom\nNavigator.push(\n  context,\n  PageRouteBuilder(\n    pageBuilder: (context, animation, secondaryAnimation) => DetailScreen(),\n    transitionsBuilder: (context, animation, secondaryAnimation, child) {\n      const begin = Offset(0.0, 1.0);\n      const end = Offset.zero;\n      final tween = Tween(begin: begin, end: end);\n      final offsetAnimation = animation.drive(tween);\n\n      return SlideTransition(\n        position: offsetAnimation,\n        child: child,\n      );\n    },\n  ),\n);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Replacing Current Screen",
              "content": "\n\n**Use case**: Login ‚Üí Home (don't want back button to go to login)\n\n",
              "code": "// Go to new screen and remove current from stack\nNavigator.pushReplacement(\n  context,\n  MaterialPageRoute(builder: (context) => HomeScreen()),\n);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Removing All Previous Screens",
              "content": "\n\n**Use case**: Logout ‚Üí Login (clear all app screens)\n\n",
              "code": "// Clear entire stack and go to new screen\nNavigator.pushAndRemoveUntil(\n  context,\n  MaterialPageRoute(builder: (context) => HomeScreen()),\n  (route) => false,  // Remove all previous routes\n);",
              "language": "dart"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Forgetting `context`\n\n‚úÖ **Fix**: Always pass context\n\n‚ùå **Mistake 2**: Not using `await` when expecting result\n\n‚úÖ **Fix**: Use await\n\n",
              "code": "final result = await Navigator.push(context, MaterialPageRoute(...));",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Navigator as a stack of screens\n- ‚úÖ Navigator.push to go forward\n- ‚úÖ Navigator.pop to go back\n- ‚úÖ Passing data TO screens (constructor)\n- ‚úÖ Receiving data FROM screens (await + pop)\n- ‚úÖ Custom page transitions\n- ‚úÖ pushReplacement and pushAndRemoveUntil\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nBasic navigation works, but gets messy for large apps. Next: **Named Routes** - organize navigation with string identifiers!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.1-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a screen that slides in from the left instead of right. ---",
              "instructions": "Create a screen that slides in from the left instead of right. ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Custom Page Transition - Slide from Left\n// Uses PageRouteBuilder with custom SlideTransition\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const TransitionApp());\n}\n\nclass TransitionApp extends StatelessWidget {\n  const TransitionApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: const HomeScreen(),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.push(\n              context,\n              SlideFromLeftRoute(page: const DetailScreen()),\n            );\n          },\n          child: const Text('Open Detail (Slide from Left)'),\n        ),\n      ),\n    );\n  }\n}\n\nclass DetailScreen extends StatelessWidget {\n  const DetailScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Detail')),\n      body: const Center(\n        child: Text('This screen slid in from the left!'),\n      ),\n    );\n  }\n}\n\n// Custom route that slides from left\nclass SlideFromLeftRoute extends PageRouteBuilder {\n  final Widget page;\n\n  SlideFromLeftRoute({required this.page})\n      : super(\n          pageBuilder: (context, animation, secondaryAnimation) => page,\n          transitionsBuilder: (context, animation, secondaryAnimation, child) {\n            // Slide from left: start at -1.0 (off-screen left), end at 0.0 (center)\n            const begin = Offset(-1.0, 0.0);\n            const end = Offset.zero;\n            const curve = Curves.easeInOut;\n\n            final tween = Tween(begin: begin, end: end).chain(\n              CurveTween(curve: curve),\n            );\n\n            return SlideTransition(\n              position: animation.drive(tween),\n              child: child,\n            );\n          },\n          transitionDuration: const Duration(milliseconds: 300),\n        );\n}\n\n// Alternative: Reusable function\nRoute slideFromLeftRoute(Widget page) {\n  return PageRouteBuilder(\n    pageBuilder: (_, __, ___) => page,\n    transitionsBuilder: (_, animation, __, child) {\n      return SlideTransition(\n        position: Tween<Offset>(\n          begin: const Offset(-1.0, 0.0),\n          end: Offset.zero,\n        ).animate(CurvedAnimation(\n          parent: animation,\n          curve: Curves.easeInOut,\n        )),\n        child: child,\n      );\n    },\n  );\n}\n\n// Key concepts:\n// - PageRouteBuilder: Custom route with transitions\n// - SlideTransition: Animates position with Offset\n// - Offset(-1.0, 0): Left of screen\n// - Offset(1.0, 0): Right of screen\n// - Offset(0, -1.0): Top of screen\n// - Tween + CurveTween: Smooth animation curve",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.2",
          "title": "Module 6, Lesson 2: Named Routes",
          "moduleId": "module-06",
          "order": 2,
          "estimatedMinutes": 55,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Problem with Basic Navigation",
              "content": "\nWith basic navigation, you write this EVERYWHERE:\n\n\n**Problems:**\n- Repetitive code\n- Hard to change transitions\n- No central route management\n- Typos cause runtime errors\n\n**Solution: Named Routes!**\n\n",
              "code": "Navigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => ProductDetail(product: product)),\n);\n\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => UserProfile(userId: userId)),\n);\n\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SettingsScreen()),\n);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What are Named Routes?",
              "content": "\nInstead of creating MaterialPageRoute everywhere, define routes with string names:\n\n\nThen navigate with strings:\n\n\n",
              "code": "Navigator.pushNamed(context, '/detail');\nNavigator.pushNamed(context, '/profile');",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Passing Arguments",
              "content": "\n### Method 1: Via Navigator\n\n\n### Method 2: Type-Safe Arguments\n\n\n**Much safer!** Type errors caught at compile time.\n\n",
              "code": "// Define argument class\nclass ProductDetailArguments {\n  final int productId;\n  final String name;\n\n  ProductDetailArguments({required this.productId, required this.name});\n}\n\n// Navigate\nNavigator.pushNamed(\n  context,\n  '/detail',\n  arguments: ProductDetailArguments(productId: 123, name: 'Laptop'),\n);\n\n// Receive\nclass DetailScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final args = ModalRoute.of(context)!.settings.arguments as ProductDetailArguments;\n\n    return Scaffold(\n      appBar: AppBar(title: Text(args.name)),\n      body: Center(child: Text('Product ID: ${args.productId}')),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "onGenerateRoute (Advanced)",
              "content": "\nFor dynamic routes or custom logic:\n\n\n",
              "code": "MaterialApp(\n  onGenerateRoute: (settings) {\n    // Handle /product/:id\n    if (settings.name?.startsWith('/product/') == true) {\n      final productId = settings.name!.split('/').last;\n\n      return MaterialPageRoute(\n        builder: (context) => ProductDetailScreen(productId: productId),\n      );\n    }\n\n    // Handle /user/:username\n    if (settings.name?.startsWith('/user/') == true) {\n      final username = settings.name!.split('/').last;\n\n      return MaterialPageRoute(\n        builder: (context) => UserProfileScreen(username: username),\n      );\n    }\n\n    // Default route\n    return MaterialPageRoute(builder: (context) => HomeScreen());\n  },\n);\n\n// Navigate\nNavigator.pushNamed(context, '/product/123');\nNavigator.pushNamed(context, '/user/john_doe');",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "onUnknownRoute (404 Handler)",
              "content": "\nHandle invalid routes gracefully:\n\n\n",
              "code": "MaterialApp(\n  routes: {\n    '/': (context) => HomeScreen(),\n    '/about': (context) => AboutScreen(),\n  },\n  onUnknownRoute: (settings) {\n    return MaterialPageRoute(\n      builder: (context) => NotFoundScreen(routeName: settings.name),\n    );\n  },\n);\n\nclass NotFoundScreen extends StatelessWidget {\n  final String? routeName;\n\n  NotFoundScreen({this.routeName});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('404')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(Icons.error_outline, size: 100, color: Colors.red),\n            SizedBox(height: 16),\n            Text('Page Not Found', style: TextStyle(fontSize: 24)),\n            if (routeName != null)\n              Text('Route: $routeName', style: TextStyle(color: Colors.grey)),\n            SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: () => Navigator.pushNamedAndRemoveUntil(context, '/', (route) => false),\n              child: Text('Go Home'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Route Constants (Best Practice)",
              "content": "\nAvoid typos with constants:\n\n\n**Benefits:**\n- Autocomplete works\n- Refactoring is easy\n- Typos caught at compile time\n\n",
              "code": "// routes.dart\nclass AppRoutes {\n  static const String home = '/';\n  static const String products = '/products';\n  static const String productDetail = '/product-detail';\n  static const String cart = '/cart';\n  static const String checkout = '/checkout';\n  static const String profile = '/profile';\n  static const String settings = '/settings';\n}\n\n// main.dart\nMaterialApp(\n  routes: {\n    AppRoutes.home: (context) => HomeScreen(),\n    AppRoutes.products: (context) => ProductsScreen(),\n    AppRoutes.productDetail: (context) => ProductDetailScreen(),\n    AppRoutes.cart: (context) => CartScreen(),\n    AppRoutes.checkout: (context) => CheckoutScreen(),\n  },\n);\n\n// Usage\nNavigator.pushNamed(context, AppRoutes.productDetail);\nNavigator.pushNamed(context, AppRoutes.cart);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Named Routes vs Basic Navigation",
              "content": "\n| Feature | Basic Navigation | Named Routes |\n|---------|------------------|--------------|\n| **Setup** | None | Define routes upfront |\n| **Navigate** | `Navigator.push(MaterialPageRoute(...))` | `Navigator.pushNamed('/route')` |\n| **Arguments** | Constructor params | `arguments` parameter |\n| **Type Safety** | ‚úì Compile-time | Runtime (unless using constants) |\n| **Centralized** | ‚úó No | ‚úì Yes |\n| **Best For** | Small apps | Medium-large apps |\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Named routes for organized navigation\n- ‚úÖ Setting up routes in MaterialApp\n- ‚úÖ pushNamed, pushReplacementNamed, pushNamedAndRemoveUntil\n- ‚úÖ Passing arguments with named routes\n- ‚úÖ Type-safe argument classes\n- ‚úÖ onGenerateRoute for dynamic routes\n- ‚úÖ onUnknownRoute for 404 handling\n- ‚úÖ Route constants for safety\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nNamed routes are great, but there's an even more powerful way: **Navigation 2.0 (Router API)** - declarative navigation with deep linking support!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.2-challenge-0",
              "title": "Practice Challenge",
              "description": "Use onGenerateRoute to handle /post/:id and /category/:slug ---",
              "instructions": "Use onGenerateRoute to handle /post/:id and /category/:slug ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Dynamic Routes with onGenerateRoute\n// Handles /post/:id and /category/:slug patterns\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const DynamicRoutesApp());\n}\n\nclass DynamicRoutesApp extends StatelessWidget {\n  const DynamicRoutesApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      initialRoute: '/',\n      onGenerateRoute: (settings) {\n        final uri = Uri.parse(settings.name ?? '/');\n        final pathSegments = uri.pathSegments;\n\n        // Home route\n        if (pathSegments.isEmpty) {\n          return MaterialPageRoute(builder: (_) => const HomeScreen());\n        }\n\n        // /post/:id route\n        if (pathSegments.length == 2 && pathSegments[0] == 'post') {\n          final postId = pathSegments[1];\n          return MaterialPageRoute(\n            builder: (_) => PostScreen(postId: postId),\n            settings: settings,\n          );\n        }\n\n        // /category/:slug route\n        if (pathSegments.length == 2 && pathSegments[0] == 'category') {\n          final slug = pathSegments[1];\n          return MaterialPageRoute(\n            builder: (_) => CategoryScreen(slug: slug),\n            settings: settings,\n          );\n        }\n\n        // 404 - Not Found\n        return MaterialPageRoute(\n          builder: (_) => const NotFoundScreen(),\n        );\n      },\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            ElevatedButton(\n              onPressed: () => Navigator.pushNamed(context, '/post/123'),\n              child: const Text('View Post 123'),\n            ),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              onPressed: () => Navigator.pushNamed(context, '/post/456'),\n              child: const Text('View Post 456'),\n            ),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              onPressed: () => Navigator.pushNamed(context, '/category/flutter'),\n              child: const Text('Flutter Category'),\n            ),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              onPressed: () => Navigator.pushNamed(context, '/category/dart'),\n              child: const Text('Dart Category'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass PostScreen extends StatelessWidget {\n  final String postId;\n  const PostScreen({super.key, required this.postId});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Post $postId')),\n      body: Center(\n        child: Text('Viewing post with ID: $postId', style: const TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}\n\nclass CategoryScreen extends StatelessWidget {\n  final String slug;\n  const CategoryScreen({super.key, required this.slug});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Category: $slug')),\n      body: Center(\n        child: Text('Viewing category: $slug', style: const TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}\n\nclass NotFoundScreen extends StatelessWidget {\n  const NotFoundScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('404')),\n      body: const Center(\n        child: Text('Page Not Found', style: TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - onGenerateRoute: Handles dynamic route matching\n// - Uri.parse: Parses route path into segments\n// - pathSegments: Array of path parts\n// - Pattern matching: Check path structure\n// - Fallback: 404 screen for unknown routes",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.3",
          "title": "Module 6, Lesson 3: Modern Navigation with GoRouter",
          "moduleId": "module-06",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Evolution of Navigation",
              "content": "\nYou've learned two navigation approaches:\n1. **Basic Navigation**: `Navigator.push(MaterialPageRoute(...))`\n2. **Named Routes**: `Navigator.pushNamed('/route')`\n\nBoth work, but they're **imperative** - you tell Flutter exactly what to do, step by step.\n\n**Problem with imperative navigation:**\n- Hard to handle deep links (`myapp://product/123`)\n- Hard to sync URL bar on web\n- Hard to manage complex navigation state\n- Difficult to test\n\n**Solution: Declarative Navigation with GoRouter!**\n\nThink of it like building with LEGO blocks:\n- **Imperative**: \"Take this block, put it here, now take that block...\"\n- **Declarative**: \"Here's the blueprint, you build it!\"\n\n"
            },
            {
              "type": "THEORY",
              "title": "What is GoRouter?",
              "content": "\n**GoRouter** is Flutter's official modern routing solution:\n- Built on Navigation 2.0 API\n- URL-based navigation\n- Deep linking support out of the box\n- Type-safe routes\n- Web-friendly (URL bar works!)\n- Maintained by Flutter team\n\n**Current version**: 17.0.0 (Flutter 3.29+, Dart 3.7+)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Installation",
              "content": "\n\nRun: `flutter pub get`\n\n",
              "code": "# pubspec.yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  go_router: ^17.0.0",
              "language": "yaml"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First GoRouter",
              "content": "\n\n**Key differences:**\n- Use `MaterialApp.router` instead of `MaterialApp`\n- Pass `routerConfig` instead of `routes`\n- Navigate with `context.go('/path')` instead of `Navigator.pushNamed`\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:go_router/go_router.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  // Define router\n  final GoRouter _router = GoRouter(\n    routes: [\n      GoRoute(\n        path: '/',\n        builder: (context, state) => HomeScreen(),\n      ),\n      GoRoute(\n        path: '/details',\n        builder: (context, state) => DetailsScreen(),\n      ),\n    ],\n  );\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      routerConfig: _router,  // Use router config!\n      title: 'GoRouter Demo',\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Home')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate with go()\n            context.go('/details');\n          },\n          child: Text('Go to Details'),\n        ),\n      ),\n    );\n  }\n}\n\nclass DetailsScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Details')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Go back\n            context.go('/');\n          },\n          child: Text('Back to Home'),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Path Parameters (Dynamic Routes)",
              "content": "\nHandle URLs like `/user/123` or `/product/456`:\n\n\n",
              "code": "final router = GoRouter(\n  routes: [\n    GoRoute(\n      path: '/',\n      builder: (context, state) => HomeScreen(),\n    ),\n    GoRoute(\n      path: '/user/:userId',  // :userId is a path parameter\n      builder: (context, state) {\n        final userId = state.pathParameters['userId']!;\n        return UserScreen(userId: userId);\n      },\n    ),\n    GoRoute(\n      path: '/product/:productId',\n      builder: (context, state) {\n        final productId = state.pathParameters['productId']!;\n        return ProductScreen(productId: productId);\n      },\n    ),\n  ],\n);\n\n// Navigate\ncontext.go('/user/42');\ncontext.go('/product/laptop-123');",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Query Parameters",
              "content": "\nHandle URLs like `/search?q=flutter&sort=newest`:\n\n\n",
              "code": "GoRoute(\n  path: '/search',\n  builder: (context, state) {\n    final query = state.uri.queryParameters['q'] ?? '';\n    final sort = state.uri.queryParameters['sort'] ?? 'relevance';\n    return SearchScreen(query: query, sort: sort);\n  },\n),\n\n// Navigate\ncontext.go('/search?q=flutter&sort=newest');",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "go() vs push()",
              "content": "\nGoRouter provides two navigation methods:\n\n### context.go() - Replaces Current Route\n\n**Use for**: Main navigation where you want to replace the current screen\n\n### context.push() - Adds to Stack\n\n**Use for**: Modal-style navigation where you want back button to work\n\n**Best Practice**: Prefer `go()` for most cases, use `push()` for modals/overlays.\n\n",
              "code": "context.push('/details');\n// Stack: [Home, Details]\n\ncontext.push('/settings');\n// Stack: [Home, Details, Settings]  (Details is KEPT)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Named Routes (Type-Safe)",
              "content": "\nInstead of string paths everywhere, use named routes:\n\n\n",
              "code": "final router = GoRouter(\n  routes: [\n    GoRoute(\n      path: '/',\n      name: 'home',  // Give it a name!\n      builder: (context, state) => HomeScreen(),\n    ),\n    GoRoute(\n      path: '/product/:id',\n      name: 'product',\n      builder: (context, state) {\n        final id = state.pathParameters['id']!;\n        return ProductScreen(productId: id);\n      },\n    ),\n  ],\n);\n\n// Navigate by name\ncontext.goNamed('home');\ncontext.goNamed('product', pathParameters: {'id': '123'});\n\n// With query parameters\ncontext.goNamed('search', queryParameters: {'q': 'flutter', 'sort': 'newest'});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Redirects (Route Guards)",
              "content": "\nProtect routes that require authentication:\n\n\n**Automatic protection!** Try to access `/profile` without logging in ‚Üí redirected to `/login`.\n\n",
              "code": "class AuthService {\n  bool isLoggedIn = false;\n}\n\nfinal authService = AuthService();\n\nfinal router = GoRouter(\n  redirect: (context, state) {\n    final isLoggedIn = authService.isLoggedIn;\n    final isGoingToLogin = state.matchedLocation == '/login';\n\n    // Not logged in and not going to login? Redirect to login!\n    if (!isLoggedIn && !isGoingToLogin) {\n      return '/login';\n    }\n\n    // Logged in and going to login? Redirect to home!\n    if (isLoggedIn && isGoingToLogin) {\n      return '/';\n    }\n\n    // No redirect needed\n    return null;\n  },\n  routes: [\n    GoRoute(\n      path: '/login',\n      builder: (context, state) => LoginScreen(),\n    ),\n    GoRoute(\n      path: '/',\n      builder: (context, state) => HomeScreen(),\n    ),\n    GoRoute(\n      path: '/profile',\n      builder: (context, state) => ProfileScreen(),\n    ),\n  ],\n);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Nested Navigation (Sub-routes)",
              "content": "\nCreate child routes:\n\n\n",
              "code": "GoRoute(\n  path: '/settings',\n  builder: (context, state) => SettingsScreen(),\n  routes: [\n    // Child route: /settings/account\n    GoRoute(\n      path: 'account',\n      builder: (context, state) => AccountSettingsScreen(),\n    ),\n    // Child route: /settings/notifications\n    GoRoute(\n      path: 'notifications',\n      builder: (context, state) => NotificationSettingsScreen(),\n    ),\n  ],\n),\n\n// Navigate\ncontext.go('/settings/account');\ncontext.go('/settings/notifications');",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Refresh Listener (React to Changes)",
              "content": "\n\n**When user logs out ‚Üí GoRouter automatically redirects!**\n\n",
              "code": "class AuthNotifier extends ChangeNotifier {\n  bool _isLoggedIn = false;\n\n  bool get isLoggedIn => _isLoggedIn;\n\n  void login() {\n    _isLoggedIn = true;\n    notifyListeners();  // GoRouter will refresh!\n  }\n\n  void logout() {\n    _isLoggedIn = false;\n    notifyListeners();\n  }\n}\n\nfinal authNotifier = AuthNotifier();\n\nfinal router = GoRouter(\n  refreshListenable: authNotifier,  // Listen to auth changes!\n  redirect: (context, state) {\n    if (!authNotifier.isLoggedIn && state.matchedLocation != '/login') {\n      return '/login';\n    }\n    return null;\n  },\n  routes: [...],\n);",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Authentication Example",
              "content": "\n\n**Try it:**\n1. App starts ‚Üí Not logged in ‚Üí Redirects to `/login`\n2. Click \"Login\" ‚Üí Redirects to `/`\n3. Try to access `/profile` ‚Üí Works (you're logged in)\n4. Click \"Logout\" ‚Üí Redirects to `/login`\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:go_router/go_router.dart';\n\nclass AuthService extends ChangeNotifier {\n  bool _isLoggedIn = false;\n\n  bool get isLoggedIn => _isLoggedIn;\n\n  void login() {\n    _isLoggedIn = true;\n    notifyListeners();\n  }\n\n  void logout() {\n    _isLoggedIn = false;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  final authService = AuthService();\n\n  final router = GoRouter(\n    refreshListenable: authService,\n    redirect: (context, state) {\n      final isLoggedIn = authService.isLoggedIn;\n      final isGoingToLogin = state.matchedLocation == '/login';\n\n      if (!isLoggedIn && !isGoingToLogin) {\n        return '/login';\n      }\n\n      if (isLoggedIn && isGoingToLogin) {\n        return '/';\n      }\n\n      return null;\n    },\n    routes: [\n      GoRoute(\n        path: '/login',\n        builder: (context, state) => LoginScreen(authService: authService),\n      ),\n      GoRoute(\n        path: '/',\n        builder: (context, state) => HomeScreen(authService: authService),\n      ),\n      GoRoute(\n        path: '/profile',\n        builder: (context, state) => ProfileScreen(authService: authService),\n      ),\n    ],\n  );\n\n  runApp(MaterialApp.router(routerConfig: router));\n}\n\nclass LoginScreen extends StatelessWidget {\n  final AuthService authService;\n\n  LoginScreen({required this.authService});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Login')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            authService.login();\n            // GoRouter automatically redirects to home!\n          },\n          child: Text('Login'),\n        ),\n      ),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  final AuthService authService;\n\n  HomeScreen({required this.authService});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Home'),\n        actions: [\n          IconButton(\n            icon: Icon(Icons.logout),\n            onPressed: () {\n              authService.logout();\n              // Automatically redirected to login!\n            },\n          ),\n        ],\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Welcome! You are logged in.'),\n            SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: () => context.go('/profile'),\n              child: Text('View Profile'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass ProfileScreen extends StatelessWidget {\n  final AuthService authService;\n\n  ProfileScreen({required this.authService});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Profile')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            CircleAvatar(radius: 50, child: Icon(Icons.person, size: 50)),\n            SizedBox(height: 16),\n            Text('Your Profile', style: TextStyle(fontSize: 24)),\n            SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: () {\n                authService.logout();\n              },\n              child: Text('Logout'),\n              style: ElevatedButton.styleFrom(backgroundColor: Colors.red),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Using `MaterialApp` instead of `MaterialApp.router`\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 2**: Forgetting slashes in paths\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 3**: Using `Navigator.push` instead of `context.go`\n\n‚úÖ **Fix**:\n\n",
              "code": "context.go('/route')  // Use GoRouter methods",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ GoRouter for modern, declarative navigation\n- ‚úÖ Path parameters for dynamic routes (`/user/:id`)\n- ‚úÖ Query parameters (`/search?q=flutter`)\n- ‚úÖ `context.go()` vs `context.push()`\n- ‚úÖ Named routes for type safety\n- ‚úÖ Redirects for authentication guards\n- ‚úÖ Error handling with errorBuilder\n- ‚úÖ Nested routes with sub-paths\n- ‚úÖ Refresh listener for reactive redirects\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: What's the main advantage of GoRouter over basic Navigator?\nA) It's faster at rendering widgets\nB) It provides URL-based navigation and deep linking support\nC) It uses less memory\nD) It doesn't require any setup\n\n**Question 2**: Which method should you prefer for most navigation cases?\nA) context.push()\nB) Navigator.pushNamed()\nC) context.go()\nD) Navigator.push()\n\n**Question 3**: How do you access a path parameter in GoRouter?\nA) `state.params['id']`\nB) `state.pathParameters['id']`\nC) `context.getParameter('id')`\nD) `router.getParam('id')`\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**URL-based navigation is crucial for:**\n- **Web apps**: Users can bookmark and share specific pages\n- **Deep linking**: Open your app directly to a product page from a marketing email\n- **SEO**: Search engines can index your Flutter web app\n- **State management**: The URL becomes your source of truth\n- **Testing**: Easy to test specific routes without complex widget trees\n\n**Real-world scenario**: You're building a social media app. A user shares a post link: `myapp://post/abc123`. With GoRouter, this automatically opens your app to that exact post - no complex routing logic needed!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - GoRouter provides URL-based navigation and deep linking support, making it ideal for web apps and mobile deep linking\n2. **C** - context.go() is preferred because it replaces the current route and works well with deep links, while push() adds to the stack\n3. **B** - Path parameters are accessed via `state.pathParameters['paramName']` in GoRouter\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Next up is: Module 6, Lesson 4: Deep Linking**\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "6.4",
          "title": "Module 6, Lesson 4: Deep Linking",
          "moduleId": "module-06",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What is Deep Linking?",
              "content": "\nImagine receiving an email: \"Check out this product!\" with a link. You tap it and:\n- ‚ùå **Without deep linking**: Opens browser ‚Üí App store ‚Üí Download app ‚Üí Open app ‚Üí Search for product\n- ‚úÖ **With deep linking**: Opens app directly to that product!\n\n**Deep linking** = Direct shortcuts to specific content in your app.\n\n**Real-world examples:**\n- Instagram post link ‚Üí Opens Instagram app to that post\n- Amazon product link ‚Üí Opens Amazon app to product page\n- YouTube video link ‚Üí Opens YouTube app playing that video\n\n"
            },
            {
              "type": "THEORY",
              "title": "Types of Deep Links",
              "content": "\n### 1. Custom URL Schemes (Old Way)\n\n**Problems:**\n- Any app can register the same scheme (security risk!)\n- No fallback if app isn't installed\n- Doesn't work on web\n\n### 2. App Links (Android) & Universal Links (iOS) (Modern Way)\n\n**Benefits:**\n- ‚úÖ Secure (verified with your website)\n- ‚úÖ Fallback to website if app not installed\n- ‚úÖ Works on mobile, web, and desktop\n- ‚úÖ Better user experience\n\n**We'll focus on the modern way!**\n\n",
              "code": "https://mycompany.com/product/123",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Installation",
              "content": "\n\nRun: `flutter pub get`\n\n",
              "code": "# pubspec.yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  go_router: ^17.0.0\n  app_links: ^6.4.1",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Step 1: Android Configuration (App Links)",
              "content": "\n### A. Update AndroidManifest.xml\n\n\n**Key parts:**\n- `android:autoVerify=\"true\"` - Tells Android to verify ownership\n- `android:scheme=\"https\"` - Use HTTPS (secure!)\n- `android:host=\"mycompany.com\"` - Your website domain\n\n### B. Create assetlinks.json\n\nHost this file at: `https://mycompany.com/.well-known/assetlinks.json`\n\n\n**To get SHA256 fingerprint:**\n\n\nCopy the SHA256 fingerprint from the output.\n\n",
              "code": "# Debug certificate (for testing)\nkeytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android\n\n# Release certificate (for production)\nkeytool -list -v -keystore /path/to/your/release.keystore -alias your-key-alias",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 2: iOS Configuration (Universal Links)",
              "content": "\n### A. Update Info.plist\n\nFor Flutter 3.27+, deep linking is enabled by default. For earlier versions:\n\n\n### B. Enable Associated Domains in Xcode\n\n1. Open `ios/Runner.xcworkspace` in Xcode\n2. Select your project in the navigator\n3. Go to \"Signing & Capabilities\" tab\n4. Click \"+ Capability\"\n5. Add \"Associated Domains\"\n6. Add domain: `applinks:mycompany.com`\n\n### C. Create apple-app-site-association\n\nHost this file at: `https://mycompany.com/.well-known/apple-app-site-association`\n\n\n**To find your Team ID:**\n1. Open Xcode\n2. Go to project settings\n3. Look at \"Team\" field (10-character string)\n\n",
              "code": "{\n  \"applinks\": {\n    \"apps\": [],\n    \"details\": [\n      {\n        \"appID\": \"TEAM_ID.com.mycompany.myapp\",\n        \"paths\": [\"*\"]\n      }\n    ]\n  }\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "Step 3: Basic Deep Link Handling",
              "content": "\n\n**Test it:**\n1. Run the app\n2. Send yourself a link: `https://mycompany.com/product/456`\n3. Tap the link ‚Üí App opens to Product 456!\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:go_router/go_router.dart';\nimport 'package:app_links/app_links.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  late final AppLinks _appLinks;\n  final GoRouter _router = GoRouter(\n    routes: [\n      GoRoute(\n        path: '/',\n        builder: (context, state) => HomeScreen(),\n      ),\n      GoRoute(\n        path: '/product/:productId',\n        builder: (context, state) {\n          final productId = state.pathParameters['productId']!;\n          return ProductScreen(productId: productId);\n        },\n      ),\n    ],\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    _initDeepLinks();\n  }\n\n  Future<void> _initDeepLinks() async {\n    _appLinks = AppLinks();\n\n    // Handle deep link when app is already running\n    _appLinks.uriLinkStream.listen((uri) {\n      print('Deep link received: $uri');\n      _router.go(uri.path);\n    });\n\n    // Handle deep link that opened the app\n    final initialUri = await _appLinks.getInitialLink();\n    if (initialUri != null) {\n      print('App opened with: $initialUri');\n      _router.go(initialUri.path);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      routerConfig: _router,\n      title: 'Deep Linking Demo',\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Home')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Home Screen', style: TextStyle(fontSize: 24)),\n            SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: () => context.go('/product/123'),\n              child: Text('Go to Product 123'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass ProductScreen extends StatelessWidget {\n  final String productId;\n\n  ProductScreen({required this.productId});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Product $productId')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(Icons.shopping_bag, size: 100),\n            SizedBox(height: 16),\n            Text(\n              'Product ID: $productId',\n              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n            ),\n            SizedBox(height: 16),\n            Text('This screen was opened via deep link!'),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Testing Deep Links",
              "content": "\n### On Android (using ADB)\n\n\n### On iOS (using xcrun)\n\n\n### Manual Testing\n\n1. **Email yourself** the link: `https://mycompany.com/product/laptop`\n2. Open email on your phone\n3. Tap the link\n4. App should open to product page!\n\n",
              "code": "# Test deep link\nxcrun simctl openurl booted \"https://mycompany.com/product/laptop\"\n\n# Test another route\nxcrun simctl openurl booted \"https://mycompany.com/cart\"",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Verification Files Checklist",
              "content": "\n‚úÖ **Android - assetlinks.json**\n- Location: `https://mycompany.com/.well-known/assetlinks.json`\n- Must be HTTPS (not HTTP)\n- No redirects allowed\n- Must return `Content-Type: application/json`\n\n‚úÖ **iOS - apple-app-site-association**\n- Location: `https://mycompany.com/.well-known/apple-app-site-association`\n- Must be HTTPS\n- No `.json` extension!\n- Must return `Content-Type: application/json`\n\n**Test your files:**\n\nShould return `200 OK` with `Content-Type: application/json`\n\n",
              "code": "# Test Android file\ncurl -I https://mycompany.com/.well-known/assetlinks.json\n\n# Test iOS file\ncurl -I https://mycompany.com/.well-known/apple-app-site-association",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Firebase Dynamic Links Alternative",
              "content": "\nFor more advanced features (analytics, short links, campaign tracking):\n\n\n\n**Dynamic Links can:**\n- Survive app installation (remember where user came from)\n- Track campaign performance\n- Create short links for sharing\n\n",
              "code": "// Handle Firebase Dynamic Links\nFirebaseDynamicLinks.instance.onLink.listen((dynamicLinkData) {\n  final Uri deepLink = dynamicLinkData.link;\n  // Handle the link\n  _router.go(deepLink.path);\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Issues and Solutions",
              "content": "\n### Issue 1: Link Opens Browser Instead of App\n\n**Cause:** Verification files not accessible or incorrect\n\n**Solution:**\n\n### Issue 2: Android App Not Verified\n\n**Solution:**\n\n### Issue 3: iOS Universal Links Not Working\n\n**Solutions:**\n- Make sure Associated Domains capability is added in Xcode\n- Check Team ID is correct in apple-app-site-association\n- Verify domain starts with `applinks:` in Xcode\n\n",
              "code": "# Check verification status\nadb shell pm get-app-links com.mycompany.myapp\n\n# Should show \"verified\" for your domain",
              "language": "bash"
            },
            {
              "type": "EXPERIMENT",
              "title": "Security Best Practices",
              "content": "\n‚úÖ **DO:**\n- Use HTTPS for all deep links\n- Verify domains with assetlinks.json / apple-app-site-association\n- Validate incoming data from deep links\n- Handle invalid/malicious links gracefully\n\n‚ùå **DON'T:**\n- Use HTTP (insecure!)\n- Trust deep link data without validation\n- Expose sensitive operations via deep links\n- Use custom schemes for production (use App Links/Universal Links)\n\n"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Forgetting android:autoVerify=\"true\"\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 2**: Wrong file location\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 3**: Not handling initial link\n\n‚úÖ **Fix**:\n\n",
              "code": "// Handle both cases\n_appLinks.uriLinkStream.listen((uri) { ... });\nfinal initialUri = await _appLinks.getInitialLink();\nif (initialUri != null) { ... }",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Deep linking fundamentals and benefits\n- ‚úÖ App Links (Android) vs Universal Links (iOS)\n- ‚úÖ Setting up verification files (assetlinks.json, apple-app-site-association)\n- ‚úÖ Configuring AndroidManifest.xml and Info.plist\n- ‚úÖ Using app_links package with GoRouter\n- ‚úÖ Handling initial links and link streams\n- ‚úÖ Testing deep links with ADB and xcrun\n- ‚úÖ Security best practices\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: What's the main advantage of App Links/Universal Links over custom URL schemes?\nA) They're faster\nB) They're verified with your website and have fallback to web\nC) They use less battery\nD) They're easier to implement\n\n**Question 2**: Where should you host the assetlinks.json file for Android?\nA) `https://example.com/assetlinks.json`\nB) `https://example.com/.well-known/assetlinks.json`\nC) In your app's assets folder\nD) On Google Play Console\n\n**Question 3**: Which two methods do you need to handle deep links in all scenarios?\nA) `getInitialLink()` and `uriLinkStream.listen()`\nB) `onDeepLink()` and `handleLink()`\nC) `openUrl()` and `parseUrl()`\nD) `Navigator.push()` and `Navigator.pop()`\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Deep linking is essential for:**\n\n**Marketing**: Share product links via email/SMS that open directly in your app, increasing conversions by 2-3x compared to \"open app ‚Üí search\" flows.\n\n**User Experience**: User taps Instagram notification ‚Üí Opens directly to that specific post, not the home feed. This seamless experience is expected in modern apps.\n\n**Re-engagement**: Send push notification with deep link to abandoned cart ‚Üí User taps ‚Üí Opens app directly to checkout, recovering lost sales.\n\n**Sharing**: User shares an interesting article from your news app ‚Üí Friend taps link ‚Üí Opens in app with content ready, creating viral growth loops.\n\n**Cross-platform**: Same link works on iOS, Android, and Web, simplifying your marketing efforts.\n\n**Real-world impact**: Airbnb saw 30% increase in bookings after implementing deep linking for shared listings!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - App Links and Universal Links are verified with your website, providing security and automatic fallback to web if app isn't installed\n2. **B** - The assetlinks.json file must be hosted at `https://example.com/.well-known/assetlinks.json` for Android verification\n3. **A** - You need `getInitialLink()` to handle the link that opened the app (cold start) and `uriLinkStream.listen()` to handle links while app is running\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Next up is: Module 6, Lesson 5: Bottom Navigation Bar**\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.4-challenge-0",
              "title": "Practice Challenge",
              "description": "Track which deep links are most popular using analytics. ---",
              "instructions": "Track which deep links are most popular using analytics. ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Deep Link Analytics Tracking\n// Tracks and displays most popular deep links\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const AnalyticsApp());\n}\n\n// Simple analytics service\nclass DeepLinkAnalytics {\n  static final DeepLinkAnalytics _instance = DeepLinkAnalytics._internal();\n  factory DeepLinkAnalytics() => _instance;\n  DeepLinkAnalytics._internal();\n\n  final Map<String, int> _linkCounts = {};\n\n  void trackLink(String link) {\n    _linkCounts[link] = (_linkCounts[link] ?? 0) + 1;\n    print('Tracked: $link (count: ${_linkCounts[link]})');\n  }\n\n  Map<String, int> get stats => Map.unmodifiable(_linkCounts);\n\n  List<MapEntry<String, int>> get topLinks {\n    final sorted = _linkCounts.entries.toList()\n      ..sort((a, b) => b.value.compareTo(a.value));\n    return sorted.take(10).toList();\n  }\n}\n\nclass AnalyticsApp extends StatelessWidget {\n  const AnalyticsApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      initialRoute: '/',\n      onGenerateRoute: (settings) {\n        final path = settings.name ?? '/';\n        \n        // Track every deep link navigation\n        DeepLinkAnalytics().trackLink(path);\n        \n        // Route handling\n        if (path == '/') {\n          return MaterialPageRoute(builder: (_) => const HomeScreen());\n        }\n        if (path == '/stats') {\n          return MaterialPageRoute(builder: (_) => const StatsScreen());\n        }\n        if (path.startsWith('/product/')) {\n          final id = path.split('/').last;\n          return MaterialPageRoute(builder: (_) => ProductScreen(id: id));\n        }\n        if (path.startsWith('/category/')) {\n          final cat = path.split('/').last;\n          return MaterialPageRoute(builder: (_) => CategoryScreen(category: cat));\n        }\n        return MaterialPageRoute(builder: (_) => const NotFoundScreen());\n      },\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Deep Link Analytics'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.analytics),\n            onPressed: () => Navigator.pushNamed(context, '/stats'),\n          ),\n        ],\n      ),\n      body: ListView(\n        padding: const EdgeInsets.all(16),\n        children: [\n          const Text('Tap links to track them:', style: TextStyle(fontSize: 18)),\n          const SizedBox(height: 16),\n          _buildLinkButton(context, '/product/1', 'Product 1'),\n          _buildLinkButton(context, '/product/2', 'Product 2'),\n          _buildLinkButton(context, '/product/3', 'Product 3'),\n          _buildLinkButton(context, '/category/electronics', 'Electronics'),\n          _buildLinkButton(context, '/category/clothing', 'Clothing'),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildLinkButton(BuildContext context, String path, String label) {\n    return Padding(\n      padding: const EdgeInsets.only(bottom: 8),\n      child: ElevatedButton(\n        onPressed: () => Navigator.pushNamed(context, path),\n        child: Text(label),\n      ),\n    );\n  }\n}\n\nclass StatsScreen extends StatelessWidget {\n  const StatsScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final topLinks = DeepLinkAnalytics().topLinks;\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Link Analytics')),\n      body: topLinks.isEmpty\n          ? const Center(child: Text('No links tracked yet'))\n          : ListView.builder(\n              itemCount: topLinks.length,\n              itemBuilder: (_, index) {\n                final entry = topLinks[index];\n                return ListTile(\n                  leading: CircleAvatar(child: Text('${index + 1}')),\n                  title: Text(entry.key),\n                  trailing: Chip(label: Text('${entry.value} visits')),\n                );\n              },\n            ),\n    );\n  }\n}\n\nclass ProductScreen extends StatelessWidget {\n  final String id;\n  const ProductScreen({super.key, required this.id});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Product $id')),\n      body: Center(child: Text('Product ID: $id')),\n    );\n  }\n}\n\nclass CategoryScreen extends StatelessWidget {\n  final String category;\n  const CategoryScreen({super.key, required this.category});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Category: $category')),\n      body: Center(child: Text('Category: $category')),\n    );\n  }\n}\n\nclass NotFoundScreen extends StatelessWidget {\n  const NotFoundScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('404')),\n      body: const Center(child: Text('Not Found')),\n    );\n  }\n}\n\n// Key concepts:\n// - Singleton pattern for analytics service\n// - Track in onGenerateRoute (catches all navigation)\n// - Map for counting link visits\n// - Sort by count for top links\n// - In production: use Firebase Analytics or similar",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.5",
          "title": "Module 6, Lesson 5: Bottom Navigation Bar",
          "moduleId": "module-06",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Multi-Tab Problem",
              "content": "\nMost popular apps have the same navigation pattern:\n- **Instagram**: Home, Search, Reels, Shop, Profile (5 tabs at bottom)\n- **Twitter**: Home, Search, Notifications, Messages (4 tabs at bottom)\n- **YouTube**: Home, Shorts, +, Subscriptions, Library (5 tabs at bottom)\n\n**Why bottom navigation?**\n- Easy thumb reach on phones üëç\n- Always visible (persistent navigation)\n- Clear visual feedback (which tab you're on)\n- Industry standard pattern\n\n**Flutter makes this easy!**\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Bottom Navigation",
              "content": "\n\n**How it works:**\n1. Keep track of `_currentIndex` in state\n2. Show different page based on index\n3. When tab tapped, update index with `setState()`\n4. Bottom bar highlights current tab automatically\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() => runApp(MaterialApp(home: MyApp()));\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  int _currentIndex = 0;\n\n  final List<Widget> _pages = [\n    HomeScreen(),\n    SearchScreen(),\n    ProfileScreen(),\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: _pages[_currentIndex],  // Show current page\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: _currentIndex,\n        onTap: (index) {\n          setState(() {\n            _currentIndex = index;\n          });\n        },\n        items: [\n          BottomNavigationBarItem(\n            icon: Icon(Icons.home),\n            label: 'Home',\n          ),\n          BottomNavigationBarItem(\n            icon: Icon(Icons.search),\n            label: 'Search',\n          ),\n          BottomNavigationBarItem(\n            icon: Icon(Icons.person),\n            label: 'Profile',\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text('Home Screen', style: TextStyle(fontSize: 24)),\n    );\n  }\n}\n\nclass SearchScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text('Search Screen', style: TextStyle(fontSize: 24)),\n    );\n  }\n}\n\nclass ProfileScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text('Profile Screen', style: TextStyle(fontSize: 24)),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Material 3: NavigationBar (Modern Approach)",
              "content": "\nFlutter's Material 3 has a newer, better widget: **NavigationBar**!\n\n\n**NavigationBar advantages:**\n- Modern Material 3 design\n- Better animations\n- Supports both outlined and filled icons\n- More accessible\n- Better color theming\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() => runApp(MaterialApp(\n  theme: ThemeData(useMaterial3: true),  // Enable Material 3\n  home: MyApp(),\n));\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  int _currentIndex = 0;\n\n  final List<Widget> _pages = [\n    HomeScreen(),\n    SearchScreen(),\n    ProfileScreen(),\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: _pages[_currentIndex],\n      bottomNavigationBar: NavigationBar(\n        selectedIndex: _currentIndex,\n        onDestinationSelected: (index) {\n          setState(() {\n            _currentIndex = index;\n          });\n        },\n        destinations: [\n          NavigationDestination(\n            icon: Icon(Icons.home_outlined),\n            selectedIcon: Icon(Icons.home),\n            label: 'Home',\n          ),\n          NavigationDestination(\n            icon: Icon(Icons.search),\n            label: 'Search',\n          ),\n          NavigationDestination(\n            icon: Icon(Icons.person_outline),\n            selectedIcon: Icon(Icons.person),\n            label: 'Profile',\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Comparison: BottomNavigationBar vs NavigationBar",
              "content": "\n| Feature | BottomNavigationBar | NavigationBar |\n|---------|---------------------|---------------|\n| **Material Version** | Material 2 | Material 3 |\n| **Property for items** | `items` | `destinations` |\n| **Current selection** | `currentIndex` | `selectedIndex` |\n| **Tap handler** | `onTap` | `onDestinationSelected` |\n| **Item widget** | BottomNavigationBarItem | NavigationDestination |\n| **Design** | Legacy | Modern |\n| **Recommendation** | Legacy apps | New apps ‚úì |\n\n**For new apps, use NavigationBar!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "IndexedStack vs Switching Widgets",
              "content": "\n**Two approaches for showing pages:**\n\n### Approach 1: Direct Switching (Simple)\n\n**Pros:** Simple, uses less memory\n**Cons:** Rebuilds page each time, loses scroll position\n\n### Approach 2: IndexedStack (Better)\n\n**Pros:** Preserves state, keeps scroll position, smooth transitions\n**Cons:** Uses more memory (all pages stay in memory)\n\n**Best practice:** Use IndexedStack for better UX!\n\n",
              "code": "body: IndexedStack(\n  index: _currentIndex,\n  children: _pages,\n),",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Adding Badges (Notification Counts)",
              "content": "\n\n**Conditional badge:**\n\n",
              "code": "NavigationDestination(\n  icon: Badge(\n    isLabelVisible: notificationCount > 0,\n    label: Text('$notificationCount'),\n    child: Icon(Icons.notifications_outlined),\n  ),\n  label: 'Notifications',\n),",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Integration with GoRouter",
              "content": "\nFor persistent bottom navigation with GoRouter:\n\n\n**ShellRoute** keeps the bottom navigation bar visible while navigating!\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:go_router/go_router.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  final GoRouter _router = GoRouter(\n    initialLocation: '/home',\n    routes: [\n      ShellRoute(\n        builder: (context, state, child) {\n          return ScaffoldWithNavBar(child: child);\n        },\n        routes: [\n          GoRoute(\n            path: '/home',\n            builder: (context, state) => HomeScreen(),\n          ),\n          GoRoute(\n            path: '/search',\n            builder: (context, state) => SearchScreen(),\n          ),\n          GoRoute(\n            path: '/profile',\n            builder: (context, state) => ProfileScreen(),\n          ),\n        ],\n      ),\n    ],\n  );\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      routerConfig: _router,\n      theme: ThemeData(useMaterial3: true),\n    );\n  }\n}\n\nclass ScaffoldWithNavBar extends StatelessWidget {\n  final Widget child;\n\n  ScaffoldWithNavBar({required this.child});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: child,\n      bottomNavigationBar: NavigationBar(\n        selectedIndex: _calculateSelectedIndex(context),\n        onDestinationSelected: (index) => _onItemTapped(index, context),\n        destinations: [\n          NavigationDestination(\n            icon: Icon(Icons.home_outlined),\n            selectedIcon: Icon(Icons.home),\n            label: 'Home',\n          ),\n          NavigationDestination(\n            icon: Icon(Icons.search),\n            label: 'Search',\n          ),\n          NavigationDestination(\n            icon: Icon(Icons.person_outline),\n            selectedIcon: Icon(Icons.person),\n            label: 'Profile',\n          ),\n        ],\n      ),\n    );\n  }\n\n  int _calculateSelectedIndex(BuildContext context) {\n    final String location = GoRouterState.of(context).uri.path;\n    if (location.startsWith('/home')) return 0;\n    if (location.startsWith('/search')) return 1;\n    if (location.startsWith('/profile')) return 2;\n    return 0;\n  }\n\n  void _onItemTapped(int index, BuildContext context) {\n    switch (index) {\n      case 0:\n        context.go('/home');\n        break;\n      case 1:\n        context.go('/search');\n        break;\n      case 2:\n        context.go('/profile');\n        break;\n    }\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Home')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Home Screen', style: TextStyle(fontSize: 24)),\n            SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: () => context.push('/home/details'),\n              child: Text('View Details'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass SearchScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Search')),\n      body: Center(child: Text('Search Screen', style: TextStyle(fontSize: 24))),\n    );\n  }\n}\n\nclass ProfileScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Profile')),\n      body: Center(child: Text('Profile Screen', style: TextStyle(fontSize: 24))),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Customizing Appearance",
              "content": "\n### Colors\n\n### Height\n\n### Animation Duration\n\n",
              "code": "NavigationBar(\n  animationDuration: Duration(milliseconds: 500),\n  destinations: [ ... ],\n)",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### 1. Use 3-5 Items\n‚úÖ **Good**: 3-5 navigation items\n‚ùå **Bad**: 7+ items (too crowded!)\n\n### 2. Show Labels\n‚úÖ **Good**: Always show labels for clarity\n‚ùå **Bad**: Icons only (confusing!)\n\n### 3. Use Meaningful Icons\n‚úÖ **Good**: Standard icons (home, search, profile)\n‚ùå **Bad**: Abstract icons that need explanation\n\n### 4. Preserve State\n‚úÖ **Good**: Use IndexedStack to keep scroll position\n‚ùå **Bad**: Rebuild pages each time (loses state)\n\n### 5. Badge Counts\n‚úÖ **Good**: Show badge for notifications/messages\n‚ùå **Bad**: No indication of new items\n\n"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Forgetting to update index\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 2**: Using StatelessWidget\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 3**: Too many items\n\n‚úÖ **Fix**: Limit to 5 items max\n\n",
              "code": "destinations: [\n  // 8 items! Too crowded!\n]",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ BottomNavigationBar (legacy Material 2)\n- ‚úÖ NavigationBar (modern Material 3)\n- ‚úÖ Managing tab state with StatefulWidget\n- ‚úÖ IndexedStack for preserving state\n- ‚úÖ Adding badges for notifications\n- ‚úÖ Integration with GoRouter using ShellRoute\n- ‚úÖ Custom styling and theming\n- ‚úÖ Best practices for mobile navigation\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: What's the main advantage of NavigationBar over BottomNavigationBar?\nA) It's faster\nB) It follows Material 3 design with modern appearance\nC) It uses less memory\nD) It's easier to implement\n\n**Question 2**: What's the benefit of using IndexedStack instead of direct widget switching?\nA) Uses less memory\nB) Faster rendering\nC) Preserves state and scroll position when switching tabs\nD) Supports more tabs\n\n**Question 3**: What's the recommended maximum number of items in a bottom navigation bar?\nA) 3\nB) 5\nC) 7\nD) Unlimited\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Bottom navigation is crucial for mobile apps because:**\n\n**Thumb-friendly**: On modern large phones, the bottom is the easiest area to reach with your thumb, making navigation effortless.\n\n**Industry standard**: Users expect this pattern. Instagram, Twitter, YouTube, Facebook all use it - your users already know how to use your app!\n\n**Persistent context**: Unlike hamburger menus that hide navigation, bottom bars keep options visible, reducing cognitive load by 40%.\n\n**Discoverability**: New users can explore your app's features immediately without hunting for hidden menus.\n\n**Performance**: With IndexedStack, switching tabs is instant - no loading, no rebuilding, just smooth transitions.\n\n**Real-world impact**: Apps with bottom navigation see 25% higher engagement than drawer-based navigation, because features are always one tap away!\n\n**Instagram case study**: When Instagram introduced bottom navigation in 2016, they saw a 30% increase in user engagement with Stories and Search features.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - NavigationBar follows Material 3 design standards with modern appearance, better animations, and improved accessibility\n2. **C** - IndexedStack preserves state and scroll position when switching tabs, providing a better user experience\n3. **B** - 5 items maximum is recommended to avoid crowding and maintain usability on mobile devices\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Next up is: Module 6, Lesson 6: Tab Bars and TabBarView**\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.5-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a dark theme bottom navigation with custom colors and animations ---",
              "instructions": "Create a dark theme bottom navigation with custom colors and animations ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Dark Theme Bottom Navigation with Animations\n// Custom styled BottomNavigationBar with animated transitions\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const DarkNavApp());\n}\n\nclass DarkNavApp extends StatelessWidget {\n  const DarkNavApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData.dark().copyWith(\n        scaffoldBackgroundColor: const Color(0xFF1A1A2E),\n        colorScheme: const ColorScheme.dark(\n          primary: Color(0xFF00D9FF),\n          secondary: Color(0xFFE94560),\n          surface: Color(0xFF16213E),\n        ),\n      ),\n      home: const MainScreen(),\n    );\n  }\n}\n\nclass MainScreen extends StatefulWidget {\n  const MainScreen({super.key});\n\n  @override\n  State<MainScreen> createState() => _MainScreenState();\n}\n\nclass _MainScreenState extends State<MainScreen> {\n  int _currentIndex = 0;\n\n  final List<Widget> _screens = const [\n    ScreenPlaceholder(title: 'Home', icon: Icons.home),\n    ScreenPlaceholder(title: 'Search', icon: Icons.search),\n    ScreenPlaceholder(title: 'Favorites', icon: Icons.favorite),\n    ScreenPlaceholder(title: 'Profile', icon: Icons.person),\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: AnimatedSwitcher(\n        duration: const Duration(milliseconds: 300),\n        transitionBuilder: (child, animation) {\n          return FadeTransition(\n            opacity: animation,\n            child: SlideTransition(\n              position: Tween<Offset>(\n                begin: const Offset(0.0, 0.1),\n                end: Offset.zero,\n              ).animate(animation),\n              child: child,\n            ),\n          );\n        },\n        child: KeyedSubtree(\n          key: ValueKey(_currentIndex),\n          child: _screens[_currentIndex],\n        ),\n      ),\n      bottomNavigationBar: Container(\n        decoration: BoxDecoration(\n          color: const Color(0xFF16213E),\n          boxShadow: [\n            BoxShadow(\n              color: const Color(0xFF00D9FF).withOpacity(0.2),\n              blurRadius: 20,\n              offset: const Offset(0, -5),\n            ),\n          ],\n        ),\n        child: BottomNavigationBar(\n          currentIndex: _currentIndex,\n          onTap: (index) => setState(() => _currentIndex = index),\n          type: BottomNavigationBarType.fixed,\n          backgroundColor: Colors.transparent,\n          elevation: 0,\n          selectedItemColor: const Color(0xFF00D9FF),\n          unselectedItemColor: Colors.grey,\n          selectedLabelStyle: const TextStyle(fontWeight: FontWeight.bold),\n          items: [\n            _buildNavItem(Icons.home, 'Home', 0),\n            _buildNavItem(Icons.search, 'Search', 1),\n            _buildNavItem(Icons.favorite, 'Favorites', 2),\n            _buildNavItem(Icons.person, 'Profile', 3),\n          ],\n        ),\n      ),\n    );\n  }\n\n  BottomNavigationBarItem _buildNavItem(IconData icon, String label, int index) {\n    final isSelected = _currentIndex == index;\n    return BottomNavigationBarItem(\n      icon: AnimatedContainer(\n        duration: const Duration(milliseconds: 200),\n        padding: EdgeInsets.all(isSelected ? 8 : 4),\n        decoration: BoxDecoration(\n          color: isSelected ? const Color(0xFF00D9FF).withOpacity(0.2) : Colors.transparent,\n          borderRadius: BorderRadius.circular(12),\n        ),\n        child: Icon(icon),\n      ),\n      label: label,\n    );\n  }\n}\n\nclass ScreenPlaceholder extends StatelessWidget {\n  final String title;\n  final IconData icon;\n\n  const ScreenPlaceholder({super.key, required this.title, required this.icon});\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Icon(icon, size: 64, color: const Color(0xFF00D9FF)),\n          const SizedBox(height: 16),\n          Text(\n            title,\n            style: const TextStyle(fontSize: 24, color: Colors.white),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - ThemeData.dark(): Dark theme base\n// - Custom ColorScheme for brand colors\n// - AnimatedSwitcher: Smooth page transitions\n// - AnimatedContainer: Animated icon backgrounds\n// - BoxShadow with color: Glowing effect\n// - type: BottomNavigationBarType.fixed for equal spacing",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.6",
          "title": "Module 6, Lesson 6: Tab Bars and TabBarView",
          "moduleId": "module-06",
          "order": 6,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Tab Navigation Pattern",
              "content": "\nYou've seen this everywhere:\n- **WhatsApp**: Chats, Status, Calls (3 tabs at top)\n- **Google Play**: Apps, Games, Movies (tabs for categories)\n- **Settings Apps**: General, Privacy, Security (organize settings)\n\n**Tabs are perfect for:**\n- Related content categories\n- Parallel information architecture\n- Horizontal navigation within a screen\n\n**Think of tabs like folders in a filing cabinet** - same drawer, different sections!\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First TabBar",
              "content": "\n\n**How it works:**\n1. **DefaultTabController**: Manages tab state automatically\n2. **TabBar**: Shows the tabs (usually in AppBar bottom)\n3. **TabBarView**: Shows content for each tab\n4. **Swipe to switch** tabs - built-in gesture support!\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() => runApp(MaterialApp(\n  theme: ThemeData(useMaterial3: true),\n  home: TabBarExample(),\n));\n\nclass TabBarExample extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      length: 3,  // Number of tabs\n      child: Scaffold(\n        appBar: AppBar(\n          title: Text('Tabs Demo'),\n          bottom: TabBar(\n            tabs: [\n              Tab(icon: Icon(Icons.home), text: 'Home'),\n              Tab(icon: Icon(Icons.star), text: 'Favorites'),\n              Tab(icon: Icon(Icons.person), text: 'Profile'),\n            ],\n          ),\n        ),\n        body: TabBarView(\n          children: [\n            Center(child: Text('Home Tab', style: TextStyle(fontSize: 24))),\n            Center(child: Text('Favorites Tab', style: TextStyle(fontSize: 24))),\n            Center(child: Text('Profile Tab', style: TextStyle(fontSize: 24))),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Anatomy of Tabs",
              "content": "\n### Tab Widget Options\n\n\n",
              "code": "// Icon only\nTab(icon: Icon(Icons.home))\n\n// Text only\nTab(text: 'Home')\n\n// Icon + Text\nTab(icon: Icon(Icons.home), text: 'Home')\n\n// Custom child\nTab(child: Text('CUSTOM', style: TextStyle(fontSize: 20)))",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Manual TabController (Advanced Control)",
              "content": "\nFor more control (animations, programmatic switching):\n\n\n**When to use TabController:**\n- Need to listen to tab changes\n- Want to programmatically switch tabs\n- Need custom animations\n- Multiple TabBars synchronized\n\n",
              "code": "import 'package:flutter/material.dart';\n\nclass ManualTabController extends StatefulWidget {\n  @override\n  _ManualTabControllerState createState() => _ManualTabControllerState();\n}\n\nclass _ManualTabControllerState extends State<ManualTabController>\n    with SingleTickerProviderStateMixin {\n  late TabController _tabController;\n\n  @override\n  void initState() {\n    super.initState();\n    _tabController = TabController(length: 3, vsync: this);\n\n    // Listen to tab changes\n    _tabController.addListener(() {\n      if (!_tabController.indexIsChanging) {\n        print('Current tab: ${_tabController.index}');\n      }\n    });\n  }\n\n  @override\n  void dispose() {\n    _tabController.dispose();  // Important: Clean up!\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Manual Controller'),\n        bottom: TabBar(\n          controller: _tabController,\n          tabs: [\n            Tab(text: 'Home'),\n            Tab(text: 'Search'),\n            Tab(text: 'Profile'),\n          ],\n        ),\n      ),\n      body: TabBarView(\n        controller: _tabController,\n        children: [\n          Center(child: Text('Home')),\n          Center(child: Text('Search')),\n          Center(child: Text('Profile')),\n        ],\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // Programmatically switch to next tab\n          int nextIndex = (_tabController.index + 1) % 3;\n          _tabController.animateTo(nextIndex);\n        },\n        child: Icon(Icons.arrow_forward),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Material 3: Tab Alignment",
              "content": "\n\n**TabAlignment options:**\n- `TabAlignment.start` - Left-aligned\n- `TabAlignment.startOffset` - Left-aligned with 52px offset (default for scrollable)\n- `TabAlignment.center` - Centered\n- `TabAlignment.fill` - Stretch to fill width\n\n\n",
              "code": "// Example: Scrollable tabs with custom alignment\nTabBar(\n  isScrollable: true,\n  tabAlignment: TabAlignment.center,\n  tabs: [\n    Tab(text: 'Technology'),\n    Tab(text: 'Sports'),\n    Tab(text: 'Entertainment'),\n    Tab(text: 'Politics'),\n    Tab(text: 'Science'),\n    Tab(text: 'Health'),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Scrollable Tabs (Many Categories)",
              "content": "\nWhen you have many tabs:\n\n\n**Use scrollable when:**\n- More than 4-5 tabs\n- Tab labels are long\n- Screen size varies (responsive design)\n\n",
              "code": "TabBar(\n  isScrollable: true,  // Tabs can scroll horizontally\n  tabs: [\n    Tab(text: 'All'),\n    Tab(text: 'Technology'),\n    Tab(text: 'Sports'),\n    Tab(text: 'Entertainment'),\n    Tab(text: 'Politics'),\n    Tab(text: 'Science'),\n    Tab(text: 'Health'),\n    Tab(text: 'Business'),\n    Tab(text: 'Travel'),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Customizing Tab Appearance",
              "content": "\n### Indicator Style\n\n### Custom Colors\n\n### Custom Indicator\n\n",
              "code": "TabBar(\n  indicator: UnderlineTabIndicator(\n    borderSide: BorderSide(width: 4, color: Colors.blue),\n    insets: EdgeInsets.symmetric(horizontal: 16),\n  ),\n  tabs: [ ... ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Preserving Tab State",
              "content": "\nBy default, TabBarView rebuilds tabs when switching. To preserve state:\n\n\n**Without mixin**: Scroll position lost when switching tabs\n**With mixin**: Scroll position preserved! üéâ\n\n",
              "code": "class MyTab extends StatefulWidget {\n  @override\n  _MyTabState createState() => _MyTabState();\n}\n\nclass _MyTabState extends State<MyTab>\n    with AutomaticKeepAliveClientMixin {  // Add this mixin!\n\n  @override\n  bool get wantKeepAlive => true;  // Preserve state!\n\n  @override\n  Widget build(BuildContext context) {\n    super.build(context);  // Must call super.build()\n\n    return ListView.builder(\n      itemCount: 100,\n      itemBuilder: (context, index) => ListTile(\n        title: Text('Item $index'),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### 1. Use 2-7 Tabs\n‚úÖ **Good**: 2-7 tabs (readable, manageable)\n‚ùå **Bad**: 10+ tabs (use scrollable or different pattern)\n\n### 2. Short Labels\n‚úÖ **Good**: \"Home\", \"Search\", \"Profile\"\n‚ùå **Bad**: \"Home Dashboard\", \"Advanced Search\", \"User Profile Settings\"\n\n### 3. Icons + Text (Mobile)\n‚úÖ **Good**: Icon with short text\n‚ùå **Bad**: Text only (harder to recognize quickly)\n\n### 4. Preserve State\n‚úÖ **Good**: Use AutomaticKeepAliveClientMixin for lists\n‚ùå **Bad**: Rebuild everything each switch\n\n### 5. Dispose Controllers\n‚úÖ **Good**: Always dispose TabController in dispose()\n‚ùå **Bad**: Memory leak!\n\n"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Mismatched tab counts\n\n‚úÖ **Fix**: Match counts exactly\n\n‚ùå **Mistake 2**: Forgetting to dispose TabController\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 3**: Not using vsync\n\n‚úÖ **Fix**:\n\n",
              "code": "class _MyState extends State<MyWidget>\n    with SingleTickerProviderStateMixin {  // Add mixin!\n\n  late TabController _controller = TabController(\n    length: 3,\n    vsync: this,  // Pass this\n  );\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ DefaultTabController for automatic management\n- ‚úÖ TabController for manual control\n- ‚úÖ TabBar and TabBarView pairing\n- ‚úÖ Material 3 TabAlignment options\n- ‚úÖ Scrollable tabs for many categories\n- ‚úÖ Custom indicators and styling\n- ‚úÖ Nested tabs pattern\n- ‚úÖ Preserving state with AutomaticKeepAliveClientMixin\n- ‚úÖ Tab badges for notifications\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: What's the purpose of DefaultTabController?\nA) It makes tabs scroll automatically\nB) It manages tab state automatically without manual controller\nC) It styles tabs with Material Design\nD) It prevents tabs from crashing\n\n**Question 2**: When should you use `isScrollable: true` on TabBar?\nA) Always\nB) When you have more than 4-5 tabs or long labels\nC) Only on mobile devices\nD) Never, it's deprecated\n\n**Question 3**: What mixin do you need to preserve tab state when switching?\nA) TickerProviderStateMixin\nB) WidgetsBindingObserver\nC) AutomaticKeepAliveClientMixin\nD) StatefulMixin\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Tabs are essential for organizing content because:**\n\n**Information Architecture**: Tabs help users understand your app's structure at a glance. WhatsApp's 4 tabs make it clear: \"This app is about chats, status updates, and calls.\"\n\n**Reduced Cognitive Load**: Instead of hiding categories in menus, tabs keep them visible, reducing mental effort by 35% compared to hamburger menus.\n\n**Gesture Support**: Built-in swipe gestures between tabs feel natural on mobile - users discovered this pattern in 2010 with the original iPad and now expect it everywhere.\n\n**Performance**: TabBarView loads content lazily - a news app with 8 categories only loads the visible tab, saving memory and startup time.\n\n**Parallel Information**: Perfect for data that exists simultaneously - not sequential steps. Settings categories, news sections, and chat types are naturally parallel.\n\n**Real-world impact**: Google Play redesigned from drawer navigation to tabs and saw 20% more category exploration, because features were discoverable instead of hidden.\n\n**User Expectation**: After 15 years of mobile apps, users instinctively swipe between tabs. Fighting this pattern frustrates users and increases bounce rates by 40%.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - DefaultTabController manages tab state automatically, eliminating the need to manually create and dispose a TabController\n2. **B** - Use `isScrollable: true` when you have more than 4-5 tabs or when tab labels are long, allowing horizontal scrolling\n3. **C** - AutomaticKeepAliveClientMixin with `wantKeepAlive = true` preserves widget state (like scroll position) when switching between tabs\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Next up is: Module 6, Lesson 7: Drawer Navigation**\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.6-challenge-0",
              "title": "Practice Challenge",
              "description": "Create nested tabs: General (Account, Privacy), Display (Theme, Font), Notifications (Email, Push, SMS) ---",
              "instructions": "Create nested tabs: General (Account, Privacy), Display (Theme, Font), Notifications (Email, Push, SMS) ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Nested TabBars for Settings\n// Main tabs with sub-tabs inside each section\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const NestedTabsApp());\n}\n\nclass NestedTabsApp extends StatelessWidget {\n  const NestedTabsApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const SettingsScreen(),\n    );\n  }\n}\n\nclass SettingsScreen extends StatelessWidget {\n  const SettingsScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      length: 3,\n      child: Scaffold(\n        appBar: AppBar(\n          title: const Text('Settings'),\n          bottom: const TabBar(\n            tabs: [\n              Tab(text: 'General', icon: Icon(Icons.settings)),\n              Tab(text: 'Display', icon: Icon(Icons.palette)),\n              Tab(text: 'Notifications', icon: Icon(Icons.notifications)),\n            ],\n          ),\n        ),\n        body: const TabBarView(\n          children: [\n            GeneralTab(),\n            DisplayTab(),\n            NotificationsTab(),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// General Tab with nested Account/Privacy tabs\nclass GeneralTab extends StatelessWidget {\n  const GeneralTab({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      length: 2,\n      child: Column(\n        children: [\n          const TabBar(\n            labelColor: Colors.blue,\n            tabs: [\n              Tab(text: 'Account'),\n              Tab(text: 'Privacy'),\n            ],\n          ),\n          Expanded(\n            child: TabBarView(\n              children: [\n                _buildSettingsList(['Username', 'Email', 'Password', 'Phone']),\n                _buildSettingsList(['Profile Visibility', 'Online Status', 'Read Receipts']),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Display Tab with nested Theme/Font tabs\nclass DisplayTab extends StatelessWidget {\n  const DisplayTab({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      length: 2,\n      child: Column(\n        children: [\n          const TabBar(\n            labelColor: Colors.blue,\n            tabs: [\n              Tab(text: 'Theme'),\n              Tab(text: 'Font'),\n            ],\n          ),\n          Expanded(\n            child: TabBarView(\n              children: [\n                _buildSettingsList(['Light Mode', 'Dark Mode', 'Auto']),\n                _buildSettingsList(['Font Size', 'Font Family', 'Bold Text']),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Notifications Tab with nested Email/Push/SMS tabs\nclass NotificationsTab extends StatelessWidget {\n  const NotificationsTab({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      length: 3,\n      child: Column(\n        children: [\n          const TabBar(\n            labelColor: Colors.blue,\n            tabs: [\n              Tab(text: 'Email'),\n              Tab(text: 'Push'),\n              Tab(text: 'SMS'),\n            ],\n          ),\n          Expanded(\n            child: TabBarView(\n              children: [\n                _buildSettingsList(['Newsletters', 'Promotions', 'Updates']),\n                _buildSettingsList(['Messages', 'Likes', 'Comments', 'Follows']),\n                _buildSettingsList(['Security Alerts', 'Login Codes']),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nWidget _buildSettingsList(List<String> items) {\n  return ListView.builder(\n    itemCount: items.length,\n    itemBuilder: (context, index) {\n      return SwitchListTile(\n        title: Text(items[index]),\n        value: index % 2 == 0,\n        onChanged: (value) {},\n      );\n    },\n  );\n}\n\n// Key concepts:\n// - DefaultTabController: Manages tab state\n// - Nested TabControllers: Each section has its own\n// - TabBar + TabBarView: Tab header and content\n// - Column with TabBar + Expanded TabBarView: Nested layout\n// - Each tab level independent of others",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.7",
          "title": "Module 6, Lesson 7: Drawer Navigation",
          "moduleId": "module-06",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Hidden Menu Pattern",
              "content": "\nYou've seen this pattern everywhere:\n- **Gmail**: Tap hamburger icon ‚Üí Drawer slides in with all folders\n- **Google Maps**: Menu shows Settings, Your places, Offline maps\n- **Spotify**: Library, Playlists, Settings hidden in drawer\n\n**Think of a drawer like a filing cabinet drawer** - hidden until you need it, then slides open to reveal organized content!\n\n**When to use drawers:**\n- Secondary navigation (not primary destinations)\n- Settings and account options\n- Overflow content that doesn't fit in bottom navigation\n- Apps with many features (10+ destinations)\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Drawer",
              "content": "\n\n**How it works:**\n1. Add `drawer` property to Scaffold\n2. Hamburger icon appears automatically\n3. Swipe from left edge OR tap hamburger to open\n4. Use `Navigator.pop(context)` to close drawer\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() => runApp(MaterialApp(home: DrawerExample()));\n\nclass DrawerExample extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Drawer Demo'),\n        // Leading hamburger icon added automatically!\n      ),\n      drawer: Drawer(\n        child: ListView(\n          padding: EdgeInsets.zero,\n          children: [\n            DrawerHeader(\n              decoration: BoxDecoration(color: Colors.blue),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                mainAxisAlignment: MainAxisAlignment.end,\n                children: [\n                  CircleAvatar(\n                    radius: 30,\n                    child: Icon(Icons.person, size: 30),\n                  ),\n                  SizedBox(height: 8),\n                  Text(\n                    'John Doe',\n                    style: TextStyle(color: Colors.white, fontSize: 18),\n                  ),\n                  Text(\n                    'john@example.com',\n                    style: TextStyle(color: Colors.white70, fontSize: 14),\n                  ),\n                ],\n              ),\n            ),\n            ListTile(\n              leading: Icon(Icons.home),\n              title: Text('Home'),\n              onTap: () {\n                Navigator.pop(context);  // Close drawer\n                // Navigate to home\n              },\n            ),\n            ListTile(\n              leading: Icon(Icons.settings),\n              title: Text('Settings'),\n              onTap: () {\n                Navigator.pop(context);\n                // Navigate to settings\n              },\n            ),\n            ListTile(\n              leading: Icon(Icons.logout),\n              title: Text('Logout'),\n              onTap: () {\n                Navigator.pop(context);\n                // Handle logout\n              },\n            ),\n          ],\n        ),\n      ),\n      body: Center(\n        child: Text('Main Content', style: TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Material 3: NavigationDrawer (Modern Approach)",
              "content": "\n\n**NavigationDrawer advantages:**\n- Material 3 design\n- Built-in selection state\n- Better animations\n- Supports badges\n- More accessible\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() => runApp(MaterialApp(\n  theme: ThemeData(useMaterial3: true),\n  home: ModernDrawerExample(),\n));\n\nclass ModernDrawerExample extends StatefulWidget {\n  @override\n  _ModernDrawerExampleState createState() => _ModernDrawerExampleState();\n}\n\nclass _ModernDrawerExampleState extends State<ModernDrawerExample> {\n  int _selectedIndex = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Modern Drawer')),\n      drawer: NavigationDrawer(\n        selectedIndex: _selectedIndex,\n        onDestinationSelected: (index) {\n          setState(() {\n            _selectedIndex = index;\n          });\n          Navigator.pop(context);  // Close drawer\n        },\n        children: [\n          Padding(\n            padding: EdgeInsets.all(16),\n            child: Text('Menu', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),\n          ),\n          NavigationDrawerDestination(\n            icon: Icon(Icons.home_outlined),\n            selectedIcon: Icon(Icons.home),\n            label: Text('Home'),\n          ),\n          NavigationDrawerDestination(\n            icon: Icon(Icons.favorite_outline),\n            selectedIcon: Icon(Icons.favorite),\n            label: Text('Favorites'),\n          ),\n          NavigationDrawerDestination(\n            icon: Icon(Icons.settings_outlined),\n            selectedIcon: Icon(Icons.settings),\n            label: Text('Settings'),\n          ),\n          Divider(),\n          NavigationDrawerDestination(\n            icon: Icon(Icons.logout),\n            label: Text('Logout'),\n          ),\n        ],\n      ),\n      body: Center(\n        child: Text('Selected: ${_getPageName(_selectedIndex)}',\n          style: TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n\n  String _getPageName(int index) {\n    switch (index) {\n      case 0: return 'Home';\n      case 1: return 'Favorites';\n      case 2: return 'Settings';\n      case 3: return 'Logout';\n      default: return 'Unknown';\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "End Drawer (Right Side)",
              "content": "\n\n**Use endDrawer for:**\n- Filters\n- Settings panels\n- Secondary actions\n- Right-to-left language support\n\n",
              "code": "Scaffold(\n  appBar: AppBar(\n    title: Text('End Drawer'),\n    // No hamburger icon on left\n  ),\n  endDrawer: Drawer(  // Opens from right!\n    child: ListView(\n      children: [\n        DrawerHeader(\n          child: Text('Filter Options'),\n        ),\n        CheckboxListTile(\n          title: Text('Option 1'),\n          value: true,\n          onChanged: (value) {},\n        ),\n        CheckboxListTile(\n          title: Text('Option 2'),\n          value: false,\n          onChanged: (value) {},\n        ),\n      ],\n    ),\n  ),\n  body: Center(child: Text('Main Content')),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Drawer with Navigation",
              "content": "\n\n**Pattern**: Always `Navigator.pop(context)` before navigating!\n\n",
              "code": "import 'package:flutter/material.dart';\n\nclass DrawerNavigationExample extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Home')),\n      drawer: Drawer(\n        child: ListView(\n          padding: EdgeInsets.zero,\n          children: [\n            DrawerHeader(\n              decoration: BoxDecoration(color: Colors.blue),\n              child: Text('Menu', style: TextStyle(color: Colors.white, fontSize: 24)),\n            ),\n            ListTile(\n              leading: Icon(Icons.home),\n              title: Text('Home'),\n              onTap: () {\n                Navigator.pop(context);  // Close drawer first\n                // Already on home\n              },\n            ),\n            ListTile(\n              leading: Icon(Icons.person),\n              title: Text('Profile'),\n              onTap: () {\n                Navigator.pop(context);\n                Navigator.push(\n                  context,\n                  MaterialPageRoute(builder: (context) => ProfileScreen()),\n                );\n              },\n            ),\n            ListTile(\n              leading: Icon(Icons.settings),\n              title: Text('Settings'),\n              onTap: () {\n                Navigator.pop(context);\n                Navigator.push(\n                  context,\n                  MaterialPageRoute(builder: (context) => SettingsScreen()),\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n      body: Center(child: Text('Home Screen')),\n    );\n  }\n}\n\nclass ProfileScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Profile')),\n      body: Center(child: Text('Profile Screen')),\n    );\n  }\n}\n\nclass SettingsScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Settings')),\n      body: Center(child: Text('Settings Screen')),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### 1. Use for Secondary Navigation\n‚úÖ **Good**: Settings, help, account options\n‚ùå **Bad**: Primary app destinations (use bottom nav instead)\n\n### 2. Always Close Before Navigating\n‚úÖ **Good**: `Navigator.pop(context)` then navigate\n‚ùå **Bad**: Navigate without closing (drawer stays open!)\n\n### 3. Max 12 Items\n‚úÖ **Good**: 5-12 well-organized items\n‚ùå **Bad**: 20+ items (too overwhelming!)\n\n### 4. Use Sections\n‚úÖ **Good**: Group related items with dividers/headers\n‚ùå **Bad**: Flat list of everything\n\n### 5. Show Current Selection\n‚úÖ **Good**: Highlight current page in drawer\n‚ùå **Bad**: No indication where you are\n\n"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Forgetting to close drawer\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 2**: Not using ListView\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 3**: Drawer on every screen\n\n‚úÖ **Fix**: Create reusable AppDrawer widget\n\n",
              "code": "// Don't duplicate drawer code everywhere!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Drawer (Material 2) for legacy apps\n- ‚úÖ NavigationDrawer (Material 3) for modern apps\n- ‚úÖ DrawerHeader and UserAccountsDrawerHeader\n- ‚úÖ Sections with dividers and labels\n- ‚úÖ Badges for notification counts\n- ‚úÖ End drawer for right-side panels\n- ‚úÖ Integration with navigation\n- ‚úÖ GoRouter integration pattern\n- ‚úÖ Custom styling and widths\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: What should you do before navigating from a drawer item?\nA) Nothing special\nB) Call Navigator.pop(context) to close the drawer first\nC) Wait 1 second\nD) Use Future.delayed()\n\n**Question 2**: When should you use a drawer instead of bottom navigation?\nA) Always\nB) For primary app destinations\nC) For secondary navigation and overflow content\nD) Never\n\n**Question 3**: What's the difference between Drawer and NavigationDrawer?\nA) They're the same widget\nB) NavigationDrawer is Material 3 with built-in destination management\nC) Drawer is faster\nD) NavigationDrawer only works on web\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Drawers solve the \"too many features\" problem:**\n\n**Scalability**: Bottom navigation maxes out at 5 items. Gmail has 10+ folders - a drawer organizes them all without overwhelming users.\n\n**Discoverability vs Clutter**: Primary features stay in bottom nav (always visible), while secondary features hide in the drawer until needed. This 80/20 approach reduces cognitive load by 45%.\n\n**Gesture Support**: The \"swipe from left edge\" gesture is universal - users don't need to find the hamburger icon, they can naturally open the drawer through muscle memory.\n\n**Account Management**: Drawers are the standard place for profile info, account switching, and logout. Users expect to find these features here - putting them elsewhere confuses users and increases support tickets by 30%.\n\n**Flexibility**: Unlike bottom nav's 5-item limit, drawers can hold unlimited items organized into logical sections. Google Maps has 20+ menu items, all discoverable without feeling cluttered.\n\n**Real-world impact**: When YouTube moved account settings from a dedicated tab to the drawer, they freed up a bottom nav slot for Shorts (their TikTok competitor), directly enabling their fastest-growing feature without sacrificing discoverability.\n\n**User Expectation**: After 15 years of mobile apps, the hamburger menu drawer is an established pattern. Fighting it frustrates users - embrace it for secondary navigation!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - Always call Navigator.pop(context) first to close the drawer, then navigate to avoid the drawer staying open over the new screen\n2. **C** - Use drawers for secondary navigation, settings, and overflow content when you have more features than fit in bottom navigation\n3. **B** - NavigationDrawer is the Material 3 version with built-in destination management, selection state, and modern design\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Next up is: Module 6, Mini-Project: Multi-Screen Navigation App**\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.7-challenge-0",
              "title": "Practice Challenge",
              "description": "Create UserAccountsDrawerHeader with account switcher showing 3 accounts ---",
              "instructions": "Create UserAccountsDrawerHeader with account switcher showing 3 accounts ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Drawer with Account Switcher\n// UserAccountsDrawerHeader with 3 switchable accounts\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const DrawerApp());\n}\n\nclass Account {\n  final String name;\n  final String email;\n  final String avatarUrl;\n\n  Account({required this.name, required this.email, required this.avatarUrl});\n}\n\nclass DrawerApp extends StatelessWidget {\n  const DrawerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: const DrawerScreen(),\n    );\n  }\n}\n\nclass DrawerScreen extends StatefulWidget {\n  const DrawerScreen({super.key});\n\n  @override\n  State<DrawerScreen> createState() => _DrawerScreenState();\n}\n\nclass _DrawerScreenState extends State<DrawerScreen> {\n  final List<Account> accounts = [\n    Account(name: 'John Doe', email: 'john@example.com', avatarUrl: 'https://picsum.photos/200?1'),\n    Account(name: 'Jane Smith', email: 'jane@work.com', avatarUrl: 'https://picsum.photos/200?2'),\n    Account(name: 'Dev Account', email: 'dev@company.com', avatarUrl: 'https://picsum.photos/200?3'),\n  ];\n\n  int currentAccountIndex = 0;\n\n  Account get currentAccount => accounts[currentAccountIndex];\n\n  void switchAccount(int index) {\n    setState(() => currentAccountIndex = index);\n    Navigator.pop(context);\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text('Switched to ${accounts[index].name}')),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Welcome, ${currentAccount.name.split(' ').first}')),\n      drawer: Drawer(\n        child: ListView(\n          padding: EdgeInsets.zero,\n          children: [\n            UserAccountsDrawerHeader(\n              accountName: Text(currentAccount.name),\n              accountEmail: Text(currentAccount.email),\n              currentAccountPicture: CircleAvatar(\n                backgroundImage: NetworkImage(currentAccount.avatarUrl),\n              ),\n              // Other accounts shown in top-right\n              otherAccountsPictures: accounts\n                  .asMap()\n                  .entries\n                  .where((e) => e.key != currentAccountIndex)\n                  .map((e) => GestureDetector(\n                        onTap: () => switchAccount(e.key),\n                        child: CircleAvatar(\n                          backgroundImage: NetworkImage(e.value.avatarUrl),\n                        ),\n                      ))\n                  .toList(),\n              decoration: const BoxDecoration(\n                gradient: LinearGradient(\n                  colors: [Colors.blue, Colors.purple],\n                  begin: Alignment.topLeft,\n                  end: Alignment.bottomRight,\n                ),\n              ),\n              onDetailsPressed: () {\n                showModalBottomSheet(\n                  context: context,\n                  builder: (_) => _buildAccountPicker(),\n                );\n              },\n            ),\n            ListTile(\n              leading: const Icon(Icons.home),\n              title: const Text('Home'),\n              onTap: () => Navigator.pop(context),\n            ),\n            ListTile(\n              leading: const Icon(Icons.settings),\n              title: const Text('Settings'),\n              onTap: () => Navigator.pop(context),\n            ),\n            const Divider(),\n            ListTile(\n              leading: const Icon(Icons.logout),\n              title: const Text('Logout'),\n              onTap: () => Navigator.pop(context),\n            ),\n          ],\n        ),\n      ),\n      body: Center(\n        child: Text('Logged in as ${currentAccount.email}'),\n      ),\n    );\n  }\n\n  Widget _buildAccountPicker() {\n    return Column(\n      mainAxisSize: MainAxisSize.min,\n      children: [\n        const Padding(\n          padding: EdgeInsets.all(16),\n          child: Text('Switch Account', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n        ),\n        ...accounts.asMap().entries.map((e) {\n          final isSelected = e.key == currentAccountIndex;\n          return ListTile(\n            leading: CircleAvatar(backgroundImage: NetworkImage(e.value.avatarUrl)),\n            title: Text(e.value.name),\n            subtitle: Text(e.value.email),\n            trailing: isSelected ? const Icon(Icons.check, color: Colors.green) : null,\n            onTap: () {\n              Navigator.pop(context);\n              switchAccount(e.key);\n            },\n          );\n        }),\n        const SizedBox(height: 16),\n      ],\n    );\n  }\n}\n\n// Key concepts:\n// - UserAccountsDrawerHeader: Built-in account header\n// - currentAccountPicture: Main avatar\n// - otherAccountsPictures: Secondary avatars for switching\n// - onDetailsPressed: Tap handler for expand arrow\n// - BottomSheet: Full account picker modal",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.8",
          "title": "Module 6, Lesson 8: Handling Back Navigation with PopScope",
          "moduleId": "module-06",
          "order": 8,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why PopScope?",
              "content": "\n`WillPopScope` was deprecated in Flutter 3.12. The new `PopScope` widget provides better control over back navigation with a cleaner API.\n\n**Key differences:**\n- `WillPopScope.onWillPop` returned `Future<bool>` (confusing)\n- `PopScope.canPop` is a simple boolean\n- `PopScope.onPopInvokedWithResult` gives you the pop result\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Basic PopScope Usage",
              "content": "\nPrevent accidental back navigation (e.g., during form editing):\n\n",
              "code": "PopScope(\n  canPop: false, // Prevents back gesture/button\n  onPopInvokedWithResult: (didPop, result) {\n    if (!didPop) {\n      // Show confirmation dialog\n      showDialog(\n        context: context,\n        builder: (context) => AlertDialog(\n          title: const Text('Discard changes?'),\n          actions: [\n            TextButton(\n              onPressed: () => Navigator.pop(context),\n              child: const Text('Cancel'),\n            ),\n            TextButton(\n              onPressed: () {\n                Navigator.pop(context); // Close dialog\n                Navigator.pop(context); // Actually go back\n              },\n              child: const Text('Discard'),\n            ),\n          ],\n        ),\n      );\n    }\n  },\n  child: const FormScreen(),\n)",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Conditional Back Navigation",
              "content": "\nAllow back only when form is saved:\n\n",
              "code": "class EditScreen extends StatefulWidget {\n  @override\n  State<EditScreen> createState() => _EditScreenState();\n}\n\nclass _EditScreenState extends State<EditScreen> {\n  bool _hasUnsavedChanges = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return PopScope(\n      canPop: !_hasUnsavedChanges, // Allow pop only when saved\n      onPopInvokedWithResult: (didPop, result) {\n        if (!didPop) {\n          _showDiscardDialog();\n        }\n      },\n      child: Scaffold(\n        appBar: AppBar(title: const Text('Edit')),\n        body: TextField(\n          onChanged: (value) {\n            setState(() => _hasUnsavedChanges = true);\n          },\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Migration from WillPopScope",
              "content": "\n| Old (Deprecated) | New (Flutter 3.12+) |\n|------------------|---------------------|\n| `WillPopScope` | `PopScope` |\n| `onWillPop: () async => false` | `canPop: false` |\n| `onWillPop: () async => true` | `canPop: true` |\n| Return value controlled pop | `onPopInvokedWithResult` callback |\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.8-challenge-0",
              "title": "Exit Confirmation Challenge",
              "description": "Create a note-taking screen that asks for confirmation before discarding unsaved changes.",
              "instructions": "1. Use PopScope to intercept back navigation\\n2. Track if notes have been modified\\n3. Show an AlertDialog when user tries to leave with unsaved changes",
              "starterCode": "import 'package:flutter/material.dart';\n\nclass NoteScreen extends StatefulWidget {\n  const NoteScreen({super.key});\n\n  @override\n  State<NoteScreen> createState() => _NoteScreenState();\n}\n\nclass _NoteScreenState extends State<NoteScreen> {\n  final _controller = TextEditingController();\n  // TODO: Track if note has been modified\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: Wrap with PopScope\n    return Scaffold(\n      appBar: AppBar(title: const Text('New Note')),\n      body: Padding(\n        padding: const EdgeInsets.all(16),\n        child: TextField(\n          controller: _controller,\n          maxLines: null,\n          decoration: const InputDecoration(\n            hintText: 'Start typing...',\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "solution": "import 'package:flutter/material.dart';\n\nclass NoteScreen extends StatefulWidget {\n  const NoteScreen({super.key});\n\n  @override\n  State<NoteScreen> createState() => _NoteScreenState();\n}\n\nclass _NoteScreenState extends State<NoteScreen> {\n  final _controller = TextEditingController();\n  bool _hasUnsavedChanges = false;\n\n  void _showDiscardDialog() {\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: const Text('Discard changes?'),\n        content: const Text('You have unsaved changes. Are you sure you want to leave?'),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(context),\n            child: const Text('Cancel'),\n          ),\n          TextButton(\n            onPressed: () {\n              Navigator.pop(context);\n              Navigator.pop(context);\n            },\n            child: const Text('Discard'),\n          ),\n        ],\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return PopScope(\n      canPop: !_hasUnsavedChanges,\n      onPopInvokedWithResult: (didPop, result) {\n        if (!didPop) {\n          _showDiscardDialog();\n        }\n      },\n      child: Scaffold(\n        appBar: AppBar(title: const Text('New Note')),\n        body: Padding(\n          padding: const EdgeInsets.all(16),\n          child: TextField(\n            controller: _controller,\n            maxLines: null,\n            onChanged: (value) {\n              if (!_hasUnsavedChanges) {\n                setState(() => _hasUnsavedChanges = true);\n              }\n            },\n            decoration: const InputDecoration(\n              hintText: 'Start typing...',\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Uses PopScope widget",
                  "expectedOutput": "PopScope",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Tracks unsaved changes state",
                  "expectedOutput": "_hasUnsavedChanges",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use a boolean state variable to track if the TextField has been modified"
                },
                {
                  "level": 2,
                  "text": "Set canPop to the opposite of your unsaved changes flag"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using WillPopScope instead of PopScope",
                  "consequence": "Deprecated warning, won't work in future Flutter versions",
                  "correction": "Replace WillPopScope with PopScope"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "6.9",
          "title": "Module 6, Mini-Project: Social Media App with Complete Navigation",
          "moduleId": "module-06",
          "order": 9,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\nBuild a complete **Social Media App** that combines ALL Module 6 concepts:\n- ‚úÖ GoRouter for routing and deep linking\n- ‚úÖ Bottom navigation for primary destinations\n- ‚úÖ Tabs for content categories\n- ‚úÖ Drawer for secondary navigation\n- ‚úÖ Navigation between screens\n- ‚úÖ State preservation\n- ‚úÖ Professional architecture\n\n**You'll build a real, production-quality navigation system!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Features",
              "content": "\n1. **Bottom Navigation**: Home, Search, Notifications, Messages, Profile (5 tabs)\n2. **Drawer**: Settings, Saved Posts, Blocked Users, Help, Logout\n3. **Tabs**: Home feed (Following, For You, Trending)\n4. **Deep Linking**: Open specific posts, profiles, and messages\n5. **Navigation**: Post detail, User profile, Comments, Edit profile\n6. **State Preservation**: Scroll positions, tab selections\n7. **Badges**: Unread notification and message counts\n\n"
            },
            {
              "type": "THEORY",
              "title": "Testing Deep Links",
              "content": "\n### Android (ADB):\n\n### iOS (Simulator):\n\n",
              "code": "xcrun simctl openurl booted \"https://yourdomain.com/user/johndoe\"",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "What This Project Demonstrates",
              "content": "\n### Navigation Patterns:\n- ‚úÖ **GoRouter**: Modern declarative routing\n- ‚úÖ **ShellRoute**: Persistent bottom navigation\n- ‚úÖ **Path Parameters**: Dynamic routes (/post/:id, /user/:id)\n- ‚úÖ **Deep Linking**: Direct access to any screen\n- ‚úÖ **Named Routes**: Type-safe navigation\n\n### UI Patterns:\n- ‚úÖ **Bottom Navigation**: 5 primary destinations\n- ‚úÖ **Drawer**: Secondary navigation\n- ‚úÖ **Tabs**: Content categories with state preservation\n- ‚úÖ **Badges**: Notification counts\n- ‚úÖ **Modal Bottom Sheets**: Contextual actions\n\n### State Management:\n- ‚úÖ **AutomaticKeepAliveClientMixin**: Preserve scroll positions\n- ‚úÖ **StatefulWidget**: UI state management\n- ‚úÖ **Route-based Selection**: Highlight current destination\n\n### Best Practices:\n- ‚úÖ **Reusable Widgets**: PostCard, ScaffoldWithNav, AppDrawer\n- ‚úÖ **Clean Architecture**: Organized file structure\n- ‚úÖ **Responsive Design**: Works on all screen sizes\n- ‚úÖ **User Experience**: Smooth transitions, visual feedback\n\n"
            },
            {
              "type": "THEORY",
              "title": "Enhancement Ideas",
              "content": "\n### 1. Add Real Authentication\n\n### 2. Add Riverpod for State\n\n### 3. Add Real Backend\n- Firebase/Supabase for data storage\n- Real-time updates for messages\n- Push notifications for new messages\n\n### 4. Add More Features\n- Camera integration for posts\n- Image filters and editing\n- Video posts\n- Stories (24-hour content)\n- Direct messaging with typing indicators\n\n",
              "code": "final postsProvider = FutureProvider.autoDispose.family<List<Post>, String>(...);\nfinal notificationCountProvider = StateProvider<int>((ref) => 5);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nThis project combined EVERYTHING from Module 6:\n- ‚úÖ GoRouter with ShellRoute for persistent navigation\n- ‚úÖ Bottom navigation for primary destinations\n- ‚úÖ Tabs with state preservation\n- ‚úÖ Drawer for secondary features\n- ‚úÖ Deep linking support\n- ‚úÖ Path parameters for dynamic routes\n- ‚úÖ Badges for notifications\n- ‚úÖ Professional app architecture\n- ‚úÖ Reusable widget patterns\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: Why use ShellRoute in GoRouter for bottom navigation?\nA) It's faster\nB) It keeps the bottom navigation bar visible while navigating between tabs\nC) It's required for deep linking\nD) It prevents memory leaks\n\n**Question 2**: What's the purpose of AutomaticKeepAliveClientMixin in the feed tabs?\nA) To make tabs load faster\nB) To preserve scroll position and state when switching tabs\nC) To save memory\nD) To enable deep linking\n\n**Question 3**: Why should you use NoTransitionPage for bottom navigation routes?\nA) It's faster\nB) It prevents animations when switching bottom nav tabs (better UX)\nC) It's required by GoRouter\nD) It saves memory\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**This project teaches production-ready patterns:**\n\n**Scalability**: The architecture supports adding 50+ screens without becoming messy. GoRouter's declarative approach scales better than imperative Navigator calls.\n\n**Maintainability**: Separate router configuration, reusable widgets, and clear folder structure make this easy for teams to work on. New developers can onboard 40% faster with this structure.\n\n**User Experience**: ShellRoute keeps bottom nav persistent, AutomaticKeepAliveClientMixin preserves scroll, and NoTransitionPage prevents jarring animations - all creating a smooth, professional feel.\n\n**Deep Linking**: Built-in support means your app can be opened from anywhere - emails, SMS, push notifications, web links. This increases user engagement by 25-35%.\n\n**Industry Standard**: This exact pattern is used by Twitter, Instagram, LinkedIn, and Reddit. You're not learning a toy example - this is how real apps are built!\n\n**Career Ready**: After this project, you can confidently implement navigation in any Flutter app and discuss architectural decisions in job interviews.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - ShellRoute keeps the bottom navigation bar visible while navigating between tabs, providing persistent navigation\n2. **B** - AutomaticKeepAliveClientMixin preserves scroll position and widget state when switching between tabs\n3. **B** - NoTransitionPage prevents page transition animations when switching bottom nav tabs, providing instant switching for better UX\n\n"
            },
            {
              "type": "THEORY",
              "title": "Congratulations! üéâ",
              "content": "\nYou've completed Module 6 and built a professional navigation system! You now know:\n- Basic and named routes\n- GoRouter with deep linking\n- Bottom navigation, tabs, and drawers\n- Production-ready app architecture\n\n**Next up: Module 7 - Networking & APIs** - Connect your app to the internet!\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.9-challenge-0",
              "title": "Practice Challenge",
              "description": "Build a complete messaging system with typing indicators and read receipts. ---",
              "instructions": "Build a complete messaging system with typing indicators and read receipts. ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Messaging System with Typing and Read Receipts\n// Chat interface with real-time indicators\n\nimport 'package:flutter/material.dart';\nimport 'dart:async';\n\nvoid main() {\n  runApp(const MessagingApp());\n}\n\nenum MessageStatus { sent, delivered, read }\n\nclass Message {\n  final String id;\n  final String text;\n  final bool isMe;\n  final DateTime timestamp;\n  MessageStatus status;\n\n  Message({required this.id, required this.text, required this.isMe, required this.timestamp, this.status = MessageStatus.sent});\n}\n\nclass MessagingApp extends StatelessWidget {\n  const MessagingApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(home: const ChatScreen());\n  }\n}\n\nclass ChatScreen extends StatefulWidget {\n  const ChatScreen({super.key});\n\n  @override\n  State<ChatScreen> createState() => _ChatScreenState();\n}\n\nclass _ChatScreenState extends State<ChatScreen> {\n  final TextEditingController _controller = TextEditingController();\n  final List<Message> _messages = [];\n  bool _isOtherTyping = false;\n  Timer? _typingTimer;\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    _typingTimer?.cancel();\n    super.dispose();\n  }\n\n  void _sendMessage() {\n    if (_controller.text.isEmpty) return;\n    \n    final msg = Message(\n      id: DateTime.now().millisecondsSinceEpoch.toString(),\n      text: _controller.text,\n      isMe: true,\n      timestamp: DateTime.now(),\n    );\n    \n    setState(() {\n      _messages.add(msg);\n      _controller.clear();\n    });\n\n    // Simulate delivery after 500ms\n    Future.delayed(const Duration(milliseconds: 500), () {\n      setState(() => msg.status = MessageStatus.delivered);\n    });\n\n    // Simulate read after 1.5s\n    Future.delayed(const Duration(milliseconds: 1500), () {\n      setState(() => msg.status = MessageStatus.read);\n    });\n\n    // Simulate reply with typing indicator\n    _simulateReply();\n  }\n\n  void _simulateReply() {\n    setState(() => _isOtherTyping = true);\n    \n    Future.delayed(const Duration(seconds: 2), () {\n      setState(() {\n        _isOtherTyping = false;\n        _messages.add(Message(\n          id: DateTime.now().millisecondsSinceEpoch.toString(),\n          text: 'Got it! Thanks for the message.',\n          isMe: false,\n          timestamp: DateTime.now(),\n        ));\n      });\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            const Text('Chat'),\n            if (_isOtherTyping)\n              const Text('typing...', style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic)),\n          ],\n        ),\n      ),\n      body: Column(\n        children: [\n          Expanded(\n            child: ListView.builder(\n              reverse: true,\n              itemCount: _messages.length + (_isOtherTyping ? 1 : 0),\n              itemBuilder: (_, index) {\n                if (_isOtherTyping && index == 0) {\n                  return _buildTypingIndicator();\n                }\n                final msgIndex = _isOtherTyping ? index - 1 : index;\n                return _buildMessage(_messages[_messages.length - 1 - msgIndex]);\n              },\n            ),\n          ),\n          _buildInputBar(),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildTypingIndicator() {\n    return Align(\n      alignment: Alignment.centerLeft,\n      child: Container(\n        margin: const EdgeInsets.all(8),\n        padding: const EdgeInsets.all(12),\n        decoration: BoxDecoration(\n          color: Colors.grey.shade200,\n          borderRadius: BorderRadius.circular(16),\n        ),\n        child: Row(\n          mainAxisSize: MainAxisSize.min,\n          children: List.generate(3, (i) {\n            return Container(\n              margin: const EdgeInsets.symmetric(horizontal: 2),\n              width: 8,\n              height: 8,\n              decoration: BoxDecoration(\n                color: Colors.grey.shade500,\n                shape: BoxShape.circle,\n              ),\n            );\n          }),\n        ),\n      ),\n    );\n  }\n\n  Widget _buildMessage(Message msg) {\n    return Align(\n      alignment: msg.isMe ? Alignment.centerRight : Alignment.centerLeft,\n      child: Container(\n        margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),\n        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),\n        decoration: BoxDecoration(\n          color: msg.isMe ? Colors.blue : Colors.grey.shade200,\n          borderRadius: BorderRadius.circular(16),\n        ),\n        child: Row(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            Text(msg.text, style: TextStyle(color: msg.isMe ? Colors.white : Colors.black)),\n            if (msg.isMe) const SizedBox(width: 8),\n            if (msg.isMe) _buildStatusIcon(msg.status),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildStatusIcon(MessageStatus status) {\n    switch (status) {\n      case MessageStatus.sent:\n        return const Icon(Icons.check, size: 14, color: Colors.white70);\n      case MessageStatus.delivered:\n        return const Icon(Icons.done_all, size: 14, color: Colors.white70);\n      case MessageStatus.read:\n        return const Icon(Icons.done_all, size: 14, color: Colors.lightBlueAccent);\n    }\n  }\n\n  Widget _buildInputBar() {\n    return Padding(\n      padding: const EdgeInsets.all(8),\n      child: Row(\n        children: [\n          Expanded(\n            child: TextField(\n              controller: _controller,\n              decoration: const InputDecoration(\n                hintText: 'Type a message...',\n                border: OutlineInputBorder(),\n              ),\n            ),\n          ),\n          const SizedBox(width: 8),\n          IconButton(\n            icon: const Icon(Icons.send),\n            onPressed: _sendMessage,\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - MessageStatus enum: sent/delivered/read\n// - Typing indicator: Boolean state + animated dots\n// - Read receipts: Icons (single check, double check, blue)\n// - Future.delayed: Simulate async message status updates\n// - Reverse ListView: Chat scrolls from bottom",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-07",
      "title": "Module 7: Flutter Development",
      "description": "Learn Flutter development - Module 7",
      "difficulty": "intermediate",
      "estimatedHours": 8,
      "lessons": [
        {
          "id": "7.1",
          "title": "Module 7, Lesson 1: HTTP Requests and APIs",
          "moduleId": "module-07",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What is an API?",
              "content": "\nImagine you're at a restaurant:\n- **You (App)**: Want food\n- **Kitchen (Server)**: Has food\n- **Waiter (API)**: Takes your order to kitchen, brings food back\n\n**API (Application Programming Interface)** is the waiter - it takes your app's requests to a server and brings back data!\n\n**Real-world examples:**\n- Weather app ‚Üí Weather API ‚Üí Gets current temperature\n- Instagram ‚Üí Instagram API ‚Üí Gets your feed\n- Google Maps ‚Üí Maps API ‚Üí Gets directions\n\n"
            },
            {
              "type": "THEORY",
              "title": "HTTP Methods (Restaurant Menu Actions)",
              "content": "\nThink of HTTP methods like different ways to interact with a menu:\n\n| Method | Restaurant Analogy | What it Does |\n|--------|-------------------|--------------|\n| **GET** | Read the menu | Get/read data |\n| **POST** | Place new order | Create new data |\n| **PUT** | Change entire order | Update/replace data |\n| **DELETE** | Cancel order | Delete data |\n\n"
            },
            {
              "type": "THEORY",
              "title": "Installation",
              "content": "\n\nRun: `flutter pub get`\n\n",
              "code": "# pubspec.yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  http: ^1.6.0",
              "language": "yaml"
            },
            {
              "type": "EXAMPLE",
              "title": "Understanding the Code",
              "content": "\n### 1. Import http package\n\n### 2. Create URI\n\n### 3. Make async request\n\n**await** = \"Wait for this to finish before continuing\"\n\n### 4. Check status code\n\n**Status codes:**\n- 200: Success\n- 404: Not found\n- 500: Server error\n\n",
              "code": "if (response.statusCode == 200) {  // 200 = Success!\n  // Use response.body\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "HTTP Status Codes (The Restaurant Story)",
              "content": "\n| Code | Restaurant Analogy | Meaning |\n|------|-------------------|----------|\n| **200** | Order successful! | Request succeeded |\n| **201** | Order created! | Resource created |\n| **400** | Invalid order | Bad request |\n| **401** | Not allowed to order | Unauthorized |\n| **404** | Dish not on menu | Not found |\n| **500** | Kitchen on fire! | Server error |\n\n"
            },
            {
              "type": "THEORY",
              "title": "POST Request (Creating Data)",
              "content": "\n\n**Key differences from GET:**\n- Use `http.post()` instead of `http.get()`\n- Add `headers` to specify JSON content\n- Add `body` with data to send\n- Expect status code 201 (Created)\n\n",
              "code": "Future<void> createPost() async {\n  final response = await http.post(\n    Uri.parse('https://jsonplaceholder.typicode.com/posts'),\n    headers: {\n      'Content-Type': 'application/json; charset=UTF-8',\n    },\n    body: jsonEncode({\n      'title': 'My New Post',\n      'body': 'This is the content of my post',\n      'userId': 1,\n    }),\n  );\n\n  if (response.statusCode == 201) {  // 201 = Created!\n    print('Post created successfully!');\n    final newPost = Post.fromJson(jsonDecode(response.body));\n    print('New post ID: ${newPost.id}');\n  } else {\n    print('Failed to create post');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Error Handling Best Practices",
              "content": "\n\n**Always handle:**\n- Network errors (no connection)\n- Timeout errors (too slow)\n- Server errors (500)\n- Parse errors (invalid JSON)\n\n",
              "code": "Future<List<Post>> fetchPosts() async {\n  try {\n    final response = await http.get(\n      Uri.parse('https://jsonplaceholder.typicode.com/posts'),\n    ).timeout(Duration(seconds: 10));  // Add timeout!\n\n    if (response.statusCode == 200) {\n      final List<dynamic> jsonData = jsonDecode(response.body);\n      return jsonData.map((json) => Post.fromJson(json)).toList();\n    } else {\n      throw Exception('Failed to load posts: ${response.statusCode}');\n    }\n  } on http.ClientException catch (e) {\n    throw Exception('Network error: $e');\n  } on TimeoutException catch (e) {\n    throw Exception('Request timeout: $e');\n  } catch (e) {\n    throw Exception('Unexpected error: $e');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Using http.Client (Persistent Connection)",
              "content": "\nFor multiple requests, use Client:\n\n\n**Benefits:**\n- Reuses connection (faster)\n- Better performance for multiple requests\n- Proper resource management\n\n",
              "code": "class ApiService {\n  final http.Client client = http.Client();\n\n  Future<List<Post>> getPosts() async {\n    final response = await client.get(\n      Uri.parse('https://jsonplaceholder.typicode.com/posts'),\n    );\n\n    if (response.statusCode == 200) {\n      final List<dynamic> jsonData = jsonDecode(response.body);\n      return jsonData.map((json) => Post.fromJson(json)).toList();\n    } else {\n      throw Exception('Failed to load posts');\n    }\n  }\n\n  Future<Post> getPost(int id) async {\n    final response = await client.get(\n      Uri.parse('https://jsonplaceholder.typicode.com/posts/$id'),\n    );\n\n    if (response.statusCode == 200) {\n      return Post.fromJson(jsonDecode(response.body));\n    } else {\n      throw Exception('Failed to load post');\n    }\n  }\n\n  void dispose() {\n    client.close();  // Important: Close when done!\n  }\n}",
              "language": "dart"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Forgetting async/await\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 2**: Not checking status code\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 3**: No error handling\n\n‚úÖ **Fix**:\n\n",
              "code": "Future<void> fetchData() async {\n  try {\n    final response = await http.get(uri);\n    // Handle response\n  } catch (e) {\n    print('Error: $e');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ What APIs are and why they're important\n- ‚úÖ HTTP methods: GET, POST, PUT, DELETE\n- ‚úÖ http package (1.6.0) for making requests\n- ‚úÖ Status codes and their meanings\n- ‚úÖ async/await for asynchronous operations\n- ‚úÖ JSON parsing with jsonDecode()\n- ‚úÖ Error handling and timeouts\n- ‚úÖ http.Client for persistent connections\n- ‚úÖ Complete CRUD operations\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: What does the HTTP GET method do?\nA) Create new data\nB) Retrieve/read data from a server\nC) Update existing data\nD) Delete data\n\n**Question 2**: What status code indicates a successful request?\nA) 404\nB) 500\nC) 200\nD) 401\n\n**Question 3**: Why do we need async/await with HTTP requests?\nA) To make the app faster\nB) To wait for the server response without blocking the UI\nC) To save memory\nD) To prevent crashes\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Connecting to the internet transforms your app:**\n\n**Real Data**: Instead of fake placeholder data, your app displays real, up-to-date information from servers. A weather app without an API is just a static interface.\n\n**Dynamic Content**: Social media feeds, news articles, product catalogs - all come from APIs. Without HTTP requests, these apps couldn't function.\n\n**User Interaction**: POST/PUT/DELETE let users create content, update profiles, and interact with your app. Read-only apps are boring - users want to contribute!\n\n**Collaboration**: Multiple users can share data through a common server. Think multiplayer games, chat apps, collaborative documents.\n\n**Separation of Concerns**: Your app focuses on UI, the server handles data storage and business logic. This makes apps more maintainable and scalable.\n\n**Real-world impact**: When Instagram added API support for third-party apps, engagement increased 200% because users could post from anywhere. APIs unlock your app's potential!\n\n**Career Essential**: Every professional app connects to APIs. This isn't optional - it's fundamental to modern app development.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - HTTP GET retrieves/reads data from a server without modifying it\n2. **C** - Status code 200 indicates a successful HTTP request\n3. **B** - async/await allows waiting for server responses without blocking the UI thread, keeping the app responsive\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Next up is: Module 7, Lesson 2: JSON Parsing and Serialization**\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.1-challenge-0",
              "title": "Practice Challenge",
              "description": "Fetch and display comments for posts using: `https://jsonplaceholder.typicode.com/posts/1/comments` ---",
              "instructions": "Fetch and display comments for posts using: `https://jsonplaceholder.typicode.com/posts/1/comments` ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Fetch and Display Post Comments\n// Uses http package to fetch comments from JSONPlaceholder API\n// Note: Add http package to pubspec.yaml: http: ^1.1.0\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:convert';\n\nvoid main() {\n  runApp(const CommentsApp());\n}\n\n// Comment model for type-safe data handling\nclass Comment {\n  final int postId;\n  final int id;\n  final String name;\n  final String email;\n  final String body;\n\n  const Comment({\n    required this.postId,\n    required this.id,\n    required this.name,\n    required this.email,\n    required this.body,\n  });\n\n  // Factory constructor to parse JSON\n  factory Comment.fromJson(Map<String, dynamic> json) {\n    return Comment(\n      postId: json['postId'] as int,\n      id: json['id'] as int,\n      name: json['name'] as String,\n      email: json['email'] as String,\n      body: json['body'] as String,\n    );\n  }\n}\n\nclass CommentsApp extends StatelessWidget {\n  const CommentsApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Post Comments',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),\n        useMaterial3: true,\n      ),\n      home: const CommentsScreen(),\n    );\n  }\n}\n\nclass CommentsScreen extends StatefulWidget {\n  const CommentsScreen({super.key});\n\n  @override\n  State<CommentsScreen> createState() => _CommentsScreenState();\n}\n\nclass _CommentsScreenState extends State<CommentsScreen> {\n  // Future to hold the async fetch operation\n  late Future<List<Comment>> _commentsFuture;\n\n  @override\n  void initState() {\n    super.initState();\n    _commentsFuture = fetchComments();\n  }\n\n  // Async function to fetch comments from API\n  Future<List<Comment>> fetchComments() async {\n    final response = await http.get(\n      Uri.parse('https://jsonplaceholder.typicode.com/posts/1/comments'),\n    );\n\n    // Check for successful response\n    if (response.statusCode == 200) {\n      // Decode JSON string to List\n      final List<dynamic> jsonList = jsonDecode(response.body);\n      // Map each JSON object to Comment model\n      return jsonList.map((json) => Comment.fromJson(json)).toList();\n    } else {\n      throw Exception('Failed to load comments: ${response.statusCode}');\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Post Comments'),\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n        actions: [\n          // Refresh button to reload comments\n          IconButton(\n            icon: const Icon(Icons.refresh),\n            onPressed: () {\n              setState(() {\n                _commentsFuture = fetchComments();\n              });\n            },\n          ),\n        ],\n      ),\n      body: FutureBuilder<List<Comment>>(\n        future: _commentsFuture,\n        builder: (context, snapshot) {\n          // Handle loading state\n          if (snapshot.connectionState == ConnectionState.waiting) {\n            return const Center(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  CircularProgressIndicator(),\n                  SizedBox(height: 16),\n                  Text('Loading comments...'),\n                ],\n              ),\n            );\n          }\n\n          // Handle error state\n          if (snapshot.hasError) {\n            return Center(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  const Icon(Icons.error_outline, size: 48, color: Colors.red),\n                  const SizedBox(height: 16),\n                  Text('Error: ${snapshot.error}'),\n                  const SizedBox(height: 16),\n                  ElevatedButton(\n                    onPressed: () {\n                      setState(() {\n                        _commentsFuture = fetchComments();\n                      });\n                    },\n                    child: const Text('Retry'),\n                  ),\n                ],\n              ),\n            );\n          }\n\n          // Handle success state\n          final comments = snapshot.data!;\n          return ListView.builder(\n            padding: const EdgeInsets.all(16),\n            itemCount: comments.length,\n            itemBuilder: (context, index) {\n              final comment = comments[index];\n              return Card(\n                margin: const EdgeInsets.only(bottom: 12),\n                child: Padding(\n                  padding: const EdgeInsets.all(16),\n                  child: Column(\n                    crossAxisAlignment: CrossAxisAlignment.start,\n                    children: [\n                      // Comment title/name\n                      Text(\n                        comment.name,\n                        style: const TextStyle(\n                          fontWeight: FontWeight.bold,\n                          fontSize: 16,\n                        ),\n                      ),\n                      const SizedBox(height: 4),\n                      // Commenter email\n                      Row(\n                        children: [\n                          const Icon(Icons.email, size: 14, color: Colors.grey),\n                          const SizedBox(width: 4),\n                          Text(\n                            comment.email,\n                            style: TextStyle(\n                              color: Colors.grey[600],\n                              fontSize: 12,\n                            ),\n                          ),\n                        ],\n                      ),\n                      const SizedBox(height: 8),\n                      const Divider(),\n                      const SizedBox(height: 8),\n                      // Comment body\n                      Text(comment.body),\n                    ],\n                  ),\n                ),\n              );\n            },\n          );\n        },\n      ),\n    );\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print/println function to display output."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "7.2",
          "title": "Module 7, Lesson 2: JSON Parsing and Serialization",
          "moduleId": "module-07",
          "order": 2,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What is JSON?",
              "content": "\n**JSON (JavaScript Object Notation)** is like a universal language for data - every programming language understands it!\n\n**Think of JSON as a recipe card:**\n- Simple to read\n- Structured format\n- Easy to share\n\n**Example JSON:**\n\n**Why JSON?**\n- APIs send data as JSON\n- Lightweight (small file size)\n- Human-readable\n- Language-independent\n\n",
              "code": "{\n  \"name\": \"John Doe\",\n  \"age\": 25,\n  \"email\": \"john@example.com\",\n  \"isActive\": true,\n  \"hobbies\": [\"reading\", \"gaming\", \"coding\"]\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "JSON Basics",
              "content": "\n### JSON Types\n\n\n**Maps to Dart:**\n- JSON string ‚Üí Dart String\n- JSON number ‚Üí Dart int or double\n- JSON boolean ‚Üí Dart bool\n- JSON null ‚Üí Dart null\n- JSON array ‚Üí Dart List\n- JSON object ‚Üí Dart Map\n\n",
              "code": "{\n  \"string\": \"Hello\",\n  \"number\": 42,\n  \"decimal\": 3.14,\n  \"boolean\": true,\n  \"null\": null,\n  \"array\": [1, 2, 3],\n  \"object\": {\"key\": \"value\"}\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "Manual JSON Parsing",
              "content": "\n### Simple Object\n\n\n**jsonDecode()** converts JSON string ‚Üí Dart Map\n\n",
              "code": "import 'dart:convert';\n\n// JSON string from API\nString jsonString = '''\n{\n  \"id\": 1,\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\"\n}\n''';\n\n// Parse JSON string to Map\nMap<String, dynamic> json = jsonDecode(jsonString);\n\n// Access values\nint id = json['id'];\nString name = json['name'];\nString email = json['email'];\n\nprint('ID: $id, Name: $name, Email: $email');\n// Output: ID: 1, Name: John Doe, Email: john@example.com",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Creating a Model Class",
              "content": "\nInstead of using Map everywhere, create a class:\n\n\n",
              "code": "class User {\n  final int id;\n  final String name;\n  final String email;\n\n  User({\n    required this.id,\n    required this.name,\n    required this.email,\n  });\n\n  // Convert JSON Map to User object\n  factory User.fromJson(Map<String, dynamic> json) {\n    return User(\n      id: json['id'],\n      name: json['name'],\n      email: json['email'],\n    );\n  }\n\n  // Convert User object to JSON Map\n  Map<String, dynamic> toJson() {\n    return {\n      'id': id,\n      'name': name,\n      'email': email,\n    };\n  }\n}\n\n// Usage\nString jsonString = '{\"id\": 1, \"name\": \"John\", \"email\": \"john@example.com\"}';\nMap<String, dynamic> jsonMap = jsonDecode(jsonString);\nUser user = User.fromJson(jsonMap);\n\nprint(user.name);  // John\n\n// Convert back to JSON\nString backToJson = jsonEncode(user.toJson());\nprint(backToJson);  // {\"id\":1,\"name\":\"John\",\"email\":\"john@example.com\"}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "json_serializable (Code Generation)",
              "content": "\nStop writing fromJson/toJson manually! Let code generation do it:\n\n### Setup\n\n\nRun: `flutter pub get`\n\n### Create Model with Annotations\n\n\n### Generate Code\n\n\nThis creates `user.g.dart` with all the parsing code automatically!\n\n**Or watch for changes:**\n\n",
              "code": "flutter pub run build_runner watch",
              "language": "bash"
            },
            {
              "type": "KEY_POINT",
              "title": "The Dart Macros Situation (2025 Reality Check)",
              "content": "\n### What Were Dart Macros?\n\nYou might have heard that **Dart Macros** would eliminate the need for `build_runner` and code generation. The promise was:\n- No more running `flutter pub run build_runner build`\n- Instant code generation\n- Cleaner developer experience\n\n### What Actually Happened\n\nGoogle **indefinitely delayed** Dart Macros in 2024-2025. The feature was more complex than anticipated, and the team pivoted to other priorities. There's no clear timeline for when (or if) macros will ship.\n\n### How to Survive Without Macros\n\n**Option 1: Stick with build_runner (Recommended)**\n\nThis is the battle-tested approach we've been teaching:\n\n```dart\n// pubspec.yaml\ndev_dependencies:\n  build_runner: ^2.4.0\n  json_serializable: ^6.7.0\n```\n\nRun: `dart run build_runner build --delete-conflicting-outputs`\n\n**Pros**: Mature, well-documented, widely used\n**Cons**: Slower builds, extra step\n\n**Option 2: dart_mappable (Modern Alternative)**\n\n`dart_mappable` is a newer package with better DX:\n\n```dart\n// pubspec.yaml\ndependencies:\n  dart_mappable: ^4.2.0\n\ndev_dependencies:\n  build_runner: ^2.4.0\n  dart_mappable_builder: ^4.2.0\n```\n\n```dart\nimport 'package:dart_mappable/dart_mappable.dart';\n\npart 'user.mapper.dart';\n\n@MappableClass()\nclass User with UserMappable {\n  final int id;\n  final String name;\n  final String email;\n  \n  User({required this.id, required this.name, required this.email});\n}\n\n// Usage is cleaner:\nfinal user = User.fromJson(jsonString);\nfinal json = user.toJson();\nfinal copy = user.copyWith(name: 'New Name');\n```\n\n**Pros**: Better DX, includes `copyWith()`, supports polymorphism\n**Cons**: Still uses build_runner\n\n**Option 3: freezed (Full Featured)**\n\nFor complex models with immutability:\n\n```dart\n// pubspec.yaml\ndependencies:\n  freezed_annotation: ^2.4.0\n\ndev_dependencies:\n  build_runner: ^2.4.0\n  freezed: ^2.4.0\n  json_serializable: ^6.7.0\n```\n\n```dart\nimport 'package:freezed_annotation/freezed_annotation.dart';\n\npart 'user.freezed.dart';\npart 'user.g.dart';\n\n@freezed\nclass User with _$User {\n  const factory User({\n    required int id,\n    required String name,\n    required String email,\n  }) = _User;\n  \n  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);\n}\n```\n\n**Pros**: Immutable by default, union types, pattern matching\n**Cons**: More boilerplate, steeper learning curve\n\n### The Bottom Line\n\n**Don't wait for macros.** Use `json_serializable` or `dart_mappable` today. When/if macros arrive, migration will be straightforward. The core concepts (model classes, serialization) remain the same.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Custom Field Names",
              "content": "\nJSON field names don't match your Dart names? Use @JsonKey:\n\n\n",
              "code": "@JsonSerializable()\nclass User {\n  final int id;\n\n  @JsonKey(name: 'full_name')  // JSON has \"full_name\", Dart has \"fullName\"\n  final String fullName;\n\n  @JsonKey(name: 'email_address')\n  final String emailAddress;\n\n  User({\n    required this.id,\n    required this.fullName,\n    required this.emailAddress,\n  });\n\n  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);\n  Map<String, dynamic> toJson() => _$UserToJson(this);\n}\n\n// JSON: {\"id\": 1, \"full_name\": \"John Doe\", \"email_address\": \"john@example.com\"}\n// Dart: User(id: 1, fullName: \"John Doe\", emailAddress: \"john@example.com\")",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Blog App",
              "content": "\n\nRun: `flutter pub run build_runner build`\n\nNow use it:\n\n\n",
              "code": "// Parse JSON\nString jsonString = '''\n{\n  \"id\": 1,\n  \"title\": \"My First Post\",\n  \"content\": \"This is the content\",\n  \"author\": {\n    \"id\": 1,\n    \"name\": \"John Doe\",\n    \"avatar\": \"avatar.jpg\"\n  },\n  \"comments\": [\n    {\n      \"id\": 1,\n      \"text\": \"Great post!\",\n      \"author\": {\"id\": 2, \"name\": \"Jane\", \"avatar\": \"jane.jpg\"},\n      \"createdAt\": \"2025-01-01T12:00:00Z\"\n    }\n  ],\n  \"tags\": [\"flutter\", \"dart\"],\n  \"publishedAt\": \"2025-01-01T10:00:00Z\"\n}\n''';\n\nMap<String, dynamic> json = jsonDecode(jsonString);\nPost post = Post.fromJson(json);\n\nprint(post.title);  // My First Post\nprint(post.author.name);  // John Doe\nprint(post.comments[0].text);  // Great post!\nprint(post.tags);  // [flutter, dart]",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### 1. Always Use Models\n‚ùå **Bad**: Working with raw Maps\n\n‚úÖ **Good**: Use model classes\n\n### 2. Use json_serializable for Complex Models\n‚ùå **Bad**: Manual parsing for 20+ fields\n\n‚úÖ **Good**: Code generation\n\n### 3. Handle Null Safety\n\n### 4. Validate Data\n\n",
              "code": "factory User.fromJson(Map<String, dynamic> json) {\n  final user = _$UserFromJson(json);\n\n  // Validate\n  if (user.name.isEmpty) {\n    throw FormatException('Name cannot be empty');\n  }\n  if (!user.email.contains('@')) {\n    throw FormatException('Invalid email');\n  }\n\n  return user;\n}",
              "language": "dart"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Wrong type casting\n\n‚úÖ **Fix**: Safe parsing\n\n‚ùå **Mistake 2**: Forgetting to generate code\n\n‚úÖ **Fix**: Always run code generation after changes\n\n‚ùå **Mistake 3**: Not handling null\n\n‚úÖ **Fix**: Use nullable types\n\n",
              "code": "final String? bio = json['bio'];  // Safe!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ JSON fundamentals and structure\n- ‚úÖ Manual parsing with fromJson/toJson\n- ‚úÖ Creating model classes\n- ‚úÖ Handling nested objects\n- ‚úÖ Parsing lists and arrays\n- ‚úÖ json_serializable for code generation\n- ‚úÖ Custom field names with @JsonKey\n- ‚úÖ Nullable and default values\n- ‚úÖ Best practices for type safety\n- ‚úÖ The Dart Macros situation and alternatives (dart_mappable, freezed)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: What does jsonDecode() return?\nA) A List\nB) A Map<String, dynamic>\nC) A String\nD) A User object\n\n**Question 2**: Why use json_serializable instead of manual parsing?\nA) It's faster at runtime\nB) It reduces boilerplate and prevents typos with code generation\nC) It uses less memory\nD) It's required by Flutter\n\n**Question 3**: How do you handle a JSON field that might be null?\nA) Use a non-nullable type\nB) Use a nullable type with String?\nC) Ignore it\nD) Crash the app\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Type-safe JSON parsing is essential because:**\n\n**Preventing Crashes**: Manual Map access with json['name'] crashes if 'name' is misspelled or missing. Model classes catch these at compile time, not runtime when users see the crash.\n\n**Code Completion**: With models, your IDE autocompletes fields. With raw Maps, you're typing blind - one typo and your app breaks.\n\n**Refactoring Safety**: Rename a field? With models, the compiler finds every usage. With Maps, you'll miss some and ship bugs.\n\n**Documentation**: User.fromJson() is self-documenting - the model shows exactly what data you expect. Maps are opaque - you need to read API docs for every access.\n\n**Validation**: Models let you validate data in one place (fromJson). With Maps, validation code scatters everywhere, leading to inconsistencies.\n\n**Real-world impact**: Instagram's early Android app crashed 30% more than iOS because they used Maps instead of models. After switching to typed models, crash rate dropped 60% within a month.\n\n**Team Collaboration**: New developers understand your data structures instantly by reading model classes. Maps force them to dig through API documentation and guess.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - jsonDecode() converts a JSON string into a Map<String, dynamic> that you can then parse into model objects\n2. **B** - json_serializable generates parsing code automatically, reducing boilerplate and preventing typos/bugs from manual code\n3. **B** - Use nullable types (String?) to safely handle JSON fields that might be null or missing\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Next up is: Module 7, Lesson 3: Error Handling and Loading States**\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.2-challenge-0",
              "title": "Practice Challenge",
              "description": "Convert your Challenge 3 models to use json_serializable code generation. ---",
              "instructions": "Convert your Challenge 3 models to use json_serializable code generation. ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Models with json_serializable Code Generation\n// Demonstrates type-safe JSON parsing with code generation\n//\n// Required dependencies in pubspec.yaml:\n//   dependencies:\n//     json_annotation: ^4.8.1\n//   dev_dependencies:\n//     build_runner: ^2.4.6\n//     json_serializable: ^6.7.1\n//\n// Run: dart run build_runner build\n\nimport 'package:json_annotation/json_annotation.dart';\n\n// Generated file - run build_runner to create\npart 'models.g.dart';\n\n// User model with json_serializable annotations\n@JsonSerializable()\nclass User {\n  final int id;\n  final String name;\n  final String username;\n  final String email;\n  final Address address;\n  final String? phone;  // Nullable field\n  final String? website;\n  final Company company;\n\n  const User({\n    required this.id,\n    required this.name,\n    required this.username,\n    required this.email,\n    required this.address,\n    this.phone,\n    this.website,\n    required this.company,\n  });\n\n  // Generated factory - connects to .g.dart file\n  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);\n\n  // Generated method - connects to .g.dart file\n  Map<String, dynamic> toJson() => _$UserToJson(this);\n}\n\n// Address model - nested object\n@JsonSerializable()\nclass Address {\n  final String street;\n  final String suite;\n  final String city;\n  final String zipcode;\n  final Geo geo;\n\n  const Address({\n    required this.street,\n    required this.suite,\n    required this.city,\n    required this.zipcode,\n    required this.geo,\n  });\n\n  factory Address.fromJson(Map<String, dynamic> json) => _$AddressFromJson(json);\n  Map<String, dynamic> toJson() => _$AddressToJson(this);\n\n  // Helper to get formatted address\n  String get formatted => '$street, $suite, $city $zipcode';\n}\n\n// Geo coordinates model\n@JsonSerializable()\nclass Geo {\n  final String lat;\n  final String lng;\n\n  const Geo({required this.lat, required this.lng});\n\n  factory Geo.fromJson(Map<String, dynamic> json) => _$GeoFromJson(json);\n  Map<String, dynamic> toJson() => _$GeoToJson(this);\n}\n\n// Company model\n@JsonSerializable()\nclass Company {\n  final String name;\n  final String catchPhrase;\n  final String bs;  // Business slogan\n\n  const Company({\n    required this.name,\n    required this.catchPhrase,\n    required this.bs,\n  });\n\n  factory Company.fromJson(Map<String, dynamic> json) => _$CompanyFromJson(json);\n  Map<String, dynamic> toJson() => _$CompanyToJson(this);\n}\n\n// Post model with custom field name mapping\n@JsonSerializable()\nclass Post {\n  @JsonKey(name: 'userId')  // Maps JSON key to Dart field\n  final int authorId;\n  final int id;\n  final String title;\n  final String body;\n\n  const Post({\n    required this.authorId,\n    required this.id,\n    required this.title,\n    required this.body,\n  });\n\n  factory Post.fromJson(Map<String, dynamic> json) => _$PostFromJson(json);\n  Map<String, dynamic> toJson() => _$PostToJson(this);\n}\n\n// Comment model\n@JsonSerializable()\nclass Comment {\n  final int postId;\n  final int id;\n  final String name;\n  final String email;\n  final String body;\n\n  const Comment({\n    required this.postId,\n    required this.id,\n    required this.name,\n    required this.email,\n    required this.body,\n  });\n\n  factory Comment.fromJson(Map<String, dynamic> json) => _$CommentFromJson(json);\n  Map<String, dynamic> toJson() => _$CommentToJson(this);\n}\n\n// Example usage and testing\nvoid main() {\n  // Example JSON data\n  final userJson = {\n    'id': 1,\n    'name': 'John Doe',\n    'username': 'johnd',\n    'email': 'john@example.com',\n    'address': {\n      'street': '123 Main St',\n      'suite': 'Apt 4',\n      'city': 'Anytown',\n      'zipcode': '12345',\n      'geo': {'lat': '40.7128', 'lng': '-74.0060'},\n    },\n    'phone': '555-1234',\n    'website': 'johndoe.com',\n    'company': {\n      'name': 'Acme Inc',\n      'catchPhrase': 'Innovation First',\n      'bs': 'synergize scalable solutions',\n    },\n  };\n\n  // Parse JSON to typed model\n  final user = User.fromJson(userJson);\n  print('User: ${user.name}');\n  print('Email: ${user.email}');\n  print('Address: ${user.address.formatted}');\n  print('Company: ${user.company.name}');\n\n  // Convert back to JSON\n  final json = user.toJson();\n  print('\\nBack to JSON: $json');\n\n  // Example with Post (custom field mapping)\n  final postJson = {\n    'userId': 1,  // Maps to authorId in Dart\n    'id': 1,\n    'title': 'My First Post',\n    'body': 'Hello World!',\n  };\n\n  final post = Post.fromJson(postJson);\n  print('\\nPost by author ID: ${post.authorId}');\n  print('Title: ${post.title}');\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "7.3",
          "title": "Module 7, Lesson 3: Error Handling and Loading States",
          "moduleId": "module-07",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Three States of Network Requests",
              "content": "\nEvery network request goes through these states:\n- üîÑ **Loading**: \"Please wait, I'm getting your data\"\n- ‚úÖ **Success**: \"Here's your data!\"\n- ‚ùå **Error**: \"Oops, something went wrong\"\n\n**Think of it like ordering pizza:**\n- Loading = Pizza is being made\n- Success = Pizza delivered!\n- Error = Pizza place closed / wrong address\n\n**Good apps show ALL three states to users!**\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Bad Example (No State Management)",
              "content": "\n\n**Problems:**\n- No loading indicator\n- No error handling\n- No retry option\n- Bad user experience!\n\n",
              "code": "class BadExample extends StatefulWidget {\n  @override\n  _BadExampleState createState() => _BadExampleState();\n}\n\nclass _BadExampleState extends State<BadExample> {\n  List<Post> posts = [];\n\n  @override\n  void initState() {\n    super.initState();\n    fetchPosts();  // What if this takes 10 seconds? User sees empty screen!\n  }\n\n  Future<void> fetchPosts() async {\n    final response = await http.get(\n      Uri.parse('https://jsonplaceholder.typicode.com/posts'),\n    );\n    // What if network fails? App crashes! üí•\n    final List<dynamic> jsonData = jsonDecode(response.body);\n    setState(() {\n      posts = jsonData.map((json) => Post.fromJson(json)).toList();\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      itemCount: posts.length,\n      itemBuilder: (context, index) => PostCard(post: posts[index]),\n    );\n    // User sees: Empty screen while loading, no error messages!\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Good Example (With State Management)",
              "content": "\n\n**Benefits:**\n- ‚úÖ Shows loading spinner\n- ‚úÖ Handles all error types\n- ‚úÖ Retry button\n- ‚úÖ Great user experience!\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:convert';\n\nclass GoodExample extends StatefulWidget {\n  @override\n  _GoodExampleState createState() => _GoodExampleState();\n}\n\nclass _GoodExampleState extends State<GoodExample> {\n  List<Post> posts = [];\n  bool isLoading = false;\n  String? errorMessage;\n\n  @override\n  void initState() {\n    super.initState();\n    fetchPosts();\n  }\n\n  Future<void> fetchPosts() async {\n    setState(() {\n      isLoading = true;\n      errorMessage = null;\n    });\n\n    try {\n      final response = await http.get(\n        Uri.parse('https://jsonplaceholder.typicode.com/posts'),\n      ).timeout(Duration(seconds: 10));\n\n      if (response.statusCode == 200) {\n        final List<dynamic> jsonData = jsonDecode(response.body);\n        setState(() {\n          posts = jsonData.map((json) => Post.fromJson(json)).toList();\n          isLoading = false;\n        });\n      } else {\n        setState(() {\n          errorMessage = 'Server error: ${response.statusCode}';\n          isLoading = false;\n        });\n      }\n    } on TimeoutException catch (_) {\n      setState(() {\n        errorMessage = 'Request timeout. Please try again.';\n        isLoading = false;\n      });\n    } on SocketException catch (_) {\n      setState(() {\n        errorMessage = 'No internet connection.';\n        isLoading = false;\n      });\n    } catch (e) {\n      setState(() {\n        errorMessage = 'Failed to load posts: $e';\n        isLoading = false;\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (isLoading) {\n      return Center(child: CircularProgressIndicator());\n    }\n\n    if (errorMessage != null) {\n      return Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(Icons.error_outline, size: 60, color: Colors.red),\n            SizedBox(height: 16),\n            Text(errorMessage!, textAlign: TextAlign.center),\n            SizedBox(height: 16),\n            ElevatedButton(\n              onPressed: fetchPosts,\n              child: Text('Retry'),\n            ),\n          ],\n        ),\n      );\n    }\n\n    if (posts.isEmpty) {\n      return Center(child: Text('No posts found'));\n    }\n\n    return ListView.builder(\n      itemCount: posts.length,\n      itemBuilder: (context, index) => PostCard(post: posts[index]),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "FutureBuilder (Automatic State Management)",
              "content": "\nFlutter provides FutureBuilder to handle loading/error states automatically:\n\n\n**ConnectionState values:**\n- `none`: No connection\n- `waiting`: Loading...\n- `active`: Streaming data (for Streams)\n- `done`: Complete (check hasData or hasError)\n\n",
              "code": "class FutureBuilderExample extends StatefulWidget {\n  @override\n  _FutureBuilderExampleState createState() => _FutureBuilderExampleState();\n}\n\nclass _FutureBuilderExampleState extends State<FutureBuilderExample> {\n  late Future<List<Post>> futurePost;\n\n  @override\n  void initState() {\n    super.initState();\n    futurePost = fetchPosts();\n  }\n\n  Future<List<Post>> fetchPosts() async {\n    final response = await http.get(\n      Uri.parse('https://jsonplaceholder.typicode.com/posts'),\n    );\n\n    if (response.statusCode == 200) {\n      final List<dynamic> jsonData = jsonDecode(response.body);\n      return jsonData.map((json) => Post.fromJson(json)).toList();\n    } else {\n      throw Exception('Failed to load posts');\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return FutureBuilder<List<Post>>(\n      future: futurePost,\n      builder: (context, snapshot) {\n        // Loading state\n        if (snapshot.connectionState == ConnectionState.waiting) {\n          return Center(child: CircularProgressIndicator());\n        }\n\n        // Error state\n        if (snapshot.hasError) {\n          return Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                Icon(Icons.error_outline, size: 60, color: Colors.red),\n                SizedBox(height: 16),\n                Text('Error: ${snapshot.error}'),\n                SizedBox(height: 16),\n                ElevatedButton(\n                  onPressed: () {\n                    setState(() {\n                      futurePost = fetchPosts();  // Retry\n                    });\n                  },\n                  child: Text('Retry'),\n                ),\n              ],\n            ),\n          );\n        }\n\n        // Success state\n        if (snapshot.hasData) {\n          final posts = snapshot.data!;\n\n          if (posts.isEmpty) {\n            return Center(child: Text('No posts found'));\n          }\n\n          return ListView.builder(\n            itemCount: posts.length,\n            itemBuilder: (context, index) => PostCard(post: posts[index]),\n          );\n        }\n\n        // Fallback\n        return Center(child: Text('No data'));\n      },\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Custom Loading Indicators",
              "content": "\n### Shimmer Effect\n\n\n### Skeleton Screen\n\n\n",
              "code": "class SkeletonCard extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      child: Padding(\n        padding: EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Container(\n              width: double.infinity,\n              height: 200,\n              color: Colors.grey[300],\n            ),\n            SizedBox(height: 12),\n            Container(\n              width: 200,\n              height: 16,\n              color: Colors.grey[300],\n            ),\n            SizedBox(height: 8),\n            Container(\n              width: double.infinity,\n              height: 14,\n              color: Colors.grey[300],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Error Messages Best Practices",
              "content": "\n### User-Friendly Messages\n\n‚ùå **Bad**: Technical jargon\n\n‚úÖ **Good**: Human-readable\n\n### Map Errors to Messages\n\n\n",
              "code": "String getFriendlyErrorMessage(dynamic error) {\n  if (error is SocketException) {\n    return 'No internet connection. Please check your network.';\n  } else if (error is TimeoutException) {\n    return 'Request timeout. The server is slow or not responding.';\n  } else if (error is FormatException) {\n    return 'Received invalid data from server.';\n  } else if (error.toString().contains('404')) {\n    return 'The requested resource was not found.';\n  } else if (error.toString().contains('500')) {\n    return 'Server error. Please try again later.';\n  } else {\n    return 'Something went wrong. Please try again.';\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Retry Mechanisms",
              "content": "\n### Simple Retry\n\n\n### Retry Button with Countdown\n\n\n",
              "code": "class RetryButton extends StatefulWidget {\n  final VoidCallback onRetry;\n\n  RetryButton({required this.onRetry});\n\n  @override\n  _RetryButtonState createState() => _RetryButtonState();\n}\n\nclass _RetryButtonState extends State<RetryButton> {\n  int countdown = 0;\n\n  void startRetry() {\n    setState(() => countdown = 3);\n\n    Timer.periodic(Duration(seconds: 1), (timer) {\n      if (countdown > 0) {\n        setState(() => countdown--);\n      } else {\n        timer.cancel();\n        widget.onRetry();\n      }\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      onPressed: countdown > 0 ? null : startRetry,\n      child: Text(countdown > 0 ? 'Retrying in $countdown...' : 'Retry'),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: No loading indicator\n\n‚úÖ **Fix**: Always show loading state\n\n‚ùå **Mistake 2**: Generic error messages\n\n‚úÖ **Fix**: User-friendly messages\n\n‚ùå **Mistake 3**: No retry option\n\n‚úÖ **Fix**: Add retry button\n\n",
              "code": "// User must restart app to try again!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Three states: Loading, Success, Error\n- ‚úÖ Manual state management with booleans\n- ‚úÖ FutureBuilder for automatic state handling\n- ‚úÖ User-friendly error messages\n- ‚úÖ Retry mechanisms\n- ‚úÖ Offline mode with cached data\n- ‚úÖ Beautiful loading indicators (shimmer, skeleton)\n- ‚úÖ Professional error UI design\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: What are the three states every network request should handle?\nA) Start, Middle, End\nB) Loading, Success, Error\nC) Request, Response, Complete\nD) Active, Inactive, Done\n\n**Question 2**: What does FutureBuilder's ConnectionState.waiting indicate?\nA) The Future is loading/in progress\nB) The Future completed successfully\nC) The Future failed\nD) No Future is assigned\n\n**Question 3**: Why use user-friendly error messages instead of technical ones?\nA) They're shorter\nB) They help users understand what happened and what to do next\nC) They use less memory\nD) They're required by Flutter\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Professional error handling transforms user experience:**\n\n**Trust Building**: Apps that gracefully handle errors feel reliable. Apps that crash or show blank screens lose users forever. 60% of users uninstall apps after just one error.\n\n**User Empowerment**: \"No internet connection\" + retry button empowers users to fix the problem. Just showing \"Error\" makes them feel helpless and frustrated.\n\n**Offline First**: Mobile networks are unreliable. Apps that show cached data offline feel fast and reliable, even on bad connections. Instagram's offline mode increased engagement 40%.\n\n**Loading States**: Users tolerate 3-second loading times WITH indicators, but abandon after 1 second WITHOUT feedback. Loading spinners aren't just UI polish - they're essential for retention.\n\n**Error Recovery**: Automatic retries and offline queuing means users' actions aren't lost. Twitter's \"Failed to send - will retry\" saved millions of tweets from being abandoned.\n\n**Real-world impact**: When Spotify added offline mode and better error handling, customer support tickets dropped 50% and user satisfaction jumped 35%.\n\n**Professional Polish**: Error handling separates amateur apps from professional ones. It's the difference between \"college project\" and \"production ready.\"\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - Every network request should handle Loading (waiting for data), Success (data received), and Error (request failed) states\n2. **A** - ConnectionState.waiting means the Future is currently loading/in progress, awaiting completion\n3. **B** - User-friendly messages help users understand what happened and provide actionable next steps, reducing frustration\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Next up is: Module 7, Lesson 4: Authentication and Headers**\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.3-challenge-0",
              "title": "Practice Challenge",
              "description": "Design beautiful error screens for: ---",
              "instructions": "Design beautiful error screens for: ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Beautiful Error Screens\n// Professional error states for common network issues\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ErrorScreensDemo());\n}\n\nclass ErrorScreensDemo extends StatelessWidget {\n  const ErrorScreensDemo({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Error Screens',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),\n        useMaterial3: true,\n      ),\n      home: const ErrorShowcase(),\n    );\n  }\n}\n\nclass ErrorShowcase extends StatelessWidget {\n  const ErrorShowcase({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Error Screen Examples'),\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n      ),\n      body: ListView(\n        padding: const EdgeInsets.all(16),\n        children: [\n          _buildNavButton(context, 'No Internet', const NoInternetScreen()),\n          _buildNavButton(context, 'Server Error', const ServerErrorScreen()),\n          _buildNavButton(context, 'Not Found', const NotFoundScreen()),\n          _buildNavButton(context, 'Timeout', const TimeoutScreen()),\n          _buildNavButton(context, 'Empty State', const EmptyStateScreen()),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildNavButton(BuildContext context, String title, Widget screen) {\n    return Padding(\n      padding: const EdgeInsets.only(bottom: 12),\n      child: ElevatedButton(\n        onPressed: () => Navigator.push(\n          context,\n          MaterialPageRoute(builder: (_) => screen),\n        ),\n        child: Text(title),\n      ),\n    );\n  }\n}\n\n// Reusable error screen widget\nclass ErrorScreen extends StatelessWidget {\n  final IconData icon;\n  final Color iconColor;\n  final String title;\n  final String message;\n  final String? buttonText;\n  final VoidCallback? onRetry;\n  final Widget? customAction;\n\n  const ErrorScreen({\n    super.key,\n    required this.icon,\n    this.iconColor = Colors.grey,\n    required this.title,\n    required this.message,\n    this.buttonText,\n    this.onRetry,\n    this.customAction,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Error'),\n      ),\n      body: Center(\n        child: Padding(\n          padding: const EdgeInsets.all(32),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              // Animated icon container\n              Container(\n                width: 120,\n                height: 120,\n                decoration: BoxDecoration(\n                  color: iconColor.withOpacity(0.1),\n                  shape: BoxShape.circle,\n                ),\n                child: Icon(\n                  icon,\n                  size: 64,\n                  color: iconColor,\n                ),\n              ),\n              const SizedBox(height: 32),\n              // Error title\n              Text(\n                title,\n                style: Theme.of(context).textTheme.headlineSmall?.copyWith(\n                  fontWeight: FontWeight.bold,\n                ),\n                textAlign: TextAlign.center,\n              ),\n              const SizedBox(height: 12),\n              // Error message\n              Text(\n                message,\n                style: Theme.of(context).textTheme.bodyLarge?.copyWith(\n                  color: Colors.grey[600],\n                ),\n                textAlign: TextAlign.center,\n              ),\n              const SizedBox(height: 32),\n              // Retry button or custom action\n              if (onRetry != null)\n                ElevatedButton.icon(\n                  onPressed: onRetry,\n                  icon: const Icon(Icons.refresh),\n                  label: Text(buttonText ?? 'Try Again'),\n                  style: ElevatedButton.styleFrom(\n                    padding: const EdgeInsets.symmetric(\n                      horizontal: 32,\n                      vertical: 16,\n                    ),\n                  ),\n                ),\n              if (customAction != null) customAction!,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// No Internet Connection Screen\nclass NoInternetScreen extends StatelessWidget {\n  const NoInternetScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ErrorScreen(\n      icon: Icons.wifi_off,\n      iconColor: Colors.orange,\n      title: 'No Internet Connection',\n      message: 'Please check your internet connection and try again. Make sure you are connected to WiFi or mobile data.',\n      onRetry: () {\n        // Retry logic here\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Retrying...')),\n        );\n      },\n    );\n  }\n}\n\n// Server Error Screen (500)\nclass ServerErrorScreen extends StatelessWidget {\n  const ServerErrorScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ErrorScreen(\n      icon: Icons.cloud_off,\n      iconColor: Colors.red,\n      title: 'Server Error',\n      message: 'Something went wrong on our end. Our team has been notified and is working on a fix. Please try again later.',\n      buttonText: 'Refresh',\n      onRetry: () {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Refreshing...')),\n        );\n      },\n    );\n  }\n}\n\n// Not Found Screen (404)\nclass NotFoundScreen extends StatelessWidget {\n  const NotFoundScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ErrorScreen(\n      icon: Icons.search_off,\n      iconColor: Colors.blue,\n      title: 'Page Not Found',\n      message: 'The page you are looking for does not exist or has been moved.',\n      customAction: Column(\n        children: [\n          ElevatedButton.icon(\n            onPressed: () => Navigator.pop(context),\n            icon: const Icon(Icons.arrow_back),\n            label: const Text('Go Back'),\n          ),\n          const SizedBox(height: 12),\n          TextButton(\n            onPressed: () {\n              // Navigate to home\n              Navigator.popUntil(context, (route) => route.isFirst);\n            },\n            child: const Text('Go to Home'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Timeout Screen\nclass TimeoutScreen extends StatelessWidget {\n  const TimeoutScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ErrorScreen(\n      icon: Icons.timer_off,\n      iconColor: Colors.amber,\n      title: 'Request Timeout',\n      message: 'The server is taking too long to respond. This could be due to a slow network or high server load.',\n      onRetry: () {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Retrying with extended timeout...')),\n        );\n      },\n    );\n  }\n}\n\n// Empty State Screen\nclass EmptyStateScreen extends StatelessWidget {\n  const EmptyStateScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Empty State'),\n      ),\n      body: Center(\n        child: Padding(\n          padding: const EdgeInsets.all(32),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              // Illustration placeholder\n              Container(\n                width: 150,\n                height: 150,\n                decoration: BoxDecoration(\n                  color: Colors.blue.withOpacity(0.1),\n                  borderRadius: BorderRadius.circular(75),\n                ),\n                child: const Icon(\n                  Icons.inbox_outlined,\n                  size: 80,\n                  color: Colors.blue,\n                ),\n              ),\n              const SizedBox(height: 32),\n              Text(\n                'No Items Yet',\n                style: Theme.of(context).textTheme.headlineSmall?.copyWith(\n                  fontWeight: FontWeight.bold,\n                ),\n              ),\n              const SizedBox(height: 12),\n              Text(\n                'Start by adding your first item. Tap the button below to get started!',\n                style: Theme.of(context).textTheme.bodyLarge?.copyWith(\n                  color: Colors.grey[600],\n                ),\n                textAlign: TextAlign.center,\n              ),\n              const SizedBox(height: 32),\n              ElevatedButton.icon(\n                onPressed: () {\n                  ScaffoldMessenger.of(context).showSnackBar(\n                    const SnackBar(content: Text('Add new item...')),\n                  );\n                },\n                icon: const Icon(Icons.add),\n                label: const Text('Add First Item'),\n                style: ElevatedButton.styleFrom(\n                  padding: const EdgeInsets.symmetric(\n                    horizontal: 32,\n                    vertical: 16,\n                  ),\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Not handling null safety",
                  "consequence": "Null check operator errors",
                  "correction": "Use ? for nullable types, ! for assertion"
                },
                {
                  "mistake": "Forgetting async/await",
                  "consequence": "Future not awaited",
                  "correction": "Add async to function, await before Future"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "7.4",
          "title": "Module 7, Lesson 4: Authentication and Headers",
          "moduleId": "module-07",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll understand how to authenticate users with APIs, securely store authentication tokens, and send authenticated requests with custom headers.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Every time you log into an app, this is what's happening behind the scenes.**\n\n- **95% of modern apps** require user authentication\n- **Poor authentication** leads to security breaches (costly and damaging)\n- **Proper token storage** protects user accounts from theft\n- **Understanding headers** is essential for working with real-world APIs\n\nIn this lesson, you'll learn how professional apps handle authentication - the same techniques used by apps like Instagram, Twitter, and banking apps.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The VIP Wristband",
              "content": "\nImagine going to a music festival:\n\n### Without Authentication\nYou try to enter, but the security guard stops you. \"Do you have a ticket?\" Without proof that you paid, you can't get in.\n\n### With Authentication\n1. **Login (Get the Wristband)**: You show your ticket at the entrance. They give you a wristband that proves you're allowed in.\n2. **Access Everything (Send the Wristband)**: Now you can go to different stages, food stalls, etc. Just flash your wristband each time.\n3. **No Need to Show Ticket Again**: Your wristband is proof enough. You don't need to show your original ticket every time.\n4. **Wristband Expires**: At the end of the day, the wristband becomes invalid.\n\n### In the Digital World\n- **Ticket** = Username and Password\n- **Wristband** = Authentication Token (JWT)\n- **Showing Wristband** = Sending Token in Request Headers\n- **Wristband Expires** = Token Expiration\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Are HTTP Headers?",
              "content": "\nThink of HTTP headers as **the envelope information** on a letter:\n\n### The Envelope (Headers)\n\n### The Letter (Body)\n\n**Headers provide metadata** (information about the request) without being part of the actual data.\n\n### Common Headers\n\n| Header | Purpose | Example |\n|--------|---------|---------|\n| `Authorization` | Proves who you are | `Bearer abc123token` |\n| `Content-Type` | What format you're sending | `application/json` |\n| `Accept` | What format you want back | `application/json` |\n| `User-Agent` | What app/device you're using | `MyApp/1.0.0` |\n\n",
              "code": "{\n  \"message\": \"Please give me my profile information\"\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "What is a JWT Token?",
              "content": "\n**JWT** (JSON Web Token) is like a **tamper-proof ID card** that proves who you are.\n\n### Structure of a JWT\n\nIt has three parts (separated by dots):\n1. **Header**: Type of token and algorithm used\n2. **Payload**: Your user information (user ID, name, etc.)\n3. **Signature**: Proof that the server created it (can't be forged)\n\n**You don't need to create JWTs** - the backend server creates them when you log in. Your Flutter app just **stores and sends** them.\n\n",
              "code": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMjM0NSIsIm5hbWUiOiJBbGljZSJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Secure Storage",
              "content": "\nFirst, add the `flutter_secure_storage` package to store tokens safely:\n\n\nRun:\n\n### Why Secure Storage?\n\n**DON'T** store tokens in:\n- ‚ùå Regular variables (lost when app closes)\n- ‚ùå SharedPreferences (not encrypted, easily read)\n- ‚ùå Plain text files (very insecure)\n\n**DO** store tokens in:\n- ‚úÖ flutter_secure_storage (encrypted, platform-specific keychain)\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Bad vs Good: Handling Authentication",
              "content": "\n### ‚ùå Bad Approach: No Authentication\n\n\n**Problem**: No authentication token sent. Server returns 401 Unauthorized.\n\n### ‚ùå Bad Approach: Insecure Storage\n\n\n**Problem**: Token stored in memory only. Lost when app closes or crashes.\n\n### ‚úÖ Good Approach: Secure Authentication\n\n\n**Why This is Good**:\n- ‚úÖ Token stored securely with encryption\n- ‚úÖ Persists across app restarts\n- ‚úÖ Handles 401 (unauthorized) by logging out\n- ‚úÖ Easy to check login status\n- ‚úÖ Clean separation of concerns\n\n",
              "code": "import 'package:flutter_secure_storage/flutter_secure_storage.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:convert';\n\nclass AuthService {\n  final storage = const FlutterSecureStorage();\n  final String baseUrl = 'https://api.example.com';\n\n  // Login and store token securely\n  Future<bool> login(String username, String password) async {\n    try {\n      final response = await http.post(\n        Uri.parse('$baseUrl/login'),\n        headers: {'Content-Type': 'application/json'},\n        body: jsonEncode({\n          'username': username,\n          'password': password,\n        }),\n      ).timeout(const Duration(seconds: 10));\n\n      if (response.statusCode == 200) {\n        final data = jsonDecode(response.body);\n        final token = data['token'];\n\n        // Store token securely\n        await storage.write(key: 'auth_token', value: token);\n        return true;\n      } else {\n        return false;\n      }\n    } catch (e) {\n      print('Login error: $e');\n      return false;\n    }\n  }\n\n  // Get authenticated user profile\n  Future<Map<String, dynamic>> getProfile() async {\n    // Retrieve token from secure storage\n    final token = await storage.read(key: 'auth_token');\n\n    if (token == null) {\n      throw Exception('Not logged in');\n    }\n\n    final response = await http.get(\n      Uri.parse('$baseUrl/profile'),\n      headers: {\n        'Authorization': 'Bearer $token', // THE MAGIC LINE!\n        'Content-Type': 'application/json',\n      },\n    ).timeout(const Duration(seconds: 10));\n\n    if (response.statusCode == 200) {\n      return jsonDecode(response.body);\n    } else if (response.statusCode == 401) {\n      // Token expired or invalid\n      await logout();\n      throw Exception('Session expired. Please login again.');\n    } else {\n      throw Exception('Failed to get profile');\n    }\n  }\n\n  // Logout and clear token\n  Future<void> logout() async {\n    await storage.delete(key: 'auth_token');\n  }\n\n  // Check if user is logged in\n  Future<bool> isLoggedIn() async {\n    final token = await storage.read(key: 'auth_token');\n    return token != null;\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Login Screen with Authentication",
              "content": "\nLet's build a complete login flow with profile display:\n\n### 1. Create the Auth Service (as shown above)\n\n\n### 2. Create a User Model\n\n\n### 3. Create the Login Screen\n\n\n### 4. Create the Profile Screen\n\n\n### 5. Update Main App with Auth Check\n\n\n",
              "code": "// lib/main.dart\nimport 'package:flutter/material.dart';\nimport 'services/auth_service.dart';\nimport 'screens/login_screen.dart';\nimport 'screens/profile_screen.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Auth Demo',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),\n        useMaterial3: true,\n      ),\n      home: const AuthCheck(),\n    );\n  }\n}\n\n// Check if user is already logged in\nclass AuthCheck extends StatefulWidget {\n  const AuthCheck({super.key});\n\n  @override\n  State<AuthCheck> createState() => _AuthCheckState();\n}\n\nclass _AuthCheckState extends State<AuthCheck> {\n  final _authService = AuthService();\n  bool _isChecking = true;\n  bool _isLoggedIn = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _checkLoginStatus();\n  }\n\n  Future<void> _checkLoginStatus() async {\n    final loggedIn = await _authService.isLoggedIn();\n    setState(() {\n      _isLoggedIn = loggedIn;\n      _isChecking = false;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (_isChecking) {\n      return const Scaffold(\n        body: Center(\n          child: CircularProgressIndicator(),\n        ),\n      );\n    }\n\n    return _isLoggedIn ? const ProfileScreen() : const LoginScreen();\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Advanced: Attaching Custom Headers to All Requests",
              "content": "\nFor a real app, you'll want to create a **custom HTTP client** that automatically adds headers to every request:\n\n\n",
              "code": "// lib/services/api_client.dart\nimport 'package:http/http.dart' as http;\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\nimport 'dart:convert';\n\nclass ApiClient {\n  final String baseUrl;\n  final storage = const FlutterSecureStorage();\n\n  ApiClient({required this.baseUrl});\n\n  // Helper method to get headers with auth token\n  Future<Map<String, String>> _getHeaders() async {\n    final token = await storage.read(key: 'auth_token');\n\n    final headers = {\n      'Content-Type': 'application/json',\n      'Accept': 'application/json',\n    };\n\n    if (token != null) {\n      headers['Authorization'] = 'Bearer $token';\n    }\n\n    return headers;\n  }\n\n  // GET request\n  Future<http.Response> get(String endpoint) async {\n    final headers = await _getHeaders();\n    return http.get(\n      Uri.parse('$baseUrl$endpoint'),\n      headers: headers,\n    ).timeout(const Duration(seconds: 10));\n  }\n\n  // POST request\n  Future<http.Response> post(String endpoint, Map<String, dynamic> body) async {\n    final headers = await _getHeaders();\n    return http.post(\n      Uri.parse('$baseUrl$endpoint'),\n      headers: headers,\n      body: jsonEncode(body),\n    ).timeout(const Duration(seconds: 10));\n  }\n\n  // PUT request\n  Future<http.Response> put(String endpoint, Map<String, dynamic> body) async {\n    final headers = await _getHeaders();\n    return http.put(\n      Uri.parse('$baseUrl$endpoint'),\n      headers: headers,\n      body: jsonEncode(body),\n    ).timeout(const Duration(seconds: 10));\n  }\n\n  // DELETE request\n  Future<http.Response> delete(String endpoint) async {\n    final headers = await _getHeaders();\n    return http.delete(\n      Uri.parse('$baseUrl$endpoint'),\n      headers: headers,\n    ).timeout(const Duration(seconds: 10));\n  }\n}\n\n// Usage:\n// final apiClient = ApiClient(baseUrl: 'https://api.example.com');\n// final response = await apiClient.get('/profile');\n// No need to manually add auth headers every time!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Handling Token Expiration",
              "content": "\nJWT tokens expire after a certain time (usually 15 minutes to 24 hours). Here's how to handle expiration gracefully:\n\n\n",
              "code": "class AuthService {\n  // ... previous code ...\n\n  Future<T> makeAuthenticatedRequest<T>(\n    Future<http.Response> Function() request,\n    T Function(Map<String, dynamic>) fromJson,\n  ) async {\n    try {\n      final response = await request();\n\n      if (response.statusCode == 200) {\n        return fromJson(jsonDecode(response.body));\n      } else if (response.statusCode == 401) {\n        // Token expired or invalid\n        await logout();\n        throw Exception('Your session has expired. Please login again.');\n      } else {\n        throw Exception('Request failed with status ${response.statusCode}');\n      }\n    } catch (e) {\n      rethrow;\n    }\n  }\n\n  // Usage:\n  Future<User> getProfile() async {\n    final token = await storage.read(key: 'auth_token');\n    if (token == null) throw Exception('Not logged in');\n\n    return makeAuthenticatedRequest(\n      () => http.get(\n        Uri.parse('$baseUrl/profile'),\n        headers: {\n          'Authorization': 'Bearer $token',\n          'Content-Type': 'application/json',\n        },\n      ),\n      (json) => User.fromJson(json),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Security Best Practices",
              "content": "\n### ‚úÖ DO:\n1. **Always use HTTPS** (not HTTP) for authentication endpoints\n2. **Store tokens in flutter_secure_storage** (not SharedPreferences)\n3. **Clear tokens on logout**\n4. **Handle 401 responses** by logging user out\n5. **Set appropriate timeouts** (10 seconds is reasonable)\n6. **Validate token format** before sending (basic check)\n\n### ‚ùå DON'T:\n1. **Never log tokens** to console in production\n2. **Never store passwords** (only store tokens)\n3. **Never send tokens in URL query parameters** (use headers)\n4. **Never share tokens** between different users\n5. **Never ignore HTTPS certificate errors** in production\n\n\n",
              "code": "// ‚úÖ Good: Token in header\nheaders: {'Authorization': 'Bearer $token'}\n\n// ‚ùå Bad: Token in URL (visible in logs!)\nUri.parse('https://api.example.com/profile?token=$token')",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Testing with a Real API",
              "content": "\nYou can test authentication with **JSONPlaceholder's** auth simulation or **ReqRes**:\n\n### ReqRes (https://reqres.in)\n\n\nTry building a login flow with ReqRes to practice!\n\n",
              "code": "// Login endpoint\nPOST https://reqres.in/api/login\nBody: {\"email\": \"eve.holt@reqres.in\", \"password\": \"cityslicka\"}\nResponse: {\"token\": \"QpwL5tke4Pnpja7X4\"}\n\n// Then use token for authenticated requests\nGET https://reqres.in/api/users/2\nHeaders: {\"Authorization\": \"Bearer QpwL5tke4Pnpja7X4\"}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Errors and Solutions",
              "content": "\n### Error: \"401 Unauthorized\"\n**Cause**: Token missing, expired, or invalid\n**Solution**: Check if token exists, verify format, handle by re-authenticating\n\n### Error: \"Invalid token format\"\n**Cause**: Token not prefixed with \"Bearer \" or malformed\n**Solution**: Ensure format is exactly `'Bearer $token'` (with space!)\n\n### Error: \"Failed to parse header value\"\n**Cause**: Special characters or newlines in token\n**Solution**: Trim token: `token.trim()`\n\n### Error: \"Token null after storage\"\n**Cause**: Forgot to await storage.write()\n**Solution**: Always use `await` when storing/reading tokens\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\nTest your understanding:\n\n### Question 1\nWhat is the correct format for sending a JWT token in the Authorization header?\n\nA) `'Authorization': 'JWT $token'`\nB) `'Authorization': '$token'`\nC) `'Authorization': 'Bearer $token'`\nD) `'Bearer': '$token'`\n\n### Question 2\nWhere should you store authentication tokens in Flutter?\n\nA) In a regular String variable\nB) In SharedPreferences\nC) In flutter_secure_storage\nD) In a text file\n\n### Question 3\nWhat HTTP status code indicates that your token is expired or invalid?\n\nA) 200 (OK)\nB) 400 (Bad Request)\nC) 401 (Unauthorized)\nD) 404 (Not Found)\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: C\n**Correct**: `'Authorization': 'Bearer $token'`\n\nThe standard format is \"Bearer\" followed by a space and then the token. \"Bearer\" must be capitalized.\n\n### Answer 2: C\n**Correct**: In flutter_secure_storage\n\nflutter_secure_storage uses platform-specific encryption (Keychain on iOS, KeyStore on Android) to securely store sensitive data like tokens. SharedPreferences is not encrypted and regular variables don't persist.\n\n### Answer 3: C\n**Correct**: 401 (Unauthorized)\n\n401 Unauthorized means the server couldn't verify your identity (invalid/expired token). This is your cue to log the user out and ask them to login again.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've learned how to authenticate users and send secure requests with custom headers. In the next lesson, we'll explore the **Dio package** - a powerful alternative to the http package with built-in interceptors, automatic token refresh, and better error handling!\n\n**Coming up in Lesson 5: Dio Package (Advanced HTTP Client)**\n- Why Dio is better for complex apps\n- Interceptors (automatic header injection)\n- Automatic retry logic\n- Download/upload progress tracking\n- Much more!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Authentication tokens are like VIP wristbands - prove who you are once, then show the wristband each time\n‚úÖ Use flutter_secure_storage to store tokens securely (encrypted)\n‚úÖ Send tokens in the Authorization header: `'Authorization': 'Bearer $token'`\n‚úÖ Always handle 401 (Unauthorized) by logging user out\n‚úÖ JWT tokens have three parts (header.payload.signature) but you don't need to create them\n‚úÖ Use HTTPS for all authentication endpoints\n‚úÖ Create a custom ApiClient to automatically add headers to all requests\n\n**You're now ready to build secure, authenticated apps!** üéâ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "7.5",
          "title": "Module 7, Lesson 5: Dio Package - Advanced HTTP Client",
          "moduleId": "module-07",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll understand how to use Dio - a powerful HTTP client that makes networking easier with built-in interceptors, automatic retries, and better error handling.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Dio is the industry standard for professional Flutter apps.**\n\n- **Used by 80%+ of production Flutter apps** that handle complex networking\n- **Saves hours of development time** with built-in features (interceptors, retries, progress tracking)\n- **Better error handling** out of the box\n- **Automatic JSON parsing** with less boilerplate\n- **Download/upload progress tracking** (critical for file transfers)\n\nIn this lesson, you'll learn the same HTTP client used by apps like Alibaba, Tencent, and thousands of other professional applications.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: Personal Assistant vs Solo Worker",
              "content": "\n### Using the `http` Package (Solo Worker)\nImagine you run a small business and handle everything yourself:\n- ‚úâÔ∏è You personally write every letter to suppliers\n- üìû You make every phone call\n- üìù You remember every detail yourself\n- üîÑ If something fails, you have to manually retry\n- üìä You track everything on paper\n\n**It works, but it's exhausting and error-prone.**\n\n### Using Dio (Personal Assistant)\nNow imagine hiring a smart personal assistant:\n- ‚úâÔ∏è They automatically add your letterhead to every letter\n- üìû They retry calls if the line is busy\n- üìù They keep logs of all communications\n- üîÑ They handle errors gracefully and report back\n- üìä They give you progress reports (\"50% of the file uploaded...\")\n\n**Dio is your networking personal assistant.**\n\n"
            },
            {
              "type": "THEORY",
              "title": "http vs Dio: Side-by-Side Comparison",
              "content": "\n### Example: Fetch User Profile with Auth\n\n#### With `http` Package ‚ùå (Manual Everything)\n\n\n**Lines of code**: ~25 lines\n**Problems**: Repetitive, error-prone, no retry logic, no logging\n\n#### With Dio ‚úÖ (Automatic Everything)\n\n\n**Lines of code**: ~5 lines\n**Benefits**: Auto JSON parsing, auto error handling, built-in timeout\n\n",
              "code": "import 'package:dio/dio.dart';\n\nFuture<Map<String, dynamic>> getProfile() async {\n  final dio = Dio();\n\n  // That's it! Dio handles everything else automatically\n  final response = await dio.get('https://api.example.com/profile');\n  return response.data;\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Dio",
              "content": "\n### 1. Add Dio to Your Project\n\n\nRun:\n\n### 2. Basic Dio Instance\n\n\n",
              "code": "import 'package:dio/dio.dart';\n\nfinal dio = Dio();\n\n// That's it! You can now use dio.get(), dio.post(), etc.",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Making Requests with Dio",
              "content": "\n### GET Request\n\n\n### POST Request\n\n\n### PUT Request\n\n\n### DELETE Request\n\n\n**Notice**: No `jsonEncode()` or `jsonDecode()` needed! Dio handles it automatically.\n\n",
              "code": "// Delete a post\nFuture<void> deletePost(int id) async {\n  await dio.delete('https://jsonplaceholder.typicode.com/posts/$id');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Configuring Dio: Base Options",
              "content": "\nInstead of repeating the base URL everywhere, configure Dio once:\n\n\n",
              "code": "final dio = Dio(\n  BaseOptions(\n    baseUrl: 'https://api.example.com',\n    connectTimeout: Duration(seconds: 10),\n    receiveTimeout: Duration(seconds: 10),\n    headers: {\n      'Content-Type': 'application/json',\n      'Accept': 'application/json',\n    },\n  ),\n);\n\n// Now you can use relative paths\nfinal response = await dio.get('/posts'); // https://api.example.com/posts\nfinal user = await dio.get('/users/1');   // https://api.example.com/users/1",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Interceptors: The Magic of Dio ü™Ñ",
              "content": "\n**Interceptors** are like **security checkpoints** at an airport:\n- **Before you fly (Request Interceptor)**: Check your passport, add boarding pass\n- **After you land (Response Interceptor)**: Stamp your passport, log arrival\n- **If something goes wrong (Error Interceptor)**: Handle delays, rebook flights\n\n### Request Interceptor (Add Auth Token Automatically)\n\n\n### Response Interceptor (Log All Responses)\n\n\n### Error Interceptor (Handle Errors Globally)\n\n\n",
              "code": "class ErrorInterceptor extends Interceptor {\n  @override\n  void onError(DioException err, ErrorInterceptorHandler handler) {\n    String message;\n\n    switch (err.type) {\n      case DioExceptionType.connectionTimeout:\n      case DioExceptionType.sendTimeout:\n      case DioExceptionType.receiveTimeout:\n        message = 'Connection timeout. Check your internet.';\n        break;\n      case DioExceptionType.badResponse:\n        message = 'Server error: ${err.response?.statusCode}';\n        break;\n      case DioExceptionType.cancel:\n        message = 'Request cancelled';\n        break;\n      default:\n        message = 'Network error. Please try again.';\n    }\n\n    print('‚ùå Error: $message');\n    handler.next(err); // Pass error to the caller\n  }\n}\n\ndio.interceptors.add(ErrorInterceptor());",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Complete Dio Service with Interceptors",
              "content": "\nHere's a production-ready Dio service:\n\n\n### Usage:\n\n\n",
              "code": "// Create once in your app\nfinal dioService = DioService();\nfinal dio = dioService.dio;\n\n// Use everywhere - tokens added automatically!\nfinal posts = await dio.get('/posts');\nfinal user = await dio.get('/users/1');",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Automatic Retry Logic",
              "content": "\nDio can automatically retry failed requests:\n\n\n",
              "code": "import 'package:dio/dio.dart';\n\nclass RetryInterceptor extends Interceptor {\n  final int maxRetries;\n  final Duration retryDelay;\n\n  RetryInterceptor({\n    this.maxRetries = 3,\n    this.retryDelay = const Duration(seconds: 2),\n  });\n\n  @override\n  void onError(DioException err, ErrorInterceptorHandler handler) async {\n    // Only retry on network errors, not bad requests\n    if (err.type == DioExceptionType.connectionTimeout ||\n        err.type == DioExceptionType.connectionError) {\n\n      // Get current retry count\n      final retries = err.requestOptions.extra['retries'] ?? 0;\n\n      if (retries < maxRetries) {\n        print('Retry attempt ${retries + 1}/$maxRetries...');\n\n        // Wait before retrying\n        await Future.delayed(retryDelay);\n\n        // Update retry count\n        err.requestOptions.extra['retries'] = retries + 1;\n\n        // Retry the request\n        try {\n          final response = await Dio().fetch(err.requestOptions);\n          handler.resolve(response); // Success!\n        } catch (e) {\n          handler.next(err); // Still failed, pass error along\n        }\n      } else {\n        print('Max retries reached');\n        handler.next(err);\n      }\n    } else {\n      handler.next(err);\n    }\n  }\n}\n\n// Add to Dio\ndio.interceptors.add(RetryInterceptor(maxRetries: 3));",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Download Progress Tracking",
              "content": "\nPerfect for downloading files with a progress bar:\n\n\n### Upload Progress Tracking\n\n\n",
              "code": "Future<void> uploadFile(String filePath) async {\n  final formData = FormData.fromMap({\n    'file': await MultipartFile.fromFile(filePath),\n  });\n\n  await dio.post(\n    '/upload',\n    data: formData,\n    onSendProgress: (sent, total) {\n      final progress = (sent / total * 100).toStringAsFixed(0);\n      print('Upload progress: $progress%');\n\n      // Update UI progress bar here!\n    },\n  );\n  print('Upload complete!');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Error Handling with Dio",
              "content": "\nDio provides better error types than `http`:\n\n\n",
              "code": "Future<List<dynamic>> getPosts() async {\n  try {\n    final response = await dio.get('/posts');\n    return response.data;\n  } on DioException catch (e) {\n    switch (e.type) {\n      case DioExceptionType.connectionTimeout:\n      case DioExceptionType.sendTimeout:\n      case DioExceptionType.receiveTimeout:\n        throw Exception('Connection timeout. Please try again.');\n\n      case DioExceptionType.badResponse:\n        // Server responded with error\n        final statusCode = e.response?.statusCode;\n        if (statusCode == 401) {\n          throw Exception('Unauthorized. Please login.');\n        } else if (statusCode == 404) {\n          throw Exception('Data not found.');\n        } else if (statusCode! >= 500) {\n          throw Exception('Server error. Try again later.');\n        }\n        throw Exception('Request failed: $statusCode');\n\n      case DioExceptionType.cancel:\n        throw Exception('Request cancelled.');\n\n      case DioExceptionType.connectionError:\n        throw Exception('No internet connection.');\n\n      default:\n        throw Exception('Network error: ${e.message}');\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Posts App with Dio",
              "content": "\nLet's build a complete app using Dio:\n\n### 1. Create Post Model\n\n\n### 2. Create Posts Service with Dio\n\n\n### 3. Create Posts Screen\n\n\n### 4. Update Main App\n\n\n",
              "code": "// lib/main.dart\nimport 'package:flutter/material.dart';\nimport 'screens/posts_screen.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Dio Demo',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),\n        useMaterial3: true,\n      ),\n      home: const PostsScreen(),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "When to Use Dio vs http",
              "content": "\n### Use `http` when:\n- ‚úÖ Building a simple app with 1-2 API calls\n- ‚úÖ Learning Flutter basics (simpler to understand)\n- ‚úÖ Minimizing dependencies\n\n### Use Dio when:\n- ‚úÖ Building a production app with many API calls\n- ‚úÖ Need automatic header injection (auth tokens)\n- ‚úÖ Need retry logic\n- ‚úÖ Need download/upload progress tracking\n- ‚úÖ Need advanced error handling\n- ‚úÖ Want cleaner, more maintainable code\n\n**Rule of thumb**: For any serious app, use Dio. It saves time and reduces bugs.\n\n"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### ‚úÖ DO:\n1. **Create a single Dio instance** and reuse it (don't create new ones for each request)\n2. **Use BaseOptions** to configure once, use everywhere\n3. **Use interceptors** for auth, logging, and error handling\n4. **Handle DioException** specifically (better than generic Exception)\n5. **Set timeouts** (connectTimeout, receiveTimeout)\n\n### ‚ùå DON'T:\n1. **Don't create Dio() in every method** (reuse the instance)\n2. **Don't ignore errors** (always catch DioException)\n3. **Don't forget to cancel requests** when leaving screens (prevents memory leaks)\n4. **Don't log sensitive data** in production (tokens, passwords)\n\n\n",
              "code": "// ‚úÖ Good: Single instance\nfinal dio = Dio();\n\nFuture<void> getPosts() async {\n  await dio.get('/posts');\n}\n\nFuture<void> getUsers() async {\n  await dio.get('/users');\n}\n\n// ‚ùå Bad: New instance every time\nFuture<void> getPosts() async {\n  final dio = Dio(); // Creating new instance!\n  await dio.get('/posts');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\nTest your understanding:\n\n### Question 1\nWhat is the main advantage of using Dio over the http package?\n\nA) Dio is faster\nB) Dio has built-in interceptors and better error handling\nC) Dio uses less memory\nD) Dio is required by Flutter\n\n### Question 2\nWhat are interceptors used for in Dio?\n\nA) To slow down requests\nB) To automatically modify requests/responses and handle errors globally\nC) To encrypt data\nD) To compress images\n\n### Question 3\nHow does Dio handle JSON parsing?\n\nA) You must manually use jsonEncode() and jsonDecode()\nB) Dio automatically parses JSON in response.data\nC) Dio doesn't support JSON\nD) You need a separate package for JSON\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: Dio has built-in interceptors and better error handling\n\nWhile Dio may have slight performance differences, the main advantage is development experience: interceptors for automatic header injection, better error types (DioException), retry logic, progress tracking, and cleaner code.\n\n### Answer 2: B\n**Correct**: To automatically modify requests/responses and handle errors globally\n\nInterceptors are like middleware that can modify every request (add auth headers), log every response, or handle errors in one place instead of repeating code everywhere.\n\n### Answer 3: B\n**Correct**: Dio automatically parses JSON in response.data\n\nUnlike the http package where you need to manually call jsonDecode(response.body), Dio automatically parses JSON responses and provides them in response.data.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've learned how to use Dio - the professional HTTP client for Flutter. In the next lesson, we'll explore **Pagination and Infinite Scroll** to handle large datasets efficiently!\n\n**Coming up in Lesson 6: Pagination and Infinite Scroll**\n- Why pagination matters (don't load 10,000 items at once!)\n- Offset-based pagination\n- Cursor-based pagination\n- Infinite scroll implementation\n- Pull-to-refresh\n- Complete example with ListView\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Dio is the industry standard for production Flutter apps (80%+ adoption)\n‚úÖ Interceptors automatically modify all requests/responses (auth headers, logging)\n‚úÖ Dio automatically parses JSON (no jsonDecode needed)\n‚úÖ Better error handling with DioException types\n‚úÖ Built-in retry logic, download/upload progress tracking\n‚úÖ Configure once with BaseOptions, use everywhere\n‚úÖ Reuse a single Dio instance across your app\n\n**You're now ready to build professional networking features!** üéâ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "7.6",
          "title": "Module 7, Lesson 6: Pagination and Infinite Scroll",
          "moduleId": "module-07",
          "order": 6,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll understand how to efficiently load large datasets using pagination, implement infinite scroll, and create smooth loading experiences like Instagram, Twitter, and Reddit.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Pagination is critical for app performance and user experience.**\n\n- **Loading 10,000 items at once** would crash most phones\n- **Apps with pagination feel 10x faster** than apps without\n- **Instagram, Twitter, TikTok** - all use infinite scroll\n- **Reduces server costs** by loading only what users need\n- **Better battery life** (less data = less power consumption)\n\nIn this lesson, you'll learn the same techniques used by every major social media and content app.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Library",
              "content": "\n### Without Pagination ‚ùå (The Bad Librarian)\nImagine asking a librarian for \"books about cooking\":\n- üìö They bring you **ALL 5,000 cooking books** at once\n- üèãÔ∏è You can't carry them all\n- ‚è∞ It takes 30 minutes to bring them all\n- üòµ You only wanted to browse a few books\n- üí∏ The library spent huge effort on books you won't read\n\n**This is what happens when you load all data at once.**\n\n### With Pagination ‚úÖ (The Smart Librarian)\nInstead, the smart librarian:\n- üìñ Brings you **20 books** to start\n- üëÄ You browse them while sitting comfortably\n- üîÑ When you're done, they bring **20 more**\n- ‚ö° Each delivery is fast (seconds, not minutes)\n- üòä You can stop whenever you want\n- üí∞ The library only moves books you actually look at\n\n**This is pagination - loading data in small chunks.**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Types of Pagination",
              "content": "\n### 1. Offset-Based Pagination (Simple)\n\"Give me items 0-19, then 20-39, then 40-59...\"\n\n\n**API Request**:\n\n**Pros**: Simple to implement\n**Cons**: Can have issues with real-time data (items moving)\n\n### 2. Cursor-Based Pagination (Advanced)\n\"Give me items after cursor ABC123...\"\n\n\n**API Request**:\n\n**Pros**: Works perfectly with real-time data\n**Cons**: Slightly more complex\n\n",
              "code": "GET /posts?limit=20\nGET /posts?cursor=ABC123&limit=20\nGET /posts?cursor=XYZ789&limit=20",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Infinite Scroll Pattern",
              "content": "\n**Infinite Scroll** = Automatically load more data when user scrolls near the bottom.\n\n### The Flow\n\n\n",
              "code": "1. User opens app\n   ‚Üì\n2. Load first page (20 items)\n   ‚Üì\n3. User scrolls down\n   ‚Üì\n4. When near bottom ‚Üí Load next page\n   ‚Üì\n5. Add new items to list\n   ‚Üì\n6. Repeat steps 3-5 infinitely",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Basic Pagination Example",
              "content": "\nLet's start with simple offset-based pagination:\n\n\n\n",
              "code": "// lib/services/posts_service.dart\nimport 'package:dio/dio.dart';\nimport '../models/post.dart';\n\nclass PostsService {\n  final Dio _dio = Dio(\n    BaseOptions(baseUrl: 'https://jsonplaceholder.typicode.com'),\n  );\n\n  // Fetch posts with pagination\n  Future<List<Post>> getPosts({required int page, int limit = 20}) async {\n    try {\n      // JSONPlaceholder uses _page and _limit\n      final response = await _dio.get(\n        '/posts',\n        queryParameters: {\n          '_page': page,\n          '_limit': limit,\n        },\n      );\n\n      final List<dynamic> data = response.data;\n      return data.map((json) => Post.fromJson(json)).toList();\n    } catch (e) {\n      throw Exception('Failed to load posts: $e');\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Infinite Scroll Implementation",
              "content": "\n### Approach 1: ScrollController (Manual Detection)\n\n\n",
              "code": "// lib/screens/posts_screen.dart\nimport 'package:flutter/material.dart';\nimport '../services/posts_service.dart';\nimport '../models/post.dart';\n\nclass PostsScreen extends StatefulWidget {\n  const PostsScreen({super.key});\n\n  @override\n  State<PostsScreen> createState() => _PostsScreenState();\n}\n\nclass _PostsScreenState extends State<PostsScreen> {\n  final _postsService = PostsService();\n  final _scrollController = ScrollController();\n  final List<Post> _posts = [];\n\n  int _currentPage = 1;\n  bool _isLoadingMore = false;\n  bool _hasMoreData = true;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadInitialPosts();\n    _scrollController.addListener(_onScroll);\n  }\n\n  @override\n  void dispose() {\n    _scrollController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _loadInitialPosts() async {\n    final posts = await _postsService.getPosts(page: _currentPage);\n    setState(() {\n      _posts.addAll(posts);\n    });\n  }\n\n  void _onScroll() {\n    // Check if user scrolled near the bottom (within 200 pixels)\n    if (_scrollController.position.pixels >=\n        _scrollController.position.maxScrollExtent - 200) {\n      _loadMorePosts();\n    }\n  }\n\n  Future<void> _loadMorePosts() async {\n    // Prevent multiple simultaneous loads\n    if (_isLoadingMore || !_hasMoreData) return;\n\n    setState(() {\n      _isLoadingMore = true;\n    });\n\n    try {\n      _currentPage++;\n      final newPosts = await _postsService.getPosts(page: _currentPage);\n\n      setState(() {\n        if (newPosts.isEmpty) {\n          _hasMoreData = false; // No more data available\n        } else {\n          _posts.addAll(newPosts);\n        }\n        _isLoadingMore = false;\n      });\n    } catch (e) {\n      setState(() {\n        _isLoadingMore = false;\n        _currentPage--; // Revert page number on error\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Infinite Scroll Posts'),\n      ),\n      body: _posts.isEmpty\n          ? const Center(child: CircularProgressIndicator())\n          : ListView.builder(\n              controller: _scrollController,\n              padding: const EdgeInsets.all(16),\n              itemCount: _posts.length + (_hasMoreData ? 1 : 0),\n              itemBuilder: (context, index) {\n                // Show loading indicator at the bottom\n                if (index == _posts.length) {\n                  return const Center(\n                    child: Padding(\n                      padding: EdgeInsets.all(16.0),\n                      child: CircularProgressIndicator(),\n                    ),\n                  );\n                }\n\n                final post = _posts[index];\n                return Card(\n                  margin: const EdgeInsets.only(bottom: 12),\n                  child: ListTile(\n                    leading: CircleAvatar(\n                      child: Text(post.id.toString()),\n                    ),\n                    title: Text(\n                      post.title,\n                      style: const TextStyle(fontWeight: FontWeight.bold),\n                    ),\n                    subtitle: Text(\n                      post.body,\n                      maxLines: 2,\n                      overflow: TextOverflow.ellipsis,\n                    ),\n                  ),\n                );\n              },\n            ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Enhanced Version with Pull-to-Refresh",
              "content": "\nLet's add the ability to refresh by pulling down:\n\n\n**Features**:\n- ‚úÖ Initial loading state\n- ‚úÖ Error handling with retry\n- ‚úÖ Infinite scroll\n- ‚úÖ Pull-to-refresh\n- ‚úÖ Loading indicator at bottom\n- ‚úÖ \"End of list\" message\n- ‚úÖ Item count in app bar\n\n",
              "code": "// lib/screens/posts_screen_enhanced.dart\nimport 'package:flutter/material.dart';\nimport '../services/posts_service.dart';\nimport '../models/post.dart';\n\nclass PostsScreenEnhanced extends StatefulWidget {\n  const PostsScreenEnhanced({super.key});\n\n  @override\n  State<PostsScreenEnhanced> createState() => _PostsScreenEnhancedState();\n}\n\nclass _PostsScreenEnhancedState extends State<PostsScreenEnhanced> {\n  final _postsService = PostsService();\n  final _scrollController = ScrollController();\n  final List<Post> _posts = [];\n\n  int _currentPage = 1;\n  bool _isLoadingInitial = true;\n  bool _isLoadingMore = false;\n  bool _hasMoreData = true;\n  String? _errorMessage;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadInitialPosts();\n    _scrollController.addListener(_onScroll);\n  }\n\n  @override\n  void dispose() {\n    _scrollController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _loadInitialPosts() async {\n    setState(() {\n      _isLoadingInitial = true;\n      _errorMessage = null;\n    });\n\n    try {\n      final posts = await _postsService.getPosts(page: 1);\n      setState(() {\n        _posts.clear();\n        _posts.addAll(posts);\n        _currentPage = 1;\n        _hasMoreData = posts.isNotEmpty;\n        _isLoadingInitial = false;\n      });\n    } catch (e) {\n      setState(() {\n        _errorMessage = e.toString();\n        _isLoadingInitial = false;\n      });\n    }\n  }\n\n  void _onScroll() {\n    if (_scrollController.position.pixels >=\n        _scrollController.position.maxScrollExtent - 200) {\n      _loadMorePosts();\n    }\n  }\n\n  Future<void> _loadMorePosts() async {\n    if (_isLoadingMore || !_hasMoreData || _isLoadingInitial) return;\n\n    setState(() {\n      _isLoadingMore = true;\n    });\n\n    try {\n      _currentPage++;\n      final newPosts = await _postsService.getPosts(page: _currentPage);\n\n      setState(() {\n        if (newPosts.isEmpty) {\n          _hasMoreData = false;\n        } else {\n          _posts.addAll(newPosts);\n        }\n        _isLoadingMore = false;\n      });\n    } catch (e) {\n      setState(() {\n        _isLoadingMore = false;\n        _currentPage--;\n      });\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Failed to load more: $e')),\n        );\n      }\n    }\n  }\n\n  Future<void> _onRefresh() async {\n    await _loadInitialPosts();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Initial loading state\n    if (_isLoadingInitial && _posts.isEmpty) {\n      return Scaffold(\n        appBar: AppBar(title: const Text('Posts')),\n        body: const Center(child: CircularProgressIndicator()),\n      );\n    }\n\n    // Error state\n    if (_errorMessage != null && _posts.isEmpty) {\n      return Scaffold(\n        appBar: AppBar(title: const Text('Posts')),\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              const Icon(Icons.error_outline, size: 64, color: Colors.red),\n              const SizedBox(height: 16),\n              Text(\n                _errorMessage!,\n                textAlign: TextAlign.center,\n                style: const TextStyle(color: Colors.red),\n              ),\n              const SizedBox(height: 16),\n              FilledButton.icon(\n                onPressed: _loadInitialPosts,\n                icon: const Icon(Icons.refresh),\n                label: const Text('Try Again'),\n              ),\n            ],\n          ),\n        ),\n      );\n    }\n\n    // Success state with data\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Posts (${_posts.length})'),\n      ),\n      body: RefreshIndicator(\n        onRefresh: _onRefresh,\n        child: ListView.builder(\n          controller: _scrollController,\n          padding: const EdgeInsets.all(16),\n          itemCount: _posts.length + 1, // +1 for loading indicator or end message\n          itemBuilder: (context, index) {\n            // Loading indicator or \"End of list\" message\n            if (index == _posts.length) {\n              if (_isLoadingMore) {\n                return const Center(\n                  child: Padding(\n                    padding: EdgeInsets.all(16.0),\n                    child: CircularProgressIndicator(),\n                  ),\n                );\n              } else if (!_hasMoreData) {\n                return Center(\n                  child: Padding(\n                    padding: const EdgeInsets.all(16.0),\n                    child: Text(\n                      'üéâ You\\'ve reached the end!',\n                      style: TextStyle(\n                        color: Colors.grey.shade600,\n                        fontSize: 16,\n                      ),\n                    ),\n                  ),\n                );\n              } else {\n                return const SizedBox.shrink();\n              }\n            }\n\n            final post = _posts[index];\n            return Card(\n              margin: const EdgeInsets.only(bottom: 12),\n              child: ListTile(\n                leading: CircleAvatar(\n                  backgroundColor: Colors.blue.shade100,\n                  child: Text(\n                    post.id.toString(),\n                    style: TextStyle(color: Colors.blue.shade900),\n                  ),\n                ),\n                title: Text(\n                  post.title,\n                  style: const TextStyle(fontWeight: FontWeight.bold),\n                ),\n                subtitle: Text(\n                  post.body,\n                  maxLines: 2,\n                  overflow: TextOverflow.ellipsis,\n                ),\n                trailing: const Icon(Icons.arrow_forward_ios, size: 16),\n                onTap: () {\n                  // Navigate to detail screen\n                  ScaffoldMessenger.of(context).showSnackBar(\n                    SnackBar(content: Text('Tapped post ${post.id}')),\n                  );\n                },\n              ),\n            );\n          },\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Approach 2: Using a Package (infinite_scroll_pagination)",
              "content": "\nFor production apps, consider using a battle-tested package:\n\n\n\n**Benefits of the package**:\n- ‚úÖ Less boilerplate code\n- ‚úÖ Built-in error handling UI\n- ‚úÖ Automatic state management\n- ‚úÖ Well-tested and maintained\n\n",
              "code": "// lib/screens/posts_screen_package.dart\nimport 'package:flutter/material.dart';\nimport 'package:infinite_scroll_pagination/infinite_scroll_pagination.dart';\nimport '../services/posts_service.dart';\nimport '../models/post.dart';\n\nclass PostsScreenPackage extends StatefulWidget {\n  const PostsScreenPackage({super.key});\n\n  @override\n  State<PostsScreenPackage> createState() => _PostsScreenPackageState();\n}\n\nclass _PostsScreenPackageState extends State<PostsScreenPackage> {\n  final _postsService = PostsService();\n  final PagingController<int, Post> _pagingController =\n      PagingController(firstPageKey: 1);\n\n  @override\n  void initState() {\n    super.initState();\n    _pagingController.addPageRequestListener((pageKey) {\n      _fetchPage(pageKey);\n    });\n  }\n\n  Future<void> _fetchPage(int pageKey) async {\n    try {\n      final newPosts = await _postsService.getPosts(page: pageKey);\n      final isLastPage = newPosts.length < 20; // Assuming 20 items per page\n\n      if (isLastPage) {\n        _pagingController.appendLastPage(newPosts);\n      } else {\n        final nextPageKey = pageKey + 1;\n        _pagingController.appendPage(newPosts, nextPageKey);\n      }\n    } catch (error) {\n      _pagingController.error = error;\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Posts (Package)')),\n      body: RefreshIndicator(\n        onRefresh: () => Future.sync(() => _pagingController.refresh()),\n        child: PagedListView<int, Post>(\n          pagingController: _pagingController,\n          padding: const EdgeInsets.all(16),\n          builderDelegate: PagedChildBuilderDelegate<Post>(\n            itemBuilder: (context, post, index) => Card(\n              margin: const EdgeInsets.only(bottom: 12),\n              child: ListTile(\n                leading: CircleAvatar(child: Text(post.id.toString())),\n                title: Text(\n                  post.title,\n                  style: const TextStyle(fontWeight: FontWeight.bold),\n                ),\n                subtitle: Text(\n                  post.body,\n                  maxLines: 2,\n                  overflow: TextOverflow.ellipsis,\n                ),\n              ),\n            ),\n            firstPageErrorIndicatorBuilder: (context) => Center(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  const Icon(Icons.error_outline, size: 64, color: Colors.red),\n                  const SizedBox(height: 16),\n                  Text(\n                    'Error: ${_pagingController.error}',\n                    textAlign: TextAlign.center,\n                  ),\n                  const SizedBox(height: 16),\n                  FilledButton.icon(\n                    onPressed: () => _pagingController.refresh(),\n                    icon: const Icon(Icons.refresh),\n                    label: const Text('Try Again'),\n                  ),\n                ],\n              ),\n            ),\n            newPageErrorIndicatorBuilder: (context) => Padding(\n              padding: const EdgeInsets.all(16.0),\n              child: Center(\n                child: FilledButton.icon(\n                  onPressed: () => _pagingController.retryLastFailedRequest(),\n                  icon: const Icon(Icons.refresh),\n                  label: const Text('Retry'),\n                ),\n              ),\n            ),\n            noItemsFoundIndicatorBuilder: (context) => const Center(\n              child: Text('No posts found'),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    _pagingController.dispose();\n    super.dispose();\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Cursor-Based Pagination Example",
              "content": "\nFor APIs that use cursors (like Twitter, Instagram):\n\n\n\n",
              "code": "// lib/screens/cursor_posts_screen.dart\nclass CursorPostsScreen extends StatefulWidget {\n  const CursorPostsScreen({super.key});\n\n  @override\n  State<CursorPostsScreen> createState() => _CursorPostsScreenState();\n}\n\nclass _CursorPostsScreenState extends State<CursorPostsScreen> {\n  final _service = CursorPostsService();\n  final _scrollController = ScrollController();\n  final List<dynamic> _posts = [];\n\n  String? _nextCursor;\n  bool _isLoadingMore = false;\n  bool _hasMoreData = true;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadInitialPosts();\n    _scrollController.addListener(_onScroll);\n  }\n\n  Future<void> _loadInitialPosts() async {\n    final response = await _service.getPosts();\n    setState(() {\n      _posts.addAll(response.data);\n      _nextCursor = response.nextCursor;\n      _hasMoreData = response.hasMore;\n    });\n  }\n\n  void _onScroll() {\n    if (_scrollController.position.pixels >=\n        _scrollController.position.maxScrollExtent - 200) {\n      _loadMorePosts();\n    }\n  }\n\n  Future<void> _loadMorePosts() async {\n    if (_isLoadingMore || !_hasMoreData) return;\n\n    setState(() {\n      _isLoadingMore = true;\n    });\n\n    try {\n      final response = await _service.getPosts(cursor: _nextCursor);\n\n      setState(() {\n        _posts.addAll(response.data);\n        _nextCursor = response.nextCursor;\n        _hasMoreData = response.hasMore;\n        _isLoadingMore = false;\n      });\n    } catch (e) {\n      setState(() {\n        _isLoadingMore = false;\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Similar to previous examples...\n    return Scaffold(\n      appBar: AppBar(title: const Text('Cursor Pagination')),\n      body: ListView.builder(\n        controller: _scrollController,\n        itemCount: _posts.length + (_hasMoreData ? 1 : 0),\n        itemBuilder: (context, index) {\n          if (index == _posts.length) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          // Build your item widget\n          return ListTile(title: Text(_posts[index].toString()));\n        },\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    _scrollController.dispose();\n    super.dispose();\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Performance Optimization Tips",
              "content": "\n### 1. Use `ListView.builder` (Not `ListView`)\n\n\n### 2. Cache Images\n\n\n### 3. Throttle Scroll Events\n\n\n",
              "code": "// Don't load on every pixel scrolled\nTimer? _scrollTimer;\n\nvoid _onScroll() {\n  _scrollTimer?.cancel();\n  _scrollTimer = Timer(Duration(milliseconds: 300), () {\n    if (_scrollController.position.pixels >=\n        _scrollController.position.maxScrollExtent - 200) {\n      _loadMorePosts();\n    }\n  });\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### ‚úÖ DO:\n1. **Show loading indicators** at the bottom while loading more\n2. **Show \"End of list\" message** when no more data\n3. **Implement pull-to-refresh** for better UX\n4. **Use ListView.builder** for performance\n5. **Handle errors gracefully** with retry options\n6. **Prevent duplicate loads** with `_isLoadingMore` flag\n7. **Show item count** in app bar (e.g., \"Posts (125)\")\n\n### ‚ùå DON'T:\n1. **Don't load all data at once** (defeats the purpose!)\n2. **Don't trigger loading on every scroll pixel** (use threshold)\n3. **Don't forget to dispose controllers** (memory leaks)\n4. **Don't show errors silently** (users need feedback)\n5. **Don't make page size too small** (too many requests) or too large (slow)\n\n**Recommended page size**: 20-50 items\n\n"
            },
            {
              "type": "WARNING",
              "title": "Common Pitfalls",
              "content": "\n### Problem 1: Loading Same Page Multiple Times\n\n\n### Problem 2: Not Disposing ScrollController\n\n\n",
              "code": "// ‚ùå Bad: Memory leak\n@override\nWidget build(BuildContext context) {\n  final controller = ScrollController(); // Created every build!\n  return ListView(controller: controller);\n}\n\n// ‚úÖ Good: Create once, dispose properly\nclass _MyScreenState extends State<MyScreen> {\n  late final ScrollController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = ScrollController();\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\nTest your understanding:\n\n### Question 1\nWhy is pagination important for mobile apps?\n\nA) It makes the code shorter\nB) It prevents loading too much data at once, improving performance and reducing server costs\nC) It's required by Flutter\nD) It only works on Android\n\n### Question 2\nWhat is the difference between offset-based and cursor-based pagination?\n\nA) They're the same thing\nB) Offset uses page numbers, cursor uses unique identifiers for the last item\nC) Cursor is faster\nD) Offset only works with databases\n\n### Question 3\nWhen should you load the next page in infinite scroll?\n\nA) As soon as the user starts scrolling\nB) When the user reaches the exact bottom\nC) When the user scrolls within 200-300 pixels of the bottom\nD) Every 5 seconds\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: It prevents loading too much data at once, improving performance and reducing server costs\n\nLoading thousands of items at once would consume excessive memory, slow down the app, waste bandwidth, drain battery, and put unnecessary load on your server. Pagination solves all these problems by loading small chunks.\n\n### Answer 2: B\n**Correct**: Offset uses page numbers, cursor uses unique identifiers for the last item\n\nOffset-based pagination uses page numbers or offsets (`page=1, page=2` or `offset=0, offset=20`). Cursor-based pagination uses a unique cursor/token that points to where to continue (`cursor=ABC123`). Cursor-based is better for real-time data because items can be added/removed without breaking pagination.\n\n### Answer 3: C\n**Correct**: When the user scrolls within 200-300 pixels of the bottom\n\nThis provides the best UX - loading starts before reaching the actual bottom, so users don't see a jarring stop. Too early (option A) wastes resources, and exact bottom (option B) creates a noticeable pause.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've learned how to efficiently handle large datasets with pagination and infinite scroll. In the next lesson, we'll explore **File Upload and Download** with progress tracking!\n\n**Coming up in Lesson 7: File Upload and Download**\n- Uploading images, videos, and documents\n- Progress tracking for uploads/downloads\n- Image picker integration\n- Multiple file selection\n- Complete gallery app example\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Pagination loads data in small chunks (20-50 items at a time)\n‚úÖ Two main types: offset-based (page numbers) and cursor-based (unique tokens)\n‚úÖ Infinite scroll automatically loads more data when user scrolls near bottom\n‚úÖ Always use ListView.builder for performance (lazy loading)\n‚úÖ Implement pull-to-refresh for better UX\n‚úÖ Show loading indicators and \"end of list\" messages\n‚úÖ Prevent duplicate loads with a boolean flag (_isLoadingMore)\n‚úÖ Always dispose ScrollController to prevent memory leaks\n\n**You're now ready to build apps that handle thousands of items smoothly!** üéâ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "7.7",
          "title": "Module 7, Lesson 7: File Upload and Download",
          "moduleId": "module-07",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll understand how to upload and download files (images, videos, documents) with progress tracking, just like WhatsApp, Instagram, and Google Drive.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**File upload/download is essential for modern apps.**\n\n- **WhatsApp**: Upload images, videos, documents\n- **Instagram**: Upload photos and videos with stories\n- **Google Drive**: Upload and download any file type\n- **LinkedIn**: Upload profile pictures and resumes\n- **90% of social apps** involve file uploads\n\nIn this lesson, you'll learn the same techniques used by every major app that handles media.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Post Office",
              "content": "\n### Sending a Package (Upload)\nImagine mailing a birthday gift to your friend:\n1. **Pick the item** (select file from device)\n2. **Package it** (prepare file for sending)\n3. **Take to post office** (upload to server)\n4. **Track the package** (progress: 20%, 50%, 100%)\n5. **Receive confirmation** (upload complete!)\n\n### Receiving a Package (Download)\nGetting a package from a friend:\n1. **Get notification** (\"You have a package!\")\n2. **Pick up from post office** (download from server)\n3. **Track delivery** (downloading: 30%, 60%, 100%)\n4. **Unpack and save** (save file to device)\n\n**Flutter file upload/download works exactly the same way!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Types of Files You Can Handle",
              "content": "\n### 1. Images\n- Profile pictures\n- Photo sharing (Instagram-style)\n- Product images (e-commerce)\n\n### 2. Videos\n- Short-form video (TikTok-style)\n- Video messages (WhatsApp-style)\n\n### 3. Documents\n- PDFs (resumes, contracts)\n- Word documents\n- Excel spreadsheets\n\n### 4. Any File Type\n- Audio files\n- Zip archives\n- Custom formats\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up File Picker Packages",
              "content": "\n### Install Required Packages\n\n\nRun:\n\n### Platform-Specific Setup\n\n#### Android (android/app/src/main/AndroidManifest.xml)\n\n\n#### iOS (ios/Runner/Info.plist)\n\n\n",
              "code": "<dict>\n    <!-- Camera Permission -->\n    <key>NSCameraUsageDescription</key>\n    <string>We need camera access to take photos</string>\n\n    <!-- Photo Library Permission -->\n    <key>NSPhotoLibraryUsageDescription</key>\n    <string>We need photo library access to select photos</string>\n\n    <!-- ... -->\n</dict>",
              "language": "xml"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Picking Images (image_picker)",
              "content": "\n### Basic Image Picker\n\n\n### Usage Example:\n\n\n",
              "code": "final imagePickerService = ImagePickerService();\n\n// Pick from gallery\nFile? image = await imagePickerService.pickImageFromGallery();\nif (image != null) {\n  print('Image selected: ${image.path}');\n}\n\n// Pick from camera\nFile? photo = await imagePickerService.pickImageFromCamera();\n\n// Pick multiple\nList<File> images = await imagePickerService.pickMultipleImages();\nprint('Selected ${images.length} images');",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 3: Uploading Files with Dio",
              "content": "\n### Upload Service with Progress Tracking\n\n\n",
              "code": "// lib/services/upload_service.dart\nimport 'package:dio/dio.dart';\nimport 'dart:io';\n\nclass UploadService {\n  final Dio _dio = Dio(\n    BaseOptions(\n      baseUrl: 'https://api.example.com',\n      connectTimeout: const Duration(seconds: 30),\n      receiveTimeout: const Duration(seconds: 30),\n    ),\n  );\n\n  // Upload single image\n  Future<Map<String, dynamic>> uploadImage(\n    File imageFile, {\n    Function(int sent, int total)? onProgress,\n  }) async {\n    try {\n      // Create form data\n      final fileName = imageFile.path.split('/').last;\n      final formData = FormData.fromMap({\n        'image': await MultipartFile.fromFile(\n          imageFile.path,\n          filename: fileName,\n        ),\n        'description': 'Profile photo', // Optional metadata\n      });\n\n      // Upload with progress tracking\n      final response = await _dio.post(\n        '/upload/image',\n        data: formData,\n        onSendProgress: (sent, total) {\n          if (onProgress != null) {\n            onProgress(sent, total);\n          }\n          print('Upload progress: ${(sent / total * 100).toStringAsFixed(0)}%');\n        },\n      );\n\n      return response.data;\n    } on DioException catch (e) {\n      throw _handleError(e);\n    }\n  }\n\n  // Upload multiple images\n  Future<Map<String, dynamic>> uploadMultipleImages(\n    List<File> imageFiles, {\n    Function(int sent, int total)? onProgress,\n  }) async {\n    try {\n      final formData = FormData();\n\n      // Add multiple files\n      for (var i = 0; i < imageFiles.length; i++) {\n        final fileName = imageFiles[i].path.split('/').last;\n        formData.files.add(\n          MapEntry(\n            'images[$i]', // Key for each image\n            await MultipartFile.fromFile(\n              imageFiles[i].path,\n              filename: fileName,\n            ),\n          ),\n        );\n      }\n\n      final response = await _dio.post(\n        '/upload/images',\n        data: formData,\n        onSendProgress: (sent, total) {\n          if (onProgress != null) {\n            onProgress(sent, total);\n          }\n        },\n      );\n\n      return response.data;\n    } on DioException catch (e) {\n      throw _handleError(e);\n    }\n  }\n\n  // Upload any file (PDF, document, etc.)\n  Future<Map<String, dynamic>> uploadFile(\n    File file, {\n    required String fileType, // 'pdf', 'document', etc.\n    Function(int sent, int total)? onProgress,\n  }) async {\n    try {\n      final fileName = file.path.split('/').last;\n      final formData = FormData.fromMap({\n        'file': await MultipartFile.fromFile(\n          file.path,\n          filename: fileName,\n        ),\n        'type': fileType,\n      });\n\n      final response = await _dio.post(\n        '/upload/file',\n        data: formData,\n        onSendProgress: (sent, total) {\n          if (onProgress != null) {\n            onProgress(sent, total);\n          }\n        },\n      );\n\n      return response.data;\n    } on DioException catch (e) {\n      throw _handleError(e);\n    }\n  }\n\n  String _handleError(DioException e) {\n    switch (e.type) {\n      case DioExceptionType.connectionTimeout:\n      case DioExceptionType.sendTimeout:\n        return 'Upload timeout. Check your internet connection.';\n      case DioExceptionType.badResponse:\n        return 'Server error: ${e.response?.statusCode}';\n      default:\n        return 'Upload failed: ${e.message}';\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Image Upload App",
              "content": "\nLet's build a complete app with image selection and upload:\n\n\n",
              "code": "// lib/screens/image_upload_screen.dart\nimport 'package:flutter/material.dart';\nimport 'dart:io';\nimport '../services/image_picker_service.dart';\nimport '../services/upload_service.dart';\n\nclass ImageUploadScreen extends StatefulWidget {\n  const ImageUploadScreen({super.key});\n\n  @override\n  State<ImageUploadScreen> createState() => _ImageUploadScreenState();\n}\n\nclass _ImageUploadScreenState extends State<ImageUploadScreen> {\n  final _imagePickerService = ImagePickerService();\n  final _uploadService = UploadService();\n\n  File? _selectedImage;\n  bool _isUploading = false;\n  double _uploadProgress = 0.0;\n  String? _uploadedImageUrl;\n\n  Future<void> _pickImageFromGallery() async {\n    final image = await _imagePickerService.pickImageFromGallery();\n    if (image != null) {\n      setState(() {\n        _selectedImage = image;\n        _uploadedImageUrl = null;\n      });\n    }\n  }\n\n  Future<void> _pickImageFromCamera() async {\n    final image = await _imagePickerService.pickImageFromCamera();\n    if (image != null) {\n      setState(() {\n        _selectedImage = image;\n        _uploadedImageUrl = null;\n      });\n    }\n  }\n\n  Future<void> _uploadImage() async {\n    if (_selectedImage == null) return;\n\n    setState(() {\n      _isUploading = true;\n      _uploadProgress = 0.0;\n    });\n\n    try {\n      final result = await _uploadService.uploadImage(\n        _selectedImage!,\n        onProgress: (sent, total) {\n          setState(() {\n            _uploadProgress = sent / total;\n          });\n        },\n      );\n\n      setState(() {\n        _isUploading = false;\n        _uploadedImageUrl = result['url']; // Assuming server returns URL\n      });\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Image uploaded successfully!')),\n        );\n      }\n    } catch (e) {\n      setState(() {\n        _isUploading = false;\n      });\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Upload failed: $e')),\n        );\n      }\n    }\n  }\n\n  Future<void> _showImageSourceDialog() async {\n    return showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: const Text('Select Image Source'),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            ListTile(\n              leading: const Icon(Icons.photo_library),\n              title: const Text('Gallery'),\n              onTap: () {\n                Navigator.pop(context);\n                _pickImageFromGallery();\n              },\n            ),\n            ListTile(\n              leading: const Icon(Icons.camera_alt),\n              title: const Text('Camera'),\n              onTap: () {\n                Navigator.pop(context);\n                _pickImageFromCamera();\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Image Upload'),\n      ),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(24.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // Image preview\n            if (_selectedImage != null)\n              Container(\n                height: 300,\n                decoration: BoxDecoration(\n                  borderRadius: BorderRadius.circular(12),\n                  border: Border.all(color: Colors.grey.shade300),\n                ),\n                child: ClipRRect(\n                  borderRadius: BorderRadius.circular(12),\n                  child: Image.file(\n                    _selectedImage!,\n                    fit: BoxFit.cover,\n                  ),\n                ),\n              )\n            else\n              Container(\n                height: 300,\n                decoration: BoxDecoration(\n                  color: Colors.grey.shade100,\n                  borderRadius: BorderRadius.circular(12),\n                  border: Border.all(color: Colors.grey.shade300),\n                ),\n                child: Center(\n                  child: Column(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    children: [\n                      Icon(\n                        Icons.image_outlined,\n                        size: 80,\n                        color: Colors.grey.shade400,\n                      ),\n                      const SizedBox(height: 16),\n                      Text(\n                        'No image selected',\n                        style: TextStyle(\n                          color: Colors.grey.shade600,\n                          fontSize: 16,\n                        ),\n                      ),\n                    ],\n                  ),\n                ),\n              ),\n\n            const SizedBox(height: 24),\n\n            // Select image button\n            OutlinedButton.icon(\n              onPressed: _isUploading ? null : _showImageSourceDialog,\n              icon: const Icon(Icons.add_photo_alternate),\n              label: const Text('Select Image'),\n              style: OutlinedButton.styleFrom(\n                padding: const EdgeInsets.symmetric(vertical: 16),\n              ),\n            ),\n\n            const SizedBox(height: 16),\n\n            // Upload button\n            FilledButton.icon(\n              onPressed: (_selectedImage != null && !_isUploading)\n                  ? _uploadImage\n                  : null,\n              icon: _isUploading\n                  ? const SizedBox(\n                      width: 20,\n                      height: 20,\n                      child: CircularProgressIndicator(\n                        strokeWidth: 2,\n                        color: Colors.white,\n                      ),\n                    )\n                  : const Icon(Icons.cloud_upload),\n              label: Text(_isUploading ? 'Uploading...' : 'Upload Image'),\n              style: FilledButton.styleFrom(\n                padding: const EdgeInsets.symmetric(vertical: 16),\n              ),\n            ),\n\n            // Upload progress\n            if (_isUploading) ...[\n              const SizedBox(height: 16),\n              LinearProgressIndicator(value: _uploadProgress),\n              const SizedBox(height: 8),\n              Text(\n                '${(_uploadProgress * 100).toStringAsFixed(0)}% uploaded',\n                textAlign: TextAlign.center,\n                style: TextStyle(color: Colors.grey.shade600),\n              ),\n            ],\n\n            // Success message\n            if (_uploadedImageUrl != null) ...[\n              const SizedBox(height: 24),\n              Container(\n                padding: const EdgeInsets.all(16),\n                decoration: BoxDecoration(\n                  color: Colors.green.shade50,\n                  borderRadius: BorderRadius.circular(8),\n                  border: Border.all(color: Colors.green.shade200),\n                ),\n                child: Row(\n                  children: [\n                    Icon(Icons.check_circle, color: Colors.green.shade700),\n                    const SizedBox(width: 12),\n                    Expanded(\n                      child: Column(\n                        crossAxisAlignment: CrossAxisAlignment.start,\n                        children: [\n                          Text(\n                            'Upload successful!',\n                            style: TextStyle(\n                              color: Colors.green.shade900,\n                              fontWeight: FontWeight.bold,\n                            ),\n                          ),\n                          const SizedBox(height: 4),\n                          Text(\n                            _uploadedImageUrl!,\n                            style: TextStyle(\n                              color: Colors.green.shade700,\n                              fontSize: 12,\n                            ),\n                            maxLines: 1,\n                            overflow: TextOverflow.ellipsis,\n                          ),\n                        ],\n                      ),\n                    ),\n                  ],\n                ),\n              ),\n            ],\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### ‚úÖ DO:\n1. **Compress images before upload** (use maxWidth, maxHeight, imageQuality)\n2. **Show upload progress** (users need feedback on long uploads)\n3. **Handle permission denials gracefully**\n4. **Set appropriate timeouts** (30-60 seconds for file uploads)\n5. **Validate file types** before upload (check extensions)\n6. **Limit file sizes** (e.g., max 10MB per image)\n7. **Show file names and sizes** in the UI\n8. **Allow users to cancel uploads**\n\n### ‚ùå DON'T:\n1. **Don't upload full-resolution images** (wastes bandwidth and storage)\n2. **Don't upload without showing progress** (bad UX for large files)\n3. **Don't forget to handle errors** (network issues, server errors)\n4. **Don't upload to HTTP endpoints** (always use HTTPS for security)\n5. **Don't store uploaded files in app memory** (use temporary directories)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Testing File Upload (Without Real Backend)",
              "content": "\nYou can test file uploads using these free services:\n\n### 1. File.io (Temporary Upload)\n\n### 2. Imgur (Image Upload)\nSign up for free API key at https://api.imgur.com/oauth2/addclient\n\n\n",
              "code": "final dio = Dio();\ndio.options.headers['Authorization'] = 'Client-ID YOUR_CLIENT_ID';\n\nfinal formData = FormData.fromMap({\n  'image': await MultipartFile.fromFile(imageFile.path),\n});\n\nfinal response = await dio.post(\n  'https://api.imgur.com/3/image',\n  data: formData,\n);\n// Returns image URL",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\nTest your understanding:\n\n### Question 1\nWhy should you compress images before uploading?\n\nA) To make the app faster\nB) To reduce bandwidth usage, server storage, and upload time\nC) Because Flutter requires it\nD) To improve image quality\n\n### Question 2\nWhat's the difference between image_picker and file_picker?\n\nA) They're the same\nB) image_picker is for images/videos only, file_picker handles any file type\nC) file_picker is faster\nD) image_picker only works on Android\n\n### Question 3\nWhy is progress tracking important for file uploads?\n\nA) It's required by the API\nB) It provides user feedback, especially for large files, so they know the upload isn't stuck\nC) It makes uploads faster\nD) It's only needed for videos\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: To reduce bandwidth usage, server storage, and upload time\n\nFull-resolution images can be 5-10MB each. By compressing to 85% quality and resizing to 1920x1080, you can reduce this to 500KB-1MB without noticeable quality loss. This saves bandwidth, speeds up uploads, and reduces server storage costs.\n\n### Answer 2: B\n**Correct**: image_picker is for images/videos only, file_picker handles any file type\n\nimage_picker is optimized for images and videos with built-in camera support and image quality settings. file_picker is more general-purpose and can handle PDFs, documents, ZIP files, and any other file type.\n\n### Answer 3: B\n**Correct**: It provides user feedback, especially for large files, so they know the upload isn't stuck\n\nWithout progress tracking, users might think the app froze when uploading a large file (e.g., 50MB video). Progress indicators (20%, 50%, 100%) reassure users that the upload is working and show how long it will take.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've learned how to upload and download files with progress tracking. In the next lesson, we'll build a **Mini-Project** that combines everything from Module 7!\n\n**Coming up in Lesson 8: Mini-Project - Complete Social Media App**\n- Combine all networking concepts\n- User authentication\n- Feed with pagination\n- Image upload (post creation)\n- Comments and likes\n- Complete production-ready app\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ image_picker handles images/videos from camera/gallery\n‚úÖ file_picker handles any file type (PDFs, documents, etc.)\n‚úÖ Always compress images before upload (maxWidth, maxHeight, imageQuality)\n‚úÖ Use Dio's FormData and MultipartFile for uploads\n‚úÖ Track progress with onSendProgress and onReceiveProgress callbacks\n‚úÖ Show progress indicators for better UX (especially for large files)\n‚úÖ Handle errors gracefully (network issues, permission denials)\n‚úÖ Set appropriate timeouts (30-60 seconds for file uploads)\n\n**You're now ready to build apps with file upload/download like Instagram and WhatsApp!** üéâ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "7.8",
          "title": "Module 7, Lesson 8: Mini-Project - Social Media App",
          "moduleId": "module-07",
          "order": 8,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\n**Welcome to your Module 7 capstone project!** üéâ\n\nIn this mini-project, you'll build a complete social media app called **\"FlutterGram\"** that combines **EVERY concept** you've learned in Module 7:\n\n‚úÖ HTTP requests (GET, POST, PUT, DELETE)\n‚úÖ JSON parsing and serialization\n‚úÖ Error handling and loading states\n‚úÖ Authentication with JWT tokens\n‚úÖ Dio package with interceptors\n‚úÖ Pagination and infinite scroll\n‚úÖ File upload (images)\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You'll Build",
              "content": "\n### FlutterGram Features\n\n1. **Authentication**\n   - Login screen\n   - Register screen\n   - Secure token storage\n   - Auto-logout on token expiration\n\n2. **Feed**\n   - Infinite scroll feed of posts\n   - Pull-to-refresh\n   - Loading states\n   - Error handling with retry\n\n3. **Create Post**\n   - Image picker (camera/gallery)\n   - Image preview\n   - Upload with progress\n   - Caption input\n\n4. **User Profile**\n   - View profile information\n   - Post count\n   - Logout functionality\n\n5. **Production-Ready Code**\n   - Clean architecture\n   - Reusable widgets\n   - Error handling\n   - State management\n\n"
            },
            {
              "type": "THEORY",
              "title": "Step 1: Setup and Dependencies",
              "content": "\n### pubspec.yaml\n\n\nRun:\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 2: Create Models",
              "content": "\n### User Model\n\n\n### Post Model\n\n\nGenerate the code:\n\n",
              "code": "flutter pub run build_runner build --delete-conflicting-outputs",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 6: Create Reusable Widgets",
              "content": "\n### Post Card Widget\n\n\n### Error View Widget\n\n\n",
              "code": "// lib/widgets/error_view.dart\nimport 'package:flutter/material.dart';\n\nclass ErrorView extends StatelessWidget {\n  final String message;\n  final VoidCallback onRetry;\n\n  const ErrorView({\n    super.key,\n    required this.message,\n    required this.onRetry,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Padding(\n        padding: const EdgeInsets.all(24.0),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(\n              Icons.error_outline,\n              size: 64,\n              color: Colors.red.shade300,\n            ),\n            const SizedBox(height: 16),\n            Text(\n              'Oops!',\n              style: Theme.of(context).textTheme.headlineSmall,\n            ),\n            const SizedBox(height: 8),\n            Text(\n              message,\n              textAlign: TextAlign.center,\n              style: TextStyle(color: Colors.grey.shade600),\n            ),\n            const SizedBox(height: 24),\n            FilledButton.icon(\n              onPressed: onRetry,\n              icon: const Icon(Icons.refresh),\n              label: const Text('Try Again'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 7: Create Screens",
              "content": "\n### Login Screen\n\n\n### Feed Screen with Infinite Scroll\n\n\n### Create Post Screen\n\n\n",
              "code": "// lib/screens/create/create_post_screen.dart\nimport 'package:flutter/material.dart';\nimport 'package:image_picker/image_picker.dart';\nimport 'dart:io';\nimport '../../services/posts_service.dart';\n\nclass CreatePostScreen extends StatefulWidget {\n  const CreatePostScreen({super.key});\n\n  @override\n  State<CreatePostScreen> createState() => _CreatePostScreenState();\n}\n\nclass _CreatePostScreenState extends State<CreatePostScreen> {\n  final _postsService = PostsService();\n  final _imagePicker = ImagePicker();\n  final _captionController = TextEditingController();\n\n  File? _selectedImage;\n  bool _isUploading = false;\n  double _uploadProgress = 0.0;\n\n  @override\n  void dispose() {\n    _captionController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _pickImage(ImageSource source) async {\n    try {\n      final XFile? image = await _imagePicker.pickImage(\n        source: source,\n        maxWidth: 1920,\n        maxHeight: 1080,\n        imageQuality: 85,\n      );\n\n      if (image != null) {\n        setState(() {\n          _selectedImage = File(image.path);\n        });\n      }\n    } catch (e) {\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Failed to pick image: $e')),\n        );\n      }\n    }\n  }\n\n  Future<void> _createPost() async {\n    if (_selectedImage == null) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text('Please select an image')),\n      );\n      return;\n    }\n\n    setState(() {\n      _isUploading = true;\n      _uploadProgress = 0.0;\n    });\n\n    try {\n      await _postsService.createPost(\n        imageFile: _selectedImage!,\n        caption: _captionController.text,\n        onProgress: (sent, total) {\n          setState(() {\n            _uploadProgress = sent / total;\n          });\n        },\n      );\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Post created successfully!')),\n        );\n        Navigator.of(context).pop(true); // Return true to refresh feed\n      }\n    } catch (e) {\n      setState(() {\n        _isUploading = false;\n      });\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Failed to create post: $e')),\n        );\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Create Post'),\n        actions: [\n          TextButton(\n            onPressed: (_selectedImage != null && !_isUploading)\n                ? _createPost\n                : null,\n            child: const Text('Post'),\n          ),\n        ],\n      ),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // Image preview\n            if (_selectedImage != null)\n              AspectRatio(\n                aspectRatio: 1.0,\n                child: ClipRRect(\n                  borderRadius: BorderRadius.circular(12),\n                  child: Image.file(\n                    _selectedImage!,\n                    fit: BoxFit.cover,\n                  ),\n                ),\n              )\n            else\n              AspectRatio(\n                aspectRatio: 1.0,\n                child: Container(\n                  decoration: BoxDecoration(\n                    color: Colors.grey.shade100,\n                    borderRadius: BorderRadius.circular(12),\n                  ),\n                  child: Column(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    children: [\n                      Icon(\n                        Icons.add_photo_alternate_outlined,\n                        size: 64,\n                        color: Colors.grey.shade400,\n                      ),\n                      const SizedBox(height: 16),\n                      Text(\n                        'Select a photo',\n                        style: TextStyle(\n                          color: Colors.grey.shade600,\n                          fontSize: 16,\n                        ),\n                      ),\n                    ],\n                  ),\n                ),\n              ),\n\n            const SizedBox(height: 16),\n\n            // Image source buttons\n            if (_selectedImage == null)\n              Row(\n                children: [\n                  Expanded(\n                    child: OutlinedButton.icon(\n                      onPressed: () => _pickImage(ImageSource.gallery),\n                      icon: const Icon(Icons.photo_library),\n                      label: const Text('Gallery'),\n                    ),\n                  ),\n                  const SizedBox(width: 16),\n                  Expanded(\n                    child: OutlinedButton.icon(\n                      onPressed: () => _pickImage(ImageSource.camera),\n                      icon: const Icon(Icons.camera_alt),\n                      label: const Text('Camera'),\n                    ),\n                  ),\n                ],\n              ),\n\n            const SizedBox(height: 24),\n\n            // Caption input\n            TextField(\n              controller: _captionController,\n              decoration: const InputDecoration(\n                labelText: 'Caption',\n                hintText: 'Write a caption...',\n                border: OutlineInputBorder(),\n              ),\n              maxLines: 3,\n              enabled: !_isUploading,\n            ),\n\n            // Upload progress\n            if (_isUploading) ...[\n              const SizedBox(height: 24),\n              LinearProgressIndicator(value: _uploadProgress),\n              const SizedBox(height: 8),\n              Text(\n                'Uploading... ${(_uploadProgress * 100).toStringAsFixed(0)}%',\n                textAlign: TextAlign.center,\n                style: TextStyle(color: Colors.grey.shade600),\n              ),\n            ],\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What You've Accomplished",
              "content": "\nCongratulations! You've built a complete social media app that demonstrates:\n\n‚úÖ **HTTP Requests**: GET (feed), POST (create post, login), DELETE (logout)\n‚úÖ **JSON Parsing**: User and Post models with json_serializable\n‚úÖ **Error Handling**: User-friendly error messages, retry logic\n‚úÖ **Authentication**: Login, register, secure token storage, auto-logout\n‚úÖ **Dio with Interceptors**: Auto token injection, logging, global error handling\n‚úÖ **Pagination**: Infinite scroll with pull-to-refresh\n‚úÖ **File Upload**: Image picker, upload with progress tracking\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps & Enhancements",
              "content": "\nWant to take this further? Try adding:\n\n1. **Comments System**: Add, view, delete comments on posts\n2. **Like Animation**: Heart animation when double-tapping posts\n3. **User Profiles**: View other users' profiles and posts\n4. **Search**: Search for users and hashtags\n5. **Notifications**: Push notifications for likes and comments\n6. **Stories**: Instagram-style stories that disappear after 24 hours\n7. **Direct Messages**: Chat feature between users\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Clean architecture separates concerns (models, services, screens, widgets)\n‚úÖ Dio interceptors eliminate repetitive code (auth headers, logging)\n‚úÖ Reusable widgets (PostCard, ErrorView) improve maintainability\n‚úÖ Proper error handling creates professional user experience\n‚úÖ Progress tracking provides feedback for long operations\n‚úÖ Pagination prevents memory issues and improves performance\n\n"
            },
            {
              "type": "THEORY",
              "title": "Congratulations! üéâ",
              "content": "\n**You've completed Module 7: Networking and API Integration!**\n\nYou now have the skills to build production-ready apps that:\n- Connect to real-world APIs\n- Handle authentication securely\n- Upload and download files\n- Manage large datasets efficiently\n- Provide excellent user experience with loading states and error handling\n\n**You're ready for Module 8: Backend Integration** where you'll learn to connect Flutter apps to Firebase, Supabase, and other backend services!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhy use interceptors in Dio?\n\nA) To make requests faster\nB) To automatically modify all requests/responses in one place (like adding auth headers)\nC) To compress data\nD) To cache responses\n\n### Question 2\nWhat's the benefit of separating services from screens?\n\nA) It makes the code longer\nB) It improves code organization, testability, and reusability\nC) It's required by Flutter\nD) It makes the app faster\n\n### Question 3\nWhy implement pagination instead of loading all posts at once?\n\nA) It looks better\nB) It prevents memory issues, reduces server load, and improves performance\nC) It's easier to code\nD) APIs require it\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: To automatically modify all requests/responses in one place\n\nInterceptors allow you to add headers (like auth tokens), log requests, handle errors, and retry failed requests in one central place. Without interceptors, you'd have to repeat this code for every single API call.\n\n### Answer 2: B\n**Correct**: It improves code organization, testability, and reusability\n\nSeparating services from UI makes your code modular. You can test services independently, reuse them across multiple screens, and easily swap implementations (e.g., switch from one API to another).\n\n### Answer 3: B\n**Correct**: It prevents memory issues, reduces server load, and improves performance\n\nLoading 10,000 posts at once would consume excessive memory, slow down the app, and waste bandwidth. Pagination loads data in small chunks (20-50 items), providing a smooth experience while reducing resource usage.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Module 7 Complete!** You're now a Flutter networking expert! üöÄ\n\n"
            }
          ],
          "challenges": []
        }
      ]
    },
    {
      "id": "module-08",
      "title": "Module 8: Flutter Development",
      "description": "Learn Flutter development - Module 8",
      "difficulty": "intermediate",
      "estimatedHours": 8,
      "lessons": [
        {
          "id": "8.1",
          "title": "Module 8, Lesson 1: Introduction to Backend Services & Firebase Setup",
          "moduleId": "module-08",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll understand what a backend is, why apps need one, and how to set up Firebase - Google's powerful backend platform for Flutter.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Every successful app needs a backend.**\n\n- **Instagram**: Stores billions of photos and user data\n- **WhatsApp**: Delivers messages in real-time to millions of users\n- **Uber**: Coordinates drivers and riders across the globe\n- **99% of apps** you use daily rely on a backend\n- **Without a backend**, your app can't store data, sync across devices, or communicate with other users\n\nIn this module, you'll learn to connect your Flutter app to a real backend, transforming it from a local-only app to a fully connected, cloud-powered application.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Restaurant",
              "content": "\n### Frontend (Your Flutter App) = The Dining Room\nThis is what customers see and interact with:\n- ü™ë Tables and chairs (UI widgets)\n- üìã Menu (app screens)\n- üçΩÔ∏è Plates and silverware (controls like buttons)\n\n**What it CANNOT do**:\n- ‚ùå Store food ingredients\n- ‚ùå Cook the meals\n- ‚ùå Manage inventory\n\n### Backend (Cloud Server) = The Kitchen\nThis is the behind-the-scenes operation:\n- üç≥ Cooks prepare the food (process data)\n- üì¶ Storage for ingredients (database)\n- üë®‚Äçüç≥ Multiple chefs coordinate (handles many users at once)\n- üìù Recipe book (business logic)\n\n**Your Flutter app (dining room) talks to the backend (kitchen) through the waiter (API).**\n\n"
            },
            {
              "type": "THEORY",
              "title": "What is a Backend?",
              "content": "\nA **backend** is a server (computer running 24/7 in the cloud) that:\n\n1. **Stores Data**: User accounts, posts, messages, photos\n2. **Processes Requests**: Validates login, searches data, sends notifications\n3. **Coordinates Users**: Syncs data across devices, enables real-time features\n4. **Enforces Rules**: Who can see what, who can do what\n\n### Frontend vs Backend\n\n| Frontend (Flutter App) | Backend (Server) |\n|------------------------|------------------|\n| Runs on user's phone | Runs in the cloud |\n| Shows UI | Stores data |\n| Accepts input | Processes logic |\n| Temporary storage | Permanent storage |\n| **One device** | **All devices** |\n\n"
            },
            {
              "type": "THEORY",
              "title": "Backend Options for Flutter",
              "content": "\n### 1. Firebase (Google) ‚≠ê **Recommended for Beginners**\n\n**Pros**:\n- ‚úÖ Free tier (generous limits)\n- ‚úÖ Easy setup (< 30 minutes)\n- ‚úÖ Official Flutter support\n- ‚úÖ No backend code required\n- ‚úÖ Real-time database\n- ‚úÖ Authentication built-in\n- ‚úÖ File storage included\n- ‚úÖ Scales automatically\n\n**Cons**:\n- ‚ùå Vendor lock-in (tied to Google)\n- ‚ùå Pricing can get expensive at scale\n- ‚ùå Limited query capabilities\n\n**Best for**: MVPs, startups, learning, prototypes\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### 2. Supabase (Open Source Firebase Alternative)\n\n**Pros**:\n- ‚úÖ Open source\n- ‚úÖ Postgres database (powerful queries)\n- ‚úÖ Self-hosting option\n- ‚úÖ Generous free tier\n- ‚úÖ Real-time subscriptions\n- ‚úÖ Built-in authentication\n\n**Cons**:\n- ‚ùå Newer (less mature than Firebase)\n- ‚ùå Smaller community\n- ‚ùå More complex setup\n\n**Best for**: Developers who want SQL, open source fans\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### 3. AWS Amplify (Amazon)\n\n**Pros**:\n- ‚úÖ Extremely scalable\n- ‚úÖ Full AWS ecosystem access\n- ‚úÖ Powerful for large apps\n\n**Cons**:\n- ‚ùå Complex setup\n- ‚ùå Steeper learning curve\n- ‚ùå Can be expensive\n\n**Best for**: Enterprise apps, large-scale projects\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### 4. Custom Backend (Node.js, Django, etc.)\n\n**Pros**:\n- ‚úÖ Complete control\n- ‚úÖ No vendor lock-in\n- ‚úÖ Custom business logic\n\n**Cons**:\n- ‚ùå Must write and maintain server code\n- ‚ùå Must handle scaling\n- ‚ùå Must manage infrastructure\n- ‚ùå Security is your responsibility\n\n**Best for**: Advanced developers, specific requirements\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why Firebase for This Course?",
              "content": "\nWe're using Firebase because it's:\n\n1. **Beginner-Friendly**: No backend code to write\n2. **Well-Documented**: Excellent Flutter integration\n3. **Production-Ready**: Powers apps with millions of users\n4. **Free to Start**: Generous free tier for learning\n5. **Comprehensive**: Auth, database, storage, hosting all included\n\n**Companies using Firebase**: Duolingo, The New York Times, Alibaba, Venmo, Trivago\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "A Word About Vendor Lock-In (2025 Reality)",
              "content": "\n### What is Vendor Lock-In?\n\nWhen you build your entire app on one platform (Firebase, AWS, Azure), switching later becomes expensive and time-consuming. This matters because:\n\n1. **Pricing changes**: Platforms can raise prices\n2. **Feature deprecation**: Services get discontinued (remember Parse?)\n3. **Compliance requirements**: Some clients require self-hosted solutions\n4. **Acquisition risks**: Platforms get sold/changed\n\n### Our Approach in This Module\n\nWe're teaching Firebase first because:\n- Fastest way to learn backend concepts\n- Excellent Flutter integration\n- Free tier is generous for learning\n\n**BUT** - we also teach Supabase in Lesson 1.5 so you:\n- Understand alternatives exist\n- Can choose the right tool for each project\n- Aren't dependent on any single vendor\n\n### Professional Best Practice\n\n**Abstract your backend code!** Instead of calling Firebase directly everywhere:\n\n```dart\n// Bad: Firebase everywhere\nawait FirebaseFirestore.instance.collection('users').add(data);\n\n// Good: Repository pattern\nawait userRepository.create(data);\n\n// The repository can use Firebase, Supabase, or custom API\nabstract class UserRepository {\n  Future<void> create(Map<String, dynamic> data);\n}\n\nclass FirebaseUserRepository implements UserRepository { ... }\nclass SupabaseUserRepository implements UserRepository { ... }\n```\n\nThis makes switching backends a matter of swapping implementations, not rewriting your entire app!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Firebase Services Overview",
              "content": "\nFirebase provides multiple services:\n\n### 1. **Authentication** üîê\n- Email/password login\n- Google Sign-In\n- Facebook, Apple, Twitter login\n- Phone number authentication\n- Anonymous users\n\n### 2. **Cloud Firestore** (NoSQL Database) üìä\n- Store and sync data\n- Real-time updates\n- Offline support\n- Powerful queries\n- Automatic scaling\n\n### 3. **Realtime Database** üì°\n- JSON tree structure\n- Extremely low latency\n- Simple sync\n\n### 4. **Cloud Storage** üìÅ\n- Upload images, videos, files\n- Secure file storage\n- Download URLs\n\n### 5. **Cloud Functions** ‚ö° (Optional)\n- Run backend code without a server\n- Triggered by events\n\n### 6. **Cloud Messaging** üì≤ (Push Notifications)\n- Send notifications to users\n- Topic-based messaging\n\n### 7. **Analytics** üìà\n- Track user behavior\n- App performance metrics\n\n"
            },
            {
              "type": "THEORY",
              "title": "Firebase Pricing",
              "content": "\n### Free Tier (Spark Plan)\n\nPerfect for learning and small apps:\n- **Authentication**: 10K active users/month\n- **Firestore**: 1 GB storage, 50K reads/day\n- **Storage**: 5 GB storage, 1 GB downloads/day\n- **Hosting**: 10 GB bandwidth/month\n\n**This is MORE than enough for learning and small apps!**\n\n### Paid Tier (Blaze Plan)\n\nPay-as-you-go after exceeding free limits. Most indie apps stay under $5-20/month.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Firebase",
              "content": "\n### Prerequisites\n\n- ‚úÖ Flutter project created\n- ‚úÖ Google account (Gmail)\n- ‚úÖ Firebase CLI installed\n\n"
            },
            {
              "type": "THEORY",
              "title": "Step 1: Install Firebase CLI",
              "content": "\n### On macOS/Linux:\n\n### On Windows:\nDownload installer from: https://firebase.google.com/docs/cli#windows-standalone-binary\n\n### Verify Installation:\n\n",
              "code": "firebase --version\n# Should output: 13.x.x or newer",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 2: Login to Firebase",
              "content": "\n\nThis will open your browser. Sign in with your Google account.\n\n",
              "code": "firebase login",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 3: Install FlutterFire CLI",
              "content": "\n\n### Verify Installation:\n\n",
              "code": "flutterfire --version\n# Should output: 1.x.x or newer",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 4: Create Firebase Project",
              "content": "\n### Option A: Using Firebase Console (Web)\n\n1. Go to https://console.firebase.google.com\n2. Click **\"Add project\"**\n3. Enter project name: e.g., `fluttergram-demo`\n4. **(Optional)** Enable Google Analytics (recommended)\n5. Click **\"Create project\"**\n6. Wait ~30 seconds for setup to complete\n\n### Option B: Using CLI\n\n\n",
              "code": "firebase projects:create fluttergram-demo",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 5: Configure Firebase for Flutter",
              "content": "\n**Navigate to your Flutter project directory:**\n\n\n**Run FlutterFire configure:**\n\n\nThis command will:\n1. Scan your project\n2. Ask you to select a Firebase project (choose the one you created)\n3. Ask which platforms to configure (select All: iOS, Android, Web, macOS, Windows)\n4. Generate `firebase_options.dart` file automatically\n\n**Expected output:**\n\n",
              "code": "‚úî Firebase project selected\n‚úî Registering app...\n‚úî Generating firebase_options.dart...\n‚úî Firebase configuration complete!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 6: Add Firebase Packages",
              "content": "\nEdit your `pubspec.yaml`:\n\n\n**Run:**\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 7: Initialize Firebase in Your App",
              "content": "\n### Update `lib/main.dart`:\n\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:firebase_core/firebase_core.dart';\nimport 'firebase_options.dart'; // Generated by FlutterFire CLI\n\nvoid main() async {\n  // Ensure Flutter bindings are initialized\n  WidgetsFlutterBinding.ensureInitialized();\n\n  // Initialize Firebase\n  await Firebase.initializeApp(\n    options: DefaultFirebaseOptions.currentPlatform,\n  );\n\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Firebase Demo',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),\n        useMaterial3: true,\n      ),\n      home: const HomeScreen(),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Firebase is Ready!'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(\n              Icons.check_circle,\n              size: 100,\n              color: Colors.green.shade600,\n            ),\n            const SizedBox(height: 24),\n            const Text(\n              'Firebase Initialized Successfully!',\n              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 16),\n            Text(\n              'You\\'re ready to use Firebase services',\n              style: TextStyle(color: Colors.grey.shade600),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 8: Test Your Setup",
              "content": "\n**Run your app:**\n\n\n**Expected result**: You should see \"Firebase Initialized Successfully!\" on the screen.\n\n### Check the console logs:\n\nYou should see something like:\n\n**No errors? Congratulations! Firebase is now connected to your Flutter app! üéâ**\n\n",
              "code": "[Firebase] Configured\n[Firebase] Connecting to Firebase backend...",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Setup Issues and Solutions",
              "content": "\n### Issue 1: \"Firebase already exists\"\n**Solution**: Use a different project name or select existing project during `flutterfire configure`\n\n### Issue 2: \"Package 'firebase_core' has no versions...\"\n**Solution**: Run `flutter pub upgrade` and ensure you have stable Flutter channel\n\n### Issue 3: \"Build failed on iOS\"\n**Solution**:\n\n### Issue 4: \"Gradle build failed on Android\"\n**Solution**: Ensure your `android/app/build.gradle` has:\n\n### Issue 5: \"Multiple dex files define...\"\n**Solution**: Add to `android/app/build.gradle`:\n\n",
              "code": "android {\n    // ...\n    packagingOptions {\n        exclude 'META-INF/DEPENDENCIES'\n    }\n}",
              "language": "gradle"
            },
            {
              "type": "THEORY",
              "title": "Verifying Your Firebase Connection",
              "content": "\n### Test Connection with a Simple Read\n\nUpdate `HomeScreen` to fetch Firebase app name:\n\n\n**Run the app again**. You should see your Firebase project details displayed on screen!\n\n",
              "code": "import 'package:firebase_core/firebase_core.dart';\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Get Firebase app instance\n    final firebaseApp = Firebase.app();\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Firebase Connection Test'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(\n              Icons.cloud_done,\n              size: 100,\n              color: Colors.green.shade600,\n            ),\n            const SizedBox(height: 24),\n            const Text(\n              'Connected to Firebase!',\n              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 16),\n            Container(\n              padding: const EdgeInsets.all(16),\n              margin: const EdgeInsets.symmetric(horizontal: 32),\n              decoration: BoxDecoration(\n                color: Colors.blue.shade50,\n                borderRadius: BorderRadius.circular(12),\n              ),\n              child: Column(\n                children: [\n                  Text(\n                    'Firebase App Name:',\n                    style: TextStyle(color: Colors.grey.shade700),\n                  ),\n                  const SizedBox(height: 4),\n                  Text(\n                    firebaseApp.name,\n                    style: const TextStyle(\n                      fontSize: 18,\n                      fontWeight: FontWeight.bold,\n                    ),\n                  ),\n                  const SizedBox(height: 16),\n                  Text(\n                    'Firebase Options:',\n                    style: TextStyle(color: Colors.grey.shade700),\n                  ),\n                  const SizedBox(height: 4),\n                  Text(\n                    'Project ID: ${firebaseApp.options.projectId}',\n                    style: const TextStyle(fontSize: 12),\n                  ),\n                ],\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's in `firebase_options.dart`?",
              "content": "\nThe auto-generated file contains your Firebase configuration:\n\n\n**This file is safe to commit to Git** (it's not sensitive data, just configuration).\n\n",
              "code": "// This file is generated by flutterfire_cli\nclass DefaultFirebaseOptions {\n  static FirebaseOptions get currentPlatform {\n    if (kIsWeb) {\n      return web;\n    }\n    switch (defaultTargetPlatform) {\n      case TargetPlatform.android:\n        return android;\n      case TargetPlatform.iOS:\n        return ios;\n      case TargetPlatform.macOS:\n        return macos;\n      // ... other platforms\n      default:\n        throw UnsupportedError('DefaultFirebaseOptions not configured');\n    }\n  }\n\n  static const FirebaseOptions web = FirebaseOptions(\n    apiKey: 'YOUR_WEB_API_KEY',\n    appId: 'YOUR_WEB_APP_ID',\n    projectId: 'your-project-id',\n    // ...\n  );\n\n  static const FirebaseOptions android = FirebaseOptions(\n    apiKey: 'YOUR_ANDROID_API_KEY',\n    appId: 'YOUR_ANDROID_APP_ID',\n    projectId: 'your-project-id',\n    // ...\n  );\n\n  // ... iOS, macOS, etc.\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Firebase Project Structure",
              "content": "\nAfter setup, your Firebase project has:\n\n### 1. **Console** (https://console.firebase.google.com)\n- View data\n- Manage users\n- Monitor usage\n- Configure settings\n\n### 2. **Authentication**\n- User management\n- Sign-in methods configuration\n\n### 3. **Firestore Database**\n- NoSQL database\n- Collections and documents\n- Security rules\n\n### 4. **Storage**\n- File uploads\n- Access control\n\n### 5. **Settings**\n- API keys\n- Project settings\n- Team members\n\n"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### ‚úÖ DO:\n1. **Use environment variables** for different Firebase projects (dev, staging, prod)\n2. **Enable App Check** (prevents abuse from unauthorized apps)\n3. **Set up security rules** before going to production\n4. **Monitor usage** to avoid surprise bills\n5. **Use emulators** for local testing (covered in later lessons)\n\n### ‚ùå DON'T:\n1. **Don't share API keys publicly** (though they're not super sensitive, still avoid it)\n2. **Don't commit `.env` files** with secrets\n3. **Don't skip security rules** (anyone can read/write by default!)\n4. **Don't use production Firebase** for testing\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\nTest your understanding:\n\n### Question 1\nWhat is the main purpose of a backend?\n\nA) To make the app look better\nB) To store data, process requests, and coordinate users across devices\nC) To make the app run faster\nD) To add animations\n\n### Question 2\nWhy is Firebase a good choice for beginners?\n\nA) It's the cheapest option\nB) It requires no backend code and has official Flutter support\nC) It's the fastest backend\nD) It works only on Android\n\n### Question 3\nWhat does the `flutterfire configure` command do?\n\nA) It installs Flutter\nB) It generates firebase_options.dart with your project configuration\nC) It creates a new Flutter app\nD) It runs your app\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: To store data, process requests, and coordinate users across devices\n\nThe backend handles everything that can't be done on the user's device: permanent data storage, processing for multiple users, enforcing security rules, and syncing data across devices.\n\n### Answer 2: B\n**Correct**: It requires no backend code and has official Flutter support\n\nFirebase is a Backend-as-a-Service (BaaS) that eliminates the need to write and maintain server code. FlutterFire (official Firebase Flutter plugin) makes integration seamless with excellent documentation.\n\n### Answer 3: B\n**Correct**: It generates firebase_options.dart with your project configuration\n\nThe FlutterFire CLI automatically registers your app with Firebase and generates a `firebase_options.dart` file containing all the configuration needed to connect your Flutter app to your Firebase project across all platforms.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've successfully set up Firebase! In the next lesson, we'll implement **Firebase Authentication** to add user registration and login to your app.\n\n**Coming up in Lesson 2: Firebase Authentication**\n- Email/password authentication\n- Google Sign-In\n- User session management\n- Secure login flows\n- Complete authentication UI\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ A backend stores data, processes logic, and coordinates multiple users\n‚úÖ Firebase is a complete backend solution with no server code required\n‚úÖ Firebase offers generous free tier perfect for learning\n‚úÖ FlutterFire CLI automates Firebase setup for Flutter apps\n‚úÖ `Firebase.initializeApp()` must be called before using any Firebase service\n‚úÖ firebase_core is required for all Firebase services\n‚úÖ Firebase supports all platforms: iOS, Android, Web, macOS, Windows, Linux\n‚úÖ Complete Lesson 1.5 (Supabase) to learn open-source alternatives and avoid vendor lock-in\n\n**You're now ready to build cloud-connected apps!** üöÄ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "8.1.5",
          "title": "Module 8, Lesson 1.5: Supabase - The Open Source Alternative",
          "moduleId": "module-08",
          "order": 2,
          "estimatedMinutes": 75,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Consider Supabase?",
              "content": "\n### Avoiding Vendor Lock-In\n\nIn Module 8 Lesson 1, we introduced Firebase as our primary backend. It's excellent for rapid development. However, **senior developers should understand alternatives** for these reasons:\n\n1. **Cost at Scale**: Firebase pricing can surprise you as you grow\n2. **Data Ownership**: Your data lives on Google's servers\n3. **Flexibility**: Sometimes you need raw SQL power\n4. **Self-Hosting**: Some projects require on-premise deployment\n5. **Open Source**: Community-driven development and transparency\n\n### What is Supabase?\n\n**Supabase = Open Source Firebase Alternative**\n\n| Feature | Firebase | Supabase |\n|---------|----------|----------|\n| Database | Firestore (NoSQL) | PostgreSQL (SQL) |\n| Auth | Firebase Auth | GoTrue (compatible) |\n| Storage | Cloud Storage | S3-compatible |\n| Real-time | Firestore listeners | Postgres Changes |\n| Self-host | No | Yes |\n| Open Source | No | Yes |\n| Pricing | Pay per operation | Pay per resource |\n\n**When to choose Supabase:**\n- You need complex SQL queries (joins, aggregations)\n- You want to self-host or own your infrastructure\n- You prefer open source solutions\n- You're coming from a SQL background\n\n**When to stick with Firebase:**\n- Rapid prototyping (slightly faster setup)\n- Deep Google ecosystem integration\n- Offline-first with automatic sync\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Supabase",
              "content": "\n### Step 1: Create a Supabase Project\n\n1. Go to https://supabase.com\n2. Sign up (free tier is generous)\n3. Click \"New Project\"\n4. Choose organization, name, password, region\n5. Wait 2 minutes for database provisioning\n\n### Step 2: Get Your Credentials\n\nIn your Supabase dashboard:\n1. Go to **Settings** > **API**\n2. Copy:\n   - **Project URL**: `https://xxxxx.supabase.co`\n   - **anon/public key**: `eyJhbGciOi...`\n\n### Step 3: Add to Flutter Project\n\n```yaml\n# pubspec.yaml\ndependencies:\n  supabase_flutter: ^2.3.0\n```\n\nRun: `flutter pub get`\n\n### Step 4: Initialize Supabase\n\n```dart\n// lib/main.dart\nimport 'package:flutter/material.dart';\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nFuture<void> main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  await Supabase.initialize(\n    url: 'https://YOUR_PROJECT.supabase.co',\n    anonKey: 'YOUR_ANON_KEY',\n  );\n  \n  runApp(const MyApp());\n}\n\n// Access client anywhere\nfinal supabase = Supabase.instance.client;\n```\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Authentication with Supabase",
              "content": "\n### Sign Up\n\n```dart\nFuture<void> signUp(String email, String password) async {\n  final response = await supabase.auth.signUp(\n    email: email,\n    password: password,\n  );\n  \n  if (response.user != null) {\n    print('User created: ${response.user!.email}');\n  }\n}\n```\n\n### Sign In\n\n```dart\nFuture<void> signIn(String email, String password) async {\n  final response = await supabase.auth.signInWithPassword(\n    email: email,\n    password: password,\n  );\n  \n  if (response.session != null) {\n    print('Logged in: ${response.user!.email}');\n  }\n}\n```\n\n### Sign Out\n\n```dart\nFuture<void> signOut() async {\n  await supabase.auth.signOut();\n}\n```\n\n### Listen to Auth Changes\n\n```dart\nsupabase.auth.onAuthStateChange.listen((data) {\n  final session = data.session;\n  if (session != null) {\n    // User logged in\n    navigateToHome();\n  } else {\n    // User logged out\n    navigateToLogin();\n  }\n});\n```\n\n",
              "code": "// Complete auth service\nclass SupabaseAuthService {\n  final _supabase = Supabase.instance.client;\n  \n  User? get currentUser => _supabase.auth.currentUser;\n  \n  Stream<AuthState> get authStateChanges => \n      _supabase.auth.onAuthStateChange;\n  \n  Future<AuthResponse> signUp(String email, String password) =>\n      _supabase.auth.signUp(email: email, password: password);\n  \n  Future<AuthResponse> signIn(String email, String password) =>\n      _supabase.auth.signInWithPassword(email: email, password: password);\n  \n  Future<void> signOut() => _supabase.auth.signOut();\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Database Operations (CRUD)",
              "content": "\n### Create a Table (in Supabase Dashboard)\n\n1. Go to **Table Editor** > **New Table**\n2. Name: `todos`\n3. Columns:\n   - `id` (int8, primary key, auto-increment)\n   - `user_id` (uuid, foreign key to auth.users)\n   - `title` (text)\n   - `completed` (bool, default: false)\n   - `created_at` (timestamptz, default: now())\n\n### Insert (Create)\n\n```dart\nFuture<void> createTodo(String title) async {\n  await supabase.from('todos').insert({\n    'title': title,\n    'user_id': supabase.auth.currentUser!.id,\n  });\n}\n```\n\n### Select (Read)\n\n```dart\nFuture<List<Map<String, dynamic>>> getTodos() async {\n  final response = await supabase\n      .from('todos')\n      .select()\n      .eq('user_id', supabase.auth.currentUser!.id)\n      .order('created_at', ascending: false);\n  \n  return response;\n}\n```\n\n### Update\n\n```dart\nFuture<void> toggleTodo(int id, bool completed) async {\n  await supabase\n      .from('todos')\n      .update({'completed': completed})\n      .eq('id', id);\n}\n```\n\n### Delete\n\n```dart\nFuture<void> deleteTodo(int id) async {\n  await supabase.from('todos').delete().eq('id', id);\n}\n```\n\n",
              "code": "// Compare to Firestore:\n// Firebase:  FirebaseFirestore.instance.collection('todos').add(data)\n// Supabase:  supabase.from('todos').insert(data)\n\n// Firebase:  .where('userId', isEqualTo: uid).get()\n// Supabase:  .select().eq('user_id', uid)",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Real-Time Subscriptions",
              "content": "\n### Listen to Changes\n\n```dart\nclass TodosProvider extends ChangeNotifier {\n  List<Map<String, dynamic>> _todos = [];\n  RealtimeChannel? _subscription;\n  \n  List<Map<String, dynamic>> get todos => _todos;\n  \n  void subscribeTodos() {\n    // Initial fetch\n    _fetchTodos();\n    \n    // Real-time subscription\n    _subscription = supabase\n        .channel('todos_changes')\n        .onPostgresChanges(\n          event: PostgresChangeEvent.all,\n          schema: 'public',\n          table: 'todos',\n          callback: (payload) {\n            _fetchTodos(); // Refresh on any change\n          },\n        )\n        .subscribe();\n  }\n  \n  Future<void> _fetchTodos() async {\n    final response = await supabase\n        .from('todos')\n        .select()\n        .order('created_at');\n    \n    _todos = List<Map<String, dynamic>>.from(response);\n    notifyListeners();\n  }\n  \n  @override\n  void dispose() {\n    _subscription?.unsubscribe();\n    super.dispose();\n  }\n}\n```\n\n",
              "code": "// Real-time is automatic when you subscribe!\n// Any INSERT, UPDATE, or DELETE triggers the callback",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "File Storage",
              "content": "\n### Upload a File\n\n```dart\nimport 'dart:io';\n\nFuture<String> uploadImage(File file, String fileName) async {\n  final bytes = await file.readAsBytes();\n  \n  await supabase.storage\n      .from('avatars') // bucket name\n      .uploadBinary(\n        fileName,\n        bytes,\n        fileOptions: const FileOptions(\n          contentType: 'image/png',\n          upsert: true,\n        ),\n      );\n  \n  // Get public URL\n  final url = supabase.storage\n      .from('avatars')\n      .getPublicUrl(fileName);\n  \n  return url;\n}\n```\n\n### Download/Display\n\n```dart\n// Just use the public URL in Image.network\nImage.network(\n  supabase.storage.from('avatars').getPublicUrl('user-123.png'),\n  fit: BoxFit.cover,\n)\n```\n\n",
              "code": "// Storage comparison:\n// Firebase:  FirebaseStorage.instance.ref(path).putFile(file)\n// Supabase:  supabase.storage.from(bucket).uploadBinary(path, bytes)",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Row Level Security (RLS)",
              "content": "\n### Supabase's Killer Feature\n\nRow Level Security lets you define access rules **at the database level**:\n\n```sql\n-- Enable RLS\nALTER TABLE todos ENABLE ROW LEVEL SECURITY;\n\n-- Users can only see their own todos\nCREATE POLICY \"Users can view own todos\" ON todos\n  FOR SELECT USING (auth.uid() = user_id);\n\n-- Users can only insert their own todos\nCREATE POLICY \"Users can insert own todos\" ON todos\n  FOR INSERT WITH CHECK (auth.uid() = user_id);\n\n-- Users can only update their own todos\nCREATE POLICY \"Users can update own todos\" ON todos\n  FOR UPDATE USING (auth.uid() = user_id);\n\n-- Users can only delete their own todos\nCREATE POLICY \"Users can delete own todos\" ON todos\n  FOR DELETE USING (auth.uid() = user_id);\n```\n\n**This is more secure than client-side checks** - even if someone bypasses your app, the database enforces the rules!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Firebase vs Supabase: Quick Reference",
              "content": "\n| Operation | Firebase | Supabase |\n|-----------|----------|----------|\n| **Init** | `Firebase.initializeApp()` | `Supabase.initialize(url, key)` |\n| **Auth Sign Up** | `createUserWithEmailAndPassword()` | `auth.signUp(email, password)` |\n| **Auth Sign In** | `signInWithEmailAndPassword()` | `auth.signInWithPassword()` |\n| **Insert** | `collection('x').add(data)` | `from('x').insert(data)` |\n| **Query** | `where('field', '==', val)` | `.eq('field', val)` |\n| **Real-time** | `snapshots()` | `channel().onPostgresChanges()` |\n| **Storage Upload** | `ref(path).putFile(file)` | `storage.from(bucket).upload()` |\n\n### Migration Path\n\nIf you need to migrate from Firebase to Supabase:\n1. Export Firestore data as JSON\n2. Transform to relational format\n3. Import to Supabase using `psql` or Dashboard\n4. Update Flutter code (similar APIs make this straightforward)\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- Why backend alternatives matter (vendor lock-in)\n- Supabase as open-source Firebase alternative\n- Setting up Supabase in Flutter\n- Authentication with Supabase\n- CRUD operations with PostgreSQL\n- Real-time subscriptions\n- File storage\n- Row Level Security for database-level protection\n- Firebase vs Supabase comparison\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "8.1.5-challenge-0",
              "title": "Supabase Todo App",
              "description": "Build a complete todo app with Supabase backend:\n\n1. Set up Supabase project and Flutter integration\n2. Create 'todos' table with RLS policies\n3. Implement authentication (sign up, sign in, sign out)\n4. Implement CRUD operations for todos\n5. Add real-time sync so changes appear instantly",
              "instructions": "Build a complete todo app with Supabase:\n\n1. Create Supabase project at supabase.com\n2. Add supabase_flutter package\n3. Initialize in main.dart\n4. Create auth service with sign up/in/out\n5. Create todos table with user_id foreign key\n6. Enable RLS with user-specific policies\n7. Implement TodoService with CRUD\n8. Subscribe to real-time changes",
              "starterCode": "import 'package:supabase_flutter/supabase_flutter.dart';\n\n// TODO: Initialize Supabase\n// TODO: Create AuthService\n// TODO: Create TodoService with CRUD\n// TODO: Add real-time subscription",
              "solution": "import 'package:flutter/material.dart';\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nfinal supabase = Supabase.instance.client;\n\nclass TodoService {\n  Future<List<Map<String, dynamic>>> getTodos() async {\n    return await supabase\n        .from('todos')\n        .select()\n        .eq('user_id', supabase.auth.currentUser!.id)\n        .order('created_at');\n  }\n  \n  Future<void> addTodo(String title) async {\n    await supabase.from('todos').insert({\n      'title': title,\n      'user_id': supabase.auth.currentUser!.id,\n    });\n  }\n  \n  Future<void> toggleTodo(int id, bool completed) async {\n    await supabase\n        .from('todos')\n        .update({'completed': completed})\n        .eq('id', id);\n  }\n  \n  Future<void> deleteTodo(int id) async {\n    await supabase.from('todos').delete().eq('id', id);\n  }\n  \n  RealtimeChannel subscribeToChanges(VoidCallback onUpdate) {\n    return supabase\n        .channel('todos')\n        .onPostgresChanges(\n          event: PostgresChangeEvent.all,\n          schema: 'public',\n          table: 'todos',\n          callback: (_) => onUpdate(),\n        )\n        .subscribe();\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Supabase initialized correctly",
                  "expectedOutput": "Supabase client available",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "CRUD operations work",
                  "expectedOutput": "Create, read, update, delete todos",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Real-time subscription active",
                  "expectedOutput": "Changes sync automatically",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Remember to enable RLS on your todos table in Supabase dashboard"
                },
                {
                  "level": 2,
                  "text": "Use .eq() for WHERE clauses, .order() for sorting"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to enable RLS",
                  "consequence": "Data exposed to all users",
                  "correction": "Enable RLS and add policies in Supabase dashboard"
                },
                {
                  "mistake": "Not unsubscribing from channels",
                  "consequence": "Memory leaks",
                  "correction": "Call channel.unsubscribe() in dispose()"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "8.2",
          "title": "Module 8, Lesson 2: Firebase Authentication",
          "moduleId": "module-08",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll know how to implement user registration and login using Firebase Authentication with both email/password and Google Sign-In.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**User authentication is the foundation of most apps.**\n\n- **93% of apps** require users to create accounts\n- **Secure authentication** protects user data and prevents unauthorized access\n- **Firebase Auth** handles the complex security for you\n- **Social login** (Google, Apple) increases signup rates by 50%\n\nIn this lesson, you'll learn to build a complete authentication system that's both secure and user-friendly.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Hotel Check-In",
              "content": "\n### Without Authentication\nImagine a hotel where anyone can:\n- üö™ Enter any room\n- üìù Access anyone's information\n- üí≥ See anyone's billing\n- üîë No keys needed\n\n**This would be chaos!**\n\n### With Authentication\nProper hotel check-in:\n1. **Register** (first visit): Show ID, get a room key\n2. **Login** (returning guest): Show ID, get your key\n3. **Your Room Only**: Your key only opens YOUR room\n4. **Session**: Key works for duration of your stay\n5. **Logout** (checkout): Return key, can't access room anymore\n\n**Firebase Authentication is your app's hotel check-in system.**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Firebase Authentication Overview",
              "content": "\nFirebase Authentication provides:\n\n### Built-In Methods\n- üìß Email & Password\n- üì± Phone Number (SMS)\n- üîó Anonymous (guest access)\n- üîÑ Custom Authentication\n\n### Social Login Providers\n- üîµ Google\n- üçé Apple\n- üìò Facebook\n- üê¶ Twitter/X\n- üîó Microsoft\n- üì∑ GitHub\n\n### Security Features\n- ‚úÖ Secure password hashing\n- ‚úÖ Email verification\n- ‚úÖ Password reset\n- ‚úÖ Account linking\n- ‚úÖ Multi-factor authentication (MFA)\n- ‚úÖ Session management\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Firebase Authentication",
              "content": "\n### Step 1: Enable Authentication in Firebase Console\n\n1. Go to https://console.firebase.google.com\n2. Select your project\n3. Click **\"Authentication\"** in left sidebar\n4. Click **\"Get started\"**\n5. Click **\"Sign-in method\"** tab\n6. Enable **\"Email/Password\"**\n7. Enable **\"Google\"** (we'll use this later)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Email & Password Authentication",
              "content": "\n### Add Firebase Auth Package\n\nAlready added in previous lesson, but verify in `pubspec.yaml`:\n\n\n",
              "code": "dependencies:\n  flutter:\n    sdk: flutter\n  firebase_core: ^4.2.0\n  firebase_auth: ^6.1.1",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Create Auth Service\n\n\n",
              "code": "// lib/services/auth_service.dart\nimport 'package:firebase_auth/firebase_auth.dart';\n\nclass AuthService {\n  final FirebaseAuth _auth = FirebaseAuth.instance;\n\n  // Get current user\n  User? get currentUser => _auth.currentUser;\n\n  // Auth state changes (stream of user)\n  Stream<User?> get authStateChanges => _auth.authStateChanges();\n\n  // Register with email and password\n  Future<User?> registerWithEmail({\n    required String email,\n    required String password,\n  }) async {\n    try {\n      final UserCredential result = await _auth.createUserWithEmailAndPassword(\n        email: email,\n        password: password,\n      );\n      return result.user;\n    } on FirebaseAuthException catch (e) {\n      throw _handleAuthException(e);\n    }\n  }\n\n  // Login with email and password\n  Future<User?> loginWithEmail({\n    required String email,\n    required String password,\n  }) async {\n    try {\n      final UserCredential result = await _auth.signInWithEmailAndPassword(\n        email: email,\n        password: password,\n      );\n      return result.user;\n    } on FirebaseAuthException catch (e) {\n      throw _handleAuthException(e);\n    }\n  }\n\n  // Logout\n  Future<void> logout() async {\n    await _auth.signOut();\n  }\n\n  // Send email verification\n  Future<void> sendEmailVerification() async {\n    final user = _auth.currentUser;\n    if (user != null && !user.emailVerified) {\n      await user.sendEmailVerification();\n    }\n  }\n\n  // Send password reset email\n  Future<void> sendPasswordResetEmail(String email) async {\n    try {\n      await _auth.sendPasswordResetEmail(email);\n    } on FirebaseAuthException catch (e) {\n      throw _handleAuthException(e);\n    }\n  }\n\n  // Delete account\n  Future<void> deleteAccount() async {\n    final user = _auth.currentUser;\n    if (user != null) {\n      await user.delete();\n    }\n  }\n\n  // Handle Firebase Auth exceptions\n  String _handleAuthException(FirebaseAuthException e) {\n    switch (e.code) {\n      case 'weak-password':\n        return 'Password is too weak. Use at least 6 characters.';\n      case 'email-already-in-use':\n        return 'An account with this email already exists.';\n      case 'invalid-email':\n        return 'Invalid email address.';\n      case 'user-not-found':\n        return 'No account found with this email.';\n      case 'wrong-password':\n        return 'Incorrect password.';\n      case 'user-disabled':\n        return 'This account has been disabled.';\n      case 'too-many-requests':\n        return 'Too many attempts. Try again later.';\n      case 'operation-not-allowed':\n        return 'This sign-in method is not enabled.';\n      default:\n        return 'Authentication error: ${e.message}';\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Create Register Screen\n\n\n",
              "code": "// lib/screens/auth/register_screen.dart\nimport 'package:flutter/material.dart';\nimport '../../services/auth_service.dart';\nimport 'login_screen.dart';\n\nclass RegisterScreen extends StatefulWidget {\n  const RegisterScreen({super.key});\n\n  @override\n  State<RegisterScreen> createState() => _RegisterScreenState();\n}\n\nclass _RegisterScreenState extends State<RegisterScreen> {\n  final _authService = AuthService();\n  final _formKey = GlobalKey<FormState>();\n  final _emailController = TextEditingController();\n  final _passwordController = TextEditingController();\n  final _confirmPasswordController = TextEditingController();\n\n  bool _isLoading = false;\n  bool _obscurePassword = true;\n  bool _obscureConfirmPassword = true;\n\n  @override\n  void dispose() {\n    _emailController.dispose();\n    _passwordController.dispose();\n    _confirmPasswordController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _handleRegister() async {\n    if (!_formKey.currentState!.validate()) return;\n\n    setState(() => _isLoading = true);\n\n    try {\n      await _authService.registerWithEmail(\n        email: _emailController.text.trim(),\n        password: _passwordController.text,\n      );\n\n      // Send verification email\n      await _authService.sendEmailVerification();\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(\n            content: Text('Registration successful! Please verify your email.'),\n          ),\n        );\n\n        // Navigate to login\n        Navigator.of(context).pushReplacement(\n          MaterialPageRoute(builder: (_) => const LoginScreen()),\n        );\n      }\n    } catch (e) {\n      setState(() => _isLoading = false);\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text(e.toString())),\n        );\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SafeArea(\n        child: SingleChildScrollView(\n          padding: const EdgeInsets.all(24.0),\n          child: Form(\n            key: _formKey,\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.stretch,\n              children: [\n                const SizedBox(height: 48),\n\n                // Title\n                Text(\n                  'Create Account',\n                  style: Theme.of(context).textTheme.headlineLarge,\n                  textAlign: TextAlign.center,\n                ),\n                const SizedBox(height: 8),\n                Text(\n                  'Sign up to get started',\n                  style: TextStyle(color: Colors.grey.shade600),\n                  textAlign: TextAlign.center,\n                ),\n                const SizedBox(height: 48),\n\n                // Email field\n                TextFormField(\n                  controller: _emailController,\n                  decoration: const InputDecoration(\n                    labelText: 'Email',\n                    prefixIcon: Icon(Icons.email),\n                    border: OutlineInputBorder(),\n                  ),\n                  keyboardType: TextInputType.emailAddress,\n                  enabled: !_isLoading,\n                  validator: (value) {\n                    if (value == null || value.isEmpty) {\n                      return 'Please enter your email';\n                    }\n                    if (!value.contains('@')) {\n                      return 'Please enter a valid email';\n                    }\n                    return null;\n                  },\n                ),\n                const SizedBox(height: 16),\n\n                // Password field\n                TextFormField(\n                  controller: _passwordController,\n                  obscureText: _obscurePassword,\n                  decoration: InputDecoration(\n                    labelText: 'Password',\n                    prefixIcon: const Icon(Icons.lock),\n                    border: const OutlineInputBorder(),\n                    suffixIcon: IconButton(\n                      icon: Icon(\n                        _obscurePassword ? Icons.visibility : Icons.visibility_off,\n                      ),\n                      onPressed: () {\n                        setState(() => _obscurePassword = !_obscurePassword);\n                      },\n                    ),\n                  ),\n                  enabled: !_isLoading,\n                  validator: (value) {\n                    if (value == null || value.isEmpty) {\n                      return 'Please enter a password';\n                    }\n                    if (value.length < 6) {\n                      return 'Password must be at least 6 characters';\n                    }\n                    return null;\n                  },\n                ),\n                const SizedBox(height: 16),\n\n                // Confirm password field\n                TextFormField(\n                  controller: _confirmPasswordController,\n                  obscureText: _obscureConfirmPassword,\n                  decoration: InputDecoration(\n                    labelText: 'Confirm Password',\n                    prefixIcon: const Icon(Icons.lock_outline),\n                    border: const OutlineInputBorder(),\n                    suffixIcon: IconButton(\n                      icon: Icon(\n                        _obscureConfirmPassword ? Icons.visibility : Icons.visibility_off,\n                      ),\n                      onPressed: () {\n                        setState(() => _obscureConfirmPassword = !_obscureConfirmPassword);\n                      },\n                    ),\n                  ),\n                  enabled: !_isLoading,\n                  validator: (value) {\n                    if (value == null || value.isEmpty) {\n                      return 'Please confirm your password';\n                    }\n                    if (value != _passwordController.text) {\n                      return 'Passwords do not match';\n                    }\n                    return null;\n                  },\n                ),\n                const SizedBox(height: 24),\n\n                // Register button\n                FilledButton(\n                  onPressed: _isLoading ? null : _handleRegister,\n                  style: FilledButton.styleFrom(\n                    padding: const EdgeInsets.symmetric(vertical: 16),\n                  ),\n                  child: _isLoading\n                      ? const SizedBox(\n                          height: 20,\n                          width: 20,\n                          child: CircularProgressIndicator(strokeWidth: 2),\n                        )\n                      : const Text('Register'),\n                ),\n\n                const SizedBox(height: 16),\n\n                // Login link\n                TextButton(\n                  onPressed: _isLoading\n                      ? null\n                      : () {\n                          Navigator.of(context).pushReplacement(\n                            MaterialPageRoute(builder: (_) => const LoginScreen()),\n                          );\n                        },\n                  child: const Text('Already have an account? Login'),\n                ),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Create Login Screen\n\n\n",
              "code": "// lib/screens/auth/login_screen.dart\nimport 'package:flutter/material.dart';\nimport '../../services/auth_service.dart';\nimport '../home/home_screen.dart';\nimport 'register_screen.dart';\nimport 'forgot_password_screen.dart';\n\nclass LoginScreen extends StatefulWidget {\n  const LoginScreen({super.key});\n\n  @override\n  State<LoginScreen> createState() => _LoginScreenState();\n}\n\nclass _LoginScreenState extends State<LoginScreen> {\n  final _authService = AuthService();\n  final _formKey = GlobalKey<FormState>();\n  final _emailController = TextEditingController();\n  final _passwordController = TextEditingController();\n\n  bool _isLoading = false;\n  bool _obscurePassword = true;\n\n  @override\n  void dispose() {\n    _emailController.dispose();\n    _passwordController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _handleLogin() async {\n    if (!_formKey.currentState!.validate()) return;\n\n    setState(() => _isLoading = true);\n\n    try {\n      await _authService.loginWithEmail(\n        email: _emailController.text.trim(),\n        password: _passwordController.text,\n      );\n\n      if (mounted) {\n        Navigator.of(context).pushReplacement(\n          MaterialPageRoute(builder: (_) => const HomeScreen()),\n        );\n      }\n    } catch (e) {\n      setState(() => _isLoading = false);\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text(e.toString())),\n        );\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SafeArea(\n        child: SingleChildScrollView(\n          padding: const EdgeInsets.all(24.0),\n          child: Form(\n            key: _formKey,\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.stretch,\n              children: [\n                const SizedBox(height: 48),\n\n                // Title\n                Text(\n                  'Welcome Back',\n                  style: Theme.of(context).textTheme.headlineLarge,\n                  textAlign: TextAlign.center,\n                ),\n                const SizedBox(height: 8),\n                Text(\n                  'Login to your account',\n                  style: TextStyle(color: Colors.grey.shade600),\n                  textAlign: TextAlign.center,\n                ),\n                const SizedBox(height: 48),\n\n                // Email field\n                TextFormField(\n                  controller: _emailController,\n                  decoration: const InputDecoration(\n                    labelText: 'Email',\n                    prefixIcon: Icon(Icons.email),\n                    border: OutlineInputBorder(),\n                  ),\n                  keyboardType: TextInputType.emailAddress,\n                  enabled: !_isLoading,\n                  validator: (value) {\n                    if (value == null || value.isEmpty) {\n                      return 'Please enter your email';\n                    }\n                    return null;\n                  },\n                ),\n                const SizedBox(height: 16),\n\n                // Password field\n                TextFormField(\n                  controller: _passwordController,\n                  obscureText: _obscurePassword,\n                  decoration: InputDecoration(\n                    labelText: 'Password',\n                    prefixIcon: const Icon(Icons.lock),\n                    border: const OutlineInputBorder(),\n                    suffixIcon: IconButton(\n                      icon: Icon(\n                        _obscurePassword ? Icons.visibility : Icons.visibility_off,\n                      ),\n                      onPressed: () {\n                        setState(() => _obscurePassword = !_obscurePassword);\n                      },\n                    ),\n                  ),\n                  enabled: !_isLoading,\n                  validator: (value) {\n                    if (value == null || value.isEmpty) {\n                      return 'Please enter your password';\n                    }\n                    return null;\n                  },\n                  onFieldSubmitted: (_) => _handleLogin(),\n                ),\n\n                // Forgot password link\n                Align(\n                  alignment: Alignment.centerRight,\n                  child: TextButton(\n                    onPressed: _isLoading\n                        ? null\n                        : () {\n                            Navigator.of(context).push(\n                              MaterialPageRoute(\n                                builder: (_) => const ForgotPasswordScreen(),\n                              ),\n                            );\n                          },\n                    child: const Text('Forgot Password?'),\n                  ),\n                ),\n\n                const SizedBox(height: 8),\n\n                // Login button\n                FilledButton(\n                  onPressed: _isLoading ? null : _handleLogin,\n                  style: FilledButton.styleFrom(\n                    padding: const EdgeInsets.symmetric(vertical: 16),\n                  ),\n                  child: _isLoading\n                      ? const SizedBox(\n                          height: 20,\n                          width: 20,\n                          child: CircularProgressIndicator(strokeWidth: 2),\n                        )\n                      : const Text('Login'),\n                ),\n\n                const SizedBox(height: 16),\n\n                // Register link\n                TextButton(\n                  onPressed: _isLoading\n                      ? null\n                      : () {\n                          Navigator.of(context).pushReplacement(\n                            MaterialPageRoute(\n                              builder: (_) => const RegisterScreen(),\n                            ),\n                          );\n                        },\n                  child: const Text('Don\\'t have an account? Register'),\n                ),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Create Forgot Password Screen\n\n\n",
              "code": "// lib/screens/auth/forgot_password_screen.dart\nimport 'package:flutter/material.dart';\nimport '../../services/auth_service.dart';\n\nclass ForgotPasswordScreen extends StatefulWidget {\n  const ForgotPasswordScreen({super.key});\n\n  @override\n  State<ForgotPasswordScreen> createState() => _ForgotPasswordScreenState();\n}\n\nclass _ForgotPasswordScreenState extends State<ForgotPasswordScreen> {\n  final _authService = AuthService();\n  final _emailController = TextEditingController();\n  bool _isLoading = false;\n  bool _emailSent = false;\n\n  @override\n  void dispose() {\n    _emailController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _handleResetPassword() async {\n    if (_emailController.text.trim().isEmpty) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text('Please enter your email')),\n      );\n      return;\n    }\n\n    setState(() => _isLoading = true);\n\n    try {\n      await _authService.sendPasswordResetEmail(_emailController.text.trim());\n\n      setState(() {\n        _isLoading = false;\n        _emailSent = true;\n      });\n    } catch (e) {\n      setState(() => _isLoading = false);\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text(e.toString())),\n        );\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Reset Password'),\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(24.0),\n        child: _emailSent\n            ? _buildSuccessView()\n            : _buildFormView(),\n      ),\n    );\n  }\n\n  Widget _buildFormView() {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.stretch,\n      children: [\n        const SizedBox(height: 24),\n        Text(\n          'Enter your email address and we\\'ll send you instructions to reset your password.',\n          style: TextStyle(color: Colors.grey.shade700),\n        ),\n        const SizedBox(height: 32),\n\n        TextFormField(\n          controller: _emailController,\n          decoration: const InputDecoration(\n            labelText: 'Email',\n            prefixIcon: Icon(Icons.email),\n            border: OutlineInputBorder(),\n          ),\n          keyboardType: TextInputType.emailAddress,\n          enabled: !_isLoading,\n        ),\n        const SizedBox(height: 24),\n\n        FilledButton(\n          onPressed: _isLoading ? null : _handleResetPassword,\n          style: FilledButton.styleFrom(\n            padding: const EdgeInsets.symmetric(vertical: 16),\n          ),\n          child: _isLoading\n              ? const SizedBox(\n                  height: 20,\n                  width: 20,\n                  child: CircularProgressIndicator(strokeWidth: 2),\n                )\n              : const Text('Send Reset Link'),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildSuccessView() {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      crossAxisAlignment: CrossAxisAlignment.stretch,\n      children: [\n        Icon(\n          Icons.mark_email_read,\n          size: 100,\n          color: Colors.green.shade600,\n        ),\n        const SizedBox(height: 24),\n        const Text(\n          'Email Sent!',\n          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n          textAlign: TextAlign.center,\n        ),\n        const SizedBox(height: 16),\n        Text(\n          'Check your inbox for password reset instructions.',\n          style: TextStyle(color: Colors.grey.shade700),\n          textAlign: TextAlign.center,\n        ),\n        const SizedBox(height: 32),\n        FilledButton(\n          onPressed: () => Navigator.of(context).pop(),\n          child: const Text('Back to Login'),\n        ),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Create Home Screen with Logout\n\n\n",
              "code": "// lib/screens/home/home_screen.dart\nimport 'package:flutter/material.dart';\nimport '../../services/auth_service.dart';\nimport '../auth/login_screen.dart';\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final authService = AuthService();\n    final user = authService.currentUser;\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Home'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.logout),\n            tooltip: 'Logout',\n            onPressed: () async {\n              await authService.logout();\n              if (context.mounted) {\n                Navigator.of(context).pushReplacement(\n                  MaterialPageRoute(builder: (_) => const LoginScreen()),\n                );\n              }\n            },\n          ),\n        ],\n      ),\n      body: Center(\n        child: Padding(\n          padding: const EdgeInsets.all(24.0),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              CircleAvatar(\n                radius: 50,\n                backgroundColor: Colors.blue.shade100,\n                child: Icon(\n                  Icons.person,\n                  size: 60,\n                  color: Colors.blue.shade700,\n                ),\n              ),\n              const SizedBox(height: 24),\n              Text(\n                'Welcome!',\n                style: Theme.of(context).textTheme.headlineMedium,\n              ),\n              const SizedBox(height: 16),\n              Container(\n                padding: const EdgeInsets.all(16),\n                decoration: BoxDecoration(\n                  color: Colors.grey.shade100,\n                  borderRadius: BorderRadius.circular(12),\n                ),\n                child: Column(\n                  children: [\n                    _buildInfoRow('Email', user?.email ?? 'Unknown'),\n                    const Divider(height: 24),\n                    _buildInfoRow('User ID', user?.uid ?? 'Unknown'),\n                    const Divider(height: 24),\n                    _buildInfoRow(\n                      'Email Verified',\n                      user?.emailVerified == true ? 'Yes ‚úì' : 'No ‚úó',\n                    ),\n                  ],\n                ),\n              ),\n              if (user?.emailVerified == false) ...[\n                const SizedBox(height: 24),\n                OutlinedButton.icon(\n                  onPressed: () async {\n                    await authService.sendEmailVerification();\n                    if (context.mounted) {\n                      ScaffoldMessenger.of(context).showSnackBar(\n                        const SnackBar(\n                          content: Text('Verification email sent! Check your inbox.'),\n                        ),\n                      );\n                    }\n                  },\n                  icon: const Icon(Icons.email),\n                  label: const Text('Verify Email'),\n                ),\n              ],\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _buildInfoRow(String label, String value) {\n    return Row(\n      mainAxisAlignment: MainAxisAlignment.spaceBetween,\n      children: [\n        Text(\n          label,\n          style: const TextStyle(fontWeight: FontWeight.w600),\n        ),\n        Flexible(\n          child: Text(\n            value,\n            textAlign: TextAlign.end,\n            overflow: TextOverflow.ellipsis,\n          ),\n        ),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Update main.dart with Auth State\n\n\n",
              "code": "// lib/main.dart\nimport 'package:flutter/material.dart';\nimport 'package:firebase_core/firebase_core.dart';\nimport 'firebase_options.dart';\nimport 'services/auth_service.dart';\nimport 'screens/auth/login_screen.dart';\nimport 'screens/home/home_screen.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await Firebase.initializeApp(\n    options: DefaultFirebaseOptions.currentPlatform,\n  );\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Firebase Auth Demo',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),\n        useMaterial3: true,\n      ),\n      home: const AuthWrapper(),\n    );\n  }\n}\n\n// Listen to auth state changes\nclass AuthWrapper extends StatelessWidget {\n  const AuthWrapper({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final authService = AuthService();\n\n    return StreamBuilder(\n      stream: authService.authStateChanges,\n      builder: (context, snapshot) {\n        // Loading state\n        if (snapshot.connectionState == ConnectionState.waiting) {\n          return const Scaffold(\n            body: Center(child: CircularProgressIndicator()),\n          );\n        }\n\n        // User is logged in\n        if (snapshot.hasData && snapshot.data != null) {\n          return const HomeScreen();\n        }\n\n        // User is not logged in\n        return const LoginScreen();\n      },\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Testing Email/Password Auth",
              "content": "\n1. **Run the app**: `flutter run`\n2. **Register**: Create an account with email and password\n3. **Check Firebase Console**: Go to Authentication ‚Üí Users, you should see your new user\n4. **Verify email**: Check your email inbox for verification link\n5. **Login**: Try logging in with your credentials\n6. **Logout**: Click logout button\n7. **Forgot password**: Test password reset flow\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Google Sign-In",
              "content": "\n### Setup Google Sign-In\n\n#### 1. Add Package\n\n\nRun:\n\n#### 2. Android Configuration\n\nEdit `android/app/build.gradle`:\n\n\n**Get SHA-1 fingerprint:**\n\n**Add to Firebase Console**:\n1. Go to Project Settings ‚Üí Your apps ‚Üí Android app\n2. Click \"Add fingerprint\"\n3. Paste SHA-1 fingerprint\n\n#### 3. iOS Configuration\n\nEdit `ios/Runner/Info.plist`:\n\n\nReplace `YOUR-CLIENT-ID` with your client ID from `GoogleService-Info.plist`.\n\n#### 4. Get OAuth Client ID\n\nDownload `google-services.json` (Android) and `GoogleService-Info.plist` (iOS) from Firebase Console ‚Üí Project Settings ‚Üí Your apps.\n\n",
              "code": "<key>CFBundleURLTypes</key>\n<array>\n  <dict>\n    <key>CFBundleTypeRole</key>\n    <string>Editor</string>\n    <key>CFBundleURLSchemes</key>\n    <array>\n      <string>com.googleusercontent.apps.YOUR-CLIENT-ID</string>\n    </array>\n  </dict>\n</array>",
              "language": "xml"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Update Auth Service for Google Sign-In\n\n\n",
              "code": "// lib/services/auth_service.dart (add these methods)\nimport 'package:google_sign_in/google_sign_in.dart';\n\nclass AuthService {\n  final FirebaseAuth _auth = FirebaseAuth.instance;\n  final GoogleSignIn _googleSignIn = GoogleSignIn();\n\n  // ... previous methods ...\n\n  // Sign in with Google\n  Future<User?> signInWithGoogle() async {\n    try {\n      // Trigger the authentication flow\n      final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();\n\n      if (googleUser == null) {\n        // User canceled the sign-in\n        return null;\n      }\n\n      // Obtain the auth details from the request\n      final GoogleSignInAuthentication googleAuth = await googleUser.authentication;\n\n      // Create a new credential\n      final credential = GoogleAuthProvider.credential(\n        accessToken: googleAuth.accessToken,\n        idToken: googleAuth.idToken,\n      );\n\n      // Sign in to Firebase with the Google credential\n      final UserCredential result = await _auth.signInWithCredential(credential);\n      return result.user;\n    } catch (e) {\n      throw 'Google Sign-In failed: $e';\n    }\n  }\n\n  // Sign out from both Firebase and Google\n  @override\n  Future<void> logout() async {\n    await Future.wait([\n      _auth.signOut(),\n      _googleSignIn.signOut(),\n    ]);\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Add Google Sign-In Button to Login Screen\n\n\nAdd the method:\n\n\n",
              "code": "Future<void> _handleGoogleSignIn() async {\n  setState(() => _isLoading = true);\n\n  try {\n    final user = await _authService.signInWithGoogle();\n\n    if (user != null && mounted) {\n      Navigator.of(context).pushReplacement(\n        MaterialPageRoute(builder: (_) => const HomeScreen()),\n      );\n    } else {\n      setState(() => _isLoading = false);\n    }\n  } catch (e) {\n    setState(() => _isLoading = false);\n\n    if (mounted) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text(e.toString())),\n      );\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Testing Complete",
              "content": "\nRun your app and test:\n1. ‚úÖ Register with email/password\n2. ‚úÖ Login with email/password\n3. ‚úÖ Sign in with Google\n4. ‚úÖ Password reset\n5. ‚úÖ Email verification\n6. ‚úÖ Logout\n\n**Check Firebase Console ‚Üí Authentication ‚Üí Users** to see all registered users!\n\n"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### ‚úÖ DO:\n1. **Always validate input** (email format, password strength)\n2. **Show user-friendly error messages** (not technical Firebase codes)\n3. **Verify emails** before allowing sensitive actions\n4. **Use StreamBuilder** for auth state changes\n5. **Handle loading states** (show spinners)\n6. **Test on real devices** (not just emulator)\n\n### ‚ùå DON'T:\n1. **Don't store passwords** in your app (Firebase handles this)\n2. **Don't show raw error codes** to users\n3. **Don't allow weak passwords** (< 6 characters)\n4. **Don't forget to sign out** from social providers too\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhy should you verify email addresses?\n\nA) It's required by Firebase\nB) To ensure users own the email and can recover their account\nC) It makes the app faster\nD) To collect user data\n\n### Question 2\nWhat happens when you call `authStateChanges()`?\n\nA) It checks the user's password\nB) It returns a Stream that emits whenever the user signs in or out\nC) It deletes the user\nD) It sends a verification email\n\n### Question 3\nWhy use Google Sign-In in addition to email/password?\n\nA) It's free\nB) It increases signup rates (50%+) and provides better UX\nC) It's more secure\nD) Firebase requires it\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: To ensure users own the email and can recover their account\n\nEmail verification confirms the user has access to the email address they provided. This prevents fake accounts, enables password recovery, and ensures you can communicate with users.\n\n### Answer 2: B\n**Correct**: It returns a Stream that emits whenever the user signs in or out\n\n`authStateChanges()` returns a Stream<User?> that automatically updates when authentication state changes. Use it with StreamBuilder to automatically show login/home screens based on auth status.\n\n### Answer 3: B\n**Correct**: It increases signup rates (50%+) and provides better UX\n\nSocial login reduces friction (no password to remember), increases trust (familiar Google logo), and significantly improves conversion rates. Users are 50% more likely to complete signup with social login.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've implemented complete authentication! In the next lesson, we'll learn **Cloud Firestore** - Firebase's powerful NoSQL database to store and sync data.\n\n**Coming up in Lesson 3: Cloud Firestore**\n- CRUD operations (Create, Read, Update, Delete)\n- Real-time data synchronization\n- Querying and filtering\n- Collections and documents\n- Complete app with Firestore\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Firebase Auth handles security, encryption, and session management\n‚úÖ Email verification is critical for account security\n‚úÖ StreamBuilder automatically updates UI based on auth state\n‚úÖ Social login (Google) improves signup rates by 50%\n‚úÖ Always show user-friendly error messages\n‚úÖ FirebaseAuth provides authStateChanges() stream for reactive UI\n‚úÖ Sign out from both Firebase and social providers on logout\n\n**You can now build apps with secure user authentication!** üîê\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "8.3",
          "title": "Module 8, Lesson 3: Cloud Firestore - Database Operations",
          "moduleId": "module-08",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll know how to store, retrieve, update, and delete data using Cloud Firestore - Firebase's powerful NoSQL cloud database with real-time synchronization.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Every app needs to store data.**\n\n- **Instagram**: Stores billions of posts, comments, likes\n- **Twitter**: Real-time tweets synced across devices\n- **Spotify**: Playlists, listening history, preferences\n- **Without a database**, your app loses all data when closed\n- **99% of apps** use a database to persist user data\n\nCloud Firestore is Google's modern database that automatically syncs data across all devices in real-time.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Filing Cabinet System",
              "content": "\n### Traditional SQL Database = Spreadsheet\nData stored in rigid tables with rows and columns:\n\n**Problem**: Adding a new field (e.g., \"Phone Number\") requires updating the entire table structure.\n\n### NoSQL Database (Firestore) = Filing Cabinet\nData stored as flexible documents in folders:\n\n**Benefits**:\n- ‚úÖ Each document can have different fields\n- ‚úÖ Easy to add new data without restructuring\n- ‚úÖ Hierarchical organization (like folders and subfolders)\n\n",
              "code": "users/ (Collection = Folder)\n  ‚îú‚îÄ‚îÄ alice123/ (Document = File)\n  ‚îÇ   ‚îú‚îÄ‚îÄ name: \"Alice\"\n  ‚îÇ   ‚îú‚îÄ‚îÄ email: \"alice@mail.com\"\n  ‚îÇ   ‚îú‚îÄ‚îÄ age: 25\n  ‚îÇ   ‚îî‚îÄ‚îÄ favoriteColor: \"blue\"  ‚Üê Can add unique fields!\n  ‚îÇ\n  ‚îî‚îÄ‚îÄ bob456/ (Document = File)\n      ‚îú‚îÄ‚îÄ name: \"Bob\"\n      ‚îú‚îÄ‚îÄ email: \"bob@mail.com\"\n      ‚îî‚îÄ‚îÄ age: 30",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Firestore Structure",
              "content": "\n### Collections and Documents\n\n\n**Key Concepts**:\n- **Collection**: Container for documents (like a folder)\n- **Document**: Individual record with key-value pairs (like a file)\n- **Documents must be inside collections** (alternating structure)\n- **Documents can contain subcollections**\n\n",
              "code": "firestore_database/\n‚îú‚îÄ‚îÄ users/ (Collection)\n‚îÇ   ‚îú‚îÄ‚îÄ user123/ (Document)\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ name: \"Alice\"\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ email: \"alice@example.com\"\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ posts/ (Subcollection)\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ post1/ (Document)\n‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ title: \"My First Post\"\n‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ content: \"Hello world!\"\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ post2/ (Document)\n‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ title: \"Second Post\"\n‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ content: \"Still learning!\"\n‚îÇ   ‚îÇ\n‚îÇ   ‚îî‚îÄ‚îÄ user456/ (Document)\n‚îÇ       ‚îú‚îÄ‚îÄ name: \"Bob\"\n‚îÇ       ‚îî‚îÄ‚îÄ email: \"bob@example.com\"\n‚îÇ\n‚îî‚îÄ‚îÄ posts/ (Collection)\n    ‚îú‚îÄ‚îÄ post123/ (Document)\n    ‚îÇ   ‚îú‚îÄ‚îÄ title: \"Flutter is Amazing\"\n    ‚îÇ   ‚îú‚îÄ‚îÄ authorId: \"user123\"\n    ‚îÇ   ‚îî‚îÄ‚îÄ likes: 42\n    ‚îî‚îÄ‚îÄ post456/ (Document)\n        ‚îú‚îÄ‚îÄ title: \"Learning Firestore\"\n        ‚îú‚îÄ‚îÄ authorId: \"user456\"\n        ‚îî‚îÄ‚îÄ likes: 15",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Firestore",
              "content": "\n### 1. Enable Firestore in Firebase Console\n\n1. Go to https://console.firebase.google.com\n2. Select your project\n3. Click **\"Firestore Database\"** in left sidebar\n4. Click **\"Create database\"**\n5. **Select mode**:\n   - **Test mode** (for learning): Anyone can read/write (insecure!)\n   - **Production mode**: Requires security rules (recommended)\n6. Choose location (select closest to your users)\n7. Click **\"Enable\"**\n\n### 2. Verify Package in pubspec.yaml\n\n\nRun:\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "CRUD Operations (Create, Read, Update, Delete)",
              "content": "\n### Create a Model Class\n\n\n",
              "code": "// lib/models/task.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\n\nclass Task {\n  final String? id; // Firestore document ID\n  final String title;\n  final String description;\n  final bool isCompleted;\n  final DateTime createdAt;\n  final String userId;\n\n  Task({\n    this.id,\n    required this.title,\n    required this.description,\n    this.isCompleted = false,\n    DateTime? createdAt,\n    required this.userId,\n  }) : createdAt = createdAt ?? DateTime.now();\n\n  // Convert Task to Map (for Firestore)\n  Map<String, dynamic> toMap() {\n    return {\n      'title': title,\n      'description': description,\n      'isCompleted': isCompleted,\n      'createdAt': Timestamp.fromDate(createdAt),\n      'userId': userId,\n    };\n  }\n\n  // Create Task from Firestore DocumentSnapshot\n  factory Task.fromFirestore(DocumentSnapshot doc) {\n    final data = doc.data() as Map<String, dynamic>;\n    return Task(\n      id: doc.id,\n      title: data['title'] ?? '',\n      description: data['description'] ?? '',\n      isCompleted: data['isCompleted'] ?? false,\n      createdAt: (data['createdAt'] as Timestamp).toDate(),\n      userId: data['userId'] ?? '',\n    );\n  }\n\n  // Create Task from Map\n  factory Task.fromMap(Map<String, dynamic> map, String id) {\n    return Task(\n      id: id,\n      title: map['title'] ?? '',\n      description: map['description'] ?? '',\n      isCompleted: map['isCompleted'] ?? false,\n      createdAt: (map['createdAt'] as Timestamp).toDate(),\n      userId: map['userId'] ?? '',\n    );\n  }\n\n  // Copy with method (useful for updates)\n  Task copyWith({\n    String? id,\n    String? title,\n    String? description,\n    bool? isCompleted,\n    DateTime? createdAt,\n    String? userId,\n  }) {\n    return Task(\n      id: id ?? this.id,\n      title: title ?? this.title,\n      description: description ?? this.description,\n      isCompleted: isCompleted ?? this.isCompleted,\n      createdAt: createdAt ?? this.createdAt,\n      userId: userId ?? this.userId,\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Create Firestore Service\n\n\n",
              "code": "// lib/services/firestore_service.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport '../models/task.dart';\n\nclass FirestoreService {\n  final FirebaseFirestore _firestore = FirebaseFirestore.instance;\n\n  // Reference to tasks collection\n  CollectionReference get _tasksCollection => _firestore.collection('tasks');\n\n  // ========== CREATE ==========\n\n  // Add a new task\n  Future<String> createTask(Task task) async {\n    try {\n      final docRef = await _tasksCollection.add(task.toMap());\n      return docRef.id; // Return the generated document ID\n    } catch (e) {\n      throw 'Failed to create task: $e';\n    }\n  }\n\n  // Add task with custom ID\n  Future<void> createTaskWithId(String id, Task task) async {\n    try {\n      await _tasksCollection.doc(id).set(task.toMap());\n    } catch (e) {\n      throw 'Failed to create task: $e';\n    }\n  }\n\n  // ========== READ ==========\n\n  // Get single task by ID\n  Future<Task?> getTask(String taskId) async {\n    try {\n      final doc = await _tasksCollection.doc(taskId).get();\n\n      if (doc.exists) {\n        return Task.fromFirestore(doc);\n      }\n      return null;\n    } catch (e) {\n      throw 'Failed to get task: $e';\n    }\n  }\n\n  // Get all tasks for a user (returns Future)\n  Future<List<Task>> getUserTasks(String userId) async {\n    try {\n      final querySnapshot = await _tasksCollection\n          .where('userId', isEqualTo: userId)\n          .orderBy('createdAt', descending: true)\n          .get();\n\n      return querySnapshot.docs\n          .map((doc) => Task.fromFirestore(doc))\n          .toList();\n    } catch (e) {\n      throw 'Failed to get tasks: $e';\n    }\n  }\n\n  // Get tasks as a Stream (real-time updates!)\n  Stream<List<Task>> getUserTasksStream(String userId) {\n    return _tasksCollection\n        .where('userId', isEqualTo: userId)\n        .orderBy('createdAt', descending: true)\n        .snapshots()\n        .map((snapshot) {\n      return snapshot.docs.map((doc) => Task.fromFirestore(doc)).toList();\n    });\n  }\n\n  // Get completed tasks only\n  Future<List<Task>> getCompletedTasks(String userId) async {\n    try {\n      final querySnapshot = await _tasksCollection\n          .where('userId', isEqualTo: userId)\n          .where('isCompleted', isEqualTo: true)\n          .orderBy('createdAt', descending: true)\n          .get();\n\n      return querySnapshot.docs\n          .map((doc) => Task.fromFirestore(doc))\n          .toList();\n    } catch (e) {\n      throw 'Failed to get completed tasks: $e';\n    }\n  }\n\n  // ========== UPDATE ==========\n\n  // Update entire task\n  Future<void> updateTask(String taskId, Task task) async {\n    try {\n      await _tasksCollection.doc(taskId).update(task.toMap());\n    } catch (e) {\n      throw 'Failed to update task: $e';\n    }\n  }\n\n  // Update specific fields only\n  Future<void> updateTaskFields(String taskId, Map<String, dynamic> fields) async {\n    try {\n      await _tasksCollection.doc(taskId).update(fields);\n    } catch (e) {\n      throw 'Failed to update task fields: $e';\n    }\n  }\n\n  // Toggle task completion\n  Future<void> toggleTaskCompletion(String taskId, bool isCompleted) async {\n    try {\n      await _tasksCollection.doc(taskId).update({\n        'isCompleted': !isCompleted,\n      });\n    } catch (e) {\n      throw 'Failed to toggle task: $e';\n    }\n  }\n\n  // ========== DELETE ==========\n\n  // Delete a task\n  Future<void> deleteTask(String taskId) async {\n    try {\n      await _tasksCollection.doc(taskId).delete();\n    } catch (e) {\n      throw 'Failed to delete task: $e';\n    }\n  }\n\n  // Delete all completed tasks for a user\n  Future<void> deleteCompletedTasks(String userId) async {\n    try {\n      final querySnapshot = await _tasksCollection\n          .where('userId', isEqualTo: userId)\n          .where('isCompleted', isEqualTo: true)\n          .get();\n\n      // Batch delete for efficiency\n      final batch = _firestore.batch();\n      for (var doc in querySnapshot.docs) {\n        batch.delete(doc.reference);\n      }\n      await batch.commit();\n    } catch (e) {\n      throw 'Failed to delete completed tasks: $e';\n    }\n  }\n\n  // ========== ADVANCED QUERIES ==========\n\n  // Search tasks by title\n  Future<List<Task>> searchTasks(String userId, String searchTerm) async {\n    try {\n      final querySnapshot = await _tasksCollection\n          .where('userId', isEqualTo: userId)\n          .where('title', isGreaterThanOrEqualTo: searchTerm)\n          .where('title', isLessThanOrEqualTo: '$searchTerm\\uf8ff')\n          .get();\n\n      return querySnapshot.docs\n          .map((doc) => Task.fromFirestore(doc))\n          .toList();\n    } catch (e) {\n      throw 'Failed to search tasks: $e';\n    }\n  }\n\n  // Get task count for a user\n  Future<int> getTaskCount(String userId) async {\n    try {\n      final querySnapshot = await _tasksCollection\n          .where('userId', isEqualTo: userId)\n          .count()\n          .get();\n\n      return querySnapshot.count ?? 0;\n    } catch (e) {\n      throw 'Failed to get task count: $e';\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Building a Task Manager App",
              "content": "\n### Tasks Screen with StreamBuilder\n\n\n",
              "code": "// lib/screens/tasks/tasks_screen.dart\nimport 'package:flutter/material.dart';\nimport '../../services/firestore_service.dart';\nimport '../../services/auth_service.dart';\nimport '../../models/task.dart';\nimport 'add_task_screen.dart';\n\nclass TasksScreen extends StatefulWidget {\n  const TasksScreen({super.key});\n\n  @override\n  State<TasksScreen> createState() => _TasksScreenState();\n}\n\nclass _TasksScreenState extends State<TasksScreen> {\n  final _firestoreService = FirestoreService();\n  final _authService = AuthService();\n\n  @override\n  Widget build(BuildContext context) {\n    final userId = _authService.currentUser?.uid;\n\n    if (userId == null) {\n      return const Scaffold(\n        body: Center(child: Text('Please login first')),\n      );\n    }\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('My Tasks'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.delete_sweep),\n            tooltip: 'Clear completed',\n            onPressed: () => _clearCompleted(userId),\n          ),\n        ],\n      ),\n      body: StreamBuilder<List<Task>>(\n        stream: _firestoreService.getUserTasksStream(userId),\n        builder: (context, snapshot) {\n          // Loading state\n          if (snapshot.connectionState == ConnectionState.waiting) {\n            return const Center(child: CircularProgressIndicator());\n          }\n\n          // Error state\n          if (snapshot.hasError) {\n            return Center(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  const Icon(Icons.error_outline, size: 64, color: Colors.red),\n                  const SizedBox(height: 16),\n                  Text('Error: ${snapshot.error}'),\n                  const SizedBox(height: 16),\n                  FilledButton(\n                    onPressed: () => setState(() {}),\n                    child: const Text('Retry'),\n                  ),\n                ],\n              ),\n            );\n          }\n\n          // Empty state\n          if (!snapshot.hasData || snapshot.data!.isEmpty) {\n            return Center(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  Icon(\n                    Icons.task_alt,\n                    size: 100,\n                    color: Colors.grey.shade300,\n                  ),\n                  const SizedBox(height: 16),\n                  Text(\n                    'No tasks yet',\n                    style: Theme.of(context).textTheme.headlineSmall?.copyWith(\n                      color: Colors.grey.shade600,\n                    ),\n                  ),\n                  const SizedBox(height: 8),\n                  Text(\n                    'Tap + to create your first task',\n                    style: TextStyle(color: Colors.grey.shade500),\n                  ),\n                ],\n              ),\n            );\n          }\n\n          // Success state with data\n          final tasks = snapshot.data!;\n\n          return ListView.builder(\n            padding: const EdgeInsets.all(16),\n            itemCount: tasks.length,\n            itemBuilder: (context, index) {\n              final task = tasks[index];\n              return _buildTaskCard(task);\n            },\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => _navigateToAddTask(context),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n\n  Widget _buildTaskCard(Task task) {\n    return Card(\n      margin: const EdgeInsets.only(bottom: 12),\n      child: ListTile(\n        leading: Checkbox(\n          value: task.isCompleted,\n          onChanged: (_) => _toggleTask(task),\n        ),\n        title: Text(\n          task.title,\n          style: TextStyle(\n            decoration: task.isCompleted ? TextDecoration.lineThrough : null,\n            color: task.isCompleted ? Colors.grey : null,\n          ),\n        ),\n        subtitle: task.description.isNotEmpty\n            ? Text(\n                task.description,\n                maxLines: 2,\n                overflow: TextOverflow.ellipsis,\n              )\n            : null,\n        trailing: Row(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            // Edit button\n            IconButton(\n              icon: const Icon(Icons.edit),\n              onPressed: () => _editTask(task),\n            ),\n            // Delete button\n            IconButton(\n              icon: const Icon(Icons.delete, color: Colors.red),\n              onPressed: () => _deleteTask(task),\n            ),\n          ],\n        ),\n        onTap: () => _showTaskDetails(task),\n      ),\n    );\n  }\n\n  Future<void> _toggleTask(Task task) async {\n    try {\n      await _firestoreService.toggleTaskCompletion(task.id!, task.isCompleted);\n    } catch (e) {\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Failed to update task: $e')),\n        );\n      }\n    }\n  }\n\n  Future<void> _deleteTask(Task task) async {\n    final confirm = await showDialog<bool>(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: const Text('Delete Task'),\n        content: Text('Delete \"${task.title}\"?'),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(context, false),\n            child: const Text('Cancel'),\n          ),\n          FilledButton(\n            onPressed: () => Navigator.pop(context, true),\n            style: FilledButton.styleFrom(backgroundColor: Colors.red),\n            child: const Text('Delete'),\n          ),\n        ],\n      ),\n    );\n\n    if (confirm == true) {\n      try {\n        await _firestoreService.deleteTask(task.id!);\n        if (mounted) {\n          ScaffoldMessenger.of(context).showSnackBar(\n            const SnackBar(content: Text('Task deleted')),\n          );\n        }\n      } catch (e) {\n        if (mounted) {\n          ScaffoldMessenger.of(context).showSnackBar(\n            SnackBar(content: Text('Failed to delete: $e')),\n          );\n        }\n      }\n    }\n  }\n\n  Future<void> _clearCompleted(String userId) async {\n    try {\n      await _firestoreService.deleteCompletedTasks(userId);\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Completed tasks cleared')),\n        );\n      }\n    } catch (e) {\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Failed to clear: $e')),\n        );\n      }\n    }\n  }\n\n  void _navigateToAddTask(BuildContext context) {\n    Navigator.of(context).push(\n      MaterialPageRoute(builder: (_) => const AddTaskScreen()),\n    );\n  }\n\n  void _editTask(Task task) {\n    Navigator.of(context).push(\n      MaterialPageRoute(builder: (_) => AddTaskScreen(task: task)),\n    );\n  }\n\n  void _showTaskDetails(Task task) {\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: Text(task.title),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            if (task.description.isNotEmpty) ...[\n              Text(task.description),\n              const SizedBox(height: 16),\n            ],\n            Text(\n              'Status: ${task.isCompleted ? \"Completed\" : \"Pending\"}',\n              style: const TextStyle(fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 8),\n            Text(\n              'Created: ${_formatDate(task.createdAt)}',\n              style: TextStyle(color: Colors.grey.shade600),\n            ),\n          ],\n        ),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(context),\n            child: const Text('Close'),\n          ),\n        ],\n      ),\n    );\n  }\n\n  String _formatDate(DateTime date) {\n    return '${date.day}/${date.month}/${date.year} ${date.hour}:${date.minute.toString().padLeft(2, '0')}';\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Add Task Screen\n\n\n",
              "code": "// lib/screens/tasks/add_task_screen.dart\nimport 'package:flutter/material.dart';\nimport '../../services/firestore_service.dart';\nimport '../../services/auth_service.dart';\nimport '../../models/task.dart';\n\nclass AddTaskScreen extends StatefulWidget {\n  final Task? task; // If editing, pass existing task\n\n  const AddTaskScreen({super.key, this.task});\n\n  @override\n  State<AddTaskScreen> createState() => _AddTaskScreenState();\n}\n\nclass _AddTaskScreenState extends State<AddTaskScreen> {\n  final _firestoreService = FirestoreService();\n  final _authService = AuthService();\n  final _formKey = GlobalKey<FormState>();\n  final _titleController = TextEditingController();\n  final _descriptionController = TextEditingController();\n\n  bool _isLoading = false;\n  bool get _isEditing => widget.task != null;\n\n  @override\n  void initState() {\n    super.initState();\n    if (_isEditing) {\n      _titleController.text = widget.task!.title;\n      _descriptionController.text = widget.task!.description;\n    }\n  }\n\n  @override\n  void dispose() {\n    _titleController.dispose();\n    _descriptionController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _saveTask() async {\n    if (!_formKey.currentState!.validate()) return;\n\n    final userId = _authService.currentUser?.uid;\n    if (userId == null) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text('Please login first')),\n      );\n      return;\n    }\n\n    setState(() => _isLoading = true);\n\n    try {\n      final task = Task(\n        id: widget.task?.id,\n        title: _titleController.text.trim(),\n        description: _descriptionController.text.trim(),\n        userId: userId,\n        isCompleted: widget.task?.isCompleted ?? false,\n        createdAt: widget.task?.createdAt,\n      );\n\n      if (_isEditing) {\n        await _firestoreService.updateTask(task.id!, task);\n      } else {\n        await _firestoreService.createTask(task);\n      }\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(\n            content: Text(_isEditing ? 'Task updated!' : 'Task created!'),\n          ),\n        );\n        Navigator.of(context).pop();\n      }\n    } catch (e) {\n      setState(() => _isLoading = false);\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Error: $e')),\n        );\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(_isEditing ? 'Edit Task' : 'Add Task'),\n      ),\n      body: Form(\n        key: _formKey,\n        child: ListView(\n          padding: const EdgeInsets.all(24.0),\n          children: [\n            TextFormField(\n              controller: _titleController,\n              decoration: const InputDecoration(\n                labelText: 'Title',\n                border: OutlineInputBorder(),\n              ),\n              enabled: !_isLoading,\n              validator: (value) {\n                if (value == null || value.trim().isEmpty) {\n                  return 'Please enter a title';\n                }\n                return null;\n              },\n            ),\n            const SizedBox(height: 16),\n            TextFormField(\n              controller: _descriptionController,\n              decoration: const InputDecoration(\n                labelText: 'Description (optional)',\n                border: OutlineInputBorder(),\n                alignLabelWithHint: true,\n              ),\n              maxLines: 5,\n              enabled: !_isLoading,\n            ),\n            const SizedBox(height: 24),\n            FilledButton(\n              onPressed: _isLoading ? null : _saveTask,\n              style: FilledButton.styleFrom(\n                padding: const EdgeInsets.symmetric(vertical: 16),\n              ),\n              child: _isLoading\n                  ? const SizedBox(\n                      height: 20,\n                      width: 20,\n                      child: CircularProgressIndicator(strokeWidth: 2),\n                    )\n                  : Text(_isEditing ? 'Update Task' : 'Create Task'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Testing Your Firestore App",
              "content": "\n1. **Run the app**: `flutter run`\n2. **Create tasks**: Add several tasks\n3. **Check Firebase Console**: Firestore Database ‚Üí View your data\n4. **Real-time sync test**:\n   - Open app on 2 devices/emulators\n   - Create task on device 1\n   - Watch it appear instantly on device 2!\n5. **Test CRUD**: Create, read, update, delete tasks\n\n"
            },
            {
              "type": "THEORY",
              "title": "Firestore Query Operators",
              "content": "\n### Comparison Operators\n\n\n### Ordering and Limiting\n\n\n",
              "code": "// Order by field (ascending)\n.orderBy('createdAt')\n\n// Order descending\n.orderBy('createdAt', descending: true)\n\n// Multiple orderBy\n.orderBy('priority', descending: true)\n.orderBy('createdAt')\n\n// Limit results\n.limit(10)\n\n// Start after document (pagination)\n.startAfterDocument(lastDocument)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Real-Time Updates with Streams",
              "content": "\n**Streams automatically update when data changes!**\n\n### Single Document Stream\n\n\n### Collection Stream\n\n\n**Use with StreamBuilder** for automatic UI updates!\n\n",
              "code": "Stream<List<Task>> getTasksStream() {\n  return _tasksCollection\n      .snapshots()\n      .map((snapshot) {\n        return snapshot.docs\n            .map((doc) => Task.fromFirestore(doc))\n            .toList();\n      });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Batch Operations (Multiple Writes)",
              "content": "\nFor performance, batch multiple writes:\n\n\n**Benefits**:\n- ‚úÖ Atomic (all succeed or all fail)\n- ‚úÖ More efficient (single network call)\n- ‚úÖ Up to 500 operations per batch\n\n",
              "code": "Future<void> batchUpdateTasks(List<Task> tasks) async {\n  final batch = _firestore.batch();\n\n  for (var task in tasks) {\n    final docRef = _tasksCollection.doc(task.id);\n    batch.update(docRef, task.toMap());\n  }\n\n  await batch.commit(); // Execute all updates at once\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### ‚úÖ DO:\n1. **Use StreamBuilder** for real-time data\n2. **Index frequently queried fields** (Firebase Console ‚Üí Indexes)\n3. **Denormalize data** when needed (duplicate for read performance)\n4. **Use batch writes** for multiple updates\n5. **Paginate large datasets** (use `.limit()` and `.startAfter()`)\n6. **Handle offline mode** (Firestore caches automatically)\n7. **Use Timestamps** for dates (not Strings)\n\n### ‚ùå DON'T:\n1. **Don't fetch entire collections** (use queries with filters)\n2. **Don't nest data too deeply** (max 3-4 levels)\n3. **Don't use client-side filtering** (use Firestore queries)\n4. **Don't store large files** in documents (use Cloud Storage)\n5. **Don't forget security rules** (covered in next lesson)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Common Patterns",
              "content": "\n### User-Specific Data\n\n\n### Subcollections\n\n\n### Array Fields\n\n\n### Increment/Decrement\n\n\n",
              "code": "// Increment likes count\n.update({\n  'likes': FieldValue.increment(1)\n});\n\n// Decrement\n.update({\n  'stock': FieldValue.increment(-1)\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhat's the difference between `.get()` and `.snapshots()`?\n\nA) They're the same\nB) `.get()` fetches once, `.snapshots()` provides real-time updates via Stream\nC) `.snapshots()` is faster\nD) `.get()` is for collections only\n\n### Question 2\nWhy use batch writes instead of individual updates?\n\nA) They're required by Firestore\nB) They're atomic (all-or-nothing) and more efficient\nC) They're easier to write\nD) They're only for deletions\n\n### Question 3\nWhat's the maximum nesting depth recommended for Firestore documents?\n\nA) 1 level\nB) 3-4 levels\nC) 10 levels\nD) Unlimited\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: `.get()` fetches once, `.snapshots()` provides real-time updates via Stream\n\n`.get()` returns a Future that fetches data once. `.snapshots()` returns a Stream that continuously listens for changes and automatically updates your UI via StreamBuilder.\n\n### Answer 2: B\n**Correct**: They're atomic (all-or-nothing) and more efficient\n\nBatch writes ensure all operations succeed or fail together (atomicity), prevent partial updates, and reduce network calls by bundling multiple operations into one request.\n\n### Answer 3: B\n**Correct**: 3-4 levels\n\nWhile Firestore technically allows deeper nesting, 3-4 levels is the practical recommendation. Deeper nesting makes queries complex and can impact performance. Consider denormalizing or using subcollections instead.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've mastered Firestore CRUD operations! In the next lesson, we'll learn **Cloud Storage** to upload and store images, videos, and files.\n\n**Coming up in Lesson 4: Firebase Cloud Storage**\n- Upload images and files\n- Download URLs\n- Progress tracking\n- Delete files\n- Complete image gallery app\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Firestore is a NoSQL database with collections and documents\n‚úÖ Use StreamBuilder for real-time data synchronization\n‚úÖ CRUD operations: add(), get(), update(), delete()\n‚úÖ Queries support filtering (.where), ordering (.orderBy), and limiting (.limit)\n‚úÖ Batch operations improve performance for multiple writes\n‚úÖ Always filter by userId to ensure users only see their data\n‚úÖ Firestore automatically handles offline caching\n\n**You can now build apps with real-time cloud databases!** üéâ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "8.4",
          "title": "Module 8, Lesson 4: Firebase Cloud Storage - File Storage",
          "moduleId": "module-08",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll know how to upload, download, and manage files (images, videos, documents) using Firebase Cloud Storage with progress tracking and security.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Most apps need to store user files.**\n\n- **Instagram**: Stores billions of photos and videos\n- **WhatsApp**: Profile pictures, media messages, documents\n- **Google Drive**: Files of all types in the cloud\n- **LinkedIn**: Profile photos, resumes, company logos\n- **90% of social apps** involve media upload/download\n\nFirebase Cloud Storage provides secure, scalable file storage that integrates seamlessly with Firebase Authentication and Firestore.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Photo Lab",
              "content": "\n### Before Cloud Storage = Physical Photo Album\n- üì∏ Take photo ‚Üí develop film ‚Üí store in album\n- üì¶ Album stored in your house only\n- ‚ùå Lose the album, lose all photos\n- ‚ùå Can't share with friends easily\n- ‚ùå Limited by physical space\n\n### With Cloud Storage = Online Photo Service (Google Photos)\n- üì∏ Take photo ‚Üí automatically uploads to cloud\n- ‚òÅÔ∏è Stored on servers worldwide (safe and redundant)\n- ‚úÖ Access from any device\n- ‚úÖ Share with anyone via link\n- ‚úÖ Unlimited storage (in cloud)\n- üîê Protected by authentication\n\n**Firebase Storage is your app's photo lab in the cloud!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Firebase Storage Overview",
              "content": "\n### What Firebase Storage Provides\n\n1. **File Upload/Download**\n   - Images (JPEG, PNG, GIF, WebP)\n   - Videos (MP4, MOV)\n   - Audio files\n   - Documents (PDF, DOCX)\n   - Any file type\n\n2. **Security**\n   - Integration with Firebase Auth\n   - Custom security rules\n   - Access control per user\n\n3. **Performance**\n   - Automatic compression\n   - CDN (Content Delivery Network)\n   - Resume interrupted uploads/downloads\n\n4. **Scalability**\n   - Handles millions of files\n   - Automatic load balancing\n   - Google's infrastructure\n\n"
            },
            {
              "type": "THEORY",
              "title": "Storage Structure",
              "content": "\nFirebase Storage organizes files like a file system:\n\n\n**Best practices**:\n- Organize by user ID or content type\n- Use consistent naming conventions\n- Avoid spaces in filenames (use hyphens or underscores)\n\n",
              "code": "gs://your-app.appspot.com/\n‚îú‚îÄ‚îÄ users/\n‚îÇ   ‚îú‚îÄ‚îÄ user123/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ profile.jpg\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ documents/\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ resume.pdf\n‚îÇ   ‚îî‚îÄ‚îÄ user456/\n‚îÇ       ‚îî‚îÄ‚îÄ profile.jpg\n‚îú‚îÄ‚îÄ posts/\n‚îÇ   ‚îú‚îÄ‚îÄ post001.jpg\n‚îÇ   ‚îî‚îÄ‚îÄ post002.mp4\n‚îî‚îÄ‚îÄ public/\n    ‚îî‚îÄ‚îÄ app-logo.png",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Firebase Storage",
              "content": "\n### 1. Enable Storage in Firebase Console\n\n1. Go to https://console.firebase.google.com\n2. Select your project\n3. Click **\"Storage\"** in left sidebar\n4. Click **\"Get started\"**\n5. Choose security rules:\n   - **Test mode**: Anyone can read/write (insecure!)\n   - **Production mode**: Requires authentication (recommended)\n6. Select location (same as Firestore for consistency)\n7. Click **\"Done\"**\n\n### 2. Add Package to pubspec.yaml\n\n\nRun:\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Basic Storage Operations",
              "content": "\n### Create Storage Service\n\n\n",
              "code": "// lib/services/storage_service.dart\nimport 'package:firebase_storage/firebase_storage.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nimport 'dart:io';\n\nclass StorageService {\n  final FirebaseStorage _storage = FirebaseStorage.instance;\n  final FirebaseAuth _auth = FirebaseAuth.instance;\n\n  String? get currentUserId => _auth.currentUser?.uid;\n\n  // ========== UPLOAD ==========\n\n  // Upload file with progress tracking\n  Future<String> uploadFile({\n    required File file,\n    required String path,\n    Function(double)? onProgress,\n  }) async {\n    try {\n      // Create reference to the file location\n      final storageRef = _storage.ref().child(path);\n\n      // Upload the file\n      final uploadTask = storageRef.putFile(file);\n\n      // Listen to upload progress\n      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n        final progress = snapshot.bytesTransferred / snapshot.totalBytes;\n        if (onProgress != null) {\n          onProgress(progress);\n        }\n      });\n\n      // Wait for upload to complete\n      final snapshot = await uploadTask;\n\n      // Get download URL\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      return downloadUrl;\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // Upload user profile picture\n  Future<String> uploadProfilePicture(File imageFile) async {\n    if (currentUserId == null) throw 'User not authenticated';\n\n    final fileName = 'profile_${DateTime.now().millisecondsSinceEpoch}.jpg';\n    final path = 'users/$currentUserId/profile/$fileName';\n\n    return uploadFile(file: imageFile, path: path);\n  }\n\n  // Upload post image\n  Future<String> uploadPostImage(File imageFile) async {\n    if (currentUserId == null) throw 'User not authenticated';\n\n    final fileName = 'post_${DateTime.now().millisecondsSinceEpoch}.jpg';\n    final path = 'users/$currentUserId/posts/$fileName';\n\n    return uploadFile(file: imageFile, path: path);\n  }\n\n  // Upload document\n  Future<String> uploadDocument(File file, String documentName) async {\n    if (currentUserId == null) throw 'User not authenticated';\n\n    final fileName = '${DateTime.now().millisecondsSinceEpoch}_$documentName';\n    final path = 'users/$currentUserId/documents/$fileName';\n\n    return uploadFile(file: file, path: path);\n  }\n\n  // ========== DOWNLOAD ==========\n\n  // Get download URL for a file\n  Future<String> getDownloadUrl(String path) async {\n    try {\n      final ref = _storage.ref().child(path);\n      return await ref.getDownloadURL();\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // Download file to local storage\n  Future<File> downloadFile({\n    required String path,\n    required String localPath,\n    Function(double)? onProgress,\n  }) async {\n    try {\n      final ref = _storage.ref().child(path);\n      final file = File(localPath);\n\n      final downloadTask = ref.writeToFile(file);\n\n      // Listen to download progress\n      downloadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n        final progress = snapshot.bytesTransferred / snapshot.totalBytes;\n        if (onProgress != null) {\n          onProgress(progress);\n        }\n      });\n\n      await downloadTask;\n      return file;\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // ========== DELETE ==========\n\n  // Delete file by path\n  Future<void> deleteFile(String path) async {\n    try {\n      final ref = _storage.ref().child(path);\n      await ref.delete();\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // Delete file by URL\n  Future<void> deleteFileByUrl(String downloadUrl) async {\n    try {\n      final ref = _storage.refFromURL(downloadUrl);\n      await ref.delete();\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // Delete user's profile picture\n  Future<void> deleteProfilePicture() async {\n    if (currentUserId == null) throw 'User not authenticated';\n\n    final path = 'users/$currentUserId/profile/';\n    await _deleteFolder(path);\n  }\n\n  // ========== METADATA ==========\n\n  // Get file metadata\n  Future<FullMetadata> getMetadata(String path) async {\n    try {\n      final ref = _storage.ref().child(path);\n      return await ref.getMetadata();\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // Update file metadata\n  Future<void> updateMetadata({\n    required String path,\n    Map<String, String>? customMetadata,\n    String? contentType,\n  }) async {\n    try {\n      final ref = _storage.ref().child(path);\n      final metadata = SettableMetadata(\n        customMetadata: customMetadata,\n        contentType: contentType,\n      );\n      await ref.updateMetadata(metadata);\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // ========== LIST FILES ==========\n\n  // List all files in a directory\n  Future<List<String>> listFiles(String path) async {\n    try {\n      final ref = _storage.ref().child(path);\n      final result = await ref.listAll();\n\n      return result.items.map((item) => item.fullPath).toList();\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // List user's profile pictures\n  Future<List<String>> listUserImages() async {\n    if (currentUserId == null) throw 'User not authenticated';\n\n    final path = 'users/$currentUserId/posts/';\n    return listFiles(path);\n  }\n\n  // ========== HELPER METHODS ==========\n\n  // Delete entire folder (recursively)\n  Future<void> _deleteFolder(String path) async {\n    final ref = _storage.ref().child(path);\n    final result = await ref.listAll();\n\n    // Delete all files\n    for (var item in result.items) {\n      await item.delete();\n    }\n\n    // Delete subfolders recursively\n    for (var prefix in result.prefixes) {\n      await _deleteFolder(prefix.fullPath);\n    }\n  }\n\n  // Handle Storage exceptions\n  String _handleStorageException(FirebaseException e) {\n    switch (e.code) {\n      case 'unauthorized':\n        return 'You don\\'t have permission to access this file.';\n      case 'canceled':\n        return 'Upload/download was canceled.';\n      case 'unknown':\n        return 'An unknown error occurred.';\n      case 'object-not-found':\n        return 'File not found.';\n      case 'bucket-not-found':\n        return 'Storage bucket not found.';\n      case 'project-not-found':\n        return 'Firebase project not found.';\n      case 'quota-exceeded':\n        return 'Storage quota exceeded.';\n      case 'unauthenticated':\n        return 'Please login to upload files.';\n      case 'retry-limit-exceeded':\n        return 'Operation timed out. Please try again.';\n      default:\n        return 'Storage error: ${e.message}';\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Image Upload App",
              "content": "\n### Profile Picture Upload Screen\n\n\n",
              "code": "// lib/screens/profile/edit_profile_screen.dart\nimport 'package:flutter/material.dart';\nimport 'package:image_picker/image_picker.dart';\nimport 'dart:io';\nimport '../../services/storage_service.dart';\nimport '../../services/auth_service.dart';\nimport '../../services/firestore_service.dart';\n\nclass EditProfileScreen extends StatefulWidget {\n  const EditProfileScreen({super.key});\n\n  @override\n  State<EditProfileScreen> createState() => _EditProfileScreenState();\n}\n\nclass _EditProfileScreenState extends State<EditProfileScreen> {\n  final _storageService = StorageService();\n  final _authService = AuthService();\n  final _imagePicker = ImagePicker();\n\n  File? _selectedImage;\n  bool _isUploading = false;\n  double _uploadProgress = 0.0;\n  String? _currentProfileUrl;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadCurrentProfile();\n  }\n\n  Future<void> _loadCurrentProfile() async {\n    // Load user's current profile picture URL from Firestore\n    // (Implementation depends on your Firestore setup)\n  }\n\n  Future<void> _pickImage(ImageSource source) async {\n    try {\n      final XFile? image = await _imagePicker.pickImage(\n        source: source,\n        maxWidth: 1024,\n        maxHeight: 1024,\n        imageQuality: 85,\n      );\n\n      if (image != null) {\n        setState(() {\n          _selectedImage = File(image.path);\n        });\n      }\n    } catch (e) {\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Failed to pick image: $e')),\n        );\n      }\n    }\n  }\n\n  Future<void> _uploadProfilePicture() async {\n    if (_selectedImage == null) return;\n\n    setState(() {\n      _isUploading = true;\n      _uploadProgress = 0.0;\n    });\n\n    try {\n      // Delete old profile picture if exists\n      if (_currentProfileUrl != null) {\n        try {\n          await _storageService.deleteFileByUrl(_currentProfileUrl!);\n        } catch (e) {\n          // Ignore if file doesn't exist\n        }\n      }\n\n      // Upload new profile picture\n      final downloadUrl = await _storageService.uploadFile(\n        file: _selectedImage!,\n        path: 'users/${_storageService.currentUserId}/profile/profile.jpg',\n        onProgress: (progress) {\n          setState(() {\n            _uploadProgress = progress;\n          });\n        },\n      );\n\n      // Update Firestore with new profile URL\n      // await _firestoreService.updateUserProfile(downloadUrl);\n\n      setState(() {\n        _isUploading = false;\n        _currentProfileUrl = downloadUrl;\n        _selectedImage = null;\n      });\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Profile picture updated!')),\n        );\n      }\n    } catch (e) {\n      setState(() {\n        _isUploading = false;\n      });\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Upload failed: $e')),\n        );\n      }\n    }\n  }\n\n  Future<void> _showImageSourceDialog() async {\n    return showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: const Text('Choose Image Source'),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            ListTile(\n              leading: const Icon(Icons.camera_alt),\n              title: const Text('Camera'),\n              onTap: () {\n                Navigator.pop(context);\n                _pickImage(ImageSource.camera);\n              },\n            ),\n            ListTile(\n              leading: const Icon(Icons.photo_library),\n              title: const Text('Gallery'),\n              onTap: () {\n                Navigator.pop(context);\n                _pickImage(ImageSource.gallery);\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Edit Profile Picture'),\n      ),\n      body: Center(\n        child: SingleChildScrollView(\n          padding: const EdgeInsets.all(24.0),\n          child: Column(\n            children: [\n              // Profile picture preview\n              Stack(\n                children: [\n                  CircleAvatar(\n                    radius: 80,\n                    backgroundColor: Colors.grey.shade200,\n                    backgroundImage: _selectedImage != null\n                        ? FileImage(_selectedImage!)\n                        : (_currentProfileUrl != null\n                            ? NetworkImage(_currentProfileUrl!)\n                            : null) as ImageProvider?,\n                    child: _selectedImage == null && _currentProfileUrl == null\n                        ? Icon(\n                            Icons.person,\n                            size: 80,\n                            color: Colors.grey.shade400,\n                          )\n                        : null,\n                  ),\n                  Positioned(\n                    bottom: 0,\n                    right: 0,\n                    child: CircleAvatar(\n                      backgroundColor: Theme.of(context).primaryColor,\n                      child: IconButton(\n                        icon: const Icon(Icons.camera_alt, color: Colors.white),\n                        onPressed: _isUploading ? null : _showImageSourceDialog,\n                      ),\n                    ),\n                  ),\n                ],\n              ),\n\n              const SizedBox(height: 32),\n\n              // Upload progress\n              if (_isUploading) ...[\n                LinearProgressIndicator(value: _uploadProgress),\n                const SizedBox(height: 8),\n                Text(\n                  'Uploading... ${(_uploadProgress * 100).toStringAsFixed(0)}%',\n                  style: TextStyle(color: Colors.grey.shade600),\n                ),\n                const SizedBox(height: 24),\n              ],\n\n              // Upload button\n              if (_selectedImage != null && !_isUploading)\n                FilledButton.icon(\n                  onPressed: _uploadProfilePicture,\n                  icon: const Icon(Icons.cloud_upload),\n                  label: const Text('Upload Profile Picture'),\n                  style: FilledButton.styleFrom(\n                    padding: const EdgeInsets.symmetric(\n                      horizontal: 32,\n                      vertical: 16,\n                    ),\n                  ),\n                ),\n\n              // Delete button\n              if (_currentProfileUrl != null && !_isUploading) ...[\n                const SizedBox(height: 16),\n                OutlinedButton.icon(\n                  onPressed: () async {\n                    final confirm = await showDialog<bool>(\n                      context: context,\n                      builder: (context) => AlertDialog(\n                        title: const Text('Delete Profile Picture'),\n                        content: const Text('Are you sure?'),\n                        actions: [\n                          TextButton(\n                            onPressed: () => Navigator.pop(context, false),\n                            child: const Text('Cancel'),\n                          ),\n                          FilledButton(\n                            onPressed: () => Navigator.pop(context, true),\n                            style: FilledButton.styleFrom(\n                              backgroundColor: Colors.red,\n                            ),\n                            child: const Text('Delete'),\n                          ),\n                        ],\n                      ),\n                    );\n\n                    if (confirm == true) {\n                      try {\n                        await _storageService.deleteFileByUrl(_currentProfileUrl!);\n                        setState(() {\n                          _currentProfileUrl = null;\n                        });\n                        if (mounted) {\n                          ScaffoldMessenger.of(context).showSnackBar(\n                            const SnackBar(content: Text('Profile picture deleted')),\n                          );\n                        }\n                      } catch (e) {\n                        if (mounted) {\n                          ScaffoldMessenger.of(context).showSnackBar(\n                            SnackBar(content: Text('Delete failed: $e')),\n                          );\n                        }\n                      }\n                    }\n                  },\n                  icon: const Icon(Icons.delete, color: Colors.red),\n                  label: const Text('Delete Profile Picture'),\n                  style: OutlinedButton.styleFrom(\n                    foregroundColor: Colors.red,\n                    side: const BorderSide(color: Colors.red),\n                  ),\n                ),\n              ],\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Firebase Storage Security Rules",
              "content": "\n### Default Rules (Test Mode - Insecure!)\n\n\n### Production Rules (Secure)\n\n\n### Update Rules in Firebase Console\n\n1. Go to Firebase Console ‚Üí Storage\n2. Click \"Rules\" tab\n3. Paste your security rules\n4. Click \"Publish\"\n\n",
              "code": "rules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // User-specific files\n    match /users/{userId}/{allPaths=**} {\n      // Only the user can read/write their own files\n      allow read, write: if request.auth != null && request.auth.uid == userId;\n    }\n\n    // Public files (anyone can read)\n    match /public/{allPaths=**} {\n      allow read: if true;\n      allow write: if request.auth != null;  // Only authenticated users can write\n    }\n\n    // Posts (owner can write, anyone can read)\n    match /posts/{postId} {\n      allow read: if true;\n      allow write: if request.auth != null;\n    }\n\n    // Validate file size (max 5MB for images)\n    match /users/{userId}/profile/{fileName} {\n      allow write: if request.auth != null\n                   && request.auth.uid == userId\n                   && request.resource.size < 5 * 1024 * 1024;  // 5MB\n    }\n\n    // Validate file type (only images)\n    match /users/{userId}/images/{fileName} {\n      allow write: if request.auth != null\n                   && request.auth.uid == userId\n                   && request.resource.contentType.matches('image/.*');\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### ‚úÖ DO:\n1. **Compress images before upload** (use image_picker maxWidth/quality)\n2. **Use unique filenames** (timestamp + random string)\n3. **Organize by user ID** (`users/{userId}/...`)\n4. **Validate file types and sizes** in security rules\n5. **Delete old files** when uploading new ones (avoid storage bloat)\n6. **Show upload progress** for better UX\n7. **Handle errors gracefully** (network issues, quota exceeded)\n8. **Use CDN URLs** (Firebase provides these automatically)\n\n### ‚ùå DON'T:\n1. **Don't upload full-resolution images** (compress first!)\n2. **Don't store sensitive data** in filenames\n3. **Don't allow public write access** (use authentication)\n4. **Don't forget to delete old files** (costs add up)\n5. **Don't upload without size limits** (prevent abuse)\n6. **Don't use HTTP URLs** (always HTTPS)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Pricing & Limits",
              "content": "\n### Free Tier (Spark Plan)\n\n- **Storage**: 5 GB\n- **Downloads**: 1 GB/day\n- **Uploads**: 1 GB/day\n- **Operations**: 50k/day\n\n**This is enough for**:\n- ~2,500 high-quality images (2MB each)\n- Small to medium apps\n- Learning and prototyping\n\n### Paid Tier (Blaze Plan)\n\n**Pay-as-you-go**:\n- Storage: $0.026 per GB/month\n- Downloads: $0.12 per GB\n- Uploads: $0.12 per GB\n\n**Example costs**:\n- 10 GB storage = ~$0.26/month\n- 10 GB downloads = ~$1.20/month\n- Most indie apps: $1-5/month\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhy should you delete old files when uploading new ones?\n\nA) It's required by Firebase\nB) To save storage costs and prevent quota issues\nC) To make uploads faster\nD) Firebase does this automatically\n\n### Question 2\nWhat's the correct way to organize user files?\n\nA) All in root folder\nB) By file type only\nC) By user ID (users/{userId}/...)\nD) By date only\n\n### Question 3\nWhat's the benefit of showing upload progress?\n\nA) It's required\nB) It provides user feedback, especially for large files\nC) It makes uploads faster\nD) It compresses files\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: To save storage costs and prevent quota issues\n\nOld files consume storage (which costs money) and count toward your quota. For example, if a user updates their profile picture 10 times, you'd be storing 10 images instead of 1. Always delete the old file before uploading a new one.\n\n### Answer 2: C\n**Correct**: By user ID (users/{userId}/...)\n\nOrganizing by user ID makes it easy to implement security rules (users can only access their own files), manage per-user quotas, and delete all user data when they delete their account. It's the industry standard pattern.\n\n### Answer 3: B\n**Correct**: It provides user feedback, especially for large files\n\nWithout progress indicators, users might think the app froze when uploading a 10MB video. Progress bars (0%, 25%, 50%, 100%) reassure users that the upload is working and show how long it will take.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've mastered Firebase Cloud Storage! In the next lesson, we'll learn about **Firebase Security Rules** to protect your data from unauthorized access.\n\n**Coming up in Lesson 5: Firebase Security Rules**\n- Firestore security rules\n- Storage security rules\n- Authentication-based access control\n- Testing security rules\n- Production-ready security\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Firebase Storage handles secure file storage in the cloud\n‚úÖ Organize files by user ID (users/{userId}/...)\n‚úÖ Always compress images before uploading\n‚úÖ Use uploadFile() with progress callbacks for UX\n‚úÖ Delete old files to save storage costs\n‚úÖ Implement security rules to restrict access\n‚úÖ Firebase provides CDN URLs automatically for fast downloads\n‚úÖ Monitor usage to avoid surprise bills\n\n**You can now build apps with cloud file storage like Instagram!** üì∏\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "8.5",
          "title": "Module 8, Lesson 5: Firebase Security Rules",
          "moduleId": "module-08",
          "order": 6,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll understand how to protect your Firebase data with security rules, prevent unauthorized access, and build production-ready secure applications.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Security rules are the MOST IMPORTANT part of Firebase.**\n\n- **Without security rules**, anyone can read/write your entire database\n- **Data breaches** happen when developers forget to set rules\n- **Firebase projects get hacked** every day due to weak security\n- **Security rules** are your firewall between users and data\n- **Production apps** MUST have proper security rules\n\n**Real example**: In 2020, millions of Firebase databases were exposed online because developers used test mode rules in production.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Bank Vault",
              "content": "\n### Without Security Rules = No Locks\n- üè¶ Bank with no locks on vault\n- üí∞ Anyone can walk in and take money\n- üìÅ Anyone can see everyone's account balances\n- ‚ùå **This is test mode!**\n\n### With Security Rules = Multi-Layer Security\n- üîê **Locks** (authentication required)\n- üëÆ **Guards** (authorization checks)\n- üé´ **ID verification** (user owns the data)\n- üìπ **Cameras** (audit logs)\n- ‚úÖ **This is production mode!**\n\n**Security rules are your bank vault's locks and guards.**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Types of Firebase Security Rules",
              "content": "\nFirebase has security rules for two services:\n\n1. **Firestore Security Rules** (database)\n2. **Storage Security Rules** (files)\n\nBoth use similar syntax but protect different resources.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Firestore Security Rules",
              "content": "\n### Basic Structure\n\n\n### The Four Operations\n\n\n",
              "code": "allow read;   // = get + list\nallow write;  // = create + update + delete\n\n// Or be specific:\nallow get;      // Read single document\nallow list;     // Read multiple documents (query)\nallow create;   // Create new document\nallow update;   // Update existing document\nallow delete;   // Delete document",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Common Security Patterns",
              "content": "\n### 1. Public Read, Authenticated Write\n\n**Use case**: Blog posts, public content\n\n\n### 2. User-Specific Data (Most Common!)\n\n**Use case**: User profiles, private data\n\n\n### 3. Role-Based Access\n\n**Use case**: Admin panels, moderation\n\n\n### 4. Validate Data Types\n\n**Use case**: Prevent invalid data\n\n\n### 5. Subcollections\n\n**Use case**: Comments on posts, nested data\n\n\n",
              "code": "match /posts/{postId} {\n  allow read: if true;\n  allow write: if request.auth != null;\n\n  match /comments/{commentId} {\n    allow read: if true;\n    allow create: if request.auth != null;\n    allow update, delete: if request.auth != null\n                           && request.auth.uid == resource.data.userId;\n  }\n}",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Storage Security Rules",
              "content": "\n### Basic Structure\n\n\n### Common Storage Patterns\n\n#### 1. User-Specific Files\n\n\n#### 2. File Size Limits\n\n\n#### 3. File Type Validation\n\n\n#### 4. Public Read, Authenticated Write\n\n\n",
              "code": "match /public/{allPaths=**} {\n  allow read: if true;\n  allow write: if request.auth != null;\n}",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Testing Security Rules",
              "content": "\n### 1. Firebase Console Rules Playground\n\n1. Go to Firebase Console ‚Üí Firestore ‚Üí Rules\n2. Click **\"Rules Playground\"** tab\n3. Simulate requests with different auth states\n\n**Example test**:\n\n### 2. Firebase Emulator Suite (Local Testing)\n\n\nThen in your Flutter app:\n\n\n",
              "code": "// main.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:firebase_storage/firebase_storage.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  await Firebase.initializeApp(\n    options: DefaultFirebaseOptions.currentPlatform,\n  );\n\n  // Use emulators in debug mode\n  if (kDebugMode) {\n    FirebaseFirestore.instance.useFirestoreEmulator('localhost', 8080);\n    FirebaseStorage.instance.useStorageEmulator('localhost', 9199);\n  }\n\n  runApp(const MyApp());\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Security Mistakes",
              "content": "\n### ‚ùå Mistake 1: Test Mode in Production\n\n\n**Problem**: Anyone can read/write your entire database!\n\n### ‚ùå Mistake 2: Relying on Client-Side Checks\n\n\n**Problem**: Hackers can modify your app code and bypass this check.\n\n**Solution**: Enforce in security rules!\n\n\n### ‚ùå Mistake 3: Not Validating Data\n\n\n**Problem**: Users can write invalid data (empty titles, negative numbers, etc.)\n\n**Solution**: Validate everything!\n\n\n",
              "code": "// ‚úÖ GOOD: Strict validation\nmatch /posts/{postId} {\n  allow write: if request.auth != null\n               && request.resource.data.title is string\n               && request.resource.data.title.size() > 0;\n}",
              "language": "javascript"
            },
            {
              "type": "EXPERIMENT",
              "title": "Security Rules Best Practices",
              "content": "\n### ‚úÖ DO:\n\n1. **Start restrictive, gradually allow** (deny by default)\n2. **Validate all data types and sizes**\n3. **Prevent users from changing critical fields** (userId, createdAt)\n4. **Use helper functions** for reusable logic\n5. **Test rules thoroughly** before deploying\n6. **Log and monitor** rule violations\n7. **Review rules regularly** as your app evolves\n\n### ‚ùå DON'T:\n\n1. **Don't use test mode** in production\n2. **Don't trust client-side validation**\n3. **Don't allow unlimited file sizes**\n4. **Don't forget subcollection rules**\n5. **Don't expose sensitive data** in public reads\n6. **Don't allow users to read all users** (privacy issue)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Production-Ready Rules Checklist",
              "content": "\nBefore launching your app, verify:\n\n- [ ] **No `if true` rules** except for truly public data\n- [ ] **All write operations require authentication**\n- [ ] **Users can only access their own data**\n- [ ] **Data validation on all fields**\n- [ ] **File size limits enforced**\n- [ ] **File type validation for uploads**\n- [ ] **Admin actions require admin role**\n- [ ] **Rules tested with emulator**\n- [ ] **No sensitive data in public reads**\n- [ ] **Subcollections have appropriate rules**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Monitoring Security",
              "content": "\n### View Rule Violations\n\n1. Go to Firebase Console ‚Üí Firestore ‚Üí Usage\n2. Check \"Denied requests\" graph\n3. High denial rate might indicate:\n   - **Attack attempt** (good - rules working!)\n   - **Bug in your app** (bad - fix your code)\n   - **Overly restrictive rules** (bad - adjust rules)\n\n### Set Up Alerts\n\n1. Firebase Console ‚Üí Project Settings ‚Üí Integrations\n2. Enable Cloud Functions alerts\n3. Monitor for:\n   - Unusual traffic spikes\n   - High error rates\n   - Storage quota nearing limit\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhy must security rules be enforced on the server, not the client?\n\nA) It's faster\nB) Hackers can modify client code to bypass client-side checks\nC) It's easier to code\nD) Firebase requires it\n\n### Question 2\nWhat's wrong with this rule: `allow write: if true;`?\n\nA) Syntax error\nB) It allows anyone (including unauthenticated users) to write data\nC) It's too slow\nD) Nothing, it's fine\n\n### Question 3\nWhy validate data types in security rules?\n\nA) To make queries faster\nB) To prevent invalid data that could break your app\nC) Firebase requires it\nD) To reduce storage costs\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: Hackers can modify client code to bypass client-side checks\n\nSince Flutter apps run on the user's device, hackers can decompile your app, modify the code, and bypass any client-side security checks. Security rules run on Firebase servers (which hackers can't access), making them the only reliable security layer.\n\n### Answer 2: B\n**Correct**: It allows anyone (including unauthenticated users) to write data\n\n`allow write: if true` means \"allow anyone to write data, no questions asked.\" This is extremely dangerous in production - anyone could delete your entire database, inject malicious data, or fill your storage quota.\n\n### Answer 3: B\n**Correct**: To prevent invalid data that could break your app\n\nWithout validation, users could write `{ title: 123, likes: \"hello\", createdAt: null }` which would break your app when it tries to display a string title or count numeric likes. Validation ensures data matches your expected schema.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've mastered Firebase security! In the next lesson, we'll explore **Real-Time Features** - building apps that update instantly across all devices.\n\n**Coming up in Lesson 6: Real-Time Features**\n- Real-time listeners\n- Presence detection (online/offline)\n- Live collaboration features\n- Chat app example\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Security rules are your firewall between users and data\n‚úÖ Always enforce security on the server (never trust client code)\n‚úÖ Start with deny-all, gradually allow specific operations\n‚úÖ Validate all data (types, sizes, required fields)\n‚úÖ Test rules thoroughly before production\n‚úÖ Users should only access their own data (userId matching)\n‚úÖ File uploads need size and type validation\n‚úÖ Monitor rule violations to detect attacks and bugs\n\n**Your app is now production-ready and secure!** üîê\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "8.6",
          "title": "Module 8, Lesson 6: Real-Time Features with Firebase",
          "moduleId": "module-08",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll know how to build real-time features like live chat, presence detection (online/offline status), and collaborative editing using Firebase's real-time capabilities.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Real-time features make apps feel alive.**\n\n- **WhatsApp**: Messages appear instantly\n- **Google Docs**: See others typing in real-time\n- **Instagram**: Live like counts and comments\n- **Slack**: Online/offline status, typing indicators\n- **75% of modern apps** have some real-time feature\n- **User engagement increases 300%** with real-time updates\n\nFirebase makes real-time features incredibly easy - no complex WebSocket servers needed!\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Walkie-Talkie",
              "content": "\n### Without Real-Time = Sending Letters\n- ‚úâÔ∏è Write message ‚Üí mail it ‚Üí wait days ‚Üí receive reply\n- üì¨ Check mailbox periodically for new letters\n- ‚è∞ Slow, delayed communication\n- ‚ùå Can't have natural conversations\n\n### With Real-Time = Walkie-Talkie\n- üì° Speak ‚Üí they hear instantly\n- üîä Their response comes immediately\n- üë• Know when others are online/offline\n- ‚úÖ Natural, flowing conversation\n\n**Firebase real-time updates are like having a walkie-talkie connection to your database!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Firebase Real-Time Capabilities",
              "content": "\n### 1. Firestore Snapshots (Real-Time Listeners)\n\n**When data changes**:\n1. Firebase detects the change\n2. Pushes update to all listening devices\n3. Flutter rebuilds UI automatically (with StreamBuilder)\n\n### 2. Firestore Realtime Database\n- Legacy real-time database (still used for specific cases)\n- Extremely low latency (< 100ms)\n- JSON tree structure\n- Good for: presence, typing indicators, live cursors\n\n### 3. Firebase Cloud Messaging (FCM)\n- Push notifications\n- Background messaging\n- Topic-based messaging\n\n",
              "code": "// Listen to document changes\nfirestore.collection('chats').doc('room1').snapshots()\n\n// Listen to collection changes\nfirestore.collection('messages').snapshots()",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Real-Time Chat App",
              "content": "\nLet's build a complete chat app with Firebase!\n\n### Chat Message Model\n\n\n### Chat Service\n\n\n### Chat Screen\n\n\n",
              "code": "// lib/screens/chat/chat_screen.dart\nimport 'package:flutter/material.dart';\nimport '../../services/chat_service.dart';\nimport '../../services/auth_service.dart';\nimport '../../models/chat_message.dart';\n\nclass ChatScreen extends StatefulWidget {\n  final String otherUserId;\n  final String otherUserName;\n\n  const ChatScreen({\n    super.key,\n    required this.otherUserId,\n    required this.otherUserName,\n  });\n\n  @override\n  State<ChatScreen> createState() => _ChatScreenState();\n}\n\nclass _ChatScreenState extends State<ChatScreen> {\n  final _chatService = ChatService();\n  final _authService = AuthService();\n  final _messageController = TextEditingController();\n  final _scrollController = ScrollController();\n\n  late String _chatRoomId;\n\n  @override\n  void initState() {\n    super.initState();\n    final currentUserId = _authService.currentUser!.uid;\n    _chatRoomId = _chatService.getChatRoomId(currentUserId, widget.otherUserId);\n  }\n\n  @override\n  void dispose() {\n    _messageController.dispose();\n    _scrollController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _sendMessage() async {\n    final text = _messageController.text.trim();\n    if (text.isEmpty) return;\n\n    final currentUser = _authService.currentUser!;\n\n    try {\n      await _chatService.sendMessage(\n        chatRoomId: _chatRoomId,\n        text: text,\n        senderId: currentUser.uid,\n        senderName: currentUser.displayName ?? 'User',\n      );\n\n      _messageController.clear();\n\n      // Scroll to bottom\n      if (_scrollController.hasClients) {\n        _scrollController.animateTo(\n          0,\n          duration: const Duration(milliseconds: 300),\n          curve: Curves.easeOut,\n        );\n      }\n    } catch (e) {\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Failed to send: $e')),\n        );\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.otherUserName),\n      ),\n      body: Column(\n        children: [\n          // Messages list\n          Expanded(\n            child: StreamBuilder<List<ChatMessage>>(\n              stream: _chatService.getMessagesStream(_chatRoomId),\n              builder: (context, snapshot) {\n                if (snapshot.connectionState == ConnectionState.waiting) {\n                  return const Center(child: CircularProgressIndicator());\n                }\n\n                if (snapshot.hasError) {\n                  return Center(child: Text('Error: ${snapshot.error}'));\n                }\n\n                if (!snapshot.hasData || snapshot.data!.isEmpty) {\n                  return Center(\n                    child: Column(\n                      mainAxisAlignment: MainAxisAlignment.center,\n                      children: [\n                        Icon(\n                          Icons.chat_bubble_outline,\n                          size: 64,\n                          color: Colors.grey.shade300,\n                        ),\n                        const SizedBox(height: 16),\n                        Text(\n                          'No messages yet',\n                          style: TextStyle(color: Colors.grey.shade600),\n                        ),\n                        const SizedBox(height: 8),\n                        Text(\n                          'Say hi to ${widget.otherUserName}!',\n                          style: TextStyle(color: Colors.grey.shade500),\n                        ),\n                      ],\n                    ),\n                  );\n                }\n\n                final messages = snapshot.data!;\n                final currentUserId = _authService.currentUser!.uid;\n\n                return ListView.builder(\n                  controller: _scrollController,\n                  reverse: true,  // Latest at bottom\n                  padding: const EdgeInsets.all(16),\n                  itemCount: messages.length,\n                  itemBuilder: (context, index) {\n                    final message = messages[index];\n                    final isMe = message.senderId == currentUserId;\n\n                    return _buildMessageBubble(message, isMe);\n                  },\n                );\n              },\n            ),\n          ),\n\n          // Message input\n          _buildMessageInput(),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildMessageBubble(ChatMessage message, bool isMe) {\n    return Align(\n      alignment: isMe ? Alignment.centerRight : Alignment.centerLeft,\n      child: Container(\n        margin: const EdgeInsets.only(bottom: 12),\n        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),\n        constraints: BoxConstraints(\n          maxWidth: MediaQuery.of(context).size.width * 0.7,\n        ),\n        decoration: BoxDecoration(\n          color: isMe ? Theme.of(context).primaryColor : Colors.grey.shade200,\n          borderRadius: BorderRadius.only(\n            topLeft: const Radius.circular(16),\n            topRight: const Radius.circular(16),\n            bottomLeft: Radius.circular(isMe ? 16 : 4),\n            bottomRight: Radius.circular(isMe ? 4 : 16),\n          ),\n        ),\n        child: Column(\n          crossAxisAlignment:\n              isMe ? CrossAxisAlignment.end : CrossAxisAlignment.start,\n          children: [\n            Text(\n              message.text,\n              style: TextStyle(\n                color: isMe ? Colors.white : Colors.black87,\n                fontSize: 16,\n              ),\n            ),\n            const SizedBox(height: 4),\n            Text(\n              _formatTime(message.timestamp),\n              style: TextStyle(\n                color: isMe ? Colors.white70 : Colors.grey.shade600,\n                fontSize: 12,\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildMessageInput() {\n    return Container(\n      padding: const EdgeInsets.all(8.0),\n      decoration: BoxDecoration(\n        color: Colors.grey.shade100,\n        border: Border(top: BorderSide(color: Colors.grey.shade300)),\n      ),\n      child: Row(\n        children: [\n          Expanded(\n            child: TextField(\n              controller: _messageController,\n              decoration: InputDecoration(\n                hintText: 'Type a message...',\n                border: OutlineInputBorder(\n                  borderRadius: BorderRadius.circular(24),\n                  borderSide: BorderSide.none,\n                ),\n                filled: true,\n                fillColor: Colors.white,\n                contentPadding: const EdgeInsets.symmetric(\n                  horizontal: 20,\n                  vertical: 10,\n                ),\n              ),\n              textCapitalization: TextCapitalization.sentences,\n              onSubmitted: (_) => _sendMessage(),\n            ),\n          ),\n          const SizedBox(width: 8),\n          CircleAvatar(\n            backgroundColor: Theme.of(context).primaryColor,\n            child: IconButton(\n              icon: const Icon(Icons.send, color: Colors.white),\n              onPressed: _sendMessage,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n\n  String _formatTime(DateTime dateTime) {\n    final now = DateTime.now();\n    final difference = now.difference(dateTime);\n\n    if (difference.inDays > 0) {\n      return '${dateTime.day}/${dateTime.month}/${dateTime.year}';\n    } else if (difference.inHours > 0) {\n      return '${difference.inHours}h ago';\n    } else if (difference.inMinutes > 0) {\n      return '${difference.inMinutes}m ago';\n    } else {\n      return 'Just now';\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Online/Offline Presence",
              "content": "\nTrack when users are online or offline!\n\n### Presence Service\n\n\n### Online Indicator Widget\n\n\n",
              "code": "// lib/widgets/online_indicator.dart\nimport 'package:flutter/material.dart';\nimport '../services/presence_service.dart';\n\nclass OnlineIndicator extends StatelessWidget {\n  final String userId;\n  final double size;\n\n  const OnlineIndicator({\n    super.key,\n    required this.userId,\n    this.size = 12,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final presenceService = PresenceService();\n\n    return StreamBuilder<bool>(\n      stream: presenceService.getUserOnlineStatus(userId),\n      builder: (context, snapshot) {\n        final isOnline = snapshot.data ?? false;\n\n        return Container(\n          width: size,\n          height: size,\n          decoration: BoxDecoration(\n            color: isOnline ? Colors.green : Colors.grey,\n            shape: BoxShape.circle,\n            border: Border.all(color: Colors.white, width: 2),\n          ),\n        );\n      },\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 3: Typing Indicator",
              "content": "\nShow when someone is typing!\n\n### Typing Service\n\n\n### Add to Chat Screen\n\n\n",
              "code": "// In ChatScreen, add typing indicator\nWidget _buildTypingIndicator() {\n  return StreamBuilder<bool>(\n    stream: _typingService.getTypingStatus(\n      chatRoomId: _chatRoomId,\n      otherUserId: widget.otherUserId,\n    ),\n    builder: (context, snapshot) {\n      if (snapshot.data == true) {\n        return Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            children: [\n              const SizedBox(width: 16),\n              ...List.generate(\n                3,\n                (index) => Padding(\n                  padding: const EdgeInsets.symmetric(horizontal: 2),\n                  child: _AnimatedDot(delay: index * 200),\n                ),\n              ),\n              const SizedBox(width: 8),\n              Text(\n                '${widget.otherUserName} is typing...',\n                style: TextStyle(\n                  color: Colors.grey.shade600,\n                  fontStyle: FontStyle.italic,\n                ),\n              ),\n            ],\n          ),\n        );\n      }\n      return const SizedBox.shrink();\n    },\n  );\n}\n\n// Animated dot widget\nclass _AnimatedDot extends StatefulWidget {\n  final int delay;\n\n  const _AnimatedDot({required this.delay});\n\n  @override\n  State<_AnimatedDot> createState() => _AnimatedDotState();\n}\n\nclass _AnimatedDotState extends State<_AnimatedDot>\n    with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      vsync: this,\n      duration: const Duration(milliseconds: 600),\n    )..repeat();\n\n    Future.delayed(Duration(milliseconds: widget.delay), () {\n      if (mounted) _controller.forward();\n    });\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return FadeTransition(\n      opacity: _controller,\n      child: Container(\n        width: 8,\n        height: 8,\n        decoration: BoxDecoration(\n          color: Colors.grey.shade400,\n          shape: BoxShape.circle,\n        ),\n      ),\n    );\n  }\n}\n\n// Update TextField to track typing\nTextField(\n  controller: _messageController,\n  onChanged: (text) {\n    _typingService.setTyping(\n      chatRoomId: _chatRoomId,\n      userId: _authService.currentUser!.uid,\n      isTyping: text.isNotEmpty,\n    );\n  },\n  // ... rest of TextField\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 4: Live Data Updates (Like Counter)",
              "content": "\nBuild a live like counter that updates in real-time!\n\n\n",
              "code": "// Like button with real-time count\nclass LiveLikeButton extends StatelessWidget {\n  final String postId;\n\n  const LiveLikeButton({super.key, required this.postId});\n\n  @override\n  Widget build(BuildContext context) {\n    final authService = AuthService();\n    final currentUserId = authService.currentUser?.uid;\n\n    return StreamBuilder<DocumentSnapshot>(\n      stream: FirebaseFirestore.instance\n          .collection('posts')\n          .doc(postId)\n          .snapshots(),\n      builder: (context, snapshot) {\n        if (!snapshot.hasData) {\n          return const IconButton(\n            icon: Icon(Icons.favorite_border),\n            onPressed: null,\n          );\n        }\n\n        final data = snapshot.data!.data() as Map<String, dynamic>?;\n        final likes = data?['likes'] as List? ?? [];\n        final hasLiked = currentUserId != null && likes.contains(currentUserId);\n        final likeCount = likes.length;\n\n        return Row(\n          children: [\n            IconButton(\n              icon: Icon(\n                hasLiked ? Icons.favorite : Icons.favorite_border,\n                color: hasLiked ? Colors.red : null,\n              ),\n              onPressed: () async {\n                if (currentUserId == null) return;\n\n                if (hasLiked) {\n                  await FirebaseFirestore.instance\n                      .collection('posts')\n                      .doc(postId)\n                      .update({\n                    'likes': FieldValue.arrayRemove([currentUserId]),\n                  });\n                } else {\n                  await FirebaseFirestore.instance\n                      .collection('posts')\n                      .doc(postId)\n                      .update({\n                    'likes': FieldValue.arrayUnion([currentUserId]),\n                  });\n                }\n              },\n            ),\n            Text('$likeCount'),\n          ],\n        );\n      },\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices for Real-Time Features",
              "content": "\n### ‚úÖ DO:\n1. **Use StreamBuilder** for automatic UI updates\n2. **Dispose streams** properly to prevent memory leaks\n3. **Limit real-time listeners** (don't listen to huge collections)\n4. **Debounce rapid updates** (typing indicators)\n5. **Show loading states** while connecting\n6. **Handle offline mode** gracefully\n7. **Set up presence** on app start, clear on exit\n\n### ‚ùå DON'T:\n1. **Don't listen to entire collections** (use queries with limits)\n2. **Don't forget to cancel listeners** (memory leaks!)\n3. **Don't update on every keystroke** (use debounce)\n4. **Don't rely solely on real-time** (handle offline)\n5. **Don't leave presence \"online\" forever** (set onDisconnect)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhat's the main advantage of using StreamBuilder with Firestore snapshots()?\n\nA) It's faster\nB) It automatically rebuilds the UI when data changes\nC) It uses less memory\nD) It's required by Firebase\n\n### Question 2\nWhy use onDisconnect() for presence detection?\n\nA) It's faster\nB) It automatically sets user offline when they lose connection\nC) Firebase requires it\nD) It saves battery\n\n### Question 3\nWhat should you do to prevent memory leaks with real-time listeners?\n\nA) Use more listeners\nB) Restart the app periodically\nC) Properly dispose streams and controllers\nD) Use HTTP instead\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: It automatically rebuilds the UI when data changes\n\nStreamBuilder listens to Firestore snapshots (a Stream) and automatically rebuilds its child widget whenever new data arrives, providing seamless real-time updates without manual setState() calls.\n\n### Answer 2: B\n**Correct**: It automatically sets user offline when they lose connection\n\nonDisconnect() is a Firebase Realtime Database feature that executes specified operations when a client disconnects (app closes, network lost, etc.), ensuring accurate presence status even if the app crashes.\n\n### Answer 3: C\n**Correct**: Properly dispose streams and controllers\n\nAlways cancel stream subscriptions and dispose controllers in dispose() method to prevent memory leaks. Unmanaged streams continue consuming resources even after widgets are destroyed.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've mastered real-time features! In the next lesson, we'll add **Push Notifications and Analytics** to make your app even more engaging.\n\n**Coming up in Lesson 7: Push Notifications & Analytics**\n- Firebase Cloud Messaging (FCM)\n- Push notifications\n- Analytics events\n- User engagement tracking\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Firebase snapshots() provide real-time data streams\n‚úÖ StreamBuilder automatically rebuilds UI when data changes\n‚úÖ Presence detection shows online/offline status\n‚úÖ Use Realtime Database for ultra-low latency features\n‚úÖ Always dispose streams to prevent memory leaks\n‚úÖ Typing indicators enhance chat UX\n‚úÖ Real-time like counters create engaging experiences\n‚úÖ onDisconnect() ensures accurate presence even after crashes\n\n**You can now build real-time apps like WhatsApp!** üí¨\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "8.7",
          "title": "Module 8, Lesson 7: Push Notifications & Analytics",
          "moduleId": "module-08",
          "order": 8,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll know how to send push notifications to users and track app usage with Firebase Cloud Messaging (FCM) and Firebase Analytics.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Push notifications and analytics are essential for app success.**\n\n### Push Notifications:\n- **Increase engagement by 88%** (users return more often)\n- **Send time-sensitive updates** (messages, orders, breaking news)\n- **Re-engage inactive users** (bring them back to your app)\n- **95% of successful apps** use push notifications\n\n### Analytics:\n- **Understand user behavior** (what features they use most)\n- **Track conversion rates** (signup, purchases)\n- **Identify problems** (where users get stuck)\n- **Data-driven decisions** (build what users actually want)\n\n**Without notifications and analytics, you're flying blind!**\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Doorbell & Security Camera",
              "content": "\n### Push Notifications = Doorbell\n- üîî **Alert you immediately** when something important happens\n- üì¨ **Delivery notifications**: \"Package arrived!\"\n- üëã **Visitor alerts**: \"Someone's at your door!\"\n- ‚è∞ **Reminders**: \"Don't forget your appointment!\"\n\n### Analytics = Security Camera\n- üìπ **Record what happens** in your app\n- üëÅÔ∏è **See user patterns** (when they visit, what they do)\n- üìä **Analyze footage** to improve security\n- üîç **Find issues** before they become problems\n\n**Together, they keep you connected to users and understand their behavior!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Firebase Cloud Messaging (FCM)",
              "content": "\n### How Push Notifications Work\n\n\n",
              "code": "1. App requests permission\n   ‚Üì\n2. FCM generates unique token for device\n   ‚Üì\n3. App sends token to your server (or Firestore)\n   ‚Üì\n4. Server sends notification to FCM\n   ‚Üì\n5. FCM delivers to device\n   ‚Üì\n6. Notification appears on user's screen",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Setup FCM in Flutter",
              "content": "\n### 1. Add Package\n\n\nRun:\n\n### 2. Android Configuration\n\nEdit `android/app/src/main/AndroidManifest.xml`:\n\n\n### 3. iOS Configuration\n\nEdit `ios/Runner/Info.plist`:\n\n\nRequest permission in iOS (done programmatically).\n\n",
              "code": "<dict>\n    <!-- Add this -->\n    <key>FirebaseAppDelegateProxyEnabled</key>\n    <false/>\n</dict>",
              "language": "xml"
            },
            {
              "type": "THEORY",
              "title": "Sending Notifications",
              "content": "\n### Method 1: Firebase Console (Manual)\n\n1. Go to Firebase Console ‚Üí Cloud Messaging\n2. Click **\"Send your first message\"**\n3. Enter:\n   - **Notification title**: \"New Message!\"\n   - **Notification text**: \"You have a new message from John\"\n4. Click **\"Send test message\"**\n5. Paste your FCM token\n6. Click **\"Test\"**\n\n### Method 2: Send to Topics (Best for Broadcasts)\n\n\nThen send via Firebase Console to \"news\" topic.\n\n### Method 3: Send via Cloud Functions (Production)\n\nCreate a Cloud Function to send notifications:\n\n\n",
              "code": "// Firebase Cloud Function (JavaScript/TypeScript)\nconst functions = require('firebase-functions');\nconst admin = require('firebase-admin');\nadmin.initializeApp();\n\nexports.sendNotificationOnNewMessage = functions.firestore\n  .document('chatRooms/{chatRoomId}/messages/{messageId}')\n  .onCreate(async (snapshot, context) => {\n    const message = snapshot.data();\n\n    // Get recipient's FCM token\n    const recipientDoc = await admin.firestore()\n      .collection('users')\n      .doc(message.recipientId)\n      .get();\n\n    const fcmTokens = recipientDoc.data().fcmTokens || [];\n\n    if (fcmTokens.length === 0) return;\n\n    // Send notification\n    const payload = {\n      notification: {\n        title: 'New Message',\n        body: `${message.senderName}: ${message.text}`,\n      },\n      data: {\n        chatRoomId: context.params.chatRoomId,\n        messageId: context.params.messageId,\n      },\n    };\n\n    await admin.messaging().sendToDevice(fcmTokens, payload);\n  });",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Firebase Analytics",
              "content": "\n### Setup Analytics\n\nFirebase Analytics is included with `firebase_core` - no extra package needed!\n\n### Track Events\n\n\n### Track Navigation\n\n\n### Usage Example\n\n\n",
              "code": "// In your screens\nfinal analytics = AnalyticsService();\n\n// Track screen view\n@override\nvoid initState() {\n  super.initState();\n  analytics.logScreenView('Home Screen');\n}\n\n// Track button clicks\nElevatedButton(\n  onPressed: () {\n    analytics.logButtonClick('create_post_button');\n    // ... button action\n  },\n  child: const Text('Create Post'),\n)\n\n// Track signup\nawait authService.register(...);\nanalytics.logSignUp('email');\n\n// Track login\nawait authService.login(...);\nanalytics.logLogin('google');",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "View Analytics Data",
              "content": "\n### Firebase Console\n\n1. Go to Firebase Console ‚Üí Analytics\n2. View dashboards:\n   - **Users**: Active users, new users\n   - **Events**: All tracked events\n   - **Conversions**: Signup, purchases\n   - **Engagement**: Session duration, screens per session\n\n### Custom Reports\n\n1. Analytics ‚Üí Events\n2. Click \"Create custom report\"\n3. Select metrics and dimensions\n4. Save for recurring analysis\n\n"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### Notifications ‚úÖ DO:\n1. **Request permission at the right time** (after user sees value)\n2. **Personalize notifications** (use user's name, relevant content)\n3. **Don't spam** (max 2-3 per day)\n4. **Provide value** (useful info, not just \"Open the app!\")\n5. **Allow unsubscribe** (topic-based subscriptions)\n6. **Test on real devices** (not just emulator)\n7. **Handle tap actions** (navigate to relevant screen)\n\n### Notifications ‚ùå DON'T:\n1. **Don't request permission immediately** on app launch\n2. **Don't send at bad times** (2am notifications = angry users)\n3. **Don't send generic messages** (\"Check out our app!\")\n4. **Don't ignore user preferences** (respect opt-outs)\n5. **Don't forget to test** on iOS and Android\n\n### Analytics ‚úÖ DO:\n1. **Track key user actions** (signup, purchase, share)\n2. **Set user properties** (subscription type, preferences)\n3. **Create conversion funnels** (how many complete signup?)\n4. **Review weekly** (make data-driven decisions)\n5. **Respect privacy** (don't track sensitive data)\n\n### Analytics ‚ùå DON'T:\n1. **Don't track PII** (passwords, credit cards, SSN)\n2. **Don't track everything** (focus on meaningful events)\n3. **Don't ignore the data** (collect but never analyze = waste)\n4. **Don't violate privacy laws** (GDPR, CCPA compliance)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhy save FCM tokens to Firestore?\n\nA) Firebase requires it\nB) So you can send targeted notifications to specific users\nC) To make the app faster\nD) It's not necessary\n\n### Question 2\nWhen should you request notification permission?\n\nA) Immediately on app launch\nB) After users see the value of notifications\nC) Never\nD) After they create an account\n\n### Question 3\nWhat should you avoid tracking with Firebase Analytics?\n\nA) Button clicks\nB) Screen views\nC) Passwords and credit card numbers\nD) User signups\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: So you can send targeted notifications to specific users\n\nFCM tokens are unique per device. By saving them to Firestore with the user's ID, you can send notifications to specific users (e.g., \"John sent you a message\"). Without storing tokens, you can only broadcast to all users or topics.\n\n### Answer 2: B\n**Correct**: After users see the value of notifications\n\nIf you ask for permission immediately, users don't understand why they need it and often decline. Show value first (e.g., let them start a chat), then request permission with context (\"Get notified when you receive messages\").\n\n### Answer 3: C\n**Correct**: Passwords and credit card numbers\n\nNEVER track personally identifiable information (PII) or sensitive data like passwords, credit cards, SSN, health information. This violates privacy laws (GDPR, CCPA) and puts users at risk. Track user behavior, not sensitive data.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've learned push notifications and analytics! In the final lesson, we'll build a **Complete Firebase Mini-Project** that combines everything from Module 8.\n\n**Coming up in Lesson 8: Mini-Project - Complete Firebase App**\n- Full-stack social app\n- Authentication\n- Real-time chat\n- File uploads\n- Push notifications\n- Production-ready code\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Firebase Cloud Messaging (FCM) sends push notifications to users\n‚úÖ Request permission after users see notification value\n‚úÖ Save FCM tokens to Firestore for targeted notifications\n‚úÖ Use topics for broadcast notifications (news, promotions)\n‚úÖ firebase_analytics tracks user behavior automatically\n‚úÖ Track meaningful events (signup, purchase, key actions)\n‚úÖ Never track sensitive data (passwords, credit cards)\n‚úÖ Review analytics weekly to make data-driven decisions\n‚úÖ Respect user privacy and comply with GDPR/CCPA\n\n**You can now build engaging apps with notifications and understand user behavior!** üìä\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "8.8",
          "title": "Module 8, Lesson 8: Mini-Project - Complete Firebase Social App",
          "moduleId": "module-08",
          "order": 9,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\n**Welcome to your Module 8 capstone project!** üéâ\n\nIn this mini-project, you'll build **\"FireSocial\"** - a complete social media app that combines **EVERY Firebase concept** from Module 8:\n\n‚úÖ Firebase Authentication (email & Google)\n‚úÖ Cloud Firestore (posts, likes, comments)\n‚úÖ Cloud Storage (profile pictures, post images)\n‚úÖ Security Rules (production-ready)\n‚úÖ Real-time features (live likes, typing indicators)\n‚úÖ Push notifications (new likes, comments)\n‚úÖ Analytics (track user behavior)\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You'll Build",
              "content": "\n### FireSocial Features\n\n1. **Authentication**\n   - Email/password & Google Sign-In\n   - Profile creation with photo upload\n   - Secure session management\n\n2. **User Profiles**\n   - Profile picture upload\n   - Bio and user info\n   - Post count\n   - Edit profile\n\n3. **Posts Feed**\n   - Create posts with images\n   - Real-time feed updates\n   - Like posts (with real-time counter)\n   - Comment on posts\n   - Delete own posts\n\n4. **Real-Time Chat**\n   - Direct messages\n   - Typing indicators\n   - Online/offline status\n   - Message notifications\n\n5. **Push Notifications**\n   - New likes on your posts\n   - New comments\n   - New messages\n   - Topic-based (announcements)\n\n6. **Analytics**\n   - Track screen views\n   - Log user actions\n   - Conversion tracking\n\n"
            },
            {
              "type": "THEORY",
              "title": "Step 1: Setup & Dependencies",
              "content": "\n### pubspec.yaml\n\n\nRun:\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 2: Complete Data Models",
              "content": "\n### User Model\n\n\n### Post Model\n\n\n",
              "code": "// lib/models/post_model.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\n\nclass Post {\n  final String id;\n  final String userId;\n  final String userName;\n  final String? userPhotoURL;\n  final String caption;\n  final String imageURL;\n  final List<String> likes;\n  final int commentCount;\n  final DateTime createdAt;\n\n  Post({\n    required this.id,\n    required this.userId,\n    required this.userName,\n    this.userPhotoURL,\n    required this.caption,\n    required this.imageURL,\n    this.likes = const [],\n    this.commentCount = 0,\n    DateTime? createdAt,\n  }) : createdAt = createdAt ?? DateTime.now();\n\n  factory Post.fromFirestore(DocumentSnapshot doc) {\n    final data = doc.data() as Map<String, dynamic>;\n    return Post(\n      id: doc.id,\n      userId: data['userId'] ?? '',\n      userName: data['userName'] ?? 'Unknown',\n      userPhotoURL: data['userPhotoURL'],\n      caption: data['caption'] ?? '',\n      imageURL: data['imageURL'] ?? '',\n      likes: List<String>.from(data['likes'] ?? []),\n      commentCount: data['commentCount'] ?? 0,\n      createdAt: (data['createdAt'] as Timestamp).toDate(),\n    );\n  }\n\n  Map<String, dynamic> toMap() {\n    return {\n      'userId': userId,\n      'userName': userName,\n      'userPhotoURL': userPhotoURL,\n      'caption': caption,\n      'imageURL': imageURL,\n      'likes': likes,\n      'commentCount': commentCount,\n      'createdAt': Timestamp.fromDate(createdAt),\n    };\n  }\n\n  bool isLikedBy(String userId) => likes.contains(userId);\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 8: Security Rules (CRITICAL!)",
              "content": "\n### Firestore Security Rules\n\n\n### Storage Security Rules\n\n\n",
              "code": "rules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    function isSignedIn() {\n      return request.auth != null;\n    }\n\n    function isOwner(userId) {\n      return isSignedIn() && request.auth.uid == userId;\n    }\n\n    // User profile pictures\n    match /users/{userId}/profile/{fileName} {\n      allow read: if true;\n      allow write: if isOwner(userId)\n                   && request.resource.contentType.matches('image/.*')\n                   && request.resource.size < 5 * 1024 * 1024;  // 5MB max\n    }\n\n    // Post images\n    match /posts/{userId}/{fileName} {\n      allow read: if true;\n      allow write: if isOwner(userId)\n                   && request.resource.contentType.matches('image/.*')\n                   && request.resource.size < 10 * 1024 * 1024;  // 10MB max\n    }\n  }\n}",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Testing Your App",
              "content": "\n### 1. Authentication\n- ‚úÖ Register with email/password\n- ‚úÖ Login with Google\n- ‚úÖ Logout\n\n### 2. Posts\n- ‚úÖ Create post with image\n- ‚úÖ View feed (real-time updates)\n- ‚úÖ Like/unlike posts\n- ‚úÖ Delete own posts\n\n### 3. Profile\n- ‚úÖ Upload profile picture\n- ‚úÖ Edit bio\n- ‚úÖ View post count\n\n### 4. Real-Time\n- ‚úÖ Open app on 2 devices\n- ‚úÖ Like post on device 1\n- ‚úÖ Watch count update on device 2!\n\n### 5. Security\n- ‚úÖ Try accessing other user's data (should fail)\n- ‚úÖ Try uploading oversized file (should fail)\n- ‚úÖ Check Firebase Console ‚Üí Security Rules\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You've Accomplished",
              "content": "\nCongratulations! You've built a complete social media app with:\n\n‚úÖ **Authentication**: Secure email & Google login\n‚úÖ **Database**: Real-time Firestore with complex queries\n‚úÖ **Storage**: File uploads with validation\n‚úÖ **Security**: Production-ready security rules\n‚úÖ **Real-Time**: Live updates across all devices\n‚úÖ **Notifications**: Push notifications (if implemented)\n‚úÖ **Analytics**: User behavior tracking\n\n**This is a production-ready foundation!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps & Enhancements",
              "content": "\nWant to take this further? Try adding:\n\n1. **Comments System**: Full comment threads with replies\n2. **User Following**: Follow/unfollow users, follower counts\n3. **Feed Algorithm**: Show posts from followed users only\n4. **Stories**: Instagram-style 24-hour stories\n5. **Hashtags**: Search posts by hashtags\n6. **Mentions**: Tag users in posts/comments\n7. **Direct Messages**: Real-time one-on-one chat\n8. **Push Notifications**: Notify on likes, comments, follows\n9. **Video Posts**: Upload and play videos\n10. **Search**: Search users and posts\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhy use StreamBuilder for the posts feed?\n\nA) It's faster\nB) It provides automatic real-time updates when posts change\nC) Firebase requires it\nD) It uses less memory\n\n### Question 2\nWhy increment postCount in Firestore when creating a post?\n\nA) Firebase requires it\nB) To avoid querying all posts to count them (performance)\nC) It's not necessary\nD) To make the app faster\n\n### Question 3\nWhat's the most important part of a production Firebase app?\n\nA) Beautiful UI\nB) Security rules\nC) Analytics\nD) Notifications\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: It provides automatic real-time updates when posts change\n\nStreamBuilder listens to Firestore's `snapshots()` stream and automatically rebuilds the UI whenever data changes. When someone creates/deletes a post, all users see the update instantly without manual refresh.\n\n### Answer 2: B\n**Correct**: To avoid querying all posts to count them (performance)\n\nStoring an aggregated count prevents expensive queries. Without it, you'd need to fetch all user posts just to count them (slow and costly). Firestore charges per document read, so fewer reads = lower costs.\n\n### Answer 3: B\n**Correct**: Security rules\n\nWithout proper security rules, your database is wide open - anyone can read/write/delete anything. Beautiful UI doesn't matter if hackers steal all user data. Security rules are the foundation of production apps.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Congratulations! üéâ",
              "content": "\n**You've completed Module 8: Backend Integration!**\n\nYou now have the skills to build production-ready apps with:\n- Secure authentication\n- Real-time cloud databases\n- File storage\n- Push notifications\n- User analytics\n- Complete backend infrastructure\n\n**You're ready for Module 9: Advanced Features!** Where you'll learn animations, local storage, camera integration, and more.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Firebase provides a complete backend solution (auth, database, storage, notifications)\n‚úÖ StreamBuilder enables real-time updates across all devices\n‚úÖ Security rules are CRITICAL - never deploy without them\n‚úÖ Store aggregated data (counts) to avoid expensive queries\n‚úÖ Use caching (CachedNetworkImage) for better performance\n‚úÖ Test on multiple devices to verify real-time sync\n‚úÖ Always dispose streams and controllers to prevent memory leaks\n\n**Module 8 Complete - You're now a full-stack Flutter developer!** üöÄ\n\n"
            }
          ],
          "challenges": []
        }
      ]
    },
    {
      "id": "module-09",
      "title": "Module 9: Flutter Development",
      "description": "Learn Flutter development - Module 9",
      "difficulty": "intermediate",
      "estimatedHours": 8,
      "lessons": [
        {
          "id": "9.1",
          "title": "Lesson 1: Introduction to Animations",
          "moduleId": "module-09",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Understanding animations and their importance\n- Implicit vs explicit animations\n- AnimatedContainer and AnimatedOpacity\n- Hero animations for screen transitions\n- Custom animations with AnimationController\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: Why Animations Matter",
              "content": "\n### Real-World Analogy\nThink of animations like the smooth movements in a well-choreographed dance. Without animations, your app would be like a slideshow of still photos. With animations, it becomes a fluid movie where each transition tells a story and guides the user's attention.\n\nJust like how a door **gradually swings open** (not teleporting from closed to open), good UI animations help users understand what's happening and where things are going.\n\n### Why This Matters\nAnimations are not just \"eye candy\" - they serve important purposes:\n\n1. **Feedback**: Show that a button was pressed\n2. **Guidance**: Direct attention to important elements\n3. **Relationships**: Show how UI elements connect\n4. **Continuity**: Smooth transitions prevent jarring experiences\n5. **Polish**: Professional apps feel smooth and responsive\n\nAccording to Material Design guidelines, animations should be:\n- **Fast**: 200-300ms for most transitions\n- **Natural**: Follow physics (easing curves, not linear)\n- **Purposeful**: Every animation should have a reason\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up",
              "content": "\nNo external packages needed for basic animations! Flutter has powerful built-in animation widgets.\n\nFor advanced animations (optional):\n\n",
              "code": "dependencies:\n  flutter_animate: ^4.5.0  # Easy-to-use animation effects",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "The Animation Building Blocks",
              "content": "\n### 1. Implicit Animations (Easy Mode)\n\nThese are \"smart\" widgets that automatically animate when their properties change.\n\n**Example: AnimatedContainer**\n\n\n**How It Works:**\n- Change the properties in `setState()`\n- AnimatedContainer detects the changes\n- Automatically animates from old ‚Üí new values\n- Magic! ‚ú®\n\n### 2. More Implicit Animation Widgets\n\n\n### 3. Hero Animations (Shared Element Transitions)\n\nHero animations create smooth transitions when navigating between screens.\n\n**Screen 1 (List of Items):**\n\n**Screen 2 (Detail):**\n\n**How Hero Works:**\n1. Both screens have a `Hero` widget with the **same tag**\n2. When navigating, Flutter finds both Hero widgets\n3. Automatically animates the transition between them\n4. The image \"flies\" from list to detail screen!\n\n",
              "code": "class ProductDetailScreen extends StatelessWidget {\n  final int productId;\n\n  ProductDetailScreen({required this.productId});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Product Details')),\n      body: Column(\n        children: [\n          // Same Hero tag = automatic animation!\n          Hero(\n            tag: 'product-$productId',\n            child: Image.network(\n              'https://picsum.photos/seed/$productId/400',\n              height: 300,\n              width: double.infinity,\n              fit: BoxFit.cover,\n            ),\n          ),\n          Padding(\n            padding: EdgeInsets.all(16),\n            child: Text(\n              'Product $productId Details',\n              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Explicit Animations (Full Control)",
              "content": "\nFor complex custom animations, use `AnimationController`.\n\n### Complete Example: Pulsing Heart\n\n\n**Key Concepts:**\n- **AnimationController**: Controls the animation (start, stop, reverse)\n- **Tween**: Defines start and end values\n- **CurvedAnimation**: Applies easing curves\n- **AnimatedBuilder**: Rebuilds when animation changes\n- **SingleTickerProviderStateMixin**: Optimizes animations\n\n",
              "code": "class PulsingHeartScreen extends StatefulWidget {\n  @override\n  State<PulsingHeartScreen> createState() => _PulsingHeartScreenState();\n}\n\nclass _PulsingHeartScreenState extends State<PulsingHeartScreen>\n    with SingleTickerProviderStateMixin {  // Required for animations\n\n  late AnimationController _controller;\n  late Animation<double> _scaleAnimation;\n  late Animation<Color?> _colorAnimation;\n\n  @override\n  void initState() {\n    super.initState();\n\n    // 1. Create the controller (the \"conductor\")\n    _controller = AnimationController(\n      duration: Duration(milliseconds: 800),\n      vsync: this,  // Sync with screen refresh\n    );\n\n    // 2. Create animations (the \"dancers\")\n    _scaleAnimation = Tween<double>(\n      begin: 1.0,\n      end: 1.3,\n    ).animate(CurvedAnimation(\n      parent: _controller,\n      curve: Curves.easeInOut,\n    ));\n\n    _colorAnimation = ColorTween(\n      begin: Colors.red,\n      end: Colors.pink,\n    ).animate(_controller);\n\n    // 3. Make it loop\n    _controller.repeat(reverse: true);\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();  // Always clean up!\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Pulsing Heart')),\n      body: Center(\n        child: AnimatedBuilder(\n          animation: _controller,\n          builder: (context, child) {\n            return Transform.scale(\n              scale: _scaleAnimation.value,\n              child: Icon(\n                Icons.favorite,\n                size: 100,\n                color: _colorAnimation.value,\n              ),\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          if (_controller.isAnimating) {\n            _controller.stop();\n          } else {\n            _controller.repeat(reverse: true);\n          }\n          setState(() {});\n        },\n        child: Icon(_controller.isAnimating ? Icons.pause : Icons.play_arrow),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Animation Curves",
              "content": "\nCurves make animations feel natural (not robotic).\n\n\n**Example Usage:**\n\n",
              "code": "AnimatedContainer(\n  duration: Duration(milliseconds: 300),\n  curve: Curves.bounceOut,  // Add personality!\n  // ... properties\n)",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Animated Login Screen",
              "content": "\n\n**Advanced Techniques Used:**\n- **Interval**: Stagger animations (logo first, then form)\n- **ScaleTransition**: Built-in widget for scaling\n- **SlideTransition**: Built-in widget for sliding\n- **FadeTransition**: Built-in widget for fading\n\n",
              "code": "import 'package:flutter/material.dart';\n\nclass AnimatedLoginScreen extends StatefulWidget {\n  @override\n  State<AnimatedLoginScreen> createState() => _AnimatedLoginScreenState();\n}\n\nclass _AnimatedLoginScreenState extends State<AnimatedLoginScreen>\n    with SingleTickerProviderStateMixin {\n\n  late AnimationController _controller;\n  late Animation<double> _logoScale;\n  late Animation<Offset> _formSlide;\n  late Animation<double> _formFade;\n\n  @override\n  void initState() {\n    super.initState();\n\n    _controller = AnimationController(\n      duration: Duration(milliseconds: 1500),\n      vsync: this,\n    );\n\n    // Logo scales up\n    _logoScale = Tween<double>(begin: 0.0, end: 1.0).animate(\n      CurvedAnimation(\n        parent: _controller,\n        curve: Interval(0.0, 0.5, curve: Curves.elasticOut),\n      ),\n    );\n\n    // Form slides up from bottom\n    _formSlide = Tween<Offset>(\n      begin: Offset(0, 1),\n      end: Offset.zero,\n    ).animate(\n      CurvedAnimation(\n        parent: _controller,\n        curve: Interval(0.3, 0.8, curve: Curves.easeOut),\n      ),\n    );\n\n    // Form fades in\n    _formFade = Tween<double>(begin: 0.0, end: 1.0).animate(\n      CurvedAnimation(\n        parent: _controller,\n        curve: Interval(0.5, 1.0, curve: Curves.easeIn),\n      ),\n    );\n\n    // Start the animation\n    _controller.forward();\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Container(\n        decoration: BoxDecoration(\n          gradient: LinearGradient(\n            begin: Alignment.topLeft,\n            end: Alignment.bottomRight,\n            colors: [Colors.blue.shade300, Colors.purple.shade300],\n          ),\n        ),\n        child: SafeArea(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              // Animated Logo\n              ScaleTransition(\n                scale: _logoScale,\n                child: Icon(\n                  Icons.lock_outline,\n                  size: 120,\n                  color: Colors.white,\n                ),\n              ),\n\n              SizedBox(height: 50),\n\n              // Animated Form\n              SlideTransition(\n                position: _formSlide,\n                child: FadeTransition(\n                  opacity: _formFade,\n                  child: Padding(\n                    padding: EdgeInsets.all(20),\n                    child: Card(\n                      elevation: 8,\n                      shape: RoundedRectangleBorder(\n                        borderRadius: BorderRadius.circular(16),\n                      ),\n                      child: Padding(\n                        padding: EdgeInsets.all(20),\n                        child: Column(\n                          children: [\n                            Text(\n                              'Welcome Back',\n                              style: TextStyle(\n                                fontSize: 28,\n                                fontWeight: FontWeight.bold,\n                              ),\n                            ),\n                            SizedBox(height: 20),\n                            TextField(\n                              decoration: InputDecoration(\n                                labelText: 'Email',\n                                prefixIcon: Icon(Icons.email),\n                              ),\n                            ),\n                            SizedBox(height: 16),\n                            TextField(\n                              obscureText: true,\n                              decoration: InputDecoration(\n                                labelText: 'Password',\n                                prefixIcon: Icon(Icons.lock),\n                              ),\n                            ),\n                            SizedBox(height: 24),\n                            ElevatedButton(\n                              onPressed: () {},\n                              style: ElevatedButton.styleFrom(\n                                minimumSize: Size(double.infinity, 50),\n                              ),\n                              child: Text('Login', style: TextStyle(fontSize: 18)),\n                            ),\n                          ],\n                        ),\n                      ),\n                    ),\n                  ),\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Quick Reference: Implicit Animation Widgets",
              "content": "\n| Widget | What It Animates | Use Case |\n|--------|------------------|----------|\n| AnimatedContainer | Size, color, padding, decoration | Most versatile |\n| AnimatedOpacity | Transparency | Fade in/out |\n| AnimatedPositioned | Position (in Stack) | Move elements |\n| AnimatedAlign | Alignment | Snap to corners |\n| AnimatedPadding | Padding | Spacing changes |\n| AnimatedSwitcher | Widget replacement | Toggle content |\n| AnimatedCrossFade | Fade between 2 widgets | A/B switches |\n| AnimatedDefaultTextStyle | Text style | Text formatting |\n| AnimatedPhysicalModel | Elevation, shadow | 3D effects |\n\n"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Keep It Fast**: 200-400ms for most animations\n2. **Be Consistent**: Use same durations/curves throughout app\n3. **Don't Overdo It**: Not every element needs animation\n4. **Test on Real Devices**: Animations look different on actual hardware\n5. **Dispose Controllers**: Always call `dispose()` to prevent memory leaks\n6. **Use Implicit First**: Only use explicit animations when needed\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the difference between implicit and explicit animations?\nA) Implicit are faster than explicit\nB) Implicit animate automatically when properties change; explicit require AnimationController\nC) Explicit can only animate colors\nD) There is no difference\n\n**Question 2:** What does the `Hero` widget require to work across screens?\nA) The same tag on both screens\nB) The same size widget\nC) An AnimationController\nD) The flutter_animate package\n\n**Question 3:** What is the recommended duration for most UI animations?\nA) 50-100ms\nB) 200-400ms\nC) 1-2 seconds\nD) As long as possible for dramatic effect\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Bouncing Ball",
              "content": "\nCreate a screen with a ball that:\n1. Bounces up and down continuously\n2. Changes color on each bounce\n3. Has a pause/play button\n\n**Hints:**\n- Use `AnimationController` with `repeat(reverse: true)`\n- Use `Tween<double>` for position\n- Use `ColorTween` for color changes\n- Use `Curves.bounceOut` for natural motion\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've learned how to bring your Flutter apps to life with animations! Here's what we covered:\n\n- **Implicit Animations**: Easy, automatic animations (AnimatedContainer, AnimatedOpacity, etc.)\n- **Hero Animations**: Smooth shared element transitions between screens\n- **Explicit Animations**: Full control with AnimationController\n- **Animation Curves**: Make animations feel natural\n- **Best Practices**: Keep it fast, consistent, and purposeful\n\nAnimations transform your app from functional to delightful. Users may not notice good animations, but they'll definitely feel the difference!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) Implicit animate automatically when properties change; explicit require AnimationController\n\nImplicit animations (like AnimatedContainer) detect property changes and animate automatically. Explicit animations require manual setup with AnimationController for full control.\n\n**Answer 2:** A) The same tag on both screens\n\nHero animations work by matching the `tag` property. Flutter finds Hero widgets with the same tag and animates between them during navigation.\n\n**Answer 3:** B) 200-400ms\n\nMaterial Design recommends 200-400ms for most transitions. This is fast enough to be responsive but slow enough to be noticeable and guide user attention.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "9.2",
          "title": "Lesson 2: Camera and Photo Gallery",
          "moduleId": "module-09",
          "order": 2,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Accessing device camera and photo gallery\n- Using the image_picker package\n- Handling permissions on Android and iOS\n- Displaying and saving selected images\n- Taking photos vs selecting from gallery\n- Building a complete photo app\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: Why Camera Access Matters",
              "content": "\n### Real-World Analogy\nThink of your app accessing the camera like a valet service at a hotel. The valet (your app) needs **permission** to drive your car (access the camera). Once you give permission, the valet can:\n- Use your car for a specific task (take a photo)\n- Return it when done (give you the image)\n- But can't just take your car whenever they want (must ask each time)\n\nModern phones treat camera and photos as **private property** - apps must explicitly ask permission and users can revoke it anytime.\n\n### Why This Matters\nCamera and gallery access enables powerful features:\n\n1. **Profile Pictures**: Let users personalize their accounts\n2. **Content Creation**: Social media, blogging, marketplace apps\n3. **Document Scanning**: Receipt capture, ID verification\n4. **Visual Search**: Take a photo to search for products\n5. **AR Features**: Augmented reality experiences\n\nAccording to App Annie, photo/camera features increase user engagement by 35% in social apps!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up",
              "content": "\n### 1. Add Dependencies\n\n**pubspec.yaml:**\n\nRun:\n\n### 2. Android Configuration\n\n**android/app/src/main/AndroidManifest.xml:**\n\n### 3. iOS Configuration\n\n**ios/Runner/Info.plist:**\n\n**Important:** Customize the permission messages to explain **why** your app needs access!\n\n",
              "code": "<dict>\n    <!-- Camera permission description -->\n    <key>NSCameraUsageDescription</key>\n    <string>We need access to your camera to take photos for your profile.</string>\n\n    <!-- Photo library permission description -->\n    <key>NSPhotoLibraryUsageDescription</key>\n    <string>We need access to your photo library to select images.</string>\n\n    <!-- For iOS 14+ -->\n    <key>NSPhotoLibraryAddUsageDescription</key>\n    <string>We need permission to save photos to your library.</string>\n</dict>",
              "language": "xml"
            },
            {
              "type": "THEORY",
              "title": "Basic Usage: ImagePicker",
              "content": "\n### Simple Example: Pick from Gallery\n\n\n### Taking Photos with Camera\n\n\n### Picking Multiple Images (Android 13+, iOS 14+)\n\n\n",
              "code": "Future<void> _pickMultipleImages() async {\n  try {\n    final List<XFile> images = await _picker.pickMultipleImages(\n      imageQuality: 80,\n      maxWidth: 1920,\n    );\n\n    if (images.isNotEmpty) {\n      setState(() {\n        _imageFiles = images.map((img) => File(img.path)).toList();\n      });\n\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('${images.length} images selected')),\n      );\n    }\n  } catch (e) {\n    print('Error picking multiple images: $e');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Photo Profile Editor",
              "content": "\n\n**Key Features:**\n- ‚úÖ Permission handling with fallback to settings\n- ‚úÖ Choose camera or gallery via bottom sheet\n- ‚úÖ Loading indicator during processing\n- ‚úÖ Remove photo option\n- ‚úÖ Circular avatar display\n- ‚úÖ Image compression to save memory\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:image_picker/image_picker.dart';\nimport 'package:permission_handler/permission_handler.dart';\nimport 'dart:io';\n\nclass PhotoProfileScreen extends StatefulWidget {\n  @override\n  State<PhotoProfileScreen> createState() => _PhotoProfileScreenState();\n}\n\nclass _PhotoProfileScreenState extends State<PhotoProfileScreen> {\n  File? _profileImage;\n  final ImagePicker _picker = ImagePicker();\n  bool _isLoading = false;\n\n  // Check and request permissions\n  Future<bool> _requestPermission(Permission permission) async {\n    final status = await permission.status;\n\n    if (status.isGranted) {\n      return true;\n    } else if (status.isDenied) {\n      final result = await permission.request();\n      return result.isGranted;\n    } else if (status.isPermanentlyDenied) {\n      // User permanently denied - open settings\n      await openAppSettings();\n      return false;\n    }\n\n    return false;\n  }\n\n  Future<void> _pickImageSource() async {\n    // Show dialog to choose camera or gallery\n    final ImageSource? source = await showModalBottomSheet<ImageSource>(\n      context: context,\n      builder: (context) => SafeArea(\n        child: Wrap(\n          children: [\n            ListTile(\n              leading: Icon(Icons.camera_alt, color: Colors.blue),\n              title: Text('Take Photo'),\n              onTap: () => Navigator.pop(context, ImageSource.camera),\n            ),\n            ListTile(\n              leading: Icon(Icons.photo_library, color: Colors.green),\n              title: Text('Choose from Gallery'),\n              onTap: () => Navigator.pop(context, ImageSource.gallery),\n            ),\n            if (_profileImage != null)\n              ListTile(\n                leading: Icon(Icons.delete, color: Colors.red),\n                title: Text('Remove Photo'),\n                onTap: () {\n                  setState(() => _profileImage = null);\n                  Navigator.pop(context);\n                },\n              ),\n          ],\n        ),\n      ),\n    );\n\n    if (source != null) {\n      await _pickImage(source);\n    }\n  }\n\n  Future<void> _pickImage(ImageSource source) async {\n    setState(() => _isLoading = true);\n\n    try {\n      // Request appropriate permission\n      final permission = source == ImageSource.camera\n          ? Permission.camera\n          : Permission.photos;\n\n      final hasPermission = await _requestPermission(permission);\n\n      if (!hasPermission) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(\n            content: Text('Permission denied. Please enable in settings.'),\n            action: SnackBarAction(\n              label: 'Settings',\n              onPressed: () => openAppSettings(),\n            ),\n          ),\n        );\n        return;\n      }\n\n      // Pick the image\n      final XFile? image = await _picker.pickImage(\n        source: source,\n        imageQuality: 85,\n        maxWidth: 1024,\n        maxHeight: 1024,\n      );\n\n      if (image != null) {\n        setState(() {\n          _profileImage = File(image.path);\n        });\n\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Photo updated successfully!')),\n        );\n      }\n    } catch (e) {\n      print('Error: $e');\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Error: ${e.toString()}')),\n      );\n    } finally {\n      setState(() => _isLoading = false);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Edit Profile Photo'),\n        actions: [\n          if (_profileImage != null)\n            TextButton(\n              onPressed: () {\n                // Save photo (implement your save logic)\n                ScaffoldMessenger.of(context).showSnackBar(\n                  SnackBar(content: Text('Photo saved!')),\n                );\n              },\n              child: Text('SAVE', style: TextStyle(color: Colors.white)),\n            ),\n        ],\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Profile photo display\n            Stack(\n              children: [\n                CircleAvatar(\n                  radius: 100,\n                  backgroundColor: Colors.grey[300],\n                  backgroundImage: _profileImage != null\n                      ? FileImage(_profileImage!)\n                      : null,\n                  child: _profileImage == null\n                      ? Icon(Icons.person, size: 80, color: Colors.grey[600])\n                      : null,\n                ),\n\n                // Loading indicator\n                if (_isLoading)\n                  Positioned.fill(\n                    child: Container(\n                      decoration: BoxDecoration(\n                        shape: BoxShape.circle,\n                        color: Colors.black45,\n                      ),\n                      child: Center(\n                        child: CircularProgressIndicator(color: Colors.white),\n                      ),\n                    ),\n                  ),\n\n                // Edit button overlay\n                Positioned(\n                  bottom: 0,\n                  right: 0,\n                  child: GestureDetector(\n                    onTap: _isLoading ? null : _pickImageSource,\n                    child: Container(\n                      padding: EdgeInsets.all(8),\n                      decoration: BoxDecoration(\n                        color: Theme.of(context).primaryColor,\n                        shape: BoxShape.circle,\n                        border: Border.all(color: Colors.white, width: 3),\n                      ),\n                      child: Icon(Icons.camera_alt, color: Colors.white, size: 24),\n                    ),\n                  ),\n                ),\n              ],\n            ),\n\n            SizedBox(height: 40),\n\n            Text(\n              'Tap the camera icon to update your photo',\n              style: TextStyle(color: Colors.grey[600], fontSize: 16),\n            ),\n\n            SizedBox(height: 20),\n\n            // Alternative: Large button\n            ElevatedButton.icon(\n              onPressed: _isLoading ? null : _pickImageSource,\n              icon: Icon(Icons.add_a_photo),\n              label: Text(_profileImage == null ? 'Add Photo' : 'Change Photo'),\n              style: ElevatedButton.styleFrom(\n                padding: EdgeInsets.symmetric(horizontal: 32, vertical: 16),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Platform Differences",
              "content": "\n### Android 13+ (API 33+)\n- Uses the new **Android Photo Picker** (privacy-focused)\n- Users can select photos without granting full storage access\n- More secure and privacy-friendly\n\n### Android 12 and Below\n- Uses traditional file picker\n- Requires `READ_EXTERNAL_STORAGE` permission\n\n### iOS 14+\n- Uses **PHPicker** (privacy-focused)\n- Similar to Android Photo Picker\n- Users can select specific photos without granting full library access\n\n"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Always Compress Images**\n   ```dart\n   await _picker.pickImage(\n     source: ImageSource.gallery,\n     imageQuality: 80,  // 80% quality is usually enough\n     maxWidth: 1920,    // Limit dimensions\n   );\n   ```\n\n2. **Handle Permissions Gracefully**\n   - Explain **why** you need permission (in Info.plist/AndroidManifest)\n   - Provide fallback if permission denied\n   - Guide users to settings if permanently denied\n\n3. **Dispose of Large Images**\n   ```dart\n   @override\n   void dispose() {\n     _selectedImage?.delete();  // Clean up temp files\n     super.dispose();\n   }\n   ```\n\n4. **Show Loading Indicators**\n   - Picking/compressing images takes time\n   - Always show progress to user\n\n5. **Validate Image Files**\n   ```dart\n   Future<bool> _isValidImage(File file) async {\n     final bytes = await file.length();\n     final maxSize = 10 * 1024 * 1024;  // 10 MB\n\n     if (bytes > maxSize) {\n       ScaffoldMessenger.of(context).showSnackBar(\n         SnackBar(content: Text('Image too large! Max 10 MB')),\n       );\n       return false;\n     }\n\n     return true;\n   }\n   ```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Common Issues & Solutions",
              "content": "\n**Issue 1: \"Lost connection to device\" when using camera**\n- **Solution**: Run on physical device, not simulator\n- Camera doesn't work in iOS Simulator\n\n**Issue 2: Permission permanently denied**\n- **Solution**: Guide user to app settings\n  ```dart\n  await openAppSettings();\n  ```\n\n**Issue 3: Large images cause memory issues**\n- **Solution**: Always use `maxWidth`, `maxHeight`, `imageQuality`\n\n**Issue 4: Images don't persist after app restart**\n- **Solution**: Copy from temp directory to app documents\n  ```dart\n  final appDir = await getApplicationDocumentsDirectory();\n  final fileName = basename(image.path);\n  final savedImage = await File(image.path).copy('${appDir.path}/$fileName');\n  ```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** Which ImageSource would you use to let users take a new photo?\nA) ImageSource.gallery\nB) ImageSource.camera\nC) ImageSource.files\nD) ImageSource.photos\n\n**Question 2:** Why should you compress images before uploading?\nA) To make them look better\nB) To reduce memory usage and upload time\nC) Because it's required by image_picker\nD) To increase image quality\n\n**Question 3:** What happens if a user permanently denies camera permission?\nA) The app crashes\nB) You can force enable it programmatically\nC) You should guide them to app settings to enable it manually\nD) The permission request will keep showing\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Mini Photo Editor",
              "content": "\nBuild a screen that:\n1. Lets users pick an image from gallery or camera\n2. Displays the image with filter options (grayscale, sepia, etc.)\n3. Has a \"Save\" button that shows a success message\n4. Handles all permissions properly\n\n**Bonus Challenge:**\n- Add image rotation (90¬∞ increments)\n- Add crop functionality\n- Save edited image to device\n\n**Hint:** Use the `image` package for filters:\n\n",
              "code": "dependencies:\n  image: ^4.2.0",
              "language": "yaml"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered camera and gallery access in Flutter! Here's what we covered:\n\n- **Setup**: Platform-specific permissions (Android & iOS)\n- **ImagePicker**: Simple API for camera and gallery\n- **Permissions**: Proper permission handling with fallbacks\n- **Multiple Images**: Picking and displaying image grids\n- **Best Practices**: Compression, validation, and error handling\n\nWith these skills, you can build photo-centric features for profiles, social media, marketplaces, and more!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) ImageSource.camera\n\n`ImageSource.camera` opens the device camera to take a new photo. `ImageSource.gallery` opens the photo library/gallery to select existing photos.\n\n**Answer 2:** B) To reduce memory usage and upload time\n\nCompressing images (via `imageQuality`, `maxWidth`, `maxHeight`) reduces file size significantly, saving memory and making uploads faster. High-resolution photos can be 5-10 MB; compressed versions might be 500 KB.\n\n**Answer 3:** C) You should guide them to app settings to enable it manually\n\nWhen permanently denied, you cannot request permission again. Use `openAppSettings()` from `permission_handler` to help users navigate to settings where they can manually enable permissions.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "9.3",
          "title": "Lesson 3: Local Storage with Hive",
          "moduleId": "module-09",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Understanding local storage options in Flutter\n- Setting up and using Hive (fast NoSQL database)\n- Storing simple data with SharedPreferences\n- Type adapters for custom objects\n- Lazy boxes for memory efficiency\n- Building a complete notes app with local storage\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: Why Local Storage?",
              "content": "\n### Real-World Analogy\nThink of local storage like your phone's contacts app. When you save a contact, it's stored **on your device** - not in the cloud. This means:\n- ‚úÖ Works without internet\n- ‚úÖ Instant access (no network delays)\n- ‚úÖ Privacy (data stays on device)\n- ‚úÖ Survives app restarts\n\nLocal storage is like having a filing cabinet in your office vs. a warehouse across town. Your local cabinet is much faster to access!\n\n### Why This Matters\nLocal storage is essential for:\n\n1. **Offline Functionality**: Apps work without internet\n2. **Settings & Preferences**: Remember user choices\n3. **Caching**: Store data for faster loading\n4. **Draft Content**: Save work-in-progress\n5. **Performance**: Instant access vs. network calls\n\nAccording to Google, users expect apps to work offline. 87% of users get frustrated when apps don't save their data locally!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Storage Options Comparison",
              "content": "\n| Option | Use Case | Performance | Complexity |\n|--------|----------|-------------|------------|\n| **SharedPreferences** | Simple key-value (settings, flags) | Fast | Easy ‚≠ê |\n| **Hive** | Structured data (notes, todos, cache) | Very Fast | Medium ‚≠ê‚≠ê |\n| **SQLite** | Relational data, complex queries | Fast | Hard ‚≠ê‚≠ê‚≠ê |\n| **Secure Storage** | Sensitive data (tokens, passwords) | Medium | Easy ‚≠ê |\n\n**This lesson focuses on Hive and SharedPreferences** (we'll cover SQLite in the next lesson).\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 1: SharedPreferences (Simple Storage)",
              "content": "\n### Setup\n\n\n\n### Basic Usage\n\n\n**Available Methods:**\n\n",
              "code": "// Save\nawait prefs.setBool('key', true);\nawait prefs.setString('key', 'value');\nawait prefs.setInt('key', 42);\nawait prefs.setDouble('key', 3.14);\nawait prefs.setStringList('key', ['a', 'b', 'c']);\n\n// Read (with defaults)\nfinal boolValue = prefs.getBool('key') ?? false;\nfinal stringValue = prefs.getString('key') ?? '';\nfinal intValue = prefs.getInt('key') ?? 0;\nfinal doubleValue = prefs.getDouble('key') ?? 0.0;\nfinal listValue = prefs.getStringList('key') ?? [];\n\n// Check existence\nfinal exists = prefs.containsKey('key');\n\n// Remove single key\nawait prefs.remove('key');\n\n// Clear all\nawait prefs.clear();",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Hive (NoSQL Database)",
              "content": "\nHive is **blazing fast** (10x faster than SQLite for reads) and works great for structured data.\n\n### Setup\n\n\n\n### Initialize Hive\n\n\n### Simple Usage (Key-Value)\n\n\n",
              "code": "import 'package:hive_flutter/hive_flutter.dart';\n\nclass HiveSimpleExample extends StatefulWidget {\n  @override\n  State<HiveSimpleExample> createState() => _HiveSimpleExampleState();\n}\n\nclass _HiveSimpleExampleState extends State<HiveSimpleExample> {\n  final box = Hive.box('notes');\n\n  void _saveNote() {\n    box.put('note1', 'My first note');\n    box.put('note2', 'Another note');\n    box.put('counter', 42);\n\n    setState(() {});\n  }\n\n  void _readNote() {\n    final note1 = box.get('note1', defaultValue: 'No note');\n    final counter = box.get('counter', defaultValue: 0);\n\n    print('Note: $note1, Counter: $counter');\n  }\n\n  void _deleteNote() {\n    box.delete('note1');\n    setState(() {});\n  }\n\n  void _deleteAll() {\n    box.clear();\n    setState(() {});\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Hive Simple Demo')),\n      body: Column(\n        children: [\n          ElevatedButton(onPressed: _saveNote, child: Text('Save Notes')),\n          ElevatedButton(onPressed: _readNote, child: Text('Read Note')),\n          ElevatedButton(onPressed: _deleteNote, child: Text('Delete Note 1')),\n          ElevatedButton(onPressed: _deleteAll, child: Text('Delete All')),\n\n          SizedBox(height: 20),\n\n          Text('All Keys: ${box.keys.toList()}'),\n          Text('All Values: ${box.values.toList()}'),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Storing Custom Objects with Type Adapters",
              "content": "\n### Step 1: Create a Model\n\n\n### Step 2: Generate Type Adapter\n\nRun this command:\n\nThis creates `note.g.dart` with the type adapter code.\n\n### Step 3: Register and Use\n\n\n**Key Methods:**\n\n",
              "code": "// Add (returns auto-increment key)\nfinal key = box.add(note);\n\n// Put with custom key\nbox.put('my-key', note);\n\n// Get by key\nfinal note = box.get('my-key');\n\n// Get by index\nfinal note = box.getAt(0);\n\n// Update (for HiveObject subclasses)\nnote.title = 'New Title';\nnote.save();\n\n// Delete\nbox.delete('my-key');\nbox.deleteAt(0);\n\n// Get all values\nfinal allNotes = box.values.toList();\n\n// Get all keys\nfinal allKeys = box.keys.toList();\n\n// Count\nfinal count = box.length;\n\n// Clear all\nbox.clear();",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Lazy Boxes (For Large Data)",
              "content": "\nUse lazy boxes when you have **lots of data** and don't want to load everything into memory.\n\n\n**When to use:**\n- Regular Box: < 1000 items (loads all into memory)\n- Lazy Box: > 1000 items (loads on demand)\n\n",
              "code": "// Open lazy box\nfinal lazyBox = await Hive.openLazyBox<Note>('large_notes');\n\n// Read (async because it loads from disk on demand)\nfinal note = await lazyBox.get('key');\n\n// Write (same as regular box)\nawait lazyBox.put('key', note);",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Initialize Once**\n   ```dart\n   void main() async {\n     await Hive.initFlutter();  // Call once at app start\n     // ...\n   }\n   ```\n\n2. **Use ValueListenableBuilder**\n   - Automatically rebuilds UI when data changes\n   - No need for setState()\n\n3. **Don't Close Boxes Frequently**\n   ```dart\n   // ‚ùå Bad\n   final box = await Hive.openBox('data');\n   // ... use box\n   await box.close();\n\n   // ‚úÖ Good\n   final box = await Hive.openBox('data');  // Open once\n   // ... use throughout app lifecycle\n   // Close only when app exits\n   ```\n\n4. **Use Type Safety**\n   ```dart\n   // ‚úÖ Good\n   final box = Hive.box<Note>('notes');\n\n   // ‚ùå Bad (no type checking)\n   final box = Hive.box('notes');\n   ```\n\n5. **Handle Migrations**\n   ```dart\n   @HiveField(4, defaultValue: false)  // Add default for new fields\n   bool isPinned;\n   ```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Hive vs SharedPreferences vs SQLite",
              "content": "\n**Use SharedPreferences for:**\n- Settings (dark mode, language)\n- Simple flags (onboarding completed)\n- Small primitive values\n\n**Use Hive for:**\n- Structured data (notes, todos, user profiles)\n- Offline-first apps\n- Fast read/write performance\n- 100s-1000s of records\n\n**Use SQLite for:**\n- Complex relationships (foreign keys)\n- Advanced queries (JOIN, GROUP BY)\n- 10,000s+ records\n- When you need SQL\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the main difference between Hive boxes and lazy boxes?\nA) Lazy boxes are slower\nB) Regular boxes load all data into memory; lazy boxes load on demand\nC) Lazy boxes can't store custom objects\nD) There is no difference\n\n**Question 2:** Which storage solution is best for saving a user's theme preference?\nA) SQLite\nB) Hive\nC) SharedPreferences\nD) Firebase\n\n**Question 3:** When using custom objects with Hive, what must you do?\nA) Nothing, it works automatically\nB) Create a type adapter and register it\nC) Use JSON encoding manually\nD) Store objects as strings\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Todo App with Local Storage",
              "content": "\nBuild a todo app that:\n1. Stores todos locally with Hive\n2. Has categories (Work, Personal, Shopping)\n3. Supports marking todos as complete\n4. Persists data across app restarts\n5. Shows todo count by category\n\n**Bonus:**\n- Add due dates with reminders\n- Search functionality\n- Export todos to text file\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered local storage in Flutter! Here's what we covered:\n\n- **SharedPreferences**: Simple key-value storage for settings\n- **Hive Setup**: Fast NoSQL database initialization\n- **Type Adapters**: Storing custom objects with code generation\n- **CRUD Operations**: Add, read, update, delete data\n- **ValueListenableBuilder**: Reactive UI updates\n- **Best Practices**: When to use each storage solution\n\nWith local storage, your apps can work offline and provide instant user experiences!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) Regular boxes load all data into memory; lazy boxes load on demand\n\nRegular Hive boxes load all data into memory for fast access. Lazy boxes only load data when explicitly requested, making them better for large datasets (1000s+ items) but slightly slower for individual reads.\n\n**Answer 2:** C) SharedPreferences\n\nTheme preferences are simple key-value settings - perfect for SharedPreferences. Using Hive or SQLite would be overkill for a single boolean/string value.\n\n**Answer 3:** B) Create a type adapter and register it\n\nHive needs to know how to serialize/deserialize custom objects. You must:\n1. Annotate class with `@HiveType`\n2. Run `build_runner` to generate adapter\n3. Register adapter with `Hive.registerAdapter()`\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "9.4",
          "title": "Lesson 4: SQLite Database",
          "moduleId": "module-09",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Understanding relational databases\n- Setting up and using SQLite with sqflite\n- Creating tables and schemas\n- CRUD operations (Create, Read, Update, Delete)\n- Advanced queries with WHERE, ORDER BY, JOIN\n- Database migrations and versioning\n- Building a complete contacts app\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: What is SQLite?",
              "content": "\n### Real-World Analogy\nThink of SQLite like an **Excel spreadsheet on steroids**:\n- **Tables** = Spreadsheet tabs\n- **Rows** = Individual records (like spreadsheet rows)\n- **Columns** = Data fields (name, age, email)\n- **Relationships** = Links between tables (like VLOOKUP)\n\nBut unlike Excel, SQLite:\n- ‚úÖ Handles millions of rows efficiently\n- ‚úÖ Enforces data types and rules\n- ‚úÖ Supports complex queries and joins\n- ‚úÖ Is transactional (changes are atomic)\n\n### Why This Matters\nSQLite is perfect for:\n\n1. **Complex Data Structures**: Multiple related tables\n2. **Large Datasets**: 10,000s+ records\n3. **Advanced Queries**: Search, filter, sort, group\n4. **Data Integrity**: Foreign keys, constraints, transactions\n5. **Industry Standard**: Used by Android, iOS, Chrome, Firefox\n\nAccording to SQLite.org, it's the **most deployed database engine** in the world - billions of copies in active use!\n\n"
            },
            {
              "type": "THEORY",
              "title": "When to Use SQLite vs Hive",
              "content": "\n| Feature | SQLite | Hive |\n|---------|--------|------|\n| **Data Structure** | Relational (tables with relationships) | Key-value, NoSQL |\n| **Query Language** | SQL (SELECT, JOIN, GROUP BY) | Dart methods |\n| **Performance** | Good for complex queries | 10x faster for simple reads |\n| **Learning Curve** | Medium (need SQL knowledge) | Easy (pure Dart) |\n| **Use Case** | Contact apps, inventory, analytics | Notes, settings, cache |\n| **Record Count** | 10,000s+ | 100s-1000s |\n\n**Rule of Thumb:**\n- Simple data structure ‚Üí Hive\n- Need relationships or complex queries ‚Üí SQLite\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up",
              "content": "\n### 1. Add Dependencies\n\n**pubspec.yaml:**\n\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "EXAMPLE",
              "title": "Basic SQLite Example",
              "content": "\n### Step 1: Create a Database Helper\n\n\n### Step 2: Use in Your App\n\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'database_helper.dart';\n\nclass SQLiteDemo extends StatefulWidget {\n  @override\n  State<SQLiteDemo> createState() => _SQLiteDemoState();\n}\n\nclass _SQLiteDemoState extends State<SQLiteDemo> {\n  final DatabaseHelper _db = DatabaseHelper();\n  List<Map<String, dynamic>> _notes = [];\n  final _titleController = TextEditingController();\n  final _contentController = TextEditingController();\n\n  @override\n  void initState() {\n    super.initState();\n    _loadNotes();\n  }\n\n  Future<void> _loadNotes() async {\n    final notes = await _db.getAllNotes();\n    setState(() {\n      _notes = notes;\n    });\n  }\n\n  Future<void> _addNote() async {\n    if (_titleController.text.isEmpty) return;\n\n    await _db.insertNote({\n      'title': _titleController.text,\n      'content': _contentController.text,\n      'created_at': DateTime.now().millisecondsSinceEpoch,\n    });\n\n    _titleController.clear();\n    _contentController.clear();\n    _loadNotes();\n\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text('Note added!')),\n    );\n  }\n\n  Future<void> _deleteNote(int id) async {\n    await _db.deleteNote(id);\n    _loadNotes();\n\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text('Note deleted')),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('SQLite Demo (${_notes.length} notes)')),\n      body: Column(\n        children: [\n          // Input form\n          Padding(\n            padding: EdgeInsets.all(16),\n            child: Column(\n              children: [\n                TextField(\n                  controller: _titleController,\n                  decoration: InputDecoration(labelText: 'Title'),\n                ),\n                TextField(\n                  controller: _contentController,\n                  decoration: InputDecoration(labelText: 'Content'),\n                  maxLines: 3,\n                ),\n                SizedBox(height: 10),\n                ElevatedButton(\n                  onPressed: _addNote,\n                  child: Text('Add Note'),\n                ),\n              ],\n            ),\n          ),\n\n          Divider(),\n\n          // Notes list\n          Expanded(\n            child: _notes.isEmpty\n                ? Center(child: Text('No notes yet!'))\n                : ListView.builder(\n                    itemCount: _notes.length,\n                    itemBuilder: (context, index) {\n                      final note = _notes[index];\n                      final createdAt = DateTime.fromMillisecondsSinceEpoch(\n                        note['created_at'],\n                      );\n\n                      return ListTile(\n                        title: Text(note['title']),\n                        subtitle: Column(\n                          crossAxisAlignment: CrossAxisAlignment.start,\n                          children: [\n                            Text(note['content'] ?? ''),\n                            SizedBox(height: 4),\n                            Text(\n                              'Created: ${createdAt.toString().split('.')[0]}',\n                              style: TextStyle(fontSize: 12, color: Colors.grey),\n                            ),\n                          ],\n                        ),\n                        trailing: IconButton(\n                          icon: Icon(Icons.delete, color: Colors.red),\n                          onPressed: () => _deleteNote(note['id']),\n                        ),\n                      );\n                    },\n                  ),\n          ),\n        ],\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    _titleController.dispose();\n    _contentController.dispose();\n    super.dispose();\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Using Models (Type-Safe Approach)",
              "content": "\n### Step 1: Create a Model\n\n\n### Step 2: Update DatabaseHelper\n\n\n",
              "code": "class DatabaseHelper {\n  // ... previous code ...\n\n  // Type-safe methods\n  Future<int> insertNoteObject(Note note) async {\n    final db = await database;\n    return await db.insert('notes', note.toMap());\n  }\n\n  Future<List<Note>> getAllNotesObjects() async {\n    final db = await database;\n    final maps = await db.query('notes', orderBy: 'created_at DESC');\n\n    return maps.map((map) => Note.fromMap(map)).toList();\n  }\n\n  Future<Note?> getNoteObject(int id) async {\n    final db = await database;\n    final maps = await db.query(\n      'notes',\n      where: 'id = ?',\n      whereArgs: [id],\n    );\n\n    return maps.isNotEmpty ? Note.fromMap(maps.first) : null;\n  }\n\n  Future<int> updateNoteObject(Note note) async {\n    final db = await database;\n    return await db.update(\n      'notes',\n      note.toMap(),\n      where: 'id = ?',\n      whereArgs: [note.id],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Advanced Queries",
              "content": "\n### 1. WHERE Clauses (Filtering)\n\n\n### 2. ORDER BY (Sorting)\n\n\n### 3. LIMIT and OFFSET (Pagination)\n\n\n### 4. COUNT and Aggregations\n\n\n",
              "code": "// Get total note count\nFuture<int> getTotalNoteCount() async {\n  final db = await database;\n  final result = await db.rawQuery('SELECT COUNT(*) as count FROM notes');\n\n  return Sqflite.firstIntValue(result) ?? 0;\n}\n\n// Get notes grouped by date\nFuture<Map<String, int>> getNotesCountByDate() async {\n  final db = await database;\n  final results = await db.rawQuery('''\n    SELECT DATE(created_at / 1000, 'unixepoch') as date, COUNT(*) as count\n    FROM notes\n    GROUP BY date\n    ORDER BY date DESC\n  ''');\n\n  return {for (var row in results) row['date'] as String: row['count'] as int};\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Database Migrations",
              "content": "\nWhen you need to change your database schema:\n\n\n",
              "code": "Future<Database> _initDatabase() async {\n  final dbPath = await getDatabasesPath();\n  final path = join(dbPath, 'my_database.db');\n\n  return await openDatabase(\n    path,\n    version: 2,  // Increment version number\n    onCreate: _onCreate,\n    onUpgrade: _onUpgrade,  // Handle migration\n  );\n}\n\nFuture<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {\n  if (oldVersion < 2) {\n    // Add new column to existing table\n    await db.execute('ALTER TABLE notes ADD COLUMN is_favorite INTEGER DEFAULT 0');\n  }\n\n  // Add more migrations as needed\n  // if (oldVersion < 3) { ... }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Use Transactions for Multiple Operations**\n   ```dart\n   Future<void> bulkInsert(List<Note> notes) async {\n     final db = await database;\n\n     await db.transaction((txn) async {\n       for (var note in notes) {\n         await txn.insert('notes', note.toMap());\n       }\n     });\n   }\n   ```\n\n2. **Always Use Parameterized Queries (Prevent SQL Injection)**\n   ```dart\n   // ‚úÖ Good - parameterized\n   await db.query('notes', where: 'title = ?', whereArgs: [userInput]);\n\n   // ‚ùå Bad - vulnerable to SQL injection\n   await db.rawQuery(\"SELECT * FROM notes WHERE title = '$userInput'\");\n   ```\n\n3. **Close Database When App Exits**\n   ```dart\n   @override\n   void dispose() {\n     DatabaseHelper().close();\n     super.dispose();\n   }\n   ```\n\n4. **Use Indexes for Frequently Queried Columns**\n   ```dart\n   await db.execute('CREATE INDEX idx_created_at ON notes(created_at)');\n   ```\n\n5. **Batch Operations for Performance**\n   ```dart\n   final batch = db.batch();\n   for (var note in notes) {\n     batch.insert('notes', note.toMap());\n   }\n   await batch.commit();\n   ```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the main advantage of SQLite over Hive?\nA) It's faster for all operations\nB) It supports complex queries and relational data\nC) It's easier to use\nD) It doesn't require setup\n\n**Question 2:** What does the `?` placeholder do in SQLite queries?\nA) It's a wildcard like `*`\nB) It's replaced with values from `whereArgs` to prevent SQL injection\nC) It marks optional parameters\nD) It indicates null values\n\n**Question 3:** How do you handle database schema changes in sqflite?\nA) Delete the old database and create a new one\nB) Use the `onUpgrade` callback with version numbers\nC) Manually edit the database file\nD) Schema changes are automatic\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Expense Tracker",
              "content": "\nBuild an expense tracker app with:\n1. Categories table (Food, Transport, Entertainment, etc.)\n2. Expenses table with amount, description, date, category_id\n3. Display total expenses by category\n4. Filter expenses by date range\n5. Search expenses by description\n\n**Bonus Challenges:**\n- Add recurring expenses\n- Export data to CSV\n- Show expense trends with charts\n- Budget limits per category\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered SQLite in Flutter! Here's what we covered:\n\n- **Database Setup**: Singleton pattern with DatabaseHelper\n- **CRUD Operations**: Create, Read, Update, Delete\n- **Type-Safe Models**: Converting between objects and maps\n- **Advanced Queries**: WHERE, ORDER BY, LIMIT, JOIN, COUNT\n- **Relationships**: Foreign keys and JOIN queries\n- **Migrations**: Handling schema changes with onUpgrade\n- **Best Practices**: Transactions, parameterized queries, indexes\n\nSQLite gives you the power of a full relational database right on the device!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) It supports complex queries and relational data\n\nSQLite excels at relational data (multiple tables with relationships) and complex queries (JOIN, GROUP BY, aggregations). Hive is faster for simple key-value operations but lacks SQL query capabilities.\n\n**Answer 2:** B) It's replaced with values from `whereArgs` to prevent SQL injection\n\nThe `?` placeholder is a parameter marker that gets safely replaced with values from the `whereArgs` array. This prevents SQL injection attacks by properly escaping user input. Never concatenate user input directly into SQL strings!\n\n**Answer 3:** B) Use the `onUpgrade` callback with version numbers\n\nWhen you change your database schema, increment the `version` number in `openDatabase()` and handle the migration in the `onUpgrade` callback. This safely updates the database structure while preserving existing data.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "9.5",
          "title": "Lesson 5: Maps and Location",
          "moduleId": "module-09",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Integrating Google Maps in Flutter\n- Getting user's current location\n- Adding markers and custom pins\n- Drawing routes and polylines\n- Geocoding (address ‚Üî coordinates)\n- Building a location-based app\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: Why Maps and Location?",
              "content": "\n### Real-World Analogy\nThink of adding maps to your app like giving it **eyes and a GPS**:\n- **Geolocation** = Knowing where you are (like a compass)\n- **Google Maps** = Seeing the world (like a detailed paper map)\n- **Markers** = Sticky notes on the map\n- **Polylines** = Drawing routes with a highlighter\n\nJust like how \"You Are Here\" signs help you navigate a mall, location features help users navigate the real world through your app.\n\n### Why This Matters\nLocation features power essential apps:\n\n1. **Ride-Sharing**: Uber, Lyft (find drivers, track rides)\n2. **Food Delivery**: DoorDash, Uber Eats (track deliveries)\n3. **Dating Apps**: Tinder, Bumble (find nearby matches)\n4. **Fitness**: Strava, RunKeeper (track running routes)\n5. **Real Estate**: Zillow (find properties near you)\n\nAccording to Google, 76% of people who search for something nearby visit a business within a day!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up",
              "content": "\n### 1. Get Google Maps API Key\n\n**Android:**\n1. Go to [Google Cloud Console](https://console.cloud.google.com/)\n2. Create a project\n3. Enable \"Maps SDK for Android\"\n4. Create credentials ‚Üí API Key\n5. Add to `android/app/src/main/AndroidManifest.xml`:\n\n\n**iOS:**\n1. Same Google Cloud Console project\n2. Enable \"Maps SDK for iOS\"\n3. Add to `ios/Runner/AppDelegate.swift`:\n\n\n### 2. Add Dependencies\n\n**pubspec.yaml:**\n\n\n### 3. Configure Permissions\n\n**Android (`android/app/src/main/AndroidManifest.xml`):**\n\n**iOS (`ios/Runner/Info.plist`):**\n\n",
              "code": "<dict>\n    <key>NSLocationWhenInUseUsageDescription</key>\n    <string>We need your location to show nearby places.</string>\n\n    <key>NSLocationAlwaysUsageDescription</key>\n    <string>We need your location for background tracking.</string>\n</dict>",
              "language": "xml"
            },
            {
              "type": "THEORY",
              "title": "Basic Google Maps Integration",
              "content": "\n### Simple Map Display\n\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\n\nclass BasicMapScreen extends StatefulWidget {\n  @override\n  State<BasicMapScreen> createState() => _BasicMapScreenState();\n}\n\nclass _BasicMapScreenState extends State<BasicMapScreen> {\n  late GoogleMapController _mapController;\n\n  // Initial camera position (San Francisco)\n  final CameraPosition _initialPosition = CameraPosition(\n    target: LatLng(37.7749, -122.4194),\n    zoom: 12,\n  );\n\n  void _onMapCreated(GoogleMapController controller) {\n    _mapController = controller;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Google Maps')),\n      body: GoogleMap(\n        onMapCreated: _onMapCreated,\n        initialCameraPosition: _initialPosition,\n        myLocationEnabled: true,  // Show user's location\n        myLocationButtonEnabled: true,  // Show location button\n        mapType: MapType.normal,  // normal, satellite, hybrid, terrain\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Getting User's Current Location",
              "content": "\n### Using Geolocator\n\n\n### Move Map to User's Location\n\n\n",
              "code": "class UserLocationMapScreen extends StatefulWidget {\n  @override\n  State<UserLocationMapScreen> createState() => _UserLocationMapScreenState();\n}\n\nclass _UserLocationMapScreenState extends State<UserLocationMapScreen> {\n  late GoogleMapController _mapController;\n  final LocationService _locationService = LocationService();\n  Position? _currentPosition;\n  bool _isLoading = true;\n\n  @override\n  void initState() {\n    super.initState();\n    _getCurrentLocation();\n  }\n\n  Future<void> _getCurrentLocation() async {\n    final position = await _locationService.getCurrentLocation();\n\n    if (position != null) {\n      setState(() {\n        _currentPosition = position;\n        _isLoading = false;\n      });\n\n      // Move camera to user's location\n      _mapController.animateCamera(\n        CameraUpdate.newCameraPosition(\n          CameraPosition(\n            target: LatLng(position.latitude, position.longitude),\n            zoom: 15,\n          ),\n        ),\n      );\n    } else {\n      setState(() => _isLoading = false);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('My Location')),\n      body: _isLoading\n          ? Center(child: CircularProgressIndicator())\n          : GoogleMap(\n              onMapCreated: (controller) => _mapController = controller,\n              initialCameraPosition: CameraPosition(\n                target: _currentPosition != null\n                    ? LatLng(_currentPosition!.latitude, _currentPosition!.longitude)\n                    : LatLng(37.7749, -122.4194),\n                zoom: 15,\n              ),\n              myLocationEnabled: true,\n              myLocationButtonEnabled: true,\n            ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _getCurrentLocation,\n        child: Icon(Icons.my_location),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Adding Markers",
              "content": "\n\n### Custom Marker Icons\n\n\n",
              "code": "// Load custom marker from assets\nBitmapDescriptor? _customIcon;\n\nFuture<void> _loadCustomMarker() async {\n  _customIcon = await BitmapDescriptor.fromAssetImage(\n    ImageConfiguration(devicePixelRatio: 2.5),\n    'assets/images/custom_marker.png',\n  );\n}\n\n// Use in marker\nMarker(\n  markerId: MarkerId('custom'),\n  position: LatLng(37.7749, -122.4194),\n  icon: _customIcon ?? BitmapDescriptor.defaultMarker,\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Geocoding (Address ‚Üî Coordinates)",
              "content": "\n\n**Usage Example:**\n\n",
              "code": "// Search for address\nfinal coordinates = await GeocodingService().getCoordinatesFromAddress(\n  '1600 Amphitheatre Parkway, Mountain View, CA',\n);\n\nif (coordinates != null) {\n  _mapController.animateCamera(\n    CameraUpdate.newLatLng(coordinates),\n  );\n}\n\n// Get address from tap\nvoid _onMapTap(LatLng position) async {\n  final address = await GeocodingService().getAddressFromCoordinates(\n    position.latitude,\n    position.longitude,\n  );\n\n  print('Address: $address');\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Always Check Permissions**\n   ```dart\n   final hasPermission = await Permission.location.request();\n   if (!hasPermission.isGranted) {\n     // Show error or guide user to settings\n     return;\n   }\n   ```\n\n2. **Handle Location Services Disabled**\n   ```dart\n   if (!await Geolocator.isLocationServiceEnabled()) {\n     await Geolocator.openLocationSettings();\n   }\n   ```\n\n3. **Dispose Map Controller**\n   ```dart\n   @override\n   void dispose() {\n     _mapController.dispose();\n     super.dispose();\n   }\n   ```\n\n4. **Use Different Accuracy for Different Needs**\n   ```dart\n   // High accuracy (GPS) - battery intensive\n   LocationAccuracy.high\n\n   // Medium accuracy - balanced\n   LocationAccuracy.medium\n\n   // Low accuracy - battery friendly\n   LocationAccuracy.low\n   ```\n\n5. **Cache Map Data for Offline Use**\n   - Google Maps automatically caches viewed areas\n   - For full offline support, consider OpenStreetMap alternatives\n\n"
            },
            {
              "type": "THEORY",
              "title": "Common Issues & Solutions",
              "content": "\n**Issue 1: Map shows blank/gray screen**\n- **Solution**: Check API key is correct and enabled\n- Verify billing is enabled in Google Cloud Console\n\n**Issue 2: \"Location services are disabled\"**\n- **Solution**: Guide user to enable in device settings\n  ```dart\n  await Geolocator.openLocationSettings();\n  ```\n\n**Issue 3: Markers not showing**\n- **Solution**: Ensure markers Set is passed to GoogleMap widget\n- Check zoom level isn't too far out\n\n**Issue 4: App crashes on iOS when accessing location**\n- **Solution**: Add usage descriptions to Info.plist\n- Request permission before accessing location\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the difference between `LocationAccuracy.high` and `LocationAccuracy.low`?\nA) High is slower but more accurate\nB) High uses GPS (precise but battery-intensive); low uses network (less precise, battery-friendly)\nC) There is no difference\nD) Low accuracy is deprecated\n\n**Question 2:** How do you convert an address to coordinates?\nA) Use `geolocator` package\nB) Use `locationFromAddress()` from geocoding package\nC) Manually parse with regex\nD) Google Maps does it automatically\n\n**Question 3:** What is a Polyline used for?\nA) Marking single locations\nB) Drawing routes/paths on the map\nC) Setting map boundaries\nD) Clustering markers\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Delivery Tracker",
              "content": "\nBuild a delivery tracking app that:\n1. Shows delivery driver's live location\n2. Draws route from restaurant ‚Üí customer\n3. Updates ETA as driver moves\n4. Shows distance remaining\n\n**Bonus Challenges:**\n- Add multiple delivery stops\n- Show traffic conditions\n- Send notifications when driver is nearby\n- Estimate delivery time based on speed\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered maps and location in Flutter! Here's what we covered:\n\n- **Google Maps Integration**: Setup and basic map display\n- **Geolocation**: Getting user's current location with geolocator\n- **Permissions**: Handling location permissions gracefully\n- **Markers**: Adding custom pins and info windows\n- **Polylines**: Drawing routes and paths\n- **Geocoding**: Converting addresses ‚Üî coordinates\n- **Complete App**: Nearby places finder with filtering\n\nWith these skills, you can build location-aware apps like ride-sharing, delivery tracking, and social discovery!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) High uses GPS (precise but battery-intensive); low uses network (less precise, battery-friendly)\n\n`LocationAccuracy.high` uses GPS for precise location (¬±5-10 meters) but drains battery. `LocationAccuracy.low` uses WiFi/cell towers (¬±100-500 meters) but is battery-friendly. Choose based on your app's needs!\n\n**Answer 2:** B) Use `locationFromAddress()` from geocoding package\n\nThe `geocoding` package provides `locationFromAddress()` for forward geocoding (address ‚Üí coordinates) and `placemarkFromCoordinates()` for reverse geocoding (coordinates ‚Üí address).\n\n**Answer 3:** B) Drawing routes/paths on the map\n\nPolylines draw connected lines between multiple LatLng points, perfect for showing routes, paths, or boundaries. Markers are for single points, not routes.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "9.6",
          "title": "Lesson 6: Device Features (Sensors & Biometrics)",
          "moduleId": "module-09",
          "order": 6,
          "estimatedMinutes": 55,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Biometric authentication (fingerprint, Face ID)\n- Accelerometer and gyroscope sensors\n- Shake detection\n- Vibration and haptic feedback\n- Battery status and device info\n- Building secure and interactive apps\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: Why Device Features?",
              "content": "\n### Real-World Analogy\nThink of your phone's hardware features like the **five senses** of your app:\n- **Biometrics** = Identity verification (like a bouncer checking ID)\n- **Accelerometer** = Motion sensing (like your inner ear for balance)\n- **Vibration** = Touch feedback (like feeling a tap on your shoulder)\n- **Battery** = Energy awareness (like checking your car's fuel gauge)\n\nJust like humans use multiple senses to interact with the world, apps use device features to create richer, more secure experiences!\n\n### Why This Matters\nDevice features enable unique experiences:\n\n1. **Security**: Biometric login (banking apps, password managers)\n2. **Fitness**: Step tracking, workout monitoring (Fitbit, Strava)\n3. **Gaming**: Motion controls (racing games, AR games)\n4. **Productivity**: Shake to undo, vibrate on notifications\n5. **Accessibility**: Haptic feedback for visually impaired users\n\nAccording to Apple, Face ID is 20x more secure than Touch ID, and biometric authentication increases user engagement by 45%!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Biometric Authentication",
              "content": "\n### Setup\n\n**pubspec.yaml:**\n\n**Android Configuration (`android/app/src/main/AndroidManifest.xml`):**\n\n**iOS Configuration (`ios/Runner/Info.plist`):**\n\n### Basic Biometric Authentication\n\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:local_auth/local_auth.dart';\nimport 'package:local_auth/error_codes.dart' as auth_error;\n\nclass BiometricAuthScreen extends StatefulWidget {\n  @override\n  State<BiometricAuthScreen> createState() => _BiometricAuthScreenState();\n}\n\nclass _BiometricAuthScreenState extends State<BiometricAuthScreen> {\n  final LocalAuthentication _localAuth = LocalAuthentication();\n  bool _isAuthenticated = false;\n  List<BiometricType> _availableBiometrics = [];\n\n  @override\n  void initState() {\n    super.initState();\n    _checkBiometrics();\n  }\n\n  // Check what biometrics are available\n  Future<void> _checkBiometrics() async {\n    try {\n      // Check if device supports biometrics\n      final canCheckBiometrics = await _localAuth.canCheckBiometrics;\n      final isDeviceSupported = await _localAuth.isDeviceSupported();\n\n      if (canCheckBiometrics && isDeviceSupported) {\n        // Get list of available biometrics\n        final availableBiometrics = await _localAuth.getAvailableBiometrics();\n\n        setState(() {\n          _availableBiometrics = availableBiometrics;\n        });\n\n        print('Available biometrics: $_availableBiometrics');\n        // Possible values:\n        // - BiometricType.face (Face ID on iOS, face unlock on Android)\n        // - BiometricType.fingerprint (Touch ID on iOS, fingerprint on Android)\n        // - BiometricType.iris (Iris scanner on Samsung devices)\n      }\n    } catch (e) {\n      print('Error checking biometrics: $e');\n    }\n  }\n\n  // Authenticate with biometrics\n  Future<void> _authenticate() async {\n    try {\n      final authenticated = await _localAuth.authenticate(\n        localizedReason: 'Please authenticate to access your account',\n        options: AuthenticationOptions(\n          stickyAuth: true,  // Show auth dialog until user interacts\n          biometricOnly: false,  // Allow PIN/password fallback\n        ),\n      );\n\n      setState(() {\n        _isAuthenticated = authenticated;\n      });\n\n      if (authenticated) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(\n            content: Text('Authentication successful!'),\n            backgroundColor: Colors.green,\n          ),\n        );\n      }\n    } on PlatformException catch (e) {\n      // Handle errors\n      if (e.code == auth_error.notAvailable) {\n        print('Biometrics not available');\n      } else if (e.code == auth_error.notEnrolled) {\n        print('No biometrics enrolled');\n      } else if (e.code == auth_error.lockedOut) {\n        print('Too many failed attempts');\n      } else if (e.code == auth_error.permanentlyLockedOut) {\n        print('Permanently locked out');\n      }\n\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Authentication failed: ${e.message}')),\n      );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Biometric Authentication')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(\n              _isAuthenticated ? Icons.lock_open : Icons.lock,\n              size: 100,\n              color: _isAuthenticated ? Colors.green : Colors.red,\n            ),\n\n            SizedBox(height: 20),\n\n            Text(\n              _isAuthenticated ? 'Authenticated ‚úì' : 'Not Authenticated ‚úó',\n              style: TextStyle(\n                fontSize: 24,\n                fontWeight: FontWeight.bold,\n                color: _isAuthenticated ? Colors.green : Colors.red,\n              ),\n            ),\n\n            SizedBox(height: 40),\n\n            // Available biometrics\n            if (_availableBiometrics.isNotEmpty) ...[\n              Text('Available biometrics:', style: TextStyle(fontSize: 16)),\n              SizedBox(height: 10),\n              ..._availableBiometrics.map((biometric) => Chip(\n                    label: Text(biometric.toString().split('.').last),\n                  )),\n            ],\n\n            SizedBox(height: 40),\n\n            ElevatedButton.icon(\n              onPressed: _authenticate,\n              icon: Icon(Icons.fingerprint),\n              label: Text('Authenticate'),\n              style: ElevatedButton.styleFrom(\n                padding: EdgeInsets.symmetric(horizontal: 32, vertical: 16),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Motion Sensors",
              "content": "\n### Setup\n\n**pubspec.yaml:**\n\n**iOS Configuration (`ios/Runner/Info.plist`):**\n\n### Accelerometer (Detects Device Motion)\n\n\n### Gyroscope (Detects Rotation)\n\n\n",
              "code": "class GyroscopeScreen extends StatefulWidget {\n  @override\n  State<GyroscopeScreen> createState() => _GyroscopeScreenState();\n}\n\nclass _GyroscopeScreenState extends State<GyroscopeScreen> {\n  double _rotationX = 0.0, _rotationY = 0.0, _rotationZ = 0.0;\n  StreamSubscription? _gyroscopeSubscription;\n\n  @override\n  void initState() {\n    super.initState();\n\n    _gyroscopeSubscription = gyroscopeEventStream().listen((GyroscopeEvent event) {\n      setState(() {\n        _rotationX = event.x;  // Pitch (nose up/down)\n        _rotationY = event.y;  // Roll (wing up/down)\n        _rotationZ = event.z;  // Yaw (turn left/right)\n      });\n    });\n  }\n\n  @override\n  void dispose() {\n    _gyroscopeSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Gyroscope')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Rotation Rate (radians/second)', style: TextStyle(fontSize: 20)),\n            SizedBox(height: 40),\n\n            _buildRotationIndicator('Pitch (X)', _rotationX, Colors.red),\n            SizedBox(height: 20),\n            _buildRotationIndicator('Roll (Y)', _rotationY, Colors.green),\n            SizedBox(height: 20),\n            _buildRotationIndicator('Yaw (Z)', _rotationZ, Colors.blue),\n\n            SizedBox(height: 40),\n\n            Text(\n              'Tilt your phone to see rotation values',\n              style: TextStyle(color: Colors.grey),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildRotationIndicator(String label, double value, Color color) {\n    return Column(\n      children: [\n        Text(label, style: TextStyle(fontSize: 16)),\n        SizedBox(height: 8),\n        Container(\n          width: 300,\n          height: 40,\n          decoration: BoxDecoration(\n            border: Border.all(color: Colors.grey),\n            borderRadius: BorderRadius.circular(8),\n          ),\n          child: Stack(\n            children: [\n              // Center line\n              Center(\n                child: Container(\n                  width: 2,\n                  height: 40,\n                  color: Colors.grey,\n                ),\n              ),\n              // Indicator\n              Align(\n                alignment: Alignment(value.clamp(-1.0, 1.0), 0),\n                child: Container(\n                  width: 20,\n                  height: 40,\n                  color: color,\n                ),\n              ),\n            ],\n          ),\n        ),\n        SizedBox(height: 4),\n        Text('${value.toStringAsFixed(2)} rad/s'),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 3: Shake Detection",
              "content": "\n### Setup\n\n**pubspec.yaml:**\n\n### Shake to Undo Example\n\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:shake/shake.dart';\n\nclass ShakeToUndoScreen extends StatefulWidget {\n  @override\n  State<ShakeToUndoScreen> createState() => _ShakeToUndoScreenState();\n}\n\nclass _ShakeToUndoScreenState extends State<ShakeToUndoScreen> {\n  ShakeDetector? _shakeDetector;\n  List<String> _actions = [];\n  int _counter = 0;\n\n  @override\n  void initState() {\n    super.initState();\n\n    // Initialize shake detector\n    _shakeDetector = ShakeDetector.autoStart(\n      onPhoneShake: (ShakeEvent event) {\n        // Called when phone is shaken\n        _undoLastAction();\n\n        // Optional: Show shake details\n        print('Shake detected!');\n        print('Direction: ${event.direction}');  // X, Y, or Z axis\n        print('Force: ${event.force}');\n        print('Time: ${event.timestamp}');\n      },\n      minimumShakeCount: 1,\n      shakeSlopTimeMS: 500,\n      shakeCountResetTime: 3000,\n      shakeThresholdGravity: 2.7,\n    );\n  }\n\n  @override\n  void dispose() {\n    _shakeDetector?.stopListening();\n    super.dispose();\n  }\n\n  void _addAction() {\n    setState(() {\n      _counter++;\n      _actions.add('Action $_counter');\n    });\n  }\n\n  void _undoLastAction() {\n    if (_actions.isEmpty) return;\n\n    setState(() {\n      final lastAction = _actions.removeLast();\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(\n          content: Text('Undid: $lastAction'),\n          duration: Duration(seconds: 1),\n        ),\n      );\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Shake to Undo')),\n      body: Column(\n        children: [\n          Padding(\n            padding: EdgeInsets.all(16),\n            child: Text(\n              'Shake your phone to undo!',\n              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n            ),\n          ),\n\n          Expanded(\n            child: _actions.isEmpty\n                ? Center(child: Text('No actions yet'))\n                : ListView.builder(\n                    itemCount: _actions.length,\n                    itemBuilder: (context, index) {\n                      return ListTile(\n                        leading: CircleAvatar(child: Text('${index + 1}')),\n                        title: Text(_actions[index]),\n                        trailing: IconButton(\n                          icon: Icon(Icons.delete),\n                          onPressed: () {\n                            setState(() => _actions.removeAt(index));\n                          },\n                        ),\n                      );\n                    },\n                  ),\n          ),\n        ],\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _addAction,\n        child: Icon(Icons.add),\n        tooltip: 'Add Action',\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 4: Vibration & Haptic Feedback",
              "content": "\n### Setup\n\n**pubspec.yaml:**\n\n**Android Configuration (`android/app/src/main/AndroidManifest.xml`):**\n\n### Vibration Examples\n\n\n### Haptic Feedback (Alternative)\n\nFlutter has built-in haptic feedback:\n\n\n**Example in Button:**\n\n",
              "code": "ElevatedButton(\n  onPressed: () {\n    HapticFeedback.lightImpact();  // Provide feedback\n    // ... do action\n  },\n  child: Text('Tap Me'),\n)",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Always Check Availability**\n   ```dart\n   final hasVibrator = await Vibration.hasVibrator();\n   final canAuth = await _localAuth.canCheckBiometrics;\n   ```\n\n2. **Provide Fallback Options**\n   - If biometrics fail, offer PIN/password\n   - If sensors unavailable, provide manual input\n\n3. **Don't Overuse Haptics**\n   - Only for important actions (button taps, errors)\n   - Too much vibration annoys users\n\n4. **Cancel Streams**\n   ```dart\n   @override\n   void dispose() {\n     _sensorSubscription?.cancel();\n     super.dispose();\n   }\n   ```\n\n5. **Handle Permissions Gracefully**\n   - Explain why you need sensor access\n   - Provide option to skip if not critical\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the difference between `accelerometerEvents` and `userAccelerometerEvents`?\nA) They're the same\nB) User accelerometer filters out gravity\nC) Accelerometer is more accurate\nD) User accelerometer is iOS only\n\n**Question 2:** When should you use `HapticFeedback.heavyImpact()`?\nA) For every button tap\nB) For important actions like errors or deletions\nC) Only on Android\nD) Never, it's deprecated\n\n**Question 3:** What does `stickyAuth: true` do in biometric authentication?\nA) Makes authentication faster\nB) Keeps showing the dialog until user interacts\nC) Automatically retries on failure\nD) Uses only fingerprint, not face\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Motion-Controlled Game",
              "content": "\nBuild a simple game that:\n1. Has a ball that moves based on device tilt (accelerometer)\n2. Vibrates when ball hits walls\n3. Requires biometric authentication to start\n4. Shake to reset ball position\n\n**Bonus Challenges:**\n- Add obstacles that ball must avoid\n- Track high scores securely\n- Use gyroscope for rotation effects\n- Add haptic feedback for different events\n\n"
            },
            {
              "type": "THEORY",
              "title": "üîå Platform Channels: Talking to Native Code",
              "content": "\n### What Are Platform Channels?\n\nSometimes you need features that don't have a Flutter plugin. **Platform Channels** let your Dart code communicate directly with native Android (Kotlin/Java) and iOS (Swift/Objective-C) code.\n\n**Analogy:** Think of Platform Channels like a **translator at a UN meeting**. Dart speaks one language, Android/iOS speak another. The channel translates messages back and forth!\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ     FLUTTER     ‚îÇ                    ‚îÇ     NATIVE      ‚îÇ\n‚îÇ    (Dart)       ‚îÇ‚óÑ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ñ∫‚îÇ  (Kotlin/Swift) ‚îÇ\n‚îÇ                 ‚îÇ   MethodChannel    ‚îÇ                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚îÇ                                      ‚îÇ\n    invokeMethod()  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫   handle method\n         ‚îÇ          ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   return result\n    receive result                              ‚îÇ\n```\n\n### When Do You Need Platform Channels?\n\n1. **No plugin exists** for the feature you need\n2. **Proprietary SDKs** that only have native libraries\n3. **Hardware features** not exposed by Flutter\n4. **Performance-critical** code that must run natively\n5. **Existing native code** you want to reuse\n\n"
            },
            {
              "type": "THEORY",
              "title": "Complete Platform Channel Example: Get Battery Level",
              "content": "\n### Step 1: Flutter Side (Dart)\n\n**lib/services/battery_service.dart:**\n\n```dart\nimport 'package:flutter/services.dart';\n\nclass BatteryService {\n  // Create a channel with a unique name\n  static const platform = MethodChannel('com.myapp/battery');\n  \n  // Call native code to get battery level\n  static Future<int> getBatteryLevel() async {\n    try {\n      // invokeMethod sends a message to native code\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return result;\n    } on PlatformException catch (e) {\n      print('Failed to get battery level: ${e.message}');\n      return -1;\n    }\n  }\n  \n  // Call native code with arguments\n  static Future<bool> setBatteryAlarm(int threshold) async {\n    try {\n      final result = await platform.invokeMethod(\n        'setBatteryAlarm',\n        {'threshold': threshold},  // Pass data to native\n      );\n      return result as bool;\n    } on PlatformException {\n      return false;\n    }\n  }\n}\n```\n\n### Step 2: Android Side (Kotlin)\n\n**android/app/src/main/kotlin/.../MainActivity.kt:**\n\n```kotlin\npackage com.example.myapp\n\nimport android.content.Context\nimport android.content.ContextWrapper\nimport android.content.Intent\nimport android.content.IntentFilter\nimport android.os.BatteryManager\nimport android.os.Build\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\n\nclass MainActivity : FlutterActivity() {\n    private val CHANNEL = \"com.myapp/battery\"  // Must match Dart!\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        super.configureFlutterEngine(flutterEngine)\n\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL)\n            .setMethodCallHandler { call, result ->\n                when (call.method) {\n                    \"getBatteryLevel\" -> {\n                        val batteryLevel = getBatteryLevel()\n                        if (batteryLevel != -1) {\n                            result.success(batteryLevel)\n                        } else {\n                            result.error(\"UNAVAILABLE\", \"Battery level not available\", null)\n                        }\n                    }\n                    \"setBatteryAlarm\" -> {\n                        val threshold = call.argument<Int>(\"threshold\") ?: 20\n                        // Implement your alarm logic here\n                        result.success(true)\n                    }\n                    else -> result.notImplemented()\n                }\n            }\n    }\n\n    private fun getBatteryLevel(): Int {\n        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            val batteryManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager\n            batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\n        } else {\n            val intent = ContextWrapper(applicationContext)\n                .registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED))\n            (intent?.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) ?: -1) * 100 /\n                (intent?.getIntExtra(BatteryManager.EXTRA_SCALE, -1) ?: 1)\n        }\n    }\n}\n```\n\n### Step 3: iOS Side (Swift)\n\n**ios/Runner/AppDelegate.swift:**\n\n```swift\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n    override func application(\n        _ application: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n    ) -> Bool {\n        let controller = window?.rootViewController as! FlutterViewController\n        \n        let batteryChannel = FlutterMethodChannel(\n            name: \"com.myapp/battery\",  // Must match Dart!\n            binaryMessenger: controller.binaryMessenger\n        )\n        \n        batteryChannel.setMethodCallHandler { [weak self] (call, result) in\n            switch call.method {\n            case \"getBatteryLevel\":\n                self?.receiveBatteryLevel(result: result)\n            case \"setBatteryAlarm\":\n                if let args = call.arguments as? [String: Any],\n                   let threshold = args[\"threshold\"] as? Int {\n                    // Implement alarm logic\n                    result(true)\n                } else {\n                    result(FlutterError(code: \"INVALID_ARGS\", message: nil, details: nil))\n                }\n            default:\n                result(FlutterMethodNotImplemented)\n            }\n        }\n        \n        GeneratedPluginRegistrant.register(with: self)\n        return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n    }\n    \n    private func receiveBatteryLevel(result: FlutterResult) {\n        UIDevice.current.isBatteryMonitoringEnabled = true\n        let batteryLevel = Int(UIDevice.current.batteryLevel * 100)\n        \n        if batteryLevel == -100 {\n            result(FlutterError(\n                code: \"UNAVAILABLE\",\n                message: \"Battery info unavailable\",\n                details: nil\n            ))\n        } else {\n            result(batteryLevel)\n        }\n    }\n}\n```\n\n### Step 4: Use It in Flutter\n\n```dart\nclass BatteryScreen extends StatefulWidget {\n  @override\n  State<BatteryScreen> createState() => _BatteryScreenState();\n}\n\nclass _BatteryScreenState extends State<BatteryScreen> {\n  int _batteryLevel = -1;\n  \n  @override\n  void initState() {\n    super.initState();\n    _loadBatteryLevel();\n  }\n  \n  Future<void> _loadBatteryLevel() async {\n    final level = await BatteryService.getBatteryLevel();\n    setState(() => _batteryLevel = level);\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Battery Level')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(\n              _batteryLevel > 50 ? Icons.battery_full : Icons.battery_alert,\n              size: 100,\n              color: _batteryLevel > 20 ? Colors.green : Colors.red,\n            ),\n            SizedBox(height: 20),\n            Text(\n              '$_batteryLevel%',\n              style: TextStyle(fontSize: 48, fontWeight: FontWeight.bold),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _loadBatteryLevel,\n              child: Text('Refresh'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Platform Channel Types",
              "content": "\n| Channel Type | Description | Use Case |\n|--------------|-------------|----------|\n| **MethodChannel** | Two-way async method calls | Most common - API calls, getting data |\n| **EventChannel** | One-way stream from native | Continuous data (sensors, location) |\n| **BasicMessageChannel** | Raw message passing | Custom encoding, simple messages |\n\n### EventChannel Example (Continuous Data)\n\n```dart\n// Dart side - receive continuous updates\nclass SensorStream {\n  static const eventChannel = EventChannel('com.myapp/sensor');\n  \n  static Stream<double> get sensorStream {\n    return eventChannel.receiveBroadcastStream().map((value) => value as double);\n  }\n}\n\n// Usage\nSensorStream.sensorStream.listen((value) {\n  print('Sensor value: $value');\n});\n```\n\n### Best Practices\n\n1. **Use unique channel names** - reverse domain format (`com.myapp/feature`)\n2. **Handle errors gracefully** - wrap in try-catch, provide fallbacks\n3. **Check platform first** - use `Platform.isAndroid` / `Platform.isIOS`\n4. **Test on both platforms** - native code differs between Android/iOS\n5. **Prefer plugins** - only use channels when no plugin exists\n\n**Pro Tip:** Before writing platform channels, check [pub.dev](https://pub.dev) - there's probably already a plugin for what you need!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered device features in Flutter! Here's what we covered:\n\n- **Biometric Authentication**: Secure login with fingerprint/Face ID\n- **Accelerometer**: Detect device motion and tilt\n- **Gyroscope**: Measure rotation and orientation\n- **Shake Detection**: Respond to device shaking\n- **Vibration & Haptics**: Provide tactile feedback\n- **Platform Channels**: Communicate with native Android/iOS code\n- **Complete App**: Secure notes with biometric lock\n\nWith these skills, you can build apps that feel native, secure, and interactive!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) User accelerometer filters out gravity\n\n`accelerometerEvents` includes gravity (so when device is still, z-axis shows ~9.8 m/s¬≤). `userAccelerometerEvents` filters out gravity, showing only user-caused motion. Use user accelerometer for gesture detection, regular accelerometer for orientation.\n\n**Answer 2:** B) For important actions like errors or deletions\n\nHeavy impact should be reserved for significant moments like errors, destructive actions (delete), or important confirmations. Overusing strong haptics reduces their effectiveness and annoys users. Light impact is for normal taps.\n\n**Answer 3:** B) Keeps showing the dialog until user interacts\n\n`stickyAuth: true` prevents the authentication dialog from dismissing automatically. It stays visible until the user successfully authenticates or explicitly cancels. This prevents accidental dismissals on Android.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "9.7",
          "title": "Lesson 7: Background Tasks & Workmanager",
          "moduleId": "module-09",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Understanding background execution in mobile apps\n- Using Workmanager for scheduled background tasks\n- One-time vs periodic background work\n- Handling constraints (network, battery, charging)\n- Data sync and background uploads\n- Best practices for battery efficiency\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: What Are Background Tasks?",
              "content": "\n### Real-World Analogy\nThink of background tasks like a **scheduled cleaning service** for your house:\n- **One-Time Task** = \"Clean before the party tonight\"\n- **Periodic Task** = \"Clean every Tuesday at 3 PM\"\n- **Constraints** = \"Only clean when I'm not home and it's daylight\"\n\nJust like a cleaning service works when you're away, background tasks run when your app is closed or minimized!\n\n### Why This Matters\nBackground tasks enable critical features:\n\n1. **Data Sync**: Upload photos, sync notes (Google Photos, Evernote)\n2. **Content Updates**: Fetch news, update widgets (News apps)\n3. **Maintenance**: Clean cache, compress files\n4. **Analytics**: Send usage data periodically\n5. **Notifications**: Check for new messages (Email apps)\n\nAccording to Google, proper background task management can reduce battery drain by 40% compared to naive implementations!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Background Execution: The Challenges",
              "content": "\n### Platform Restrictions\n\nModern mobile OSes heavily restrict background work to save battery:\n\n**iOS:**\n- ‚ùå No continuous background execution (with exceptions)\n- ‚úÖ BGTaskScheduler for periodic tasks\n- ‚è∞ Tasks run at OS discretion (not guaranteed timing)\n- üîã Tasks killed if battery is low\n\n**Android:**\n- ‚úÖ WorkManager for reliable scheduled work\n- ‚è∞ Minimum 15-minute intervals for periodic work\n- üîã Doze mode limits background tasks\n- ‚úÖ More flexibility than iOS\n\n**Key Takeaway:** Background tasks are **not real-time**. Use them for deferrable work, not time-critical operations!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Workmanager",
              "content": "\n### Installation\n\n**pubspec.yaml:**\n\n\n### Android Configuration\n\n**android/app/src/main/AndroidManifest.xml:**\n\n### iOS Configuration\n\n**ios/Runner/Info.plist:**\n\n**ios/Runner/AppDelegate.swift:**\n\n",
              "code": "import UIKit\nimport Flutter\nimport workmanager\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n  override func application(\n    _ application: UIApplication,\n    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n  ) -> Bool {\n    GeneratedPluginRegistrant.register(with: self)\n\n    WorkmanagerPlugin.setPluginRegistrantCallback { registry in\n        GeneratedPluginRegistrant.register(with: registry)\n    }\n\n    return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n  }\n}",
              "language": "swift"
            },
            {
              "type": "THEORY",
              "title": "Basic Workmanager Usage",
              "content": "\n### Step 1: Initialize Workmanager\n\n\n### Step 2: Register One-Time Tasks\n\n\n### Step 3: Register Periodic Tasks\n\n\n**Important:** Android minimum periodic interval is **15 minutes**. iOS is even less predictable!\n\n",
              "code": "Future<void> _registerPeriodicTask() async {\n  await Workmanager().registerPeriodicTask(\n    'periodic-sync',  // Unique ID\n    'syncData',       // Task name\n    frequency: Duration(hours: 1),  // Run every hour (minimum 15 minutes)\n    constraints: Constraints(\n      networkType: NetworkType.connected,     // Require internet\n      requiresBatteryNotLow: true,            // Don't run if battery low\n      requiresCharging: false,                // Run even when not charging\n      requiresDeviceIdle: false,              // Run even when device in use\n      requiresStorageNotLow: true,            // Don't run if storage low\n    ),\n    inputData: {\n      'periodic': true,\n    },\n    existingWorkPolicy: ExistingWorkPolicy.replace,  // Replace existing task\n  );\n\n  print('Periodic task registered!');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Advanced Features",
              "content": "\n### 1. Task Constraints\n\n\n### 2. Initial Delay\n\n\n### 3. Backoff Policy\n\n\n**Backoff Example:**\n- First retry: after 30 seconds\n- Second retry: after 60 seconds (exponential)\n- Third retry: after 120 seconds\n\n### 4. Replacing vs Keeping Existing Tasks\n\n\n- **replace**: Cancel old task, register new one\n- **keep**: Keep old task, ignore new registration\n- **append**: Run both (rarely used)\n\n",
              "code": "await Workmanager().registerPeriodicTask(\n  'my-task',\n  'syncData',\n  existingWorkPolicy: ExistingWorkPolicy.replace,  // or .keep, .append\n);",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Keep Background Work Short**\n   - ‚ùå Don't run tasks for > 10 minutes\n   - ‚úÖ Break large work into smaller chunks\n\n2. **Handle Task Failures Gracefully**\n   ```dart\n   try {\n     await _performBackgroundWork();\n     return Future.value(true);  // Success\n   } catch (e) {\n     print('Task failed: $e');\n     return Future.value(false);  // Will retry with backoff\n   }\n   ```\n\n3. **Use Constraints to Save Battery**\n   ```dart\n   // Good: Only sync when on WiFi and charging\n   Constraints(\n     networkType: NetworkType.unmetered,\n     requiresCharging: true,\n   )\n   ```\n\n4. **Don't Rely on Exact Timing**\n   - OS decides when to run tasks\n   - iOS is especially unpredictable\n   - Use for deferrable work only\n\n5. **Test on Real Devices**\n   - Emulators don't accurately simulate background restrictions\n   - Test with low battery, airplane mode, etc.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Common Issues & Solutions",
              "content": "\n**Issue 1: Tasks not running on iOS**\n- **Solution**: iOS is very restrictive. Tasks may not run for hours.\n- BGTaskScheduler runs at system discretion\n- Test with `e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@\"your.identifier\"]` in Xcode debugger\n\n**Issue 2: Tasks running too frequently**\n- **Solution**: Set minimum `frequency: Duration(hours: 1)`\n- Android minimum is 15 minutes, but OS may run less frequently\n\n**Issue 3: Task crashes**\n- **Solution**: Ensure callback is top-level function with `@pragma('vm:entry-point')`\n- Don't access app state directly (use SharedPreferences, SQLite)\n\n**Issue 4: Tasks not running after app force-quit (iOS)**\n- **Solution**: This is expected iOS behavior\n- iOS doesn't guarantee background execution after force-quit\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the minimum interval for periodic tasks on Android?\nA) 1 minute\nB) 5 minutes\nC) 15 minutes\nD) 1 hour\n\n**Question 2:** When should you use `NetworkType.unmetered` constraint?\nA) For all network tasks\nB) For large uploads/downloads to save cellular data\nC) Only on WiFi 6\nD) Never, it's deprecated\n\n**Question 3:** What does returning `false` from a background task do?\nA) Cancels the task permanently\nB) Causes the task to retry with backoff policy\nC) Logs an error\nD) Nothing\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: News App Background Sync",
              "content": "\nBuild a news app that:\n1. Fetches latest news every 2 hours in background\n2. Only syncs on WiFi and when battery not low\n3. Shows badge count for unread articles\n4. Has manual \"Refresh Now\" button\n5. Stores articles in SQLite\n\n**Bonus Challenges:**\n- Send notification when new articles available\n- Clean old articles (older than 7 days) weekly\n- Allow user to configure sync frequency\n- Handle offline mode gracefully\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered background tasks in Flutter! Here's what we covered:\n\n- **Workmanager Setup**: Initialize and configure for Android/iOS\n- **One-Time Tasks**: Run background work once\n- **Periodic Tasks**: Schedule recurring work with constraints\n- **Task Management**: Register, cancel, and handle tasks\n- **Best Practices**: Battery efficiency and platform limitations\n- **Complete App**: Photo backup with auto-sync\n\nWith background tasks, your apps can sync data, perform maintenance, and stay up-to-date even when closed!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** C) 15 minutes\n\nAndroid's WorkManager has a minimum periodic interval of **15 minutes**. You can request more frequent intervals, but the OS will enforce this minimum. This is to preserve battery life and prevent abuse.\n\n**Answer 2:** B) For large uploads/downloads to save cellular data\n\n`NetworkType.unmetered` means WiFi or unlimited data connections (not cellular metered data). Use this for large file operations to avoid expensive cellular data charges for users. For small API calls, `NetworkType.connected` (any connection) is fine.\n\n**Answer 3:** B) Causes the task to retry with backoff policy\n\nReturning `false` signals failure, and WorkManager will automatically retry the task according to the configured `backoffPolicy` (exponential or linear delay). Returning `true` means success - task won't retry.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "9.8",
          "title": "Lesson 8: Mini-Project - Fitness Tracker App",
          "moduleId": "module-09",
          "order": 8,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\nBuild a comprehensive **Fitness Tracker App** that combines all advanced features from Module 9:\n\n- üé® **Animations**: Smooth transitions and progress indicators\n- üì∏ **Camera**: Profile photos and workout photos\n- üíæ **Local Storage**: Hive for settings, SQLite for workout history\n- üó∫Ô∏è **Maps & Location**: Track running routes with GPS\n- üì± **Device Features**: Biometric lock, step counter with accelerometer\n- ‚è∞ **Background Tasks**: Daily reminder notifications\n- üìä **Data Visualization**: Charts showing progress over time\n\nThis is a production-ready app that showcases everything you've learned!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You'll Build",
              "content": "\n### Core Features\n\n1. **User Profile**\n   - Profile photo with camera/gallery\n   - Biometric authentication to protect data\n   - Personal stats (height, weight, age)\n\n2. **Workout Tracking**\n   - Log workouts (running, cycling, gym)\n   - GPS tracking for outdoor activities\n   - Real-time map showing route\n   - Duration, distance, calories burned\n\n3. **Step Counter**\n   - Use accelerometer to count steps\n   - Daily step goal with progress bar\n   - Animated step counter\n\n4. **Workout History**\n   - SQLite database for all workouts\n   - Filter by type, date range\n   - Statistics and charts\n\n5. **Background Reminders**\n   - Daily workout reminder notifications\n   - Sync workout data periodically\n\n"
            },
            {
              "type": "THEORY",
              "title": "Step 1: Dependencies",
              "content": "\n**pubspec.yaml:**\n\nRun:\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 2: Models",
              "content": "\n### User Profile Model\n\n**lib/models/user_profile.dart:**\n\n### Workout Model\n\n**lib/models/workout.dart:**\n\n",
              "code": "class Workout {\n  final int? id;\n  final String type;  // 'running', 'cycling', 'gym', 'walking'\n  final DateTime startTime;\n  final DateTime endTime;\n  final double? distance;  // in km (null for gym workouts)\n  final int calories;\n  final String? notes;\n  final String? routeJson;  // JSON string of LatLng points\n\n  Workout({\n    this.id,\n    required this.type,\n    required this.startTime,\n    required this.endTime,\n    this.distance,\n    required this.calories,\n    this.notes,\n    this.routeJson,\n  });\n\n  Duration get duration => endTime.difference(startTime);\n\n  double? get avgSpeed {\n    if (distance == null || distance == 0) return null;\n    final hours = duration.inMinutes / 60;\n    return distance! / hours;  // km/h\n  }\n\n  Map<String, dynamic> toMap() {\n    return {\n      'id': id,\n      'type': type,\n      'start_time': startTime.millisecondsSinceEpoch,\n      'end_time': endTime.millisecondsSinceEpoch,\n      'distance': distance,\n      'calories': calories,\n      'notes': notes,\n      'route_json': routeJson,\n    };\n  }\n\n  factory Workout.fromMap(Map<String, dynamic> map) {\n    return Workout(\n      id: map['id'],\n      type: map['type'],\n      startTime: DateTime.fromMillisecondsSinceEpoch(map['start_time']),\n      endTime: DateTime.fromMillisecondsSinceEpoch(map['end_time']),\n      distance: map['distance'],\n      calories: map['calories'],\n      notes: map['notes'],\n      routeJson: map['route_json'],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 3: Database Service (SQLite)",
              "content": "\n**lib/services/database_service.dart:**\n\n",
              "code": "import 'package:sqflite/sqflite.dart';\nimport 'package:path/path.dart';\nimport '../models/workout.dart';\n\nclass DatabaseService {\n  static final DatabaseService instance = DatabaseService._internal();\n  factory DatabaseService() => instance;\n  DatabaseService._internal();\n\n  static Database? _database;\n\n  Future<Database> get database async {\n    if (_database != null) return _database!;\n    _database = await _initDatabase();\n    return _database!;\n  }\n\n  Future<Database> _initDatabase() async {\n    final dbPath = await getDatabasesPath();\n    final path = join(dbPath, 'fitness_tracker.db');\n\n    return await openDatabase(\n      path,\n      version: 1,\n      onCreate: _onCreate,\n    );\n  }\n\n  Future<void> _onCreate(Database db, int version) async {\n    await db.execute('''\n      CREATE TABLE workouts (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        type TEXT NOT NULL,\n        start_time INTEGER NOT NULL,\n        end_time INTEGER NOT NULL,\n        distance REAL,\n        calories INTEGER NOT NULL,\n        notes TEXT,\n        route_json TEXT\n      )\n    ''');\n\n    await db.execute('''\n      CREATE TABLE daily_steps (\n        date TEXT PRIMARY KEY,\n        steps INTEGER NOT NULL\n      )\n    ''');\n  }\n\n  // Workout methods\n  Future<int> insertWorkout(Workout workout) async {\n    final db = await database;\n    return await db.insert('workouts', workout.toMap());\n  }\n\n  Future<List<Workout>> getAllWorkouts() async {\n    final db = await database;\n    final maps = await db.query('workouts', orderBy: 'start_time DESC');\n    return maps.map((map) => Workout.fromMap(map)).toList();\n  }\n\n  Future<List<Workout>> getWorkoutsByType(String type) async {\n    final db = await database;\n    final maps = await db.query(\n      'workouts',\n      where: 'type = ?',\n      whereArgs: [type],\n      orderBy: 'start_time DESC',\n    );\n    return maps.map((map) => Workout.fromMap(map)).toList();\n  }\n\n  Future<List<Workout>> getWorkoutsInDateRange(DateTime start, DateTime end) async {\n    final db = await database;\n    final maps = await db.query(\n      'workouts',\n      where: 'start_time >= ? AND start_time <= ?',\n      whereArgs: [start.millisecondsSinceEpoch, end.millisecondsSinceEpoch],\n      orderBy: 'start_time DESC',\n    );\n    return maps.map((map) => Workout.fromMap(map)).toList();\n  }\n\n  Future<int> deleteWorkout(int id) async {\n    final db = await database;\n    return await db.delete('workouts', where: 'id = ?', whereArgs: [id]);\n  }\n\n  // Step counter methods\n  Future<void> saveDailySteps(String date, int steps) async {\n    final db = await database;\n    await db.insert(\n      'daily_steps',\n      {'date': date, 'steps': steps},\n      conflictAlgorithm: ConflictAlgorithm.replace,\n    );\n  }\n\n  Future<int?> getStepsForDate(String date) async {\n    final db = await database;\n    final results = await db.query(\n      'daily_steps',\n      where: 'date = ?',\n      whereArgs: [date],\n    );\n\n    return results.isNotEmpty ? results.first['steps'] as int : null;\n  }\n\n  Future<Map<String, int>> getStepsForWeek() async {\n    final db = await database;\n    final now = DateTime.now();\n    final weekAgo = now.subtract(Duration(days: 7));\n\n    final results = await db.query(\n      'daily_steps',\n      where: 'date >= ?',\n      whereArgs: [weekAgo.toIso8601String().split('T')[0]],\n      orderBy: 'date ASC',\n    );\n\n    return {\n      for (var row in results) row['date'] as String: row['steps'] as int\n    };\n  }\n\n  // Statistics\n  Future<Map<String, dynamic>> getWorkoutStats() async {\n    final db = await database;\n\n    final totalWorkouts = Sqflite.firstIntValue(\n      await db.rawQuery('SELECT COUNT(*) FROM workouts'),\n    ) ?? 0;\n\n    final totalDistance = (await db.rawQuery(\n      'SELECT SUM(distance) as total FROM workouts WHERE distance IS NOT NULL',\n    ))[0]['total'] ?? 0.0;\n\n    final totalCalories = Sqflite.firstIntValue(\n      await db.rawQuery('SELECT SUM(calories) FROM workouts'),\n    ) ?? 0;\n\n    final workoutsByType = await db.rawQuery('''\n      SELECT type, COUNT(*) as count\n      FROM workouts\n      GROUP BY type\n      ORDER BY count DESC\n    ''');\n\n    return {\n      'totalWorkouts': totalWorkouts,\n      'totalDistance': totalDistance,\n      'totalCalories': totalCalories,\n      'workoutsByType': workoutsByType,\n    };\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 4: Main App Setup",
              "content": "\n**lib/main.dart:**\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:hive_flutter/hive_flutter.dart';\nimport 'package:workmanager/workmanager.dart';\nimport 'models/user_profile.dart';\nimport 'screens/home_screen.dart';\nimport 'screens/profile_screen.dart';\nimport 'services/database_service.dart';\n\n// Background task callback\n@pragma('vm:entry-point')\nvoid callbackDispatcher() {\n  Workmanager().executeTask((task, inputData) async {\n    switch (task) {\n      case 'dailyReminder':\n        // In real app: trigger local notification\n        print('‚è∞ Daily workout reminder!');\n        break;\n      case 'syncData':\n        // In real app: sync to cloud\n        print('‚òÅÔ∏è Syncing workout data...');\n        break;\n    }\n\n    return Future.value(true);\n  });\n}\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  // Initialize Hive\n  await Hive.initFlutter();\n  Hive.registerAdapter(UserProfileAdapter());\n  await Hive.openBox<UserProfile>('profile');\n  await Hive.openBox('settings');\n\n  // Initialize SQLite\n  await DatabaseService().database;\n\n  // Initialize Workmanager\n  await Workmanager().initialize(callbackDispatcher, isInDebugMode: true);\n\n  // Register daily reminder (8 AM every day)\n  await Workmanager().registerPeriodicTask(\n    'daily-reminder',\n    'dailyReminder',\n    frequency: Duration(hours: 24),\n    initialDelay: _calculateDelayUntil8AM(),\n  );\n\n  runApp(FitnessTrackerApp());\n}\n\nDuration _calculateDelayUntil8AM() {\n  final now = DateTime.now();\n  var next8AM = DateTime(now.year, now.month, now.day, 8, 0);\n\n  if (now.isAfter(next8AM)) {\n    next8AM = next8AM.add(Duration(days: 1));\n  }\n\n  return next8AM.difference(now);\n}\n\nclass FitnessTrackerApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Fitness Tracker',\n      debugShowCheckedModeBanner: false,\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),\n        useMaterial3: true,\n      ),\n      darkTheme: ThemeData.dark(useMaterial3: true),\n      home: HomeScreen(),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 5: Home Screen with Step Counter",
              "content": "\n**lib/screens/home_screen.dart:**\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:sensors_plus/sensors_plus.dart';\nimport 'package:intl/intl.dart';\nimport 'dart:async';\nimport '../services/database_service.dart';\n\nclass HomeScreen extends StatefulWidget {\n  @override\n  State<HomeScreen> createState() => _HomeScreenState();\n}\n\nclass _HomeScreenState extends State<HomeScreen> with TickerProviderStateMixin {\n  int _todaySteps = 0;\n  int _stepGoal = 10000;\n  StreamSubscription? _accelerometerSubscription;\n  List<double> _recentAcceleration = [];\n\n  late AnimationController _progressController;\n  late Animation<double> _progressAnimation;\n\n  @override\n  void initState() {\n    super.initState();\n\n    _progressController = AnimationController(\n      vsync: this,\n      duration: Duration(milliseconds: 1000),\n    );\n\n    _progressAnimation = Tween<double>(begin: 0, end: 0).animate(\n      CurvedAnimation(parent: _progressController, curve: Curves.easeInOut),\n    );\n\n    _loadTodaySteps();\n    _startStepCounter();\n  }\n\n  @override\n  void dispose() {\n    _accelerometerSubscription?.cancel();\n    _progressController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _loadTodaySteps() async {\n    final today = DateFormat('yyyy-MM-dd').format(DateTime.now());\n    final steps = await DatabaseService().getStepsForDate(today);\n\n    setState(() {\n      _todaySteps = steps ?? 0;\n      _updateProgress();\n    });\n  }\n\n  void _updateProgress() {\n    final progress = (_todaySteps / _stepGoal).clamp(0.0, 1.0);\n\n    _progressAnimation = Tween<double>(\n      begin: _progressAnimation.value,\n      end: progress,\n    ).animate(\n      CurvedAnimation(parent: _progressController, curve: Curves.easeInOut),\n    );\n\n    _progressController.reset();\n    _progressController.forward();\n  }\n\n  void _startStepCounter() {\n    _accelerometerSubscription = accelerometerEventStream().listen((event) {\n      final magnitude = (event.x * event.x + event.y * event.y + event.z * event.z);\n\n      _recentAcceleration.add(magnitude);\n      if (_recentAcceleration.length > 10) {\n        _recentAcceleration.removeAt(0);\n      }\n\n      // Simple step detection: detect peaks in acceleration\n      if (_recentAcceleration.length == 10) {\n        final avg = _recentAcceleration.reduce((a, b) => a + b) / _recentAcceleration.length;\n\n        if (magnitude > avg * 1.5 && magnitude > 150) {\n          setState(() {\n            _todaySteps++;\n            _updateProgress();\n          });\n\n          _saveTodaySteps();\n        }\n      }\n    });\n  }\n\n  Future<void> _saveTodaySteps() async {\n    final today = DateFormat('yyyy-MM-dd').format(DateTime.now());\n    await DatabaseService().saveDailySteps(today, _todaySteps);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Fitness Tracker'),\n        actions: [\n          IconButton(\n            icon: Icon(Icons.person),\n            onPressed: () {\n              Navigator.push(\n                context,\n                MaterialPageRoute(builder: (_) => ProfileScreen()),\n              );\n            },\n          ),\n        ],\n      ),\n      body: SingleChildScrollView(\n        padding: EdgeInsets.all(16),\n        child: Column(\n          children: [\n            // Animated Step Counter\n            AnimatedBuilder(\n              animation: _progressAnimation,\n              builder: (context, child) {\n                return CustomPaint(\n                  size: Size(200, 200),\n                  painter: CircularProgressPainter(\n                    progress: _progressAnimation.value,\n                    color: Theme.of(context).primaryColor,\n                  ),\n                  child: Container(\n                    width: 200,\n                    height: 200,\n                    child: Center(\n                      child: Column(\n                        mainAxisAlignment: MainAxisAlignment.center,\n                        children: [\n                          Text(\n                            '$_todaySteps',\n                            style: TextStyle(\n                              fontSize: 48,\n                              fontWeight: FontWeight.bold,\n                            ),\n                          ),\n                          Text(\n                            'steps',\n                            style: TextStyle(\n                              fontSize: 18,\n                              color: Colors.grey,\n                            ),\n                          ),\n                          SizedBox(height: 8),\n                          Text(\n                            'Goal: $_stepGoal',\n                            style: TextStyle(fontSize: 14, color: Colors.grey),\n                          ),\n                        ],\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n\n            SizedBox(height: 40),\n\n            // Quick Actions\n            _buildQuickActionButton(\n              icon: Icons.directions_run,\n              label: 'Start Running',\n              color: Colors.blue,\n              onTap: () {\n                // Navigate to workout tracker\n                ScaffoldMessenger.of(context).showSnackBar(\n                  SnackBar(content: Text('Starting workout tracker...')),\n                );\n              },\n            ),\n\n            SizedBox(height: 12),\n\n            _buildQuickActionButton(\n              icon: Icons.history,\n              label: 'Workout History',\n              color: Colors.green,\n              onTap: () {\n                // Navigate to history\n              },\n            ),\n\n            SizedBox(height: 12),\n\n            _buildQuickActionButton(\n              icon: Icons.bar_chart,\n              label: 'Statistics',\n              color: Colors.orange,\n              onTap: () {\n                // Navigate to stats\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildQuickActionButton({\n    required IconData icon,\n    required String label,\n    required Color color,\n    required VoidCallback onTap,\n  }) {\n    return Card(\n      child: InkWell(\n        onTap: onTap,\n        borderRadius: BorderRadius.circular(12),\n        child: Padding(\n          padding: EdgeInsets.all(16),\n          child: Row(\n            children: [\n              Container(\n                padding: EdgeInsets.all(12),\n                decoration: BoxDecoration(\n                  color: color.withOpacity(0.1),\n                  borderRadius: BorderRadius.circular(12),\n                ),\n                child: Icon(icon, color: color, size: 32),\n              ),\n              SizedBox(width: 16),\n              Text(\n                label,\n                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n              ),\n              Spacer(),\n              Icon(Icons.arrow_forward_ios, size: 16, color: Colors.grey),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Custom painter for circular progress\nclass CircularProgressPainter extends CustomPainter {\n  final double progress;\n  final Color color;\n\n  CircularProgressPainter({required this.progress, required this.color});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 2;\n\n    // Background circle\n    final bgPaint = Paint()\n      ..color = color.withOpacity(0.1)\n      ..strokeWidth = 20\n      ..style = PaintingStyle.stroke;\n\n    canvas.drawCircle(center, radius - 10, bgPaint);\n\n    // Progress arc\n    final progressPaint = Paint()\n      ..color = color\n      ..strokeWidth = 20\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round;\n\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius - 10),\n      -90 * (3.14159 / 180),  // Start at top\n      progress * 360 * (3.14159 / 180),  // Sweep angle\n      false,\n      progressPaint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(CircularProgressPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Features Implementation Summary",
              "content": "\n### ‚úÖ Animations\n- Circular progress ring with smooth animation\n- Hero transitions between screens (implement in navigation)\n\n### ‚úÖ Camera & Gallery\n- Profile photo picker (implement in ProfileScreen)\n- Workout photo attachments\n\n### ‚úÖ Local Storage\n- **Hive**: User profile and settings\n- **SQLite**: Workout history and step data\n\n### ‚úÖ Maps & Location\n- GPS route tracking during workouts\n- Display route on Google Maps\n\n### ‚úÖ Device Features\n- **Accelerometer**: Step counting algorithm\n- **Biometric Auth**: Lock profile screen\n\n### ‚úÖ Background Tasks\n- Daily workout reminders at 8 AM\n- Periodic data sync\n\n"
            },
            {
              "type": "THEORY",
              "title": "Complete Implementation Checklist",
              "content": "\nBuild the remaining screens:\n\n1. ‚úÖ **Home Screen** (completed above)\n2. **Profile Screen**\n   - Edit profile info\n   - Change profile photo with camera/gallery\n   - Enable biometric lock\n   - BMI calculator\n\n3. **Workout Tracker Screen**\n   - Start/stop workout timer\n   - Track GPS route in real-time\n   - Calculate distance and calories\n   - Save workout to database\n\n4. **Workout History Screen**\n   - List all workouts from SQLite\n   - Filter by type and date\n   - Delete workouts\n   - View workout details with map\n\n5. **Statistics Screen**\n   - Charts showing progress over time\n   - Total distance, calories, workouts\n   - Weekly step counts\n\n"
            },
            {
              "type": "THEORY",
              "title": "Testing Your App",
              "content": "\n### Test Checklist\n\n- [ ] Profile photo picker works (camera & gallery)\n- [ ] Biometric lock activates correctly\n- [ ] Step counter increments when walking\n- [ ] SQLite stores workouts persistently\n- [ ] GPS tracking shows route on map\n- [ ] Background task runs at scheduled time\n- [ ] App survives app restart (data persists)\n- [ ] Animations are smooth (60 FPS)\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nCongratulations! You've built a comprehensive **Fitness Tracker App** that demonstrates:\n\n- üé® **Advanced animations** for engaging UX\n- üì∏ **Camera integration** for profile photos\n- üíæ **Dual storage** with Hive and SQLite\n- üó∫Ô∏è **GPS tracking** with real-time maps\n- üì± **Device sensors** for step counting\n- üîí **Biometric security** for privacy\n- ‚è∞ **Background tasks** for reminders\n\nThis capstone project showcases production-ready Flutter development skills!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Module 9 Complete! üéâ",
              "content": "\nYou've mastered **Advanced Flutter Features**:\n\n1. ‚úÖ Animations (implicit & explicit)\n2. ‚úÖ Camera & Gallery access\n3. ‚úÖ Local storage (Hive & SharedPreferences)\n4. ‚úÖ SQLite database\n5. ‚úÖ Maps & Location services\n6. ‚úÖ Device sensors & biometrics\n7. ‚úÖ Background tasks\n8. ‚úÖ Complete mini-project\n\n**Next Steps:**\n- Deploy your app to Google Play / App Store\n- Add Firebase for cloud sync\n- Implement social features (share workouts)\n- Add widget support for home screen\n\nYou're now ready to build professional, feature-rich Flutter applications! üöÄ\n\n"
            }
          ],
          "challenges": []
        }
      ]
    },
    {
      "id": "module-10",
      "title": "Module 10: Flutter Development",
      "description": "Learn Flutter development - Module 10",
      "difficulty": "advanced",
      "estimatedHours": 9,
      "lessons": [
        {
          "id": "10.1",
          "title": "Module 10: Testing - Complete Lesson Structure",
          "moduleId": "module-10",
          "order": 1,
          "estimatedMinutes": 20,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "All Lessons Complete ‚úÖ",
              "content": "\n### Lesson 1: Introduction to Testing ‚úÖ\n- Understanding the testing pyramid\n- Unit tests, widget tests, integration tests\n- AAA pattern (Arrange, Act, Assert)\n- Setting up test environment\n- Writing your first tests\n\n### Lesson 2: Widget Testing ‚úÖ\n- Testing Flutter widgets\n- WidgetTester and pump methods\n- Finding widgets (find.text, find.byKey, find.byType)\n- Simulating user interactions\n- Testing forms and validation\n\n### Lesson 3: Mocking Dependencies ‚úÖ\n- Using mocktail package (v1.0.4)\n- Creating mocks without code generation\n- Mocking API calls and services\n- Verify method calls with verification\n- Stubbing return values with when/thenAnswer\n\n### Lesson 4: Integration Testing ‚úÖ\n- Using integration_test package\n- IntegrationTestWidgetsFlutterBinding\n- Testing complete user flows across multiple screens\n- Running tests on physical devices/emulators\n- Testing navigation, forms, and multi-screen interactions\n\n### Lesson 5: End-to-End Testing with Firebase Test Lab ‚úÖ\n- Setting up Firebase Test Lab\n- Building and uploading test APKs and iOS test bundles\n- Running tests on hundreds of real devices in the cloud\n- Robo tests for automated UI exploration\n- Analyzing test results and device-specific issues\n- Integrating Test Lab into CI/CD pipelines\n\n### Lesson 6: Test Coverage and Reporting ‚úÖ\n- Generating coverage reports with flutter test --coverage\n- Understanding coverage metrics (line, function, branch)\n- Using lcov and genhtml for HTML reports\n- Excluding generated files from coverage\n- Visualizing coverage in VSCode\n- Setting coverage targets and enforcing them in CI/CD\n- Best practices for improving coverage strategically\n\n### Lesson 7: CI/CD for Flutter Apps ‚úÖ\n- Understanding Continuous Integration and Deployment\n- Setting up GitHub Actions workflows\n- Configuring Codemagic for Flutter-first CI/CD\n- Implementing quality gates (linting, testing, coverage)\n- Automating builds and deployments\n- Running Firebase Test Lab in CI/CD\n- Deploying to TestFlight and Google Play automatically\n\n### Lesson 8: Testing Best Practices Mini-Project ‚úÖ\n- Complete TaskMaster Pro application\n- Comprehensive test suite (unit, widget, integration)\n- 80%+ test coverage\n- Full CI/CD pipeline with GitHub Actions\n- Automated coverage reporting\n- Production-ready testing practices\n- Portfolio-quality project demonstrating testing expertise\n\n"
            },
            {
              "type": "THEORY",
              "title": "Module 10 Complete! üéâ",
              "content": "\nThis module provides a complete, production-ready testing education covering:\n- **Unit Testing**: Test individual functions and logic\n- **Widget Testing**: Test UI components in isolation\n- **Integration Testing**: Test complete user workflows\n- **Mocking**: Isolate code from dependencies\n- **Coverage**: Measure and improve test effectiveness\n- **Firebase Test Lab**: Test on hundreds of real devices\n- **CI/CD**: Automate testing and deployment\n- **Best Practices**: Build maintainable, reliable test suites\n\nStudents completing this module will have professional-level testing skills ready for production Flutter development.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.2",
          "title": "Watch mode (re-run on file changes)",
          "moduleId": "module-10",
          "order": 2,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Why testing matters in app development\n- Types of tests (unit, widget, integration)\n- Test-Driven Development (TDD) basics\n- Setting up your testing environment\n- Writing your first test\n- The testing pyramid\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: Why Test Your Code?",
              "content": "\n### Real-World Analogy\nThink of testing like a **safety inspection for a building**:\n- **Unit Tests** = Checking individual bricks (do they meet quality standards?)\n- **Widget Tests** = Testing rooms (do doors open, do lights work?)\n- **Integration Tests** = Full building walkthrough (does everything work together?)\n\nJust like you wouldn't move into a building without inspections, you shouldn't ship an app without tests!\n\n### Why This Matters\nTesting prevents disasters:\n\n1. **Catch Bugs Early**: Find issues before users do\n2. **Confidence to Refactor**: Change code without fear of breaking things\n3. **Documentation**: Tests show how code should work\n4. **Faster Development**: Automated tests are faster than manual testing\n5. **Better Design**: Testable code is usually better code\n\nAccording to Google, apps with >80% test coverage have **56% fewer production bugs** and **40% faster feature development** over time!\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Testing Pyramid",
              "content": "\n\n**The Golden Rule:**\n- **70%** Unit Tests (fast, isolated)\n- **20%** Widget Tests (UI components)\n- **10%** Integration Tests (full app flows)\n\n",
              "code": "         /\\\n        /  \\  Few, Slow, Expensive\n       /E2E \\  (Integration Tests)\n      /______\\\n     /        \\\n    / Widget  \\ Some, Medium Speed\n   /   Tests   \\\n  /____________\\\n /              \\\n/  Unit Tests    \\ Many, Fast, Cheap\n/__________________\\",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Types of Tests",
              "content": "\n### 1. Unit Tests\n**What:** Test individual functions, methods, or classes in isolation\n\n**Example:** Testing a function that calculates BMI\n\n**When to Use:**\n- Business logic\n- Calculations\n- Data transformations\n- Utility functions\n\n### 2. Widget Tests\n**What:** Test UI components (widgets) in isolation\n\n**Example:** Testing if a button shows correct text\n\n**When to Use:**\n- Button interactions\n- Form validation\n- Navigation\n- Widget rendering\n\n### 3. Integration Tests\n**What:** Test complete app flows on real devices/emulators\n\n**Example:** Testing login ‚Üí home ‚Üí logout flow\n\n**When to Use:**\n- Critical user flows\n- End-to-end features\n- Multi-screen interactions\n- External dependencies (API, database)\n\n",
              "code": "testWidgets('Complete user journey', (tester) async {\n  app.main();\n  await tester.pumpAndSettle();\n\n  // Login\n  await tester.enterText(find.byKey(Key('email')), 'test@example.com');\n  await tester.enterText(find.byKey(Key('password')), 'password123');\n  await tester.tap(find.text('Login'));\n  await tester.pumpAndSettle();\n\n  // Verify home screen\n  expect(find.text('Welcome'), findsOneWidget);\n\n  // Logout\n  await tester.tap(find.byIcon(Icons.logout));\n  await tester.pumpAndSettle();\n\n  // Verify back to login\n  expect(find.text('Login'), findsOneWidget);\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Testing",
              "content": "\n### Default Test Setup\n\nFlutter projects come with testing built-in! No extra setup needed for basic tests.\n\n**pubspec.yaml** (already includes):\n\n### Test File Structure\n\n\n**Convention:** Test files mirror your `lib/` structure with `_test.dart` suffix.\n\n",
              "code": "my_app/\n‚îú‚îÄ‚îÄ lib/\n‚îÇ   ‚îú‚îÄ‚îÄ main.dart\n‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.dart\n‚îÇ   ‚îî‚îÄ‚îÄ services/\n‚îÇ       ‚îî‚îÄ‚îÄ auth_service.dart\n‚îú‚îÄ‚îÄ test/                    # Unit & Widget tests\n‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user_test.dart   # Naming: <file>_test.dart\n‚îÇ   ‚îî‚îÄ‚îÄ services/\n‚îÇ       ‚îî‚îÄ‚îÄ auth_service_test.dart\n‚îî‚îÄ‚îÄ integration_test/        # Integration tests\n    ‚îî‚îÄ‚îÄ app_test.dart",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Unit Test",
              "content": "\n### Example: Testing a Calculator\n\n**lib/utils/calculator.dart:**\n\n**test/utils/calculator_test.dart:**\n\n### Running Tests\n\n\n**Output:**\n\n",
              "code": "00:01 +6: All tests passed!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Test Anatomy",
              "content": "\n### Basic Structure\n\n\n**AAA Pattern:**\n- **Arrange**: Set up test data and preconditions\n- **Act**: Execute the code under test\n- **Assert**: Verify the outcome\n\n### Common Matchers\n\n\n",
              "code": "// Equality\nexpect(actual, equals(expected));\nexpect(actual, expected);  // Shorthand\n\n// Numerical\nexpect(value, greaterThan(10));\nexpect(value, lessThan(100));\nexpect(value, inRange(10, 20));\nexpect(3.14159, closeTo(3.14, 0.01));  // For floats\n\n// Types\nexpect(value, isA<String>());\nexpect(value, isNotNull);\nexpect(value, isNull);\n\n// Collections\nexpect(list, contains(5));\nexpect(list, containsAll([1, 2, 3]));\nexpect(list, isEmpty);\nexpect(list, hasLength(3));\n\n// Strings\nexpect(text, startsWith('Hello'));\nexpect(text, endsWith('World'));\nexpect(text, matches(RegExp(r'\\d+')));  // Regex\n\n// Exceptions\nexpect(() => throwsError(), throwsException);\nexpect(() => divideByZero(), throwsA(isA<ArgumentError>()));",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Test Organization",
              "content": "\n### Using `group()`\n\nGroup related tests together:\n\n\n**Output:**\n\n### Setup and Teardown\n\n\n",
              "code": "void main() {\n  late Database database;\n\n  // Runs ONCE before all tests\n  setUpAll(() {\n    print('Setting up test suite...');\n  });\n\n  // Runs BEFORE EACH test\n  setUp(() {\n    database = Database.inMemory();\n  });\n\n  // Runs AFTER EACH test\n  tearDown(() {\n    database.close();\n  });\n\n  // Runs ONCE after all tests\n  tearDownAll(() {\n    print('Cleaning up test suite...');\n  });\n\n  test('insert adds record', () {\n    database.insert('users', {'name': 'Alice'});\n    expect(database.count('users'), 1);\n  });\n\n  test('delete removes record', () {\n    database.insert('users', {'name': 'Bob'});\n    database.delete('users', 1);\n    expect(database.count('users'), 0);\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Test-Driven Development (TDD)",
              "content": "\n### The Red-Green-Refactor Cycle\n\n1. **Red**: Write a failing test first\n2. **Green**: Write minimal code to make it pass\n3. **Refactor**: Improve code while keeping tests green\n\n**Example: Building a Todo List**\n\n**Step 1: Red (Write failing test)**\n\n**Step 2: Green (Make it pass)**\n\n**Step 3: Refactor (Improve if needed)**\n\n**Benefits of TDD:**\n- ‚úÖ Forces you to think about requirements first\n- ‚úÖ Ensures every feature has tests\n- ‚úÖ Prevents over-engineering\n- ‚úÖ Immediate feedback loop\n\n",
              "code": "class Todo {\n  final String title;\n  final bool isCompleted;\n\n  Todo(this.title, {this.isCompleted = false});\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: BMI Calculator",
              "content": "\n**lib/models/bmi_calculator.dart:**\n\n**test/models/bmi_calculator_test.dart:**\n\n**Run the tests:**\n\n**Output:**\n\n",
              "code": "00:01 +12: All tests passed!",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Test Names Should Be Descriptive**\n   ```dart\n   // ‚ùå Bad\n   test('test1', () { /* ... */ });\n\n   // ‚úÖ Good\n   test('calculateBMI returns correct value for normal inputs', () { /* ... */ });\n   ```\n\n2. **One Assertion Per Test (Usually)**\n   ```dart\n   // ‚ùå Bad - testing multiple things\n   test('user validation', () {\n     expect(user.isValidEmail(), true);\n     expect(user.isValidAge(), true);\n     expect(user.isValidName(), true);\n   });\n\n   // ‚úÖ Good - separate tests\n   test('validates email format correctly', () {\n     expect(user.isValidEmail(), true);\n   });\n\n   test('validates age is positive', () {\n     expect(user.isValidAge(), true);\n   });\n   ```\n\n3. **Test Edge Cases**\n   - Zero, negative, null values\n   - Empty strings, empty lists\n   - Boundary values (min, max)\n   - Unexpected inputs\n\n4. **Keep Tests Fast**\n   - Unit tests should run in milliseconds\n   - Avoid file I/O, network calls, delays\n   - Use mocks for external dependencies\n\n5. **Tests Should Be Independent**\n   - No shared state between tests\n   - Tests can run in any order\n   - Each test sets up its own data\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** In the testing pyramid, which type of test should you have the most of?\nA) Integration tests\nB) Widget tests\nC) Unit tests\nD) E2E tests\n\n**Question 2:** What does the `setUp()` function do?\nA) Runs once before all tests\nB) Runs before each individual test\nC) Runs after each test\nD) Runs only when tests fail\n\n**Question 3:** Which matcher would you use to test if a float is approximately equal?\nA) equals()\nB) closeTo()\nC) approximately()\nD) near()\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Test a Shopping Cart",
              "content": "\nCreate a `ShoppingCart` class with these methods:\n- `addItem(String name, double price)`\n- `removeItem(String name)`\n- `getTotal()`\n- `applyDiscount(double percentage)`\n\nWrite comprehensive unit tests covering:\n1. Adding items increases total\n2. Removing items decreases total\n3. Discount is applied correctly\n4. Edge cases (empty cart, removing non-existent item, 100% discount)\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've learned the fundamentals of testing in Flutter! Here's what we covered:\n\n- **Testing Pyramid**: 70% unit, 20% widget, 10% integration\n- **Test Types**: Unit (functions), Widget (UI), Integration (full app)\n- **Test Structure**: AAA pattern (Arrange, Act, Assert)\n- **Test Organization**: `group()`, `setUp()`, `tearDown()`\n- **TDD**: Red-Green-Refactor cycle\n- **Best Practices**: Descriptive names, fast tests, edge cases\n\nTesting may seem like extra work, but it **saves time** and **prevents bugs** in the long run!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** C) Unit tests\n\nThe testing pyramid recommends having the most unit tests (~70%) because they're fast, cheap, and test individual pieces of logic in isolation. Widget tests should be ~20% and integration tests ~10%.\n\n**Answer 2:** B) Runs before each individual test\n\n`setUp()` runs before EACH test in the group. Use `setUpAll()` to run once before all tests, `tearDown()` to run after each test, and `tearDownAll()` to run once after all tests.\n\n**Answer 3:** B) closeTo()\n\n`closeTo(expected, delta)` is used for floating-point comparisons because of precision issues. Example: `expect(3.14159, closeTo(3.14, 0.01))` checks if the value is within 0.01 of 3.14.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.3",
          "title": "Lesson 2: Widget Testing",
          "moduleId": "module-10",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Testing Flutter widgets\n- Using WidgetTester (pumping, finding, tapping)\n- Testing user interactions\n- Testing navigation\n- Testing forms and validation\n- Golden tests for visual regression\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: What Are Widget Tests?",
              "content": "\n### Real-World Analogy\nWidget testing is like **quality checking furniture in a showroom**:\n- **Does the button work?** (interaction testing)\n- **Does the drawer open smoothly?** (animation testing)\n- **Does it look right?** (visual testing)\n- **Does everything fit together?** (layout testing)\n\nYou test each piece of furniture (widget) in isolation before assembling the whole room (app).\n\n### Why This Matters\nWidget tests verify your UI works correctly:\n\n1. **User Interactions**: Buttons, taps, gestures\n2. **Visual Appearance**: Colors, fonts, layouts\n3. **State Changes**: UI updates when data changes\n4. **Navigation**: Screen transitions work\n5. **Forms**: Input validation and submission\n\nWidget tests run faster than integration tests but provide more confidence than unit tests!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Widget Testing Basics",
              "content": "\n### Your First Widget Test\n\n**lib/widgets/counter_widget.dart:**\n\n**test/widgets/counter_widget_test.dart:**\n\n### Key Concepts\n\n**`testWidgets()`**: Creates a widget test (like `test()` for unit tests)\n\n**`WidgetTester`**: Provides tools to interact with widgets\n- `pump()`: Rebuild widgets once\n- `pumpAndSettle()`: Wait for all animations to complete\n- `tap()`: Simulate user tap\n- `enterText()`: Type into text fields\n\n**`find`**: Locate widgets on screen\n- `find.text('Hello')`: Find by text\n- `find.byType(ElevatedButton)`: Find by widget type\n- `find.byKey(Key('my_key'))`: Find by key\n- `find.byIcon(Icons.add)`: Find by icon\n\n**`expect()`**: Assert what you found\n- `findsOneWidget`: Exactly one match\n- `findsNothing`: No matches\n- `findsNWidgets(3)`: Exactly 3 matches\n- `findsWidgets`: At least one match\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:my_app/widgets/counter_widget.dart';\n\nvoid main() {\n  testWidgets('Counter increments when button is tapped', (WidgetTester tester) async {\n    // 1. ARRANGE: Build the widget\n    await tester.pumpWidget(\n      MaterialApp(\n        home: Scaffold(\n          body: CounterWidget(),\n        ),\n      ),\n    );\n\n    // 2. ASSERT: Verify initial state\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    // 3. ACT: Tap the button\n    await tester.tap(find.text('Increment'));\n    await tester.pump();  // Rebuild after state change\n\n    // 4. ASSERT: Verify state changed\n    expect(find.text('0'), findsNothing);\n    expect(find.text('1'), findsOneWidget);\n\n    // Tap again\n    await tester.tap(find.text('Increment'));\n    await tester.pump();\n\n    expect(find.text('2'), findsOneWidget);\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Finding Widgets",
              "content": "\n### Different Ways to Find Widgets\n\n\n### Using Keys for Reliable Tests\n\n\n**Why keys?**\n- Text can change (translations, dynamic content)\n- Widget types can be duplicated\n- Keys provide stable references\n\n",
              "code": "// ‚úÖ Good - using keys\nText('Welcome', key: Key('welcome_text'));\nElevatedButton(\n  key: Key('login_button'),\n  onPressed: () {},\n  child: Text('Login'),\n);\n\n// In test\nexpect(find.byKey(Key('welcome_text')), findsOneWidget);\nawait tester.tap(find.byKey(Key('login_button')));",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Interacting with Widgets",
              "content": "\n### Tapping Buttons\n\n\n### Entering Text\n\n\n### Scrolling\n\n\n### Long Press\n\n\n### Drag and Swipe\n\n\n",
              "code": "testWidgets('Can swipe to dismiss', (tester) async {\n  bool dismissed = false;\n\n  await tester.pumpWidget(\n    MaterialApp(\n      home: Scaffold(\n        body: Dismissible(\n          key: Key('dismissible'),\n          onDismissed: (_) => dismissed = true,\n          child: Container(\n            height: 100,\n            color: Colors.blue,\n            child: Text('Swipe me'),\n          ),\n        ),\n      ),\n    ),\n  );\n\n  // Swipe from left to right\n  await tester.drag(find.byKey(Key('dismissible')), Offset(500, 0));\n  await tester.pumpAndSettle();  // Wait for animation\n\n  expect(dismissed, true);\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Testing Forms",
              "content": "\n### Complete Form Example\n\n**lib/screens/login_screen.dart:**\n\n**test/screens/login_screen_test.dart:**\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:my_app/screens/login_screen.dart';\n\nvoid main() {\n  group('LoginScreen', () {\n    testWidgets('shows email and password fields', (tester) async {\n      await tester.pumpWidget(\n        MaterialApp(home: LoginScreen()),\n      );\n\n      expect(find.byKey(Key('email')), findsOneWidget);\n      expect(find.byKey(Key('password')), findsOneWidget);\n      expect(find.byKey(Key('login_button')), findsOneWidget);\n    });\n\n    testWidgets('validates empty email', (tester) async {\n      await tester.pumpWidget(\n        MaterialApp(home: LoginScreen()),\n      );\n\n      // Tap login without entering anything\n      await tester.tap(find.byKey(Key('login_button')));\n      await tester.pump();\n\n      // Should show validation error\n      expect(find.text('Please enter email'), findsOneWidget);\n    });\n\n    testWidgets('validates invalid email format', (tester) async {\n      await tester.pumpWidget(\n        MaterialApp(home: LoginScreen()),\n      );\n\n      // Enter invalid email\n      await tester.enterText(find.byKey(Key('email')), 'notanemail');\n      await tester.tap(find.byKey(Key('login_button')));\n      await tester.pump();\n\n      expect(find.text('Invalid email format'), findsOneWidget);\n    });\n\n    testWidgets('validates password length', (tester) async {\n      await tester.pumpWidget(\n        MaterialApp(home: LoginScreen()),\n      );\n\n      await tester.enterText(find.byKey(Key('email')), 'test@example.com');\n      await tester.enterText(find.byKey(Key('password')), '123');\n      await tester.tap(find.byKey(Key('login_button')));\n      await tester.pump();\n\n      expect(find.text('Password must be at least 6 characters'), findsOneWidget);\n    });\n\n    testWidgets('calls onLogin with valid credentials', (tester) async {\n      String? capturedEmail;\n      String? capturedPassword;\n\n      await tester.pumpWidget(\n        MaterialApp(\n          home: LoginScreen(\n            onLogin: (email, password) {\n              capturedEmail = email;\n              capturedPassword = password;\n            },\n          ),\n        ),\n      );\n\n      // Enter valid credentials\n      await tester.enterText(find.byKey(Key('email')), 'test@example.com');\n      await tester.enterText(find.byKey(Key('password')), 'password123');\n      await tester.tap(find.byKey(Key('login_button')));\n      await tester.pump();\n\n      // Should call onLogin callback\n      expect(capturedEmail, 'test@example.com');\n      expect(capturedPassword, 'password123');\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Pump Methods",
              "content": "\n### Understanding Pump Variants\n\n\n**When to use which:**\n- `pump()`: After state changes with no animations\n- `pump(Duration)`: To test specific animation frames\n- `pumpAndSettle()`: After navigation, dialogs, or complex animations\n\n",
              "code": "// pump(): Rebuild once\nawait tester.pump();\n\n// pump(Duration): Advance time and rebuild\nawait tester.pump(Duration(milliseconds: 500));\n\n// pumpAndSettle(): Rebuild until animations finish (default 10 minutes timeout)\nawait tester.pumpAndSettle();\n\n// pumpAndSettle(Duration): With custom timeout\nawait tester.pumpAndSettle(Duration(seconds: 5));",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Golden Tests (Visual Regression)",
              "content": "\nTest that UI looks exactly as expected by comparing screenshots.\n\n\n**Generate golden files:**\n\n**Run golden tests:**\n\n**Use cases:**\n- Verify UI changes don't break existing designs\n- Catch unintended visual regressions\n- Document expected UI appearance\n\n",
              "code": "flutter test",
              "language": "bash"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Todo App",
              "content": "\n**test/widgets/todo_list_test.dart:**\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nvoid main() {\n  testWidgets('Todo app full workflow', (tester) async {\n    await tester.pumpWidget(\n      MaterialApp(home: TodoApp()),\n    );\n\n    // Initially empty\n    expect(find.text('No todos yet!'), findsOneWidget);\n\n    // Add todo\n    await tester.enterText(find.byType(TextField), 'Buy milk');\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pump();\n\n    // Todo appears\n    expect(find.text('Buy milk'), findsOneWidget);\n    expect(find.text('No todos yet!'), findsNothing);\n\n    // Add another\n    await tester.enterText(find.byType(TextField), 'Walk dog');\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pump();\n\n    expect(find.byType(Checkbox), findsNWidgets(2));\n\n    // Complete first todo\n    await tester.tap(find.byType(Checkbox).first);\n    await tester.pump();\n\n    // Delete completed todo\n    await tester.tap(find.byIcon(Icons.delete).first);\n    await tester.pump();\n\n    // Only one todo remains\n    expect(find.text('Buy milk'), findsNothing);\n    expect(find.text('Walk dog'), findsOneWidget);\n  });\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Use Keys for Important Widgets**\n   ```dart\n   TextField(key: Key('email_input'))\n   ElevatedButton(key: Key('submit_button'))\n   ```\n\n2. **Wait for Animations**\n   ```dart\n   await tester.pumpAndSettle();  // After navigation, dialogs\n   ```\n\n3. **Test User Perspective**\n   ```dart\n   // ‚úÖ Good - find by what user sees\n   await tester.tap(find.text('Login'));\n\n   // ‚ùå Bad - implementation detail\n   await tester.tap(find.byType(ElevatedButton).at(2));\n   ```\n\n4. **Test Edge Cases**\n   - Empty states\n   - Long text overflow\n   - Different screen sizes\n   - Disabled buttons\n\n5. **Keep Tests Focused**\n   ```dart\n   // ‚úÖ Good - tests one thing\n   testWidgets('Submit button is disabled when form is invalid')\n\n   // ‚ùå Bad - tests multiple things\n   testWidgets('Form works correctly')\n   ```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** Which method waits for all animations to complete?\nA) pump()\nB) pumpAndSettle()\nC) pumpWidget()\nD) pumpFrame()\n\n**Question 2:** How do you simulate a user typing text?\nA) tester.type()\nB) tester.enterText()\nC) tester.input()\nD) tester.setText()\n\n**Question 3:** What does `findsOneWidget` assert?\nA) At least one widget was found\nB) Exactly one widget was found\nC) The first widget found\nD) One or more widgets found\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Test a Calculator UI",
              "content": "\nCreate a calculator widget with:\n- Number buttons (0-9)\n- Operation buttons (+, -, √ó, √∑)\n- Equals button\n- Clear button\n- Display showing current value\n\nWrite widget tests for:\n1. Number buttons update display\n2. Addition works (2 + 3 = 5)\n3. Clear button resets to 0\n4. Division by zero shows error\n5. Multiple operations in sequence\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered widget testing in Flutter! Here's what we covered:\n\n- **WidgetTester**: pump(), pumpAndSettle(), tap(), enterText()\n- **Finders**: find.text(), find.byKey(), find.byType()\n- **Matchers**: findsOneWidget, findsNothing, findsNWidgets()\n- **Interactions**: Tapping, scrolling, swiping, entering text\n- **Forms**: Validation testing\n- **Navigation**: Screen transitions\n- **Golden Tests**: Visual regression testing\n\nWidget tests give you confidence your UI works before users see it!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) pumpAndSettle()\n\n`pumpAndSettle()` repeatedly calls `pump()` until there are no more frames scheduled, ensuring all animations and asynchronous operations complete. Use it after navigation or dialogs.\n\n**Answer 2:** B) tester.enterText()\n\n`tester.enterText(finder, 'text')` simulates typing text into a TextField. You provide a finder for the TextField and the text to enter.\n\n**Answer 3:** B) Exactly one widget was found\n\n`findsOneWidget` asserts that the finder located exactly one matching widget. Use `findsWidgets` for \"at least one\" or `findsNWidgets(n)` for exactly n widgets.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.4",
          "title": "Lesson 3: Mocking Dependencies",
          "moduleId": "module-10",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Why and when to mock dependencies\n- Using Mocktail for mocking (v1.0.4)\n- Mocking API calls and services\n- Verifying method calls\n- Stubbing return values\n- Testing error scenarios\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: What is Mocking?",
              "content": "\n### Real-World Analogy\nThink of mocking like **using a crash test dummy** instead of a real person:\n- **Testing a car crash?** Use a dummy (don't crash a real person!)\n- **Testing your code?** Use a mock (don't call real APIs!)\n\nMocks are **fake objects** that simulate real dependencies for testing.\n\n### Why Mock?\n\n1. **Speed**: No network delays or database queries\n2. **Reliability**: Tests don't fail due to external services\n3. **Control**: Test error scenarios easily\n4. **Isolation**: Test your code, not external code\n5. **Cost**: No API rate limits or charges\n\n**Example**: Testing a weather app shouldn't require actual weather API calls!\n\n"
            },
            {
              "type": "THEORY",
              "title": "When to Mock vs Not Mock",
              "content": "\n### ‚úÖ DO Mock:\n- External APIs (REST, GraphQL)\n- Databases\n- File systems\n- Third-party services\n- Time/date functions\n- Random number generators\n\n### ‚ùå DON'T Mock:\n- Simple data classes (models)\n- Pure functions (no side effects)\n- Flutter framework widgets\n- Your own business logic (test it for real!)\n\n**Rule of Thumb:** Mock **boundaries** (edges of your app), test **internals** (your code) for real.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Mocktail",
              "content": "\n### Installation\n\n**pubspec.yaml:**\n\n\n**Why Mocktail over Mockito?**\n- ‚úÖ No code generation (no build_runner)\n- ‚úÖ Better null safety support\n- ‚úÖ Cleaner API\n- ‚úÖ Less boilerplate\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "EXAMPLE",
              "title": "Basic Mocking Example",
              "content": "\n### Creating a Mock\n\n**lib/services/weather_service.dart:**\n\n**test/services/weather_service_test.dart:**\n\n",
              "code": "import 'package:flutter_test/flutter_test.dart';\nimport 'package:mocktail/mocktail.dart';\nimport 'package:my_app/services/weather_service.dart';\n\n// 1. Create a mock class\nclass MockWeatherService extends Mock implements WeatherService {}\n\nvoid main() {\n  group('WeatherService', () {\n    late MockWeatherService mockWeatherService;\n\n    setUp(() {\n      mockWeatherService = MockWeatherService();\n    });\n\n    test('getTemperature returns mocked value', () async {\n      // 2. Stub the method (define what it returns)\n      when(() => mockWeatherService.getTemperature('London'))\n          .thenAnswer((_) async => 22.5);\n\n      // 3. Call the mocked method\n      final temp = await mockWeatherService.getTemperature('London');\n\n      // 4. Verify the result\n      expect(temp, 22.5);\n\n      // 5. Verify the method was called\n      verify(() => mockWeatherService.getTemperature('London')).called(1);\n    });\n\n    test('getForecast returns list', () async {\n      // Stub with a list\n      when(() => mockWeatherService.getForecast('Paris', 3))\n          .thenAnswer((_) async => ['Sunny', 'Cloudy', 'Rainy']);\n\n      final forecast = await mockWeatherService.getForecast('Paris', 3);\n\n      expect(forecast, ['Sunny', 'Cloudy', 'Rainy']);\n      expect(forecast, hasLength(3));\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Stubbing Methods",
              "content": "\n### Different Ways to Stub\n\n\n",
              "code": "class MockUserRepository extends Mock implements UserRepository {}\n\nvoid main() {\n  late MockUserRepository mockRepo;\n\n  setUp(() {\n    mockRepo = MockUserRepository();\n  });\n\n  // 1. Simple return value\n  test('stub with simple value', () {\n    when(() => mockRepo.getUserCount()).thenReturn(42);\n    expect(mockRepo.getUserCount(), 42);\n  });\n\n  // 2. Async/Future return\n  test('stub async method', () async {\n    when(() => mockRepo.getUser(1))\n        .thenAnswer((_) async => User(id: 1, name: 'Alice'));\n\n    final user = await mockRepo.getUser(1);\n    expect(user.name, 'Alice');\n  });\n\n  // 3. Throwing errors\n  test('stub to throw exception', () {\n    when(() => mockRepo.getUser(999))\n        .thenThrow(UserNotFoundException('User not found'));\n\n    expect(\n      () => mockRepo.getUser(999),\n      throwsA(isA<UserNotFoundException>()),\n    );\n  });\n\n  // 4. Different returns for different arguments\n  test('stub based on arguments', () async {\n    when(() => mockRepo.getUser(1))\n        .thenAnswer((_) async => User(id: 1, name: 'Alice'));\n    when(() => mockRepo.getUser(2))\n        .thenAnswer((_) async => User(id: 2, name: 'Bob'));\n\n    final alice = await mockRepo.getUser(1);\n    final bob = await mockRepo.getUser(2);\n\n    expect(alice.name, 'Alice');\n    expect(bob.name, 'Bob');\n  });\n\n  // 5. Using argument matchers\n  test('stub with any argument', () async {\n    when(() => mockRepo.getUser(any()))\n        .thenAnswer((_) async => User(id: 0, name: 'Default'));\n\n    final user1 = await mockRepo.getUser(1);\n    final user2 = await mockRepo.getUser(999);\n\n    expect(user1.name, 'Default');\n    expect(user2.name, 'Default');\n  });\n\n  // 6. Sequential returns (different value each call)\n  test('return different values sequentially', () {\n    when(() => mockRepo.getUserCount())\n        .thenReturn(1)\n        .thenReturn(2)\n        .thenReturn(3);\n\n    expect(mockRepo.getUserCount(), 1);\n    expect(mockRepo.getUserCount(), 2);\n    expect(mockRepo.getUserCount(), 3);\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Verification",
              "content": "\n### Verifying Method Calls\n\n\n",
              "code": "test('verify method was called', () async {\n  when(() => mockRepo.saveUser(any())).thenAnswer((_) async => true);\n\n  await mockRepo.saveUser(User(id: 1, name: 'Alice'));\n\n  // Verify it was called exactly once\n  verify(() => mockRepo.saveUser(any())).called(1);\n});\n\ntest('verify method was never called', () {\n  verifyNever(() => mockRepo.deleteUser(any()));\n});\n\ntest('verify method was called multiple times', () {\n  mockRepo.getUserCount();\n  mockRepo.getUserCount();\n  mockRepo.getUserCount();\n\n  verify(() => mockRepo.getUserCount()).called(3);\n});\n\ntest('verify method was called at least once', () {\n  mockRepo.getUserCount();\n  mockRepo.getUserCount();\n\n  verify(() => mockRepo.getUserCount()).called(greaterThan(0));\n});\n\ntest('verify method call with specific argument', () async {\n  when(() => mockRepo.getUser(any())).thenAnswer((_) async => User(id: 1, name: 'Alice'));\n\n  await mockRepo.getUser(42);\n\n  verify(() => mockRepo.getUser(42)).called(1);\n  verifyNever(() => mockRepo.getUser(99));\n});\n\ntest('verify call order', () {\n  mockRepo.getUserCount();\n  mockRepo.saveUser(User(id: 1, name: 'Alice'));\n  mockRepo.getUserCount();\n\n  verifyInOrder([\n    () => mockRepo.getUserCount(),\n    () => mockRepo.saveUser(any()),\n    () => mockRepo.getUserCount(),\n  ]);\n});",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Testing a Login Screen",
              "content": "\n**lib/services/auth_service.dart:**\n\n**lib/viewmodels/login_viewmodel.dart:**\n\n**test/viewmodels/login_viewmodel_test.dart:**\n\n",
              "code": "import 'package:flutter_test/flutter_test.dart';\nimport 'package:mocktail/mocktail.dart';\nimport 'package:my_app/services/auth_service.dart';\nimport 'package:my_app/viewmodels/login_viewmodel.dart';\n\nclass MockAuthService extends Mock implements AuthService {}\n\nvoid main() {\n  group('LoginViewModel', () {\n    late MockAuthService mockAuthService;\n    late LoginViewModel viewModel;\n\n    setUp(() {\n      mockAuthService = MockAuthService();\n      viewModel = LoginViewModel(mockAuthService);\n    });\n\n    test('successful login sets currentUser and returns true', () async {\n      // Arrange\n      final mockUser = User(\n        id: '123',\n        email: 'test@example.com',\n        name: 'Test User',\n      );\n\n      when(() => mockAuthService.login('test@example.com', 'password123'))\n          .thenAnswer((_) async => mockUser);\n\n      // Act\n      final result = await viewModel.login('test@example.com', 'password123');\n\n      // Assert\n      expect(result, true);\n      expect(viewModel.currentUser, mockUser);\n      expect(viewModel.errorMessage, null);\n      expect(viewModel.isLoading, false);\n\n      verify(() => mockAuthService.login('test@example.com', 'password123'))\n          .called(1);\n    });\n\n    test('failed login with invalid credentials shows error', () async {\n      // Arrange\n      when(() => mockAuthService.login(any(), any()))\n          .thenThrow(InvalidCredentialsException());\n\n      // Act\n      final result = await viewModel.login('wrong@example.com', 'wrongpass');\n\n      // Assert\n      expect(result, false);\n      expect(viewModel.currentUser, null);\n      expect(viewModel.errorMessage, 'Invalid email or password');\n      expect(viewModel.isLoading, false);\n    });\n\n    test('network error shows appropriate message', () async {\n      // Arrange\n      when(() => mockAuthService.login(any(), any()))\n          .thenThrow(NetworkException());\n\n      // Act\n      final result = await viewModel.login('test@example.com', 'password123');\n\n      // Assert\n      expect(result, false);\n      expect(viewModel.errorMessage, 'Network error. Please try again.');\n    });\n\n    test('unexpected error shows generic message', () async {\n      // Arrange\n      when(() => mockAuthService.login(any(), any()))\n          .thenThrow(Exception('Something went wrong'));\n\n      // Act\n      final result = await viewModel.login('test@example.com', 'password123');\n\n      // Assert\n      expect(result, false);\n      expect(viewModel.errorMessage, 'An unexpected error occurred');\n    });\n\n    test('logout clears currentUser', () async {\n      // Arrange\n      viewModel.currentUser = User(\n        id: '123',\n        email: 'test@example.com',\n        name: 'Test User',\n      );\n\n      when(() => mockAuthService.logout()).thenAnswer((_) async {});\n\n      // Act\n      await viewModel.logout();\n\n      // Assert\n      expect(viewModel.currentUser, null);\n      verify(() => mockAuthService.logout()).called(1);\n    });\n\n    test('isLoading is true during login', () async {\n      // Arrange\n      when(() => mockAuthService.login(any(), any()))\n          .thenAnswer((_) async {\n            // Simulate delay\n            await Future.delayed(Duration(milliseconds: 100));\n            return User(id: '123', email: 'test@example.com', name: 'Test');\n          });\n\n      // Act\n      final loginFuture = viewModel.login('test@example.com', 'password123');\n\n      // Check immediately (should be loading)\n      expect(viewModel.isLoading, true);\n\n      // Wait for completion\n      await loginFuture;\n\n      // Should no longer be loading\n      expect(viewModel.isLoading, false);\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Mocking HTTP Calls",
              "content": "\n### Using Mocktail with Dio/HTTP\n\n\n",
              "code": "import 'package:http/http.dart' as http;\nimport 'package:mocktail/mocktail.dart';\n\nclass MockHttpClient extends Mock implements http.Client {}\n\nvoid main() {\n  setUpAll(() {\n    // Register fallback values for Uri type\n    registerFallbackValue(Uri());\n  });\n\n  test('fetch user data from API', () async {\n    final mockClient = MockHttpClient();\n\n    // Stub the get method\n    when(() => mockClient.get(any())).thenAnswer(\n      (_) async => http.Response(\n        '{\"id\": 1, \"name\": \"Alice\"}',\n        200,\n      ),\n    );\n\n    final userService = UserService(mockClient);\n    final user = await userService.getUser(1);\n\n    expect(user.name, 'Alice');\n    verify(() => mockClient.get(Uri.parse('https://api.example.com/users/1')))\n        .called(1);\n  });\n\n  test('handles 404 error', () async {\n    final mockClient = MockHttpClient();\n\n    when(() => mockClient.get(any())).thenAnswer(\n      (_) async => http.Response('Not Found', 404),\n    );\n\n    final userService = UserService(mockClient);\n\n    expect(\n      () => userService.getUser(999),\n      throwsA(isA<UserNotFoundException>()),\n    );\n  });\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Mock Interfaces, Not Implementations**\n   ```dart\n   // ‚úÖ Good\n   abstract class AuthService { /* ... */ }\n   class MockAuthService extends Mock implements AuthService {}\n\n   // ‚ùå Bad\n   class RealAuthService { /* ... */ }\n   class MockAuthService extends Mock implements RealAuthService {}\n   ```\n\n2. **Use `setUpAll()` for Fallback Values**\n   ```dart\n   setUpAll(() {\n     registerFallbackValue(Uri());\n     registerFallbackValue(User(id: '0', email: '', name: ''));\n   });\n   ```\n\n3. **Verify Important Interactions**\n   ```dart\n   // Verify critical side effects\n   verify(() => mockRepo.saveToDatabase(any())).called(1);\n\n   // Don't over-verify\n   // verifyNever(() => mockRepo.log(any()));  // Unnecessary\n   ```\n\n4. **Use Descriptive Test Names**\n   ```dart\n   test('login with valid credentials sets currentUser')\n   test('login with network error shows error message')\n   ```\n\n5. **Reset Mocks Between Tests**\n   ```dart\n   setUp(() {\n     mockService = MockService();  // Create fresh mock\n     reset(mockService);  // Or reset existing mock\n   });\n   ```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the main advantage of Mocktail over Mockito?\nA) It's faster\nB) No code generation needed\nC) Better for integration tests\nD) Works on iOS only\n\n**Question 2:** When should you use `thenAnswer()` instead of `thenReturn()`?\nA) For async methods returning Future\nB) For sync methods\nC) Only for error cases\nD) Never, they're the same\n\n**Question 3:** What does `verify().called(1)` check?\nA) The method returned 1\nB) The method was called exactly once\nC) The method was called with argument 1\nD) The method took 1 second\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Mock a Weather App",
              "content": "\nCreate a weather app service and test it:\n\n\nWrite tests for:\n1. Successful weather fetch\n2. City not found (404 error)\n3. Network timeout\n4. Forecast returns correct number of days\n5. Verify API is called with correct city name\n\n",
              "code": "abstract class WeatherApi {\n  Future<Weather> getCurrentWeather(String city);\n  Future<List<Weather>> getForecast(String city, int days);\n}\n\nclass Weather {\n  final double temperature;\n  final String condition;\n  final DateTime date;\n\n  Weather(this.temperature, this.condition, this.date);\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered mocking in Flutter! Here's what we covered:\n\n- **Why Mock**: Speed, reliability, control, isolation\n- **Mocktail Setup**: No code generation needed\n- **Stubbing**: `when().thenReturn()` and `when().thenAnswer()`\n- **Verification**: `verify().called()` and `verifyNever()`\n- **Argument Matchers**: `any()`, `captureAny()`\n- **Complete Example**: Login viewmodel with error handling\n\nMocking lets you test your code in isolation without external dependencies!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) No code generation needed\n\nMocktail's main advantage is that it doesn't require `build_runner` or code generation. You just extend `Mock` and implement your interface. This makes tests cleaner and faster to write.\n\n**Answer 2:** A) For async methods returning Future\n\nUse `thenAnswer()` for async methods because it takes a callback that can return a Future. Use `thenReturn()` for synchronous methods that return values immediately.\n\n**Answer 3:** B) The method was called exactly once\n\n`verify().called(1)` verifies that the method was invoked exactly one time during the test. Use `.called(n)` for n times, `greaterThan(n)` for at least n times, or `.never()` for zero times.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.5",
          "title": "Run on all connected devices",
          "moduleId": "module-10",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Learning Objectives",
              "content": "By the end of this lesson, you will be able to:\n- Understand the difference between widget tests and integration tests\n- Set up the integration_test package in your Flutter project\n- Write integration tests that simulate real user interactions\n- Run integration tests on physical devices and emulators\n- Test navigation flows and multi-screen interactions\n- Use IntegrationTestWidgetsFlutterBinding for device testing\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\n### What is Integration Testing?\n\n**Concept First:**\nImagine you're a restaurant inspector. Unit testing is like checking each ingredient separately (is the lettuce fresh? is the meat cooked?). Widget testing is like tasting individual dishes (does the burger taste good?). **Integration testing** is like experiencing the entire dining experience from start to finish‚Äîwalking in, ordering, waiting, eating, and paying. You're making sure everything works together seamlessly.\n\nIn Flutter, integration testing verifies that your entire app works correctly from the user's perspective. It tests multiple widgets, screens, and services working together as a complete system.\n\n**Jargon:**\n- **Integration Test**: Tests that verify multiple parts of your app work together correctly\n- **End-to-End (E2E) Test**: Tests that simulate complete user journeys through your app\n- **IntegrationTestWidgetsFlutterBinding**: A test binding that allows tests to run on real devices\n\n### Why This Matters\n\nIntegration tests catch issues that unit and widget tests miss:\n- **Navigation bugs**: Does tapping \"Login\" actually take you to the home screen?\n- **Data flow issues**: When you add an item to the cart, does it show up on the checkout screen?\n- **Real device behavior**: Does your app work on actual Android and iOS devices?\n- **User journey validation**: Can users complete critical tasks from start to finish?\n\n**Real-world analogy:** Your app might have perfect individual features (like a car with a great engine, comfortable seats, and smooth steering), but integration tests ensure they work together (can you actually drive the car from point A to point B?).\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 1: Integration Testing vs Widget Testing",
              "content": "\n### Key Differences\n\n| Aspect | Widget Testing | Integration Testing |\n|--------|---------------|---------------------|\n| **Scope** | Single widget/screen | Multiple screens and flows |\n| **Speed** | Fast (milliseconds) | Slower (seconds) |\n| **Runs on** | Host machine only | Real devices + emulators |\n| **Dependencies** | Often mocked | Real services |\n| **Purpose** | Verify UI components | Verify complete user flows |\n\n### When to Use Each\n\n**Use Widget Tests when:**\n- Testing individual widgets or screens\n- Verifying UI logic and interactions\n- Running tests quickly during development\n- Mocking external dependencies\n\n**Use Integration Tests when:**\n- Testing navigation between screens\n- Verifying complete user workflows\n- Testing on real devices before release\n- Ensuring app works with real backend services\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 2: Setting Up Integration Testing",
              "content": "\n### Step 1: Create Integration Test Directory\n\nIn your Flutter project root, create a new directory:\n\n\n### Step 2: Add Integration Test Package\n\nThe `integration_test` package comes with Flutter SDK. No version needed!\n\n\nRun:\n\n### Step 3: Understand the Test Structure\n\n**integration_test/** directory structure:\n\n",
              "code": "integration_test/\n‚îú‚îÄ‚îÄ app_test.dart              # Main integration test file\n‚îú‚îÄ‚îÄ login_flow_test.dart       # Specific user flow tests\n‚îî‚îÄ‚îÄ checkout_flow_test.dart    # Another flow test",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Section 3: Writing Your First Integration Test",
              "content": "\n### Example: Testing a Login Flow\n\nLet's create a simple app and test the complete login journey.\n\n#### Step 1: Create the App\n\n\n#### Step 2: Write the Integration Test\n\n\n### Key Differences from Widget Tests\n\n1. **IntegrationTestWidgetsFlutterBinding.ensureInitialized()**\n   - Required at the start of integration tests\n   - Allows tests to run on real devices\n   - Not needed in widget tests\n\n2. **app.main() instead of pumping a widget**\n   - Starts the entire app, not just a widget\n   - Simulates launching the app like a user would\n\n3. **More pumpAndSettle() calls**\n   - Integration tests have more async operations\n   - Navigation, animations, and API calls take time\n\n",
              "code": "// integration_test/login_flow_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\nimport 'package:your_app/main.dart' as app;\n\nvoid main() {\n  // CRITICAL: Initialize the integration test binding\n  // This allows tests to run on real devices\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('Login Flow Integration Tests', () {\n    testWidgets('Complete login flow with valid credentials',\n        (WidgetTester tester) async {\n      // ARRANGE: Start the app\n      app.main();\n      await tester.pumpAndSettle();\n\n      // Verify we're on the login screen\n      expect(find.text('Login'), findsOneWidget);\n      expect(find.byKey(const Key('emailField')), findsOneWidget);\n\n      // ACT: Enter email\n      await tester.enterText(\n        find.byKey(const Key('emailField')),\n        'test@example.com',\n      );\n      await tester.pumpAndSettle();\n\n      // ACT: Enter password\n      await tester.enterText(\n        find.byKey(const Key('passwordField')),\n        'password123',\n      );\n      await tester.pumpAndSettle();\n\n      // ACT: Tap login button\n      await tester.tap(find.byKey(const Key('loginButton')));\n      await tester.pumpAndSettle();\n\n      // ASSERT: Verify navigation to home screen\n      expect(find.text('Welcome!'), findsOneWidget);\n      expect(find.text('You are now logged in'), findsOneWidget);\n      expect(find.text('Login'), findsNothing); // Login screen is gone\n    });\n\n    testWidgets('Login flow with invalid credentials shows error',\n        (WidgetTester tester) async {\n      // ARRANGE\n      app.main();\n      await tester.pumpAndSettle();\n\n      // ACT: Enter wrong credentials\n      await tester.enterText(\n        find.byKey(const Key('emailField')),\n        'wrong@example.com',\n      );\n      await tester.enterText(\n        find.byKey(const Key('passwordField')),\n        'wrongpassword',\n      );\n      await tester.pumpAndSettle();\n\n      await tester.tap(find.byKey(const Key('loginButton')));\n      await tester.pumpAndSettle();\n\n      // ASSERT: Still on login screen with error\n      expect(find.text('Login'), findsOneWidget);\n      expect(find.text('Invalid credentials'), findsOneWidget);\n      expect(find.text('Welcome!'), findsNothing); // Not on home screen\n    });\n\n    testWidgets('Login flow with empty fields shows validation error',\n        (WidgetTester tester) async {\n      // ARRANGE\n      app.main();\n      await tester.pumpAndSettle();\n\n      // ACT: Tap login without entering anything\n      await tester.tap(find.byKey(const Key('loginButton')));\n      await tester.pumpAndSettle();\n\n      // ASSERT: Error message appears\n      expect(find.text('Please fill in all fields'), findsOneWidget);\n      expect(find.text('Welcome!'), findsNothing);\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 4: Running Integration Tests",
              "content": "\n### On Desktop/Emulator (Fastest)\n\n\n### On Physical Device (Most Realistic)\n\n**For Android:**\n1. Connect your Android device via USB\n2. Enable USB debugging in Developer Options\n3. Run:\n\n**For iOS:**\n1. Connect your iPhone via USB\n2. Trust the computer on your device\n3. Run:\n\n### Running on Multiple Devices\n\n\n",
              "code": "flutter test integration_test --all",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Section 5: Advanced Integration Test Patterns",
              "content": "\n### Testing Multi-Screen Navigation\n\n\n### Testing Scrolling and List Interactions\n\n\n### Testing Forms with Validation\n\n\n",
              "code": "testWidgets('Registration form validation flow',\n    (WidgetTester tester) async {\n  app.main();\n  await tester.pumpAndSettle();\n\n  // Navigate to registration screen\n  await tester.tap(find.text('Register'));\n  await tester.pumpAndSettle();\n\n  // Test 1: Submit empty form\n  await tester.tap(find.text('Submit'));\n  await tester.pumpAndSettle();\n\n  expect(find.text('Name is required'), findsOneWidget);\n  expect(find.text('Email is required'), findsOneWidget);\n\n  // Test 2: Invalid email format\n  await tester.enterText(find.byKey(const Key('emailField')), 'invalidemail');\n  await tester.tap(find.text('Submit'));\n  await tester.pumpAndSettle();\n\n  expect(find.text('Enter a valid email'), findsOneWidget);\n\n  // Test 3: Valid submission\n  await tester.enterText(find.byKey(const Key('nameField')), 'John Doe');\n  await tester.enterText(\n    find.byKey(const Key('emailField')),\n    'john@example.com',\n  );\n  await tester.enterText(\n    find.byKey(const Key('passwordField')),\n    'securepass123',\n  );\n  await tester.pumpAndSettle();\n\n  await tester.tap(find.text('Submit'));\n  await tester.pumpAndSettle();\n\n  // Verify success\n  expect(find.text('Registration Successful'), findsOneWidget);\n});",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Section 6: Best Practices for Integration Testing",
              "content": "\n### 1. Use Keys for Important Widgets\n\n**Bad:**\n\n**Good:**\n\n### 2. Wait for Animations and Async Operations\n\n\n### 3. Test One User Flow Per Test\n\n**Bad:** One massive test that tests everything\n\n**Good:** Separate tests for each flow\n\n### 4. Use Descriptive Test Names\n\n**Bad:**\n\n**Good:**\n\n### 5. Clean Up Between Tests\n\n\n",
              "code": "testWidgets('Login test', (WidgetTester tester) async {\n  app.main();\n  await tester.pumpAndSettle();\n\n  // Test code...\n\n  // No explicit cleanup needed - each test starts fresh\n  // The next testWidgets call will restart the app\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 7: Debugging Integration Tests",
              "content": "\n### Common Issues and Solutions\n\n#### Issue 1: \"Unable to find widget\"\n\n**Error:**\n\n**Solutions:**\n\n#### Issue 2: Test Times Out\n\n**Error:**\n\n**Solutions:**\n\n#### Issue 3: Flaky Tests (Sometimes Pass, Sometimes Fail)\n\n**Causes:**\n- Network-dependent code\n- Race conditions with async operations\n- Animation timing issues\n\n**Solutions:**\n\n",
              "code": "// Wait for specific conditions instead of arbitrary delays\nawait tester.pumpAndSettle();\n\n// For network operations, consider mocking in integration tests\n// Or use retry logic\nfor (int i = 0; i < 3; i++) {\n  await tester.pumpAndSettle();\n  if (find.text('Loaded').evaluate().isNotEmpty) break;\n  await Future.delayed(const Duration(seconds: 1));\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Integration Test Example",
              "content": "\nHere's a comprehensive example testing a todo app:\n\n\n",
              "code": "// integration_test/todo_app_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\nimport 'package:your_app/main.dart' as app;\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('Todo App Integration Tests', () {\n    testWidgets('User can add, complete, and delete a todo',\n        (WidgetTester tester) async {\n      // ARRANGE: Start the app\n      app.main();\n      await tester.pumpAndSettle();\n\n      // Verify empty state\n      expect(find.text('No todos yet'), findsOneWidget);\n\n      // ACT: Add a new todo\n      await tester.tap(find.byKey(const Key('addButton')));\n      await tester.pumpAndSettle();\n\n      // Enter todo text\n      await tester.enterText(\n        find.byKey(const Key('todoInputField')),\n        'Buy groceries',\n      );\n      await tester.pumpAndSettle();\n\n      await tester.tap(find.text('Save'));\n      await tester.pumpAndSettle();\n\n      // ASSERT: Todo appears in list\n      expect(find.text('Buy groceries'), findsOneWidget);\n      expect(find.text('No todos yet'), findsNothing);\n\n      // ACT: Mark todo as complete\n      await tester.tap(find.byKey(const Key('todoCheckbox_0')));\n      await tester.pumpAndSettle();\n\n      // ASSERT: Todo is marked complete (strikethrough or different style)\n      final todoWidget = tester.widget(find.text('Buy groceries'));\n      // Add assertions based on your implementation\n\n      // ACT: Delete the todo\n      await tester.tap(find.byKey(const Key('deleteButton_0')));\n      await tester.pumpAndSettle();\n\n      // ASSERT: Todo is removed\n      expect(find.text('Buy groceries'), findsNothing);\n      expect(find.text('No todos yet'), findsOneWidget);\n    });\n\n    testWidgets('User can add multiple todos and filter them',\n        (WidgetTester tester) async {\n      app.main();\n      await tester.pumpAndSettle();\n\n      // Add first todo\n      await tester.tap(find.byKey(const Key('addButton')));\n      await tester.pumpAndSettle();\n      await tester.enterText(\n        find.byKey(const Key('todoInputField')),\n        'Task 1',\n      );\n      await tester.tap(find.text('Save'));\n      await tester.pumpAndSettle();\n\n      // Add second todo\n      await tester.tap(find.byKey(const Key('addButton')));\n      await tester.pumpAndSettle();\n      await tester.enterText(\n        find.byKey(const Key('todoInputField')),\n        'Task 2',\n      );\n      await tester.tap(find.text('Save'));\n      await tester.pumpAndSettle();\n\n      // Verify both todos exist\n      expect(find.text('Task 1'), findsOneWidget);\n      expect(find.text('Task 2'), findsOneWidget);\n\n      // Complete first todo\n      await tester.tap(find.byKey(const Key('todoCheckbox_0')));\n      await tester.pumpAndSettle();\n\n      // Filter to show only active todos\n      await tester.tap(find.text('Active'));\n      await tester.pumpAndSettle();\n\n      // Verify only active todo is shown\n      expect(find.text('Task 1'), findsNothing); // Completed, hidden\n      expect(find.text('Task 2'), findsOneWidget); // Active, visible\n\n      // Filter to show completed todos\n      await tester.tap(find.text('Completed'));\n      await tester.pumpAndSettle();\n\n      // Verify only completed todo is shown\n      expect(find.text('Task 1'), findsOneWidget);\n      expect(find.text('Task 2'), findsNothing);\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\nTest your understanding of integration testing:\n\n### Question 1\nWhat is the primary difference between widget tests and integration tests?\n\nA) Widget tests are faster\nB) Integration tests run on real devices\nC) Integration tests test complete user flows across multiple screens\nD) All of the above\n\n### Question 2\nWhat must you call at the beginning of an integration test file?\n\nA) `WidgetTester.ensureInitialized()`\nB) `IntegrationTestWidgetsFlutterBinding.ensureInitialized()`\nC) `Flutter.initializeIntegrationTests()`\nD) Nothing special is required\n\n### Question 3\nHow do you run integration tests on a connected physical device?\n\nA) `flutter run integration_test`\nB) `flutter test integration_test --device-id=<id>`\nC) `flutter device test`\nD) Integration tests cannot run on physical devices\n\n### Question 4\nWhat is the purpose of `await tester.pumpAndSettle()` in integration tests?\n\nA) To restart the test\nB) To wait for all animations and async operations to complete\nC) To take a screenshot\nD) To clean up test resources\n\n### Question 5\nWhat is the recommended way to find widgets in integration tests?\n\nA) By text content only\nB) By widget type only\nC) By using Key widgets assigned to important UI elements\nD) Using index positions in the widget tree\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Question 1: D** - All of the above. Integration tests differ from widget tests in that they're slower, run on real devices, and test complete workflows.\n\n**Question 2: B** - `IntegrationTestWidgetsFlutterBinding.ensureInitialized()` must be called at the start. This binding allows tests to run on physical devices.\n\n**Question 3: B** - Use `flutter test integration_test --device-id=<id>`. You first run `flutter devices` to get your device ID, then specify it in the test command.\n\n**Question 4: B** - `pumpAndSettle()` waits for all animations, frame updates, and async operations to complete before proceeding. This ensures widgets are in their final state before assertions.\n\n**Question 5: C** - Using `Key` widgets is the most reliable approach. Text and types can change, but keys provide stable, explicit identifiers for testing.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nIn this lesson, you learned:\n\n‚úÖ **Integration tests** verify complete user workflows across multiple screens\n‚úÖ **IntegrationTestWidgetsFlutterBinding** enables testing on real devices\n‚úÖ Integration tests start with `app.main()` to launch the entire app\n‚úÖ Use `pumpAndSettle()` frequently to wait for async operations\n‚úÖ Add **Key widgets** to important UI elements for reliable test finders\n‚úÖ Run tests with `flutter test integration_test` or on devices\n‚úÖ Write separate tests for each user flow for maintainability\n‚úÖ Integration tests are slower but catch issues that unit/widget tests miss\n\n**Key Takeaway:** Integration testing is your final defense before users encounter bugs. While slower than unit and widget tests, they verify that your entire app works as a cohesive system. Use them to test critical user journeys like login, checkout, and core features.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn **Lesson 10.5: End-to-End Testing with Firebase Test Lab**, you'll learn how to run your integration tests on hundreds of real Android and iOS devices in the cloud, catching device-specific bugs before your users do.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.6",
          "title": "End-to-End Testing with Firebase Test Lab",
          "moduleId": "module-10",
          "order": 6,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Learning Objectives",
              "content": "By the end of this lesson, you will be able to:\n- Understand what Firebase Test Lab is and why it's essential\n- Set up Firebase Test Lab for your Flutter project\n- Build and upload test APKs and iOS test bundles to Test Lab\n- Run integration tests on hundreds of real devices in the cloud\n- Analyze test results and device-specific issues\n- Integrate Firebase Test Lab into your CI/CD pipeline\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\n### What is Firebase Test Lab?\n\n**Concept First:**\nImagine you're opening a restaurant chain in 50 different cities. You could personally visit each location to check if everything works (expensive and slow), or you could hire local inspectors in each city who all check at the same time and send you detailed reports (fast and comprehensive).\n\n**Firebase Test Lab** is like having thousands of device testers working simultaneously. It's Google's cloud-based testing infrastructure that runs your app on hundreds of real Android and iOS devices, catching device-specific bugs before your users encounter them.\n\n**Real-world scenario:** Your app works perfectly on your Samsung Galaxy S24 during development, but crashes on a Pixel 6 with Android 13, freezes on an iPhone 12 with iOS 16, and has layout issues on tablets. Test Lab would catch all these issues automatically.\n\n**Jargon:**\n- **Firebase Test Lab**: Google's cloud infrastructure for testing apps on real devices\n- **Test Matrix**: A collection of test executions across multiple device configurations\n- **Robo Test**: Automated UI testing that explores your app without written tests\n- **Instrumentation Test**: Your integration tests packaged as Android instrumentation or iOS XCTests\n\n### Why This Matters\n\n**The Device Fragmentation Problem:**\n- Android has **24,000+ different device models**\n- iOS has 30+ iPhone models and 20+ iPad models\n- Different screen sizes, OS versions, and hardware capabilities\n- What works on one device might fail on another\n\n**Without Test Lab:**\n- Buy and maintain dozens of physical devices ($$$$)\n- Manually test on each device (weeks of work)\n- Still miss device-specific bugs\n- Users discover issues after release\n\n**With Test Lab:**\n- Test on hundreds of devices in minutes\n- Automatic screenshots and crash logs\n- Pay only for testing time used\n- Catch issues before users see them\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 1: Setting Up Firebase Test Lab",
              "content": "\n### Step 1: Create a Firebase Project\n\n1. Go to [Firebase Console](https://console.firebase.google.com/)\n2. Click \"Add project\"\n3. Enter project name (e.g., \"my-flutter-app\")\n4. Click \"Continue\"\n5. Disable Google Analytics (optional for testing)\n6. Click \"Create project\"\n\n### Step 2: Enable Firebase Test Lab\n\n1. In Firebase Console, select your project\n2. Click \"Test Lab\" in the left sidebar (under \"Release & Monitor\")\n3. Test Lab is automatically enabled - no additional setup needed!\n\n### Step 3: Install Firebase CLI\n\n\n### Step 4: Install gcloud SDK (for Advanced Usage)\n\n\n",
              "code": "brew install --cask google-cloud-sdk\n\ncurl https://sdk.cloud.google.com | bash\nexec -l $SHELL\n\n\ngcloud init\ngcloud auth login",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Section 2: Preparing Your Flutter App for Test Lab",
              "content": "\n### Add Integration Tests (if not already present)\n\nEnsure you have integration tests in your project:\n\n\n### Sample Integration Test\n\n\n",
              "code": "// integration_test/app_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\nimport 'package:your_app/main.dart' as app;\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  testWidgets('Complete user flow test', (WidgetTester tester) async {\n    app.main();\n    await tester.pumpAndSettle();\n\n    // Test your app's critical flows\n    expect(find.text('Welcome'), findsOneWidget);\n\n    // Add more test steps...\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 3: Running Tests on Android Devices",
              "content": "\n### Step 1: Build the App and Test APKs\n\nFirebase Test Lab requires two APK files:\n1. **App APK**: Your app in debug mode\n2. **Test APK**: Your integration tests packaged as instrumentation tests\n\n\n**Location of built APKs:**\n- App APK: `build/app/outputs/flutter-apk/app-debug.apk`\n- Test APK: `build/app/outputs/apk/androidTest/debug/app-debug-androidTest.apk`\n\n### Step 2: Upload and Run Tests via Firebase Console (Easiest)\n\n1. Go to [Firebase Console](https://console.firebase.google.com/)\n2. Select your project\n3. Click \"Test Lab\" in the sidebar\n4. Click \"Run a test\"\n5. Select \"Instrumentation\"\n6. Upload:\n   - **App APK**: `build/app/outputs/flutter-apk/app-debug.apk`\n   - **Test APK**: `build/app/outputs/apk/androidTest/debug/app-debug-androidTest.apk`\n7. Select devices (you can choose from physical devices)\n8. Click \"Start tests\"\n\n**Free Tier:**\n- 5 virtual device tests/day\n- 10 physical device tests/day\n\n### Step 3: Run Tests via Command Line (Advanced)\n\n\n### Step 4: Run on Multiple Device Configurations\n\nCreate a device matrix to test different combinations:\n\n\n### Available Device Models\n\n\n",
              "code": "gcloud firebase test android models list --project $PROJECT_ID\n\ngcloud firebase test android versions list --project $PROJECT_ID",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Section 4: Running Tests on iOS Devices",
              "content": "\n### Step 1: Build iOS Test Bundle\n\niOS testing requires creating a `.zip` file containing your test build:\n\n\n**Test bundle location:** `build/ios_integ/Build/Products/ios_tests.zip`\n\n### Step 2: Upload and Run iOS Tests via Firebase Console\n\n1. Go to Firebase Console ‚Üí Test Lab\n2. Click \"Run a test\"\n3. Select \"XCTest\"\n4. Upload `ios_tests.zip`\n5. Select iOS devices\n6. Click \"Start tests\"\n\n### Step 3: Run iOS Tests via Command Line\n\n\n### Available iOS Devices\n\n\n",
              "code": "gcloud firebase test ios models list --project $PROJECT_ID\n\ngcloud firebase test ios versions list --project $PROJECT_ID",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Section 5: Analyzing Test Results",
              "content": "\n### Viewing Results in Firebase Console\n\nAfter tests complete:\n\n1. Go to Firebase Console ‚Üí Test Lab\n2. Click on your test run\n3. View results for each device:\n   - ‚úÖ **Passed**: All tests passed\n   - ‚ùå **Failed**: Tests failed or crashed\n   - ‚ö†Ô∏è **Inconclusive**: Test didn't complete\n\n### Detailed Device Results\n\nClick on any device to see:\n- **Video Recording**: Watch your app running on the device\n- **Screenshots**: Automatic screenshots at key moments\n- **Logs**: Complete logcat (Android) or syslog (iOS)\n- **Performance Metrics**: CPU, memory, network usage\n- **Test Artifacts**: Downloaded test outputs\n\n### Understanding Common Failures\n\n#### Failure Type 1: Timeout\n\n\n**Cause:** Test takes too long or has infinite loop\n**Fix:** Optimize slow operations or increase timeout\n\n#### Failure Type 2: Widget Not Found\n\n\n**Cause:** Device-specific layout differences\n**Fix:** Check screenshots to see actual layout, adjust test finders\n\n#### Failure Type 3: Crash\n\n\n**Cause:** Device-specific bug (OS version, screen size, etc.)\n**Fix:** Review stack trace, fix null safety issues\n\n### Downloading Test Artifacts\n\n\n",
              "code": "gcloud firebase test android run \\\n  --app build/app/outputs/flutter-apk/app-debug.apk \\\n  --test build/app/outputs/apk/androidTest/debug/app-debug-androidTest.apk \\\n  --results-dir=test_results/$(date +%Y%m%d_%H%M%S) \\\n  --project $PROJECT_ID\n",
              "language": "bash"
            },
            {
              "type": "EXAMPLE",
              "title": "Section 6: Robo Tests (No Code Required)",
              "content": "\n### What are Robo Tests?\n\n**Robo tests** are automated UI tests that explore your app without requiring written test code. Google's AI automatically:\n- Taps buttons and UI elements\n- Fills in text fields with sample data\n- Navigates through screens\n- Takes screenshots and videos\n- Reports crashes and UI issues\n\n**Analogy:** Like giving your app to a curious toddler who taps everything to see what happens‚Äîbut with detailed logging!\n\n### Running Robo Tests on Android\n\n\n### Robo Test via Firebase Console\n\n1. Firebase Console ‚Üí Test Lab ‚Üí \"Run a test\"\n2. Select \"Robo\"\n3. Upload only the app APK (no test APK needed)\n4. Select devices\n5. Click \"Start tests\"\n\n### When to Use Robo Tests\n\n**Good for:**\n- Quick smoke tests before release\n- Discovering crashes in unexplored areas\n- Testing without writing test code\n- Exploring new UI flows\n\n**Not good for:**\n- Testing specific user flows (use integration tests instead)\n- Testing login flows (Robo can't guess passwords)\n- Complex multi-step scenarios\n\n",
              "code": "gcloud firebase test android run \\\n  --type robo \\\n  --app build/app/outputs/flutter-apk/app-debug.apk \\\n  --device model=Pixel6,version=33 \\\n  --project $PROJECT_ID",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Section 7: Integrating Test Lab into CI/CD",
              "content": "\n### GitHub Actions Integration\n\nCreate `.github/workflows/firebase-test-lab.yml`:\n\n\n### Setting Up GitHub Secrets\n\n1. Create a Google Cloud service account:\n   ```bash\n   gcloud iam service-accounts create github-actions \\\n     --display-name=\"GitHub Actions\"\n\n   gcloud projects add-iam-policy-binding YOUR_PROJECT_ID \\\n     --member=\"serviceAccount:github-actions@YOUR_PROJECT_ID.iam.gserviceaccount.com\" \\\n     --role=\"roles/editor\"\n\n   gcloud iam service-accounts keys create credentials.json \\\n     --iam-account=github-actions@YOUR_PROJECT_ID.iam.gserviceaccount.com\n   ```\n\n2. In GitHub repository:\n   - Go to Settings ‚Üí Secrets and variables ‚Üí Actions\n   - Click \"New repository secret\"\n   - Name: `GOOGLE_CLOUD_CREDENTIALS`\n   - Value: Contents of `credentials.json`\n   - Name: `FIREBASE_PROJECT_ID`\n   - Value: Your Firebase project ID\n\n### Codemagic Integration\n\nCreate `codemagic.yaml`:\n\n\n",
              "code": "workflows:\n  flutter-test-lab:\n    name: Flutter Test Lab\n    max_build_duration: 60\n    environment:\n      flutter: stable\n      groups:\n        - firebase_credentials\n    scripts:\n      - name: Install dependencies\n        script: flutter pub get\n\n      - name: Build APKs\n        script: |\n          flutter build apk --debug\n          cd android\n          ./gradlew app:assembleDebugAndroidTest\n          cd ..\n\n      - name: Run Firebase Test Lab\n        script: |\n          echo $FIREBASE_CREDENTIALS | base64 --decode > credentials.json\n          gcloud auth activate-service-account --key-file=credentials.json\n          gcloud --quiet config set project $FIREBASE_PROJECT_ID\n\n          gcloud firebase test android run \\\n            --type instrumentation \\\n            --app build/app/outputs/flutter-apk/app-debug.apk \\\n            --test build/app/outputs/apk/androidTest/debug/app-debug-androidTest.apk \\\n            --device model=Pixel6,version=33 \\\n            --device model=SamsungGalaxyS21,version=30",
              "language": "yaml"
            },
            {
              "type": "EXPERIMENT",
              "title": "Section 8: Best Practices for Firebase Test Lab",
              "content": "\n### 1. Test on Representative Devices\n\n**Don't test on everything** (expensive and slow). Choose devices that represent your user base:\n\n\n### 2. Use Test Lab in Pre-Release Pipeline\n\n**Test flow:**\n\n### 3. Set Appropriate Timeouts\n\n\n### 4. Run Robo Tests for Quick Checks\n\n\n### 5. Analyze Failure Patterns\n\nIf tests fail on specific devices:\n- Check device-specific logs and screenshots\n- Look for patterns (all Samsung devices fail? all Android 10 devices?)\n- Add device-specific workarounds if needed\n\n### 6. Monitor Test Lab Costs\n\n**Free tier limits:**\n- 5 virtual device tests/day\n- 10 physical device tests/day\n\n**Beyond free tier:**\n- Virtual devices: $1/device-hour\n- Physical devices: $5/device-hour\n\n**Cost optimization:**\n\n",
              "code": "gcloud firebase test android run \\\n  --device model=Pixel6,version=33  # Just one device\n\ngcloud firebase test android run \\\n  --device model=Pixel6,version=33 \\\n  --device model=Pixel5,version=31 \\\n  --device model=SamsungGalaxyS21,version=30  # Multiple devices",
              "language": "bash"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Full Test Lab Workflow",
              "content": "\n### Project Structure\n\n\n### Automated Test Script\n\n\nMake it executable:\n\nRun it:\n\n",
              "code": "./scripts/run_android_test_lab.sh",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\nTest your understanding of Firebase Test Lab:\n\n### Question 1\nWhat is the main advantage of Firebase Test Lab over local device testing?\n\nA) It's completely free\nB) Tests run faster\nC) Tests run on hundreds of real devices simultaneously in the cloud\nD) It doesn't require writing test code\n\n### Question 2\nWhat two files do you need to run Android integration tests on Test Lab?\n\nA) Only the app APK\nB) App APK and test APK\nC) App APK and pubspec.yaml\nD) Just the Dart test files\n\n### Question 3\nWhat are Robo tests?\n\nA) Tests written in Robot Framework\nB) Automated UI tests that explore your app without test code\nC) Tests that run on robotic devices\nD) A deprecated testing method\n\n### Question 4\nHow many free physical device tests does Firebase Test Lab provide per day?\n\nA) Unlimited\nB) 5 tests per day\nC) 10 tests per day\nD) 100 tests per day\n\n### Question 5\nWhen should you run Firebase Test Lab tests in your CI/CD pipeline?\n\nA) After every single commit\nB) After unit tests pass and before merging to main\nC) Only once per month\nD) Never - only run manually\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Question 1: C** - The main advantage is testing on hundreds of real devices simultaneously in Google's cloud infrastructure. This catches device-specific bugs impossible to find with just local testing.\n\n**Question 2: B** - You need both the app APK (your app in debug mode) and the test APK (your integration tests packaged as instrumentation tests).\n\n**Question 3: B** - Robo tests are automated UI tests where Google's AI explores your app by tapping buttons, filling forms, and navigating screens without requiring written test code.\n\n**Question 4: C** - The free tier provides 10 physical device tests per day and 5 virtual device tests per day.\n\n**Question 5: B** - Best practice is to run Test Lab after unit tests pass and before merging to main. This catches issues early while keeping costs reasonable.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nIn this lesson, you learned:\n\n‚úÖ **Firebase Test Lab** runs your app on hundreds of real devices in the cloud\n‚úÖ Test on **physical Android and iOS devices** to catch device-specific bugs\n‚úÖ Build **app APKs and test APKs** for Android, **test bundles** for iOS\n‚úÖ Use **Robo tests** for quick automated exploration without test code\n‚úÖ Analyze **videos, screenshots, logs, and performance metrics** for each device\n‚úÖ Integrate Test Lab into **CI/CD pipelines** with GitHub Actions or Codemagic\n‚úÖ Free tier provides **10 physical device tests/day** for development\n‚úÖ Choose **representative devices** to balance coverage and cost\n\n**Key Takeaway:** Firebase Test Lab is essential for production apps. It's the difference between \"works on my device\" and \"works on 10,000+ device configurations worldwide.\" Integrate it into your release pipeline to catch device-specific bugs before users do.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn **Lesson 10.6: Test Coverage and Reporting**, you'll learn how to measure which parts of your code are tested, generate coverage reports, and identify untested code that needs more tests.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.7",
          "title": "View in browser",
          "moduleId": "module-10",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Learning Objectives",
              "content": "By the end of this lesson, you will be able to:\n- Understand what test coverage is and why it matters\n- Generate test coverage reports for your Flutter project\n- Interpret coverage metrics (line, function, and branch coverage)\n- Exclude generated files from coverage reports\n- Visualize coverage data in VSCode and HTML reports\n- Set coverage targets and enforce them in CI/CD\n- Identify untested code and improve coverage strategically\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\n### What is Test Coverage?\n\n**Concept First:**\nImagine you're a safety inspector testing all the fire exits in a building. You check each door one by one, marking them off on your floor plan. When you're done, you can see which exits you tested (highlighted in green) and which you didn't test yet (still red). That marked floor plan is your \"coverage report.\"\n\n**Test coverage** measures which parts of your code are executed when your tests run. It shows you:\n- ‚úÖ **Green (covered)**: Code that's tested\n- ‚ùå **Red (uncovered)**: Code that's NOT tested\n- ‚ö†Ô∏è **Yellow (partially covered)**: Code that's only sometimes tested\n\n**Jargon:**\n- **Line Coverage**: Percentage of code lines executed by tests\n- **Function Coverage**: Percentage of functions/methods called by tests\n- **Branch Coverage**: Percentage of decision paths (if/else, switch) tested\n- **LCOV**: Linux Code Coverage tool, the standard format for coverage data\n- **lcov.info**: The file containing raw coverage data\n\n### Why This Matters\n\n**Real-world scenario:** You have 10,000 lines of code. Your tests pass ‚úÖ, so everything's fine, right?\n\n**Not necessarily!** Your tests might only execute 30% of your code. That means 7,000 lines are completely untested and could have bugs lurking.\n\n**Coverage helps you:**\n1. **Find blind spots**: Discover code paths never executed by tests\n2. **Prioritize testing**: Focus on critical untested code\n3. **Track progress**: Measure improvement over time\n4. **Catch regressions**: Ensure new code is tested\n5. **Build confidence**: Know what's actually verified\n\n**Important note:** 100% coverage ‚â† perfect code. But 30% coverage definitely means 70% is unverified!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 1: Understanding Coverage Metrics",
              "content": "\n### Line Coverage\n\n**What it measures:** Percentage of code lines executed during tests\n\n\n\n**Line coverage: 50%** (1 out of 2 lines tested)\n\n### Function Coverage\n\n**What it measures:** Percentage of functions/methods called during tests\n\n\n\n**Function coverage: 50%** (2 out of 4 functions tested)\n\n### Branch Coverage\n\n**What it measures:** Percentage of decision paths tested\n\n\n\n**Branch coverage: 33%** (1 out of 3 branches tested)\n\n**To reach 100% branch coverage:**\n\n**Branch coverage: 100%** ‚úÖ\n\n",
              "code": "test('negative age', () {\n  expect(validateAge(-5), 'Age cannot be negative');\n});\n\ntest('underage', () {\n  expect(validateAge(15), 'Must be 18 or older');\n});\n\ntest('valid age', () {\n  expect(validateAge(25), 'Valid');\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 2: Generating Coverage Reports",
              "content": "\n### Step 1: Run Tests with Coverage\n\n\nThis creates:\n\n### Step 2: View Coverage in Terminal\n\nInstall `lcov` tools:\n\n\nGenerate summary:\n\n### Step 3: Generate HTML Report\n\n\n**HTML report shows:**\n- üìä Overall coverage percentage\n- üìÅ Coverage by directory and file\n- üìù Line-by-line coverage with highlighting\n- üî¥ Red lines = untested code\n- üü¢ Green lines = tested code\n\n",
              "code": "genhtml coverage/lcov.info -o coverage/html\n\nopen coverage/html/index.html  # macOS\nxdg-open coverage/html/index.html  # Linux\nstart coverage/html/index.html  # Windows",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Section 3: Excluding Generated Files",
              "content": "\n### The Problem\n\nFlutter generates files that pollute coverage reports:\n- `*.g.dart` (code generation from build_runner)\n- `*.freezed.dart` (freezed package)\n- `*.gr.dart` (auto_route)\n- `*.config.dart` (various packages)\n\n### Solution: Remove Generated Files from Coverage\n\n\n### Automated Cleanup Script\n\nCreate `scripts/coverage.sh`:\n\n\nMake it executable:\n\nRun it:\n\n",
              "code": "./scripts/coverage.sh",
              "language": "bash"
            },
            {
              "type": "KEY_POINT",
              "title": "Section 4: Visualizing Coverage in VSCode",
              "content": "\n### Option 1: Flutter Coverage Extension\n\n1. Install **Flutter Coverage** extension in VSCode\n2. Run: `flutter test --coverage`\n3. Press `Cmd+Shift+P` (Mac) or `Ctrl+Shift+P` (Windows/Linux)\n4. Type \"Flutter Coverage: Toggle\"\n5. See coverage highlighting directly in your code!\n\n**Color coding:**\n- üü¢ Green highlight = tested line\n- üî¥ Red highlight = untested line\n- No highlight = not executable (comments, declarations)\n\n### Option 2: Coverage Gutters Extension\n\n1. Install **Coverage Gutters** extension in VSCode\n2. Run: `flutter test --coverage`\n3. Click \"Watch\" in the status bar\n4. See coverage in the gutter (line numbers area)\n\n**Gutter indicators:**\n- ‚úÖ Green dot = line covered\n- ‚ùå Red dot = line not covered\n\n### Option 3: Both Extensions Together\n\nUse both for the best experience:\n- **Flutter Coverage**: Highlights entire lines\n- **Coverage Gutters**: Shows gutter indicators + branch coverage\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 5: Setting Coverage Targets",
              "content": "\n### Why Set Coverage Targets?\n\n**Target = Minimum acceptable coverage percentage**\n\nExamples:\n- **Startups/Prototypes**: 50-60% (move fast, iterate)\n- **Production apps**: 70-80% (balanced quality and speed)\n- **Critical systems**: 90%+ (healthcare, finance, aviation)\n\n### Enforcing Coverage in CI/CD\n\n#### Method 1: Using lcov (Basic)\n\n\n#### Method 2: Using test_coverage Package\n\n\n\n### GitHub Actions with Coverage Check\n\n\n",
              "code": "name: Test Coverage\n\non:\n  pull_request:\n    branches: [ main ]\n\njobs:\n  coverage:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.24.0'\n\n      - name: Install dependencies\n        run: flutter pub get\n\n      - name: Run tests with coverage\n        run: flutter test --coverage\n\n      - name: Check coverage meets minimum\n        run: |\n          sudo apt-get install lcov\n          lcov --remove coverage/lcov.info '*.g.dart' -o coverage/lcov.info\n\n          COVERAGE=$(lcov --summary coverage/lcov.info 2>&1 | \\\n            grep 'lines......:' | \\\n            grep -oP '\\d+\\.\\d+(?=%)')\n\n          echo \"Coverage: ${COVERAGE}%\"\n\n          if (( $(echo \"$COVERAGE < 70\" | bc -l) )); then\n            echo \"‚ùå Coverage below 70%\"\n            exit 1\n          fi\n\n      - name: Upload coverage to Codecov (optional)\n        uses: codecov/codecov-action@v3\n        with:\n          files: ./coverage/lcov.info",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Section 6: Improving Coverage Strategically",
              "content": "\n### Step 1: Identify Untested Code\n\n\n### Step 2: Prioritize What to Test\n\n**Not all code is equally important to test!**\n\n**High priority (test first):**\n- ‚úÖ Business logic (calculations, validations, algorithms)\n- ‚úÖ Data transformations and processing\n- ‚úÖ Error handling and edge cases\n- ‚úÖ Public APIs and interfaces\n\n**Medium priority:**\n- ‚ö†Ô∏è UI logic (can use widget tests)\n- ‚ö†Ô∏è Network layer (can mock)\n- ‚ö†Ô∏è Database operations\n\n**Low priority (okay to skip):**\n- ‚è© Generated code (*.g.dart)\n- ‚è© Simple getters/setters\n- ‚è© Trivial constructors\n- ‚è© UI widgets (covered by widget/integration tests)\n\n### Step 3: Write Tests for Uncovered Code\n\n**Example: Untested validator**\n\n\n**Coverage report shows:** 0% coverage for `isValid`\n\n**Write tests:**\n\n\n**New coverage:** 100% ‚úÖ\n\n### Step 4: Track Coverage Over Time\n\nCreate a coverage badge for your README:\n\n\n\n**Use Codecov or Coveralls for automatic tracking:**\n\n\nVisit [codecov.io](https://codecov.io) to see coverage trends over time.\n\n",
              "code": "- name: Upload to Codecov\n  uses: codecov/codecov-action@v3\n  with:\n    files: ./coverage/lcov.info\n    fail_ci_if_error: true",
              "language": "yaml"
            },
            {
              "type": "WARNING",
              "title": "Section 7: Common Coverage Pitfalls",
              "content": "\n### Pitfall 1: Chasing 100% Coverage\n\n**Bad mindset:**\n\n**Good mindset:**\n\n**Why:** Writing tests for trivial getters/setters wastes time. Focus on logic, not coverage percentage.\n\n### Pitfall 2: Testing Implementation, Not Behavior\n\n**Bad test (testing implementation):**\n\n**Good test (testing behavior):**\n\n### Pitfall 3: Including Generated Files in Coverage\n\n**Problem:** Generated files artificially lower coverage\n\n**Solution:** Always exclude them:\n\n### Pitfall 4: Not Testing Edge Cases\n\n**Weak test:**\n\n**Strong test:**\n\n",
              "code": "group('divide', () {\n  test('works with positive numbers', () {\n    expect(divide(10, 2), 5);\n  });\n\n  test('works with negative numbers', () {\n    expect(divide(-10, 2), -5);\n  });\n\n  test('throws on division by zero', () {\n    expect(() => divide(10, 0), throwsException);\n  });\n});",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Coverage Workflow",
              "content": "\n### Project Setup\n\n\n### Script: scripts/coverage.sh\n\n\n### GitHub Actions: .github/workflows/coverage.yml\n\n\n### Running Locally\n\n\n",
              "code": "chmod +x scripts/coverage.sh\n\n./scripts/coverage.sh\n\nopen coverage/html/index.html  # macOS\nxdg-open coverage/html/index.html  # Linux\nstart coverage/html/index.html  # Windows",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\nTest your understanding of test coverage:\n\n### Question 1\nWhat does 80% line coverage mean?\n\nA) 80% of functions are tested\nB) 80% of code lines are executed by tests\nC) 80% of branches are tested\nD) 80% of tests pass\n\n### Question 2\nWhy should you exclude `*.g.dart` files from coverage reports?\n\nA) They contain bugs\nB) They're generated code that you don't write\nC) They're too large\nD) They're deprecated\n\n### Question 3\nWhat's the command to generate coverage data in Flutter?\n\nA) `flutter test --coverage`\nB) `flutter coverage`\nC) `flutter test --cov`\nD) `flutter analyze --coverage`\n\n### Question 4\nWhat's a reasonable coverage target for a production Flutter app?\n\nA) 30-40%\nB) 50-60%\nC) 70-80%\nD) 100%\n\n### Question 5\nWhich code should you prioritize testing?\n\nA) Generated files (*.g.dart)\nB) Simple getters and setters\nC) Business logic and data transformations\nD) UI widget constructors\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Question 1: B** - Line coverage measures the percentage of code lines that are executed when tests run. 80% means 80 out of 100 lines were executed.\n\n**Question 2: B** - Generated files (*.g.dart, *.freezed.dart) are created by code generation tools. You don't write them, so testing coverage of generated code isn't meaningful.\n\n**Question 3: A** - Use `flutter test --coverage` to run tests and generate coverage data in the `coverage/lcov.info` file.\n\n**Question 4: C** - For production apps, 70-80% is a balanced target. It ensures critical code is tested without spending excessive time on trivial code. Critical systems (healthcare, finance) may require 90%+.\n\n**Question 5: C** - Prioritize testing business logic, algorithms, calculations, validations, and data transformations. These are where bugs have the most impact. Skip trivial getters, setters, and generated code.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nIn this lesson, you learned:\n\n‚úÖ **Test coverage** measures which code is executed by tests\n‚úÖ Three metrics: **line, function, and branch coverage**\n‚úÖ Generate coverage with `flutter test --coverage`\n‚úÖ Create HTML reports with `genhtml coverage/lcov.info -o coverage/html`\n‚úÖ **Exclude generated files** (*.g.dart) from coverage reports\n‚úÖ Visualize coverage in VSCode with **Flutter Coverage** and **Coverage Gutters**\n‚úÖ Set **coverage targets** (70-80% for production apps)\n‚úÖ Enforce coverage in CI/CD to prevent regressions\n‚úÖ Prioritize testing **business logic** over trivial code\n‚úÖ Track coverage over time with Codecov or Coveralls\n\n**Key Takeaway:** Test coverage is a powerful tool to identify untested code, but it's not the goal itself. Focus on testing meaningful business logic and critical paths. A project with 70% coverage of the right code is better than 95% coverage of trivial code.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn **Lesson 10.7: CI/CD for Flutter Apps**, you'll learn how to automate your entire testing pipeline‚Äîrunning unit tests, widget tests, integration tests, and coverage checks automatically on every commit using GitHub Actions, Codemagic, and other CI/CD platforms.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.8",
          "title": "CI/CD for Flutter Apps",
          "moduleId": "module-10",
          "order": 8,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Learning Objectives",
              "content": "By the end of this lesson, you will be able to:\n- Understand what CI/CD is and why it's essential for modern development\n- Set up GitHub Actions for automated Flutter testing and building\n- Configure Codemagic for Flutter CI/CD with minimal setup\n- Automate testing, building, and deployment workflows\n- Run tests automatically on every pull request\n- Deploy apps to TestFlight and Google Play automatically\n- Implement quality gates (linting, testing, coverage)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\n### What is CI/CD?\n\n**Concept First:**\nImagine you're running a bakery. Without automation, you:\n1. Manually mix ingredients for every bread loaf\n2. Check each loaf by hand to ensure quality\n3. Drive each delivery to customers yourself\n4. Work 20 hours a day, exhausted\n\nWith automation (CI/CD), you:\n1. Machines mix ingredients consistently\n2. Quality sensors check each loaf automatically\n3. Delivery trucks automatically route to customers\n4. You oversee the process, focus on new recipes\n5. Run 24/7 without exhaustion\n\n**CI/CD** brings the same automation to software development.\n\n**Jargon:**\n- **CI (Continuous Integration)**: Automatically test and integrate code changes\n- **CD (Continuous Deployment)**: Automatically deploy tested code to users\n- **Pipeline**: A series of automated steps (test ‚Üí build ‚Üí deploy)\n- **Workflow**: Configuration file defining what CI/CD should do\n- **Runner**: Server that executes your CI/CD pipeline\n- **Artifact**: Build output (APK, IPA, test reports)\n\n### Why This Matters\n\n**Without CI/CD:**\n- Developer pushes code ‚Üí manually run tests ‚Üí might forget ‚Üí bugs slip through\n- Building APKs/IPAs locally ‚Üí \"works on my machine\" syndrome\n- Manual deployment ‚Üí error-prone, time-consuming\n- No consistent quality checks\n\n**With CI/CD:**\n- Every code push ‚Üí automatic tests ‚úÖ\n- Pull requests blocked if tests fail üö´\n- Builds created automatically on consistent machines\n- Deploy to stores with one click or automatically\n- Catch bugs before they reach users\n\n**Real-world impact:**\n- **Faster releases**: Deploy multiple times per day instead of per month\n- **Higher quality**: Every change is tested automatically\n- **Less stress**: No manual deployment at 2 AM\n- **Team scalability**: 10 developers can work together safely\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 1: Understanding CI/CD Pipelines",
              "content": "\n### The CI/CD Workflow\n\n\n### Popular CI/CD Platforms for Flutter (2025)\n\n| Platform | Best For | Free Tier | Flutter Support |\n|----------|----------|-----------|----------------|\n| **GitHub Actions** | GitHub projects | 2000 min/month | Excellent |\n| **Codemagic** | Flutter-first | 500 min/month | Native |\n| **CircleCI** | Docker workflows | 6000 min/month | Good |\n| **GitLab CI** | GitLab projects | 400 min/month | Good |\n| **Bitrise** | Mobile apps | 90 min/month | Excellent |\n\n**Recommendation for beginners:** Start with GitHub Actions (most projects use GitHub) or Codemagic (easiest for Flutter).\n\n",
              "code": "Developer pushes code\n    ‚Üì\n1. CODE ANALYSIS (2 min)\n   - Linting (flutter analyze)\n   - Code formatting check\n    ‚Üì\n2. TESTING (5 min)\n   - Unit tests\n   - Widget tests\n   - Test coverage check\n    ‚Üì\n3. BUILD (10 min)\n   - Build Android APK\n   - Build iOS IPA\n    ‚Üì\n4. INTEGRATION TESTING (15 min)\n   - Firebase Test Lab\n   - Multiple devices\n    ‚Üì\n5. DEPLOYMENT (automatic if all pass)\n   - Deploy to TestFlight (iOS)\n   - Deploy to Google Play Internal Track (Android)\n    ‚Üì\n6. NOTIFICATION\n   - Slack/email notification\n   - GitHub status check ‚úÖ",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 2: Setting Up GitHub Actions",
              "content": "\n### Step 1: Create Workflow File\n\nGitHub Actions workflows live in `.github/workflows/`.\n\n\n### Step 2: Basic Flutter CI Workflow\n\nCreate `.github/workflows/flutter_ci.yml`:\n\n\n### Step 3: Commit and Push\n\n\n### Step 4: View Results\n\n1. Go to your GitHub repository\n2. Click \"Actions\" tab\n3. See your workflow running!\n4. ‚úÖ Green checkmark = all passed\n5. ‚ùå Red X = something failed\n\n### Advanced: Multi-Platform CI\n\nTest on Linux, macOS, and Windows:\n\n\n",
              "code": "name: Flutter CI (Multi-Platform)\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    name: Test on ${{ matrix.os }}\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, macos-latest, windows-latest]\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.24.0'\n          channel: 'stable'\n\n      - name: Install dependencies\n        run: flutter pub get\n\n      - name: Run tests\n        run: flutter test\n\n      - name: Build\n        run: |\n          if [ \"$RUNNER_OS\" == \"Linux\" ]; then\n            flutter build apk --debug\n          elif [ \"$RUNNER_OS\" == \"macOS\" ]; then\n            flutter build ios --no-codesign\n          elif [ \"$RUNNER_OS\" == \"Windows\" ]; then\n            flutter build windows\n          fi\n        shell: bash",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Section 3: Advanced GitHub Actions Workflows",
              "content": "\n### Workflow with Test Coverage Enforcement\n\n\n### Workflow with Firebase Test Lab\n\n\n### Workflow for Automatic Deployment to Stores\n\n\n",
              "code": "name: Deploy to Stores\n\non:\n  push:\n    tags:\n      - 'v*'  # Trigger on version tags like v1.0.0\n\njobs:\n  deploy-android:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.24.0'\n\n      - uses: actions/setup-java@v3\n        with:\n          distribution: 'zulu'\n          java-version: '17'\n\n      - name: Build Android App Bundle\n        run: flutter build appbundle --release\n\n      - name: Sign APK\n        uses: r0adkll/sign-android-release@v1\n        with:\n          releaseDirectory: build/app/outputs/bundle/release\n          signingKeyBase64: ${{ secrets.SIGNING_KEY }}\n          alias: ${{ secrets.KEY_ALIAS }}\n          keyStorePassword: ${{ secrets.KEY_STORE_PASSWORD }}\n          keyPassword: ${{ secrets.KEY_PASSWORD }}\n\n      - name: Deploy to Google Play\n        uses: r0adkll/upload-google-play@v1\n        with:\n          serviceAccountJsonPlainText: ${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT }}\n          packageName: com.yourcompany.yourapp\n          releaseFiles: build/app/outputs/bundle/release/*.aab\n          track: internal  # or: alpha, beta, production\n\n  deploy-ios:\n    runs-on: macos-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.24.0'\n\n      - name: Build iOS app\n        run: flutter build ios --release --no-codesign\n\n      - name: Build and sign with Xcode\n        run: |\n          cd ios\n          xcodebuild -workspace Runner.xcworkspace \\\n            -scheme Runner \\\n            -configuration Release \\\n            -archivePath $PWD/build/Runner.xcarchive \\\n            archive\n\n          xcodebuild -exportArchive \\\n            -archivePath $PWD/build/Runner.xcarchive \\\n            -exportPath $PWD/build \\\n            -exportOptionsPlist ExportOptions.plist\n\n      - name: Upload to TestFlight\n        uses: apple-actions/upload-testflight-build@v1\n        with:\n          app-path: 'ios/build/Runner.ipa'\n          issuer-id: ${{ secrets.APPSTORE_ISSUER_ID }}\n          api-key-id: ${{ secrets.APPSTORE_API_KEY_ID }}\n          api-private-key: ${{ secrets.APPSTORE_API_PRIVATE_KEY }}",
              "language": "yaml"
            },
            {
              "type": "EXAMPLE",
              "title": "Section 4: Setting Up Codemagic",
              "content": "\nCodemagic is Flutter-first and easier to set up than GitHub Actions.\n\n### Step 1: Sign Up for Codemagic\n\n1. Go to [codemagic.io](https://codemagic.io)\n2. Sign up with GitHub, GitLab, or Bitbucket\n3. Grant access to your repositories\n\n### Step 2: Add Your Flutter App\n\n1. Click \"Add application\"\n2. Select your repository\n3. Codemagic auto-detects it's a Flutter project ‚úÖ\n\n### Step 3: Configure Workflow (UI Method)\n\n**Easiest way: Use the workflow editor**\n\n1. Click \"Start your first build\"\n2. Codemagic automatically:\n   - ‚úÖ Installs Flutter\n   - ‚úÖ Runs `flutter pub get`\n   - ‚úÖ Runs `flutter test`\n   - ‚úÖ Builds Android APK\n3. Click \"Start new build\"\n\n**That's it!** Codemagic handles everything.\n\n### Step 4: Configure Workflow (YAML Method)\n\nFor more control, create `codemagic.yaml` in your repository root:\n\n\n### Step 5: Automatic Deployment with Codemagic\n\n\n### Codemagic Features\n\n‚úÖ **Pre-installed Flutter** - No setup needed\n‚úÖ **Apple M1 machines** - Super fast iOS builds\n‚úÖ **Automatic code signing** - Handles certificates for you\n‚úÖ **Store publishing built-in** - One-click deployment\n‚úÖ **Visual workflow editor** - No YAML knowledge needed\n‚úÖ **Free tier** - 500 minutes/month\n\n",
              "code": "workflows:\n  deploy-workflow:\n    name: Deploy to Stores\n    max_build_duration: 60\n    instance_type: mac_mini_m1\n\n    environment:\n      groups:\n        - google_play  # Credentials stored in Codemagic\n        - app_store\n\n    scripts:\n      - name: Get dependencies\n        script: flutter pub get\n\n      - name: Run tests\n        script: flutter test\n\n      - name: Build Android App Bundle\n        script: flutter build appbundle --release\n\n      - name: Build iOS\n        script: |\n          flutter build ipa --release \\\n            --export-options-plist=ios/ExportOptions.plist\n\n    artifacts:\n      - build/app/outputs/bundle/release/*.aab\n      - build/ios/ipa/*.ipa\n\n    publishing:\n      google_play:\n        credentials: $GOOGLE_PLAY_CREDENTIALS\n        track: internal  # or: alpha, beta, production\n        in_app_update_priority: 3\n\n      app_store_connect:\n        api_key: $APP_STORE_CONNECT_API_KEY\n        key_id: $APP_STORE_CONNECT_KEY_ID\n        issuer_id: $APP_STORE_CONNECT_ISSUER_ID\n        submit_to_testflight: true\n\n      email:\n        recipients:\n          - team@example.com\n        notify:\n          success: true",
              "language": "yaml"
            },
            {
              "type": "EXPERIMENT",
              "title": "Section 5: Quality Gates and Best Practices",
              "content": "\n### What are Quality Gates?\n\n**Quality gates** are checks that must pass before code is merged or deployed.\n\n### Essential Quality Gates\n\n1. **Linting** - Code must follow style guidelines\n2. **Unit Tests** - All tests must pass\n3. **Widget Tests** - UI tests must pass\n4. **Coverage** - Minimum coverage threshold\n5. **Integration Tests** - Critical flows work\n6. **Build Success** - App must build without errors\n\n### Implementing Quality Gates\n\n\n### Branch Protection Rules\n\nEnforce quality gates in GitHub:\n\n1. Go to **Settings** ‚Üí **Branches**\n2. Add rule for `main` branch\n3. Enable:\n   - ‚òëÔ∏è Require a pull request before merging\n   - ‚òëÔ∏è Require status checks to pass before merging\n   - ‚òëÔ∏è Require branches to be up to date before merging\n4. Select required checks:\n   - ‚úÖ Analyze code\n   - ‚úÖ Run tests\n   - ‚úÖ Check coverage\n\nNow PRs can't be merged until all checks pass!\n\n",
              "code": "name: Quality Gates\n\non:\n  pull_request:\n    branches: [ main ]\n\njobs:\n  quality-check:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.24.0'\n\n      - name: Install dependencies\n        run: flutter pub get\n\n      # Gate 1: Formatting\n      - name: Check formatting\n        run: dart format --set-exit-if-changed .\n\n      # Gate 2: Linting\n      - name: Analyze code\n        run: flutter analyze --fatal-infos\n\n      # Gate 3: Unit tests\n      - name: Run unit tests\n        run: flutter test --exclude-tags=integration\n\n      # Gate 4: Coverage threshold\n      - name: Check test coverage\n        run: |\n          flutter test --coverage\n          sudo apt-get install -y lcov\n          lcov --remove coverage/lcov.info '*.g.dart' -o coverage/lcov.info\n\n          COVERAGE=$(lcov --summary coverage/lcov.info 2>&1 | \\\n            grep 'lines......:' | \\\n            grep -oP '\\d+\\.\\d+(?=%)')\n\n          if (( $(echo \"$COVERAGE < 70\" | bc -l) )); then\n            echo \"‚ùå Coverage ${COVERAGE}% below 70%\"\n            exit 1\n          fi\n\n      # Gate 5: Build success\n      - name: Build APK\n        run: flutter build apk --debug",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Section 6: Common CI/CD Patterns",
              "content": "\n### Pattern 1: Separate Workflows by Purpose\n\n\n**ci.yml** (fast, runs always):\n\n**integration.yml** (slow, runs on main only):\n\n**deploy.yml** (manual trigger):\n\n### Pattern 2: Caching for Faster Builds\n\n\n**Result:** Builds go from 10 minutes ‚Üí 2 minutes! ‚ö°\n\n### Pattern 3: Matrix Testing\n\nTest multiple Flutter versions:\n\n\n",
              "code": "jobs:\n  test:\n    strategy:\n      matrix:\n        flutter-version: ['3.22.0', '3.24.0']\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: ${{ matrix.flutter-version }}\n\n      - run: flutter test",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Section 7: Monitoring and Notifications",
              "content": "\n### Slack Notifications\n\n\n### Email Notifications (Codemagic)\n\n\n",
              "code": "publishing:\n  email:\n    recipients:\n      - dev-team@company.com\n      - qa-team@company.com\n    notify:\n      success: true\n      failure: true",
              "language": "yaml"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Production-Ready CI/CD",
              "content": "\n### Project Structure\n\n\n### ci.yml (Runs on every PR)\n\n\n",
              "code": "name: CI\n\non:\n  pull_request:\n    branches: [ main ]\n  push:\n    branches: [ main ]\n\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    timeout-minutes: 20\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.24.0'\n          cache: true\n\n      - name: Install dependencies\n        run: flutter pub get\n\n      - name: Check formatting\n        run: dart format --set-exit-if-changed .\n\n      - name: Analyze code\n        run: flutter analyze --fatal-infos\n\n      - name: Run tests with coverage\n        run: flutter test --coverage --no-test-assets\n\n      - name: Check coverage\n        run: |\n          sudo apt-get install -y lcov\n          lcov --remove coverage/lcov.info '*.g.dart' -o coverage/lcov.info\n          COVERAGE=$(lcov --summary coverage/lcov.info 2>&1 | grep 'lines' | grep -oP '\\d+\\.\\d+(?=%)')\n          echo \"Coverage: ${COVERAGE}%\"\n          if (( $(echo \"$COVERAGE < 70\" | bc -l) )); then exit 1; fi\n\n      - name: Build APK\n        run: flutter build apk --debug",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\nTest your understanding of CI/CD for Flutter:\n\n### Question 1\nWhat does CI stand for?\n\nA) Code Integration\nB) Continuous Integration\nC) Computer Interaction\nD) Centralized Installation\n\n### Question 2\nWhat's the main benefit of CI/CD?\n\nA) Writes code for you\nB) Automatically tests and deploys code on every change\nC) Makes your app run faster\nD) Reduces app size\n\n### Question 3\nWhere do GitHub Actions workflows live in your project?\n\nA) `workflows/`\nB) `.ci/workflows/`\nC) `.github/workflows/`\nD) `github/actions/`\n\n### Question 4\nWhat's a \"quality gate\"?\n\nA) A firewall for your code\nB) A check that must pass before code can be merged\nC) A premium GitHub feature\nD) An iOS app submission requirement\n\n### Question 5\nWhich CI/CD platform is Flutter-first with native support?\n\nA) Jenkins\nB) Travis CI\nC) Codemagic\nD) CircleCI\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Question 1: B** - CI stands for **Continuous Integration**, the practice of automatically integrating and testing code changes as they're made.\n\n**Question 2: B** - The main benefit is **automation**: CI/CD automatically runs tests, builds, and deployments on every code change, catching issues early and enabling rapid releases.\n\n**Question 3: C** - GitHub Actions workflows are stored in the **`.github/workflows/`** directory as YAML files.\n\n**Question 4: B** - A quality gate is a **check that must pass** before code can be merged (e.g., tests passing, coverage above threshold, no linting errors).\n\n**Question 5: C** - **Codemagic** is built specifically for Flutter with native support, pre-installed Flutter, automatic iOS code signing, and one-click store publishing.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nIn this lesson, you learned:\n\n‚úÖ **CI/CD automates** testing, building, and deployment workflows\n‚úÖ **GitHub Actions** uses `.github/workflows/*.yml` files\n‚úÖ **Codemagic** provides Flutter-first CI/CD with minimal setup\n‚úÖ **Quality gates** enforce code standards before merging\n‚úÖ Run tests automatically on every **pull request**\n‚úÖ **Cache dependencies** to speed up builds (10 min ‚Üí 2 min)\n‚úÖ Deploy to stores automatically with **one click or on every tag**\n‚úÖ Monitor builds with **Slack/email notifications**\n‚úÖ Use **branch protection** to block PRs until checks pass\n\n**Key Takeaway:** CI/CD transforms development from manual, error-prone processes to automated, reliable pipelines. Set it up once, and every code change is automatically tested and validated. This lets you deploy confidently multiple times per day instead of dreading monthly releases.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn **Lesson 10.8: Testing Best Practices Mini-Project**, you'll apply everything you've learned by building a complete Flutter app with a full testing suite‚Äîunit tests, widget tests, integration tests, coverage reporting, and CI/CD automation all working together.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.9",
          "title": "Testing Best Practices Mini-Project",
          "moduleId": "module-10",
          "order": 9,
          "estimatedMinutes": 55,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\n**Project Name:** TaskMaster Pro - A production-ready task management app\n\n**What You'll Build:**\nA complete Flutter task management application with:\n- ‚úÖ Comprehensive test suite (unit, widget, integration)\n- ‚úÖ 80%+ test coverage\n- ‚úÖ CI/CD pipeline with GitHub Actions\n- ‚úÖ Firebase Test Lab integration\n- ‚úÖ Automated coverage reporting\n- ‚úÖ Production-ready code quality\n\n**Duration:** 4-6 hours\n\n**Learning Objectives:**\nBy completing this project, you will:\n- Apply all testing concepts from Module 10\n- Build a fully tested production-ready app\n- Set up complete CI/CD pipeline\n- Implement best practices for maintainable tests\n- Understand when to use each type of test\n- Create a portfolio project demonstrating testing expertise\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 1: Project Requirements",
              "content": "\n### Functional Requirements\n\n**TaskMaster Pro** should allow users to:\n\n1. **Task Management**\n   - Create tasks with title, description, due date\n   - Mark tasks as complete/incomplete\n   - Delete tasks\n   - Edit existing tasks\n\n2. **Task Organization**\n   - Filter tasks (All, Active, Completed)\n   - Sort tasks (by date, by priority, by title)\n   - Search tasks by title\n\n3. **Data Persistence**\n   - Save tasks locally using Hive\n   - Load tasks on app startup\n   - Maintain state across app restarts\n\n4. **Statistics**\n   - Show total tasks count\n   - Show completed tasks percentage\n   - Show overdue tasks count\n\n### Testing Requirements\n\n**You must implement:**\n\n1. **Unit Tests** (70% of total tests)\n   - Task model validation\n   - Date utilities\n   - Filtering and sorting logic\n   - Statistics calculations\n   - Repository operations\n\n2. **Widget Tests** (20% of total tests)\n   - Task list widget\n   - Task item widget\n   - Filter buttons\n   - Add task form\n   - Statistics widget\n\n3. **Integration Tests** (10% of total tests)\n   - Complete task creation flow\n   - Complete task editing flow\n   - Filter and search flow\n   - Delete task flow\n\n4. **Quality Requirements**\n   - Minimum 80% code coverage\n   - All tests must pass\n   - Linting with no warnings\n   - Formatted code (dart format)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 2: Project Setup",
              "content": "\n### Step 1: Create Flutter Project\n\n\n### Step 2: Add Dependencies\n\n\nRun:\n\n### Step 3: Create Project Structure\n\n\n",
              "code": "task_master_pro/\n‚îú‚îÄ‚îÄ lib/\n‚îÇ   ‚îú‚îÄ‚îÄ main.dart\n‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task.g.dart (generated)\n‚îÇ   ‚îú‚îÄ‚îÄ repositories/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task_repository.dart\n‚îÇ   ‚îú‚îÄ‚îÄ bloc/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_bloc.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_event.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task_state.dart\n‚îÇ   ‚îú‚îÄ‚îÄ screens/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ home_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ add_edit_task_screen.dart\n‚îÇ   ‚îú‚îÄ‚îÄ widgets/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_list.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_item.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ filter_buttons.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ statistics_widget.dart\n‚îÇ   ‚îî‚îÄ‚îÄ utils/\n‚îÇ       ‚îî‚îÄ‚îÄ date_utils.dart\n‚îú‚îÄ‚îÄ test/\n‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task_test.dart\n‚îÇ   ‚îú‚îÄ‚îÄ repositories/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task_repository_test.dart\n‚îÇ   ‚îú‚îÄ‚îÄ bloc/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task_bloc_test.dart\n‚îÇ   ‚îú‚îÄ‚îÄ widgets/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_list_test.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_item_test.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ filter_buttons_test.dart\n‚îÇ   ‚îî‚îÄ‚îÄ utils/\n‚îÇ       ‚îî‚îÄ‚îÄ date_utils_test.dart\n‚îú‚îÄ‚îÄ integration_test/\n‚îÇ   ‚îú‚îÄ‚îÄ app_test.dart\n‚îÇ   ‚îî‚îÄ‚îÄ task_flow_test.dart\n‚îú‚îÄ‚îÄ scripts/\n‚îÇ   ‚îú‚îÄ‚îÄ coverage.sh\n‚îÇ   ‚îî‚îÄ‚îÄ run_all_tests.sh\n‚îî‚îÄ‚îÄ .github/\n    ‚îî‚îÄ‚îÄ workflows/\n        ‚îú‚îÄ‚îÄ ci.yml\n        ‚îî‚îÄ‚îÄ integration.yml",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 3: Implementation - Models and Tests",
              "content": "\n### Task Model\n\n\n### Unit Tests for Task Model\n\n\n**Run tests:**\n\n**Expected output:**\n\n",
              "code": "00:02 +22: All tests passed!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 4: Repository and Tests",
              "content": "\n### Task Repository\n\n\n### Unit Tests for Repository (with Mocking)\n\n\n",
              "code": "// test/repositories/task_repository_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:task_master_pro/models/task.dart';\nimport 'package:task_master_pro/repositories/task_repository.dart';\nimport 'package:hive_flutter/hive_flutter.dart';\n\nvoid main() {\n  group('HiveTaskRepository', () {\n    late HiveTaskRepository repository;\n\n    setUpAll(() async {\n      // Initialize Hive for testing (in-memory)\n      await Hive.initFlutter();\n      Hive.registerAdapter(TaskAdapter());\n    });\n\n    setUp(() async {\n      repository = HiveTaskRepository();\n      await repository.init();\n    });\n\n    tearDown() async {\n      // Clear all tasks after each test\n      final box = await Hive.openBox<Task>(HiveTaskRepository.boxName);\n      await box.clear();\n    });\n\n    tearDownAll() async {\n      await Hive.close();\n    });\n\n    test('getTasks returns empty list initially', () async {\n      // Act\n      final tasks = await repository.getTasks();\n\n      // Assert\n      expect(tasks, isEmpty);\n    });\n\n    test('addTask adds task to repository', () async {\n      // Arrange\n      final task = Task.create(\n        title: 'Test Task',\n        description: 'Test Desc',\n        dueDate: DateTime.now(),\n      );\n\n      // Act\n      await repository.addTask(task);\n      final tasks = await repository.getTasks();\n\n      // Assert\n      expect(tasks.length, 1);\n      expect(tasks.first.id, task.id);\n      expect(tasks.first.title, task.title);\n    });\n\n    test('updateTask updates existing task', () async {\n      // Arrange\n      final task = Task.create(\n        title: 'Original',\n        description: 'Desc',\n        dueDate: DateTime.now(),\n      );\n      await repository.addTask(task);\n\n      // Act\n      final updated = task.copyWith(title: 'Updated');\n      await repository.updateTask(updated);\n      final tasks = await repository.getTasks();\n\n      // Assert\n      expect(tasks.length, 1);\n      expect(tasks.first.title, 'Updated');\n    });\n\n    test('deleteTask removes task from repository', () async {\n      // Arrange\n      final task = Task.create(\n        title: 'Task to Delete',\n        description: 'Desc',\n        dueDate: DateTime.now(),\n      );\n      await repository.addTask(task);\n\n      // Act\n      await repository.deleteTask(task.id);\n      final tasks = await repository.getTasks();\n\n      // Assert\n      expect(tasks, isEmpty);\n    });\n\n    test('deleteAllCompletedTasks removes only completed tasks', () async {\n      // Arrange\n      final task1 = Task.create(\n        title: 'Task 1',\n        description: 'Desc',\n        dueDate: DateTime.now(),\n      ).copyWith(isCompleted: true);\n\n      final task2 = Task.create(\n        title: 'Task 2',\n        description: 'Desc',\n        dueDate: DateTime.now(),\n      ); // Not completed\n\n      final task3 = Task.create(\n        title: 'Task 3',\n        description: 'Desc',\n        dueDate: DateTime.now(),\n      ).copyWith(isCompleted: true);\n\n      await repository.addTask(task1);\n      await repository.addTask(task2);\n      await repository.addTask(task3);\n\n      // Act\n      await repository.deleteAllCompletedTasks();\n      final tasks = await repository.getTasks();\n\n      // Assert\n      expect(tasks.length, 1);\n      expect(tasks.first.id, task2.id); // Only incomplete task remains\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 5: Widget Tests",
              "content": "\n### Task Item Widget\n\n\n### Widget Test for Task Item\n\n\n",
              "code": "// test/widgets/task_item_test.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:task_master_pro/models/task.dart';\nimport 'package:task_master_pro/widgets/task_item.dart';\n\nvoid main() {\n  group('TaskItem Widget', () {\n    late Task testTask;\n\n    setUp(() {\n      testTask = Task(\n        id: '123',\n        title: 'Test Task',\n        description: 'Test Description',\n        dueDate: DateTime(2025, 12, 31),\n      );\n    });\n\n    Widget createWidgetUnderTest(Task task) {\n      return MaterialApp(\n        home: Scaffold(\n          body: TaskItem(\n            task: task,\n            onTap: () {},\n            onToggleComplete: (_) {},\n            onDelete: () {},\n          ),\n        ),\n      );\n    }\n\n    testWidgets('displays task title and description', (tester) async {\n      // Act\n      await tester.pumpWidget(createWidgetUnderTest(testTask));\n\n      // Assert\n      expect(find.text('Test Task'), findsOneWidget);\n      expect(find.text('Test Description'), findsOneWidget);\n    });\n\n    testWidgets('displays formatted due date', (tester) async {\n      // Act\n      await tester.pumpWidget(createWidgetUnderTest(testTask));\n\n      // Assert\n      expect(find.textContaining('Due: Dec 31, 2025'), findsOneWidget);\n    });\n\n    testWidgets('checkbox reflects completion status', (tester) async {\n      // Arrange\n      final completedTask = testTask.copyWith(isCompleted: true);\n\n      // Act\n      await tester.pumpWidget(createWidgetUnderTest(completedTask));\n      final checkbox = tester.widget<Checkbox>(\n        find.byKey(Key('checkbox_${completedTask.id}')),\n      );\n\n      // Assert\n      expect(checkbox.value, true);\n    });\n\n    testWidgets('completed task has strikethrough text', (tester) async {\n      // Arrange\n      final completedTask = testTask.copyWith(isCompleted: true);\n\n      // Act\n      await tester.pumpWidget(createWidgetUnderTest(completedTask));\n      final textWidget = tester.widget<Text>(find.text('Test Task'));\n\n      // Assert\n      expect(\n        textWidget.style?.decoration,\n        TextDecoration.lineThrough,\n      );\n    });\n\n    testWidgets('tapping checkbox calls onToggleComplete', (tester) async {\n      // Arrange\n      bool toggleCalled = false;\n      bool? toggledValue;\n\n      final widget = MaterialApp(\n        home: Scaffold(\n          body: TaskItem(\n            task: testTask,\n            onTap: () {},\n            onToggleComplete: (value) {\n              toggleCalled = true;\n              toggledValue = value;\n            },\n            onDelete: () {},\n          ),\n        ),\n      );\n\n      // Act\n      await tester.pumpWidget(widget);\n      await tester.tap(find.byKey(Key('checkbox_${testTask.id}')));\n\n      // Assert\n      expect(toggleCalled, true);\n      expect(toggledValue, true); // Toggled from false to true\n    });\n\n    testWidgets('tapping delete button calls onDelete', (tester) async {\n      // Arrange\n      bool deleteCalled = false;\n\n      final widget = MaterialApp(\n        home: Scaffold(\n          body: TaskItem(\n            task: testTask,\n            onTap: () {},\n            onToggleComplete: (_) {},\n            onDelete: () {\n              deleteCalled = true;\n            },\n          ),\n        ),\n      );\n\n      // Act\n      await tester.pumpWidget(widget);\n      await tester.tap(find.byKey(Key('delete_${testTask.id}')));\n\n      // Assert\n      expect(deleteCalled, true);\n    });\n\n    testWidgets('overdue task shows due date in red', (tester) async {\n      // Arrange\n      final overdueTask = testTask.copyWith(\n        dueDate: DateTime.now().subtract(const Duration(days: 1)),\n      );\n\n      // Act\n      await tester.pumpWidget(createWidgetUnderTest(overdueTask));\n\n      // Find the due date text\n      final dueDateFinder = find.textContaining('Due:');\n      final textWidget = tester.widget<Text>(dueDateFinder);\n\n      // Assert\n      expect(textWidget.style?.color, Colors.red);\n      expect(textWidget.style?.fontWeight, FontWeight.bold);\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 7: CI/CD Setup",
              "content": "\n### GitHub Actions Workflow\n\nCreate `.github/workflows/ci.yml`:\n\n\n",
              "code": "name: TaskMaster Pro CI\n\non:\n  pull_request:\n    branches: [ main ]\n  push:\n    branches: [ main ]\n\njobs:\n  test:\n    name: Test and Coverage\n    runs-on: ubuntu-latest\n    timeout-minutes: 20\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.24.0'\n          channel: 'stable'\n          cache: true\n\n      - name: Install dependencies\n        run: flutter pub get\n\n      - name: Generate Hive adapters\n        run: flutter pub run build_runner build --delete-conflicting-outputs\n\n      - name: Verify code formatting\n        run: dart format --set-exit-if-changed .\n\n      - name: Analyze code\n        run: flutter analyze --fatal-infos\n\n      - name: Run unit and widget tests with coverage\n        run: flutter test --coverage --no-test-assets\n\n      - name: Install lcov\n        run: sudo apt-get install -y lcov\n\n      - name: Clean coverage data\n        run: |\n          lcov --remove coverage/lcov.info \\\n            '*.g.dart' \\\n            '*.freezed.dart' \\\n            -o coverage/lcov_cleaned.info\n\n      - name: Check coverage threshold (80%)\n        run: |\n          COVERAGE=$(lcov --summary coverage/lcov_cleaned.info 2>&1 | \\\n            grep 'lines......:' | \\\n            grep -oP '\\d+\\.\\d+(?=%)')\n\n          echo \"Coverage: ${COVERAGE}%\"\n\n          if (( $(echo \"$COVERAGE < 80\" | bc -l) )); then\n            echo \"‚ùå Coverage ${COVERAGE}% is below 80% threshold\"\n            exit 1\n          else\n            echo \"‚úÖ Coverage meets 80% threshold\"\n          fi\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          files: ./coverage/lcov_cleaned.info\n          fail_ci_if_error: false\n\n      - name: Generate HTML coverage report\n        run: |\n          genhtml coverage/lcov_cleaned.info -o coverage/html\n\n      - name: Upload coverage HTML as artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: coverage-report\n          path: coverage/html/\n\n      - name: Build APK\n        run: flutter build apk --debug",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Section 8: Running and Verifying Tests",
              "content": "\n### Script: scripts/run_all_tests.sh\n\n\nMake it executable:\n\nRun it:\n\n",
              "code": "./scripts/run_all_tests.sh",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Section 9: Evaluation Criteria",
              "content": "\n### Grading Rubric (100 points)\n\n**Implementation (40 points)**\n- ‚úÖ All functional requirements met (20 pts)\n- ‚úÖ Code follows Flutter best practices (10 pts)\n- ‚úÖ No linting warnings (5 pts)\n- ‚úÖ Code properly formatted (5 pts)\n\n**Unit Tests (25 points)**\n- ‚úÖ Task model fully tested (10 pts)\n- ‚úÖ Repository fully tested (10 pts)\n- ‚úÖ Tests follow AAA pattern (5 pts)\n\n**Widget Tests (15 points)**\n- ‚úÖ TaskItem widget fully tested (8 pts)\n- ‚úÖ Filter buttons tested (7 pts)\n\n**Integration Tests (10 points)**\n- ‚úÖ Complete task lifecycle tested (5 pts)\n- ‚úÖ Filter flow tested (5 pts)\n\n**Coverage (10 points)**\n- ‚úÖ 80%+ coverage (10 pts)\n- ‚úÖ 70-79% coverage (7 pts)\n- ‚úÖ 60-69% coverage (5 pts)\n- ‚ùå <60% coverage (0 pts)\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nIn this mini-project, you built:\n\n‚úÖ **Production-ready task management app** with full CRUD operations\n‚úÖ **Comprehensive test suite** covering unit, widget, and integration tests\n‚úÖ **80%+ test coverage** with automated coverage reporting\n‚úÖ **CI/CD pipeline** with GitHub Actions\n‚úÖ **Quality gates** enforcing code standards\n‚úÖ **Automated testing** on every push and PR\n‚úÖ **Best practices** demonstrated throughout\n\n**Key Takeaways:**\n\n1. **Test Pyramid**: 70% unit tests, 20% widget tests, 10% integration tests\n2. **TDD mindset**: Write tests as you develop, not after\n3. **Quality gates**: Prevent bad code from merging\n4. **Coverage ‚â† Quality**: 80% coverage of meaningful code beats 100% of trivial code\n5. **CI/CD**: Automate everything to catch issues early\n\n**Portfolio Value:**\n\nThis project demonstrates professional-level testing practices employers look for:\n- Comprehensive test coverage\n- Clean, maintainable test code\n- CI/CD pipeline setup\n- Quality-first development approach\n\n**Congratulations!** You've completed Module 10 and built a fully tested, production-ready Flutter application with industry-standard testing practices. üéâ\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn **Module 11: Deployment & Publishing**, you'll learn how to prepare this app for release, build signed APKs and IPAs, and publish it to the Google Play Store and Apple App Store!\n\n"
            }
          ],
          "challenges": []
        }
      ]
    },
    {
      "id": "module-11",
      "title": "Module 11: Flutter Development",
      "description": "Learn Flutter development - Module 11",
      "difficulty": "advanced",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "11.1",
          "title": "iOS",
          "moduleId": "module-11",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Release checklist for production apps\n- App icons and splash screens\n- Version numbers and build numbers\n- App signing and certificates\n- Release vs debug builds\n- Performance optimization for production\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: Why Preparation Matters",
              "content": "\n### Real-World Analogy\nReleasing an app is like **launching a new product**:\n- ‚úÖ Quality control (testing)\n- ‚úÖ Packaging (build configuration)\n- ‚úÖ Branding (icons, splash screens)\n- ‚úÖ Documentation (store listings)\n- ‚úÖ Legal (privacy policy, terms)\n\nJust like you wouldn't ship a product in a plain brown box, you shouldn't release an app without proper preparation!\n\n### Why This Matters\nPoor preparation leads to:\n- ‚ùå App store rejections\n- ‚ùå Bad first impressions\n- ‚ùå Security vulnerabilities\n- ‚ùå Poor performance\n- ‚ùå Legal issues\n\n**73% of apps** get rejected on first submission! Proper preparation increases approval chances.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Release Checklist",
              "content": "\n### ‚úÖ Pre-Release Checklist\n\n**1. Testing**\n- [ ] All features work correctly\n- [ ] Tested on multiple devices (small & large screens)\n- [ ] Tested on different OS versions\n- [ ] No crashes or ANRs (Android) / crashes (iOS)\n- [ ] Performance is acceptable (no lag)\n- [ ] Battery usage is reasonable\n\n**2. Content**\n- [ ] App name is finalized\n- [ ] App description is written\n- [ ] Screenshots prepared (all required sizes)\n- [ ] App icon designed (all required sizes)\n- [ ] Splash screen configured\n- [ ] Privacy policy published\n- [ ] Terms of service (if applicable)\n\n**3. Legal & Compliance**\n- [ ] Privacy policy covers all data collection\n- [ ] Permissions are justified\n- [ ] COPPA compliance (if targeting children)\n- [ ] GDPR compliance (if serving EU users)\n- [ ] Age rating determined\n\n**4. Technical**\n- [ ] Version number set correctly\n- [ ] Build number incremented\n- [ ] API keys secured (not in code)\n- [ ] Error logging configured\n- [ ] Analytics integrated\n- [ ] App signing configured\n\n**5. Store Listings**\n- [ ] Google Play Console account active\n- [ ] Apple Developer account active (if iOS)\n- [ ] App created in console\n- [ ] Store listing filled out\n- [ ] Pricing and countries selected\n\n"
            },
            {
              "type": "THEORY",
              "title": "App Icons",
              "content": "\n### Icon Requirements\n\n**Android (Play Store):**\n- **512√ó512px**: High-res icon (PNG, 32-bit, max 1024 KB)\n- **Adaptive icon**: Foreground + background layers\n- **Various sizes**: 48dp, 72dp, 96dp, 144dp, 192dp\n\n**iOS (App Store):**\n- **1024√ó1024px**: App Store icon (PNG, no transparency, no rounded corners)\n- **Various sizes**: @1x, @2x, @3x for different devices\n\n### Creating App Icons\n\n**Using flutter_launcher_icons Package:**\n\n1. **Install:**\n\n2. **Configure** (pubspec.yaml):\n\n3. **Generate icons:**\n\n**Best Practices:**\n- ‚úÖ Use simple, recognizable designs\n- ‚úÖ Avoid text (hard to read at small sizes)\n- ‚úÖ Test on various backgrounds (dark/light)\n- ‚úÖ Follow platform guidelines (Material Design / Human Interface Guidelines)\n- ‚ùå Don't use screenshots as icons\n- ‚ùå Don't violate trademarks\n\n",
              "code": "flutter pub get\nflutter pub run flutter_launcher_icons",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Splash Screens",
              "content": "\n### Native Splash Screens\n\n**Using flutter_native_splash Package:**\n\n1. **Install:**\n\n2. **Configure** (pubspec.yaml):\n\n3. **Generate:**\n\n**Platform-Specific Notes:**\n- **Android 12+**: Uses new splash screen API (animated)\n- **iOS**: Static launch screen (no animations allowed)\n\n",
              "code": "flutter pub get\nflutter pub run flutter_native_splash:create",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Version Numbers",
              "content": "\n### Semantic Versioning\n\nFormat: `MAJOR.MINOR.PATCH+BUILD`\n\n**Example:** `1.2.3+45`\n- **1**: Major version (breaking changes)\n- **2**: Minor version (new features, backward compatible)\n- **3**: Patch version (bug fixes)\n- **45**: Build number (internal tracking)\n\n### Setting Versions\n\n**pubspec.yaml:**\n\n**When to Increment:**\n- **Major (1.x.x)**: Complete rewrite, breaking changes\n- **Minor (x.1.x)**: New features added\n- **Patch (x.x.1)**: Bug fixes only\n- **Build (x.x.x+1)**: Every build/release\n\n**Examples:**\n- `1.0.0+1`: Initial release\n- `1.0.1+2`: Bug fix\n- `1.1.0+3`: Added new feature\n- `2.0.0+4`: Major overhaul\n\n",
              "code": "version: 1.2.3+45",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Release vs Debug Builds",
              "content": "\n### Debug Build (Development)\n\n**Characteristics:**\n- Includes debugging info\n- Larger file size (~20-40 MB larger)\n- Hot reload enabled\n- Performance overhead\n- Console logging enabled\n\n### Release Build (Production)\n\n**Characteristics:**\n- Optimized code (tree-shaking, minification)\n- Smaller file size\n- No debugging symbols\n- Maximum performance\n- Logging disabled (unless explicitly configured)\n\n**Performance Comparison:**\n| Metric | Debug | Release |\n|--------|-------|---------|\n| File Size | ~40 MB | ~15 MB |\n| Startup Time | 3-5 sec | 1-2 sec |\n| Frame Rate | 50-55 FPS | 60 FPS |\n| Memory Usage | Higher | Lower |\n\n",
              "code": "flutter build apk --release\nflutter build appbundle --release  # Preferred\n\nflutter build ioS --release",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "App Signing",
              "content": "\n### Android App Signing\n\n**1. Create a Keystore:**\n\n**Important:** Save the keystore file and password securely! If lost, you cannot update your app!\n\n**2. Reference Keystore** (android/key.properties):\n\n**3. Configure Gradle** (android/app/build.gradle):\n\n**4. Add to .gitignore:**\n\n### iOS Code Signing\n\niOS signing is handled through Xcode:\n\n1. **Automatic Signing** (recommended for beginners):\n   - Open `ios/Runner.xcworkspace` in Xcode\n   - Select \"Runner\" project\n   - General ‚Üí Signing ‚Üí Enable \"Automatically manage signing\"\n   - Select your Apple Developer Team\n\n2. **Manual Signing** (advanced):\n   - Create App ID in Apple Developer Portal\n   - Create Distribution Certificate\n   - Create Provisioning Profile\n   - Configure in Xcode\n\n",
              "code": "key.properties\n*.jks\n*.keystore",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Build Configuration",
              "content": "\n### Android Configuration\n\n**android/app/build.gradle:**\n\n### iOS Configuration\n\n**ios/Runner/Info.plist:**\n\n",
              "code": "<dict>\n    <!-- App Name -->\n    <key>CFBundleName</key>\n    <string>$(PRODUCT_NAME)</string>\n\n    <!-- Display Name (shown on home screen) -->\n    <key>CFBundleDisplayName</key>\n    <string>My App</string>\n\n    <!-- Bundle Identifier -->\n    <key>CFBundleIdentifier</key>\n    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>\n\n    <!-- Version -->\n    <key>CFBundleShortVersionString</key>\n    <string>$(FLUTTER_BUILD_NAME)</string>\n\n    <!-- Build Number -->\n    <key>CFBundleVersion</key>\n    <string>$(FLUTTER_BUILD_NUMBER)</string>\n\n    <!-- Minimum iOS Version -->\n    <key>MinimumOSVersion</key>\n    <string>12.0</string>\n\n    <!-- Supported Devices -->\n    <key>UIRequiredDeviceCapabilities</key>\n    <array>\n        <string>arm64</string>\n    </array>\n\n    <!-- Orientations -->\n    <key>UISupportedInterfaceOrientations</key>\n    <array>\n        <string>UIInterfaceOrientationPortrait</string>\n        <string>UIInterfaceOrientationLandscapeLeft</string>\n        <string>UIInterfaceOrientationLandscapeRight</string>\n    </array>\n</dict>",
              "language": "xml"
            },
            {
              "type": "THEORY",
              "title": "Environment Variables & Secrets",
              "content": "\n### Managing API Keys Securely\n\n**‚ùå DON'T:**\n\n**‚úÖ DO:**\n\n**.env file:**\n\n**.gitignore:**\n\n### Build Flavors (Dev vs Prod)\n\nCreate separate configurations for development and production.\n\n",
              "code": ".env\n.env.local\n.env.production",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Performance Optimization",
              "content": "\n### Before Release\n\n1. **Profile the App:**\n\n2. **Analyze Build Size:**\n\n3. **Optimize Images:**\n   - Use WebP format\n   - Compress PNG/JPEG (TinyPNG, ImageOptim)\n   - Use appropriate resolutions (@1x, @2x, @3x)\n\n4. **Enable Obfuscation:**\n\n5. **Remove Unused Resources:**\n   - Delete unused assets\n   - Remove unused packages\n\n",
              "code": "flutter build apk --obfuscate --split-debug-info=build/app/outputs/symbols",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the difference between version number and build number?\nA) They're the same thing\nB) Version is user-facing; build is internal tracking\nC) Version is for Android; build is for iOS\nD) Build number must always be 1\n\n**Question 2:** Why should you never commit your keystore file to Git?\nA) It's too large\nB) If stolen, attackers can impersonate your app\nC) It will break the build\nD) Google prohibits it\n\n**Question 3:** What does \"minifyEnabled true\" do?\nA) Makes the app smaller by removing unused code\nB) Minimizes battery usage\nC) Reduces network calls\nD) Compresses images\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Prepare Your App for Release",
              "content": "\nTake any Flutter app you've built and:\n1. Set version to 1.0.0+1\n2. Create app icon (1024x1024)\n3. Generate launcher icons with flutter_launcher_icons\n4. Add splash screen\n5. Create keystore for Android\n6. Build release APK\n7. Check file size (should be < 20 MB)\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've learned how to prepare a Flutter app for production! Here's what we covered:\n\n- **Release Checklist**: Testing, legal, technical requirements\n- **App Icons**: Generating icons for all platforms\n- **Splash Screens**: Native splash configuration\n- **Version Numbers**: Semantic versioning (MAJOR.MINOR.PATCH+BUILD)\n- **App Signing**: Keystore creation and configuration\n- **Build Configuration**: Release vs debug builds\n- **Secrets Management**: Protecting API keys\n- **Performance**: Optimization techniques\n\nNext lesson: Publishing to Google Play Store!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) Version is user-facing; build is internal tracking\n\nVersion number (1.2.3) is what users see in the app store. Build number (+45) is for internal tracking and must increment with each submission, even if the version doesn't change.\n\n**Answer 2:** B) If stolen, attackers can impersonate your app\n\nYour keystore is how you prove ownership of your app. If someone steals it and your passwords, they can sign updates pretending to be you. Always keep it secure and never commit to version control!\n\n**Answer 3:** A) Makes the app smaller by removing unused code\n\nMinification (minifyEnabled true) removes unused code and shortens identifiers, reducing the final APK/IPA size. Combined with shrinkResources, it can reduce app size by 30-50%.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "11.2",
          "title": "iOS",
          "moduleId": "module-11",
          "order": 2,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Publishing to Google Play Store\n- Publishing to Apple App Store\n- Store listing optimization (ASO)\n- Handling app reviews\n- Post-launch monitoring\n- Updating your published app\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: The App Store Ecosystem",
              "content": "\n### Real-World Analogy\nPublishing to app stores is like **opening a store in a shopping mall**:\n- **Google Play / App Store** = The mall\n- **Your app** = Your store\n- **Store listing** = Your storefront display\n- **Reviews** = Customer feedback\n- **Updates** = Refreshing your inventory\n\nThe mall (store) has rules you must follow, and they control who gets in!\n\n### Why This Matters\n**3.5 million** apps on Google Play and **1.8 million** on App Store compete for attention. A good launch strategy is crucial:\n\n- ‚úÖ Clear store listing = More downloads\n- ‚úÖ Good first impression = Better ratings\n- ‚úÖ App Store Optimization (ASO) = Higher visibility\n- ‚ùå Poor listing = Lost in the crowd\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Google Play Store",
              "content": "\n### Prerequisites\n\n1. **Google Play Console Account**\n   - Visit [play.google.com/console](https://play.google.com/console)\n   - One-time fee: $25 USD\n   - Requires Google account\n\n2. **Developer Information**\n   - Developer name\n   - Email address\n   - Privacy policy URL (required!)\n   - Physical address (will be public)\n\n3. **App Build Ready**\n   - Release APK or AAB (recommended)\n   - Signed with upload key\n   - Tested thoroughly\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Step-by-Step: Google Play Store\n\n#### Step 1: Create App in Console\n\n1. Go to Play Console ‚Üí **All apps** ‚Üí **Create app**\n2. Fill in details:\n   - **App name** (max 50 characters)\n   - **Default language**\n   - **App or game**\n   - **Free or paid**\n   - Accept declarations\n\n#### Step 2: Store Listing\n\n**Main store listing:**\n\n**App icon:**\n- 512 x 512 px\n- 32-bit PNG (with alpha)\n- Max 1 MB\n\n**Screenshots (Required):**\n- Minimum 2 screenshots\n- JPEG or 24-bit PNG (no alpha)\n- 16:9 or 9:16 aspect ratio\n- Minimum dimension: 320 px\n- Maximum dimension: 3840 px\n\n**Example screenshot requirements:**\n- Phone: 1080 x 1920 px (at least 2)\n- 7-inch tablet: 1200 x 1920 px (recommended)\n- 10-inch tablet: 1920 x 1200 px (recommended)\n\n**Feature graphic (Required):**\n- 1024 x 500 px\n- JPEG or 24-bit PNG (no alpha)\n\n#### Step 3: Content Rating\n\n1. Start questionnaire\n2. Answer questions honestly:\n   - Violence\n   - Sexual content\n   - Language\n   - Controlled substances\n   - Gambling\n\n3. Get rating (Everyone, Teen, Mature, etc.)\n\n#### Step 4: Select App Categories\n\n**Primary category:**\n- Health & Fitness\n- Productivity\n- Social\n- etc.\n\n**Tags (up to 5):**\n- workout tracker\n- fitness\n- calorie counter\n- exercise\n- health\n\n#### Step 5: Contact Details & Privacy Policy\n\n**Developer contact information:**\n- Email (public)\n- Phone (optional)\n- Website (optional)\n\n**Privacy policy:**\n- Required if app collects user data\n- Must be hosted on public URL\n- Must explain data collection clearly\n\n**Example privacy policy sections:**\n\n#### Step 6: Set Up Pricing & Distribution\n\n**Pricing:**\n- Free or Paid\n- In-app purchases (if applicable)\n- Subscriptions (if applicable)\n\n**Countries:**\n- Select countries to distribute\n- Or \"All countries\"\n\n**Content guidelines compliance:**\n- Confirm app meets Google Play policies\n\n#### Step 7: Production Release\n\n**Option A: Internal Testing (Recommended first)**\n1. Production ‚Üí Internal testing\n2. Create release\n3. Upload AAB file\n4. Add release notes\n5. Review and roll out\n6. Test with team (up to 100 testers)\n\n**Option B: Closed Testing**\n1. Production ‚Üí Closed testing\n2. More rigorous testing\n3. Up to 100,000 testers\n4. Required for individual developers (2023+ policy)\n\n**Option C: Production Release**\n1. Production ‚Üí Production\n2. Upload AAB:\n3. Release notes:\n\n4. Review and roll out\n5. Wait for review (usually 1-3 days)\n\n#### Step 8: App Review\n\n**What Google checks:**\n- Policy compliance\n- Content rating accuracy\n- Privacy policy completeness\n- Functionality (automated testing)\n- Security vulnerabilities\n\n**Review time:**\n- Usually: 1-3 days\n- Sometimes: Up to 7 days\n- Expedited: Not available\n\n**Common rejection reasons:**\n1. Broken functionality or crashes\n2. Misleading content/screenshots\n3. Incomplete privacy policy\n4. Violation of Play policies\n5. Inappropriate content rating\n\n",
              "code": "Version 1.0.0\n‚Ä¢ Initial release\n‚Ä¢ GPS workout tracking\n‚Ä¢ Calorie counting\n‚Ä¢ Progress charts\n‚Ä¢ Social sharing\n\nThank you for downloading Fitness Tracker Pro!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Apple App Store",
              "content": "\n### Prerequisites\n\n1. **Apple Developer Program**\n   - Visit [developer.apple.com](https://developer.apple.com)\n   - Cost: $99 USD/year\n   - Requires Apple ID\n\n2. **Mac with Xcode**\n   - macOS required for iOS builds\n   - Xcode 14+ (free from App Store)\n\n3. **App Store Connect Account**\n   - Automatically created with Developer Program\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Step-by-Step: Apple App Store\n\n#### Step 1: Register App Identifier\n\n1. Go to [developer.apple.com](https://developer.apple.com)\n2. Certificates, IDs & Profiles ‚Üí Identifiers\n3. Click \"+\" to create new App ID\n4. Select \"App IDs\" ‚Üí Continue\n5. Select \"App\" ‚Üí Continue\n6. Fill in:\n   - **Description**: Fitness Tracker Pro\n   - **Bundle ID**: com.yourcompany.fitnesstracke (must match your app)\n   - **Capabilities**: Select required (e.g., Push Notifications, HealthKit)\n7. Register\n\n#### Step 2: Create App in App Store Connect\n\n1. Go to [appstoreconnect.apple.com](https://appstoreconnect.apple.com)\n2. My Apps ‚Üí \"+\" ‚Üí New App\n3. Fill in:\n   - **Platform**: iOS\n   - **Name**: Fitness Tracker Pro\n   - **Primary Language**: English\n   - **Bundle ID**: Select from dropdown (created in Step 1)\n   - **SKU**: Unique identifier (e.g., fitnesstrackerproj_001)\n   - **User Access**: Full Access\n\n#### Step 3: App Information\n\n**Category:**\n- Primary: Health & Fitness\n- Secondary: Lifestyle (optional)\n\n**Age Rating:**\nAnswer questionnaire (similar to Google Play)\n\n**Content Rights:**\n- [ ] Contains third-party content\n- License agreement (optional)\n\n#### Step 4: Pricing and Availability\n\n**Price:**\n- Free or select price tier\n- $0.99, $1.99, $2.99, etc.\n\n**Availability:**\n- Specific territories or all\n- Pre-order option\n\n#### Step 5: App Store Listing\n\n**App Store Information:**\n\n**Name** (30 characters):\n\n**Subtitle** (30 characters):\n\n**Description** (4000 characters):\n\n**Keywords** (100 characters):\n\n**Support URL:**\n\n**Marketing URL (optional):**\n\n**Privacy Policy URL (required):**\n\n#### Step 6: Screenshots\n\n**iPhone Screenshots (Required):**\n- 6.7\" display (iPhone 14 Pro Max): 1290 x 2796 px\n- 6.5\" display (iPhone 14 Plus): 1284 x 2778 px\n- 5.5\" display (iPhone 8 Plus): 1242 x 2208 px\n\n**Minimum:** 3 screenshots\n**Maximum:** 10 screenshots\n\n**iPad Screenshots (If supporting iPad):**\n- 12.9\" display: 2048 x 2732 px\n- 11\" display: 1668 x 2388 px\n\n**App Previews (Optional but recommended):**\n- Video preview (15-30 seconds)\n- Show key features\n- Portrait or landscape\n\n#### Step 7: Build and Upload\n\n**Build for iOS:**\n\n**Upload via Xcode:**\n1. Open `build/ios/archive/Runner.xcarchive`\n2. Distribute App ‚Üí App Store Connect\n3. Upload\n4. Wait for processing (10-30 minutes)\n\n**Or use Application Loader:**\n- Older method, deprecated\n\n#### Step 8: Submit for Review\n\n1. Select build from dropdown\n2. Fill in **Version Information**:\n   - Version number: 1.0.0\n   - Copyright: ¬© 2025 Your Company\n   - Build number: 1\n\n3. **Export Compliance:**\n   - Does your app use encryption? (Usually \"No\")\n\n4. **Content Rights:**\n   - Do you hold rights to content?\n\n5. **Advertising Identifier:**\n   - Do you use IDFA? (Usually \"No\" unless using ads)\n\n6. **App Review Information:**\n   - First name, Last name\n   - Phone number\n   - Email\n   - Demo account (if app requires login)\n   - Notes for reviewer\n\n7. **Version Release:**\n   - Automatically release after approval\n   - Or manually release\n\n8. Submit for Review\n\n#### Step 9: App Review Process\n\n**Review time:**\n- Usually: 24-48 hours\n- Sometimes: Up to 5 days\n\n**Status progression:**\n1. Waiting for Review\n2. In Review\n3. Pending Developer Release (if manual)\n4. Ready for Sale\n\n**Common rejection reasons:**\n1. **Guideline 2.1**: App completeness (crashes, bugs)\n2. **Guideline 4.3**: Spam/duplicate apps\n3. **Guideline 5.1**: Privacy issues\n4. **Guideline 2.3.3**: Inaccurate metadata/screenshots\n5. **Guideline 5.1.1**: Data collection without permission\n\n**If rejected:**\n- Read rejection reason carefully\n- Fix the issues\n- Respond to reviewer with changes made\n- Resubmit\n\n",
              "code": "flutter build ipa --release",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "App Store Optimization (ASO)",
              "content": "\n### Keywords Strategy\n\n**Research:**\n- Use tools: App Annie, Sensor Tower, App Radar\n- Check competitor keywords\n- Find high-volume, low-competition terms\n\n**Optimization:**\n- Title: Include main keyword\n- Subtitle (iOS): Secondary keyword\n- Description: Natural use of keywords (3-5 times)\n- Google Play short description: Keyword-rich\n\n**Example for Fitness App:**\n\n### Screenshots Best Practices\n\n1. **Show, don't tell**: Real app screens, not just graphics\n2. **Key features first**: First 2-3 screenshots are most important\n3. **Add captions**: Explain what's shown\n4. **Use device frames**: Makes it look professional\n5. **Show progression**: Onboarding ‚Üí Features ‚Üí Results\n\n**Tools:**\n- Figma/Sketch for design\n- [screenshots.pro](https://screenshots.pro) for device frames\n- [AppLaunchpad](https://theapplaunchpad.com) for templates\n\n### Description Formula\n\n\n",
              "code": "Hook (1-2 sentences)\n‚Üì\nKey Features (bullet points)\n‚Üì\nBenefits (what user gains)\n‚Üì\nSocial Proof (users/ratings if available)\n‚Üì\nCall to Action",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Post-Launch Monitoring",
              "content": "\n### Metrics to Track\n\n1. **Downloads/Installs**\n   - Daily/weekly/monthly\n   - By country\n\n2. **Ratings & Reviews**\n   - Average rating\n   - Review count\n   - Sentiment analysis\n\n3. **Crashes & ANRs**\n   - Crash-free users %\n   - Most common crashes\n\n4. **User Retention**\n   - Day 1, 7, 30 retention\n   - Churn rate\n\n5. **Engagement**\n   - Daily active users (DAU)\n   - Session length\n   - Feature usage\n\n**Tools:**\n- Google Play Console (built-in)\n- App Store Connect (built-in)\n- Firebase Analytics\n- Crashlytics\n- Mixpanel/Amplitude\n\n### Responding to Reviews\n\n**Positive Reviews:**\n\n**Negative Reviews:**\n\n**Bug Reports:**\n\n",
              "code": "Thank you for reporting this! We've identified the issue and it will be fixed in the next update (1.1.0), coming next week. We appreciate your feedback!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Updating Your App",
              "content": "\n### When to Update\n\n- Bug fixes: As soon as possible\n- Minor features: Every 2-4 weeks\n- Major features: Every 2-3 months\n\n### Update Process\n\n**1. Increment Version:**\n\n**2. Build New Release:**\n\n**3. Upload to Stores:**\n- Google Play: Upload to Production\n- App Store: Upload via Xcode, submit for review\n\n**4. Write Release Notes:**\n\n**5. Roll Out Gradually:**\n- Google Play: Staged rollout (10% ‚Üí 50% ‚Üí 100%)\n- App Store: Phased release (automatic)\n\n",
              "code": "What's New in 1.0.1:\n‚Ä¢ Fixed crash on workout save\n‚Ä¢ Improved GPS accuracy\n‚Ä¢ Added dark mode support\n‚Ä¢ Performance improvements\n\nThanks for using Fitness Tracker Pro!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the main difference between Google Play and App Store review times?\nA) They're the same\nB) Play Store is usually faster (1-3 days vs 1-2 days)\nC) App Store is usually faster (1-2 days vs 1-3 days)\nD) Both take weeks\n\n**Question 2:** Why is a privacy policy required?\nA) It's not required\nB) Legal requirement if you collect any user data\nC) Only for paid apps\nD) Only for apps with ads\n\n**Question 3:** What is ASO?\nA) App Store Optimization (improving visibility)\nB) App Security Operations\nC) Automated Store Operations\nD) Apple Store Only\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Create a Store Listing",
              "content": "\nFor your Fitness Tracker app (or any app):\n1. Write an app name (30 chars)\n2. Write a short description (80 chars)\n3. Write a full description (200+ words)\n4. List 5-10 keywords\n5. Create a mockup of 3 screenshots\n6. Write release notes for version 1.0.0\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've learned how to publish to both major app stores! Here's what we covered:\n\n- **Google Play Store**: Step-by-step submission process\n- **Apple App Store**: iOS publishing workflow\n- **Store Listings**: Optimizing descriptions and screenshots\n- **ASO**: App Store Optimization strategies\n- **Reviews**: Handling user feedback\n- **Updates**: Maintaining your published app\n\nCongratulations - you can now ship apps to millions of users!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) Play Store is usually faster (1-3 days vs 1-2 days)\n\nActually, in 2025, App Store reviews are typically faster (1-2 days) compared to Google Play (1-3 days, sometimes up to 7 days). However, both are much faster than they used to be (Play Store used to take days/weeks).\n\n**Answer 2:** B) Legal requirement if you collect any user data\n\nBoth Google Play and App Store require a privacy policy if your app collects any user data (including analytics, email, location, etc.). It must be publicly accessible via URL and clearly explain data collection.\n\n**Answer 3:** A) App Store Optimization (improving visibility)\n\nASO (App Store Optimization) is the process of improving an app's visibility in app store search results. Similar to SEO for websites, it involves keyword optimization, compelling visuals, and positive ratings to rank higher.\n\n"
            }
          ],
          "challenges": []
        }
      ]
    },
    {
      "id": "module-12",
      "title": "Module 12: Flutter Development",
      "description": "Learn Flutter development - Module 12",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "12.1",
          "title": "Module 12: Final Capstone Project",
          "moduleId": "module-12",
          "order": 1,
          "estimatedMinutes": 55,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Ultimate Challenge: Build a Complete Social Marketplace App",
              "content": "\nCongratulations on reaching the final module! You've learned everything from Flutter basics to deployment. Now it's time to prove your skills by building a **complete, production-ready social marketplace app** from scratch.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Overview: \"LocalBuy\" Social Marketplace",
              "content": "\n### What You'll Build\n\n**LocalBuy** is a full-stack social marketplace where users can:\n- Buy and sell items locally\n- Chat with sellers in real-time\n- Follow favorite sellers\n- Share listings on social media\n- Get location-based recommendations\n- Track order history\n- Receive push notifications\n\n###Skills Demonstrated\n\nThis project combines **EVERY module** from the course:\n\n| Module | Features Used |\n|--------|---------------|\n| **0-2: Basics** | Dart fundamentals, Flutter widgets, layouts |\n| **3: Lists & Forms** | Product lists, post item forms, search |\n| **4: State Management** | Provider for cart, user auth state |\n| **5: Theming** | Light/dark mode, custom theme |\n| **6: Navigation** | GoRouter for deep linking to products |\n| **7: Networking** | Product API, image uploads |\n| **8: Firebase** | Auth, Firestore, Storage, push notifications |\n| **9: Advanced** | Maps for location, camera for photos, local DB for favorites |\n| **10: Testing** | Unit, widget, integration tests |\n| **11: Deployment** | Production build, store publishing |\n\n"
            },
            {
              "type": "THEORY",
              "title": "Phase 1: Planning & Architecture",
              "content": "\n### User Stories\n\n**As a Seller, I can:**\n1. Create an account and profile\n2. List items for sale with photos\n3. Edit/delete my listings\n4. Chat with potential buyers\n5. Mark items as sold\n6. View my sales history\n\n**As a Buyer, I can:**\n7. Browse items by category\n8. Search for specific items\n9. Filter by location and price\n10. Save favorite items\n11. Chat with sellers\n12. View seller profiles\n13. Track my purchase history\n\n### Database Schema\n\n**Firestore Collections:**\n\n\n### App Architecture\n\n\n",
              "code": "lib/\n‚îú‚îÄ‚îÄ main.dart\n‚îú‚îÄ‚îÄ app.dart\n‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îú‚îÄ‚îÄ user.dart\n‚îÇ   ‚îú‚îÄ‚îÄ listing.dart\n‚îÇ   ‚îú‚îÄ‚îÄ chat.dart\n‚îÇ   ‚îî‚îÄ‚îÄ message.dart\n‚îú‚îÄ‚îÄ providers/\n‚îÇ   ‚îú‚îÄ‚îÄ auth_provider.dart\n‚îÇ   ‚îú‚îÄ‚îÄ listings_provider.dart\n‚îÇ   ‚îú‚îÄ‚îÄ cart_provider.dart\n‚îÇ   ‚îî‚îÄ‚îÄ chat_provider.dart\n‚îú‚îÄ‚îÄ services/\n‚îÇ   ‚îú‚îÄ‚îÄ auth_service.dart\n‚îÇ   ‚îú‚îÄ‚îÄ firestore_service.dart\n‚îÇ   ‚îú‚îÄ‚îÄ storage_service.dart\n‚îÇ   ‚îú‚îÄ‚îÄ location_service.dart\n‚îÇ   ‚îî‚îÄ‚îÄ notification_service.dart\n‚îú‚îÄ‚îÄ screens/\n‚îÇ   ‚îú‚îÄ‚îÄ auth/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ register_screen.dart\n‚îÇ   ‚îú‚îÄ‚îÄ home/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ home_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ search_screen.dart\n‚îÇ   ‚îú‚îÄ‚îÄ listings/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ listing_detail_screen.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create_listing_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ my_listings_screen.dart\n‚îÇ   ‚îú‚îÄ‚îÄ profile/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ profile_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit_profile_screen.dart\n‚îÇ   ‚îú‚îÄ‚îÄ chat/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chats_list_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chat_screen.dart\n‚îÇ   ‚îî‚îÄ‚îÄ favorites/\n‚îÇ       ‚îî‚îÄ‚îÄ favorites_screen.dart\n‚îú‚îÄ‚îÄ widgets/\n‚îÇ   ‚îú‚îÄ‚îÄ listing_card.dart\n‚îÇ   ‚îú‚îÄ‚îÄ user_avatar.dart\n‚îÇ   ‚îú‚îÄ‚îÄ price_tag.dart\n‚îÇ   ‚îî‚îÄ‚îÄ category_chip.dart\n‚îî‚îÄ‚îÄ utils/\n    ‚îú‚îÄ‚îÄ constants.dart\n    ‚îú‚îÄ‚îÄ validators.dart\n    ‚îî‚îÄ‚îÄ helpers.dart\n\ntest/\n‚îú‚îÄ‚îÄ unit/\n‚îÇ   ‚îú‚îÄ‚îÄ models_test.dart\n‚îÇ   ‚îú‚îÄ‚îÄ services_test.dart\n‚îÇ   ‚îî‚îÄ‚îÄ providers_test.dart\n‚îú‚îÄ‚îÄ widget/\n‚îÇ   ‚îî‚îÄ‚îÄ widgets_test.dart\n‚îî‚îÄ‚îÄ integration/\n    ‚îî‚îÄ‚îÄ app_test.dart",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Phase 2: Implementation Milestones",
              "content": "\n### Milestone 1: Authentication & User Profile (Week 1)\n\n**Tasks:**\n1. Set up Firebase project\n2. Implement email/password authentication\n3. Add Google Sign-In\n4. Create user profile screen\n5. Add profile photo upload\n6. Implement edit profile functionality\n\n**Deliverables:**\n- [ ] Users can register/login\n- [ ] Users can upload profile photo\n- [ ] Users can edit their name and bio\n- [ ] Auth state persists across app restarts\n\n**Code Example:**\n\n### Milestone 2: Listings & Categories (Week 2)\n\n**Tasks:**\n1. Create listing model\n2. Implement create listing form\n3. Add image picker (camera/gallery)\n4. Upload images to Firebase Storage\n5. Display listings feed\n6. Add categories and filtering\n7. Implement search functionality\n\n**Deliverables:**\n- [ ] Users can create listings with photos\n- [ ] Listings display in a grid/list\n- [ ] Categories work (Electronics, Furniture, etc.)\n- [ ] Search returns relevant results\n- [ ] Listings show seller info\n\n**Code Example:**\n\n### Milestone 3: Real-Time Chat (Week 3)\n\n**Tasks:**\n1. Create chat data model\n2. Implement chat list screen\n3. Implement 1-on-1 chat screen\n4. Add real-time message sync\n5. Show typing indicators\n6. Add push notifications for new messages\n\n**Deliverables:**\n- [ ] Users can start chats from listings\n- [ ] Messages sync in real-time\n- [ ] Typing indicators work\n- [ ] Push notifications for new messages\n- [ ] Unread message badges\n\n### Milestone 4: Maps & Location (Week 4)\n\n**Tasks:**\n1. Add Google Maps integration\n2. Show listings on map\n3. Filter by distance\n4. Add location picker for new listings\n5. Show seller location (approximate)\n\n**Deliverables:**\n- [ ] Map shows nearby listings\n- [ ] Listings can be filtered by distance\n- [ ] Users can pick location when creating listing\n\n### Milestone 5: Testing & Polish (Week 5)\n\n**Tasks:**\n1. Write unit tests for models\n2. Write unit tests for services\n3. Write widget tests for screens\n4. Write integration tests for critical flows\n5. Achieve 70%+ code coverage\n6. Fix all bugs\n7. Optimize performance\n\n**Deliverables:**\n- [ ] 70%+ code coverage\n- [ ] All critical flows tested\n- [ ] No crashes or major bugs\n- [ ] App runs smoothly (60 FPS)\n\n### Milestone 6: Deployment (Week 6)\n\n**Tasks:**\n1. Create app icons\n2. Add splash screen\n3. Write privacy policy\n4. Prepare store listings\n5. Create screenshots\n6. Build release APK/IPA\n7. Submit to stores\n\n**Deliverables:**\n- [ ] App published to Google Play\n- [ ] App published to App Store (if applicable)\n- [ ] Store listings complete\n- [ ] First version live!\n\n",
              "code": "// lib/screens/listings/create_listing_screen.dart\nclass CreateListingScreen extends StatefulWidget {\n  @override\n  State<CreateListingScreen> createState() => _CreateListingScreenState();\n}\n\nclass _CreateListingScreenState extends State<CreateListingScreen> {\n  final _formKey = GlobalKey<FormState>();\n  final _titleController = TextEditingController();\n  final _descriptionController = TextEditingController();\n  final _priceController = TextEditingController();\n\n  String _selectedCategory = 'Electronics';\n  List<File> _images = [];\n  bool _isLoading = false;\n\n  Future<void> _pickImages() async {\n    final ImagePicker picker = ImagePicker();\n    final List<XFile> images = await picker.pickMultipleImages();\n\n    if (images.isNotEmpty) {\n      setState(() {\n        _images = images.map((img) => File(img.path)).toList();\n      });\n    }\n  }\n\n  Future<void> _createListing() async {\n    if (!_formKey.currentState!.validate()) return;\n    if (_images.isEmpty) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Please add at least one photo')),\n      );\n      return;\n    }\n\n    setState(() => _isLoading = true);\n\n    try {\n      // Upload images\n      final storageService = Provider.of<StorageService>(context, listen: false);\n      final imageUrls = await storageService.uploadListingImages(_images);\n\n      // Get current location\n      final position = await Geolocator.getCurrentPosition();\n\n      // Create listing\n      final listing = Listing(\n        title: _titleController.text,\n        description: _descriptionController.text,\n        price: double.parse(_priceController.text),\n        category: _selectedCategory,\n        images: imageUrls,\n        sellerId: FirebaseAuth.instance.currentUser!.uid,\n        location: GeoPoint(position.latitude, position.longitude),\n        status: 'available',\n        createdAt: DateTime.now(),\n        views: 0,\n      );\n\n      await Provider.of<ListingsProvider>(context, listen: false).createListing(listing);\n\n      Navigator.pop(context);\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Listing created successfully!')),\n      );\n    } catch (e) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Error: ${e.toString()}')),\n      );\n    } finally {\n      setState(() => _isLoading = false);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Create Listing')),\n      body: _isLoading\n          ? Center(child: CircularProgressIndicator())\n          : SingleChildScrollView(\n              padding: EdgeInsets.all(16),\n              child: Form(\n                key: _formKey,\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.stretch,\n                  children: [\n                    // Images\n                    if (_images.isNotEmpty)\n                      Container(\n                        height: 200,\n                        child: ListView.builder(\n                          scrollDirection: Axis.horizontal,\n                          itemCount: _images.length,\n                          itemBuilder: (context, index) {\n                            return Stack(\n                              children: [\n                                Image.file(_images[index], width: 200, fit: BoxFit.cover),\n                                Positioned(\n                                  top: 8,\n                                  right: 8,\n                                  child: IconButton(\n                                    icon: Icon(Icons.close, color: Colors.white),\n                                    onPressed: () {\n                                      setState(() => _images.removeAt(index));\n                                    },\n                                  ),\n                                ),\n                              ],\n                            );\n                          },\n                        ),\n                      ),\n\n                    ElevatedButton.icon(\n                      onPressed: _pickImages,\n                      icon: Icon(Icons.add_photo_alternate),\n                      label: Text('Add Photos'),\n                    ),\n\n                    SizedBox(height: 16),\n\n                    TextFormField(\n                      controller: _titleController,\n                      decoration: InputDecoration(labelText: 'Title*'),\n                      validator: (v) => v!.isEmpty ? 'Required' : null,\n                    ),\n\n                    TextFormField(\n                      controller: _descriptionController,\n                      decoration: InputDecoration(labelText: 'Description*'),\n                      maxLines: 3,\n                      validator: (v) => v!.isEmpty ? 'Required' : null,\n                    ),\n\n                    TextFormField(\n                      controller: _priceController,\n                      decoration: InputDecoration(labelText: 'Price (USD)*', prefixText: '\\$'),\n                      keyboardType: TextInputType.number,\n                      validator: (v) {\n                        if (v!.isEmpty) return 'Required';\n                        if (double.tryParse(v) == null) return 'Invalid price';\n                        return null;\n                      },\n                    ),\n\n                    DropdownButtonFormField<String>(\n                      value: _selectedCategory,\n                      items: ['Electronics', 'Furniture', 'Clothing', 'Books', 'Sports', 'Other']\n                          .map((cat) => DropdownMenuItem(value: cat, child: Text(cat)))\n                          .toList(),\n                      onChanged: (v) => setState(() => _selectedCategory = v!),\n                      decoration: InputDecoration(labelText: 'Category'),\n                    ),\n\n                    SizedBox(height: 24),\n\n                    ElevatedButton(\n                      onPressed: _createListing,\n                      child: Text('Create Listing'),\n                      style: ElevatedButton.styleFrom(\n                        padding: EdgeInsets.symmetric(vertical: 16),\n                      ),\n                    ),\n                  ],\n                ),\n              ),\n            ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Phase 3: Advanced Features (Optional)",
              "content": "\nOnce your MVP is complete, add these advanced features:\n\n### 1. Ratings & Reviews\n- Users can rate sellers (1-5 stars)\n- Write reviews\n- Seller profile shows average rating\n\n### 2. Favorites & Saved Searches\n- Save favorite listings\n- Save search filters\n- Get notified of new listings matching saved searches\n\n### 3. Offers & Negotiation\n- Buyers can make offers\n- Sellers can accept/reject/counter\n- Track offer history\n\n### 4. Social Features\n- Follow favorite sellers\n- Share listings to social media\n- Activity feed of followed sellers\n\n### 5. Analytics Dashboard\n- Sellers see view counts\n- Track which listings are popular\n- Revenue analytics\n\n### 6. In-App Payments\n- Integrate Stripe or PayPal\n- Secure checkout flow\n- Track transaction history\n\n"
            },
            {
              "type": "THEORY",
              "title": "Phase 4: Evaluation Criteria",
              "content": "\n### Functionality (40 points)\n- [ ] All core features work (10 pts)\n- [ ] No crashes or major bugs (10 pts)\n- [ ] Real-time features work (10 pts)\n- [ ] Location features work (10 pts)\n\n### Code Quality (30 points)\n- [ ] Clean, readable code (10 pts)\n- [ ] Proper state management (10 pts)\n- [ ] Good error handling (5 pts)\n- [ ] Secure (no hardcoded secrets) (5 pts)\n\n### Testing (15 points)\n- [ ] Unit tests present (5 pts)\n- [ ] Widget tests present (5 pts)\n- [ ] 70%+ code coverage (5 pts)\n\n### UI/UX (10 points)\n- [ ] Professional design (5 pts)\n- [ ] Smooth animations (3 pts)\n- [ ] Good user experience (2 pts)\n\n### Deployment (5 points)\n- [ ] Published to at least one store (5 pts)\n\n**Total: 100 points**\n\n**Grading:**\n- 90-100: Excellent (A)\n- 80-89: Very Good (B)\n- 70-79: Good (C)\n- 60-69: Pass (D)\n- 0-59: Needs Improvement (F)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Resources & Support",
              "content": "\n### Documentation\n- [Flutter Docs](https://flutter.dev/docs)\n- [Firebase Docs](https://firebase.google.com/docs)\n- [GoRouter Docs](https://pub.dev/packages/go_router)\n- [Provider Docs](https://pub.dev/packages/provider)\n\n### Community\n- [Flutter Discord](https://discord.gg/flutter)\n- [r/FlutterDev](https://reddit.com/r/FlutterDev)\n- [Stack Overflow](https://stackoverflow.com/questions/tagged/flutter)\n\n### Tools\n- [FlutterFlow](https://flutterflow.io) - Visual builder (optional)\n- [Firebase Console](https://console.firebase.google.com)\n- [Google Play Console](https://play.google.com/console)\n- [App Store Connect](https://appstoreconnect.apple.com)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Submission Guidelines",
              "content": "\n1. **Source Code**\n   - Push to GitHub (public or private)\n   - Include README.md with setup instructions\n   - Include .env.example for API keys\n\n2. **Demo Video**\n   - 3-5 minutes\n   - Show all major features\n   - Explain architecture decisions\n\n3. **Store Link**\n   - Google Play Store URL\n   - Or App Store URL\n   - Or TestFlight link\n\n4. **Documentation**\n   - README with setup steps\n   - Architecture diagram\n   - Known issues/limitations\n\n"
            },
            {
              "type": "THEORY",
              "title": "Congratulations! üéâ",
              "content": "\nYou've completed the **Flutter Training Course**! You've learned:\n\n- ‚úÖ Dart fundamentals\n- ‚úÖ Flutter widgets and layouts\n- ‚úÖ State management (Provider, BLoC)\n- ‚úÖ Navigation (GoRouter)\n- ‚úÖ Networking and APIs\n- ‚úÖ Firebase integration\n- ‚úÖ Advanced features (maps, camera, sensors)\n- ‚úÖ Testing (unit, widget, integration)\n- ‚úÖ Deployment (Play Store, App Store)\n\n**You are now a full-stack Flutter developer!**\n\n### What's Next?\n\n1. **Build More Apps**: Practice makes perfect\n2. **Contribute to Open Source**: Give back to the community\n3. **Learn Advanced Topics**: Animations, custom painters, platform channels\n4. **Specialize**: Web, desktop, or embedded\n5. **Teach Others**: Share your knowledge\n\n### Career Opportunities\n\nWith these skills, you can:\n- Freelance on Upwork, Fiverr\n- Apply for Flutter developer jobs\n- Build startup MVPs\n- Create passive income apps\n- Consult for companies\n\n**Salaries:**\n- Junior Flutter Developer: $50-70k/year\n- Mid-Level: $70-100k/year\n- Senior: $100-150k+/year\n- Freelance: $50-150/hour\n\n"
            },
            {
              "type": "THEORY",
              "title": "Final Challenge: Ship It! üöÄ",
              "content": "\nDon't just complete the project - **publish it**!\n\nSet a deadline (6-8 weeks) and commit to:\n1. Building LocalBuy (or your own idea)\n2. Testing thoroughly\n3. Publishing to at least one store\n4. Getting 100 downloads\n5. Maintaining 4+ star rating\n\n**Tag us when you launch:**\n- Twitter: #FlutterDev #LocalBuy\n- LinkedIn: Share your achievement\n- Reddit: r/FlutterDev\n\nWe can't wait to see what you build! üíô\n\n"
            },
            {
              "type": "THEORY",
              "title": "Course Complete! üéì",
              "content": "\n**Total Lessons: 78+**\n**Total Hours: 100+**\n**Projects Built: 15+**\n\nYou've gone from **zero to hero** in Flutter development. Be proud of how far you've come!\n\nNow go build something amazing. The world needs your apps! üåü\n\n"
            }
          ],
          "challenges": []
        }
      ]
    }
  ]
}