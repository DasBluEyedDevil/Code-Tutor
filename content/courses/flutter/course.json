{
  "id": "flutter",
  "language": "dart",
  "title": "Flutter & Dart Full-Stack Development Course",
  "description": "Master Flutter frontend development AND Dart backend programming. Build complete, production-ready applications with 100+ interactive lessons covering UI, state management, Dart Frog, Serverpod, testing, deployment, and a social app capstone.",
  "difficulty": "beginner",
  "estimatedHours": 150,
  "prerequisites": [
    "Basic programming knowledge recommended"
  ],
  "modules": [
    {
      "id": "module-00",
      "title": "Module 0: Flutter Development",
      "description": "Learn Flutter development - Module 0",
      "difficulty": "beginner",
      "estimatedHours": 5,
      "lessons": [
        {
          "id": "0.1",
          "title": "Module 0, Lesson 1: Installing Flutter & Dart SDK",
          "moduleId": "module-00",
          "order": 1,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What Are We Doing Here?",
              "content": "\nImagine you want to build a treehouse. Before you start nailing boards together, you need tools: a hammer, nails, wood, a saw. You can't build anything without your tools ready.\n\nBuilding phone apps is the same. Before we write a single line of code, we need to install our \"toolbox\" on your computer. This toolbox contains everything we need to:\n- Write instructions for your app (the code)\n- Turn those instructions into something a phone can understand\n- Test your app on a fake phone on your computer (before putting it on a real phone)\n\n**The Big Picture**: Right now, your computer doesn't know how to build phone apps. We're going to teach it. Once we're done with this lesson, your computer will be ready to build apps for Android phones, iPhones, and even websites‚Äîall from the same code.\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Technical Names",
              "content": "\nThe toolbox we're installing has two main parts:\n\n1. **Flutter**: This is the main toolkit. It's like the instruction manual and the assembly line for building apps. Flutter was created by Google and lets you build apps for phones, tablets, computers, and websites‚Äîall at once.\n\n2. **Dart SDK**: SDK stands for \"Software Development Kit\" (don't worry about memorizing that). Dart is the *language* we'll use to write our instructions. Think of it like this: if Flutter is the kitchen, Dart is the language of the recipes.\n\nWhen we \"install Flutter,\" we're actually getting both Flutter and Dart together. They're best friends and always come as a package.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Installation Instructions",
              "content": "\n### **FOR WINDOWS USERS:**\n\n**Step 1: Download Flutter**\n1. Open your web browser and go to: `https://docs.flutter.dev/get-started/install/windows`\n2. Click the blue \"Download Flutter SDK\" button\n3. A file called something like `flutter_windows_3.x.x-stable.zip` will download\n\n**Step 2: Extract the Files**\n1. Once downloaded, find the ZIP file (probably in your Downloads folder)\n2. Right-click on it ‚Üí Choose \"Extract All\"\n3. Extract it to a simple location like `C:\\src\\flutter`\n   - ‚ö†Ô∏è **Important**: Do NOT put it in a folder like `C:\\Program Files`\n\n**Step 3: Add Flutter to Your PATH**\n\n*What's PATH? It's like your computer's phonebook. When you type \"flutter\" in a terminal, your computer looks through its PATH to find where the flutter program lives. We're adding Flutter's location to that phonebook.*\n\nOpen PowerShell (search for \"PowerShell\" in the Start menu) and run:\n\n\n**Step 4: Verify Installation**\n\nClose and reopen PowerShell, then run:\n\n\n",
              "code": "flutter doctor",
              "language": "powershell"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### **FOR MAC USERS:**\n\n**Step 1: Download Flutter**\n1. Open Safari and go to: `https://docs.flutter.dev/get-started/install/macos`\n2. Choose your Mac type:\n   - **Intel Mac**: Download \"Intel Chip\" version\n   - **Apple Silicon (M1/M2/M3)**: Download \"Apple Silicon\" version\n\n**Step 2: Extract and Move the Files**\n\nOpen Terminal (press `Cmd + Space`, type \"Terminal\", press Enter):\n\n\n**Step 3: Add Flutter to Your PATH**\n\n\n**Step 4: Verify Installation**\n\n\n",
              "code": "flutter doctor",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### **FOR LINUX USERS:**\n\nOpen Terminal:\n\n\n**Verify Installation**:\n\n\n",
              "code": "flutter doctor",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Next Steps",
              "content": "\nOnce you've successfully installed Flutter, you're ready to move on to **Lesson 2: Setting Up Your Editor**. In the next lesson, we'll install VS Code and configure it to work perfectly with Flutter.\n\nGreat job completing your first lesson! üéâ\n\n"
            },
            {
              "type": "WARNING",
              "title": "Common Installation Mistakes to Avoid",
              "content": "\n**Before You Install:**\n\n1. **Don't install Flutter in paths with spaces**\n   - ‚ùå BAD: `C:\\Program Files\\flutter`\n   - ‚úÖ GOOD: `C:\\src\\flutter` or `C:\\flutter`\n\n2. **Don't use PowerShell `setx` to set PATH**\n   - PowerShell's setx command can truncate your PATH variable (max 1024 characters)\n   - Use the Windows Environment Variables GUI instead (search 'environment variables' in Start menu)\n\n3. **On Mac, restart Terminal after PATH changes**\n   - Changes to `.zshrc` or `.zprofile` only take effect in new terminal windows\n\n4. **Don't panic about red X marks in `flutter doctor`**\n   - ‚ùå Chrome, Android Studio, Xcode are OPTIONAL for now\n   - ‚úÖ You only need Flutter and Dart checkmarks to continue\n\n5. **Apple Silicon Macs (M1/M2/M3/M4) may need Rosetta**\n   - Run: `sudo softwareupdate --install-rosetta`\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "About Version Numbers",
              "content": "\nThroughout this course, we use phrases like \"latest stable\" instead of specific version numbers. This keeps the course current as Flutter evolves.\n\n**To find current recommended versions:**\nSee `CURRENT_VERSIONS.md` in the course materials.\n\n**Quick Check - Your Installed Versions:**\n```bash\nflutter --version\n```\n\n**General Rule:** Use the latest stable Flutter SDK. The course is tested with Flutter 3.38+ and Dart 3.10+, but newer versions should work fine.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Flutter's Rendering Engine: Impeller",
              "content": "\n**What is Impeller?**\n\nImpeller is Flutter's rendering engine that replaced Skia. Think of it as the \"graphics card driver\" that draws everything you see on screen.\n\n**Why Impeller Matters:**\n- **No more shader jank**: Impeller pre-compiles shaders at build time, eliminating first-frame stutters\n- **Predictable performance**: Consistent 60/120fps frame rates from the first frame\n- **Native GPU acceleration**: Uses Metal (iOS) and Vulkan (Android)\n\n**Current Status (Flutter 3.38+):**\n- **iOS**: Default since Flutter 3.29 - Skia fallback has been removed\n- **Android**: Default since Flutter 3.38 for API 29+ devices with Vulkan support\n- **Android Fallback**: Devices without Vulkan (or with known driver issues) automatically use OpenGL\n\nYou don't need to do anything to enable Impeller‚Äîit's automatic! This is why Flutter apps feel smoother than ever.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "0.1-challenge-0",
              "title": "Practice Challenge",
              "description": "1. Open your terminal (PowerShell on Windows, Terminal on Mac/Linux) 2. Run this command:    ```bash    flutter --version    ``` 3. You should see something like:    ```    Flutter 3.38.x ‚Ä¢ channel stable    Tools ‚Ä¢ Dart 3.10.x    ``` 4. Now run:    ```bash    flutter doctor    ``` 5. You'll probably see:    - ‚úÖ Green checkmarks (Flutter, Dart)    - ‚ùå Red X marks (Android Studio, Chrome, Xcode) ---",
              "instructions": "1. Open your terminal (PowerShell on Windows, Terminal on Mac/Linux) 2. Run this command:    ```bash    flutter --version    ``` 3. You should see something like:    ```    Flutter 3.38.x ‚Ä¢ channel stable    Tools ‚Ä¢ Dart 3.10.x    ``` 4. Now run:    ```bash    flutter doctor    ``` 5. You'll probably see:    - ‚úÖ Green checkmarks (Flutter, Dart)    - ‚ùå Red X marks (Android Studio, Chrome, Xcode) ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Flutter Installation Verification\n// This challenge is about running terminal commands.\n// The expected terminal commands are:\n//\n// Step 1: Check Flutter version\n// flutter --version\n//\n// Step 2: Run Flutter doctor\n// flutter doctor\n//\n// Expected output should show:\n// - Flutter SDK version (e.g., 3.24.0)\n// - Dart version (e.g., 3.5.0)\n// - Green checkmarks for installed components\n//\n// In Dart code, you could verify installation like this:\n\nvoid main() {\n  // This is a setup exercise - the actual work\n  // is done in the terminal, not in code.\n  //\n  // Commands to run:\n  // 1. flutter --version\n  // 2. flutter doctor\n  //\n  // After running flutter doctor, you should see:\n  // [‚úì] Flutter (installed)\n  // [‚úì] Dart (installed)\n  //\n  // Some items may show [!] or [‚úó] for optional\n  // components like Android Studio or Xcode.\n  \n  print('Flutter installation verified!');\n  print('Run these commands in your terminal:');\n  print('  flutter --version');\n  print('  flutter doctor');\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Program prints Flutter verification message",
                  "expectedOutput": "Flutter installation verified!",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Program includes terminal command instructions",
                  "expectedOutput": "flutter --version",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Program mentions flutter doctor command",
                  "expectedOutput": "flutter doctor",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Open your terminal (PowerShell on Windows, Terminal on Mac/Linux) and type the commands exactly as shown."
                },
                {
                  "level": 2,
                  "text": "If 'flutter' is not recognized, your PATH is not set correctly. Review the installation steps."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Flutter command not found",
                  "consequence": "Terminal shows 'flutter is not recognized' or 'command not found'",
                  "correction": "Add Flutter to your PATH and restart terminal"
                },
                {
                  "mistake": "Wrong Flutter installation path",
                  "consequence": "Issues with permissions or spaces in path",
                  "correction": "Install to a simple path like C:\\src\\flutter"
                },
                {
                  "mistake": "Not restarting terminal after PATH changes",
                  "consequence": "Old PATH is still cached",
                  "correction": "Close and reopen your terminal window"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "0.2",
          "title": "Module 0, Lesson 2: Setting Up Your Editor",
          "moduleId": "module-00",
          "order": 2,
          "estimatedMinutes": 45,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What's an Editor?",
              "content": "\nThink of writing code like writing a book. You *could* use Notepad or TextEdit, but professional writers use Microsoft Word or Google Docs because they have spell-check, grammar suggestions, and formatting tools.\n\nFor programming, we use a special kind of text editor called an **IDE** (Integrated Development Environment) or **code editor**. These tools:\n- Highlight your code with colors (making it easier to read)\n- Catch mistakes as you type (like spell-check)\n- Auto-complete your code (like text predictions on your phone)\n- Let you run and test your app with one click\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Technical Names",
              "content": "\nFor Flutter development, we recommend **Visual Studio Code** (VS Code for short). Don't confuse this with \"Visual Studio\" - they're different programs!\n\n**Why VS Code?**\n- It's **free** and works on Windows, Mac, and Linux\n- It's **lightweight** (doesn't slow down your computer)\n- It has **amazing Flutter support** through extensions\n- It's what most Flutter developers use\n\n"
            },
            {
              "type": "THEORY",
              "title": "Installation Steps",
              "content": "\n### Step 1: Download VS Code\n\n1. Go to: `https://code.visualstudio.com`\n2. Click the big download button (it auto-detects your operating system)\n3. Install it like any other program:\n   - **Windows**: Run the `.exe` file\n   - **Mac**: Drag the `.app` to your Applications folder\n   - **Linux**: Follow the instructions for your distribution\n\n### Step 2: Install the Flutter Extension\n\nOnce VS Code is installed:\n\n1. **Open VS Code**\n2. Click the **Extensions** icon on the left sidebar (it looks like four squares)\n3. In the search bar, type: `Flutter`\n4. Find the extension called **\"Flutter\"** by Dart Code\n5. Click **Install**\n\nThis will automatically install two extensions:\n- **Flutter**: Adds Flutter-specific features\n- **Dart**: Adds support for the Dart language\n\n"
            },
            {
              "type": "THEORY",
              "title": "Step 3: Verify Everything Works",
              "content": "\nLet's make sure VS Code can talk to Flutter!\n\n1. **Open the Command Palette**:\n   - Windows/Linux: Press `Ctrl + Shift + P`\n   - Mac: Press `Cmd + Shift + P`\n\n2. Type: `Flutter: Run Flutter Doctor`\n\n3. Press Enter\n\n4. You should see a terminal open showing the `flutter doctor` output\n\nIf you see green checkmarks for Flutter and Dart, you're all set! ‚úÖ\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Understanding the VS Code Interface",
              "content": "\nHere's a quick tour of what you'll see:\n\n\n**Key Parts:**\n- **Side Bar** (left): File explorer, search, source control, extensions\n- **Main Editor** (center): Where you write code\n- **Terminal** (bottom): Where you run commands and see output\n\n",
              "code": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Menu Bar                                ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ      ‚îÇ                                  ‚îÇ\n‚îÇ Side ‚îÇ    Main Editor                   ‚îÇ\n‚îÇ Bar  ‚îÇ    (Your code goes here)         ‚îÇ\n‚îÇ      ‚îÇ                                  ‚îÇ\n‚îÇ      ‚îÇ                                  ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ Terminal / Debug Console                ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Useful VS Code Shortcuts",
              "content": "\nLearn these - they'll save you tons of time:\n\n| Shortcut | What It Does |\n|----------|--------------|\n| `Ctrl/Cmd + P` | Quick file search |\n| `Ctrl/Cmd + Shift + P` | Command palette |\n| `Ctrl/Cmd + B` | Toggle sidebar |\n| `Ctrl/Cmd + J` | Toggle terminal |\n| `Ctrl/Cmd + S` | Save file |\n| `Ctrl/Cmd + /` | Comment/uncomment code |\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn the next lesson, we'll actually create and run your very first Flutter app! We'll see \"Hello World\" running on a simulated phone right on your computer.\n\nYou're making great progress! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "0.2-challenge-0",
              "title": "Practice Challenge",
              "description": "1. **Change the theme** (optional, but fun!):    - Press `Ctrl/Cmd + K`, then `Ctrl/Cmd + T`    - Browse through themes and pick one you like    - Popular choices: \"Dark+ (default)\", \"Monokai\", \"Dracula\" 2. **Adjust font size**:    - Press `Ctrl/Cmd + ,` to open Settings    - Search for \"font size\"    - Try different sizes until it's comfortable (14-16 is common) 3. **Test the Flutter extension**:    - Press `Ctrl/Cmd + Shift + P`    - Type \"Flutter: New Project\"    - See if the command appears (don't run it yet!) ---",
              "instructions": "1. **Change the theme** (optional, but fun!):    - Press `Ctrl/Cmd + K`, then `Ctrl/Cmd + T`    - Browse through themes and pick one you like    - Popular choices: \"Dark+ (default)\", \"Monokai\", \"Dracula\" 2. **Adjust font size**:    - Press `Ctrl/Cmd + ,` to open Settings    - Search for \"font size\"    - Try different sizes until it's comfortable (14-16 is common) 3. **Test the Flutter extension**:    - Press `Ctrl/Cmd + Shift + P`    - Type \"Flutter: New Project\"    - See if the command appears (don't run it yet!) ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: VS Code Editor Setup\n// This challenge is about configuring VS Code.\n//\n// The hands-on steps are:\n// 1. Theme: Ctrl/Cmd + K, then Ctrl/Cmd + T to change theme\n// 2. Font Size: Ctrl/Cmd + , to open Settings, search 'font size'\n// 3. Flutter Extension: Ctrl/Cmd + Shift + P, type 'Flutter: New Project'\n//\n// Here's a simple Dart program to verify your setup works:\n\nvoid main() {\n  // This is a comment - your editor should color it differently!\n  \n  // Variables - should be highlighted as keywords\n  final String editorName = 'VS Code';\n  const int recommendedFontSize = 14;\n  \n  // Print statements to test your setup\n  print('Welcome to Flutter development!');\n  print('Editor: $editorName');\n  print('Recommended font size: $recommendedFontSize-16px');\n  \n  // If you can see syntax highlighting and run this,\n  // your editor is set up correctly!\n  print('Setup complete! Your editor is ready.');\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Program prints welcome message",
                  "expectedOutput": "Welcome to Flutter development!",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Program displays editor name",
                  "expectedOutput": "Editor: VS Code",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Program confirms setup complete",
                  "expectedOutput": "Setup complete! Your editor is ready.",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "0.3",
          "title": "Module 0, Lesson 3: Running Your First \"Hello World\"",
          "moduleId": "module-00",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Moment of Truth",
              "content": "\nRemember all that setup we did? The Flutter installation, the editor configuration? This is where it all comes together. You're about to create and run your very first Flutter app!\n\nThink of this like turning on a new toy for the first time. We don't need to understand how all the wires and circuits work inside - we just want to see the lights turn on and know everything is working.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What is \"Hello World\"?",
              "content": "\nIn programming, \"Hello World\" is a tradition. It's the simplest possible program that just displays the text \"Hello World\" on the screen. It's used to verify that:\n- Your tools are installed correctly\n- You can create a new project\n- You can run code\n- You can see the result\n\nOnce you see \"Hello World\" running, you'll know your development environment is ready for real work!\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Creating Your First Project",
              "content": "\n### Step 1: Open VS Code\n\nLaunch Visual Studio Code (the editor we installed in the previous lesson).\n\n### Step 2: Create a New Flutter Project\n\n1. Press `Ctrl/Cmd + Shift + P` to open the command palette\n2. Type: `Flutter: New Project`\n3. Select **Application**\n4. Choose a location on your computer (like a folder called \"FlutterProjects\")\n5. Name your project: `hello_world` (must be lowercase with underscores, no spaces!)\n6. Press Enter\n\nVS Code will now create your project. This takes 30-60 seconds. You'll see a progress indicator.\n\n### Step 3: Explore What Was Created\n\nLook at the **Explorer** panel (left sidebar). You'll see a folder structure:\n\n\n**The only file you need to know about right now is `lib/main.dart`**. This is where your app's code lives.\n\n",
              "code": "hello_world/\n‚îú‚îÄ‚îÄ lib/\n‚îÇ   ‚îî‚îÄ‚îÄ main.dart        ‚Üê This is YOUR code file\n‚îú‚îÄ‚îÄ android/             ‚Üê Android-specific files\n‚îú‚îÄ‚îÄ ios/                 ‚Üê iOS-specific files\n‚îú‚îÄ‚îÄ web/                 ‚Üê Web-specific files\n‚îú‚îÄ‚îÄ test/                ‚Üê Testing files\n‚îî‚îÄ‚îÄ pubspec.yaml         ‚Üê Project configuration",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "üìÅ What's the test/ Folder For?",
              "content": "\nYou might be wondering about that `test/` folder. This is where you'll put **Widget Tests** - automated checks that verify your app works correctly!\n\n### Widget Testing: A Quick Preview\n\nThink of it like having a robot that clicks buttons and checks results for you:\n\n```dart\n// test/counter_test.dart\ntestWidgets('Counter increments when + is tapped', (tester) async {\n  // 1. BUILD: Create the widget\n  await tester.pumpWidget(MyApp());\n  \n  // 2. FIND: Locate the counter text\n  expect(find.text('0'), findsOneWidget);  // Starts at 0\n  \n  // 3. ACT: Tap the + button\n  await tester.tap(find.byIcon(Icons.add));\n  await tester.pump();  // Rebuild after state change\n  \n  // 4. VERIFY: Check the counter increased\n  expect(find.text('1'), findsOneWidget);  // Now shows 1!\n});\n```\n\n**Key concepts** (we'll learn these in Module 10):\n- `testWidgets()` - Runs a widget test\n- `tester.pumpWidget()` - Builds your widget\n- `find.text('0')` - Locates text on screen\n- `tester.tap()` - Simulates a tap\n- `expect()` - Checks if something is true\n\n**Run tests with:** `flutter test`\n\n**Don't worry!** You don't need to write tests now. Just know that the `test/` folder exists for automated quality checks. We cover testing in depth in Module 10!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Running Your App",
              "content": "\n### Step 1: Choose a Device\n\nAt the bottom-right of VS Code, you should see a device selector. Click it and choose one of:\n- **Chrome** (easiest for beginners - runs in a web browser)\n- **Windows** / **macOS** / **Linux** (if available)\n- **Android Emulator** (if you have one set up)\n- **iOS Simulator** (Mac only, if set up)\n\nFor this lesson, **choose Chrome** - it's the simplest option.\n\n### Step 2: Run the App\n\nThere are three ways to run your app:\n\n**Option 1**: Press `F5`\n\n**Option 2**: Press `Ctrl/Cmd + Shift + P`, type \"Flutter: Run\", press Enter\n\n**Option 3**: Click the \"Run\" button in the top-right corner\n\nChoose any method. You'll see:\n1. A terminal opens at the bottom\n2. Text scrolling by (this is Flutter building your app)\n3. After 10-30 seconds, a window opens showing your app!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You're Seeing",
              "content": "\nCongratulations! You're running a Flutter app! üéâ\n\nYou should see:\n- A blue app bar at the top with \"hello_world\" as the title\n- A counter showing \"0\"\n- A button with a \"+\" icon at the bottom-right\n\n**Try clicking the + button!** The counter increases. You just interacted with a real, working app!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Understanding the Magic (Just a Peek)",
              "content": "\nOpen the file `lib/main.dart`. You'll see about 110 lines of code. Don't worry - we're not going to understand all of it yet.\n\nBut notice around line 94, you'll see:\n\n\nThis is the line that displays the counter! When you press the + button, the number `_counter` changes, and the screen updates.\n\n**Don't try to understand this code yet.** We'll learn every single piece in the upcoming lessons. For now, just know: *this is what makes the number appear*.\n\n",
              "code": "Text(\n  '$_counter',\n  style: Theme.of(context).textTheme.headlineMedium,\n),",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Making Your First Change",
              "content": "Let's personalize this app! Find line 31 in main.dart and change the title. After saving, the app instantly updates. This is Hot Reload - Flutter's superpower that lets you see changes instantly without restarting!",
              "code": "// BEFORE (line 31 in main.dart):\ntitle: 'Flutter Demo',\n\n// AFTER:\ntitle: 'My First App',\n\n// Steps:\n// 1. Find line 31 in main.dart\n// 2. Change 'Flutter Demo' to 'My First App'\n// 3. Save file (Ctrl/Cmd + S)\n// 4. Watch your app update instantly!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Understanding Hot Reload vs Hot Restart",
              "content": "\nThese are two important concepts:\n\n- **Hot Reload** (`Ctrl/Cmd + S` or the lightning bolt icon):\n  - Injects your code changes into the running app\n  - Keeps the app's current state (counter stays at 10)\n  - Takes 1-2 seconds\n  - Use this 95% of the time\n\n- **Hot Restart** (`Ctrl/Cmd + Shift + F5` or circular arrow icon):\n  - Restarts the app from scratch\n  - Resets all state (counter goes back to 0)\n  - Takes a few seconds\n  - Use this when something seems broken\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap what you just did:\n- ‚úÖ Created a brand new Flutter project\n- ‚úÖ Ran the app on Chrome/your device\n- ‚úÖ Interacted with a real, working app\n- ‚úÖ Made code changes and saw them update instantly\n- ‚úÖ Experienced Hot Reload (Flutter's superpower!)\n\n**This is a huge milestone!** You now have a working development environment and you've run your first app.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn the next module, we're going to slow down and learn the Dart programming language from scratch. We'll start with the absolute basics:\n- How to store information (variables)\n- How to make decisions (if/else)\n- How to repeat actions (loops)\n\nAll taught interactively, with lots of practice!\n\nSee you in Module 1! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "0.3-challenge-0",
              "title": "Practice Challenge",
              "description": "1. **Change the title** (you just did this!) 2. **Change the button text**:    - Find line 96: `Text('You have pushed the button this many times:'),`    - Change it to something fun like: `Text('Button presses:'),`    - Save and watch it update! 3. **Click the button 10 times**    - Get that counter to at least 10! 4. **Try Hot Restart**:    - Notice the counter stays at 10    - Press `Ctrl/Cmd + Shift + F5` (or click the circular arrow icon)    - This is \"Hot Restart\" - the counter resets to 0! ---",
              "instructions": "1. **Change the title** (you just did this!) 2. **Change the button text**:    - Find line 96: `Text('You have pushed the button this many times:'),`    - Change it to something fun like: `Text('Button presses:'),`    - Save and watch it update! 3. **Click the button 10 times**    - Get that counter to at least 10! 4. **Try Hot Restart**:    - Notice the counter stays at 10    - Press `Ctrl/Cmd + Shift + F5` (or click the circular arrow icon)    - This is \"Hot Restart\" - the counter resets to 0! ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Your First Flutter App with Hot Reload\n// This shows a modified counter app with custom text\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      // Step 1: Changed the title\n      title: 'My First Flutter App',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n      ),\n      home: const MyHomePage(title: 'My Awesome App'),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  const MyHomePage({super.key, required this.title});\n  final String title;\n\n  @override\n  State<MyHomePage> createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n        title: Text(widget.title),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // Step 2: Changed the button text\n            const Text('Button presses:'),\n            Text(\n              '$_counter',\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _incrementCounter,\n        tooltip: 'Increment',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n// Hot Reload: Save file (Ctrl/Cmd + S) to see changes instantly\n// Hot Restart: Press Ctrl/Cmd + Shift + F5 to reset state",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Flutter app builds and runs successfully",
                  "expectedOutput": "App displays counter widget with increment button",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Counter increments on button press",
                  "expectedOutput": "Counter value increases from 0 to 1 when FloatingActionButton is pressed",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Hot reload updates UI instantly",
                  "expectedOutput": "Text changes are reflected without losing counter state",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "0.4",
          "title": "Module 0, Lesson 4: Understanding the Emulator vs Physical Device",
          "moduleId": "module-00",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Where Will Your App Run?",
              "content": "\nYou've installed Flutter and created your first app. But where does it actually run? You have several options, and each has its purpose.\n\nThink of it like testing a new board game:\n- **Playing solo at home** = Running on your computer (easiest, fastest)\n- **Playing on a practice board** = Using an emulator (simulates a real phone)\n- **Playing the actual game** = Using a real phone (most accurate)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Your Options for Running Flutter Apps",
              "content": "\nFlutter can run your app in multiple places:\n\n### 1. **Web Browser (Chrome/Edge/Safari)**\n- **Best for**: Quick testing, beginners\n- **Speed**: Fastest to start\n- **Limitations**: Can't test phone-specific features (camera, GPS, etc.)\n\n### 2. **Desktop (Windows/Mac/Linux)**\n- **Best for**: Apps that work on computers too\n- **Speed**: Very fast\n- **Limitations**: Different screen sizes and interactions than phones\n\n### 3. **Emulator/Simulator**\n- **Best for**: Testing on virtual phones without owning one\n- **Speed**: Slower to start (2-5 minutes first time)\n- **Limitations**: Uses more computer resources (RAM, CPU)\n\n### 4. **Physical Device**\n- **Best for**: Final testing, real-world performance\n- **Speed**: Fast once connected\n- **Limitations**: Requires a real phone and USB cable\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up the Android Emulator",
              "content": "\nThis is like having a virtual phone inside your computer.\n\n### Step 1: Install Android Studio\n\nEven though we're using VS Code, we need Android Studio for the emulator.\n\n1. Download from: `https://developer.android.com/studio`\n2. Install it (this will take 5-10 minutes)\n3. Open Android Studio\n4. Click \"More Actions\" ‚Üí \"SDK Manager\"\n5. Make sure these are checked:\n   - Android SDK Platform-Tools\n   - Android SDK Build-Tools\n   - Android SDK Command-line Tools\n\n### Step 2: Create a Virtual Device\n\n1. In Android Studio, click \"More Actions\" ‚Üí \"Virtual Device Manager\"\n2. Click \"Create Device\"\n3. Choose a phone model (Pixel 6 is a good default)\n4. Click \"Next\"\n5. Download a system image (recommended: latest stable release)\n6. Click \"Next\" ‚Üí \"Finish\"\n\n### Step 3: Start the Emulator\n\n1. In the Virtual Device Manager, click the ‚ñ∂ play button next to your device\n2. Wait 1-2 minutes for it to boot up\n3. You'll see a virtual phone appear on your screen!\n\n### Step 4: Verify in VS Code\n\n1. Open VS Code\n2. Look at the bottom-right corner\n3. Click where it shows the device\n4. You should see your new emulator listed!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "üíæ LIGHTWEIGHT ALTERNATIVE: Skip Android Studio (Save 5GB+)",
              "content": "\n**Want to save disk space?** You can install ONLY the Command Line Tools instead of the full Android Studio IDE (which is 5-10GB). This is for advanced users comfortable with the terminal.\n\n### Option B: Command Line Tools Only\n\n**Step 1: Download Command Line Tools**\n\nGo to: `https://developer.android.com/studio#command-tools`\n\nDownload \"Command line tools only\" for your OS (~150MB instead of 1GB+).\n\n**Step 2: Set Up Directory Structure**\n\n```bash\n# Create Android SDK directory\nmkdir -p ~/Android/Sdk/cmdline-tools\n\n# Extract downloaded zip to:\n~/Android/Sdk/cmdline-tools/latest/\n```\n\n**Step 3: Set Environment Variables**\n\n```bash\n# Add to ~/.bashrc, ~/.zshrc, or PowerShell profile\nexport ANDROID_SDK_ROOT=$HOME/Android/Sdk\nexport PATH=$PATH:$ANDROID_SDK_ROOT/cmdline-tools/latest/bin\nexport PATH=$PATH:$ANDROID_SDK_ROOT/platform-tools\nexport PATH=$PATH:$ANDROID_SDK_ROOT/emulator\n```\n\n**Step 4: Install Required Components**\n\n```bash\n# Accept licenses\nsdkmanager --licenses\n\n# Install essential components\nsdkmanager \"platform-tools\"\nsdkmanager \"emulator\"\nsdkmanager \"platforms;android-34\"\nsdkmanager \"system-images;android-34;google_apis;x86_64\"\nsdkmanager \"build-tools;34.0.0\"\n```\n\n**Step 5: Create and Run Emulator**\n\n```bash\n# Create virtual device\navdmanager create avd -n pixel6 -k \"system-images;android-34;google_apis;x86_64\"\n\n# Start emulator\nemulator -avd pixel6\n```\n\n**Step 6: Verify Flutter Sees It**\n\n```bash\nflutter doctor\nflutter devices\n```\n\n### Which Should You Choose?\n\n| Option | Disk Space | Ease of Use | Recommended For |\n|--------|------------|-------------|------------------|\n| Android Studio (Full) | ~10GB | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Easy | Beginners |\n| Command Line Tools | ~2GB | ‚≠ê‚≠ê Advanced | Experienced devs |\n\n**Our Recommendation**: If you're learning Flutter, install the full Android Studio - it's easier and has helpful visual tools. The command line approach is great if you're experienced or have limited disk space.\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up a Physical Android Device",
              "content": "\n### Step 1: Enable Developer Mode\n\nOn your Android phone:\n\n1. Go to **Settings** ‚Üí **About Phone**\n2. Find \"Build Number\"\n3. Tap it **7 times** (yes, really!)\n4. You'll see \"You are now a developer!\"\n\n### Step 2: Enable USB Debugging\n\n1. Go to **Settings** ‚Üí **Developer Options**\n2. Turn on **USB Debugging**\n3. Connect your phone to your computer with a USB cable\n\n### Step 3: Trust Your Computer\n\nWhen you connect:\n- Your phone will show \"Allow USB debugging?\"\n- Check \"Always allow from this computer\"\n- Tap \"OK\"\n\n### Step 4: Verify Connection\n\nIn your terminal/PowerShell:\n\n\nYou should see your phone listed!\n\n",
              "code": "flutter devices",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Setting Up iOS Simulator (Mac Only)",
              "content": "\nIf you're on a Mac, you can test iOS apps too!\n\n### Step 1: Install Xcode\n\n1. Open the **App Store**\n2. Search for \"Xcode\"\n3. Click \"Get\" (this is a large download - 10GB+)\n4. Wait for installation (15-30 minutes)\n\n### Step 2: Install Command Line Tools\n\nOpen Terminal:\n\n\n### Step 3: Open the Simulator\n\n\nAn iPhone simulator will appear!\n\n### Step 4: Verify in VS Code\n\nYou should now see iOS simulators in the device selector.\n\n",
              "code": "open -a Simulator",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Which Should You Use?",
              "content": "\nHere's a practical guide:\n\n| Stage | Recommended Device |\n|-------|-------------------|\n| **Learning basics** | Chrome (web) - fastest |\n| **Building UI** | Android Emulator or iOS Simulator |\n| **Testing features** | Physical device |\n| **Final testing** | Multiple physical devices |\n\n**Pro Tip**: Start with Chrome for quick iterations. Once your app looks good, test on an emulator. Before releasing, always test on a real phone!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Running Your App on Different Devices",
              "content": "\n### Option 1: Using the VS Code GUI\n\n1. Click the device selector (bottom-right)\n2. Choose your target device\n3. Press F5 or click \"Run\"\n\n### Option 2: Using the Terminal\n\n\n",
              "code": "# List available devices\nflutter devices\n\n# Run on a specific device\nflutter run -d <device-id>\n\n# Run on Chrome\nflutter run -d chrome\n\n# Run on all connected devices\nflutter run -d all",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Common Issues and Fixes",
              "content": "\n### \"No devices found\"\n\n**Solution**: Make sure at least one is running:\n- Start Chrome\n- Start an emulator\n- Connect a physical device\n\n### Emulator is very slow\n\n**Solutions**:\n- Enable hardware acceleration in BIOS (Intel VT-x or AMD-V)\n- Increase RAM allocated to emulator (in Android Studio)\n- Use a physical device instead\n\n### \"Waiting for another flutter command to release the startup lock\"\n\n**Solution**:\n\n### iOS Simulator not showing\n\n**Mac Only Solution**:\n\n",
              "code": "sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Hot Reload Across Devices",
              "content": "\nHere's something cool: **Hot Reload works on all devices!**\n\nTry this:\n1. Run your app on any device\n2. Change some text in your code\n3. Save the file (Ctrl/Cmd + S)\n4. Watch it update instantly!\n\nThis works whether you're on Chrome, emulator, or physical device.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Understanding Device IDs",
              "content": "\nWhen you run `flutter devices`, you see output like:\n\n\nEach line shows:\n- **Device name**: What it's called\n- **Device ID**: How Flutter identifies it (`chrome`, `emulator-5554`, etc.)\n- **Platform**: web, android, ios\n- **Version**: OS version\n\n",
              "code": "Chrome (web) ‚Ä¢ chrome ‚Ä¢ web-javascript ‚Ä¢ Google Chrome 119.0\nsdk gphone64 arm64 (mobile) ‚Ä¢ emulator-5554 ‚Ä¢ android-arm64 ‚Ä¢ Android 13\niPhone 14 Pro (mobile) ‚Ä¢ 12345-ABCD ‚Ä¢ ios ‚Ä¢ iOS 16.0",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ Flutter apps can run on web, desktop, emulators, and physical devices\n- ‚úÖ Each has trade-offs (speed vs accuracy)\n- ‚úÖ Chrome is fastest for quick testing\n- ‚úÖ Emulators simulate real phones\n- ‚úÖ Physical devices give the most accurate results\n- ‚úÖ Hot reload works everywhere!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nNow that you know where your apps can run, what happens when something goes wrong?\n\nIn the next lesson, we'll learn **Troubleshooting Common Setup Issues** - how to fix the most common problems developers face when getting started.\n\nSee you there! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "0.4-challenge-0",
              "title": "Practice Challenge",
              "description": "1. **Run on Chrome**:    - Select Chrome from device list    - Run your hello_world app    - Take a screenshot 2. **Run on Emulator or Physical Device**:    - Set up an Android emulator OR connect your phone    - Select it from device list    - Run the same app    - Notice any differences? 3. **Compare**:    - Does the app look the same?    - Does it run at the same speed?    - Which feels better? ---",
              "instructions": "1. **Run on Chrome**:    - Select Chrome from device list    - Run your hello_world app    - Take a screenshot 2. **Run on Emulator or Physical Device**:    - Set up an Android emulator OR connect your phone    - Select it from device list    - Run the same app    - Notice any differences? 3. **Compare**:    - Does the app look the same?    - Does it run at the same speed?    - Which feels better? ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Running on Different Devices\n// This challenge is about testing your app on multiple platforms.\n//\n// Terminal commands to run your app:\n//\n// 1. List available devices:\n//    flutter devices\n//\n// 2. Run on Chrome (web):\n//    flutter run -d chrome\n//\n// 3. Run on Android emulator:\n//    flutter run -d emulator-5554\n//\n// 4. Run on connected physical device:\n//    flutter run -d <device-id>\n//\n// Here's a sample app that works on all platforms:\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MultiPlatformApp());\n}\n\nclass MultiPlatformApp extends StatelessWidget {\n  const MultiPlatformApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Multi-Platform Demo',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),\n        useMaterial3: true,\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Hello Flutter!'),\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            const Icon(Icons.devices, size: 64),\n            const SizedBox(height: 16),\n            Text(\n              'Running on Flutter!',\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n            const SizedBox(height: 8),\n            const Text('This app works on Web, Android, iOS, and Desktop'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Key observations:\n// - Chrome: Fastest to start, good for quick testing\n// - Emulator: More accurate representation of mobile\n// - Physical device: Best for real performance testing",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "App runs successfully on multiple platforms",
                  "expectedOutput": "App displays 'Running on Flutter!' message with devices icon",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "flutter devices command lists available targets",
                  "expectedOutput": "At least one device (Chrome, emulator, or physical) is available",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "App adapts to different screen sizes",
                  "expectedOutput": "UI renders correctly on web, mobile emulator, and physical device",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "0.5",
          "title": "Module 0, Lesson 5: Troubleshooting Common Setup Issues",
          "moduleId": "module-00",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "When Things Go Wrong",
              "content": "\nEven experienced developers encounter setup issues. The good news? Most problems have simple solutions, and you're not alone!\n\nThink of troubleshooting like being a detective:\n- **The crime**: Your app won't run\n- **The clues**: Error messages\n- **The solution**: Following the evidence\n\nThis lesson teaches you how to solve the most common problems you'll face.\n\n"
            },
            {
              "type": "THEORY",
              "title": "The #1 Troubleshooting Tool: flutter doctor",
              "content": "\nThis command checks your entire setup and tells you what's wrong.\n\n\n**What it checks**:\n- ‚úÖ Is Flutter installed?\n- ‚úÖ Is Dart available?\n- ‚úÖ Are Android tools installed?\n- ‚úÖ Is Xcode available? (Mac)\n- ‚úÖ Are there any missing dependencies?\n\n**How to read the output**:\n\n\n- **[‚úì]**: Working perfectly\n- **[!]**: Working but with warnings\n- **[‚úó]**: Not working, needs fixing\n\n",
              "code": "[‚úì] Flutter (Channel stable, 3.24.0)\n[‚úó] Android toolchain - develop for Android devices\n    ‚úó Android SDK not found\n[!] Xcode - develop for iOS and macOS (Xcode 15.0)\n    ‚úó CocoaPods not installed\n[‚úì] Chrome - develop for the web\n[‚úì] VS Code (version 1.85.0)",
              "language": "dart"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 1: \"flutter: command not found\"",
              "content": "\n### What it means:\nYour computer doesn't know where Flutter is installed.\n\n### Solution (Windows):\n\n\n### Solution (Mac/Linux):\n\n\n",
              "code": "# Find where you installed Flutter\nls ~/flutter/bin/flutter\n\n# Add to PATH (Mac with zsh)\necho 'export PATH=\"$PATH:$HOME/flutter/bin\"' >> ~/.zshrc\nsource ~/.zshrc\n\n# Or for bash\necho 'export PATH=\"$PATH:$HOME/flutter/bin\"' >> ~/.bashrc\nsource ~/.bashrc\n\n# Test\nflutter --version",
              "language": "bash"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 2: Android License Not Accepted",
              "content": "\n### Error message:\n\n### Solution:\n\n\nIf this doesn't work:\n\n1. Open Android Studio\n2. Go to **Settings** ‚Üí **Appearance & Behavior** ‚Üí **System Settings** ‚Üí **Android SDK**\n3. Click **SDK Tools** tab\n4. Check **Android SDK Command-line Tools**\n5. Click **Apply**\n\nThen run `flutter doctor --android-licenses` again.\n\n",
              "code": "# Accept all Android licenses\nflutter doctor --android-licenses\n\n# Type 'y' and press Enter for each license",
              "language": "bash"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 3: \"Waiting for another flutter command...\"",
              "content": "\n### Error message:\n\n### What happened:\nA previous Flutter command didn't finish properly and left a lock file.\n\n### Solution:\n\n\n",
              "code": "# Kill the lock file\ncd <your-flutter-installation>\nrm -f bin/cache/lockfile\n\n# Windows PowerShell:\nRemove-Item -Force bin/cache/lockfile\n\n# Or just restart your computer (easiest)",
              "language": "bash"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 4: Emulator Won't Start",
              "content": "\n### Symptom:\nEmulator starts but shows a black screen or crashes.\n\n### Solution 1: Enable Hardware Acceleration\n\n**Windows**:\n1. Open **Task Manager** ‚Üí **Performance**\n2. Check if \"Virtualization\" is enabled\n3. If not, enable Intel VT-x or AMD-V in BIOS\n\n**Mac**:\nHardware acceleration is enabled by default.\n\n**Linux**:\n\n### Solution 2: Allocate More RAM\n\n1. Open Android Studio\n2. **Tools** ‚Üí **Device Manager**\n3. Click the pencil icon (Edit) on your emulator\n4. Click **Show Advanced Settings**\n5. Increase RAM to at least 2048 MB\n6. Click **Finish**\n\n### Solution 3: Use a Different System Image\n\nSome system images work better than others:\n- Try **API 33** (Android 13) instead of the latest\n- Use **x86_64** images (faster than ARM)\n\n",
              "code": "# Install KVM\nsudo apt-get install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils\n\n# Add yourself to the kvm group\nsudo adduser $USER kvm",
              "language": "bash"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 5: App Builds But Crashes Immediately",
              "content": "\n### Check 1: Clean and Rebuild\n\n\n### Check 2: Check for Errors in Code\n\nLook at the terminal output. Common errors:\n\n‚Ü≥ Missing semicolon\n\n‚Ü≥ Missing import: `import 'package:flutter/material.dart';`\n\n‚Ü≥ Type mismatch - check your variables\n\n",
              "code": "Error: The argument type 'int' can't be assigned to 'String'",
              "language": "dart"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 6: Hot Reload Doesn't Work",
              "content": "\n### Symptoms:\n- You save changes but nothing updates\n- App needs full restart every time\n\n### Solutions:\n\n**1. Make sure you're editing the right file**\n- Are you editing `lib/main.dart`?\n- Not a file in `android/` or `ios/`?\n\n**2. Try Hot Restart instead**\n- Press `Ctrl/Cmd + Shift + F5`\n- Or click the circular arrow icon\n\n**3. Check for errors**\n- Look at the terminal for error messages\n- Fix any syntax errors\n\n**4. Full restart**\n\n",
              "code": "# Stop the app\nq (in terminal)\n\n# Clean\nflutter clean\n\n# Run again\nflutter run",
              "language": "bash"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 7: VS Code Not Finding Flutter",
              "content": "\n### Symptoms:\n- \"Dart\" or \"Flutter\" commands not available\n- No syntax highlighting\n- Can't run apps from VS Code\n\n### Solution:\n\n1. **Install Flutter Extension**:\n   - Press `Ctrl/Cmd + Shift + X`\n   - Search \"Flutter\"\n   - Install the official Flutter extension\n\n2. **Set Flutter SDK Path**:\n   - Press `Ctrl/Cmd + Shift + P`\n   - Type \"Flutter: Change SDK\"\n   - Select your Flutter installation path\n\n3. **Restart VS Code**:\n   - Close and reopen VS Code\n   - Check if Flutter commands work\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 8: Gradle Build Fails (Android)",
              "content": "\n### Error message:\n\n### Solution 1: Update Gradle\n\nEdit `android/build.gradle`:\n\n\n### Solution 2: Clear Gradle Cache\n\n\n### Solution 3: Update Java Version\n\nFlutter requires Java 11 or higher:\n\n\n",
              "code": "# Check Java version\njava -version\n\n# If it's older than 11, download from:\n# https://adoptium.net/",
              "language": "bash"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 9: Pod Install Fails (iOS/Mac)",
              "content": "\n### Error message:\n`Error: CocoaPods not installed` or `pod install failed`\n\nCocoaPods is a dependency manager for iOS. Flutter uses it to manage iOS-specific libraries.\n\n### Solution:\nInstall CocoaPods and set up your iOS project dependencies:\n\n\n",
              "code": "# Install CocoaPods\nsudo gem install cocoapods\n\n# Set up pods\npod setup\n\n# Then from your project:\ncd ios\npod install\ncd ..\n\n# Try running again\nflutter run",
              "language": "bash"
            },
            {
              "type": "ANALOGY",
              "title": "Problem 10: \"Version Solving Failed\"",
              "content": "\n### Error message:\n`Because package_a requires package_b ^1.0.0 which doesn't exist, version solving failed.`\n\nThis happens when your packages have conflicting version requirements - Package A needs version 1.x of something, but Package B needs version 2.x.\n\n### Solution:\nUpdate packages to compatible versions or reset your dependencies:\n\n\n",
              "code": "# Update all packages\nflutter pub upgrade\n\n# If that doesn't work, delete lock file\nrm pubspec.lock\n\n# Get fresh dependencies\nflutter pub get",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "The Nuclear Option: Complete Reset",
              "content": "\nIf nothing else works, a complete reset often fixes mysterious issues. This clears all cached files, compiled code, and temporary data, forcing Flutter to rebuild everything from scratch.\n\n**When to use this:** After trying other solutions, or when errors don't make sense.\n\n\n",
              "code": "# 1. Clean everything\nflutter clean\n\n# 2. Delete build files\nrm -rf build/\nrm -rf .dart_tool/\n\n# 3. Reset pub cache\nflutter pub cache repair\n\n# 4. Get dependencies\nflutter pub get\n\n# 5. Run\nflutter run",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Getting Help When Stuck",
              "content": "\n### Official Resources:\n- **Flutter Docs**: https://docs.flutter.dev\n- **Flutter GitHub Issues**: https://github.com/flutter/flutter/issues\n- **Stack Overflow**: Tag your question with `[flutter]`\n\n### Search Strategy:\n1. Copy the exact error message\n2. Google: \"flutter [your error message]\"\n3. Look for recent results (last 1-2 years)\n4. Try the top 3 solutions\n\n### Ask for Help:\nWhen asking questions, include:\n- Exact error message (full output)\n- Output of `flutter doctor -v`\n- What you've already tried\n- Code snippet (if relevant)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Common Error Patterns",
              "content": "\n| If you see... | It usually means... |\n|---------------|---------------------|\n| `command not found` | PATH not set correctly |\n| `licenses not accepted` | Run `flutter doctor --android-licenses` |\n| `version solving failed` | Package conflict - run `flutter pub upgrade` |\n| `gradle build failed` | Android build issue - clean and rebuild |\n| `pod install failed` | iOS/Mac dependency issue - reinstall CocoaPods |\n| `waiting for lock` | Previous Flutter command stuck - restart |\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ `flutter doctor` is your best friend\n- ‚úÖ Most errors have simple solutions\n- ‚úÖ Clean and rebuild fixes many issues\n- ‚úÖ Error messages tell you what's wrong\n- ‚úÖ Google is your ally\n- ‚úÖ The Flutter community is helpful!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "üõ†Ô∏è Flutter DevTools - Your Advanced Debugging Suite",
              "content": "\nFlutter comes with powerful debugging tools called **Flutter DevTools**. Think of it as X-ray vision for your app!\n\n### What is DevTools?\n\nDevTools is a browser-based suite of debugging and profiling tools built specifically for Flutter and Dart.\n\n### Launching DevTools\n\n**Option 1: From VS Code**\n1. Run your app (`F5` or `flutter run`)\n2. Open Command Palette (`Ctrl/Cmd + Shift + P`)\n3. Type \"Dart: Open DevTools\"\n4. Choose which tool to open\n\n**Option 2: From Terminal**\n```bash\n# Run app and get observatory URL\nflutter run\n\n# In another terminal:\nflutter pub global activate devtools\nflutter pub global run devtools\n```\n\n**Option 3: From Browser**\nWhen running `flutter run`, look for:\n```\nFlutter DevTools: http://127.0.0.1:9100?uri=...\n```\n\n### DevTools Tabs Explained\n\n#### 1. üîç Widget Inspector (Most Important!)\n\nSee your entire widget tree visually:\n\n```\nüå≥ Widget Tree View:\n\nMaterialApp\n ‚îî‚îÄ Scaffold\n     ‚îú‚îÄ AppBar\n     ‚îÇ   ‚îî‚îÄ Text: \"My App\"\n     ‚îî‚îÄ Center\n         ‚îî‚îÄ Column\n             ‚îú‚îÄ Text: \"Hello\"\n             ‚îî‚îÄ ElevatedButton\n```\n\n**What you can do:**\n- Click any widget to see its properties\n- See padding, margins, and constraints\n- Find layout issues (overflow, wrong sizes)\n- Select widgets directly on the device/emulator\n\n**Pro Tip**: Click the \"Select Widget Mode\" button, then tap any widget in your app to jump directly to it in the tree!\n\n#### 2. üìä Performance Overlay\n\nMonitor your app's performance in real-time:\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ UI Thread:  ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë  16ms    ‚îÇ ‚Üê Should be under 16ms\n‚îÇ GPU Thread: ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  8ms     ‚îÇ ‚Üê Should be under 16ms\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Enable from code:**\n```dart\nMaterialApp(\n  showPerformanceOverlay: true,  // üëà Add this!\n  home: MyHomePage(),\n)\n```\n\n**What to look for:**\n- Green bars = Good (under 16ms = 60 FPS)\n- Red bars = Bad (frame dropped, causes jank)\n- Spikes = Potential performance issue\n\n#### 3. üß† Memory Tab\n\nTrack memory usage and find leaks:\n\n- See live memory graph\n- Detect memory leaks\n- Take heap snapshots\n- Compare allocations\n\n**Warning signs:**\n- Memory constantly increasing = potential leak\n- Spikes during specific actions = heavy operations\n\n#### 4. üåê Network Tab\n\nMonitor all HTTP requests:\n\n```\nMethod | URL                    | Status | Time\n-------+------------------------+--------+------\nGET    | api.example.com/users  | 200    | 120ms\nPOST   | api.example.com/login  | 401    | 85ms ‚ùå\nGET    | api.example.com/posts  | 200    | 95ms\n```\n\n**What you can inspect:**\n- Request headers and body\n- Response data\n- Timing (how long each request takes)\n- Failed requests\n\n#### 5. üêõ Debugger\n\nSet breakpoints and step through code:\n- Pause at any line\n- Inspect variables\n- Step in/out/over functions\n- Watch expressions\n\n#### 6. üìù Logging\n\nView all logs from your app:\n\n```dart\nimport 'dart:developer' as developer;\n\n// These show in DevTools Logging tab\ndeveloper.log('User logged in', name: 'Auth');\ndeveloper.log('Fetched 10 items', name: 'API');\n```\n\n### Quick Debugging Shortcuts (VS Code)\n\n| Shortcut | Action |\n|----------|--------|\n| `F5` | Start debugging |\n| `F9` | Toggle breakpoint |\n| `F10` | Step over |\n| `F11` | Step into |\n| `Shift+F11` | Step out |\n| `Ctrl+Shift+D` | Open Debug panel |\n\n### Debugging Layout Issues with Inspector\n\n**Problem**: Your widget is in the wrong place or the wrong size.\n\n**Solution**:\n1. Open Widget Inspector\n2. Click \"Select Widget Mode\" (crosshair icon)\n3. Tap the problematic widget in your app\n4. In DevTools, look at:\n   - **Constraints**: What size was it told it can be?\n   - **Size**: What size did it actually choose?\n   - **Parent**: Who gave it those constraints?\n\n```\nConstraints: BoxConstraints(0.0<=w<=400.0, 0.0<=h<=600.0)\nActual Size: Size(200.0, 50.0)\nParent: Center ‚Üí gives tight constraints from parent\n```\n\n### Performance Debugging Workflow\n\n1. **Enable Performance Overlay**\n2. **Use your app normally**\n3. **Watch for red bars** (dropped frames)\n4. **Open Timeline View** in DevTools\n5. **Record** the problematic action\n6. **Analyze** what's taking too long:\n   - Build? ‚Üí Too many widgets rebuilding\n   - Layout? ‚Üí Expensive layout calculations\n   - Paint? ‚Üí Complex graphics\n\n**Common fixes:**\n- Add `const` constructors\n- Use `ListView.builder` instead of `ListView`\n- Cache expensive calculations\n- Use `RepaintBoundary` for complex animations\n\n### DevTools Cheat Sheet\n\n| I want to... | Use... |\n|--------------|--------|\n| Find why layout is wrong | Widget Inspector |\n| Fix slow animations | Performance tab |\n| Find memory leaks | Memory tab |\n| Debug API calls | Network tab |\n| Set breakpoints | Debugger tab |\n| View logs | Logging tab |\n| Profile CPU usage | CPU Profiler tab |\n\n**Bookmark this**: https://docs.flutter.dev/tools/devtools\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\n**Congratulations!** You've completed Module 0! Your development environment is set up, and you know how to troubleshoot problems.\n\nIn **Module 1**, we'll dive into the Dart programming language. You'll learn:\n- How to store information (variables)\n- How to make decisions (if/else)\n- How to repeat actions (loops)\n- How to organize code (functions)\n\nAll taught interactively with lots of hands-on practice!\n\nReady to start coding? Let's go! üöÄ\n\n"
            },
            {
              "type": "WARNING",
              "title": "Impeller Rendering Issues on Android",
              "content": "\n**What is Impeller?**\nImpeller is Flutter's modern rendering engine, replacing the older Skia renderer. It's enabled by default on iOS (since Flutter 3.29) and Android API 29+ (since Flutter 3.38).\n\n**Why You Might See Issues:**\nMost devices work perfectly, but some Android devices have GPU driver bugs that cause:\n- Visual glitches or artifacts\n- Unexpected stuttering\n- Blank screens\n\n**Quick Fix - Disable Impeller Temporarily:**\n```bash\nflutter run --no-enable-impeller\n```\n\n**If Issues Persist:**\nSee the full troubleshooting guide in `TROUBLESHOOTING.md` section A.1.\n\n**Good News:** Flutter automatically falls back to OpenGL on devices with known issues (like some Exynos chips). Most users never encounter problems.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "0.5-challenge-0",
              "title": "Practice Challenge",
              "description": "1. **Run flutter doctor**:    ```bash    flutter doctor -v    ```    The `-v` flag shows more details. Take a screenshot! 2. **Check Flutter version**:    ```bash    flutter --version    ``` 3. **List connected devices**:    ```bash    flutter devices    ``` 4. **Intentionally break something**:    - Open your hello_world app    - Delete a semicolon `;` somewhere    - Try to run it    - Read the error message    - Fix it! ---",
              "instructions": "1. **Run flutter doctor**:    ```bash    flutter doctor -v    ```    The `-v` flag shows more details. Take a screenshot! 2. **Check Flutter version**:    ```bash    flutter --version    ``` 3. **List connected devices**:    ```bash    flutter devices    ``` 4. **Intentionally break something**:    - Open your hello_world app    - Delete a semicolon `;` somewhere    - Try to run it    - Read the error message    - Fix it! ---",
              "starterCode": "// Practice Challenge\n// Write your code below\n\nvoid main() {\n    \n}",
              "solution": "// Solution: Troubleshooting and Debugging\n// This challenge teaches you to use diagnostic commands and read errors.\n//\n// Terminal commands covered:\n//\n// 1. Detailed doctor output:\n//    flutter doctor -v\n//\n// 2. Version check:\n//    flutter --version\n//\n// 3. List devices:\n//    flutter devices\n//\n// 4. Clean rebuild (useful for fixing issues):\n//    flutter clean && flutter pub get\n//\n// Example of code WITH an error (missing semicolon):\n\n// BROKEN CODE (will cause error):\n// void main() {\n//   print('Hello')  // <- Missing semicolon!\n// }\n//\n// Error message you'll see:\n// Error: Expected ';' after this.\n//   print('Hello')\n//                 ^\n\n// FIXED CODE:\nvoid main() {\n  print('Hello');  // <- Semicolon added!\n  \n  // Common syntax errors and fixes:\n  \n  // 1. Missing semicolon\n  // Error: Expected ';' after this\n  // Fix: Add ; at end of statement\n  \n  // 2. Mismatched brackets\n  // Error: Expected ')' or 'identifier'\n  // Fix: Check all opening brackets have closing ones\n  \n  // 3. Undefined variable\n  // Error: Undefined name 'variableName'\n  // Fix: Declare the variable before using it\n  \n  // 4. Type mismatch\n  // Error: A value of type 'X' can't be assigned to 'Y'\n  // Fix: Use correct types or add type conversion\n  \n  print('Troubleshooting complete!');\n  print('Remember: Error messages tell you WHAT is wrong and WHERE!');\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Program prints hello message",
                  "expectedOutput": "Hello",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Program confirms troubleshooting complete",
                  "expectedOutput": "Troubleshooting complete!",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Program explains error messages",
                  "expectedOutput": "Remember: Error messages tell you WHAT is wrong and WHERE!",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-01",
      "title": "Module 1: Flutter Development",
      "description": "Learn Flutter development - Module 1",
      "difficulty": "beginner",
      "estimatedHours": 7,
      "lessons": [
        {
          "id": "1.1",
          "title": "Module 1, Lesson 1: What is Code?",
          "moduleId": "module-01",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Welcome to Programming!",
              "content": "\nCongratulations on completing Module 0! You've got Flutter installed, your editor set up, and you've even run your first app. Now it's time to understand what's actually happening when you write code.\n\nThis is where your journey as a *real* programmer begins.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "The Recipe Analogy",
              "content": "\nImagine you're teaching a robot to make a sandwich. The robot is very literal - it only does *exactly* what you tell it to do.\n\nYou can't just say \"make me a sandwich.\" You need to give step-by-step instructions:\n\n\n**This is what code is**: A series of precise instructions that a computer follows, step by step.\n\n",
              "code": "1. Get two slices of bread\n2. Open the peanut butter jar\n3. Spread peanut butter on one slice\n4. Open the jelly jar\n5. Spread jelly on the other slice\n6. Put the two slices together\n7. Close both jars",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Code is Just Instructions",
              "content": "\nWhen you write code, you're writing instructions for a computer. The computer:\n- Reads your instructions from top to bottom (usually)\n- Executes them exactly as written\n- Doesn't make assumptions or \"guess\" what you meant\n- Will do exactly what you say, even if it's wrong!\n\nThis is both powerful and dangerous:\n- **Powerful**: You have complete control\n- **Dangerous**: Small mistakes (like forgetting a step) cause errors\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Line of Code",
              "content": "\nLet's write the simplest possible code. Open VS Code and create a new file called `first_code.dart`.\n\nType this exactly:\n\n\nNow run it:\n1. Press `Ctrl/Cmd + Shift + P`\n2. Type \"Dart: Run\"\n3. Press Enter\n\nYou should see in the terminal:\n\n\n**Congratulations!** You just wrote and executed your first program! üéâ\n\n",
              "code": "Hello, World!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Breaking It Down (Conceptual First)",
              "content": "\nLet's understand what each part does, *in plain English first*:\n\n\nThink of this like a play with actors on a stage:\n\n1. **The stage**: `main()` is the main stage where your program starts. Every Dart program must have a `main()`. It's the starting point.\n\n2. **The action**: Inside the curly braces `{ }` is what happens on that stage.\n\n3. **The dialogue**: `print('Hello, World!');` is like an actor saying a line. It displays text.\n\n",
              "code": "void main() {\n  print('Hello, World!');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Now the Technical Terms",
              "content": "\nNow that you understand the *concept*, here are the official programming terms:\n\n- **`void`**: This means \"doesn't give back any information.\" Don't worry about this yet.\n\n- **`main()`**: This is called a **function**. It's a container for instructions. The `main` function is special - it's where every program begins.\n\n- **`{ }`**: These curly braces define the **body** of the function. Everything inside them is part of `main`.\n\n- **`print()`**: This is also a function, but one that's already built into Dart. It displays text in the terminal.\n\n- **`'Hello, World!'`**: This is a **string** - programmer-speak for \"text.\" Strings always go in quotes.\n\n- **`;`**: The semicolon tells Dart \"this instruction is complete.\" It's like a period at the end of a sentence.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "The Golden Rule of Learning Code",
              "content": "\n**Don't memorize syntax. Understand concepts.**\n\nYou might forget whether to use `print()` or `display()`. That's okay! You can always look it up.\n\nWhat matters is understanding:\n- Programs run instructions in order\n- You need a starting point (`main`)\n- You can tell the computer to display text\n\nThe exact spelling and punctuation will become natural with practice.\n\n"
            },
            {
              "type": "EXPERIMENT",
              "title": "Let's Experiment!",
              "content": "\n### Experiment 1: Multiple Lines\n\nTry this:\n\n\nRun it. What do you see? Three lines of output!\n\n**Takeaway**: Instructions execute one after another, from top to bottom.\n\n### Experiment 2: What Happens If...?\n\nTry this (intentionally wrong):\n\n\nRun it. You get an error! Something like:\n\n\n**Takeaway**: Computers are picky. Every detail matters. Semicolons are required.\n\n### Experiment 3: Inside the Quotes\n\nTry this:\n\n\n**Takeaway**: Anything inside quotes is treated as text - numbers, symbols, emojis, everything!\n\n",
              "code": "void main() {\n  print('I can print numbers: 123');\n  print('I can print symbols: !@#$%');\n  print('I can even print emojis: üéâüöÄ');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Beginner Mistakes",
              "content": "\nHere are mistakes everyone makes at first:\n\n| Mistake | What Happens |\n|---------|--------------|\n| Forgetting `;` | Error: \"Expected ';'\" |\n| Mismatched quotes `'Hello\"` | Error: \"Unexpected character\" |\n| Forgetting `()` after `main` | Error: \"Expected '('\" |\n| Typing `Main` instead of `main` | Error: \"Expected 'main'\" |\n| Forgetting closing `}` | Error: \"Expected '}'\" |\n\n**These are normal!** Every programmer makes these mistakes. The computer will always tell you exactly what's wrong.\n\n"
            },
            {
              "type": "WARNING",
              "title": "Watch Out For These",
              "content": "\n**Common Pitfalls When Starting Out:**\n\n1. **Case sensitivity matters**\n   - `main` is NOT the same as `Main` or `MAIN`\n   - `print` is NOT the same as `Print`\n\n2. **Quotes must match**\n   - ‚úÖ `'Hello'` or `\"Hello\"` (both work)\n   - ‚ùå `'Hello\"` (mismatched = error!)\n\n3. **Single vs Double quotes in Dart**\n   - Both work! Dart treats `'text'` and `\"text\"` the same\n   - Use double quotes when your text has an apostrophe: `\"I'm learning\"`\n\n4. **Every opening brace needs a closing brace**\n   - `{` must have a matching `}`\n   - `(` must have a matching `)`\n\n5. **The terminal shows your output**\n   - Look at the bottom panel in VS Code to see `print()` results\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ Code is just step-by-step instructions\n- ‚úÖ Programs start at `main()`\n- ‚úÖ `print()` displays text\n- ‚úÖ Strings (text) go in quotes\n- ‚úÖ Semicolons end statements\n- ‚úÖ Computers are very literal and precise\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nRight now, we can only display pre-written text. What if we want to store information and reuse it?\n\nIn the next lesson, we'll learn about **variables** - how to store and work with information in your programs. Think of them as labeled boxes that hold data!\n\nSee you in the next lesson! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.1-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a file called `introduction.dart` and write a program that prints: ---",
              "instructions": "Create a file called `introduction.dart` and write a program that prints: ---",
              "starterCode": "// Your code here\n// Print three lines introducing yourself:\n// 1. Your name\n// 2. Where you're from\n// 3. Why you're learning Flutter",
              "solution": "void main() {\n  print('My name is Alex');\n  print(\"I'm from New York\");\n  print(\"I'm learning Flutter because I want to build my own apps!\");\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Program prints name introduction",
                  "expectedOutput": "My name is Alex",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Program prints location",
                  "expectedOutput": "I'm from New York",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Program prints motivation for learning Flutter",
                  "expectedOutput": "I'm learning Flutter because I want to build my own apps!",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print() function to display output. Each print() call creates a new line."
                },
                {
                  "level": 2,
                  "text": "Put your text inside quotes: print('your text here');"
                },
                {
                  "level": 3,
                  "text": "Remember: every print statement needs a semicolon at the end."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error: Expected ';'",
                  "correction": "Add ; at end of each print statement"
                },
                {
                  "mistake": "Mismatched quotes",
                  "consequence": "Syntax error: Unexpected character",
                  "correction": "Use matching quotes: 'text' or \"text\""
                },
                {
                  "mistake": "Forgetting void main() wrapper",
                  "consequence": "Code won't run",
                  "correction": "Wrap your print statements in void main() { }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.2",
          "title": "Module 1, Lesson 2: Storing Information (Variables)",
          "moduleId": "module-01",
          "order": 2,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Box Analogy",
              "content": "\nImagine you're organizing your room. You have different boxes:\n- A box labeled \"TOYS\" containing your toys\n- A box labeled \"BOOKS\" containing your books\n- A box labeled \"CLOTHES\" containing your clothes\n\nEach box has:\n1. A **label** (so you know what's inside)\n2. **Contents** (the actual stuff)\n\nIn programming, we call these boxes **variables**. They let us store information and give it a name so we can use it later.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why Do We Need Variables?",
              "content": "\nLook at this code:\n\n\nWhat if we want to change the name from \"Sarah\" to \"John\"? We'd have to change it in 3 places!\n\nNow look at this:\n\n\nNow if we want to use a different name, we only change it in **one place**! That's the power of variables.\n\n",
              "code": "void main() {\n  var name = 'Sarah';\n  print('Hello, $name!');\n  print('Welcome back, $name!');\n  print('$name, you have 3 new messages.');\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Creating Your First Variable",
              "content": "\nThe basic syntax is:\n\n\nLet's break this down:\n\n**Conceptual Explanation**:\n- We're creating a box\n- The box is labeled `name`\n- We're putting the text `'Sarah'` inside it\n\n**Technical Terms**:\n- `var`: This keyword tells Dart \"I'm about to create a variable\"\n- `name`: This is the variable name (the label on the box)\n- `=`: This is the assignment operator (putting something in the box)\n- `'Sarah'`: This is the value (the contents of the box)\n\n",
              "code": "var name = 'Sarah';",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Different Types of Boxes",
              "content": "\nJust like in real life, we need different types of containers for different things. You wouldn't store milk in a cardboard box!\n\nIn Dart, variables have **types**:\n\n### 1. Text (Strings)\n\nFor storing words and sentences:\n\n\n### 2. Numbers (Integers)\n\nFor storing whole numbers:\n\n\n### 3. Decimal Numbers (Doubles)\n\nFor storing numbers with decimals:\n\n\n### 4. True/False (Booleans)\n\nFor storing yes/no, true/false values:\n\n\n",
              "code": "var isLoggedIn = true;\nvar hasNewMessages = false;\nvar isWeekend = true;",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Using Variables",
              "content": "\nOnce you create a variable, you can use it anywhere in your code:\n\n\n**Output**:\n\nNotice the `$` symbol? That's how we insert variables into strings. It's called **string interpolation**.\n\n",
              "code": "My name is Alex\nI am 28 years old\nI live in New York",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Changing Variable Contents",
              "content": "\nVariables aren't permanent - you can change what's inside the box:\n\n\nNotice: The second time, we don't use `var` - we already created the variable!\n\n",
              "code": "void main() {\n  var mood = 'happy';\n  print('I am feeling $mood');  // Output: I am feeling happy\n\n  mood = 'excited';  // Change the contents\n  print('Now I am feeling $mood');  // Output: Now I am feeling excited\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Variable Naming Rules",
              "content": "\nYou can't just name variables anything you want. There are rules:\n\n**‚úÖ Valid Names**:\n\n**‚ùå Invalid Names**:\n\n**Naming Convention (Best Practice)**:\n- Use camelCase: `firstName`, `myAge`, `isLoggedIn`\n- First word lowercase, subsequent words capitalized\n- Be descriptive: `userName` is better than `un`\n\n",
              "code": "var 2age = 25;           // Can't start with a number\nvar first-name = 'Alex'; // Can't use hyphens\nvar my age = 25;         // Can't have spaces\nvar class = 'Math';      // 'class' is a reserved word",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Explicit Types (Being More Specific)",
              "content": "\nInstead of using `var` (where Dart guesses the type), you can be explicit:\n\n\n**When to use `var` vs explicit types?**\n- `var`: When the type is obvious from the value\n- Explicit (`String`, `int`, etc.): When you want to be extra clear\n\nBoth work! It's mostly personal preference.\n\n",
              "code": "void main() {\n  String name = 'Sarah';      // This box only holds text\n  int age = 25;               // This box only holds integers\n  double price = 19.99;       // This box only holds decimals\n  bool isActive = true;       // This box only holds true/false\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Sound Null Safety: String vs String? Are DIFFERENT Types!",
              "content": "\nDart 3 has **sound null safety**, which prevents crashes from null values. Here's the key insight:\n\n### `String` and `String?` Are Completely Different Types!\n\n```dart\nString name = 'Alice';    // MUST have a value, NEVER null\nString? nickname = null;  // CAN be null (the ? makes it optional)\n```\n\n**Think of it like boxes:**\n- `String` = A box that MUST contain text (never empty)\n- `String?` = A box that MIGHT contain text OR be empty (null)\n\n### Why This Matters\n\n```dart\nvoid main() {\n  String name = 'Bob';     // ‚úÖ OK - has a value\n  // String name2 = null;  // ‚ùå ERROR! String can't be null\n  \n  String? nickname = null; // ‚úÖ OK - String? allows null\n  nickname = 'Bobby';      // ‚úÖ Can also hold a value\n}\n```\n\n### Working With Nullable Types\n\n```dart\nvoid main() {\n  String? userName = getUserName(); // Might be null\n  \n  // ‚ùå This WON'T work:\n  // print(userName.length);  // Error! userName might be null\n  \n  // ‚úÖ Option 1: Null check\n  if (userName != null) {\n    print(userName.length);  // Safe - we checked!\n  }\n  \n  // ‚úÖ Option 2: Elvis operator (provide default)\n  print(userName ?? 'Guest');  // If null, use 'Guest'\n  \n  // ‚úÖ Option 3: Safe navigation\n  print(userName?.length);  // Returns null if userName is null\n  \n  // ‚ö†Ô∏è Option 4: Force unwrap (DANGEROUS!)\n  // print(userName!.length);  // Crashes if null!\n}\n```\n\n### Quick Reference\n\n| Type | Can Be Null? | Example |\n|------|--------------|--------|\n| `String` | ‚ùå No | Must have text |\n| `String?` | ‚úÖ Yes | Can be null |\n| `int` | ‚ùå No | Must have number |\n| `int?` | ‚úÖ Yes | Can be null |\n| `List<String>` | ‚ùå No | Must have list |\n| `List<String>?` | ‚úÖ Yes | List or null |\n\n**Rule of Thumb**: Only use `?` when something truly might not exist. Prefer non-nullable types!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Math with Variables",
              "content": "\nYou can do math with number variables:\n\n\n**Note**: To print an actual `$` symbol, you need to escape it with `\\$`.\n\n",
              "code": "void main() {\n  var apples = 5;\n  var oranges = 3;\n  var totalFruit = apples + oranges;\n\n  print('Total fruit: $totalFruit');  // Output: Total fruit: 8\n\n  var price = 10.50;\n  var tax = 2.15;\n  var total = price + tax;\n\n  print('Total with tax: \\$${total}');  // Output: Total with tax: $12.65\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Beginner Mistakes",
              "content": "\n| Mistake | What Happens |\n|---------|--------------|\n| `var Name = 'Alex';` | Works, but should be `name` (lowercase first letter) |\n| `name = 'Alex';` without `var` first | Error: Variable not declared |\n| `var age = '25';` then trying to do math | Wrong! '25' is text, not a number |\n| `var age = 25; var age = 30;` | Error: Variable already declared |\n| Using a variable before creating it | Error: Undefined name |\n\n"
            },
            {
              "type": "WARNING",
              "title": "Variable Pitfalls to Avoid",
              "content": "\n**Watch out for these common traps:**\n\n1. **Confusing text numbers with actual numbers**\n   - `var age = '25';` - This is TEXT, not a number!\n   - `var age = 25;` - This is an actual number you can do math with\n\n2. **Forgetting to declare variables first**\n   - ‚ùå `name = 'Alex';` (Error - where did `name` come from?)\n   - ‚úÖ `var name = 'Alex';` (Correct - we're creating it)\n\n3. **Declaring a variable twice**\n   - ‚ùå `var age = 25; var age = 30;` (Error!)\n   - ‚úÖ `var age = 25; age = 30;` (Correct - updating existing)\n\n4. **Using variables before they exist**\n   - The variable must be created BEFORE you use it\n   - Dart reads top-to-bottom!\n\n5. **Type confusion with `var`**\n   - Once Dart decides a variable's type, you can't change it\n   - `var x = 5;` then `x = 'hello';` = ERROR!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ Variables are like labeled boxes that store information\n- ‚úÖ Use `var` or explicit types (`String`, `int`, `double`, `bool`)\n- ‚úÖ Use `$variableName` to insert variables into strings\n- ‚úÖ Variables can be changed after creation\n- ‚úÖ We can do math with number variables\n- ‚úÖ Variable names follow specific rules\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nNow we can store information. But what if we want our program to make decisions?\n\n\"If the user is logged in, show the dashboard. Otherwise, show the login page.\"\n\n\"If the age is under 18, show 'You're a minor'. Otherwise, show 'You're an adult'.\"\n\nIn the next lesson, we'll learn about **conditionals** (if/else statements) - how to make your program smart enough to make decisions!\n\nSee you there! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.2-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a file called `my_profile.dart` with: 1. Variables for:    - Your full name (String)    - Your age (int)    - Your favorite food (String)    - Whether you like programming (bool - true or false)    - Your height in feet (double) 2. Print out all this information in a nice format --- ## Bonus Challenge: Do Some Math Add these variables and calculations: Does it match your age variable? ---",
              "instructions": "Create a file called `my_profile.dart` with: 1. Variables for:    - Your full name (String)    - Your age (int)    - Your favorite food (String)    - Whether you like programming (bool - true or false)    - Your height in feet (double) 2. Print out all this information in a nice format --- ## Bonus Challenge: Do Some Math Add these variables and calculations: Does it match your age variable? ---",
              "starterCode": "// My Profile\n// TODO: Create variables for your profile information\n\nvoid main() {\n  // TODO: Create a String variable for your name\n  \n  // TODO: Create an int variable for your age\n  \n  // TODO: Create a String variable for your favorite food\n  \n  // TODO: Create a bool variable for whether you like programming\n  \n  // TODO: Create a double variable for your height\n  \n  // TODO: Print all the information in a nice format\n  print('=== My Profile ===');\n  // Add more print statements here...\n}",
              "solution": "// Solution: My Profile\n\nvoid main() {\n  // Variables for profile information\n  String name = 'Alex Johnson';\n  int age = 28;\n  String favoriteFood = 'Pizza';\n  bool likesProgramming = true;\n  double height = 5.9;\n  \n  // Print profile\n  print('=== My Profile ===');\n  print('Name: $name');\n  print('Age: $age');\n  print('Favorite Food: $favoriteFood');\n  print('Likes Programming: $likesProgramming');\n  print('Height: $height feet');\n  \n  // Bonus: Calculate age from birth year\n  var currentYear = 2025;\n  var birthYear = 1997;\n  var calculatedAge = currentYear - birthYear;\n  print('Calculated age: $calculatedAge');\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Program displays profile header",
                  "expectedOutput": "=== My Profile ===",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Program displays name with variable",
                  "expectedOutput": "Name: Alex Johnson",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Program calculates age correctly",
                  "expectedOutput": "Calculated age: 28",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print() function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In dart, use appropriate syntax."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.3",
          "title": "Module 1, Lesson 3: Making Decisions (if/else)",
          "moduleId": "module-01",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Choose Your Own Adventure",
              "content": "\nRemember those \"Choose Your Own Adventure\" books?\n\n> You're standing at a fork in the road.\n> - If you go left, turn to page 42\n> - If you go right, turn to page 67\n\nPrograms need to make decisions like this all the time:\n- If the password is correct, log the user in. Otherwise, show an error.\n- If it's raining, bring an umbrella. Otherwise, leave it home.\n- If the score is above 90, show an \"A\". Otherwise, show a different grade.\n\nThis is what **conditionals** do - they let your program choose different paths based on conditions.\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Basic Pattern: if",
              "content": "\nHere's the simplest decision:\n\n\n**Conceptual Explanation**:\n- We check a condition: \"Is age greater than or equal to 18?\"\n- If the answer is YES (true), we run the code inside the `{ }`\n- If the answer is NO (false), we skip that code\n\n**Output**: `You are an adult!` (because 20 is >= 18)\n\n",
              "code": "void main() {\n  var age = 20;\n\n  if (age >= 18) {\n    print('You are an adult!');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Now the Technical Terms",
              "content": "\n\n- **`if`**: Keyword that starts a conditional\n- **`(condition)`**: The test we're checking (must be true or false)\n- **`{ }`**: The block of code to run if the condition is true\n\n",
              "code": "if (condition) {\n  // Code to run if condition is true\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Adding an \"Otherwise\": else",
              "content": "\nWhat if we want to do something when the condition is false?\n\n\n**Output**: `You are a minor.` (because 15 is not >= 18)\n\nThink of it like:\n- **IF** the condition is true, do the first thing\n- **OTHERWISE** (else), do the second thing\n\n",
              "code": "void main() {\n  var age = 15;\n\n  if (age >= 18) {\n    print('You are an adult!');\n  } else {\n    print('You are a minor.');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Multiple Choices: else if",
              "content": "\nWhat if you have more than two options?\n\n\n**Output**: `Grade: B`\n\nThe program:\n1. Checks if score >= 90 (NO, 85 is not >= 90)\n2. Checks if score >= 80 (YES! ‚Üí runs this block)\n3. Stops checking (once one condition is true, it skips the rest)\n\n",
              "code": "void main() {\n  var score = 85;\n\n  if (score >= 90) {\n    print('Grade: A');\n  } else if (score >= 80) {\n    print('Grade: B');\n  } else if (score >= 70) {\n    print('Grade: C');\n  } else if (score >= 60) {\n    print('Grade: D');\n  } else {\n    print('Grade: F');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Comparison Operators",
              "content": "\nThese are the symbols we use to compare things:\n\n| Operator | Meaning | Example |\n|----------|---------|---------|\n| `==` | Equal to | `age == 18` |\n| `!=` | Not equal to | `age != 18` |\n| `>` | Greater than | `age > 18` |\n| `<` | Less than | `age < 18` |\n| `>=` | Greater than or equal | `age >= 18` |\n| `<=` | Less than or equal | `age <= 18` |\n\n**Common Mistake**: Using `=` instead of `==`\n- `=` means \"assign a value\" (putting something in a box)\n- `==` means \"compare for equality\" (checking if two things are equal)\n\n\n",
              "code": "var age = 18;      // ‚úÖ Assignment (setting age to 18)\nif (age == 18) {   // ‚úÖ Comparison (checking if age equals 18)\n  print('Age is 18');\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Real-World Examples",
              "content": "\n### Example 1: Login Check\n\n\n### Example 2: Weather Advice\n\n\n**Note**: `\\'` lets you put an apostrophe inside a single-quoted string.\n\n### Example 3: Shopping Cart\n\n\n**Output**: `You need $5.0 more.`\n\n",
              "code": "void main() {\n  var itemPrice = 50.00;\n  var walletMoney = 45.00;\n\n  if (walletMoney >= itemPrice) {\n    print('Purchase successful!');\n  } else {\n    var shortage = itemPrice - walletMoney;\n    print('You need \\$$shortage more.');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Combining Conditions: AND / OR",
              "content": "\nSometimes you need to check multiple things at once.\n\n### AND (&&) - Both must be true\n\n\n### OR (||) - At least one must be true\n\n\n### NOT (!) - Flips true/false\n\n\n",
              "code": "void main() {\n  var isRaining = false;\n\n  if (!isRaining) {\n    print('It\\'s not raining. Let\\'s go outside!');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Patterns",
              "content": "\n### Pattern 1: Range Checking\n\n\n### Pattern 2: Eligibility Checking\n\n\n### Pattern 3: Validation\n\n\n",
              "code": "var username = '';\n\nif (username == '') {\n  print('Error: Username cannot be empty');\n} else {\n  print('Username: $username');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Beginner Mistakes",
              "content": "\n| Mistake | What Happens |\n|---------|--------------|\n| `if (age = 18)` instead of `if (age == 18)` | Syntax error or unexpected behavior |\n| Forgetting `{ }` around code blocks | Only the first line is conditional |\n| `if (age > 18 && < 30)` | Syntax error - need `age < 30` |\n| Not covering all cases with else | Some inputs might not do anything |\n| Checking conditions in wrong order | Wrong condition might match first |\n\n"
            },
            {
              "type": "WARNING",
              "title": "if/else Pitfalls",
              "content": "\n**The = vs == Trap**\n\nThis is the #1 mistake with conditionals:\n- `=` means ASSIGN (put value into variable)\n- `==` means COMPARE (check if equal)\n\n‚ùå `if (age = 18)` - This ASSIGNS 18 to age, not compare!\n‚úÖ `if (age == 18)` - This COMPARES age to 18\n\n**Order Matters with else if**\n\nConditions are checked top-to-bottom. First match wins!\n\n‚ùå Wrong order:\n```dart\nif (score >= 60) { print('Pass'); }\nelse if (score >= 90) { print('A'); }  // Never reached!\n```\n\n‚úÖ Correct order:\n```dart\nif (score >= 90) { print('A'); }  // Check highest first\nelse if (score >= 60) { print('Pass'); }\n```\n\n**Always Use Braces**\n\nEven for single lines, use `{ }` to avoid bugs:\n```dart\n// Dangerous - only first line is conditional\nif (isLoggedIn)\n  print('Welcome');\n  showDashboard();  // This ALWAYS runs!\n\n// Safe - both lines are conditional\nif (isLoggedIn) {\n  print('Welcome');\n  showDashboard();\n}\n```\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ `if` lets programs make decisions\n- ‚úÖ `else` handles the \"otherwise\" case\n- ‚úÖ `else if` handles multiple options\n- ‚úÖ Comparison operators: `==`, `!=`, `>`, `<`, `>=`, `<=`\n- ‚úÖ Logical operators: `&&` (AND), `||` (OR), `!` (NOT)\n- ‚úÖ Conditions must evaluate to true or false\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nNow we can store information (variables) and make decisions (if/else). But what if we need to do something many times?\n\nFor example:\n- Print numbers 1 through 100\n- Process every item in a shopping cart\n- Repeat a game until the player wants to quit\n\nIn the next lesson, we'll learn about **loops** - how to repeat actions without copying and pasting code!\n\nSee you there! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.3-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a file called `age_advice.dart` that: 1. Has a variable `age` set to your age (or any age) 2. Uses if/else if/else to print different messages:    - If age < 13: \"You're a child! Enjoy playing!\"    - If age >= 13 and < 20: \"You're a teenager! Study hard!\"    - If age >= 20 and < 65: \"You're an adult! Work hard, but enjoy life!\"    - If age >= 65: \"You're a senior! Time to relax and enjoy retirement!\" --- ## Bonus Challenge: Grade Calculator Create a program that takes a score (0-100) and:   - 93-100: A   - 90-92: A-   - 87-89: B+   - And so on... This is tricky! You'll need nested conditions or multiple checks. ---",
              "instructions": "Create a file called `age_advice.dart` that: 1. Has a variable `age` set to your age (or any age) 2. Uses if/else if/else to print different messages:    - If age < 13: \"You're a child! Enjoy playing!\"    - If age >= 13 and < 20: \"You're a teenager! Study hard!\"    - If age >= 20 and < 65: \"You're an adult! Work hard, but enjoy life!\"    - If age >= 65: \"You're a senior! Time to relax and enjoy retirement!\" --- ## Bonus Challenge: Grade Calculator Create a program that takes a score (0-100) and:   - 93-100: A   - 90-92: A-   - 87-89: B+   - And so on... This is tricky! You'll need nested conditions or multiple checks. ---",
              "starterCode": "// Age Advice Program\n// TODO: Use if/else if/else to give age-appropriate advice\n\nvoid main() {\n  // TODO: Set an age variable\n  var age = 25;\n  \n  // TODO: Check the age and print appropriate message\n  // - Under 13: child message\n  // - 13-19: teenager message\n  // - 20-64: adult message\n  // - 65+: senior message\n  \n  if (age < 13) {\n    // TODO: Print child message\n  }\n  // TODO: Add else if and else branches\n}",
              "solution": "// Solution: Age Advice Program\n\nvoid main() {\n  var age = 25;  // Try different ages to test!\n  \n  if (age < 13) {\n    print(\"You're a child! Enjoy playing!\");\n  } else if (age >= 13 && age < 20) {\n    print(\"You're a teenager! Study hard!\");\n  } else if (age >= 20 && age < 65) {\n    print(\"You're an adult! Work hard, but enjoy life!\");\n  } else {\n    print(\"You're a senior! Time to relax and enjoy retirement!\");\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Adult age (25) displays correct message",
                  "expectedOutput": "You're an adult! Work hard, but enjoy life!",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Child age (10) displays correct message",
                  "expectedOutput": "You're a child! Enjoy playing!",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Senior age (70) displays correct message",
                  "expectedOutput": "You're a senior! Time to relax and enjoy retirement!",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print() function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In dart, use appropriate syntax."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.4",
          "title": "Module 1, Lesson 4: Repeating Actions (Loops)",
          "moduleId": "module-01",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Chore Analogy",
              "content": "\nImagine your parent tells you: \"Wash all 10 dishes in the sink.\"\n\nYou wouldn't write:\n\nYou'd think: \"**Repeat** washing until all dishes are done.\"\n\nThat's exactly what **loops** do in programming - they repeat actions without you having to write the same code over and over.\n\n",
              "code": "Wash dish 1\nWash dish 2\nWash dish 3\nWash dish 4\nWash dish 5\nWash dish 6\nWash dish 7\nWash dish 8\nWash dish 9\nWash dish 10",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Why Do We Need Loops?",
              "content": "\nLook at this code:\n\n\nWhat if you have 100 users? Or 1000? You can't write 1000 lines!\n\nWith a loop:\n\n\n**Output**:\n\nSame result, way less code!\n\n",
              "code": "Welcome user 1!\nWelcome user 2!\nWelcome user 3!\nWelcome user 4!\nWelcome user 5!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "The \"for\" Loop - Counting Repetitions",
              "content": "\nWhen you know **exactly how many times** to repeat something, use a `for` loop.\n\n**Conceptual Explanation**:\nThink of it like counting:\n- **Start** at 1\n- **Keep going** while less than or equal to 5\n- **Count up** by 1 each time\n\n**The Pattern**:\n\n\n**Real Example**:\n\n\n**Output**:\n\n",
              "code": "This is repetition number 1\nThis is repetition number 2\nThis is repetition number 3",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down the \"for\" Loop",
              "content": "\n\n**The Three Parts**:\n\n1. **`var i = 1`** - **Start**: Create a counter starting at 1\n2. **`i <= 3`** - **Condition**: Keep looping while i is ‚â§ 3\n3. **`i++`** - **Increment**: Add 1 to i after each loop\n\n**`i++` is shorthand for `i = i + 1`**\n\n**What Happens**:\n- First time: i = 1, prints \"Count: 1\", then i becomes 2\n- Second time: i = 2, prints \"Count: 2\", then i becomes 3\n- Third time: i = 3, prints \"Count: 3\", then i becomes 4\n- Fourth time: i = 4, but 4 is not ‚â§ 3, so STOP\n\n",
              "code": "for (var i = 1; i <= 3; i++) {\n  print('Count: $i');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Different Counting Patterns",
              "content": "\n### Counting Down\n\n\n**Output**:\n\n**Note**: `i--` means \"subtract 1\" (shorthand for `i = i - 1`)\n\n### Counting by 2s\n\n\n**Output**:\n\n**Note**: `i += 2` means \"add 2\" (shorthand for `i = i + 2`)\n\n### Starting from Any Number\n\n\n",
              "code": "void main() {\n  for (var age = 18; age <= 21; age++) {\n    print('At age $age, you can...');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "The \"while\" Loop - Repeat Until...",
              "content": "\nWhen you **don't know how many times** you'll repeat, but you know **when to stop**, use a `while` loop.\n\n**Conceptual Explanation**:\nThink of it like: \"**While** it's raining, stay inside.\"\n- You don't know how long it will rain\n- But you know the condition to check\n\n**The Pattern**:\n\n\n**Real Example**:\n\n\n**Output**:\n\n**‚ö†Ô∏è Warning**: If you forget `count++`, the loop runs FOREVER (infinite loop)!\n\n",
              "code": "Count is 1\nCount is 2\nCount is 3\nCount is 4\nCount is 5",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Real-World Examples",
              "content": "\n### Example 1: Multiplication Table\n\n\n**Output**:\n\n### Example 2: Password Attempts\n\n\n### Example 3: Sum of Numbers\n\n\n",
              "code": "void main() {\n  var sum = 0;\n\n  for (var i = 1; i <= 10; i++) {\n    sum += i;  // Same as: sum = sum + i\n  }\n\n  print('Sum of 1 to 10 is: $sum');  // Output: 55\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "The \"break\" Keyword - Exit Early",
              "content": "\nSometimes you want to **stop a loop** before it naturally ends:\n\n\n**Output**:\n\n**Use case**: Searching for something - once you find it, stop looking!\n\n",
              "code": "1\n2\n3\n4\n5\nLoop stopped",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "The \"continue\" Keyword - Skip to Next",
              "content": "\nSometimes you want to **skip the current iteration** and continue with the next:\n\n\n**Output**:\n\n**Notice**: 3 is missing because we skipped it!\n\n**Use case**: Filtering - process items that match a condition, skip others.\n\n",
              "code": "1\n2\n4\n5",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Nested Loops - Loops Inside Loops",
              "content": "\nYou can put loops inside loops!\n\n\n**Output**:\n\n**Use case**: Grid patterns, tables, 2D games (rows and columns).\n\n",
              "code": "Row 1, Column 1\nRow 1, Column 2\nRow 1, Column 3\nRow 2, Column 1\nRow 2, Column 2\nRow 2, Column 3\nRow 3, Column 1\nRow 3, Column 2\nRow 3, Column 3",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Beginner Mistakes",
              "content": "\n| Mistake | What Happens |\n|---------|--------------|\n| Forgetting `i++` in while loop | Infinite loop! |\n| Using `=` instead of `==` in condition | Always true or syntax error |\n| Starting at wrong number | Loop runs wrong number of times |\n| Off-by-one error (`< 5` vs `<= 5`) | Loop runs one too few or too many times |\n| Forgetting `var` before `i` | Error: i not defined |\n\n"
            },
            {
              "type": "WARNING",
              "title": "Loop Pitfalls to Avoid",
              "content": "\n**The Infinite Loop Trap**\n\nThe #1 mistake in loops! If your condition never becomes false, the loop runs forever:\n\n‚ùå Infinite loop - i never changes:\n```dart\nvar i = 0;\nwhile (i < 5) {\n  print(i);  // Prints 0 forever!\n  // Forgot i++!\n}\n```\n\n‚úÖ Fixed - i increments:\n```dart\nvar i = 0;\nwhile (i < 5) {\n  print(i);\n  i++;  // Now it will stop at 5\n}\n```\n\n**Off-By-One Errors**\n\nThese are subtle and common:\n- `for (var i = 0; i < 5; i++)` ‚Üí runs 5 times (0,1,2,3,4)\n- `for (var i = 0; i <= 5; i++)` ‚Üí runs 6 times (0,1,2,3,4,5)\n- `for (var i = 1; i <= 5; i++)` ‚Üí runs 5 times (1,2,3,4,5)\n\n**Modifying Collections While Iterating**\n\n‚ùå Don't add/remove items while looping through a list:\n```dart\nfor (var item in items) {\n  items.remove(item);  // CRASH or unexpected behavior!\n}\n```\n\n‚úÖ Create a copy or use removeWhere:\n```dart\nitems.removeWhere((item) => shouldRemove(item));\n```\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ Loops let us repeat code without copy-pasting\n- ‚úÖ `for` loops are for known repetitions\n- ‚úÖ `while` loops run until a condition is false\n- ‚úÖ `i++` increments, `i--` decrements\n- ‚úÖ `break` exits a loop early\n- ‚úÖ `continue` skips to the next iteration\n- ‚úÖ Nested loops create patterns and grids\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nNow we can store data (variables), make decisions (if/else), and repeat actions (loops). But what if we want to **organize** our code into reusable pieces?\n\nIn the next lesson, we'll learn about **Functions** - how to create your own custom commands that you can use over and over!\n\nThink of them as creating your own recipes that you can follow anytime.\n\nSee you there! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.4-challenge-0",
              "title": "Practice Challenge",
              "description": "Print this pattern using nested loops: --- ## Bonus Challenge: FizzBuzz This is a classic programming interview question! ---",
              "instructions": "Print this pattern using nested loops: --- ## Bonus Challenge: FizzBuzz This is a classic programming interview question! ---",
              "starterCode": "// Star Pattern with Nested Loops\n// TODO: Print a triangle of stars\n// *\n// **\n// ***\n// ****\n// *****\n\nvoid main() {\n  // TODO: Outer loop for rows (1 to 5)\n  for (var row = 1; row <= 5; row++) {\n    // TODO: Inner loop to print stars for this row\n    // Hint: Use print() without newline, then print('')\n    \n  }\n}",
              "solution": "// Solution: Star Pattern\n\nvoid main() {\n  // Print star triangle\n  for (var row = 1; row <= 5; row++) {\n    var stars = '';\n    for (var col = 1; col <= row; col++) {\n      stars += '*';\n    }\n    print(stars);\n  }\n  \n  print('');  // Blank line\n  \n  // Bonus: FizzBuzz\n  print('FizzBuzz:');\n  for (var i = 1; i <= 15; i++) {\n    if (i % 3 == 0 && i % 5 == 0) {\n      print('FizzBuzz');\n    } else if (i % 3 == 0) {\n      print('Fizz');\n    } else if (i % 5 == 0) {\n      print('Buzz');\n    } else {\n      print(i);\n    }\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Pattern starts with single asterisk",
                  "expectedOutput": "*",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Pattern includes five asterisks on last row",
                  "expectedOutput": "*****",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "FizzBuzz prints Fizz for multiples of 3",
                  "expectedOutput": "Fizz",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print() function to display output."
                },
                {
                  "level": 2,
                  "text": "Use a for loop or while loop to repeat the operation."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.5",
          "title": "Module 1, Lesson 5: Reusable Instructions (Functions)",
          "moduleId": "module-01",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Recipe Analogy",
              "content": "\nImagine you love making peanut butter sandwiches. Instead of remembering all the steps every time, you have a recipe card:\n\n\nNow, whenever you want a sandwich, you just say \"Make PB&J Sandwich\" and follow the recipe!\n\n**Functions are exactly like this** - they're named sets of instructions you can use over and over.\n\n",
              "code": "Recipe: Make PB&J Sandwich\n1. Get two slices of bread\n2. Spread peanut butter on one slice\n3. Spread jelly on the other slice\n4. Put the slices together\n5. Cut in half",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Why Do We Need Functions?",
              "content": "\nLook at this repetitive code:\n\n\nWe're printing those equals signs multiple times. With a function:\n\n\n**Same output, cleaner code!**\n\n",
              "code": "void printBorder() {\n  print('==========');\n}\n\nvoid main() {\n  printBorder();\n  print('Welcome!');\n  printBorder();\n\n  print('Processing...');\n\n  printBorder();\n  print('Done!');\n  printBorder();\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Creating Your First Function",
              "content": "\n**Conceptual Explanation**:\nA function is like creating your own command. Once you define it, you can use it anywhere!\n\n**The Pattern**:\n\n\n**Real Example**:\n\n\n**Output**:\n\n",
              "code": "Hello!\nWelcome to Flutter!\nHave a great day!\nHello!\nWelcome to Flutter!\nHave a great day!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Breaking Down a Function",
              "content": "\n\n**The Parts**:\n\n1. **`void`** - This means \"doesn't give anything back\" (we'll learn about returning values soon)\n2. **`sayHello`** - The function name (use camelCase)\n3. **`()`** - Parameters go here (empty for now)\n4. **`{ }`** - The function body (code to run)\n\n",
              "code": "void sayHello() {\n  print('Hello!');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Functions with Parameters - Making Them Flexible",
              "content": "\nWhat if you want to greet different people?\n\n**Without parameters** (rigid):\n\n**With parameters** (flexible):\n\n**Conceptual Explanation**:\nParameters are like **placeholders** or **blank spaces** in your recipe that you fill in when you use it.\n\n",
              "code": "void greet(String name) {\n  print('Hello, $name!');\n}\n\nvoid main() {\n  greet('Alice');  // Output: Hello, Alice!\n  greet('Bob');    // Output: Hello, Bob!\n  greet('Charlie'); // Output: Hello, Charlie!\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Multiple Parameters",
              "content": "\nYou can have multiple parameters:\n\n\n**Output**:\n\n**Order matters!** The values you pass must match the parameter order.\n\n",
              "code": "Hi! My name is Sarah.\nI am 25 years old.\nI live in New York.\nHi! My name is Mike.\nI am 30 years old.\nI live in Los Angeles.",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Functions That Return Values",
              "content": "\nSometimes you want a function to **give you back** a result.\n\n**Conceptual Explanation**:\nThink of a vending machine:\n- You put in money and press a button (call the function)\n- It **returns** a snack to you (the return value)\n\n**The Pattern**:\n\n\n**Real Example**:\n\n\n**Notice**:\n- **`int`** instead of `void` - this function returns an integer\n- **`return`** keyword sends the value back\n\n",
              "code": "int add(int a, int b) {\n  return a + b;\n}\n\nvoid main() {\n  var result = add(5, 3);\n  print('5 + 3 = $result');  // Output: 5 + 3 = 8\n\n  var another = add(10, 20);\n  print('10 + 20 = $another'); // Output: 10 + 20 = 30\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "More Return Examples",
              "content": "\n### Calculate Area of Rectangle\n\n\n### Check if Adult\n\n\n### Get Greeting Based on Time\n\n\n",
              "code": "String getGreeting(int hour) {\n  if (hour < 12) {\n    return 'Good morning!';\n  } else if (hour < 18) {\n    return 'Good afternoon!';\n  } else {\n    return 'Good evening!';\n  }\n}\n\nvoid main() {\n  print(getGreeting(9));   // Output: Good morning!\n  print(getGreeting(14));  // Output: Good afternoon!\n  print(getGreeting(20));  // Output: Good evening!\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Optional Parameters",
              "content": "\nSometimes you want parameters to be **optional**:\n\n\n**Square brackets `[]`** make a parameter optional with a default value.\n\n",
              "code": "void greet(String name, [String greeting = 'Hello']) {\n  print('$greeting, $name!');\n}\n\nvoid main() {\n  greet('Alice');              // Output: Hello, Alice!\n  greet('Bob', 'Hi');          // Output: Hi, Bob!\n  greet('Charlie', 'Hey');     // Output: Hey, Charlie!\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Named Parameters",
              "content": "\nNamed parameters make your code more readable:\n\n\n**Benefits**:\n- **Clear**: You can see what each value is for\n- **Flexible**: Order doesn't matter\n- **`required`**: Makes sure important parameters aren't forgotten\n\n",
              "code": "void createUser({required String name, required int age, String country = 'USA'}) {\n  print('Name: $name');\n  print('Age: $age');\n  print('Country: $country');\n}\n\nvoid main() {\n  createUser(name: 'Alice', age: 25);\n  createUser(name: 'Bob', age: 30, country: 'Canada');\n  createUser(age: 28, name: 'Charlie');  // Order doesn't matter!\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Arrow Functions (Shorthand)",
              "content": "\nFor simple, one-line functions:\n\n**Long way**:\n\n**Short way** (arrow function):\n\n**More examples**:\n\n\n",
              "code": "String shout(String text) => text.toUpperCase();\nbool isEven(int number) => number % 2 == 0;\nint square(int x) => x * x;\n\nvoid main() {\n  print(shout('hello'));    // Output: HELLO\n  print(isEven(4));         // Output: true\n  print(square(5));         // Output: 25\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Real-World Examples",
              "content": "\n### Temperature Converter\n\n\n### Discount Calculator\n\n\n### Password Validator\n\n\n",
              "code": "bool isPasswordStrong(String password) {\n  if (password.length < 8) {\n    return false;\n  }\n  if (!password.contains(RegExp(r'[0-9]'))) {\n    return false;  // Must have a number\n  }\n  return true;\n}\n\nvoid main() {\n  print(isPasswordStrong('weak'));          // Output: false\n  print(isPasswordStrong('strong123'));     // Output: true\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Function Scope - Variable Visibility",
              "content": "\nVariables inside a function can't be seen outside:\n\n\n**Global vs Local**:\n\n\n",
              "code": "var globalVar = 'I am global';\n\nvoid myFunction() {\n  var localVar = 'I am local';\n  print(globalVar);  // ‚úÖ Can access global\n  print(localVar);   // ‚úÖ Can access local\n}\n\nvoid main() {\n  print(globalVar);  // ‚úÖ Can access global\n  // print(localVar);  // ‚ùå Error: localVar only exists inside myFunction\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Beginner Mistakes",
              "content": "\n| Mistake | What Happens |\n|---------|--------------|\n| Forgetting `()` when calling | Function isn't called |\n| Wrong number of arguments | Error: Expected X arguments |\n| Wrong type of argument | Type error |\n| Forgetting `return` | Function returns null |\n| Returning from `void` function | Error: can't return value |\n| Calling function before defining it | Error: function not found |\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ Functions organize code into reusable pieces\n- ‚úÖ Parameters make functions flexible\n- ‚úÖ `return` sends values back\n- ‚úÖ Return type must match what you return\n- ‚úÖ Named parameters improve readability\n- ‚úÖ Arrow functions are shorthand for simple functions\n- ‚úÖ Variables inside functions are local (scoped)\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nNow we can:\n- Store data (variables)\n- Make decisions (if/else)\n- Repeat actions (loops)\n- Organize code (functions)\n\nBut what if we need to store **multiple related items**? Like a shopping list with many items?\n\nIn the next lesson, we'll learn about **Lists and Maps** - how to organize collections of data!\n\nSee you there! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.5-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a file called `calculator.dart`: ### Bonus Challenge 1: Make it Interactive Add a function that takes an operation name: ### Bonus Challenge 2: Add More Operations Add these functions: ---",
              "instructions": "Create a file called `calculator.dart`: ### Bonus Challenge 1: Make it Interactive Add a function that takes an operation name: ### Bonus Challenge 2: Add More Operations Add these functions: ---",
              "starterCode": "// TODO: Create these functions\n\nint add(int a, int b) {\n  // Your code here\n}\n\nint subtract(int a, int b) {\n  // Your code here\n}\n\nint multiply(int a, int b) {\n  // Your code here\n}\n\ndouble divide(int a, int b) {\n  // Your code here\n}\n\nvoid main() {\n  print('10 + 5 = ${add(10, 5)}');\n  print('10 - 5 = ${subtract(10, 5)}');\n  print('10 * 5 = ${multiply(10, 5)}');\n  print('10 / 5 = ${divide(10, 5)}');\n}",
              "solution": "10 + 5 = 15\n10 - 5 = 5\n10 * 5 = 50\n10 / 5 = 2.0",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Addition function returns correct result",
                  "expectedOutput": "10 + 5 = 15",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Subtraction function returns correct result",
                  "expectedOutput": "10 - 5 = 5",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Division function returns correct decimal result",
                  "expectedOutput": "10 / 5 = 2.0",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Define a function using the dart syntax. Don't forget the return statement if needed."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.6",
          "title": "Module 1, Lesson 6: Organizing Collections (Lists and Maps)",
          "moduleId": "module-01",
          "order": 6,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Shopping List Analogy",
              "content": "\nImagine you're going grocery shopping. You could create separate variables:\n\n\nBut that's clunky! What if you have 20 items? Or 100?\n\nInstead, you'd write a **list**:\n\n**Lists in programming work the same way** - they store multiple related items in one place.\n\n",
              "code": "Shopping List:\n1. Milk\n2. Bread\n3. Eggs\n4. Butter",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What is a List?",
              "content": "\n**Conceptual Explanation**:\nA List is like a numbered container with multiple compartments, each holding one item.\n\n\n**Note**: Lists start counting at **0**, not 1! This is called \"zero-indexing.\"\n\n",
              "code": "List of fruits:\n[0] Apple\n[1] Banana\n[2] Orange\n[3] Mango",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Creating Your First List",
              "content": "\n\n**The Parts**:\n- **`var fruits`** - Variable name for the list\n- **`[]`** - Square brackets indicate a list\n- **`'Apple', 'Banana', 'Orange'`** - Items separated by commas\n\n",
              "code": "void main() {\n  var fruits = ['Apple', 'Banana', 'Orange'];\n\n  print(fruits);  // Output: [Apple, Banana, Orange]\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Accessing List Items",
              "content": "\nUse the index (position number) to access items:\n\n\n**Remember**: The first item is at index 0!\n\n\n",
              "code": "Index:  0        1         2\nList:  [Apple | Banana | Orange]",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "List Length",
              "content": "\nHow many items are in a list?\n\n\n**Useful pattern**: The last item is always at index `length - 1`:\n\n\n",
              "code": "void main() {\n  var fruits = ['Apple', 'Banana', 'Orange'];\n\n  var lastIndex = fruits.length - 1;\n  print('Last fruit: ${fruits[lastIndex]}');  // Output: Orange\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Adding Items to a List",
              "content": "\n\n**`.add()`** adds an item to the **end** of the list.\n\n",
              "code": "void main() {\n  var fruits = ['Apple', 'Banana'];\n\n  print(fruits);  // Output: [Apple, Banana]\n\n  fruits.add('Orange');\n  print(fruits);  // Output: [Apple, Banana, Orange]\n\n  fruits.add('Mango');\n  print(fruits);  // Output: [Apple, Banana, Orange, Mango]\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Removing Items",
              "content": "\n\n**Two ways to remove**:\n- **`remove('value')`** - Remove specific item\n- **`removeAt(index)`** - Remove by position\n\n",
              "code": "void main() {\n  var fruits = ['Apple', 'Banana', 'Orange'];\n\n  fruits.remove('Banana');\n  print(fruits);  // Output: [Apple, Orange]\n\n  fruits.removeAt(0);  // Remove by index\n  print(fruits);  // Output: [Orange]\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Looping Through Lists",
              "content": "\n**This is super common!** You'll do this all the time in Flutter.\n\n### Method 1: For-each Loop\n\n\n**Output**:\n\n**Read as**: \"For each fruit in fruits, print...\"\n\n### Method 2: Traditional For Loop\n\n\n**Output**:\n\n",
              "code": "Fruit 1: Apple\nFruit 2: Banana\nFruit 3: Orange",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Different Types of Lists",
              "content": "\n### List of Numbers\n\n\n### List of Booleans\n\n\n### Mixed Type List (not recommended)\n\n\n**Best Practice**: Keep lists to one type.\n\n",
              "code": "var mixed = [1, 'hello', true, 3.14];  // Works, but confusing!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Typed Lists (Recommended)",
              "content": "\nBe explicit about what type of items your list holds:\n\n\n",
              "code": "void main() {\n  List<String> fruits = ['Apple', 'Banana'];\n  List<int> numbers = [1, 2, 3];\n  List<double> prices = [19.99, 24.50];\n\n  // fruits.add(123);  // ‚ùå Error: can't add int to List<String>\n  fruits.add('Orange');  // ‚úÖ Works!\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction to Maps",
              "content": "\n**Conceptual Explanation**:\nThink of a dictionary - you look up a **word** (key) to find its **meaning** (value).\n\nMaps work the same way: they store **key-value pairs**.\n\n**Real-world example**: A phone book\n- **Key**: Person's name\n- **Value**: Phone number\n\n\n",
              "code": "\"Alice\" ‚Üí \"555-1234\"\n\"Bob\"   ‚Üí \"555-5678\"\n\"Carol\" ‚Üí \"555-9012\"",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Creating Your First Map",
              "content": "\n\n**The Parts**:\n- **`{}`** - Curly braces indicate a Map\n- **`'Alice':`** - The key\n- **`'555-1234'`** - The value\n- **`,`** - Separates pairs\n\n",
              "code": "void main() {\n  var phoneBook = {\n    'Alice': '555-1234',\n    'Bob': '555-5678',\n    'Carol': '555-9012'\n  };\n\n  print(phoneBook);\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Accessing Map Values",
              "content": "\nUse square brackets with the key to retrieve its value. Maps provide fast lookup - finding a value by its key is nearly instant, even in large Maps.\n\n**Note:** If the key doesn't exist, you'll get `null`. Use `containsKey()` to check first, or provide a default with `??`.\n\n\n",
              "code": "void main() {\n  var phoneBook = {\n    'Alice': '555-1234',\n    'Bob': '555-5678',\n  };\n\n  print(phoneBook['Alice']);  // Output: 555-1234\n  print(phoneBook['Bob']);    // Output: 555-5678\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Looping Through Maps",
              "content": "\nYou can iterate through Maps using `entries`, `keys`, or `values`. The `entries` property gives you both the key and value together in each iteration - this is the most common approach.\n\n**Using entries (recommended):** Each entry has `.key` and `.value` properties.\n\n**Output**: `Alice scored 95` and `Bob scored 87`\n\n\n",
              "code": "void main() {\n  var scores = {'Alice': 95, 'Bob': 87};\n\n  for (var entry in scores.entries) {\n    print('${entry.key} scored ${entry.value}');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Typed Maps (Recommended)",
              "content": "\n\n**`Map<KeyType, ValueType>`** specifies both types.\n\n",
              "code": "void main() {\n  Map<String, int> ages = {\n    'Alice': 25,\n    'Bob': 30\n  };\n\n  Map<String, double> prices = {\n    'Apple': 1.99,\n    'Banana': 0.59\n  };\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Real-World Examples",
              "content": "\n### User Profile\n\n\n### Product Inventory\n\n\n### Shopping Cart\n\n\n",
              "code": "void main() {\n  List<Map<String, dynamic>> cart = [\n    {'name': 'Laptop', 'price': 999.99, 'quantity': 1},\n    {'name': 'Mouse', 'price': 29.99, 'quantity': 2},\n  ];\n\n  var total = 0.0;\n  for (var item in cart) {\n    total += item['price'] * item['quantity'];\n  }\n\n  print('Total: \\$$total');  // Output: Total: $1059.97\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ Lists store multiple items in order\n- ‚úÖ Lists use zero-based indexing [0, 1, 2...]\n- ‚úÖ Use `add()`, `remove()`, `length` with Lists\n- ‚úÖ Maps store key-value pairs\n- ‚úÖ Use keys to access values: `map[key]`\n- ‚úÖ Loop through both Lists and Maps\n- ‚úÖ Type your collections: `List<String>`, `Map<String, int>`\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've now learned all the **fundamental building blocks** of programming:\n- ‚úÖ Variables (storing data)\n- ‚úÖ Conditionals (making decisions)\n- ‚úÖ Loops (repeating actions)\n- ‚úÖ Functions (organizing code)\n- ‚úÖ Lists and Maps (managing collections)\n\nIn the next lessons, we'll do a **mini-project** to put it all together, and then we'll move into **Flutter** and start building actual user interfaces!\n\nGet ready to build something cool! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.6-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a file called `contacts.dart`: --- ## Bonus Challenge: Grade Calculator Create a program that: 1. Stores student names and grades in a Map 2. Calculates the average grade 3. Finds the highest and lowest grades 4. Prints a report ---",
              "instructions": "Create a file called `contacts.dart`: --- ## Bonus Challenge: Grade Calculator Create a program that: 1. Stores student names and grades in a Map 2. Calculates the average grade 3. Finds the highest and lowest grades 4. Prints a report ---",
              "starterCode": "void main() {\n  // TODO: Create a list of contact maps\n  List<Map<String, String>> contacts = [];\n\n  // TODO: Add 3 contacts (each should have name, phone, email)\n\n  // TODO: Print all contacts in a nice format\n\n  // TODO: Find and print a specific contact by name\n\n  // TODO: Remove one contact\n\n  // TODO: Print remaining contacts\n}",
              "solution": "=== All Contacts ===\nName: Alice\nPhone: 555-1234\nEmail: alice@email.com\n\nName: Bob\nPhone: 555-5678\nEmail: bob@email.com\n\n=== Finding Alice ===\nFound: Alice, 555-1234\n\n=== After removing Bob ===\nRemaining contacts: 1",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Displays contacts header",
                  "expectedOutput": "=== All Contacts ===",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Finds specific contact by name",
                  "expectedOutput": "Found: Alice, 555-1234",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Shows remaining contacts count after removal",
                  "expectedOutput": "Remaining contacts: 1",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print() function to display output."
                },
                {
                  "level": 1,
                  "text": "Create a variable to store your value. In dart, use appropriate syntax."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.7",
          "title": "Module 1, Lesson 7: Mini-Project - Number Guessing Game",
          "moduleId": "module-01",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Putting It All Together",
              "content": "\nCongratulations on making it this far! You've learned all the Dart fundamentals:\n- ‚úÖ Variables\n- ‚úÖ Conditionals (if/else)\n- ‚úÖ Loops\n- ‚úÖ Functions\n- ‚úÖ Lists and Maps\n\nNow it's time to **combine everything** into a real project!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What We're Building",
              "content": "\nA **Number Guessing Game** that:\n- Picks a random number between 1 and 100\n- Lets the player guess the number\n- Gives hints (\"too high\" or \"too low\")\n- Tracks the number of guesses\n- Allows playing multiple rounds\n\n**Skills you'll practice**:\n- Using variables to track game state\n- Using conditionals to check guesses\n- Using loops for multiple attempts\n- Using functions to organize code\n- Using lists to track guess history\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Structure",
              "content": "\nWe'll build this in steps:\n\n1. **Version 1**: Basic game with hardcoded number\n2. **Version 2**: Add random number generation\n3. **Version 3**: Add attempt counter and guess history\n4. **Version 4**: Add multi-round support\n5. **Version 5**: Add difficulty levels\n\n"
            },
            {
              "type": "THEORY",
              "title": "Version 1: The Foundation",
              "content": "\nLet's start simple - player tries to guess a specific number.\n\nCreate a file called `guessing_game.dart`:\n\n\n**Run it!** You should see:\n\n\n**What's happening**:\n- We have a secret number (42)\n- We loop through guesses\n- For each guess, we give feedback\n- When correct, we celebrate and exit\n\n",
              "code": "=== Number Guessing Game ===\nI'm thinking of a number between 1 and 100...\n\nYou guessed: 50\nüìâ Too high! Try again.\n\nYou guessed: 30\nüìà Too low! Try again.\n\nYou guessed: 40\nüìà Too low! Try again.\n\nYou guessed: 42\nüéâ Correct! You win!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Version 2: Adding Random Numbers",
              "content": "\nInstead of always guessing 42, let's make it random!\n\n**First, import the Random library** at the top of your file:\n\n\n**Understanding `random.nextInt(100) + 1`**:\n- `random.nextInt(100)` gives 0-99\n- `+ 1` shifts it to 1-100\n\n**Try running it multiple times** - you'll get different numbers!\n\n",
              "code": "import 'dart:math';\n\nvoid main() {\n  // Generate random number between 1 and 100\n  var random = Random();\n  var secretNumber = random.nextInt(100) + 1;\n\n  print('=== Number Guessing Game ===');\n  print('I\\'m thinking of a number between 1 and 100...');\n  print('(Psst... it\\'s $secretNumber - but pretend you don\\'t know!)');\n\n  // Rest of code...\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Version 3: Tracking Attempts and History",
              "content": "\nLet's count how many guesses it takes and remember all guesses:\n\n\n**New features**:\n- `attemptCount` tracks number of tries\n- `guessHistory` remembers all guesses\n- We show a summary at the end\n\n",
              "code": "import 'dart:math';\n\nvoid main() {\n  var random = Random();\n  var secretNumber = random.nextInt(100) + 1;\n  var guesses = [50, 30, 40, 45, 42];  // Simulated guesses\n  var attemptCount = 0;\n  List<int> guessHistory = [];\n\n  print('=== Number Guessing Game ===');\n  print('I\\'m thinking of a number between 1 and 100...');\n\n  for (var guess in guesses) {\n    attemptCount++;\n    guessHistory.add(guess);\n\n    print('\\n--- Attempt $attemptCount ---');\n    print('You guessed: $guess');\n\n    if (guess == secretNumber) {\n      print('üéâ Correct! You win!');\n      print('It took you $attemptCount attempts.');\n      print('Your guesses: $guessHistory');\n      break;\n    } else if (guess > secretNumber) {\n      print('üìâ Too high! Try again.');\n    } else {\n      print('üìà Too low! Try again.');\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Version 4: Organizing with Functions",
              "content": "\nOur code is getting messy. Let's use functions to organize it:\n\n\n**Much better!** Each function has one job:\n- `generateSecretNumber()` - creates random number\n- `checkGuess()` - compares guess to secret\n- `printHeader()` - shows game title\n- `printSummary()` - shows final stats\n\n",
              "code": "import 'dart:math';\n\n// Function to generate random number\nint generateSecretNumber() {\n  var random = Random();\n  return random.nextInt(100) + 1;\n}\n\n// Function to check a guess\nString checkGuess(int guess, int secret) {\n  if (guess == secret) {\n    return 'correct';\n  } else if (guess > secret) {\n    return 'high';\n  } else {\n    return 'low';\n  }\n}\n\n// Function to print game header\nvoid printHeader() {\n  print('=== Number Guessing Game ===');\n  print('I\\'m thinking of a number between 1 and 100...\\n');\n}\n\n// Function to print game summary\nvoid printSummary(int attempts, List<int> history) {\n  print('\\nüéâ You win!');\n  print('It took you $attempts attempts.');\n  print('Your guesses: $history');\n}\n\nvoid main() {\n  var secretNumber = generateSecretNumber();\n  var guesses = [50, 30, 70, 60, 55, 52, 51];  // Simulated\n  var attemptCount = 0;\n  List<int> guessHistory = [];\n\n  printHeader();\n\n  for (var guess in guesses) {\n    attemptCount++;\n    guessHistory.add(guess);\n\n    print('Attempt $attemptCount: You guessed $guess');\n\n    var result = checkGuess(guess, secretNumber);\n\n    if (result == 'correct') {\n      printSummary(attemptCount, guessHistory);\n      break;\n    } else if (result == 'high') {\n      print('üìâ Too high! Try again.\\n');\n    } else {\n      print('üìà Too low! Try again.\\n');\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Version 5: Adding Difficulty Levels",
              "content": "\nLet's add difficulty levels with different ranges:\n\n\n",
              "code": "import 'dart:math';\n\nint generateSecretNumber(String difficulty) {\n  var random = Random();\n\n  if (difficulty == 'easy') {\n    return random.nextInt(50) + 1;  // 1-50\n  } else if (difficulty == 'medium') {\n    return random.nextInt(100) + 1;  // 1-100\n  } else {  // hard\n    return random.nextInt(500) + 1;  // 1-500\n  }\n}\n\nvoid printHeader(String difficulty) {\n  print('=== Number Guessing Game ===');\n  print('Difficulty: ${difficulty.toUpperCase()}');\n\n  if (difficulty == 'easy') {\n    print('I\\'m thinking of a number between 1 and 50...\\n');\n  } else if (difficulty == 'medium') {\n    print('I\\'m thinking of a number between 1 and 100...\\n');\n  } else {\n    print('I\\'m thinking of a number between 1 and 500...\\n');\n  }\n}\n\nvoid main() {\n  var difficulty = 'easy';  // Try: 'easy', 'medium', 'hard'\n  var secretNumber = generateSecretNumber(difficulty);\n\n  printHeader(difficulty);\n\n  // Rest of game logic...\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Full Game with All Features",
              "content": "\nHere's the complete, polished version:\n\n\n",
              "code": "import 'dart:math';\n\n// ========== GAME CONFIGURATION ==========\n\nclass GameConfig {\n  static const Map<String, int> ranges = {\n    'easy': 50,\n    'medium': 100,\n    'hard': 500,\n  };\n\n  static const Map<String, int> maxAttempts = {\n    'easy': 10,\n    'medium': 7,\n    'hard': 12,\n  };\n}\n\n// ========== GAME FUNCTIONS ==========\n\nint generateSecretNumber(String difficulty) {\n  var random = Random();\n  var range = GameConfig.ranges[difficulty] ?? 100;\n  return random.nextInt(range) + 1;\n}\n\nvoid printHeader(String difficulty) {\n  print('\\n' + '=' * 40);\n  print('   NUMBER GUESSING GAME');\n  print('=' * 40);\n  print('Difficulty: ${difficulty.toUpperCase()}');\n  var range = GameConfig.ranges[difficulty] ?? 100;\n  print('Guess a number between 1 and $range');\n  var maxAttempts = GameConfig.maxAttempts[difficulty] ?? 7;\n  print('You have $maxAttempts attempts. Good luck!\\n');\n}\n\nString checkGuess(int guess, int secret) {\n  if (guess == secret) return 'correct';\n  if (guess > secret) return 'high';\n  return 'low';\n}\n\nvoid printAttempt(int attemptNum, int guess, String result) {\n  print('--- Attempt $attemptNum ---');\n  print('You guessed: $guess');\n\n  if (result == 'correct') {\n    print('üéâ CORRECT! You found it!');\n  } else if (result == 'high') {\n    var diff = guess - (guess * 0.1).toInt();  // Give a hint\n    print('üìâ Too high! Try something lower...');\n  } else {\n    print('üìà Too low! Try something higher...');\n  }\n  print('');\n}\n\nvoid printWinSummary(int attempts, List<int> history, String difficulty) {\n  print('=' * 40);\n  print('   üéä VICTORY! üéä');\n  print('=' * 40);\n  print('Difficulty: ${difficulty.toUpperCase()}');\n  print('Attempts used: $attempts');\n  print('Your guessing strategy: $history');\n\n  if (attempts <= 3) {\n    print('Rating: ‚≠ê‚≠ê‚≠ê Amazing! Lucky or skilled?');\n  } else if (attempts <= 5) {\n    print('Rating: ‚≠ê‚≠ê Great job!');\n  } else {\n    print('Rating: ‚≠ê You made it!');\n  }\n  print('=' * 40 + '\\n');\n}\n\nvoid printLossSummary(int secret, List<int> history) {\n  print('=' * 40);\n  print('   üò¢ GAME OVER');\n  print('=' * 40);\n  print('The number was: $secret');\n  print('Your guesses: $history');\n  print('Better luck next time!');\n  print('=' * 40 + '\\n');\n}\n\n// ========== MAIN GAME LOGIC ==========\n\nvoid playGame(String difficulty) {\n  var secretNumber = generateSecretNumber(difficulty);\n  var maxAttempts = GameConfig.maxAttempts[difficulty] ?? 7;\n  var attemptCount = 0;\n  List<int> guessHistory = [];\n\n  printHeader(difficulty);\n\n  // Simulate guesses (in real game, this would be user input)\n  var simulatedGuesses = [50, 25, 37, 31, 28, 29, 30];\n\n  for (var guess in simulatedGuesses) {\n    if (attemptCount >= maxAttempts) {\n      printLossSummary(secretNumber, guessHistory);\n      return;\n    }\n\n    attemptCount++;\n    guessHistory.add(guess);\n\n    var result = checkGuess(guess, secretNumber);\n    printAttempt(attemptCount, guess, result);\n\n    if (result == 'correct') {\n      printWinSummary(attemptCount, guessHistory, difficulty);\n      return;\n    }\n  }\n\n  // If loop ends without finding number\n  printLossSummary(secretNumber, guessHistory);\n}\n\nvoid main() {\n  print('\\nüéÆ Welcome to the Number Guessing Game! üéÆ\\n');\n\n  // Play different difficulties\n  playGame('easy');\n  playGame('medium');\n  playGame('hard');\n\n  print('Thanks for playing! üëã');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What You've Accomplished",
              "content": "\nLook at what you just built:\n- ‚úÖ A complete, working game\n- ‚úÖ Multiple functions for organization\n- ‚úÖ Variables tracking state\n- ‚úÖ Conditionals for game logic\n- ‚úÖ Loops for gameplay\n- ‚úÖ Lists storing history\n- ‚úÖ Maps for configuration\n\n**You're not a beginner anymore!** You can write real programs!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap this module:\n- ‚úÖ How to structure a complete program\n- ‚úÖ Breaking problems into functions\n- ‚úÖ Combining all Dart fundamentals\n- ‚úÖ Simulating game logic\n- ‚úÖ Organizing code for readability\n- ‚úÖ Using constants and configuration\n- ‚úÖ Providing good user feedback\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\n**Module 1 Complete!** üéâ\n\nYou now have a solid foundation in Dart programming. You can:\n- Store and manipulate data\n- Make decisions\n- Create loops\n- Write functions\n- Manage collections\n- Build complete programs\n\nIn **Module 2**, we'll take these skills and start building **actual Flutter apps** with visual interfaces!\n\nYou'll learn:\n- How Flutter apps are structured\n- What widgets are and how to use them\n- How to display text, images, and buttons\n- How to arrange elements on screen\n\nGet ready to see your code come to life on screen! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.7-challenge-0",
              "title": "Practice Challenge",
              "description": "After each guess, show the narrowed range: ---",
              "instructions": "After each guess, show the narrowed range: ---",
              "starterCode": "// Number Guessing Game - Range Tracker\n// TODO: Track and display the valid range after each guess\n\nimport 'dart:math';\n\nvoid main() {\n  final random = Random();\n  final secretNumber = random.nextInt(100) + 1;  // 1-100\n  \n  // TODO: Add variables to track the current valid range\n  // var lowBound = 1;\n  // var highBound = 100;\n  \n  // Simulate a guess\n  var guess = 50;\n  print('You guessed: $guess');\n  \n  // TODO: Check if guess is too high or too low\n  // TODO: Update the range bounds\n  // TODO: Print the narrowed range\n}",
              "solution": "// Solution: Number Guessing Game - Range Tracker\n\nimport 'dart:math';\n\nvoid main() {\n  final random = Random();\n  final secretNumber = random.nextInt(100) + 1;  // 1-100\n  \n  // Track the valid range\n  var lowBound = 1;\n  var highBound = 100;\n  \n  // Simulate guesses\n  void makeGuess(int guess) {\n    print('You guessed: $guess');\n    \n    if (guess > secretNumber) {\n      highBound = guess - 1;  // Number must be lower\n      print('Too high! The number is between $lowBound and $highBound');\n    } else if (guess < secretNumber) {\n      lowBound = guess + 1;  // Number must be higher\n      print('Too low! The number is between $lowBound and $highBound');\n    } else {\n      print('Correct! The number was $secretNumber');\n    }\n  }\n  \n  // Test with some guesses\n  makeGuess(50);\n  makeGuess(25);\n  makeGuess(37);\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Game shows narrowed range after high guess",
                  "expectedOutput": "Too high! The number is between 1 and 49",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Game displays guess value",
                  "expectedOutput": "You guessed: 50",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Game narrows range after low guess",
                  "expectedOutput": "Too low! The number is between 26 and 100",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "1.8",
          "title": "Module 1, Lesson 8: Dart 3 Modern Features",
          "moduleId": "module-01",
          "order": 8,
          "estimatedMinutes": 75,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Welcome to Modern Dart!",
              "content": "\nDart 3 (released in 2023) introduced powerful new features that make your code cleaner, safer, and more expressive. In this lesson, you'll learn three game-changing features:\n\n- **Records**: Group multiple values together without creating a class\n- **Pattern Matching**: Destructure data and match complex conditions elegantly\n- **Sealed Classes**: Create type-safe hierarchies with exhaustive switching\n\nThese features work together to make Dart feel more modern and reduce boilerplate code.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Records - Lightweight Data Grouping",
              "content": "\n### What Are Records?\n\n**Conceptual First:**\nImagine you want to return two values from a function - like a person's name AND their age. Before Dart 3, you had to either:\n- Create a whole class just for two values (overkill!)\n- Use a List or Map (loses type safety)\n- Return multiple values awkwardly\n\n**Records** solve this elegantly! They're like lightweight, immutable containers for multiple values.\n\n**Jargon:**\n- **Record**: A fixed-size, immutable collection of values\n- **Positional fields**: Fields accessed by position ($1, $2, etc.)\n- **Named fields**: Fields accessed by name\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Anonymous Records (Positional Fields)",
              "content": "Anonymous records group multiple values in parentheses. Access fields using $1, $2, etc. (1-indexed). Records are immutable - once created, values cannot be changed.",
              "code": "void main() {\n  // Create a record with two values\n  (String, int) person = ('Alice', 30);\n  \n  // Access by position (1-indexed with $ prefix)\n  print('Name: ${person.$1}');  // Alice\n  print('Age: ${person.$2}');   // 30\n  \n  // Records with more values\n  (String, String, int, bool) employee = ('Bob', 'Engineering', 5, true);\n  print('${employee.$1} works in ${employee.$2}');\n  print('Years: ${employee.$3}, Active: ${employee.$4}');\n  \n  // Records are immutable - this won't compile:\n  // person.$1 = 'Charlie';  // Error!\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Named Records (Named Fields)",
              "content": "Named records use field names instead of positions for clarity. Access fields by name (person.name) rather than index. You can mix positional and named fields in the same record.",
              "code": "void main() {\n  // Named fields for clarity\n  ({String name, int age}) person = (name: 'Alice', age: 30);\n  \n  // Access by name - much more readable!\n  print('Name: ${person.name}');\n  print('Age: ${person.age}');\n  \n  // Mix positional and named fields\n  (String, {int age, String city}) profile = (\n    'Charlie',\n    age: 25,\n    city: 'New York',\n  );\n  \n  print('${profile.$1} is ${profile.age} years old');\n  print('Lives in ${profile.city}');\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Records as Function Return Types",
              "content": "Records elegantly solve the multiple-return-value problem. Declare the record type as the return type, then return values in parentheses. Named fields make the API self-documenting.",
              "code": "// Return multiple values elegantly!\n(String, int) getUserInfo() {\n  // Imagine fetching from database\n  return ('Alice', 30);\n}\n\n// Named fields version - even clearer\n({String name, int age, String email}) fetchUser() {\n  return (\n    name: 'Bob',\n    age: 25,\n    email: 'bob@example.com',\n  );\n}\n\n// Return success/error with data\n(bool success, String? data, String? error) fetchData() {\n  try {\n    // Simulate API call\n    return (true, 'Data loaded!', null);\n  } catch (e) {\n    return (false, null, e.toString());\n  }\n}\n\nvoid main() {\n  // Using positional record\n  var info = getUserInfo();\n  print('${info.$1} is ${info.$2} years old');\n  \n  // Using named record\n  var user = fetchUser();\n  print('${user.name}: ${user.email}');\n  \n  // Handling result record\n  var result = fetchData();\n  if (result.$1) {\n    print('Success: ${result.$2}');\n  } else {\n    print('Error: ${result.$3}');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Pattern Matching - Destructuring Made Easy",
              "content": "\n### What Is Pattern Matching?\n\n**Conceptual First:**\nImagine opening a gift box. Instead of saying \"get the box, then look inside, then check what's there,\" you just say \"if it's a book, read it; if it's a toy, play with it.\"\n\n**Pattern matching** lets you inspect data structure and extract values in one elegant step. It's like X-ray vision for your data!\n\n**Jargon:**\n- **Destructuring**: Breaking apart a data structure into its components\n- **Pattern**: A template that data is matched against\n- **Guard clause**: An additional condition with `when`\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Destructuring Records",
              "content": "Destructuring extracts record values into individual variables in one step. Use var (a, b) for positional records, or var (:name, :age) shorthand for named records. The underscore (_) ignores unwanted values.",
              "code": "void main() {\n  // Create a record\n  var person = ('Alice', 30);\n  \n  // Destructure into variables - no more $1, $2!\n  var (name, age) = person;\n  print('Name: $name, Age: $age');\n  \n  // Named record destructuring\n  var user = (name: 'Bob', age: 25, city: 'NYC');\n  var (:name, :age, :city) = user;  // Shorthand!\n  print('$name ($age) from $city');\n  \n  // Swap values elegantly\n  var a = 1;\n  var b = 2;\n  (a, b) = (b, a);  // Swap!\n  print('a: $a, b: $b');  // a: 2, b: 1\n  \n  // Ignore values with _\n  var data = ('important', 'skip this', 42);\n  var (important, _, number) = data;\n  print('$important: $number');\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Destructuring Lists and Maps",
              "content": "Pattern matching works on lists and maps too. Use [...rest] to capture remaining elements, [...] to skip middle elements, and {'key': variable} for maps. Patterns can be nested for complex structures.",
              "code": "void main() {\n  // List destructuring\n  var numbers = [1, 2, 3, 4, 5];\n  var [first, second, ...rest] = numbers;\n  print('First: $first');       // 1\n  print('Second: $second');     // 2\n  print('Rest: $rest');         // [3, 4, 5]\n  \n  // Get first and last\n  var [head, ..., tail] = numbers;\n  print('Head: $head, Tail: $tail');  // 1, 5\n  \n  // Map destructuring\n  var person = {'name': 'Alice', 'age': 30};\n  var {'name': userName, 'age': userAge} = person;\n  print('$userName is $userAge');\n  \n  // Nested destructuring\n  var nested = [1, [2, 3], 4];\n  var [a, [b, c], d] = nested;\n  print('$a, $b, $c, $d');  // 1, 2, 3, 4\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Switch with Patterns",
              "content": "Dart 3 switch expressions combine type checking, value extraction, and conditional logic. Use 'when' for guard clauses. Patterns match types, extract values, and bind them to variables in one concise expression.",
              "code": "String describeValue(Object value) {\n  return switch (value) {\n    // Match specific values\n    0 => 'zero',\n    1 => 'one',\n    \n    // Match types with binding\n    int n when n < 0 => 'negative integer: $n',\n    int n when n > 100 => 'large integer: $n',\n    int n => 'integer: $n',\n    \n    // Match strings\n    String s when s.isEmpty => 'empty string',\n    String s when s.length > 10 => 'long string',\n    String s => 'string: $s',\n    \n    // Match lists\n    [] => 'empty list',\n    [var single] => 'single element: $single',\n    [var first, ...var rest] => 'list starting with $first',\n    \n    // Match records\n    (int x, int y) => 'point at ($x, $y)',\n    \n    // Catch-all\n    _ => 'something else: $value',\n  };\n}\n\nvoid main() {\n  print(describeValue(0));           // zero\n  print(describeValue(-5));          // negative integer: -5\n  print(describeValue(150));         // large integer: 150\n  print(describeValue('hello'));     // string: hello\n  print(describeValue([]));          // empty list\n  print(describeValue([1, 2, 3]));   // list starting with 1\n  print(describeValue((10, 20)));    // point at (10, 20)\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "If-Case Pattern Matching",
              "content": "If-case statements combine pattern matching with conditional execution. The pattern must match AND the optional 'when' guard must be true for the block to execute. Great for handling specific data shapes.",
              "code": "void processData(Object data) {\n  // If-case for conditional pattern matching\n  if (data case int n when n > 0) {\n    print('Positive integer: $n');\n  }\n  \n  if (data case String s when s.startsWith('Hello')) {\n    print('Greeting: $s');\n  }\n  \n  // Match and extract from records\n  if (data case (String name, int age) when age >= 18) {\n    print('$name is an adult');\n  }\n  \n  // Match list patterns\n  if (data case [var first, _, var last]) {\n    print('Three elements: first=$first, last=$last');\n  }\n}\n\nvoid main() {\n  processData(42);                    // Positive integer: 42\n  processData('Hello, World!');       // Greeting: Hello, World!\n  processData(('Alice', 25));         // Alice is an adult\n  processData([1, 2, 3]);             // Three elements: first=1, last=3\n  processData(-5);                    // (no output - doesn't match)\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 3: Sealed Classes - Exhaustive Type Hierarchies",
              "content": "\n### What Are Sealed Classes?\n\n**Conceptual First:**\nImagine a traffic light. It can ONLY be red, yellow, or green - nothing else. If you handle all three cases, you've covered everything possible.\n\n**Sealed classes** let you define a closed set of types. The compiler then ensures you handle ALL cases - no more forgotten edge cases!\n\n**Jargon:**\n- **Sealed class**: A class that can only be extended within the same file\n- **Exhaustive switch**: A switch that handles all possible subtypes\n- **Algebraic data types (ADTs)**: Types representing one of several possible variants\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Sealed Class Basics",
              "content": "Sealed classes define a closed set of subtypes that can only be extended in the same file. The compiler knows all possible subtypes, enabling exhaustive switch statements without a default case.",
              "code": "// Define a sealed class hierarchy\nsealed class Shape {}\n\nclass Circle extends Shape {\n  final double radius;\n  Circle(this.radius);\n}\n\nclass Rectangle extends Shape {\n  final double width;\n  final double height;\n  Rectangle(this.width, this.height);\n}\n\nclass Triangle extends Shape {\n  final double base;\n  final double height;\n  Triangle(this.base, this.height);\n}\n\n// The compiler KNOWS all possible shapes!\ndouble calculateArea(Shape shape) {\n  // Exhaustive switch - compiler ensures all cases covered\n  return switch (shape) {\n    Circle(radius: var r) => 3.14159 * r * r,\n    Rectangle(width: var w, height: var h) => w * h,\n    Triangle(base: var b, height: var h) => 0.5 * b * h,\n    // No default needed - all cases covered!\n  };\n}\n\nvoid main() {\n  var shapes = [\n    Circle(5),\n    Rectangle(4, 6),\n    Triangle(3, 4),\n  ];\n  \n  for (var shape in shapes) {\n    print('Area: ${calculateArea(shape).toStringAsFixed(2)}');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Sealed Classes for State Management",
              "content": "Sealed classes are perfect for UI state management. Define all possible states (loading, success, error) as subclasses. The compiler ensures every state is handled, preventing forgotten edge cases in your UI.",
              "code": "// Perfect for representing UI states!\nsealed class AuthState {}\n\nclass AuthInitial extends AuthState {}\n\nclass AuthLoading extends AuthState {}\n\nclass AuthSuccess extends AuthState {\n  final String userName;\n  final String token;\n  AuthSuccess({required this.userName, required this.token});\n}\n\nclass AuthError extends AuthState {\n  final String message;\n  AuthError(this.message);\n}\n\n// Build UI based on state - compiler checks all cases!\nString buildUI(AuthState state) {\n  return switch (state) {\n    AuthInitial() => 'Welcome! Please log in.',\n    AuthLoading() => 'Loading... Please wait.',\n    AuthSuccess(userName: var name) => 'Welcome back, $name!',\n    AuthError(message: var msg) => 'Error: $msg',\n  };\n}\n\nvoid main() {\n  var states = [\n    AuthInitial(),\n    AuthLoading(),\n    AuthSuccess(userName: 'Alice', token: 'abc123'),\n    AuthError('Invalid password'),\n  ];\n  \n  for (var state in states) {\n    print(buildUI(state));\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Sealed Classes for API Results",
              "content": "Model API responses with sealed classes for type-safe result handling. Generic type parameters let you reuse the pattern across different data types. Exhaustive switches ensure all outcomes are handled.",
              "code": "// Model API responses safely\nsealed class ApiResult<T> {}\n\nclass ApiSuccess<T> extends ApiResult<T> {\n  final T data;\n  ApiSuccess(this.data);\n}\n\nclass ApiError<T> extends ApiResult<T> {\n  final int statusCode;\n  final String message;\n  ApiError(this.statusCode, this.message);\n}\n\nclass ApiLoading<T> extends ApiResult<T> {}\n\n// Simulate API call\nApiResult<List<String>> fetchUsers() {\n  // Simulate different outcomes\n  var random = DateTime.now().second % 3;\n  \n  return switch (random) {\n    0 => ApiSuccess(['Alice', 'Bob', 'Charlie']),\n    1 => ApiError(404, 'Users not found'),\n    _ => ApiLoading(),\n  };\n}\n\n// Handle all cases exhaustively\nvoid displayResult(ApiResult<List<String>> result) {\n  switch (result) {\n    case ApiSuccess(data: var users):\n      print('Found ${users.length} users:');\n      for (var user in users) {\n        print('  - $user');\n      }\n    case ApiError(statusCode: var code, message: var msg):\n      print('Error $code: $msg');\n    case ApiLoading():\n      print('Loading...');\n  }\n}\n\nvoid main() {\n  var result = fetchUsers();\n  displayResult(result);\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Combining All Three Features",
              "content": "Records, pattern matching, and sealed classes work beautifully together. Use sealed classes for operation types, records for results, and pattern matching for exhaustive handling with guard clauses.",
              "code": "import 'dart:math';\n\n// Sealed class for operations\nsealed class MathOperation {}\n\nclass Add extends MathOperation {\n  final num a, b;\n  Add(this.a, this.b);\n}\n\nclass Subtract extends MathOperation {\n  final num a, b;\n  Subtract(this.a, this.b);\n}\n\nclass Multiply extends MathOperation {\n  final num a, b;\n  Multiply(this.a, this.b);\n}\n\nclass Divide extends MathOperation {\n  final num a, b;\n  Divide(this.a, this.b);\n}\n\n// Record for results\ntypedef CalcResult = ({num result, String description});\n\n// Pattern matching with sealed classes\nCalcResult calculate(MathOperation op) {\n  return switch (op) {\n    Add(a: var x, b: var y) => (\n      result: x + y,\n      description: '$x + $y',\n    ),\n    Subtract(a: var x, b: var y) => (\n      result: x - y,\n      description: '$x - $y',\n    ),\n    Multiply(a: var x, b: var y) => (\n      result: x * y,\n      description: '$x * $y',\n    ),\n    Divide(a: var x, b: var y) when y != 0 => (\n      result: x / y,\n      description: '$x / $y',\n    ),\n    Divide(a: var x, b: _) => (\n      result: double.nan,\n      description: '$x / 0 (undefined)',\n    ),\n  };\n}\n\nvoid main() {\n  var operations = [\n    Add(10, 5),\n    Subtract(10, 3),\n    Multiply(4, 7),\n    Divide(20, 4),\n    Divide(10, 0),  // Edge case!\n  ];\n  \n  for (var op in operations) {\n    // Destructure the result record\n    var (:result, :description) = calculate(op);\n    print('$description = $result');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "When to Use Each Feature",
              "content": "\n### Records\n- **Use when**: Returning multiple values from functions\n- **Use when**: Grouping related data without creating a class\n- **Use when**: Creating lightweight, immutable data structures\n\n### Pattern Matching\n- **Use when**: Extracting values from complex data structures\n- **Use when**: Replacing verbose if-else chains\n- **Use when**: Type-checking and casting in one step\n\n### Sealed Classes\n- **Use when**: Modeling a fixed set of states (UI state, API results)\n- **Use when**: You want exhaustive switch checking\n- **Use when**: Creating type-safe state machines\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n### Question 1\nWhat is the correct way to access the second field of an anonymous record?\n\nA) `record[1]`\nB) `record.$2`\nC) `record.second`\nD) `record[2]`\n\n### Question 2\nWhat does the `when` keyword do in pattern matching?\n\nA) Creates a new variable\nB) Adds a guard condition to the pattern\nC) Matches any value\nD) Defines a default case\n\n### Question 3\nWhat makes sealed classes special?\n\nA) They can be extended from anywhere\nB) They enable exhaustive switch statements\nC) They are always abstract\nD) They cannot have constructors\n\n### Question 4\nHow do you destructure a named record `(name: 'Alice', age: 30)`?\n\nA) `var (name, age) = record;`\nB) `var {name, age} = record;`\nC) `var (:name, :age) = record;`\nD) `var [name, age] = record;`\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Question 1: B** - Anonymous record fields are accessed with `$1`, `$2`, etc. (1-indexed with $ prefix).\n\n**Question 2: B** - The `when` keyword adds a guard condition that must be true for the pattern to match.\n\n**Question 3: B** - Sealed classes can only be extended in the same library, enabling the compiler to ensure switch statements handle all cases.\n\n**Question 4: C** - Named record fields are destructured with `:name` syntax, which creates a variable with the same name as the field.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nIn this lesson, you learned Dart 3's modern features:\n\n**Records:**\n- Create lightweight, immutable data groupings\n- Access positional fields with `$1`, `$2`\n- Access named fields by name\n- Perfect for returning multiple values from functions\n\n**Pattern Matching:**\n- Destructure records, lists, and maps elegantly\n- Use `switch` expressions with pattern cases\n- Add guard clauses with `when`\n- Use `if-case` for conditional matching\n\n**Sealed Classes:**\n- Define closed type hierarchies\n- Enable exhaustive switch statements\n- Perfect for state management\n- Compiler catches missing cases\n\nThese features work together to make your Dart code cleaner, safer, and more expressive!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nCongratulations on completing **Module 1**! You now have a comprehensive understanding of modern Dart programming, including:\n\n- Variables and data types\n- Control flow (if/else, loops)\n- Functions\n- Collections (Lists, Maps)\n- Mini-project experience\n- **Dart 3 modern features**\n\nIn **Module 2**, you'll apply all this knowledge to build actual Flutter apps with visual user interfaces!\n\nYou're ready to create beautiful, modern Flutter applications!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "1.8-challenge-0",
              "title": "Records Practice",
              "description": "Create a function that returns a person's full details as a named record and destructure it.",
              "instructions": "1. Create a function `getPersonDetails()` that returns a named record with name, age, and email fields\n2. Call the function and destructure the result\n3. Print each field on a separate line",
              "starterCode": "// Dart 3 Records Practice\n// Create a function that returns a named record\n\nvoid main() {\n  // TODO: Call getPersonDetails() and destructure the result\n  // TODO: Print each field\n}",
              "solution": "// Solution: Records Practice\n\n// Function returning a named record\n({String name, int age, String email}) getPersonDetails() {\n  return (\n    name: 'Alice Johnson',\n    age: 28,\n    email: 'alice@example.com',\n  );\n}\n\nvoid main() {\n  // Call and destructure the record\n  var (:name, :age, :email) = getPersonDetails();\n  \n  // Print each field\n  print('Name: $name');\n  print('Age: $age');\n  print('Email: $email');\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Function returns a named record with correct fields",
                  "expectedOutput": "Name: Alice Johnson",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Age field is correctly destructured",
                  "expectedOutput": "Age: 28",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Email field is correctly destructured",
                  "expectedOutput": "Email: alice@example.com",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use ({Type field1, Type field2}) syntax for named record types."
                },
                {
                  "level": 2,
                  "text": "Destructure named records with var (:field1, :field2) = record;"
                },
                {
                  "level": 3,
                  "text": "Return the record as (field1: value1, field2: value2)"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using $1, $2 with named records",
                  "consequence": "Compilation error - named fields use their names",
                  "correction": "Access named fields by name: record.name, not record.$1"
                },
                {
                  "mistake": "Forgetting the colon in destructuring",
                  "consequence": "Creates new variables instead of matching fields",
                  "correction": "Use (:name, :age) not (name, age) for named records"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "1.8-challenge-1",
              "title": "Pattern Matching with Switch",
              "description": "Create a function that uses pattern matching to describe different data types.",
              "instructions": "1. Create a function `describe(Object value)` that returns a String\n2. Use switch expression with patterns to handle: integers (positive/negative/zero), strings (empty/short/long), lists (empty/single/multiple), and a default case\n3. Test with various inputs",
              "starterCode": "// Pattern Matching Practice\n\nString describe(Object value) {\n  // TODO: Use switch expression with patterns\n  return '';\n}\n\nvoid main() {\n  print(describe(42));\n  print(describe(-5));\n  print(describe('hello'));\n  print(describe([1, 2, 3]));\n}",
              "solution": "// Solution: Pattern Matching with Switch\n\nString describe(Object value) {\n  return switch (value) {\n    // Integer patterns\n    0 => 'zero',\n    int n when n < 0 => 'negative: $n',\n    int n => 'positive: $n',\n    \n    // String patterns\n    String s when s.isEmpty => 'empty string',\n    String s when s.length <= 5 => 'short string: $s',\n    String s => 'long string: $s',\n    \n    // List patterns\n    [] => 'empty list',\n    [var single] => 'single element: $single',\n    [var first, ...] => 'list starting with: $first',\n    \n    // Default\n    _ => 'unknown: $value',\n  };\n}\n\nvoid main() {\n  print(describe(42));          // positive: 42\n  print(describe(-5));          // negative: -5\n  print(describe(0));           // zero\n  print(describe('hello'));     // short string: hello\n  print(describe(''));          // empty string\n  print(describe([1, 2, 3]));   // list starting with: 1\n  print(describe([]));          // empty list\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Correctly identifies positive integers",
                  "expectedOutput": "positive: 42",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Correctly identifies negative integers",
                  "expectedOutput": "negative: -5",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Correctly handles list patterns",
                  "expectedOutput": "list starting with: 1",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'when' for guard conditions in patterns"
                },
                {
                  "level": 2,
                  "text": "Order matters - put specific cases before general ones"
                },
                {
                  "level": 3,
                  "text": "Use '...' for rest patterns in lists"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Putting general patterns before specific ones",
                  "consequence": "Specific patterns never match",
                  "correction": "Put 'int n when n < 0' before 'int n'"
                },
                {
                  "mistake": "Forgetting the => in switch expressions",
                  "consequence": "Syntax error",
                  "correction": "Use => for expression bodies in switch expressions"
                }
              ],
              "difficulty": "intermediate"
            },
            {
              "type": "FREE_CODING",
              "id": "1.8-challenge-2",
              "title": "Sealed Classes for Weather States",
              "description": "Create a sealed class hierarchy for weather conditions and a function to get weather advice.",
              "instructions": "1. Create a sealed class `Weather` with subclasses: Sunny (temperature), Rainy (intensity), Snowy (inches)\n2. Create a function `getAdvice(Weather weather)` using exhaustive switch\n3. Return appropriate advice for each weather type",
              "starterCode": "// Sealed Classes Practice\n\n// TODO: Define sealed class Weather and its subclasses\n\nString getAdvice(Weather weather) {\n  // TODO: Use exhaustive switch\n  return '';\n}\n\nvoid main() {\n  var conditions = [\n    Sunny(85),\n    Rainy('heavy'),\n    Snowy(6),\n  ];\n  \n  for (var weather in conditions) {\n    print(getAdvice(weather));\n  }\n}",
              "solution": "// Solution: Sealed Classes for Weather States\n\nsealed class Weather {}\n\nclass Sunny extends Weather {\n  final int temperature;\n  Sunny(this.temperature);\n}\n\nclass Rainy extends Weather {\n  final String intensity;  // 'light', 'moderate', 'heavy'\n  Rainy(this.intensity);\n}\n\nclass Snowy extends Weather {\n  final int inches;\n  Snowy(this.inches);\n}\n\nString getAdvice(Weather weather) {\n  return switch (weather) {\n    Sunny(temperature: var temp) when temp > 90 => \n      'Very hot ($temp F)! Stay hydrated and seek shade.',\n    Sunny(temperature: var temp) when temp > 70 => \n      'Nice day ($temp F)! Perfect for outdoor activities.',\n    Sunny(temperature: var temp) => \n      'Cool but sunny ($temp F). Bring a light jacket.',\n    Rainy(intensity: 'heavy') => \n      'Heavy rain! Stay indoors or bring an umbrella.',\n    Rainy(intensity: 'light') => \n      'Light rain. A jacket should be enough.',\n    Rainy(intensity: var i) => \n      '$i rain. Consider an umbrella.',\n    Snowy(inches: var in) when in > 6 => \n      'Heavy snow ($in inches)! Roads may be dangerous.',\n    Snowy(inches: var in) => \n      'Light snow ($in inches). Drive carefully.',\n  };\n}\n\nvoid main() {\n  var conditions = [\n    Sunny(85),\n    Sunny(95),\n    Rainy('heavy'),\n    Rainy('light'),\n    Snowy(6),\n    Snowy(12),\n  ];\n  \n  for (var weather in conditions) {\n    print(getAdvice(weather));\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Sunny weather returns temperature-based advice",
                  "expectedOutput": "Nice day (85 F)! Perfect for outdoor activities.",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Heavy rain returns umbrella advice",
                  "expectedOutput": "Heavy rain! Stay indoors or bring an umbrella.",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Heavy snow returns driving warning",
                  "expectedOutput": "Heavy snow (12 inches)! Roads may be dangerous.",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use 'sealed class' to define the base class"
                },
                {
                  "level": 2,
                  "text": "Subclasses use 'extends' just like regular inheritance"
                },
                {
                  "level": 3,
                  "text": "Destructure properties in switch cases: Sunny(temperature: var temp)"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Adding a default case to sealed class switch",
                  "consequence": "Defeats the purpose of exhaustive checking",
                  "correction": "Handle all subclasses explicitly instead"
                },
                {
                  "mistake": "Forgetting to handle all cases",
                  "consequence": "Compiler error due to non-exhaustive switch",
                  "correction": "Add cases for all subclasses of the sealed class"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-02",
      "title": "Module 2: Flutter Development",
      "description": "Learn Flutter development - Module 2",
      "difficulty": "beginner",
      "estimatedHours": 7,
      "lessons": [
        {
          "id": "2.1",
          "title": "Module 2, Lesson 1: What Happens When You Run an App?",
          "moduleId": "module-02",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Welcome to Flutter!",
              "content": "\nCongratulations on completing Module 1! You now understand:\n- How to write basic code (instructions)\n- How to store information (variables)\n- How to make decisions (if/else)\n\nNow we're ready to start building actual Flutter apps!\n\nBut first, we need to understand: **What happens when you run a Flutter app?**\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Starting Point",
              "content": "\nRemember when we created our first app and saw all that code in `main.dart`? Let's simplify it and understand what's actually happening.\n\nEvery Flutter app starts with this:\n\n\nThat's it! This is the **entry point** of every Flutter app.\n\n",
              "code": "void main() {\n  runApp(MyApp());\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "The \"main()\" Function - Your App's Starting Point",
              "content": "\nThink of `main()` like the \"Start\" button on a video game.\n\nWhen you press \"Run\" in VS Code:\n1. Flutter looks for the `main()` function\n2. Executes whatever code is inside it\n3. Your app comes to life!\n\n**Every Dart and Flutter program must have a `main()` function.** Without it, the program doesn't know where to begin.\n\n"
            },
            {
              "type": "THEORY",
              "title": "The \"runApp()\" Function - Showing Something on Screen",
              "content": "\nNow look at what's *inside* the `main()` function:\n\n\n**Conceptual Explanation**:\n- `runApp()` is a special Flutter function that says \"Put this on the screen\"\n- `MyApp()` is what we want to show\n- Together they mean: \"Take MyApp and display it\"\n\n**The Technical Term**: `runApp()` is the function that tells Flutter to inflate your app's widget tree and attach it to the screen.\n\n(Don't worry about \"widget tree\" yet - we'll get there!)\n\n",
              "code": "runApp(MyApp());",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Minimal Flutter App",
              "content": "\nLet's create the simplest possible Flutter app. Create a new file called `minimal_app.dart`:\n\n\nLet's run this! You should see a screen with \"Hello, Flutter!\" in the middle.\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    MaterialApp(\n      home: Center(\n        child: Text('Hello, Flutter!'),\n      ),\n    ),\n  );\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Breaking It Down",
              "content": "\nLet's understand each piece:\n\n### 1. The Import Statement\n\n\n**Conceptual**: Think of this like adding tools to your toolbox. The `material.dart` package contains all the visual components (buttons, text, etc.) that Flutter provides.\n\n**Technical**: This imports Flutter's Material Design widgets, which give us access to ready-made UI components.\n\n### 2. The Main Function\n\n\nWe know this one! It's the starting point.\n\n### 3. MaterialApp\n\n\n**Conceptual**: `MaterialApp` is like the foundation of a house. It provides the basic structure that all Flutter apps need.\n\n**Technical**: `MaterialApp` is a widget that wraps your entire app and provides Material Design styling, navigation, and theme support.\n\n### 4. The Home\n\n\n**Conceptual**: The `home` is the first screen the user sees - like the homepage of a website.\n\n**Technical**: `home` is a property that takes a widget. This widget becomes the default route (screen) of your app.\n\n### 5. Center\n\n\n**Conceptual**: `Center` is like putting something in the middle of a page. Whatever is inside it gets centered on the screen.\n\n**Technical**: `Center` is a layout widget that positions its child in the center of the available space.\n\n### 6. Text\n\n\n**Conceptual**: This displays text on the screen, just like `print()` displays text in the terminal!\n\n**Technical**: `Text` is a widget that displays a string of text with styling.\n\n",
              "code": "Text('Hello, Flutter!')",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introducing: Widgets",
              "content": "\nYou've now seen your first **widgets**!\n\n**Conceptual First**: Think of widgets as LEGO pieces. Each piece is a building block:\n- A `Text` widget is like a LEGO piece with letters on it\n- A `Center` widget is like a LEGO baseplate that centers other pieces\n- A `MaterialApp` widget is like the LEGO box that holds everything together\n\nYou snap these pieces together to build your app!\n\n**Now the Technical Term**: Widgets are the building blocks of Flutter apps. Everything you see on the screen is a widget - text, buttons, images, layouts, everything.\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Widget Tree (Simplified)",
              "content": "\nLook at how our widgets are nested:\n\n\nThis is called a **widget tree**. Each widget can have children (widgets inside it), creating a tree structure.\n\nThink of it like:\n- **MaterialApp** is the trunk\n- **Center** is a branch\n- **Text** is a leaf\n\n",
              "code": "MaterialApp\n  ‚îî‚îÄ Center\n      ‚îî‚îÄ Text",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Customizing Your First App",
              "content": "\nLet's make changes to see how widgets work!\n\n### Change 1: Bigger Text\n\n\nSave and see the text get bigger!\n\n### Change 2: Add Color\n\n\nThe text is now blue!\n\n### Change 3: Multiple Style Properties\n\n\nNow it's big, blue, and bold!\n\n",
              "code": "Text(\n  'Hello, Flutter!',\n  style: TextStyle(\n    fontSize: 48,\n    color: Colors.blue,\n    fontWeight: FontWeight.bold,\n  ),\n),",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Understanding the Pattern",
              "content": "\nNotice the pattern:\n\n1. Every widget has **properties** (like `home`, `child`, `style`)\n2. Properties are set using a **colon** (`:`)\n3. Some properties take other widgets (like `child`)\n4. Some properties take values (like `fontSize`)\n\nThis is how all Flutter code is structured!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Common Beginner Questions",
              "content": "\n**Q: Why do we need both `MaterialApp` and `Center`?**\nA: `MaterialApp` sets up the app foundation. `Center` positions the content. They serve different purposes!\n\n**Q: What if I forget the `import` statement?**\nA: You'll get errors like \"Undefined name 'MaterialApp'\". The import brings in the tools you need.\n\n**Q: Can I have multiple `main()` functions?**\nA: No! Each program has exactly one `main()` function as the entry point.\n\n**Q: Why all the commas?**\nA: Commas separate properties and parameters. It's how Dart knows where one thing ends and another begins.\n\n"
            },
            {
              "type": "WARNING",
              "title": "Common Flutter App Errors",
              "content": "\n**Missing Import Statement**\n\nIf you see `Undefined name 'MaterialApp'` or similar:\n```dart\n// ‚ùå Missing import\nvoid main() {\n  runApp(MaterialApp(...));  // Error!\n}\n\n// ‚úÖ Add this at the top of your file\nimport 'package:flutter/material.dart';\n```\n\n**Mismatched Parentheses**\n\nFlutter code has many nested parentheses. Count them carefully:\n```dart\n// ‚ùå Missing closing parenthesis\nMaterialApp(\n  home: Center(\n    child: Text('Hello')\n  )\n// Where's the closing )?\n\n// ‚úÖ Every ( needs a )\nMaterialApp(\n  home: Center(\n    child: Text('Hello'),\n  ),\n)\n```\n\n**Missing Trailing Commas**\n\nAdd commas after properties for better formatting:\n```dart\n// ‚úÖ Good practice - trailing commas help formatting\nText(\n  'Hello',\n  style: TextStyle(\n    fontSize: 24,  // <-- trailing comma\n  ),  // <-- trailing comma\n)\n```\n\n**Red Screen of Death**\n\nIf you see a red error screen, don't panic! Read the error message - it tells you exactly what's wrong and which line caused it.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap:\n- ‚úÖ Every Flutter app starts with `main()`\n- ‚úÖ `runApp()` puts your app on the screen\n- ‚úÖ Widgets are LEGO-like building blocks\n- ‚úÖ Everything in Flutter is a widget\n- ‚úÖ Widgets nest inside each other (widget tree)\n- ‚úÖ We can customize widgets with properties\n- ‚úÖ `import` statements bring in the tools we need\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nRight now, we can display text. But real apps need layouts - multiple pieces of content arranged on screen.\n\nIn the next lesson, we'll learn about **layout widgets**:\n- How to stack things vertically (like a to-do list)\n- How to arrange things horizontally (like a row of buttons)\n- How to create complex arrangements\n\nGet ready to build real app screens! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.1-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a file called `my_greeting_app.dart` that: 1. Displays your name in large text 2. Centers it on the screen 3. Makes the text a color of your choice 4. Makes the text bold --- ## Bonus Challenge: Add Background Color Try adding a background color to your app: This introduces the `Container` widget - another LEGO piece that can have a background color! ---",
              "instructions": "Create a file called `my_greeting_app.dart` that: 1. Displays your name in large text 2. Centers it on the screen 3. Makes the text a color of your choice 4. Makes the text bold --- ## Bonus Challenge: Add Background Color Try adding a background color to your app: This introduces the `Container` widget - another LEGO piece that can have a background color! ---",
              "starterCode": "// My Greeting App\n// TODO: Complete the app to display your name\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    MaterialApp(\n      home: Center(\n        // TODO: Add a Text widget with your name\n        // TODO: Style it with TextStyle (fontSize, color, fontWeight)\n        child: Text('Replace me!'),\n      ),\n    ),\n  );\n}",
              "solution": "// Solution: My Greeting App\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    MaterialApp(\n      home: Container(\n        color: Colors.lightBlue,\n        child: Center(\n          child: Text(\n            'Hello, Flutter!',\n            style: TextStyle(\n              fontSize: 32,\n              color: Colors.white,\n              fontWeight: FontWeight.bold,\n            ),\n          ),\n        ),\n      ),\n    ),\n  );\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "App displays centered text with styling",
                  "expectedOutput": "Text widget is centered on screen with custom color and bold font",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Container has background color applied",
                  "expectedOutput": "Container widget has Colors.lightBlue background",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Widget tree structure is correct",
                  "expectedOutput": "MaterialApp > Container > Center > Text hierarchy established",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print() function to display output."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.2",
          "title": "Module 2, Lesson 2: Building Blocks (Widgets)",
          "moduleId": "module-02",
          "order": 2,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The LEGO Analogy",
              "content": "\nRemember playing with LEGO bricks? Each brick is a simple piece, but when you combine them, you can build amazing things - houses, cars, spaceships!\n\n**Flutter widgets work exactly the same way!**\n- Each widget is a building block\n- You snap widgets together\n- Complex UIs are made from simple widgets combined\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Exactly is a Widget?",
              "content": "\n**Conceptual First**: A widget is anything you see on screen:\n- Text? That's a widget.\n- Button? That's a widget.\n- Image? That's a widget.\n- The layout that arranges them? Also a widget!\n\n**Technical Term**: In Flutter, **everything is a widget**. Widgets are the building blocks of your app's user interface.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Two Types of Widgets",
              "content": "\n### 1. StatelessWidget - Doesn't Change\n\nThink of a street sign - it always shows the same information.\n\n\n**When to use**: Static content that doesn't change.\n\n### 2. StatefulWidget - Can Change\n\nThink of a digital clock - it updates every second.\n\n\n**When to use**: Dynamic content that changes (we'll cover this in detail later).\n\n",
              "code": "class Counter extends StatefulWidget {\n  @override\n  _CounterState createState() => _CounterState();\n}\n\nclass _CounterState extends State<Counter> {\n  int count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Count: $count');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Why 'const' Constructors Make Your App FASTER",
              "content": "\nYou'll see `const` everywhere in Flutter code. Here's WHY it matters for performance:\n\n### The Problem: Flutter Rebuilds Widgets\n\nWhen state changes, Flutter rebuilds your widget tree. Every widget gets recreated:\n\n```\nüì± User taps button\n    ‚Üì\nüîÑ setState() called\n    ‚Üì\nüèóÔ∏è build() runs again\n    ‚Üì\nüß± Every widget is recreated\n    ‚Üì\nüí° Flutter compares old vs new\n    ‚Üì\nüñºÔ∏è Only changed parts actually repaint\n```\n\n**Without const**, Flutter creates new widget objects EVERY rebuild:\n\n```dart\n// ‚ùå Creates NEW Text object every rebuild\nText('Hello')  // Object A (rebuild 1)\nText('Hello')  // Object B (rebuild 2) - DIFFERENT object!\n```\n\n**With const**, Flutter REUSES the same object:\n\n```dart\n// ‚úÖ Same object is reused across rebuilds\nconst Text('Hello')  // Object A (rebuild 1)\nconst Text('Hello')  // Object A (rebuild 2) - SAME object!\n```\n\n### Visual: Widget Tree Rebuilds\n\n```\nüî¥ = Rebuilds every time (expensive)\nüü¢ = Reused (free!)\n\nWithout const:        With const:\n                      \n   App üî¥                App üî¥\n    ‚îÇ                     ‚îÇ\n Scaffold üî¥          Scaffold üî¥\n    ‚îÇ                     ‚îÇ\n  Column üî¥            Column üî¥\n  ‚îå‚îÄ‚î¥‚îÄ‚îê               ‚îå‚îÄ‚î¥‚îÄ‚îê\nTextüî¥ Textüî¥      Textüü¢ Textüü¢\n\nResult: 6 objects    Result: 4 objects\n        recreated           (2 reused!)\n```\n\n### When Can You Use const?\n\n**‚úÖ CAN use const:**\n- Widget with all constant values\n- No variables or dynamic data\n- Lists where all items are const\n\n```dart\n// ‚úÖ All values are known at compile time\nconst Text('Hello')\nconst Icon(Icons.star)\nconst SizedBox(height: 16)\nconst EdgeInsets.all(8)\nconst [1, 2, 3]  // const list\n```\n\n**‚ùå CANNOT use const:**\n- Widget uses variables\n- Values computed at runtime\n- Dynamic data\n\n```dart\n// ‚ùå Uses variable - can't be const\nText(userName)  // userName changes\n\n// ‚ùå Calculated at runtime\nText('Count: $count')  // count changes\n\n// ‚ùå Uses method call\nText(DateTime.now().toString())  // changes every call\n```\n\n### Real Example: const Optimization\n\n```dart\nclass MyHomePage extends StatefulWidget {\n  @override\n  State<MyHomePage> createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  int counter = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        const Text('Welcome!'),       // üü¢ REUSED - never changes\n        const Icon(Icons.star),       // üü¢ REUSED - never changes\n        const SizedBox(height: 16),   // üü¢ REUSED - never changes\n        Text('Count: $counter'),      // üî¥ REBUILDS - uses variable\n        ElevatedButton(\n          onPressed: () => setState(() => counter++),\n          child: const Text('Add'),   // üü¢ REUSED - text is constant\n        ),\n      ],\n    );\n  }\n}\n```\n\n### Rule of Thumb\n\n1. **Add `const` wherever possible** - VS Code will hint when you can\n2. **Extract constant widgets** into `const` constructor classes\n3. **Use `const` constructors** in your custom widgets\n\n```dart\n// Custom widget with const constructor\nclass WelcomeCard extends StatelessWidget {\n  const WelcomeCard({super.key});  // üëà const constructor!\n\n  @override\n  Widget build(BuildContext context) {\n    return const Card(\n      child: Text('Welcome!'),\n    );\n  }\n}\n\n// Now you can use it as const:\nconst WelcomeCard()  // üü¢ Reused across rebuilds!\n```\n\n**Performance Impact**: In complex apps with frequent rebuilds, const widgets can reduce frame drops and improve smoothness significantly!\n\n---\n\n"
            },
            {
              "type": "THEORY",
              "title": "Common Built-in Widgets",
              "content": "\nFlutter provides many ready-to-use widgets:\n\n| Widget | Purpose |\n|--------|---------|\n| `Text` | Display text |\n| `Image` | Show images |\n| `Icon` | Display icons |\n| `Container` | Box for layout and styling |\n| `Row` | Arrange widgets horizontally |\n| `Column` | Arrange widgets vertically |\n| `Stack` | Overlay widgets |\n| `ListView` | Scrollable list |\n| `Button` | Clickable button |\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Widget Tree",
              "content": "\nWidgets nest inside each other, forming a tree:\n\n\n**Think of it like nesting dolls** - each widget contains other widgets.\n\n",
              "code": "MaterialApp\n ‚îî‚îÄ Scaffold\n     ‚îî‚îÄ Center\n         ‚îî‚îÄ Text",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nNow let's explore the most common widget - **Text** - and learn how to style it!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.2-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a simple app with at least 3 different widgets nested together. ---",
              "instructions": "Create a simple app with at least 3 different widgets nested together. ---",
              "starterCode": "// Nested Widgets Challenge\n// TODO: Create an app with at least 3 nested widgets\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('My App')),\n        body: Center(\n          // TODO: Add more nested widgets here\n          // Try: Card, Padding, Column, Icon, Text\n          child: Text('Replace with nested widgets!'),\n        ),\n      ),\n    ),\n  );\n}",
              "solution": "// Solution: Nested Widgets Demo\n// This demonstrates widget nesting with 5+ different widgets\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const NestedWidgetsApp());\n}\n\nclass NestedWidgetsApp extends StatelessWidget {\n  const NestedWidgetsApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Widget Tree Structure:\n    // MaterialApp (Widget 1)\n    //   -> Scaffold (Widget 2)\n    //        -> Center (Widget 3)\n    //             -> Card (Widget 4)\n    //                  -> Padding (Widget 5)\n    //                       -> Column (Widget 6)\n    //                            -> Icon, Text, SizedBox (Widgets 7-9)\n    \n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Nested Widgets'),\n        ),\n        body: Center(\n          child: Card(\n            elevation: 4,\n            child: Padding(\n              padding: const EdgeInsets.all(24),\n              child: Column(\n                mainAxisSize: MainAxisSize.min,\n                children: const [\n                  Icon(\n                    Icons.flutter_dash,\n                    size: 64,\n                    color: Colors.blue,\n                  ),\n                  SizedBox(height: 16),\n                  Text(\n                    'Hello Flutter!',\n                    style: TextStyle(\n                      fontSize: 24,\n                      fontWeight: FontWeight.bold,\n                    ),\n                  ),\n                  SizedBox(height: 8),\n                  Text(\n                    'Widgets nest inside each other',\n                    style: TextStyle(color: Colors.grey),\n                  ),\n                ],\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - Widgets nest inside each other like Russian dolls\n// - Each widget has a specific purpose (layout, styling, content)\n// - The 'child' property connects widgets together",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget tree contains at least 3 nested widgets",
                  "expectedOutput": "MaterialApp > Scaffold > Center > Card hierarchy present",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "App displays Flutter icon",
                  "expectedOutput": "Icon widget with Icons.flutter_dash rendered",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Text displays with correct styling",
                  "expectedOutput": "Hello Flutter! text with bold style visible",
                  "isVisible": false
                }
              ],
              "language": "dart",
              "hints": [
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.3",
          "title": "Module 2, Lesson 3: Displaying and Styling Text",
          "moduleId": "module-02",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Your First Widget Deep Dive",
              "content": "\nYou've seen the `Text` widget briefly. Now let's master it! Text is the most common widget you'll use - every app shows text somewhere.\n\nThink of the Text widget like a word processor:\n- You can change the **font size**\n- You can change the **color**\n- You can make it **bold** or *italic*\n- You can **align** it\n\nAll of this is possible with Flutter's Text widget!\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Basic Text Widget",
              "content": "\nThe simplest form:\n\n\nThis displays plain text in the center of the screen.\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Text('Hello, Flutter!'),\n        ),\n      ),\n    ),\n  );\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introducing TextStyle",
              "content": "\nTo style text, we use the `style` property with a `TextStyle`:\n\n\n**Conceptual**: Think of `TextStyle` as the formatting toolbar in Word or Google Docs.\n\n",
              "code": "Text(\n  'Hello, Flutter!',\n  style: TextStyle(\n    fontSize: 24,\n    color: Colors.blue,\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Text Styling Options",
              "content": "\n### Font Size\n\n\n### Text Color\n\n\n**Note**: `Color(0xFF6200EA)` is a hex color. `0xFF` means fully opaque.\n\n### Font Weight (Bold)\n\n\n### Font Style (Italic)\n\n\n### Combining Multiple Styles\n\n\n",
              "code": "Text(\n  'Fancy Text!',\n  style: TextStyle(\n    fontSize: 28,\n    color: Colors.purple,\n    fontWeight: FontWeight.bold,\n    fontStyle: FontStyle.italic,\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Text Alignment",
              "content": "\nUse the `textAlign` property:\n\n\n",
              "code": "Text(\n  'Left Aligned',\n  textAlign: TextAlign.left,\n)\n\nText(\n  'Center Aligned',\n  textAlign: TextAlign.center,\n)\n\nText(\n  'Right Aligned',\n  textAlign: TextAlign.right,\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Multi-line Text",
              "content": "\n### Line Breaks with \\n\n\n\n### Multi-line Strings\n\n\n### Max Lines\n\nLimit how many lines to show:\n\n\n",
              "code": "Text(\n  'This is a very long text that might wrap to multiple lines',\n  maxLines: 2,\n  overflow: TextOverflow.ellipsis,  // Shows ... if text is cut off\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Text Decoration",
              "content": "\n### Underline\n\n\n### Strikethrough\n\n\n### Overline\n\n\n",
              "code": "Text(\n  'Overlined Text',\n  style: TextStyle(\n    decoration: TextDecoration.overline,\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Custom Fonts",
              "content": "\nWhile we won't dive deep now, you can use custom fonts:\n\n\n**Note**: You need to add font files to your project first.\n\n",
              "code": "Text(\n  'Custom Font',\n  style: TextStyle(\n    fontFamily: 'Roboto',\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Text widget displays text\n- ‚úÖ TextStyle controls appearance\n- ‚úÖ fontSize, color, fontWeight are common properties\n- ‚úÖ textAlign controls alignment\n- ‚úÖ Can combine multiple styles\n- ‚úÖ Decorations add underlines, strikethrough\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nText is great, but apps need images too! In the next lesson, we'll learn how to display images from the internet and from your app's assets.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.3-challenge-0",
              "title": "Practice Challenge",
              "description": "Create an app that displays your profile with various text styles: 1. Your name in large, bold text 2. Your age in medium, colored text 3. Your favorite quote in italic text 4. A fun fact about you in underlined text 5. Use at least 4 different colors ---",
              "instructions": "Create an app that displays your profile with various text styles: 1. Your name in large, bold text 2. Your age in medium, colored text 3. Your favorite quote in italic text 4. A fun fact about you in underlined text 5. Use at least 4 different colors ---",
              "starterCode": "// Text Styling Profile Challenge\n// TODO: Style each text differently\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MaterialApp(\n    home: Scaffold(\n      appBar: AppBar(title: Text('My Profile')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // TODO: Add your name (large, bold)\n            Text('Your Name', style: TextStyle(fontSize: 32)),\n            \n            // TODO: Add your age (medium, colored)\n            Text('Age: XX'),\n            \n            // TODO: Add a quote (italic)\n            Text('Your favorite quote'),\n            \n            // TODO: Add a fun fact (underlined)\n            Text('A fun fact about you'),\n          ],\n        ),\n      ),\n    ),\n  ));\n}",
              "solution": "// Solution: Text Styling Profile Card\n// Demonstrates various TextStyle properties\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ProfileApp());\n}\n\nclass ProfileApp extends StatelessWidget {\n  const ProfileApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('My Profile')),\n        body: Center(\n          child: Padding(\n            padding: const EdgeInsets.all(24),\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                // 1. Name - Large, bold text (Color 1: Deep Purple)\n                const Text(\n                  'Jane Developer',\n                  style: TextStyle(\n                    fontSize: 32,\n                    fontWeight: FontWeight.bold,\n                    color: Colors.deepPurple,\n                  ),\n                ),\n                const SizedBox(height: 16),\n                \n                // 2. Age - Medium, colored text (Color 2: Teal)\n                const Text(\n                  'Age: 28',\n                  style: TextStyle(\n                    fontSize: 20,\n                    color: Colors.teal,\n                  ),\n                ),\n                const SizedBox(height: 24),\n                \n                // 3. Quote - Italic text (Color 3: Grey)\n                const Text(\n                  '\"Code is poetry written for machines\"',\n                  style: TextStyle(\n                    fontSize: 18,\n                    fontStyle: FontStyle.italic,\n                    color: Colors.grey,\n                  ),\n                  textAlign: TextAlign.center,\n                ),\n                const SizedBox(height: 24),\n                \n                // 4. Fun fact - Underlined text (Color 4: Orange)\n                const Text(\n                  'Fun fact: I love building Flutter apps!',\n                  style: TextStyle(\n                    fontSize: 16,\n                    color: Colors.orange,\n                    decoration: TextDecoration.underline,\n                    decorationColor: Colors.orange,\n                  ),\n                ),\n                const SizedBox(height: 16),\n                \n                // Bonus: Combining multiple styles\n                const Text(\n                  'Flutter Developer',\n                  style: TextStyle(\n                    fontSize: 14,\n                    color: Colors.blue,\n                    fontWeight: FontWeight.w500,\n                    letterSpacing: 2,\n                  ),\n                ),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// TextStyle properties used:\n// - fontSize: Size of text\n// - fontWeight: Bold/light/normal\n// - fontStyle: Italic/normal\n// - color: Text color\n// - decoration: Underline/strikethrough\n// - letterSpacing: Space between letters",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Profile displays name with bold styling",
                  "expectedOutput": "Text widget with fontSize: 32, fontWeight: bold, color: deepPurple",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Quote text displays with italic style",
                  "expectedOutput": "Text widget with fontStyle: italic rendered",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Fun fact displays with underline decoration",
                  "expectedOutput": "Text widget with TextDecoration.underline visible",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print() function to display output."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.4",
          "title": "Module 2, Lesson 4: Displaying Images",
          "moduleId": "module-02",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Images Matter",
              "content": "\nA picture is worth a thousand words! Images make apps come alive:\n- **Icons** for buttons and navigation\n- **Photos** for social media\n- **Logos** for branding\n- **Illustrations** for instructions\n\nFlutter makes it easy to display images from different sources.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Two Types of Images",
              "content": "\n### 1. Network Images (from the internet)\n\nLike linking to a photo on the web.\n\n### 2. Asset Images (bundled with your app)\n\nLike photos you pack in your suitcase - they're always with you.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Network Images - The Easy Way",
              "content": "\nDisplay an image from a URL:\n\n\n**That's it!** The image loads from the internet and displays.\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('Network Image')),\n        body: Center(\n          child: Image.network(\n            'https://picsum.photos/200/300',\n          ),\n        ),\n      ),\n    ),\n  );\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Controlling Image Size",
              "content": "\n### Fixed Width and Height\n\n\n### Using fit Property\n\n\n**Common fit values**:\n- `BoxFit.cover` - Fill space, may crop\n- `BoxFit.contain` - Fit entirely, may have empty space\n- `BoxFit.fill` - Stretch to fill (may distort)\n- `BoxFit.fitWidth` - Fit width, height adjusts\n- `BoxFit.fitHeight` - Fit height, width adjusts\n\n",
              "code": "Image.network(\n  'https://picsum.photos/200/300',\n  width: 300,\n  height: 200,\n  fit: BoxFit.cover,  // Fills the space, may crop\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Asset Images - Images in Your App",
              "content": "\n### Step 1: Create an assets folder\n\n\n### Step 2: Add images\n\nPut your image files (like `logo.png`) in `assets/images/`\n\n### Step 3: Register in pubspec.yaml\n\nEdit `pubspec.yaml`:\n\n\n**Important**: Indentation matters in YAML!\n\n### Step 4: Use in code\n\n\n",
              "code": "Image.asset('assets/images/logo.png')",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Circular Images",
              "content": "\nUse `CircleAvatar`:\n\n\nOr use `ClipOval`:\n\n\n",
              "code": "ClipOval(\n  child: Image.network(\n    'https://picsum.photos/200',\n    width: 100,\n    height: 100,\n    fit: BoxFit.cover,\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Loading Indicator",
              "content": "\nShow a loading spinner while image loads:\n\n\n",
              "code": "Image.network(\n  'https://picsum.photos/200/300',\n  loadingBuilder: (context, child, progress) {\n    if (progress == null) return child;\n    return CircularProgressIndicator();\n  },\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Error Handling",
              "content": "\nWhat if the image fails to load?\n\n\n",
              "code": "Image.network(\n  'https://invalid-url.com/image.jpg',\n  errorBuilder: (context, error, stackTrace) {\n    return Text('Failed to load image');\n  },\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Icons - Special Images",
              "content": "\nFlutter has tons of built-in icons:\n\n\n**Explore all icons**: https://api.flutter.dev/flutter/material/Icons-class.html\n\n",
              "code": "Icon(\n  Icons.favorite,\n  color: Colors.red,\n  size: 50,\n)\n\nIcon(Icons.star)\nIcon(Icons.home)\nIcon(Icons.settings)\nIcon(Icons.person)\nIcon(Icons.search)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ `Image.network()` loads from URLs\n- ‚úÖ `Image.asset()` loads bundled images\n- ‚úÖ `BoxFit` controls how images fill space\n- ‚úÖ `CircleAvatar` creates circular images\n- ‚úÖ `Icon` widget for built-in icons\n- ‚úÖ Loading and error handling\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou can display text and images! Next, we'll learn about **Container** - the Swiss Army knife widget for layout and decoration. It's like a box you can style however you want!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.4-challenge-0",
              "title": "Practice Challenge",
              "description": "Create an app with: 1. At least 3 network images 2. Different sizes 3. At least one circular image 4. Text labels under each image ---",
              "instructions": "Create an app with: 1. At least 3 network images 2. Different sizes 3. At least one circular image 4. Text labels under each image ---",
              "starterCode": "// Image Gallery Challenge\n// Create an app with multiple network images\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ImageGalleryApp());\n}\n\nclass ImageGalleryApp extends StatelessWidget {\n  const ImageGalleryApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Image Gallery')),\n        body: SingleChildScrollView(\n          padding: const EdgeInsets.all(16),\n          child: Column(\n            children: [\n              // TODO: Add Image.network for a large landscape image\n              // Use: https://picsum.photos/400/200\n              \n              const SizedBox(height: 16),\n              \n              // TODO: Add a Row with two images side by side\n              // One square image, one CircleAvatar\n              \n              const SizedBox(height: 16),\n              \n              // TODO: Add text labels under each image\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "solution": "// Solution: Image Gallery with Labels\n// Shows network images with different sizes and shapes\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ImageGalleryApp());\n}\n\nclass ImageGalleryApp extends StatelessWidget {\n  const ImageGalleryApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Image Gallery')),\n        body: SingleChildScrollView(\n          padding: const EdgeInsets.all(16),\n          child: Column(\n            children: [\n              // Image 1: Large rectangular image\n              _buildImageCard(\n                imageUrl: 'https://picsum.photos/400/200',\n                label: 'Landscape Photo',\n                width: double.infinity,\n                height: 200,\n              ),\n              const SizedBox(height: 16),\n              \n              // Row with two smaller images\n              Row(\n                children: [\n                  // Image 2: Medium square image\n                  Expanded(\n                    child: _buildImageCard(\n                      imageUrl: 'https://picsum.photos/200/200',\n                      label: 'Square Photo',\n                      height: 150,\n                    ),\n                  ),\n                  const SizedBox(width: 16),\n                  \n                  // Image 3: Circular profile image\n                  Column(\n                    children: [\n                      const CircleAvatar(\n                        radius: 60,\n                        backgroundImage: NetworkImage(\n                          'https://picsum.photos/150/150',\n                        ),\n                      ),\n                      const SizedBox(height: 8),\n                      const Text(\n                        'Profile Photo',\n                        style: TextStyle(fontWeight: FontWeight.w500),\n                      ),\n                    ],\n                  ),\n                ],\n              ),\n              const SizedBox(height: 16),\n              \n              // Image 4: Small thumbnail\n              _buildImageCard(\n                imageUrl: 'https://picsum.photos/300/150',\n                label: 'Thumbnail',\n                width: 200,\n                height: 100,\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _buildImageCard({\n    required String imageUrl,\n    required String label,\n    double? width,\n    double? height,\n  }) {\n    return Column(\n      children: [\n        ClipRRect(\n          borderRadius: BorderRadius.circular(8),\n          child: Image.network(\n            imageUrl,\n            width: width,\n            height: height,\n            fit: BoxFit.cover,\n            loadingBuilder: (context, child, loadingProgress) {\n              if (loadingProgress == null) return child;\n              return SizedBox(\n                width: width,\n                height: height,\n                child: const Center(child: CircularProgressIndicator()),\n              );\n            },\n            errorBuilder: (context, error, stackTrace) {\n              return SizedBox(\n                width: width,\n                height: height,\n                child: const Center(child: Icon(Icons.error)),\n              );\n            },\n          ),\n        ),\n        const SizedBox(height: 8),\n        Text(label, style: const TextStyle(fontWeight: FontWeight.w500)),\n      ],\n    );\n  }\n}\n\n// Key concepts:\n// - Image.network() loads images from URLs\n// - CircleAvatar for circular profile images\n// - ClipRRect for rounded corners\n// - loadingBuilder shows progress\n// - errorBuilder handles failed loads",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Gallery displays network images",
                  "expectedOutput": "Image.network widgets loading from picsum.photos URLs",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Circular profile image displays correctly",
                  "expectedOutput": "CircleAvatar with radius 60 and NetworkImage",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Text labels appear below images",
                  "expectedOutput": "Landscape Photo, Square Photo, Profile Photo labels visible",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use Image.network('url') to load images from URLs"
                },
                {
                  "level": 3,
                  "text": "CircleAvatar uses backgroundImage: NetworkImage('url') for circular images"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to wrap images in SizedBox with explicit height",
                  "consequence": "Unbounded height error or layout issues",
                  "correction": "Use SizedBox or Container with height property"
                },
                {
                  "mistake": "Missing BoxFit for Image.network",
                  "consequence": "Image may overflow or look distorted",
                  "correction": "Add fit: BoxFit.cover to control how image fills space"
                },
                {
                  "mistake": "Using Image.network for CircleAvatar",
                  "consequence": "Image won't be circular",
                  "correction": "Use backgroundImage: NetworkImage('url') for CircleAvatar"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.5",
          "title": "Module 2, Lesson 5: The Container Widget",
          "moduleId": "module-02",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Swiss Army Knife of Widgets",
              "content": "\nIf widgets were tools, `Container` would be a Swiss Army knife - it does MANY things:\n- Acts as a **box** to hold other widgets\n- Adds **padding** (breathing room inside)\n- Adds **margin** (spacing outside)\n- Sets **background color**\n- Adds **borders**\n- Makes **rounded corners**\n- Sets **width and height**\n\n**Container is the most versatile widget you'll use!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Empty Container",
              "content": "\nThe simplest container:\n\n\nYou can't see it because it's invisible and empty! Let's give it color:\n\n\nNow you have a blue square!\n\n",
              "code": "Container(\n  color: Colors.blue,\n  width: 100,\n  height: 100,\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Container with a Child",
              "content": "\nContainers can hold exactly ONE child widget. Use the `child` property to nest any widget inside. The container then wraps that widget with its styling (color, padding, etc.).\n\nIf you need multiple widgets, wrap them in a Column or Row first, then put that inside the Container.\n\n\n",
              "code": "Container(\n  color: Colors.blue,\n  padding: EdgeInsets.all(20),\n  child: Text(\n    'Hello!',\n    style: TextStyle(color: Colors.white),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Padding - Space Inside",
              "content": "\n**Conceptual**: Padding is like bubble wrap inside a box.\n\n\n",
              "code": "// Padding on all sides\nContainer(\n  color: Colors.blue,\n  padding: EdgeInsets.all(20),\n  child: Text('Padded'),\n)\n\n// Different padding per side\nContainer(\n  padding: EdgeInsets.only(\n    left: 10,\n    right: 10,\n    top: 20,\n    bottom: 20,\n  ),\n  child: Text('Custom Padding'),\n)\n\n// Symmetric padding\nContainer(\n  padding: EdgeInsets.symmetric(\n    horizontal: 20,  // left and right\n    vertical: 10,    // top and bottom\n  ),\n  child: Text('Symmetric'),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Margin - Space Outside",
              "content": "\n**Conceptual**: Margin is like the space between boxes on a shelf.\n\n\n**Margin vs Padding**:\n- **Padding**: Space between container edge and its child (inside)\n- **Margin**: Space between container and other widgets (outside)\n\n",
              "code": "Container(\n  margin: EdgeInsets.all(20),\n  color: Colors.red,\n  child: Text('Has margin'),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Width and Height",
              "content": "\nContainers have no size by default - they expand to fit their child, or shrink to nothing if empty. Set explicit `width` and `height` to control the size.\n\n**Special value:** Use `double.infinity` to take up all available space in that dimension. This is useful for full-width buttons or dividers.\n\n\n",
              "code": "// Take up all available width\nContainer(\n  width: double.infinity,\n  height: 100,\n  color: Colors.orange,\n)\n\n// Take up all available height\nContainer(\n  width: 100,\n  height: double.infinity,\n  color: Colors.purple,\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "BoxDecoration - Advanced Styling",
              "content": "\nFor more complex styling, use `decoration`:\n\n\n**Note**: When using `decoration`, put `color` inside `BoxDecoration`, not directly on Container!\n\n",
              "code": "Container(\n  width: 200,\n  height: 100,\n  decoration: BoxDecoration(\n    color: Colors.blue,\n    borderRadius: BorderRadius.circular(20),  // Rounded corners\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Rounded Corners",
              "content": "\nUse `BorderRadius.circular()` for uniform corners, or `BorderRadius.only()` to control each corner individually. Common use cases include:\n- **Cards**: Slight rounding (8-15 pixels)\n- **Buttons**: Pill shape (large radius or circular)\n- **Tabs**: Top corners only\n\n\n",
              "code": "decoration: BoxDecoration(\n  color: Colors.blue,\n  borderRadius: BorderRadius.only(\n    topLeft: Radius.circular(20),\n    topRight: Radius.circular(20),\n    bottomLeft: Radius.circular(0),\n    bottomRight: Radius.circular(0),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Card Example",
              "content": "\nLet's combine everything to create a nice card:\n\n\n",
              "code": "Container(\n  margin: EdgeInsets.all(20),\n  padding: EdgeInsets.all(20),\n  decoration: BoxDecoration(\n    color: Colors.white,\n    borderRadius: BorderRadius.circular(15),\n    boxShadow: [\n      BoxShadow(\n        color: Colors.grey.withOpacity(0.5),\n        blurRadius: 10,\n        offset: Offset(0, 3),\n      ),\n    ],\n  ),\n  child: Column(\n    mainAxisSize: MainAxisSize.min,\n    children: [\n      Text(\n        'Card Title',\n        style: TextStyle(\n          fontSize: 20,\n          fontWeight: FontWeight.bold,\n        ),\n      ),\n      SizedBox(height: 10),\n      Text(\n        'This is a nice card with shadow and rounded corners!',\n        textAlign: TextAlign.center,\n      ),\n    ],\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Alignment Inside Container",
              "content": "\n\n**Alignment options**:\n- `Alignment.topLeft`\n- `Alignment.topCenter`\n- `Alignment.topRight`\n- `Alignment.centerLeft`\n- `Alignment.center`\n- `Alignment.centerRight`\n- `Alignment.bottomLeft`\n- `Alignment.bottomCenter`\n- `Alignment.bottomRight`\n\n",
              "code": "Container(\n  width: 200,\n  height: 200,\n  color: Colors.blue,\n  alignment: Alignment.center,  // Center the child\n  child: Text('Centered'),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Container is the Swiss Army knife widget\n- ‚úÖ `padding` adds space inside\n- ‚úÖ `margin` adds space outside\n- ‚úÖ `width` and `height` control size\n- ‚úÖ `BoxDecoration` for advanced styling\n- ‚úÖ Borders, shadows, gradients, rounded corners\n- ‚úÖ `alignment` positions child inside\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've learned individual widgets (Text, Image, Container). Now it's time to learn how to **arrange multiple widgets** on screen! In the next lesson, we'll explore **Column and Row** - the building blocks of layouts.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.5-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a business card using Container with: 1. Rounded corners 2. A nice color or gradient 3. Shadow 4. Padding 5. Your name and title ---",
              "instructions": "Create a business card using Container with: 1. Rounded corners 2. A nice color or gradient 3. Shadow 4. Padding 5. Your name and title ---",
              "starterCode": "// Business Card Widget\n// TODO: Create a styled business card\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MaterialApp(home: Scaffold(body: Center(child: BusinessCard()))));\n}\n\nclass BusinessCard extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // TODO: Add width and padding\n      // TODO: Add BoxDecoration with:\n      //   - color or gradient\n      //   - borderRadius\n      //   - boxShadow\n      child: Column(\n        mainAxisSize: MainAxisSize.min,\n        children: [\n          // TODO: Add name, title, email Text widgets\n        ],\n      ),\n    );\n  }\n}",
              "solution": "// Solution: Business Card Widget\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MaterialApp(home: Scaffold(body: Center(child: BusinessCard()))));\n}\n\nclass BusinessCard extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      width: 300,\n      padding: EdgeInsets.all(24),\n      decoration: BoxDecoration(\n        gradient: LinearGradient(\n          colors: [Colors.blue.shade700, Colors.blue.shade400],\n          begin: Alignment.topLeft,\n          end: Alignment.bottomRight,\n        ),\n        borderRadius: BorderRadius.circular(16),\n        boxShadow: [\n          BoxShadow(\n            color: Colors.black26,\n            blurRadius: 10,\n            offset: Offset(0, 4),\n          ),\n        ],\n      ),\n      child: Column(\n        mainAxisSize: MainAxisSize.min,\n        children: [\n          Text(\n            'Your Name',\n            style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: Colors.white),\n          ),\n          SizedBox(height: 8),\n          Text(\n            'Flutter Developer',\n            style: TextStyle(fontSize: 16, color: Colors.white70),\n          ),\n          SizedBox(height: 16),\n          Text(\n            'your@email.com',\n            style: TextStyle(fontSize: 14, color: Colors.white),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Business card has rounded corners",
                  "expectedOutput": "Container with BoxDecoration and BorderRadius.circular",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Card has shadow effect",
                  "expectedOutput": "BoxShadow with blur and offset applied",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Card displays name, title, and email",
                  "expectedOutput": "Text widgets for name, title, and email visible",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.6",
          "title": "Module 2, Lesson 6: Arranging Widgets (Column & Row)",
          "moduleId": "module-02",
          "order": 6,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Layout Problem",
              "content": "\nYou know how to create individual widgets (Text, Image, Container). But real apps have MANY widgets on screen:\n- A profile screen: photo + name + bio + buttons\n- A login screen: logo + text fields + button\n- A feed: many posts stacked vertically\n\n**How do we arrange multiple widgets?** Enter `Column` and `Row`!\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Stack of Pancakes (Column)",
              "content": "\n**Conceptual First**: Imagine stacking pancakes on a plate. Each pancake sits on top of the previous one.\n\n**Column does the same** - it stacks widgets vertically (top to bottom).\n\n\nOutput:\n\n",
              "code": "First widget\nSecond widget\nThird widget",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Main Axis Alignment (Vertical)",
              "content": "\nControl how children are spaced vertically:\n\n\n**Options**:\n- `MainAxisAlignment.start` - At the top\n- `MainAxisAlignment.center` - Centered vertically\n- `MainAxisAlignment.end` - At the bottom\n- `MainAxisAlignment.spaceBetween` - Space between items\n- `MainAxisAlignment.spaceAround` - Space around items\n- `MainAxisAlignment.spaceEvenly` - Equal spacing\n\n",
              "code": "Column(\n  mainAxisAlignment: MainAxisAlignment.start,  // Default: top\n  children: [\n    Text('Item 1'),\n    Text('Item 2'),\n    Text('Item 3'),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Cross Axis Alignment (Horizontal)",
              "content": "\nControl how children are aligned horizontally:\n\n\n**Options**:\n- `CrossAxisAlignment.start` - Left edge\n- `CrossAxisAlignment.center` - Centered (default)\n- `CrossAxisAlignment.end` - Right edge\n- `CrossAxisAlignment.stretch` - Fill width\n\n",
              "code": "Column(\n  crossAxisAlignment: CrossAxisAlignment.start,  // Left-aligned\n  children: [\n    Text('Short'),\n    Text('Medium text'),\n    Text('Very long text here'),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Books on a Shelf (Row)",
              "content": "\n**Conceptual First**: Imagine books lined up on a shelf, side by side.\n\n**Row does the same** - it arranges widgets horizontally (left to right).\n\n\nOutput:\n\n",
              "code": "First  Second  Third",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Combining Column and Row",
              "content": "\nThis is where it gets powerful!\n\n\n",
              "code": "Column(\n  children: [\n    Text('Header'),\n    Row(\n      mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n      children: [\n        Icon(Icons.favorite),\n        Icon(Icons.star),\n        Icon(Icons.share),\n      ],\n    ),\n    Text('Footer'),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Spacing Between Children",
              "content": "\n### Using SizedBox\n\n\nFor Row:\n\n",
              "code": "Row(\n  children: [\n    Icon(Icons.home),\n    SizedBox(width: 30),  // 30 pixels of space\n    Icon(Icons.search),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Expanded - Taking Up Available Space",
              "content": "\nSometimes you want a child to take up all remaining space:\n\n\n",
              "code": "Row(\n  children: [\n    Icon(Icons.menu),\n    Expanded(\n      child: Text('This takes up remaining space'),\n    ),\n    Icon(Icons.search),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n### 1. Column without Constrained Height\n\n\n### 2. Row/Column Overflow\n\n\n",
              "code": "// If children are too wide/tall, wrap in SingleChildScrollView:\nSingleChildScrollView(\n  child: Column(\n    children: [\n      // Many children...\n    ],\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Dart 3.10+ Dot Shorthands",
              "content": "\n**New in Dart 3.10:** You can now use dot shorthands to write cleaner code! When the type is known, skip the type name:\n\n**Before (verbose):**\n```dart\nColumn(\n  mainAxisAlignment: MainAxisAlignment.center,\n  crossAxisAlignment: CrossAxisAlignment.start,\n)\n```\n\n**After (with dot shorthands):**\n```dart\nColumn(\n  mainAxisAlignment: .center,\n  crossAxisAlignment: .start,\n)\n```\n\nThe compiler knows `mainAxisAlignment` expects a `MainAxisAlignment`, so you can just write `.center`!\n\n**Works with:**\n- Enums: `Colors.blue` ‚Üí `.blue`\n- Alignment: `Alignment.center` ‚Üí `.center`\n- Any typed parameter where the type is unambiguous\n\n**Note:** Dot shorthands are enabled by default in Dart 3.10+. Use them to reduce boilerplate!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ `Column` arranges widgets vertically\n- ‚úÖ `Row` arranges widgets horizontally\n- ‚úÖ `mainAxisAlignment` controls spacing along main axis\n- ‚úÖ `crossAxisAlignment` controls alignment on cross axis\n- ‚úÖ `SizedBox` creates spacing\n- ‚úÖ `Expanded` takes remaining space\n- ‚úÖ Combine Row and Column for complex layouts\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou now know the fundamentals of Flutter! You can display text, images, use containers, and arrange widgets in rows and columns.\n\nIn the next lesson, we'll build a **mini-project** that combines everything you've learned to create a complete app screen!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.6-challenge-0",
              "title": "Practice Challenge",
              "description": "Build a social media post layout: 1. Top row: profile photo + name 2. Middle: post text 3. Bottom row: like button + comment button + share button Use Column for vertical arrangement, Row for horizontal. ---",
              "instructions": "Build a social media post layout: 1. Top row: profile photo + name 2. Middle: post text 3. Bottom row: like button + comment button + share button Use Column for vertical arrangement, Row for horizontal. ---",
              "starterCode": "// Social Media Post Challenge\n// Build a post layout with profile, text, and action buttons\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const SocialMediaApp());\n}\n\nclass SocialMediaApp extends StatelessWidget {\n  const SocialMediaApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Social Feed')),\n        body: Card(\n          margin: const EdgeInsets.all(16),\n          child: Padding(\n            padding: const EdgeInsets.all(16),\n            // TODO: Use Column to arrange sections vertically\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              mainAxisSize: MainAxisSize.min,\n              children: [\n                // TODO 1: Top Row with CircleAvatar and name Text\n                \n                const SizedBox(height: 16),\n                \n                // TODO 2: Middle - Post text content\n                \n                const SizedBox(height: 16),\n                \n                // TODO 3: Bottom Row with Like, Comment, Share buttons\n                // Hint: Use mainAxisAlignment: MainAxisAlignment.spaceAround\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "solution": "// Solution: Social Media Post Layout\n// Uses Column for vertical and Row for horizontal arrangement\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const SocialMediaApp());\n}\n\nclass SocialMediaApp extends StatelessWidget {\n  const SocialMediaApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Social Feed')),\n        body: const SocialMediaPost(),\n      ),\n    );\n  }\n}\n\nclass SocialMediaPost extends StatelessWidget {\n  const SocialMediaPost({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      margin: const EdgeInsets.all(16),\n      child: Padding(\n        padding: const EdgeInsets.all(16),\n        // Main Column: arranges sections vertically\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            // 1. Top Row: Profile photo + name\n            Row(\n              children: [\n                const CircleAvatar(\n                  radius: 24,\n                  backgroundImage: NetworkImage(\n                    'https://picsum.photos/100/100',\n                  ),\n                ),\n                const SizedBox(width: 12),\n                Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: const [\n                    Text(\n                      'Jane Developer',\n                      style: TextStyle(\n                        fontWeight: FontWeight.bold,\n                        fontSize: 16,\n                      ),\n                    ),\n                    Text(\n                      '2 hours ago',\n                      style: TextStyle(color: Colors.grey, fontSize: 12),\n                    ),\n                  ],\n                ),\n              ],\n            ),\n            const SizedBox(height: 16),\n            \n            // 2. Middle: Post text\n            const Text(\n              'Just finished building my first Flutter app! The widget system is amazing - everything just clicks together like LEGO blocks.',\n              style: TextStyle(fontSize: 15),\n            ),\n            const SizedBox(height: 16),\n            \n            // 3. Bottom Row: Action buttons\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: [\n                _buildActionButton(Icons.thumb_up_outlined, 'Like', '42'),\n                _buildActionButton(Icons.comment_outlined, 'Comment', '8'),\n                _buildActionButton(Icons.share_outlined, 'Share', ''),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildActionButton(IconData icon, String label, String count) {\n    return TextButton.icon(\n      onPressed: () {},\n      icon: Icon(icon, size: 20),\n      label: Text(count.isNotEmpty ? '$label ($count)' : label),\n    );\n  }\n}\n\n// Layout structure:\n// Column (vertical)\n//   -> Row (horizontal): Avatar + Name\n//   -> Text: Post content\n//   -> Row (horizontal): Action buttons",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Top row contains profile photo and name",
                  "expectedOutput": "Row with CircleAvatar and Text for name visible",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Bottom row contains action buttons",
                  "expectedOutput": "Like, Comment, Share buttons in Row with spaceAround alignment",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Column arranges sections vertically",
                  "expectedOutput": "Main Column contains profile Row, post Text, and buttons Row",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use Row for horizontal layouts, Column for vertical"
                },
                {
                  "level": 3,
                  "text": "mainAxisAlignment: MainAxisAlignment.spaceAround distributes buttons evenly"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Nesting Row inside Row instead of Column",
                  "consequence": "Elements stacked horizontally instead of vertically",
                  "correction": "Use Column as the outer container for vertical sections"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.7",
          "title": "Module 2, Lesson 7: Dart 3.10 Dot Shorthands",
          "moduleId": "module-02",
          "order": 7,
          "estimatedMinutes": 30,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What Are Dot Shorthands?",
              "content": "\nDart 3.10 introduced a cleaner way to write enum values. When the type is known from context, you can omit the enum name.\n\n**Why this matters:**\n- Less typing\n- Cleaner code\n- Easier to read and refactor\n- The analyzer knows the type so you don't need to repeat it\n\nThis is a modern Dart feature that makes Flutter code significantly more readable!\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Before vs After - Traditional Verbose Syntax",
              "content": "\nHere's what Flutter code looked like before Dart 3.10. Notice how we have to repeat the enum name every time:\n\n",
              "code": "Column(\n  mainAxisAlignment: MainAxisAlignment.center,\n  crossAxisAlignment: CrossAxisAlignment.start,\n  children: [\n    Text(\n      'Hello',\n      textAlign: TextAlign.center,\n      style: TextStyle(fontWeight: FontWeight.bold),\n    ),\n    Image.asset('photo.png', fit: BoxFit.cover),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Modern Dart 3.10+ Syntax",
              "content": "\nWith Dart 3.10+, when the type is known from context, you can use the shorthand dot syntax. The code becomes much cleaner:\n\n",
              "code": "Column(\n  mainAxisAlignment: .center,\n  crossAxisAlignment: .start,\n  children: [\n    Text(\n      'Hello',\n      textAlign: .center,\n      style: TextStyle(fontWeight: .bold),\n    ),\n    Image.asset('photo.png', fit: .cover),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Common Shorthands",
              "content": "\nHere are the most common enum shorthands you'll use in Flutter:\n\n| Verbose | Shorthand | Context |\n|---------|-----------|-------------------------------|\n| MainAxisAlignment.center | .center | Column/Row |\n| CrossAxisAlignment.start | .start | Column/Row |\n| TextAlign.center | .center | Text widget |\n| FontWeight.bold | .bold | TextStyle |\n| BoxFit.cover | .cover | Image/BoxDecoration |\n| Axis.vertical | .vertical | Scrollable widgets |\n| Alignment.center | .center | Container |\n\n**Important Note:** `Colors.blue` does **NOT** have a shorthand because `Colors` is a class with static constants, not an enum. You must still write `Colors.blue`, not `.blue`.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "When to Use Each Style",
              "content": "\n**Use shorthands when:**\n- The parameter type makes context obvious\n- You want cleaner, more readable code\n- Working on new Dart 3.10+ projects\n\n**Use verbose form when:**\n- Reading older code from StackOverflow (it may use verbose syntax)\n- Working on projects with older Dart SDK versions\n- Teaching someone new (explicit is clearer for learning)\n\n**Both styles are valid!** Flutter accepts either syntax. Use whatever makes your code most readable for your situation.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.7-challenge-0",
              "title": "Refactor to Shorthands",
              "description": "Take the verbose Flutter code and refactor it to use modern Dart 3.10 dot shorthands where applicable. Remember: Colors.amber should NOT be shortened - it's a static constant, not an enum!",
              "instructions": "Convert the verbose enum syntax to modern dot shorthand syntax. Be careful: only enums can use shorthands, not static constants like Colors.",
              "starterCode": "// Refactor this code to use dot shorthands\n// where applicable!\n\nimport 'package:flutter/material.dart';\n\nclass ProfileCard extends StatelessWidget {\n  const ProfileCard({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      alignment: Alignment.center,\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          Text(\n            'Jane Developer',\n            textAlign: TextAlign.left,\n            style: TextStyle(\n              fontWeight: FontWeight.bold,\n              fontStyle: FontStyle.italic,\n            ),\n          ),\n          Image.asset(\n            'profile.png',\n            fit: BoxFit.cover,\n          ),\n          Container(\n            color: Colors.amber, // Don't change this!\n            alignment: Alignment.centerLeft,\n            child: Text('Flutter Expert'),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "solution": "// Refactored to use dot shorthands\n// Note: Colors.amber stays verbose (not an enum)\n\nimport 'package:flutter/material.dart';\n\nclass ProfileCard extends StatelessWidget {\n  const ProfileCard({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      alignment: .center,\n      child: Column(\n        mainAxisAlignment: .center,\n        crossAxisAlignment: .start,\n        children: [\n          Text(\n            'Jane Developer',\n            textAlign: .left,\n            style: TextStyle(\n              fontWeight: .bold,\n              fontStyle: .italic,\n            ),\n          ),\n          Image.asset(\n            'profile.png',\n            fit: .cover,\n          ),\n          Container(\n            color: Colors.amber, // Stays verbose - not an enum!\n            alignment: .centerLeft,\n            child: Text('Flutter Expert'),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "MainAxisAlignment and CrossAxisAlignment use dot shorthands",
                  "expectedOutput": "mainAxisAlignment: .center, crossAxisAlignment: .start",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "TextAlign, FontWeight, FontStyle use dot shorthands",
                  "expectedOutput": "textAlign: .left, fontWeight: .bold, fontStyle: .italic",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "BoxFit and Alignment use dot shorthands",
                  "expectedOutput": "fit: .cover, alignment: .center, alignment: .centerLeft",
                  "isVisible": true
                },
                {
                  "id": "test-4",
                  "description": "Colors.amber remains unchanged (not an enum)",
                  "expectedOutput": "color: Colors.amber (verbose form preserved)",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Look for places where the type is obvious from the parameter name, like mainAxisAlignment expects MainAxisAlignment."
                },
                {
                  "level": 2,
                  "text": "Remember: Colors is a class with static constants, NOT an enum. Colors.amber cannot become .amber."
                },
                {
                  "level": 3,
                  "text": "Replace EnumName.value with just .value when the parameter type makes the enum clear."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Trying to shorten Colors.blue to .blue",
                  "consequence": "Compilation error - Colors is not an enum",
                  "correction": "Keep Colors.blue as is - only enums support dot shorthands"
                },
                {
                  "mistake": "Using shorthands in older Dart versions",
                  "consequence": "Syntax error on Dart < 3.10",
                  "correction": "Check your Dart SDK version in pubspec.yaml"
                },
                {
                  "mistake": "Forgetting context matters",
                  "consequence": "Ambiguous shorthand",
                  "correction": "Shorthands only work when the type is clear from context"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "2.8",
          "title": "Module 2, Lesson 8: Mini-Project - Business Card App",
          "moduleId": "module-02",
          "order": 8,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Putting It All Together!",
              "content": "\nCongratulations on making it through Module 2! You've learned:\n- ‚úÖ How Flutter apps start (main, runApp)\n- ‚úÖ Widgets are building blocks\n- ‚úÖ Styling text\n- ‚úÖ Displaying images\n- ‚úÖ Using containers for decoration\n- ‚úÖ Arranging widgets with Column and Row\n\nNow let's combine EVERYTHING into a real project!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What We're Building",
              "content": "\nA **digital business card app** that shows:\n- Your name\n- Your title/profession\n- Your photo\n- Contact information (email, phone)\n- Social media icons\n- A professional design with colors, shadows, and spacing\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Final Result",
              "content": "\nYour app will look something like this:\n\n\n",
              "code": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                                 ‚îÇ\n‚îÇ         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ\n‚îÇ         ‚îÇ  Photo   ‚îÇ            ‚îÇ\n‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ\n‚îÇ                                 ‚îÇ\n‚îÇ         Your Name               ‚îÇ\n‚îÇ         Your Title              ‚îÇ\n‚îÇ                                 ‚îÇ\n‚îÇ    ‚úâ email@example.com          ‚îÇ\n‚îÇ    ‚òé +1 234 567 8900            ‚îÇ\n‚îÇ                                 ‚îÇ\n‚îÇ    üîó  üíº  üì∑  üê¶               ‚îÇ\n‚îÇ                                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 1: Create the Project",
              "content": "\n\nOpen `lib/main.dart` and let's start coding!\n\n",
              "code": "flutter create business_card\ncd business_card",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 2: Basic Structure",
              "content": "\nReplace everything in `main.dart`:\n\n\nRun it! You should see a teal screen with text.\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(BusinessCardApp());\n}\n\nclass BusinessCardApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Business Card',\n      home: BusinessCardScreen(),\n    );\n  }\n}\n\nclass BusinessCardScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      backgroundColor: Colors.teal,\n      body: SafeArea(\n        child: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              Text('Your card will go here'),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 3: Add the Profile Photo",
              "content": "\n\n**Tip**: Replace `Icon(Icons.person...)` with `backgroundImage: NetworkImage('YOUR_PHOTO_URL')` to use a real photo!\n\n",
              "code": "class BusinessCardScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      backgroundColor: Colors.teal,\n      body: SafeArea(\n        child: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              CircleAvatar(\n                radius: 50,\n                backgroundColor: Colors.white,\n                child: Icon(\n                  Icons.person,\n                  size: 60,\n                  color: Colors.teal,\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 6: Create Contact Info Cards",
              "content": "\nLet's create a reusable widget for contact info:\n\n\n",
              "code": "// Add this widget outside BusinessCardScreen class\nclass ContactCard extends StatelessWidget {\n  final IconData icon;\n  final String text;\n\n  ContactCard({required this.icon, required this.text});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      margin: EdgeInsets.symmetric(vertical: 10, horizontal: 25),\n      padding: EdgeInsets.all(10),\n      decoration: BoxDecoration(\n        color: Colors.white,\n        borderRadius: BorderRadius.circular(5),\n      ),\n      child: Row(\n        children: [\n          Icon(icon, color: Colors.teal),\n          SizedBox(width: 10),\n          Text(\n            text,\n            style: TextStyle(\n              color: Colors.teal[900],\n              fontSize: 16,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 7: Use Contact Cards",
              "content": "\nIn your Column, after the divider:\n\n\n",
              "code": "ContactCard(\n  icon: Icons.phone,\n  text: '+1 234 567 8900',\n),\nContactCard(\n  icon: Icons.email,\n  text: 'your.email@example.com',\n),",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nLet's recap Module 2:\n- ‚úÖ Created a complete Flutter app from scratch\n- ‚úÖ Used multiple widgets together\n- ‚úÖ Created custom widgets (ContactCard)\n- ‚úÖ Applied styling (colors, fonts, spacing)\n- ‚úÖ Used Column for vertical layout\n- ‚úÖ Used Row for horizontal layout\n- ‚úÖ Added images, icons, and text\n- ‚úÖ Made a real, shareable project\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\n**Module 2 Complete!** üéâ\n\nYou can now build static Flutter apps with beautiful layouts!\n\nIn **Module 3**, we'll learn advanced layout techniques:\n- ListView for scrollable lists\n- GridView for grids\n- Stack for overlaying widgets\n- Responsive layouts\n\nGet ready to build more complex UIs! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "2.8-challenge-0",
              "title": "Practice Challenge",
              "description": "Test on different device sizes and adjust spacing. ---",
              "instructions": "Test on different device sizes and adjust spacing. ---",
              "starterCode": "// Responsive Layout Challenge\n// Create a layout that adapts to different screen sizes\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ResponsiveApp());\n}\n\nclass ResponsiveApp extends StatelessWidget {\n  const ResponsiveApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Responsive Layout')),\n        body: const ResponsiveContent(),\n      ),\n    );\n  }\n}\n\nclass ResponsiveContent extends StatelessWidget {\n  const ResponsiveContent({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: Use MediaQuery.sizeOf(context) to get screen dimensions\n    final size = MediaQuery.sizeOf(context);\n    final screenWidth = size.width;\n    \n    // TODO: Create responsive values based on screen size\n    // Hint: isSmallScreen = screenWidth < 600\n    \n    return SingleChildScrollView(\n      padding: const EdgeInsets.all(16),\n      child: Column(\n        children: [\n          // TODO: Display screen info\n          Text('Screen width: ${screenWidth.toStringAsFixed(0)}px'),\n          \n          const SizedBox(height: 16),\n          \n          // TODO: Create cards that adapt to screen size\n          // Use Wrap widget for responsive grid behavior\n        ],\n      ),\n    );\n  }\n}",
              "solution": "// Solution: Responsive Spacing Demo\n// Adjusts padding and spacing based on screen size\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ResponsiveApp());\n}\n\nclass ResponsiveApp extends StatelessWidget {\n  const ResponsiveApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Responsive Layout')),\n        body: const ResponsiveContent(),\n      ),\n    );\n  }\n}\n\nclass ResponsiveContent extends StatelessWidget {\n  const ResponsiveContent({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Get screen dimensions\n    final size = MediaQuery.sizeOf(context);\n    final screenWidth = size.width;\n    final screenHeight = size.height;\n    \n    // Calculate responsive values\n    final isSmallScreen = screenWidth < 600;\n    final horizontalPadding = screenWidth * 0.05; // 5% of screen width\n    final verticalSpacing = isSmallScreen ? 12.0 : 24.0;\n    final fontSize = isSmallScreen ? 16.0 : 20.0;\n    \n    return SingleChildScrollView(\n      padding: EdgeInsets.symmetric(\n        horizontal: horizontalPadding,\n        vertical: 16,\n      ),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          // Display screen info\n          Card(\n            child: Padding(\n              padding: const EdgeInsets.all(16),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text(\n                    'Screen Info',\n                    style: TextStyle(\n                      fontSize: fontSize,\n                      fontWeight: FontWeight.bold,\n                    ),\n                  ),\n                  SizedBox(height: verticalSpacing),\n                  Text('Width: ${screenWidth.toStringAsFixed(0)}px'),\n                  Text('Height: ${screenHeight.toStringAsFixed(0)}px'),\n                  Text('Device: ${isSmallScreen ? \"Mobile\" : \"Tablet/Desktop\"}'),\n                ],\n              ),\n            ),\n          ),\n          SizedBox(height: verticalSpacing),\n          \n          // Responsive grid\n          Text(\n            'Responsive Cards',\n            style: TextStyle(fontSize: fontSize, fontWeight: FontWeight.bold),\n          ),\n          SizedBox(height: verticalSpacing),\n          \n          // Use Wrap for responsive grid behavior\n          Wrap(\n            spacing: verticalSpacing,\n            runSpacing: verticalSpacing,\n            children: List.generate(6, (index) {\n              return SizedBox(\n                width: isSmallScreen\n                    ? (screenWidth - horizontalPadding * 2 - verticalSpacing) / 2\n                    : (screenWidth - horizontalPadding * 2 - verticalSpacing * 2) / 3,\n                child: Card(\n                  child: Padding(\n                    padding: EdgeInsets.all(isSmallScreen ? 12 : 20),\n                    child: Column(\n                      children: [\n                        Icon(Icons.widgets, size: isSmallScreen ? 32 : 48),\n                        SizedBox(height: verticalSpacing / 2),\n                        Text('Card ${index + 1}'),\n                      ],\n                    ),\n                  ),\n                ),\n              );\n            }),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Responsive techniques:\n// - MediaQuery for screen dimensions\n// - Conditional values based on screen size\n// - Percentage-based padding\n// - Wrap widget for flexible grid",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "App uses MediaQuery for responsive sizing",
                  "expectedOutput": "MediaQuery.sizeOf(context) used to determine screen dimensions",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Layout adapts to different screen sizes",
                  "expectedOutput": "Different padding and spacing for mobile vs tablet/desktop",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Wrap widget creates responsive grid",
                  "expectedOutput": "Cards rearrange from 2 to 3 columns based on screen width",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use MediaQuery.sizeOf(context).width to get screen width"
                },
                {
                  "level": 3,
                  "text": "Create a breakpoint: final isSmallScreen = screenWidth < 600"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using MediaQuery.of(context).size instead of MediaQuery.sizeOf(context)",
                  "consequence": "Unnecessary widget rebuilds on any MediaQuery change",
                  "correction": "Use MediaQuery.sizeOf(context) for better performance"
                },
                {
                  "mistake": "Hardcoding pixel values instead of using percentages",
                  "consequence": "Layout breaks on different screen sizes",
                  "correction": "Use screenWidth * 0.05 for percentage-based values"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-03",
      "title": "Module 3: Flutter Development",
      "description": "Learn Flutter development - Module 3",
      "difficulty": "beginner",
      "estimatedHours": 5,
      "lessons": [
        {
          "id": "3.1",
          "title": "Module 3, Lesson 1: Scrollable Lists (ListView)",
          "moduleId": "module-03",
          "order": 1,
          "estimatedMinutes": 45,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Scrolling Problem",
              "content": "\nImagine a news app with 100 articles. You can't fit them all on one screen! You need **scrolling**.\n\n**Column** doesn't scroll by default. If content is too long, it overflows and you get an error.\n\n**ListView** solves this - it creates a scrollable list of widgets!\n\n"
            },
            {
              "type": "THEORY",
              "title": "When to Use ListView",
              "content": "\nUse ListView when you have:\n- A list of items (emails, messages, products)\n- Content that might be longer than the screen\n- Repeated items with similar structure\n\n**Think**: Instagram feed, WhatsApp chat list, shopping cart\n\n"
            },
            {
              "type": "THEORY",
              "title": "ListTile - The Perfect List Item",
              "content": "\n`ListTile` is a pre-built widget perfect for lists:\n\n\n",
              "code": "ListTile(\n  leading: Icon(Icons.person),  // Left side\n  title: Text('John Doe'),      // Main text\n  subtitle: Text('Software Engineer'),  // Secondary text\n  trailing: Icon(Icons.arrow_forward),  // Right side\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "ListView.builder - For Dynamic Lists",
              "content": "\nWhen you have many items (especially from data), use `ListView.builder`:\n\n\n**Why builder?** It only creates widgets for visible items - much more efficient!\n\n",
              "code": "ListView.builder(\n  itemCount: 100,  // Number of items\n  itemBuilder: (context, index) {\n    return ListTile(\n      title: Text('Item $index'),\n    );\n  },\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "ListView.separated - With Dividers",
              "content": "\nAdd dividers between items:\n\n\n",
              "code": "ListView.separated(\n  itemCount: contacts.length,\n  itemBuilder: (context, index) {\n    return ListTile(title: Text(contacts[index]));\n  },\n  separatorBuilder: (context, index) {\n    return Divider();\n  },\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Horizontal ListView",
              "content": "\nLists can scroll horizontally too:\n\n\n",
              "code": "ListView(\n  scrollDirection: Axis.horizontal,\n  children: [\n    Container(width: 160, color: Colors.red),\n    Container(width: 160, color: Colors.blue),\n    Container(width: 160, color: Colors.green),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "WARNING",
              "title": "Common ListView Mistakes",
              "content": "\n**Horizontal ListView Needs a Height!**\n\nA horizontal ListView inside a Column/Scaffold will crash with 'unbounded height':\n\n‚ùå This crashes:\n```dart\nColumn(\n  children: [\n    ListView(scrollDirection: Axis.horizontal, ...)  // Error!\n  ],\n)\n```\n\n‚úÖ Fix - Give it a height:\n```dart\nColumn(\n  children: [\n    SizedBox(\n      height: 100,  // Now it knows how tall to be\n      child: ListView(scrollDirection: Axis.horizontal, ...),\n    ),\n  ],\n)\n```\n\n**Forgetting itemCount in ListView.builder**\n\nWithout `itemCount`, ListView.builder creates items forever (infinite loop):\n```dart\n// ‚ùå Missing itemCount - infinite items!\nListView.builder(\n  itemBuilder: (ctx, index) => Text('Item $index'),\n)\n\n// ‚úÖ Always specify itemCount\nListView.builder(\n  itemCount: myList.length,\n  itemBuilder: (ctx, index) => Text(myList[index]),\n)\n```\n\n**Not Returning a Widget**\n\nitemBuilder MUST return a widget:\n```dart\n// ‚ùå Forgot to return\nitemBuilder: (ctx, index) {\n  Text('Item $index');  // No return!\n}\n\n// ‚úÖ Return the widget\nitemBuilder: (ctx, index) {\n  return Text('Item $index');\n}\n```\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nLists are one way to show multiple items. What about **grids** like a photo gallery? That's next!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.1-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a todo list with: 1. At least 5 todos 2. Use ListView.builder 3. Each todo has a checkbox icon 4. Bonus: Add dividers ---",
              "instructions": "Create a todo list with: 1. At least 5 todos 2. Use ListView.builder 3. Each todo has a checkbox icon 4. Bonus: Add dividers ---",
              "starterCode": "// Todo List Challenge\n// Create a scrollable todo list using ListView.builder\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const TodoApp());\n}\n\nclass TodoApp extends StatelessWidget {\n  const TodoApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('My Todo List')),\n        body: const TodoList(),\n      ),\n    );\n  }\n}\n\nclass TodoList extends StatelessWidget {\n  const TodoList({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Sample todo data\n    final todos = [\n      'Learn Flutter basics',\n      'Build a todo app',\n      'Study ListView.builder',\n      'Practice widget nesting',\n      'Create a beautiful UI',\n    ];\n\n    // TODO: Use ListView.builder instead of Column\n    // Remember: itemCount, itemBuilder\n    return ListView.builder(\n      itemCount: todos.length,\n      itemBuilder: (context, index) {\n        // TODO: Return a ListTile with:\n        // - leading: checkbox icon\n        // - title: todo text\n        return const Placeholder(); // Replace with ListTile\n      },\n    );\n  }\n}",
              "solution": "// Solution: Todo List with ListView.builder\n// Shows a scrollable todo list with checkboxes and dividers\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const TodoApp());\n}\n\nclass TodoApp extends StatelessWidget {\n  const TodoApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('My Todo List')),\n        body: const TodoList(),\n      ),\n    );\n  }\n}\n\nclass TodoList extends StatefulWidget {\n  const TodoList({super.key});\n\n  @override\n  State<TodoList> createState() => _TodoListState();\n}\n\nclass _TodoListState extends State<TodoList> {\n  // List of todo items with completion status\n  final List<Map<String, dynamic>> todos = [\n    {'title': 'Learn Flutter basics', 'completed': true},\n    {'title': 'Build a todo app', 'completed': false},\n    {'title': 'Study ListView.builder', 'completed': true},\n    {'title': 'Practice widget nesting', 'completed': false},\n    {'title': 'Create a beautiful UI', 'completed': false},\n    {'title': 'Deploy to app store', 'completed': false},\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    // ListView.builder efficiently builds items on demand\n    return ListView.builder(\n      itemCount: todos.length,\n      itemBuilder: (context, index) {\n        final todo = todos[index];\n        return Column(\n          children: [\n            ListTile(\n              // Checkbox icon based on completion\n              leading: Icon(\n                todo['completed']\n                    ? Icons.check_box\n                    : Icons.check_box_outline_blank,\n                color: todo['completed'] ? Colors.green : Colors.grey,\n              ),\n              // Todo title with strikethrough if completed\n              title: Text(\n                todo['title'],\n                style: TextStyle(\n                  decoration: todo['completed']\n                      ? TextDecoration.lineThrough\n                      : TextDecoration.none,\n                  color: todo['completed'] ? Colors.grey : Colors.black,\n                ),\n              ),\n              // Tap to toggle completion\n              onTap: () {\n                setState(() {\n                  todos[index]['completed'] = !todo['completed'];\n                });\n              },\n            ),\n            // Divider between items (bonus)\n            if (index < todos.length - 1) const Divider(height: 1),\n          ],\n        );\n      },\n    );\n  }\n}\n\n// Key concepts:\n// - ListView.builder: Efficient for long lists\n// - itemCount: Total number of items\n// - itemBuilder: Function called for each visible item\n// - StatefulWidget: Allows updating todo completion\n// - Divider: Visual separator between items",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "ListView.builder used with itemCount",
                  "expectedOutput": "ListView.builder creates items dynamically with itemCount: 6",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Checkbox icons toggle with completion",
                  "expectedOutput": "Icons.check_box for completed, Icons.check_box_outline_blank for pending",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Dividers separate todo items",
                  "expectedOutput": "Divider widget rendered between each ListTile",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Use ListView.builder with itemCount and itemBuilder parameters"
                },
                {
                  "level": 3,
                  "text": "ListTile has leading (icon), title (text) properties - perfect for todo items"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting itemCount in ListView.builder",
                  "consequence": "Infinite loop creating items forever",
                  "correction": "Always specify itemCount: todos.length"
                },
                {
                  "mistake": "Not returning a widget from itemBuilder",
                  "consequence": "Null error - 'return Text(...)' is required",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.2",
          "title": "Module 3, Lesson 2: Photo Grids (GridView)",
          "moduleId": "module-03",
          "order": 2,
          "estimatedMinutes": 30,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "When ListView Isn't Enough",
              "content": "\nLists are great for vertical scrolling, but what about a **photo gallery** or **product catalog**? You need items arranged in a **grid** - multiple columns!\n\nThink: Instagram explore page, Pinterest, app store icons.\n\n**GridView** creates scrollable grids of widgets!\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First GridView",
              "content": "\n`GridView.count` is the simplest way to create a grid. You specify `crossAxisCount` (number of columns), and GridView automatically arranges your children into rows.\n\nThis creates a 2-column grid with 4 colored boxes:\n\n",
              "code": "GridView.count(\n  crossAxisCount: 2,  // 2 columns\n  children: [\n    Container(color: Colors.red),\n    Container(color: Colors.blue),\n    Container(color: Colors.green),\n    Container(color: Colors.yellow),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "GridView.extent - Maximum Item Size",
              "content": "\nInstead of specifying columns, specify max width per item:\n\n\nAutomatically adjusts columns based on screen size - **responsive**!\n\n",
              "code": "GridView.extent(\n  maxCrossAxisExtent: 150,  // Max 150px per item\n  children: [\n    // Items adjust to fit screen width\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nGrids arrange items in 2D. But what about **overlaying** widgets on top of each other? That's **Stack**!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.2-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a product grid with: 1. At least 9 items 2. 3 columns 3. Each item shows image and name 4. Add spacing between items ---",
              "instructions": "Create a product grid with: 1. At least 9 items 2. 3 columns 3. Each item shows image and name 4. Add spacing between items ---",
              "starterCode": "// Product Grid Challenge\n// Create a 3-column grid of products\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ProductGridApp());\n}\n\nclass ProductGridApp extends StatelessWidget {\n  const ProductGridApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Product Grid')),\n        body: const ProductGrid(),\n      ),\n    );\n  }\n}\n\nclass ProductGrid extends StatelessWidget {\n  const ProductGrid({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Sample product names\n    final products = ['Laptop', 'Phone', 'Headphones', 'Watch', \n                      'Camera', 'Tablet', 'Speaker', 'Keyboard', 'Mouse'];\n\n    return Padding(\n      padding: const EdgeInsets.all(8),\n      // TODO: Use GridView.builder with SliverGridDelegateWithFixedCrossAxisCount\n      child: GridView.builder(\n        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(\n          crossAxisCount: 3, // TODO: 3 columns\n          crossAxisSpacing: 8, // TODO: horizontal spacing\n          mainAxisSpacing: 8, // TODO: vertical spacing\n        ),\n        itemCount: products.length,\n        itemBuilder: (context, index) {\n          // TODO: Return a Card with image and product name\n          return Card(\n            child: Center(child: Text(products[index])),\n          );\n        },\n      ),\n    );\n  }\n}",
              "solution": "// Solution: Product Grid with GridView\n// Shows a 3-column grid of products with images and names\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ProductGridApp());\n}\n\nclass ProductGridApp extends StatelessWidget {\n  const ProductGridApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Product Grid')),\n        body: const ProductGrid(),\n      ),\n    );\n  }\n}\n\nclass ProductGrid extends StatelessWidget {\n  const ProductGrid({super.key});\n\n  // Sample product data\n  static const List<Map<String, String>> products = [\n    {'name': 'Laptop', 'image': 'https://picsum.photos/200?1'},\n    {'name': 'Phone', 'image': 'https://picsum.photos/200?2'},\n    {'name': 'Headphones', 'image': 'https://picsum.photos/200?3'},\n    {'name': 'Watch', 'image': 'https://picsum.photos/200?4'},\n    {'name': 'Camera', 'image': 'https://picsum.photos/200?5'},\n    {'name': 'Tablet', 'image': 'https://picsum.photos/200?6'},\n    {'name': 'Speaker', 'image': 'https://picsum.photos/200?7'},\n    {'name': 'Keyboard', 'image': 'https://picsum.photos/200?8'},\n    {'name': 'Mouse', 'image': 'https://picsum.photos/200?9'},\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(8),\n      child: GridView.builder(\n        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(\n          crossAxisCount: 3,       // 3 columns\n          crossAxisSpacing: 8,     // Horizontal spacing\n          mainAxisSpacing: 8,      // Vertical spacing\n          childAspectRatio: 0.75,  // Height = width / 0.75\n        ),\n        itemCount: products.length,\n        itemBuilder: (context, index) {\n          final product = products[index];\n          return ProductCard(\n            name: product['name']!,\n            imageUrl: product['image']!,\n          );\n        },\n      ),\n    );\n  }\n}\n\nclass ProductCard extends StatelessWidget {\n  final String name;\n  final String imageUrl;\n\n  const ProductCard({\n    super.key,\n    required this.name,\n    required this.imageUrl,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      clipBehavior: Clip.antiAlias,\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.stretch,\n        children: [\n          // Product image\n          Expanded(\n            child: Image.network(\n              imageUrl,\n              fit: BoxFit.cover,\n              errorBuilder: (_, __, ___) => const Center(\n                child: Icon(Icons.image_not_supported),\n              ),\n            ),\n          ),\n          // Product name\n          Padding(\n            padding: const EdgeInsets.all(8),\n            child: Text(\n              name,\n              textAlign: TextAlign.center,\n              style: const TextStyle(fontWeight: FontWeight.w500),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - GridView.builder: Efficient grid for many items\n// - SliverGridDelegateWithFixedCrossAxisCount: Fixed columns\n// - crossAxisSpacing/mainAxisSpacing: Spacing between items\n// - childAspectRatio: Controls item height relative to width",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "GridView displays 3 columns",
                  "expectedOutput": "crossAxisCount: 3 creates 3-column grid layout",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Grid items show product images and names",
                  "expectedOutput": "Image.network and Text widget in each ProductCard",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Spacing applied between grid items",
                  "expectedOutput": "crossAxisSpacing: 8 and mainAxisSpacing: 8 configured",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "GridView.builder needs a gridDelegate to define the layout"
                },
                {
                  "level": 3,
                  "text": "SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3) creates 3 columns"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Missing gridDelegate in GridView.builder",
                  "consequence": "Error - GridView.builder requires a gridDelegate",
                  "correction": "Add gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(...)"
                },
                {
                  "mistake": "Forgetting itemCount in GridView.builder",
                  "consequence": "Infinite grid items",
                  "correction": "Always specify itemCount: products.length"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.3",
          "title": "Module 3, Lesson 3: Layering Widgets (Stack)",
          "moduleId": "module-03",
          "order": 3,
          "estimatedMinutes": 20,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Layer Cake Concept",
              "content": "\nSometimes you need widgets **on top** of each other:\n- Text on an image\n- Badge on an icon\n- Floating button over content\n\n**Stack** lets you layer widgets like a cake!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou can now arrange widgets vertically (Column), horizontally (Row), in lists (ListView), grids (GridView), and layers (Stack)! Next: making layouts **responsive** to different screen sizes!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.3-challenge-0",
              "title": "Stack Practice Challenge",
              "description": "Create a profile header with: 1. Background image 2. Profile photo overlaid 3. Name overlay at bottom ---",
              "instructions": "Create a profile header with: 1. Background image 2. Profile photo overlaid 3. Name overlay at bottom ---",
              "starterCode": "// Profile Header Challenge\n// Use Stack to layer widgets on top of each other\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ProfileHeaderApp());\n}\n\nclass ProfileHeaderApp extends StatelessWidget {\n  const ProfileHeaderApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Column(\n          children: const [\n            ProfileHeader(),\n            Expanded(\n              child: Center(child: Text('Profile Content')),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass ProfileHeader extends StatelessWidget {\n  const ProfileHeader({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      height: 250,\n      // TODO: Use Stack to layer widgets\n      child: Stack(\n        children: [\n          // TODO 1: Background image using Positioned.fill\n          // Image.network('https://picsum.photos/800/400', fit: BoxFit.cover)\n          \n          // TODO 2: Profile photo (CircleAvatar) positioned in center\n          \n          // TODO 3: Name text positioned at bottom\n        ],\n      ),\n    );\n  }\n}",
              "solution": "// Solution: Profile Header with Stack\n// Uses Stack to overlay profile photo and name on background\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ProfileHeaderApp());\n}\n\nclass ProfileHeaderApp extends StatelessWidget {\n  const ProfileHeaderApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Column(\n          children: const [\n            ProfileHeader(),\n            Expanded(\n              child: Center(\n                child: Text('Profile Content'),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass ProfileHeader extends StatelessWidget {\n  const ProfileHeader({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      height: 250,\n      child: Stack(\n        clipBehavior: Clip.none,\n        children: [\n          // 1. Background image (fills entire Stack)\n          Positioned.fill(\n            child: Image.network(\n              'https://picsum.photos/800/400',\n              fit: BoxFit.cover,\n            ),\n          ),\n          \n          // Gradient overlay for better text visibility\n          Positioned.fill(\n            child: Container(\n              decoration: BoxDecoration(\n                gradient: LinearGradient(\n                  begin: Alignment.topCenter,\n                  end: Alignment.bottomCenter,\n                  colors: [\n                    Colors.transparent,\n                    Colors.black.withOpacity(0.7),\n                  ],\n                ),\n              ),\n            ),\n          ),\n          \n          // 2. Profile photo (centered, overlapping bottom)\n          Positioned(\n            bottom: -50, // Extends below the header\n            left: 0,\n            right: 0,\n            child: Center(\n              child: Container(\n                decoration: BoxDecoration(\n                  shape: BoxShape.circle,\n                  border: Border.all(color: Colors.white, width: 4),\n                ),\n                child: const CircleAvatar(\n                  radius: 50,\n                  backgroundImage: NetworkImage(\n                    'https://picsum.photos/200/200',\n                  ),\n                ),\n              ),\n            ),\n          ),\n          \n          // 3. Name overlay at bottom\n          Positioned(\n            bottom: 60,\n            left: 0,\n            right: 0,\n            child: Column(\n              children: const [\n                Text(\n                  'Jane Developer',\n                  style: TextStyle(\n                    color: Colors.white,\n                    fontSize: 24,\n                    fontWeight: FontWeight.bold,\n                  ),\n                ),\n                SizedBox(height: 4),\n                Text(\n                  'Flutter Enthusiast',\n                  style: TextStyle(\n                    color: Colors.white70,\n                    fontSize: 14,\n                  ),\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - Stack: Overlays widgets on top of each other\n// - Positioned: Places widgets at specific locations\n// - Positioned.fill: Fills entire Stack\n// - clipBehavior: Allows content to overflow",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Stack places widgets on top of each other - first child is bottom layer"
                },
                {
                  "level": 3,
                  "text": "Use Positioned.fill for background, Positioned(bottom:) for overlay text"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to give Stack a height",
                  "consequence": "Stack collapses or has zero height",
                  "correction": "Wrap Stack in SizedBox with explicit height"
                },
                {
                  "mistake": "Children clipped when overflowing Stack bounds",
                  "consequence": "Profile photo cut off at container edge",
                  "correction": "Add clipBehavior: Clip.none to Stack"
                },
                {
                  "mistake": "Missing Positioned widget for placement",
                  "consequence": "Widgets pile up at top-left corner",
                  "correction": "Use Positioned(top/bottom/left/right:)"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.4",
          "title": "Module 3, Lesson 4: Responsive Layouts",
          "moduleId": "module-03",
          "order": 4,
          "estimatedMinutes": 30,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Multi-Screen Challenge",
              "content": "\nYour app runs on:\n- Small phones (320px wide)\n- Large phones (400px+)  \n- Tablets (600px+)\n- Desktop (1200px+)\n\n**One layout doesn't fit all!** You need **responsive** design.\n\n"
            },
            {
              "type": "THEORY",
              "title": "MediaQuery - Screen Information",
              "content": "\n`MediaQuery` provides information about the device screen and user preferences. Use it to get dimensions, safe areas, text scaling, and more.\n\nThe most common use is getting the screen width to decide which layout to show:\n\n",
              "code": "final size = MediaQuery.sizeOf(context);\ndouble screenWidth = size.width;\ndouble screenHeight = size.height;",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Efficient MediaQuery Usage (Flutter 3.10+)",
              "content": "\n**Old pattern (causes unnecessary rebuilds):**\n```dart\nfinal size = MediaQuery.of(context).size;\n```\n\n**New pattern (more efficient):**\n```dart\nfinal size = MediaQuery.sizeOf(context);\nfinal padding = MediaQuery.paddingOf(context);\nfinal viewInsets = MediaQuery.viewInsetsOf(context);\n```\n\n**Why?** The `.of(context)` version rebuilds when ANY MediaQuery property changes. The specific methods only rebuild when that property changes.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Flexible Columns with GridView",
              "content": "\n\nOn 400px screen: 2 columns\nOn 800px screen: 4 columns\nAuto-responsive!\n\n",
              "code": "GridView.extent(\n  maxCrossAxisExtent: 200,  // Adjusts columns automatically!\n  children: items,\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou can now build responsive layouts! Next: creating **custom, reusable widgets** to organize your code!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.4-challenge-0",
              "title": "Practice Challenge",
              "description": "Create an app that shows: Use MediaQuery or GridView.extent! ---",
              "instructions": "Create an app that shows: Use MediaQuery or GridView.extent! ---",
              "starterCode": "// Responsive Grid Challenge\n// Create a grid that adapts to screen size\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ResponsiveGridApp());\n}\n\nclass ResponsiveGridApp extends StatelessWidget {\n  const ResponsiveGridApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Responsive Grid')),\n        body: const ResponsiveGrid(),\n      ),\n    );\n  }\n}\n\nclass ResponsiveGrid extends StatelessWidget {\n  const ResponsiveGrid({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: Get screen width using MediaQuery.sizeOf(context).width\n    \n    // TODO: Use GridView.extent with maxCrossAxisExtent\n    // This auto-adjusts columns based on item size!\n    return GridView.extent(\n      maxCrossAxisExtent: 150, // Max width per item\n      padding: const EdgeInsets.all(8),\n      crossAxisSpacing: 8,\n      mainAxisSpacing: 8,\n      children: List.generate(12, (index) {\n        // TODO: Create Card widgets for each item\n        return Card(\n          child: Center(child: Text('Item ${index + 1}')),\n        );\n      }),\n    );\n  }\n}",
              "solution": "// Solution: Responsive Grid with GridView.extent\n// Automatically adjusts columns based on screen width\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ResponsiveGridApp());\n}\n\nclass ResponsiveGridApp extends StatelessWidget {\n  const ResponsiveGridApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Responsive Grid')),\n        body: const ResponsiveGrid(),\n      ),\n    );\n  }\n}\n\nclass ResponsiveGrid extends StatelessWidget {\n  const ResponsiveGrid({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Get screen width using MediaQuery\n    final screenWidth = MediaQuery.sizeOf(context).width;\n    \n    return Column(\n      children: [\n        // Display screen info\n        Container(\n          padding: const EdgeInsets.all(16),\n          color: Colors.blue.shade50,\n          width: double.infinity,\n          child: Text(\n            'Screen width: ${screenWidth.toStringAsFixed(0)}px',\n            style: const TextStyle(fontWeight: FontWeight.bold),\n          ),\n        ),\n        \n        // GridView.extent: Auto-adjusts columns based on item size\n        Expanded(\n          child: GridView.extent(\n            maxCrossAxisExtent: 150, // Max width of each item\n            padding: const EdgeInsets.all(8),\n            crossAxisSpacing: 8,\n            mainAxisSpacing: 8,\n            children: List.generate(12, (index) {\n              return Card(\n                color: Colors.primaries[index % Colors.primaries.length],\n                child: Center(\n                  child: Column(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    children: [\n                      Icon(\n                        Icons.widgets,\n                        color: Colors.white,\n                        size: 32,\n                      ),\n                      const SizedBox(height: 8),\n                      Text(\n                        'Item ${index + 1}',\n                        style: const TextStyle(\n                          color: Colors.white,\n                          fontWeight: FontWeight.bold,\n                        ),\n                      ),\n                    ],\n                  ),\n                ),\n              );\n            }),\n          ),\n        ),\n      ],\n    );\n  }\n}\n\n// Alternative: Using MediaQuery for manual control\nclass MediaQueryGrid extends StatelessWidget {\n  const MediaQueryGrid({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final width = MediaQuery.sizeOf(context).width;\n    // Calculate columns based on screen width\n    final columns = width < 400 ? 2 : (width < 800 ? 3 : 4);\n    \n    return GridView.builder(\n      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(\n        crossAxisCount: columns,\n        crossAxisSpacing: 8,\n        mainAxisSpacing: 8,\n      ),\n      itemCount: 12,\n      itemBuilder: (context, index) => Card(\n        child: Center(child: Text('Item ${index + 1}')),\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - GridView.extent: Auto columns based on maxCrossAxisExtent\n// - MediaQuery: Manual control over layout based on screen size\n// - Responsive design: Adapts to any screen width",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "GridView.extent auto-adjusts columns based on maxCrossAxisExtent"
                },
                {
                  "level": 3,
                  "text": "MediaQuery.sizeOf(context).width gives screen width for manual breakpoints"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using hardcoded column count instead of maxCrossAxisExtent",
                  "consequence": "Grid doesn't adapt to different screen sizes",
                  "correction": "Use GridView.extent with maxCrossAxisExtent for auto columns"
                },
                {
                  "mistake": "Forgetting to wrap GridView in Expanded inside Column",
                  "consequence": "Unbounded height error",
                  "correction": "Wrap GridView in Expanded when inside Column"
                },
                {
                  "mistake": "Using MediaQuery.of(context).size",
                  "consequence": "Unnecessary rebuilds on any MediaQuery change",
                  "correction": "Use MediaQuery.sizeOf(context) for better performance"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.5",
          "title": "Module 3, Lesson 5: Creating Custom Widgets",
          "moduleId": "module-03",
          "order": 5,
          "estimatedMinutes": 35,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Custom Widgets?",
              "content": "\nYou keep writing the same code over and over:\n- Product cards\n- List items\n- Buttons with icons\n\n**Solution**: Create **custom widgets** - reusable components!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Extracting a Widget",
              "content": "\n**Before**: Messy code with repetition\n\n\n**After**: Clean custom widget\n\n\n",
              "code": "// Define once\nclass CustomCard extends StatelessWidget {\n  final String text;\n  \n  CustomCard({required this.text});\n  \n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(16),\n      decoration: BoxDecoration(\n        color: Colors.white,\n        borderRadius: BorderRadius.circular(8),\n        boxShadow: [BoxShadow(color: Colors.grey, blurRadius: 4)],\n      ),\n      child: Text(text),\n    );\n  }\n}\n\n// Use many times\nCustomCard(text: 'Hello'),\nCustomCard(text: 'World'),",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Passing Callbacks",
              "content": "\nTo make your custom widgets interactive, pass callback functions as parameters. Use `VoidCallback` for functions with no arguments, or `Function(Type)` for functions that take parameters.\n\nThis lets parent widgets handle the logic while child widgets handle the UI:\n\n",
              "code": "class CustomButton extends StatelessWidget {\n  final String label;\n  final VoidCallback onPressed;  // Function parameter!\n  \n  CustomButton({required this.label, required this.onPressed});\n  \n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      onPressed: onPressed,\n      child: Text(label),\n    );\n  }\n}\n\n// Usage:\nCustomButton(\n  label: 'Click Me',\n  onPressed: () {\n    print('Button clicked!');\n  },\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Widget Organization",
              "content": "\n**Project structure:**\n\n\n**Import and use:**\n\n\n",
              "code": "import 'widgets/product_card.dart';\n\n// Now use ProductCard anywhere",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou can now build and organize custom widgets! In the final Module 3 lessons, we'll cover **scrolling techniques** and build a complete **mini-project** combining everything!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.5-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a `CommentWidget` with: Use it to display 5 comments in a ListView! ---",
              "instructions": "Create a `CommentWidget` with: Use it to display 5 comments in a ListView! ---",
              "starterCode": "// Custom CommentWidget Challenge\n// Create a reusable comment widget\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const CommentsApp());\n}\n\nclass CommentsApp extends StatelessWidget {\n  const CommentsApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Comments')),\n        body: const CommentsList(),\n      ),\n    );\n  }\n}\n\n// TODO: Create a reusable CommentWidget class\n// It should have these properties:\n// - authorName (String)\n// - commentText (String)\n// - timestamp (String)\nclass CommentWidget extends StatelessWidget {\n  final String authorName;\n  final String commentText;\n  final String timestamp;\n\n  const CommentWidget({\n    super.key,\n    required this.authorName,\n    required this.commentText,\n    required this.timestamp,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: Build the comment UI\n    // Hint: Use Row with CircleAvatar and Column\n    return const Placeholder();\n  }\n}\n\nclass CommentsList extends StatelessWidget {\n  const CommentsList({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: Use ListView.builder to display 5 CommentWidget instances\n    return ListView(\n      children: const [\n        // Add CommentWidget instances here\n      ],\n    );\n  }\n}",
              "solution": "// Solution: Reusable CommentWidget in ListView\n// Creates a reusable comment widget and displays 5 comments\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const CommentsApp());\n}\n\nclass CommentsApp extends StatelessWidget {\n  const CommentsApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Comments')),\n        body: const CommentsList(),\n      ),\n    );\n  }\n}\n\n// Reusable CommentWidget\nclass CommentWidget extends StatelessWidget {\n  final String authorName;\n  final String authorAvatar;\n  final String commentText;\n  final String timestamp;\n  final int likes;\n\n  const CommentWidget({\n    super.key,\n    required this.authorName,\n    required this.authorAvatar,\n    required this.commentText,\n    required this.timestamp,\n    this.likes = 0,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\n      child: Row(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          // Author avatar\n          CircleAvatar(\n            radius: 20,\n            backgroundImage: NetworkImage(authorAvatar),\n          ),\n          const SizedBox(width: 12),\n          \n          // Comment content\n          Expanded(\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                // Author name and timestamp\n                Row(\n                  children: [\n                    Text(\n                      authorName,\n                      style: const TextStyle(fontWeight: FontWeight.bold),\n                    ),\n                    const SizedBox(width: 8),\n                    Text(\n                      timestamp,\n                      style: TextStyle(color: Colors.grey.shade600, fontSize: 12),\n                    ),\n                  ],\n                ),\n                const SizedBox(height: 4),\n                \n                // Comment text\n                Text(commentText),\n                const SizedBox(height: 8),\n                \n                // Like button\n                Row(\n                  children: [\n                    Icon(Icons.thumb_up_outlined, size: 16, color: Colors.grey),\n                    const SizedBox(width: 4),\n                    Text('$likes', style: TextStyle(color: Colors.grey)),\n                    const SizedBox(width: 16),\n                    Text('Reply', style: TextStyle(color: Colors.blue)),\n                  ],\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Display 5 comments using ListView\nclass CommentsList extends StatelessWidget {\n  const CommentsList({super.key});\n\n  static const List<Map<String, dynamic>> comments = [\n    {'name': 'Alice', 'text': 'Great article! Very helpful.', 'time': '2h ago', 'likes': 12},\n    {'name': 'Bob', 'text': 'I learned a lot from this. Thanks!', 'time': '3h ago', 'likes': 8},\n    {'name': 'Carol', 'text': 'Can you explain the Stack widget more?', 'time': '5h ago', 'likes': 3},\n    {'name': 'David', 'text': 'Flutter is amazing!', 'time': '1d ago', 'likes': 25},\n    {'name': 'Eve', 'text': 'Following for more content like this.', 'time': '2d ago', 'likes': 5},\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.separated(\n      itemCount: comments.length,\n      separatorBuilder: (_, __) => const Divider(),\n      itemBuilder: (context, index) {\n        final comment = comments[index];\n        return CommentWidget(\n          authorName: comment['name'],\n          authorAvatar: 'https://picsum.photos/100?${index + 1}',\n          commentText: comment['text'],\n          timestamp: comment['time'],\n          likes: comment['likes'],\n        );\n      },\n    );\n  }\n}\n\n// Key concepts:\n// - Reusable widget with constructor parameters\n// - ListView.separated for dividers between items\n// - Flexible layout with Row and Expanded",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Custom widgets use constructor parameters: final String name; required this.name"
                },
                {
                  "level": 3,
                  "text": "Use Row with CircleAvatar for avatar, Expanded with Column for text content"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting 'required' keyword for constructor parameters",
                  "consequence": "Null values passed to widget",
                  "correction": "Add 'required' for mandatory parameters: required this.name"
                },
                {
                  "mistake": "Not using Expanded for text content in Row",
                  "consequence": "Text overflow error on long comments",
                  "correction": "Wrap Column with Expanded to let text wrap"
                },
                {
                  "mistake": "Missing super.key in constructor",
                  "consequence": "Widget key not properly initialized",
                  "correction": "Add super.key in const constructor"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.6",
          "title": "Module 3, Lesson 6: Advanced Scrolling Techniques",
          "moduleId": "module-03",
          "order": 6,
          "estimatedMinutes": 45,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Beyond Basic Lists",
              "content": "\nYou've learned ListView for simple scrolling. But what about:\n- Horizontal scrolling\n- Mixing scrolling directions\n- Scrolling only when needed\n\nLet's master advanced scrolling!\n\n"
            },
            {
              "type": "THEORY",
              "title": "SingleChildScrollView",
              "content": "\nMakes ANY widget scrollable:\n\n\n**Use case**: Forms, long content that might overflow.\n\n",
              "code": "SingleChildScrollView(\n  child: Column(\n    children: [\n      Container(height: 200, color: Colors.red),\n      Container(height: 200, color: Colors.blue),\n      Container(height: 200, color: Colors.green),\n      Container(height: 200, color: Colors.yellow),\n      // If total height > screen, it scrolls!\n    ],\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Horizontal Scrolling",
              "content": "\n\n**Use case**: Image galleries, category chips.\n\n",
              "code": "SingleChildScrollView(\n  scrollDirection: Axis.horizontal,\n  child: Row(\n    children: [\n      Container(width: 200, color: Colors.red),\n      Container(width: 200, color: Colors.blue),\n      Container(width: 200, color: Colors.green),\n    ],\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "PageView - Swipeable Pages",
              "content": "\nLike Instagram stories:\n\n\nSwipe to navigate!\n\n",
              "code": "PageView(\n  children: [\n    Container(color: Colors.red, child: Center(child: Text('Page 1'))),\n    Container(color: Colors.blue, child: Center(child: Text('Page 2'))),\n    Container(color: Colors.green, child: Center(child: Text('Page 3'))),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Wrap - Auto-wrapping",
              "content": "\nLike word wrap, but for widgets:\n\n\n**Use case**: Tags, filter chips, buttons that wrap.\n\n",
              "code": "Wrap(\n  spacing: 8,  // Horizontal spacing\n  runSpacing: 8,  // Vertical spacing\n  children: [\n    Chip(label: Text('Flutter')),\n    Chip(label: Text('Dart')),\n    Chip(label: Text('Mobile')),\n    Chip(label: Text('Development')),\n    Chip(label: Text('UI')),\n    // Auto-wraps to next line when needed!\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "NestedScrollView",
              "content": "\n`NestedScrollView` lets you coordinate scrolling between a header (like a collapsing app bar) and a body (like a ListView). The header collapses as you scroll, with smooth synchronized motion.\n\nThis pattern is common in profile screens, product pages, and settings:\n\n",
              "code": "NestedScrollView(\n  headerSliverBuilder: (context, innerBoxIsScrolled) {\n    return [\n      SliverAppBar(\n        expandedHeight: 200,\n        floating: false,\n        pinned: true,\n        flexibleSpace: FlexibleSpaceBar(\n          title: Text('My App'),\n          background: Image.network('url', fit: BoxFit.cover),\n        ),\n      ),\n    ];\n  },\n  body: ListView.builder(\n    itemCount: 50,\n    itemBuilder: (context, index) {\n      return ListTile(title: Text('Item $index'));\n    },\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nFinal Module 3 lesson: **Mini-project** combining all layout techniques!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.6-challenge-0",
              "title": "Practice Challenge",
              "description": "Create: 1. Horizontal scrolling category chips (Wrap or Row) 2. Vertical product list 3. Pull-to-refresh functionality ---",
              "instructions": "Create: 1. Horizontal scrolling category chips (Wrap or Row) 2. Vertical product list 3. Pull-to-refresh functionality ---",
              "starterCode": "// Scroll & Refresh Challenge\n// Create horizontal categories and vertical product list\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ShopApp());\n}\n\nclass ShopApp extends StatelessWidget {\n  const ShopApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Shop')),\n        body: const ShopScreen(),\n      ),\n    );\n  }\n}\n\nclass ShopScreen extends StatefulWidget {\n  const ShopScreen({super.key});\n\n  @override\n  State<ShopScreen> createState() => _ShopScreenState();\n}\n\nclass _ShopScreenState extends State<ShopScreen> {\n  final categories = ['All', 'Electronics', 'Clothing', 'Books', 'Home'];\n  final products = ['Product 1', 'Product 2', 'Product 3', 'Product 4', 'Product 5'];\n\n  Future<void> _handleRefresh() async {\n    // TODO: Simulate refresh delay\n    await Future.delayed(const Duration(seconds: 1));\n    setState(() {});\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // TODO 1: Horizontal scrolling category chips\n        // Hint: SizedBox with height + horizontal ListView\n        SizedBox(\n          height: 50,\n          child: ListView.builder(\n            scrollDirection: Axis.horizontal,\n            itemCount: categories.length,\n            itemBuilder: (context, index) {\n              return Chip(label: Text(categories[index]));\n            },\n          ),\n        ),\n        \n        // TODO 2 & 3: Vertical product list with RefreshIndicator\n        // Wrap ListView in RefreshIndicator for pull-to-refresh\n        Expanded(\n          child: ListView.builder(\n            itemCount: products.length,\n            itemBuilder: (context, index) {\n              return ListTile(title: Text(products[index]));\n            },\n          ),\n        ),\n      ],\n    );\n  }\n}",
              "solution": "// Solution: Categories with Pull-to-Refresh Product List\n// Horizontal chips, vertical list, and RefreshIndicator\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ShopApp());\n}\n\nclass ShopApp extends StatelessWidget {\n  const ShopApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Shop')),\n        body: const ShopScreen(),\n      ),\n    );\n  }\n}\n\nclass ShopScreen extends StatefulWidget {\n  const ShopScreen({super.key});\n\n  @override\n  State<ShopScreen> createState() => _ShopScreenState();\n}\n\nclass _ShopScreenState extends State<ShopScreen> {\n  String selectedCategory = 'All';\n  final categories = ['All', 'Electronics', 'Clothing', 'Books', 'Home', 'Sports'];\n  \n  final products = List.generate(\n    10,\n    (i) => {'name': 'Product ${i + 1}', 'price': (i + 1) * 9.99},\n  );\n\n  Future<void> _handleRefresh() async {\n    // Simulate network delay\n    await Future.delayed(const Duration(seconds: 1));\n    // In real app, fetch new data here\n    setState(() {});\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // 1. Horizontal scrolling category chips\n        SizedBox(\n          height: 50,\n          child: ListView.builder(\n            scrollDirection: Axis.horizontal,\n            padding: const EdgeInsets.symmetric(horizontal: 8),\n            itemCount: categories.length,\n            itemBuilder: (context, index) {\n              final category = categories[index];\n              final isSelected = category == selectedCategory;\n              return Padding(\n                padding: const EdgeInsets.symmetric(horizontal: 4),\n                child: FilterChip(\n                  label: Text(category),\n                  selected: isSelected,\n                  onSelected: (_) => setState(() => selectedCategory = category),\n                  backgroundColor: Colors.grey.shade200,\n                  selectedColor: Colors.blue.shade100,\n                ),\n              );\n            },\n          ),\n        ),\n        const Divider(),\n        \n        // 2 & 3. Vertical product list with pull-to-refresh\n        Expanded(\n          child: RefreshIndicator(\n            onRefresh: _handleRefresh,\n            child: ListView.builder(\n              itemCount: products.length,\n              itemBuilder: (context, index) {\n                final product = products[index];\n                return ListTile(\n                  leading: Container(\n                    width: 50,\n                    height: 50,\n                    color: Colors.grey.shade300,\n                    child: const Icon(Icons.shopping_bag),\n                  ),\n                  title: Text(product['name'] as String),\n                  subtitle: Text('\\$${(product['price'] as double).toStringAsFixed(2)}'),\n                  trailing: IconButton(\n                    icon: const Icon(Icons.add_shopping_cart),\n                    onPressed: () {},\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n\n// Key concepts:\n// - Horizontal ListView with scrollDirection: Axis.horizontal\n// - FilterChip for selectable category pills\n// - RefreshIndicator wraps scrollable for pull-to-refresh\n// - onRefresh must return a Future (async function)",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 2,
                  "text": "Horizontal ListView needs SizedBox with height, add scrollDirection: Axis.horizontal"
                },
                {
                  "level": 3,
                  "text": "RefreshIndicator wraps ListView - onRefresh must return Future<void>"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Horizontal ListView without height constraint",
                  "consequence": "Unbounded height error - ListView doesn't know how tall to be",
                  "correction": "Wrap in SizedBox(height: 50) or similar"
                },
                {
                  "mistake": "onRefresh not returning Future",
                  "consequence": "RefreshIndicator never stops spinning",
                  "correction": "Use async function: Future<void> _handleRefresh() async { ... }"
                },
                {
                  "mistake": "Forgetting to wrap ListView in Expanded inside Column",
                  "consequence": "Unbounded height error",
                  "correction": "Wrap ListView in Expanded when inside Column"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "3.7",
          "title": "App Theming with Material 3",
          "moduleId": "module-03",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Learning Objectives",
              "content": "By the end of this lesson, you will be able to:\n- Understand Flutter's theming system with Material 3\n- Create a custom theme using ColorScheme.fromSeed\n- Implement light and dark themes\n- Customize TextTheme for consistent typography\n- Apply component-specific themes\n- Switch between themes dynamically\n- Use theme data throughout your app\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\n### What is App Theming?\n\n**Concept First:**\nImagine you're decorating a house. Without a theme, each room has random colors, different furniture styles, and mismatched lighting. It looks chaotic and unprofessional.\n\nWith a design theme, every room follows consistent colors, matching furniture styles, and coordinated lighting. The house feels cohesive and well-designed.\n\n**App theming** is the same idea: defining a consistent visual style (colors, fonts, button styles, etc.) that applies automatically throughout your entire app.\n\n**Real-world analogy:** Starbucks has a consistent theme‚Äîgreen colors, sans-serif fonts, rounded corners. You recognize it instantly. Your app needs the same consistency!\n\n**Jargon:**\n- **ThemeData**: Flutter's object containing all theme information\n- **ColorScheme**: A set of 30+ colors defining your app's color palette\n- **TextTheme**: A set of text styles for different purposes (headlines, body, captions)\n- **Material 3**: Google's latest design system (default in Flutter 3.16+)\n- **Seed Color**: A single color that generates an entire color palette\n\n### Why This Matters\n\n**Without theming:**\n\n**With theming:**\n\n",
              "code": "// Styled automatically from theme!\nElevatedButton(\n  child: Text('Submit'),\n  onPressed: () {},\n)\n\n// Change your theme's primary color once ‚Üí all buttons update! ‚ú®",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 1: Understanding Material 3 Theming",
              "content": "\n### Material 3 Color System\n\nMaterial 3 generates a complete color palette from a **single seed color**:\n\n\n**Analogy:** Give an interior designer your favorite color. They create an entire palette‚Äîwall colors, furniture, accents‚Äîall coordinated automatically!\n\n### Material 3 is Default (Flutter 3.16+)\n\nAs of Flutter 3.16, Material 3 is enabled by default. You don't need to set `useMaterial3: true` anymore!\n\n",
              "code": "Seed Color (e.g., Blue #2196F3)\n    ‚Üì\nGenerates:\n- Primary (Main brand color)\n- Secondary (Accent color)\n- Tertiary (Complementary color)\n- Error (Error states)\n- Surface (Backgrounds)\n- OnPrimary (Text on primary color)\n- OnSecondary (Text on secondary color)\n... (30+ colors total!)",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Section 2: Creating Your First Theme",
              "content": "\n### Basic Theme Setup\n\n\n**What happens:**\n1. `ColorScheme.fromSeed` generates 30+ coordinated colors from `Colors.deepPurple`\n2. All Material widgets (buttons, app bars, cards) use these colors automatically\n3. Change `seedColor` to `Colors.teal` ‚Üí entire app changes instantly!\n\n",
              "code": "// main.dart\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(const MyApp());\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Themed App',\n\n      // Define your theme here\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(\n          seedColor: Colors.deepPurple,\n        ),\n      ),\n\n      home: const HomeScreen(),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('My Themed App'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // These widgets automatically use theme colors!\n            ElevatedButton(\n              onPressed: () {},\n              child: const Text('Primary Button'),\n            ),\n            const SizedBox(height: 16),\n            FilledButton(\n              onPressed: () {},\n              child: const Text('Filled Button'),\n            ),\n            const SizedBox(height: 16),\n            OutlinedButton(\n              onPressed: () {},\n              child: const Text('Outlined Button'),\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {},\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 3: Light and Dark Themes",
              "content": "\n### Implementing Theme Switching\n\n\n**ThemeMode options:**\n- `ThemeMode.light` - Always use light theme\n- `ThemeMode.dark` - Always use dark theme\n- `ThemeMode.system` - Follow device setting (recommended)\n\n### Manual Theme Switching\n\n\n",
              "code": "class MyApp extends StatefulWidget {\n  const MyApp({super.key});\n\n  @override\n  State<MyApp> createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  ThemeMode _themeMode = ThemeMode.system;\n\n  void _toggleTheme() {\n    setState(() {\n      _themeMode = _themeMode == ThemeMode.light\n          ? ThemeMode.dark\n          : ThemeMode.light;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(\n          seedColor: Colors.blue,\n          brightness: Brightness.light,\n        ),\n      ),\n      darkTheme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(\n          seedColor: Colors.blue,\n          brightness: Brightness.dark,\n        ),\n      ),\n      themeMode: _themeMode,\n      home: HomeScreen(onToggleTheme: _toggleTheme),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  final VoidCallback onToggleTheme;\n\n  const HomeScreen({super.key, required this.onToggleTheme});\n\n  @override\n  Widget build(BuildContext context) {\n    final isDark = Theme.of(context).brightness == Brightness.dark;\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Theme Switcher'),\n        actions: [\n          IconButton(\n            icon: Icon(isDark ? Icons.light_mode : Icons.dark_mode),\n            onPressed: onToggleTheme,\n          ),\n        ],\n      ),\n      body: const Center(\n        child: Text('Toggle theme with the icon button'),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 4: Customizing TextTheme",
              "content": "\n### Understanding TextTheme Styles\n\nTextTheme provides predefined styles for different text purposes:\n\n| Style | Purpose | Example |\n|-------|---------|---------|\n| `displayLarge` | Very large headlines | \"Welcome\" on splash screen |\n| `headlineLarge` | Section headers | \"Settings\" title |\n| `titleLarge` | Card titles | \"New Message\" dialog title |\n| `bodyLarge` | Main content | Article text |\n| `bodyMedium` | Default body text | Paragraph text |\n| `labelLarge` | Button text | \"SUBMIT\" button |\n\n### Custom TextTheme Example\n\n\n### Using Custom Fonts\n\n\n\n",
              "code": "ThemeData(\n  colorScheme: ColorScheme.fromSeed(seedColor: Colors.purple),\n\n  textTheme: const TextTheme(\n    headlineLarge: TextStyle(\n      fontFamily: 'Poppins',\n      fontSize: 32,\n      fontWeight: FontWeight.bold,\n    ),\n    bodyLarge: TextStyle(\n      fontFamily: 'Poppins',\n      fontSize: 16,\n    ),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 5: Component-Specific Theming",
              "content": "\n### Customizing Button Themes\n\n\n### Customizing AppBar Theme\n\n\n### Customizing Input Decoration Theme\n\n\n### Customizing Card Theme\n\n\n",
              "code": "ThemeData(\n  colorScheme: ColorScheme.fromSeed(seedColor: Colors.purple),\n\n  cardTheme: CardTheme(\n    elevation: 4,\n    shape: RoundedRectangleBorder(\n      borderRadius: BorderRadius.circular(16),\n    ),\n    margin: const EdgeInsets.all(8),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 6: Accessing Theme Data",
              "content": "\n### Using Theme.of(context)\n\n\n### Common Theme Properties\n\n\n",
              "code": "// Colors\nTheme.of(context).colorScheme.primary\nTheme.of(context).colorScheme.secondary\nTheme.of(context).colorScheme.surface\nTheme.of(context).colorScheme.error\nTheme.of(context).colorScheme.onPrimary  // Text color on primary background\n\n// Text styles\nTheme.of(context).textTheme.headlineLarge\nTheme.of(context).textTheme.bodyLarge\nTheme.of(context).textTheme.labelLarge\n\n// Check if dark mode\nTheme.of(context).brightness == Brightness.dark",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Section 7: Complete Theming Example",
              "content": "\n### Comprehensive App Theme\n\n\n### Using the Theme\n\n\n",
              "code": "// lib/main.dart\nimport 'package:flutter/material.dart';\nimport 'theme/app_theme.dart';\n\nvoid main() => runApp(const MyApp());\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Themed App',\n      theme: AppTheme.lightTheme,\n      darkTheme: AppTheme.darkTheme,\n      themeMode: ThemeMode.system,\n      home: const HomeScreen(),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Material 3 Theme'),\n      ),\n      body: ListView(\n        padding: const EdgeInsets.all(16),\n        children: [\n          // Headline\n          Text(\n            'Welcome!',\n            style: Theme.of(context).textTheme.headlineLarge,\n          ),\n          const SizedBox(height: 16),\n\n          // Body text\n          Text(\n            'This app uses a custom Material 3 theme with consistent colors, typography, and component styling.',\n            style: Theme.of(context).textTheme.bodyLarge,\n          ),\n          const SizedBox(height: 24),\n\n          // Buttons\n          ElevatedButton(\n            onPressed: () {},\n            child: const Text('Elevated Button'),\n          ),\n          const SizedBox(height: 16),\n\n          FilledButton(\n            onPressed: () {},\n            child: const Text('Filled Button'),\n          ),\n          const SizedBox(height: 16),\n\n          OutlinedButton(\n            onPressed: () {},\n            child: const Text('Outlined Button'),\n          ),\n          const SizedBox(height: 24),\n\n          // Card\n          Card(\n            child: Padding(\n              padding: const EdgeInsets.all(16),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text(\n                    'Themed Card',\n                    style: Theme.of(context).textTheme.titleLarge,\n                  ),\n                  const SizedBox(height: 8),\n                  Text(\n                    'This card automatically uses the theme\\'s card styling.',\n                    style: Theme.of(context).textTheme.bodyMedium,\n                  ),\n                ],\n              ),\n            ),\n          ),\n          const SizedBox(height: 24),\n\n          // Input field\n          const TextField(\n            decoration: InputDecoration(\n              labelText: 'Username',\n              hintText: 'Enter your username',\n              prefixIcon: Icon(Icons.person),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Section 8: Best Practices",
              "content": "\n### 1. Use One Seed Color for Consistency\n\n**Good:**\n\n### 2. Extract Theme to Separate File\n\n\n### 3. Always Use Theme Colors, Never Hardcode\n\n**Bad:**\n\n**Good:**\n\n### 4. Use Material 3 Color Roles\n\nMaterial 3 provides semantic color roles:\n- `primary` - Main brand actions\n- `secondary` - Less prominent actions\n- `tertiary` - Complementary accents\n- `error` - Errors and warnings\n- `surface` - Card and sheet backgrounds\n- `onPrimary`, `onSecondary`, etc. - Text on those colors\n\nUse these instead of arbitrary colors!\n\n### 5. Test Both Light and Dark Themes\n\nAlways test your app in both themes:\n\n",
              "code": "// In main.dart, temporarily force dark mode for testing\nthemeMode: ThemeMode.dark,  // Change to test",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\nTest your understanding of app theming:\n\n### Question 1\nWhat is the recommended way to create a color scheme in Material 3?\n\nA) Define 30 colors manually\nB) Use `ColorScheme.fromSeed()` with a single seed color\nC) Use hexadecimal color codes throughout your app\nD) Copy colors from another app\n\n### Question 2\nWhat does `Theme.of(context)` do?\n\nA) Creates a new theme\nB) Returns the current theme applied to the widget tree\nC) Switches between light and dark themes\nD) Deletes the current theme\n\n### Question 3\nWhich TextTheme style should you use for button text?\n\nA) `displayLarge`\nB) `headlineLarge`\nC) `bodyLarge`\nD) `labelLarge`\n\n### Question 4\nWhat is the correct way to make an app support both light and dark themes?\n\nA) Create two separate apps\nB) Define both `theme` and `darkTheme` in MaterialApp\nC) Use only dark colors\nD) Themes can't be switched\n\n### Question 5\nWhen should you hardcode colors like `Colors.red` in your widgets?\n\nA) Always, for precision\nB) For important elements only\nC) Rarely‚Äîuse theme colors instead for consistency\nD) Never, even for semantic colors like error states\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Question 1: B** - `ColorScheme.fromSeed()` is the Material 3 way. It generates a complete, harmonious 30-color palette from a single seed color automatically.\n\n**Question 2: B** - `Theme.of(context)` returns the nearest ThemeData in the widget tree, allowing you to access theme colors, text styles, and other styling information.\n\n**Question 3: D** - `labelLarge` is specifically designed for button text in Material 3. It has appropriate sizing and weight for button labels.\n\n**Question 4: B** - Define both `theme` (light) and `darkTheme` (dark) in MaterialApp, then use `themeMode` to control which is active. Flutter handles the switching automatically.\n\n**Question 5: C** - Use theme colors for consistency. Hardcoded colors should be rare exceptions. For error states, use `Theme.of(context).colorScheme.error` instead of `Colors.red`.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nIn this lesson, you learned:\n\n‚úÖ **ThemeData** defines your app's visual style in one place\n‚úÖ **ColorScheme.fromSeed()** generates a complete color palette from one seed color\n‚úÖ **Material 3** is the default in Flutter 3.16+ with 30+ coordinated colors\n‚úÖ **Light and dark themes** can be implemented with `theme` and `darkTheme`\n‚úÖ **TextTheme** provides predefined styles for different text purposes\n‚úÖ **Component themes** customize specific widgets (buttons, cards, inputs)\n‚úÖ **Theme.of(context)** accesses theme data anywhere in your widget tree\n‚úÖ Using theme colors ensures **consistency** across your entire app\n\n**Key Takeaway:** Theming is essential for professional apps. Define your theme once, and every widget automatically follows your design system. Change your seed color, and your entire app updates instantly. This saves time, ensures consistency, and makes your app look polished!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn **Lesson 3.8: Mini-Project - Instagram-Style Feed** (previously Lesson 3.7), you'll apply everything you've learned about layouts AND theming to build a beautiful, themed social media feed with custom styling!\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "3.8",
          "title": "Module 3, Lesson 7: Mini-Project - Instagram-Style Feed",
          "moduleId": "module-03",
          "order": 8,
          "estimatedMinutes": 30,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Putting It All Together!",
              "content": "\nYou've mastered layouts! Now build a complete Instagram-style feed combining:\n- ListView for scrolling posts\n- GridView for photo galleries\n- Stack for overlays\n- Custom widgets for posts\n- Responsive design\n\n"
            },
            {
              "type": "THEORY",
              "title": "What We're Building",
              "content": "\nAn Instagram-like feed with:\n- Posts with images\n- Like/comment/share buttons\n- Profile avatars\n- Stories section (horizontal scroll)\n- Responsive grid for explore page\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nModule 3 complete! You can now:\n- ‚úÖ Create scrollable lists (ListView)\n- ‚úÖ Build grids (GridView)\n- ‚úÖ Layer widgets (Stack)\n- ‚úÖ Make responsive layouts (MediaQuery, LayoutBuilder)\n- ‚úÖ Create custom widgets\n- ‚úÖ Use advanced scrolling (PageView, Wrap)\n- ‚úÖ Build complex UI layouts\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\n**Module 4: User Interaction!**\n\nYou can build beautiful layouts, but they don't DO anything yet! Next, you'll learn:\n- Handling button presses\n- Getting user input from text fields\n- Managing state (making your app interactive)\n- Building forms\n\nGet ready to make your apps come alive! üöÄ\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "3.8-challenge-0",
              "title": "Adaptive Layout Challenge",
              "description": "Adjust grid columns based on screen width using LayoutBuilder.",
              "instructions": "Adjust grid columns based on screen width. ---",
              "starterCode": "// Adaptive Grid Challenge\n// Create a grid that changes columns based on screen width\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const AdaptiveGridApp());\n}\n\nclass AdaptiveGridApp extends StatelessWidget {\n  const AdaptiveGridApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Adaptive Grid')),\n        body: const AdaptiveGrid(),\n      ),\n    );\n  }\n}\n\nclass AdaptiveGrid extends StatelessWidget {\n  const AdaptiveGrid({super.key});\n\n  // TODO: Create a function to determine column count based on width\n  // Hint: if (width < 400) return 2; etc.\n  int _getColumnCount(double width) {\n    return 2; // TODO: Return different values based on width\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: Use LayoutBuilder to get available width\n    return LayoutBuilder(\n      builder: (context, constraints) {\n        final width = constraints.maxWidth;\n        final columns = _getColumnCount(width);\n        \n        return GridView.builder(\n          padding: const EdgeInsets.all(8),\n          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(\n            crossAxisCount: columns,\n            crossAxisSpacing: 8,\n            mainAxisSpacing: 8,\n          ),\n          itemCount: 12,\n          itemBuilder: (context, index) {\n            return Card(\n              child: Center(child: Text('Item ${index + 1}')),\n            );\n          },\n        );\n      },\n    );\n  }\n}",
              "solution": "// Solution: Adaptive Grid Columns\n// Changes column count based on screen width breakpoints\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const AdaptiveGridApp());\n}\n\nclass AdaptiveGridApp extends StatelessWidget {\n  const AdaptiveGridApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Adaptive Grid')),\n        body: const AdaptiveGrid(),\n      ),\n    );\n  }\n}\n\nclass AdaptiveGrid extends StatelessWidget {\n  const AdaptiveGrid({super.key});\n\n  // Determine column count based on screen width\n  int _getColumnCount(double width) {\n    if (width < 400) return 2;       // Mobile portrait\n    if (width < 600) return 3;       // Mobile landscape / small tablet\n    if (width < 900) return 4;       // Tablet\n    return 5;                         // Desktop\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n      builder: (context, constraints) {\n        final width = constraints.maxWidth;\n        final columns = _getColumnCount(width);\n        \n        return Column(\n          children: [\n            // Info bar showing current layout\n            Container(\n              width: double.infinity,\n              padding: const EdgeInsets.all(12),\n              color: Colors.blue.shade50,\n              child: Text(\n                'Width: ${width.toStringAsFixed(0)}px | Columns: $columns',\n                style: const TextStyle(fontWeight: FontWeight.bold),\n                textAlign: TextAlign.center,\n              ),\n            ),\n            \n            // Adaptive grid\n            Expanded(\n              child: GridView.builder(\n                padding: const EdgeInsets.all(8),\n                gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(\n                  crossAxisCount: columns,\n                  crossAxisSpacing: 8,\n                  mainAxisSpacing: 8,\n                  childAspectRatio: 1,\n                ),\n                itemCount: 20,\n                itemBuilder: (context, index) {\n                  return Card(\n                    color: Colors.primaries[index % Colors.primaries.length].shade100,\n                    child: Center(\n                      child: Column(\n                        mainAxisAlignment: MainAxisAlignment.center,\n                        children: [\n                          Icon(\n                            Icons.grid_view,\n                            size: 32,\n                            color: Colors.primaries[index % Colors.primaries.length],\n                          ),\n                          const SizedBox(height: 8),\n                          Text(\n                            'Item ${index + 1}',\n                            style: const TextStyle(fontWeight: FontWeight.w500),\n                          ),\n                        ],\n                      ),\n                    ),\n                  );\n                },\n              ),\n            ),\n          ],\n        );\n      },\n    );\n  }\n}\n\n// Key concepts:\n// - LayoutBuilder provides parent constraints\n// - Breakpoints define column count for different widths\n// - SliverGridDelegateWithFixedCrossAxisCount for fixed columns\n// - Resize window to see columns change dynamically",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Calculate crossAxisCount from constraints.maxWidth"
                },
                {
                  "mistake": "Not handling all breakpoints",
                  "consequence": "Layout may break on unexpected screen sizes",
                  "correction": "Include fallback case with default column count"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-04",
      "title": "Module 4: Flutter Development",
      "description": "Learn Flutter development - Module 4",
      "difficulty": "beginner",
      "estimatedHours": 4,
      "lessons": [
        {
          "id": "4.1",
          "title": "Module 4, Lesson 1: Making Things Clickable (Buttons)",
          "moduleId": "module-04",
          "order": 1,
          "estimatedMinutes": 45,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "From Static to Interactive!",
              "content": "\nBeautiful UIs are great, but **real apps respond** to user actions!\n\nThink about every app you use:\n- Tap to like a post\n- Click to submit a form\n- Press to send a message\n\n**Buttons make apps interactive!**\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Button",
              "content": "\n\nRun this and click the button - check the console!\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () {\n              print('Button pressed!');\n            },\n            child: Text('Click Me'),\n          ),\n        ),\n      ),\n    ),\n  );\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Button Types in Flutter",
              "content": "\n### 1. ElevatedButton - Raised with shadow\n\n\n### 2. TextButton - Flat, no background\n\n\n### 3. OutlinedButton - Border, no fill\n\n\n### 4. IconButton - Just an icon\n\n\n### 5. FloatingActionButton - Circular, floating\n\n\n",
              "code": "FloatingActionButton(\n  onPressed: () {\n    print('FAB pressed');\n  },\n  child: Icon(Icons.add),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Styling Buttons",
              "content": "\n### Colors\n\n\n### Size\n\n\n### Rounded Corners\n\n\n",
              "code": "ElevatedButton(\n  style: ElevatedButton.styleFrom(\n    shape: RoundedRectangleBorder(\n      borderRadius: BorderRadius.circular(30),\n    ),\n  ),\n  onPressed: () {},\n  child: Text('Rounded'),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Disabled Buttons",
              "content": "\n\nThe button appears grayed out and doesn't respond!\n\n",
              "code": "ElevatedButton(\n  onPressed: null,  // null = disabled\n  child: Text('Disabled'),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "InkWell - Make Anything Clickable",
              "content": "\n`InkWell` wraps any widget and makes it respond to taps with a Material ripple effect. Use it when you need custom-looking buttons or tappable containers.\n\n`GestureDetector` is similar but without the ripple. Choose `InkWell` for Material design, `GestureDetector` for custom effects:\n\n",
              "code": "InkWell(\n  onTap: () {\n    print('Container tapped!');\n  },\n  child: Container(\n    padding: EdgeInsets.all(20),\n    color: Colors.blue,\n    child: Text('Tap me', style: TextStyle(color: Colors.white)),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nButtons let users trigger actions. But what about **getting INPUT** from users? Next: Text fields!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.1-challenge-0",
              "title": "Button Types Challenge",
              "description": "Create an app with: 1. At least 5 different button types 2. Each button with different styling 3. Buttons that print different messages 4. One disabled button ---",
              "instructions": "Create an app with: 1. At least 5 different button types 2. Each button with different styling 3. Buttons that print different messages 4. One disabled button ---",
              "starterCode": "// Button Showcase Challenge\n// Create an app with different button types\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ButtonShowcaseApp());\n}\n\nclass ButtonShowcaseApp extends StatelessWidget {\n  const ButtonShowcaseApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Button Types')),\n        body: const ButtonShowcase(),\n      ),\n    );\n  }\n}\n\nclass ButtonShowcase extends StatelessWidget {\n  const ButtonShowcase({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SingleChildScrollView(\n      padding: const EdgeInsets.all(16),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.stretch,\n        children: [\n          // TODO 1: ElevatedButton - Primary action\n          ElevatedButton(\n            onPressed: () => print('Elevated pressed'),\n            child: const Text('Elevated Button'),\n          ),\n          const SizedBox(height: 16),\n          \n          // TODO 2: TextButton - Secondary action\n          \n          // TODO 3: OutlinedButton - Tertiary action\n          \n          // TODO 4: IconButton - Icon-only\n          \n          // TODO 5: Disabled button (onPressed: null)\n        ],\n      ),\n    );\n  }\n}",
              "solution": "// Solution: Button Showcase App\n// Demonstrates 5+ button types with different styles\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ButtonShowcaseApp());\n}\n\nclass ButtonShowcaseApp extends StatelessWidget {\n  const ButtonShowcaseApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Button Types')),\n        body: const ButtonShowcase(),\n      ),\n    );\n  }\n}\n\nclass ButtonShowcase extends StatelessWidget {\n  const ButtonShowcase({super.key});\n\n  void _showMessage(BuildContext context, String message) {\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text(message), duration: const Duration(seconds: 1)),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SingleChildScrollView(\n      padding: const EdgeInsets.all(16),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.stretch,\n        children: [\n          // 1. ElevatedButton - Primary action\n          ElevatedButton(\n            onPressed: () => _showMessage(context, 'ElevatedButton pressed!'),\n            style: ElevatedButton.styleFrom(\n              backgroundColor: Colors.blue,\n              foregroundColor: Colors.white,\n              padding: const EdgeInsets.all(16),\n            ),\n            child: const Text('Elevated Button'),\n          ),\n          const SizedBox(height: 16),\n          \n          // 2. TextButton - Secondary action\n          TextButton(\n            onPressed: () => _showMessage(context, 'TextButton pressed!'),\n            style: TextButton.styleFrom(\n              foregroundColor: Colors.purple,\n            ),\n            child: const Text('Text Button'),\n          ),\n          const SizedBox(height: 16),\n          \n          // 3. OutlinedButton - Tertiary action\n          OutlinedButton(\n            onPressed: () => _showMessage(context, 'OutlinedButton pressed!'),\n            style: OutlinedButton.styleFrom(\n              side: const BorderSide(color: Colors.green, width: 2),\n              foregroundColor: Colors.green,\n            ),\n            child: const Text('Outlined Button'),\n          ),\n          const SizedBox(height: 16),\n          \n          // 4. IconButton - Icon-only action\n          Row(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              IconButton(\n                onPressed: () => _showMessage(context, 'Favorite pressed!'),\n                icon: const Icon(Icons.favorite),\n                color: Colors.red,\n                iconSize: 32,\n              ),\n              IconButton(\n                onPressed: () => _showMessage(context, 'Share pressed!'),\n                icon: const Icon(Icons.share),\n                color: Colors.blue,\n                iconSize: 32,\n              ),\n            ],\n          ),\n          const SizedBox(height: 16),\n          \n          // 5. FloatingActionButton style\n          Center(\n            child: FloatingActionButton.extended(\n              onPressed: () => _showMessage(context, 'FAB pressed!'),\n              icon: const Icon(Icons.add),\n              label: const Text('Add Item'),\n            ),\n          ),\n          const SizedBox(height: 16),\n          \n          // 6. Disabled button\n          ElevatedButton(\n            onPressed: null, // null makes it disabled\n            style: ElevatedButton.styleFrom(\n              disabledBackgroundColor: Colors.grey.shade300,\n            ),\n            child: const Text('Disabled Button'),\n          ),\n          const SizedBox(height: 16),\n          \n          // 7. Custom styled button\n          ElevatedButton(\n            onPressed: () => _showMessage(context, 'Custom button pressed!'),\n            style: ElevatedButton.styleFrom(\n              backgroundColor: Colors.orange,\n              foregroundColor: Colors.white,\n              shape: RoundedRectangleBorder(\n                borderRadius: BorderRadius.circular(20),\n              ),\n              elevation: 8,\n            ),\n            child: const Text('Custom Styled'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - ElevatedButton: Primary actions with elevation\n// - TextButton: Low-emphasis actions\n// - OutlinedButton: Medium-emphasis with border\n// - IconButton: Icon-only actions\n// - onPressed: null makes button disabled",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print() function to display output."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "4.2",
          "title": "Module 4, Lessons 2-3: Text Input and Forms",
          "moduleId": "module-04",
          "order": 2,
          "estimatedMinutes": 25,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Getting User Input",
              "content": "\nButtons trigger actions, but how do we get TEXT from users?\n- Login forms (username/password)\n- Search bars\n- Comments and messages\n- Registration forms\n\n**TextField** is the answer!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Reading TextField Value",
              "content": "\nTo read what the user typed, use a `TextEditingController`. It stores the current text and can also be used to programmatically set or clear the text.\n\n**Important:** Always call `dispose()` on controllers when done to free memory. This is a common source of memory leaks if forgotten:\n\n",
              "code": "class TextFieldDemo extends StatefulWidget {\n  @override\n  _TextFieldDemoState createState() => _TextFieldDemoState();\n}\n\nclass _TextFieldDemoState extends State<TextFieldDemo> {\n  TextEditingController nameController = TextEditingController();\n  \n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TextField(\n          controller: nameController,\n          decoration: InputDecoration(labelText: 'Name'),\n        ),\n        ElevatedButton(\n          onPressed: () {\n            String name = nameController.text;\n            print('Name: $name');\n          },\n          child: Text('Submit'),\n        ),\n      ],\n    );\n  }\n  \n  @override\n  void dispose() {\n    nameController.dispose();  // Clean up!\n    super.dispose();\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou can now get input from users! But how do we make the UI UPDATE when data changes? Next: **StatefulWidget and setState**!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.2-challenge-0",
              "title": "Search TextField Challenge",
              "description": "Create a search TextField with search icon that filters a list. ---",
              "instructions": "Create a search TextField with search icon that filters a list. ---",
              "starterCode": "// Search TextField Challenge\n// Create a TextField that filters a list in real-time\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const SearchApp());\n}\n\nclass SearchApp extends StatelessWidget {\n  const SearchApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Search Demo')),\n        body: const SearchScreen(),\n      ),\n    );\n  }\n}\n\nclass SearchScreen extends StatefulWidget {\n  const SearchScreen({super.key});\n\n  @override\n  State<SearchScreen> createState() => _SearchScreenState();\n}\n\nclass _SearchScreenState extends State<SearchScreen> {\n  // TODO: Create TextEditingController\n  final TextEditingController _searchController = TextEditingController();\n  \n  final List<String> allItems = [\n    'Apple', 'Banana', 'Cherry', 'Date', 'Elderberry',\n    'Fig', 'Grape', 'Honeydew', 'Kiwi', 'Lemon',\n  ];\n  \n  List<String> filteredItems = [];\n  \n  @override\n  void initState() {\n    super.initState();\n    filteredItems = allItems;\n    // TODO: Add listener to controller\n  }\n  \n  @override\n  void dispose() {\n    _searchController.dispose(); // Don't forget to dispose!\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // TODO: Add TextField with prefixIcon: Icon(Icons.search)\n        Padding(\n          padding: const EdgeInsets.all(16),\n          child: TextField(\n            controller: _searchController,\n            decoration: const InputDecoration(\n              hintText: 'Search...',\n              prefixIcon: Icon(Icons.search),\n            ),\n          ),\n        ),\n        \n        // TODO: Display filtered list with ListView.builder\n        Expanded(\n          child: ListView.builder(\n            itemCount: filteredItems.length,\n            itemBuilder: (context, index) {\n              return ListTile(title: Text(filteredItems[index]));\n            },\n          ),\n        ),\n      ],\n    );\n  }\n}",
              "solution": "// Solution: Search TextField with Filtering\n// Real-time search that filters a list of items\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const SearchApp());\n}\n\nclass SearchApp extends StatelessWidget {\n  const SearchApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Search Demo')),\n        body: const SearchScreen(),\n      ),\n    );\n  }\n}\n\nclass SearchScreen extends StatefulWidget {\n  const SearchScreen({super.key});\n\n  @override\n  State<SearchScreen> createState() => _SearchScreenState();\n}\n\nclass _SearchScreenState extends State<SearchScreen> {\n  final TextEditingController _searchController = TextEditingController();\n  \n  // Sample data\n  final List<String> allItems = [\n    'Apple', 'Banana', 'Cherry', 'Date', 'Elderberry',\n    'Fig', 'Grape', 'Honeydew', 'Kiwi', 'Lemon',\n    'Mango', 'Nectarine', 'Orange', 'Papaya', 'Quince',\n  ];\n  \n  List<String> filteredItems = [];\n  \n  @override\n  void initState() {\n    super.initState();\n    filteredItems = allItems; // Start with all items\n    _searchController.addListener(_onSearchChanged);\n  }\n  \n  @override\n  void dispose() {\n    _searchController.dispose();\n    super.dispose();\n  }\n  \n  void _onSearchChanged() {\n    final query = _searchController.text.toLowerCase();\n    setState(() {\n      if (query.isEmpty) {\n        filteredItems = allItems;\n      } else {\n        filteredItems = allItems\n            .where((item) => item.toLowerCase().contains(query))\n            .toList();\n      }\n    });\n  }\n  \n  void _clearSearch() {\n    _searchController.clear();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // Search TextField with icon\n        Padding(\n          padding: const EdgeInsets.all(16),\n          child: TextField(\n            controller: _searchController,\n            decoration: InputDecoration(\n              hintText: 'Search fruits...',\n              prefixIcon: const Icon(Icons.search),\n              suffixIcon: _searchController.text.isNotEmpty\n                  ? IconButton(\n                      icon: const Icon(Icons.clear),\n                      onPressed: _clearSearch,\n                    )\n                  : null,\n              border: OutlineInputBorder(\n                borderRadius: BorderRadius.circular(12),\n              ),\n              filled: true,\n              fillColor: Colors.grey.shade100,\n            ),\n          ),\n        ),\n        \n        // Results count\n        Padding(\n          padding: const EdgeInsets.symmetric(horizontal: 16),\n          child: Text(\n            'Found ${filteredItems.length} items',\n            style: TextStyle(color: Colors.grey.shade600),\n          ),\n        ),\n        const SizedBox(height: 8),\n        \n        // Filtered list\n        Expanded(\n          child: filteredItems.isEmpty\n              ? const Center(child: Text('No items found'))\n              : ListView.builder(\n                  itemCount: filteredItems.length,\n                  itemBuilder: (context, index) {\n                    return ListTile(\n                      leading: const Icon(Icons.local_grocery_store),\n                      title: Text(filteredItems[index]),\n                    );\n                  },\n                ),\n        ),\n      ],\n    );\n  }\n}\n\n// Key concepts:\n// - TextEditingController: Manages text input\n// - addListener: Responds to text changes\n// - where + contains: Filter list by search query\n// - prefixIcon/suffixIcon: Icons inside TextField\n// - dispose: Clean up controller",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "4.3",
          "title": "Module 4, Lesson 3: Gestures and Touch Interactions",
          "moduleId": "module-04",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Beyond Buttons",
              "content": "\nButtons are great, but apps need richer interactions:\n- **Swipe** to delete items\n- **Long press** for context menus\n- **Drag** items around\n- **Pinch** to zoom\n- **Double tap** to like\n\n**Flutter makes this easy with GestureDetector!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "The GestureDetector Widget",
              "content": "\nWrap ANY widget to make it detect gestures:\n\n\n",
              "code": "GestureDetector(\n  onTap: () {\n    print('Tapped!');\n  },\n  child: Container(\n    width: 200,\n    height: 200,\n    color: Colors.blue,\n    child: Center(child: Text('Tap Me')),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Tap vs InkWell",
              "content": "\n**GestureDetector**: No visual feedback\n**InkWell**: Material ripple effect\n\n\n**Best Practice**: Use InkWell for Material Design apps!\n\n",
              "code": "// No visual feedback\nGestureDetector(\n  onTap: () => print('Tap'),\n  child: Container(\n    color: Colors.blue,\n    padding: EdgeInsets.all(20),\n    child: Text('Tap Me'),\n  ),\n)\n\n// With ripple effect\nInkWell(\n  onTap: () => print('Tap'),\n  child: Container(\n    padding: EdgeInsets.all(20),\n    child: Text('Tap Me'),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Double Tap Example (Like Button)",
              "content": "\n\n**Instagram-style double-tap to like!**\n\n",
              "code": "class LikeableImage extends StatefulWidget {\n  @override\n  _LikeableImageState createState() => _LikeableImageState();\n}\n\nclass _LikeableImageState extends State<LikeableImage> {\n  bool isLiked = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onDoubleTap: () {\n        setState(() {\n          isLiked = !isLiked;\n        });\n      },\n      child: Stack(\n        alignment: Alignment.center,\n        children: [\n          Image.network(\n            'https://picsum.photos/400',\n            width: 400,\n            height: 400,\n            fit: BoxFit.cover,\n          ),\n          if (isLiked)\n            Icon(\n              Icons.favorite,\n              size: 100,\n              color: Colors.red.withOpacity(0.7),\n            ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Swipe to Dismiss",
              "content": "\n\n**Swipe left to delete - like iOS Mail!**\n\n",
              "code": "class SwipeableTodo extends StatelessWidget {\n  final List<String> todos = ['Buy milk', 'Walk dog', 'Code Flutter'];\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      itemCount: todos.length,\n      itemBuilder: (context, index) {\n        return Dismissible(\n          key: Key(todos[index]),\n          background: Container(\n            color: Colors.red,\n            alignment: Alignment.centerRight,\n            padding: EdgeInsets.only(right: 20),\n            child: Icon(Icons.delete, color: Colors.white),\n          ),\n          direction: DismissDirection.endToStart,\n          onDismissed: (direction) {\n            ScaffoldMessenger.of(context).showSnackBar(\n              SnackBar(content: Text('${todos[index]} deleted')),\n            );\n          },\n          child: ListTile(\n            leading: Icon(Icons.check_box_outline_blank),\n            title: Text(todos[index]),\n          ),\n        );\n      },\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Haptic Feedback",
              "content": "\nAdd tactile feedback for better UX:\n\n\n",
              "code": "import 'package:flutter/services.dart';\n\nGestureDetector(\n  onTap: () {\n    HapticFeedback.lightImpact();  // Subtle vibration\n    print('Tapped!');\n  },\n  onLongPress: () {\n    HapticFeedback.heavyImpact();  // Stronger vibration\n    print('Long pressed!');\n  },\n  child: YourWidget(),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Gesture Priority",
              "content": "\n**Problem**: What if you have overlapping gestures?\n\n\n**Result**: Only \"Child tap\" prints (child wins)\n\nTo allow parent to handle: Use `behavior: HitTestBehavior.translucent`\n\n",
              "code": "GestureDetector(\n  onTap: () => print('Parent tap'),\n  child: Container(\n    color: Colors.blue,\n    padding: EdgeInsets.all(50),\n    child: GestureDetector(\n      onTap: () => print('Child tap'),\n      child: Container(\n        color: Colors.red,\n        width: 100,\n        height: 100,\n      ),\n    ),\n  ),\n)",
              "language": "dart"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: No visual feedback\n\n‚úÖ **Fix**: Use InkWell or change colors on tap\n\n‚ùå **Mistake 2**: Forgetting setState in gesture handlers\n\n‚úÖ **Fix**: Always use setState\n\n",
              "code": "onTap: () {\n  setState(() {\n    isLiked = !isLiked;\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ GestureDetector for custom touch handling\n- ‚úÖ Tap, double tap, long press, drag gestures\n- ‚úÖ InkWell for Material ripple effects\n- ‚úÖ Dismissible for swipe-to-delete\n- ‚úÖ Haptic feedback for better UX\n- ‚úÖ Building Instagram-style interactions\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've mastered buttons, forms, state, and gestures! Next up: **Navigation and Routing** - how to build multi-screen apps!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.3-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a 3x3 grid where tiles can be dragged to reorder. ---",
              "instructions": "Create a 3x3 grid where tiles can be dragged to reorder. ---",
              "starterCode": "// Draggable Grid Challenge\n// Create tiles that can be dragged and dropped\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const DraggableGridApp());\n}\n\nclass DraggableGridApp extends StatelessWidget {\n  const DraggableGridApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Drag to Reorder')),\n        body: const DraggableGrid(),\n      ),\n    );\n  }\n}\n\nclass DraggableGrid extends StatefulWidget {\n  const DraggableGrid({super.key});\n\n  @override\n  State<DraggableGrid> createState() => _DraggableGridState();\n}\n\nclass _DraggableGridState extends State<DraggableGrid> {\n  List<int> tiles = List.generate(9, (i) => i + 1);\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(16),\n      child: GridView.builder(\n        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(\n          crossAxisCount: 3,\n          crossAxisSpacing: 8,\n          mainAxisSpacing: 8,\n        ),\n        itemCount: tiles.length,\n        itemBuilder: (context, index) {\n          final tile = tiles[index];\n          // TODO: Wrap with DragTarget and Draggable\n          // Draggable<int> for dragging\n          // DragTarget<int> for dropping\n          return Container(\n            decoration: BoxDecoration(\n              color: Colors.primaries[tile % Colors.primaries.length],\n              borderRadius: BorderRadius.circular(12),\n            ),\n            child: Center(\n              child: Text(\n                '$tile',\n                style: const TextStyle(color: Colors.white, fontSize: 24),\n              ),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}",
              "solution": "// Solution: Draggable 3x3 Grid\n// Tiles can be dragged and dropped to reorder\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const DraggableGridApp());\n}\n\nclass DraggableGridApp extends StatelessWidget {\n  const DraggableGridApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Drag to Reorder')),\n        body: const DraggableGrid(),\n      ),\n    );\n  }\n}\n\nclass DraggableGrid extends StatefulWidget {\n  const DraggableGrid({super.key});\n\n  @override\n  State<DraggableGrid> createState() => _DraggableGridState();\n}\n\nclass _DraggableGridState extends State<DraggableGrid> {\n  // 9 tiles for 3x3 grid\n  List<int> tiles = List.generate(9, (i) => i + 1);\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(16),\n      child: GridView.builder(\n        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(\n          crossAxisCount: 3,\n          crossAxisSpacing: 8,\n          mainAxisSpacing: 8,\n        ),\n        itemCount: tiles.length,\n        itemBuilder: (context, index) {\n          final tile = tiles[index];\n          return DragTarget<int>(\n            onAcceptWithDetails: (details) {\n              setState(() {\n                final draggedIndex = tiles.indexOf(details.data);\n                tiles.removeAt(draggedIndex);\n                tiles.insert(index, details.data);\n              });\n            },\n            builder: (context, candidateData, rejectedData) {\n              final isHighlighted = candidateData.isNotEmpty;\n              return Draggable<int>(\n                data: tile,\n                feedback: Material(\n                  elevation: 8,\n                  borderRadius: BorderRadius.circular(12),\n                  child: _buildTile(tile, isDragging: true),\n                ),\n                childWhenDragging: Container(\n                  decoration: BoxDecoration(\n                    color: Colors.grey.shade200,\n                    borderRadius: BorderRadius.circular(12),\n                    border: Border.all(color: Colors.grey, style: BorderStyle.solid),\n                  ),\n                ),\n                child: AnimatedContainer(\n                  duration: const Duration(milliseconds: 200),\n                  decoration: BoxDecoration(\n                    color: isHighlighted ? Colors.blue.shade100 : null,\n                    borderRadius: BorderRadius.circular(12),\n                  ),\n                  child: _buildTile(tile),\n                ),\n              );\n            },\n          );\n        },\n      ),\n    );\n  }\n\n  Widget _buildTile(int number, {bool isDragging = false}) {\n    return Container(\n      width: 100,\n      height: 100,\n      decoration: BoxDecoration(\n        color: Colors.primaries[number % Colors.primaries.length],\n        borderRadius: BorderRadius.circular(12),\n        boxShadow: isDragging\n            ? [BoxShadow(color: Colors.black26, blurRadius: 10)]\n            : null,\n      ),\n      child: Center(\n        child: Text(\n          '$number',\n          style: const TextStyle(\n            color: Colors.white,\n            fontSize: 32,\n            fontWeight: FontWeight.bold,\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - Draggable: Makes widget draggable\n// - DragTarget: Accepts dropped items\n// - feedback: Widget shown while dragging\n// - childWhenDragging: Placeholder at original position\n// - onAcceptWithDetails: Handle drop and reorder list",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "4.4",
          "title": "Module 4, Lessons 4-5: StatefulWidget and Managing State",
          "moduleId": "module-04",
          "order": 4,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Update Problem",
              "content": "\nRight now, your apps are **static**. When you click a button, nothing changes on screen!\n\nTry this - it WON'T work:\n\n\n**Problem**: The screen doesn't know to rebuild!\n\n**Solution**: **StatefulWidget** and **setState()**!\n\n",
              "code": "class CounterBroken extends StatelessWidget {\n  int counter = 0;  // This won't update the UI!\n  \n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text('Count: $counter'),\n        ElevatedButton(\n          onPressed: () {\n            counter++;  // Changes variable but UI doesn't rebuild!\n            print(counter);  // Console shows it changes\n          },\n          child: Text('Increment'),\n        ),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First StatefulWidget",
              "content": "\n\n**Now it works!** Click the button and the number updates!\n\n",
              "code": "class Counter extends StatefulWidget {\n  @override\n  _CounterState createState() => _CounterState();\n}\n\nclass _CounterState extends State<Counter> {\n  int counter = 0;\n  \n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text('Count: $counter', style: TextStyle(fontSize: 48)),\n        ElevatedButton(\n          onPressed: () {\n            setState(() {\n              counter++;  // setState tells Flutter to rebuild!\n            });\n          },\n          child: Text('Increment'),\n        ),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Understanding StatefulWidget",
              "content": "\n**Two classes work together:**\n\n1. **Widget class** (`Counter`) - Immutable configuration\n2. **State class** (`_CounterState`) - Mutable state\n\n**Why?** Widgets rebuild often. State persists across rebuilds.\n\n"
            },
            {
              "type": "THEORY",
              "title": "The setState() Magic",
              "content": "\n\n**What setState does:**\n1. Runs the code inside  \n2. Marks widget as \"dirty\"\n3. Schedules a rebuild\n4. Calls `build()` again with new values\n\n",
              "code": "setState(() {\n  // Make changes here\n  counter++;\n  name = 'New Name';\n  isVisible = !isVisible;\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ StatelessWidget for static content\n- ‚úÖ StatefulWidget for dynamic content\n- ‚úÖ setState() triggers rebuilds\n- ‚úÖ State persists across rebuilds\n- ‚úÖ Lifecycle methods (initState, dispose)\n- ‚úÖ Managing lists, toggles, counters\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\n**Module 5: State Management!**\n\nsetState works great for simple apps. But what about:\n- Sharing data between screens?\n- Complex app state?\n- Better organization?\n\nNext module: **Provider, Riverpod, and professional state management**!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.4-challenge-0",
              "title": "Practice Challenge",
              "description": "Create a contact form that shows/hides error messages. ---",
              "instructions": "Create a contact form that shows/hides error messages. ---",
              "starterCode": "// Contact Form Challenge\n// Create a form with validation\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ContactFormApp());\n}\n\nclass ContactFormApp extends StatelessWidget {\n  const ContactFormApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Contact Form')),\n        body: const ContactForm(),\n      ),\n    );\n  }\n}\n\nclass ContactForm extends StatefulWidget {\n  const ContactForm({super.key});\n\n  @override\n  State<ContactForm> createState() => _ContactFormState();\n}\n\nclass _ContactFormState extends State<ContactForm> {\n  // TODO: Create GlobalKey<FormState> for form validation\n  final _formKey = GlobalKey<FormState>();\n  \n  final _nameController = TextEditingController();\n  final _emailController = TextEditingController();\n\n  @override\n  void dispose() {\n    _nameController.dispose();\n    _emailController.dispose();\n    super.dispose();\n  }\n\n  // TODO: Create validator functions that return error message or null\n  String? _validateName(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Please enter your name';\n    }\n    return null;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SingleChildScrollView(\n      padding: const EdgeInsets.all(16),\n      child: Form(\n        key: _formKey,\n        child: Column(\n          children: [\n            // TODO: Use TextFormField with validator property\n            TextFormField(\n              controller: _nameController,\n              decoration: const InputDecoration(\n                labelText: 'Name',\n                border: OutlineInputBorder(),\n              ),\n              validator: _validateName,\n            ),\n            const SizedBox(height: 16),\n            \n            // TODO: Add email field with email validation\n            \n            ElevatedButton(\n              onPressed: () {\n                // TODO: Call _formKey.currentState!.validate()\n              },\n              child: const Text('Submit'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "solution": "// Solution: Contact Form with Validation\n// Shows/hides error messages based on input validation\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ContactFormApp());\n}\n\nclass ContactFormApp extends StatelessWidget {\n  const ContactFormApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Contact Form')),\n        body: const ContactForm(),\n      ),\n    );\n  }\n}\n\nclass ContactForm extends StatefulWidget {\n  const ContactForm({super.key});\n\n  @override\n  State<ContactForm> createState() => _ContactFormState();\n}\n\nclass _ContactFormState extends State<ContactForm> {\n  final _formKey = GlobalKey<FormState>();\n  final _nameController = TextEditingController();\n  final _emailController = TextEditingController();\n  final _messageController = TextEditingController();\n\n  @override\n  void dispose() {\n    _nameController.dispose();\n    _emailController.dispose();\n    _messageController.dispose();\n    super.dispose();\n  }\n\n  String? _validateName(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Please enter your name';\n    }\n    if (value.length < 2) {\n      return 'Name must be at least 2 characters';\n    }\n    return null;\n  }\n\n  String? _validateEmail(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Please enter your email';\n    }\n    final emailRegex = RegExp(r'^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$');\n    if (!emailRegex.hasMatch(value)) {\n      return 'Please enter a valid email';\n    }\n    return null;\n  }\n\n  String? _validateMessage(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Please enter a message';\n    }\n    if (value.length < 10) {\n      return 'Message must be at least 10 characters';\n    }\n    return null;\n  }\n\n  void _submitForm() {\n    if (_formKey.currentState!.validate()) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(\n          content: Text('Form submitted successfully!'),\n          backgroundColor: Colors.green,\n        ),\n      );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SingleChildScrollView(\n      padding: const EdgeInsets.all(16),\n      child: Form(\n        key: _formKey,\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // Name field\n            TextFormField(\n              controller: _nameController,\n              decoration: const InputDecoration(\n                labelText: 'Name',\n                prefixIcon: Icon(Icons.person),\n                border: OutlineInputBorder(),\n              ),\n              validator: _validateName,\n              autovalidateMode: AutovalidateMode.onUserInteraction,\n            ),\n            const SizedBox(height: 16),\n            \n            // Email field\n            TextFormField(\n              controller: _emailController,\n              decoration: const InputDecoration(\n                labelText: 'Email',\n                prefixIcon: Icon(Icons.email),\n                border: OutlineInputBorder(),\n              ),\n              keyboardType: TextInputType.emailAddress,\n              validator: _validateEmail,\n              autovalidateMode: AutovalidateMode.onUserInteraction,\n            ),\n            const SizedBox(height: 16),\n            \n            // Message field\n            TextFormField(\n              controller: _messageController,\n              decoration: const InputDecoration(\n                labelText: 'Message',\n                prefixIcon: Icon(Icons.message),\n                border: OutlineInputBorder(),\n                alignLabelWithHint: true,\n              ),\n              maxLines: 4,\n              validator: _validateMessage,\n              autovalidateMode: AutovalidateMode.onUserInteraction,\n            ),\n            const SizedBox(height: 24),\n            \n            // Submit button\n            ElevatedButton(\n              onPressed: _submitForm,\n              style: ElevatedButton.styleFrom(\n                padding: const EdgeInsets.all(16),\n              ),\n              child: const Text('Submit'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - Form + GlobalKey: Manages form state\n// - TextFormField: Input with built-in validation\n// - validator: Returns error message or null\n// - autovalidateMode: When to show errors\n// - validate(): Checks all fields and shows errors",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "4.5",
          "title": "Module 4, Mini-Project: Interactive Notes App",
          "moduleId": "module-04",
          "order": 5,
          "estimatedMinutes": 40,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\nBuild a complete **Notes App** with all Module 4 concepts:\n- ‚úÖ Buttons (FAB, IconButton, ElevatedButton)\n- ‚úÖ Forms and text input\n- ‚úÖ StatefulWidget and setState\n- ‚úÖ Gestures (swipe to delete, long press menu)\n\n**You'll build a real, production-quality app!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Features",
              "content": "\n1. **Add notes** with title and content\n2. **Edit existing notes**\n3. **Delete notes** with swipe gesture\n4. **Color-code notes**\n5. **Long press** for quick actions\n6. **Search notes**\n7. **Persistent state** (data survives app restart)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Features Walkthrough",
              "content": "\n### 1. Search Notes\n- Real-time filtering as you type\n- Searches both title and content\n\n### 2. Swipe to Delete\n- Swipe left on any note\n- Shows red delete background\n- Includes UNDO option\n\n### 3. Long Press Menu\n- Long press any note\n- Shows bottom sheet with options:\n  - Edit\n  - Change Color\n  - Share\n  - Delete\n\n### 4. Color Coding\n- 7 different colors\n- Visual organization\n- Tap to change\n\n### 5. Empty State\n- Beautiful placeholder when no notes\n- Clear call-to-action\n\n"
            },
            {
              "type": "THEORY",
              "title": "Enhancement Ideas",
              "content": "\nWant to make it even better? Add these:\n\n### 1. Persistent Storage\n\n### 2. Categories/Tags\nAdd a category field to Note model and filter by category.\n\n### 3. Voice Input\nUse speech_to_text package for voice notes.\n\n### 4. Rich Text Formatting\nBold, italic, bullet points using a rich text editor package.\n\n### 5. Pin Important Notes\nAdd a `isPinned` field and show pinned notes at top.\n\n",
              "code": "import 'package:shared_preferences/shared_preferences.dart';\n\nFuture<void> _saveNotes() async {\n  final prefs = await SharedPreferences.getInstance();\n  final notesJson = notes.map((n) => n.toJson()).toList();\n  await prefs.setString('notes', jsonEncode(notesJson));\n}\n\nFuture<void> _loadNotes() async {\n  final prefs = await SharedPreferences.getInstance();\n  final notesString = prefs.getString('notes');\n  if (notesString != null) {\n    final List<dynamic> notesJson = jsonDecode(notesString);\n    notes = notesJson.map((json) => Note.fromJson(json)).toList();\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nThis project combined EVERYTHING from Module 4:\n- ‚úÖ Multiple button types (FAB, IconButton)\n- ‚úÖ Text input with TextEditingController\n- ‚úÖ Forms and validation\n- ‚úÖ StatefulWidget with complex state\n- ‚úÖ Gestures (tap, long press, swipe)\n- ‚úÖ Navigation between screens\n- ‚úÖ Material Design components\n- ‚úÖ Real-world app architecture\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\n**Module 5: State Management**\n\nYour notes app works, but what if you want to:\n- Share data between screens more elegantly?\n- Separate business logic from UI?\n- Make state management scalable?\n\nNext module: **Provider, Riverpod, and professional state management patterns!**\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "4.5-challenge-0",
              "title": "Notes Statistics Challenge",
              "description": "Show total notes count, character count, and most recent update.",
              "instructions": "Build a Notes app that displays statistics: total note count, total characters across all notes, and when the most recent update occurred. Use computed properties (getters) to calculate statistics dynamically.",
              "starterCode": "// Notes Statistics Challenge\n// Display stats: note count, total characters, last update\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const NotesApp());\n}\n\nclass NotesApp extends StatelessWidget {\n  const NotesApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Notes')),\n        body: const NotesScreen(),\n      ),\n    );\n  }\n}\n\nclass Note {\n  final String id;\n  final String title;\n  final String content;\n  final DateTime updatedAt;\n\n  Note({\n    required this.id,\n    required this.title,\n    required this.content,\n    required this.updatedAt,\n  });\n}\n\nclass NotesScreen extends StatefulWidget {\n  const NotesScreen({super.key});\n\n  @override\n  State<NotesScreen> createState() => _NotesScreenState();\n}\n\nclass _NotesScreenState extends State<NotesScreen> {\n  final List<Note> notes = [\n    Note(id: '1', title: 'Shopping', content: 'Milk, eggs, bread', updatedAt: DateTime.now().subtract(const Duration(hours: 2))),\n    Note(id: '2', title: 'Meeting', content: 'Discuss Q4 goals', updatedAt: DateTime.now()),\n  ];\n\n  // TODO 1: Create getter 'totalNotes' that returns notes.length\n  \n  // TODO 2: Create getter 'totalCharacters' using fold()\n  // Hint: notes.fold(0, (sum, note) => sum + note.title.length + note.content.length)\n  \n  // TODO 3: Create getter 'mostRecentUpdate' that returns a String\n  // Use reduce() to find the note with latest updatedAt\n  // Format as 'Just now', 'Xm ago', 'Xh ago', or 'Xd ago'\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // TODO 4: Build a statistics Card\n        Card(\n          margin: const EdgeInsets.all(16),\n          child: Padding(\n            padding: const EdgeInsets.all(16),\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: [\n                // TODO: Add stat columns for Notes, Characters, Updated\n                // Use _buildStat helper method\n              ],\n            ),\n          ),\n        ),\n        \n        // Notes list\n        Expanded(\n          child: ListView.builder(\n            itemCount: notes.length,\n            itemBuilder: (context, index) {\n              final note = notes[index];\n              return ListTile(\n                title: Text(note.title),\n                subtitle: Text(note.content, maxLines: 1, overflow: TextOverflow.ellipsis),\n              );\n            },\n          ),\n        ),\n      ],\n    );\n  }\n\n  // Helper to build a stat column\n  Widget _buildStat(String label, String value, IconData icon) {\n    return Column(\n      children: [\n        Icon(icon, color: Colors.blue),\n        const SizedBox(height: 4),\n        Text(value, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18)),\n        Text(label, style: TextStyle(color: Colors.grey.shade600, fontSize: 12)),\n      ],\n    );\n  }\n}",
              "solution": "// Solution: Notes App with Statistics\n// Displays note count, character count, and last update time\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const NotesApp());\n}\n\nclass NotesApp extends StatelessWidget {\n  const NotesApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Notes')),\n        body: const NotesScreen(),\n      ),\n    );\n  }\n}\n\nclass Note {\n  final String id;\n  final String title;\n  final String content;\n  final DateTime updatedAt;\n\n  Note({\n    required this.id,\n    required this.title,\n    required this.content,\n    required this.updatedAt,\n  });\n}\n\nclass NotesScreen extends StatefulWidget {\n  const NotesScreen({super.key});\n\n  @override\n  State<NotesScreen> createState() => _NotesScreenState();\n}\n\nclass _NotesScreenState extends State<NotesScreen> {\n  final List<Note> notes = [\n    Note(id: '1', title: 'Shopping List', content: 'Milk, eggs, bread, butter', updatedAt: DateTime.now().subtract(const Duration(hours: 2))),\n    Note(id: '2', title: 'Meeting Notes', content: 'Discuss Q4 goals and project timeline', updatedAt: DateTime.now().subtract(const Duration(days: 1))),\n    Note(id: '3', title: 'Ideas', content: 'Build a Flutter app with notes and todos', updatedAt: DateTime.now()),\n  ];\n\n  // Calculate statistics\n  int get totalNotes => notes.length;\n  \n  int get totalCharacters => notes.fold(0, (sum, note) => sum + note.title.length + note.content.length);\n  \n  String get mostRecentUpdate {\n    if (notes.isEmpty) return 'No notes';\n    final latest = notes.reduce((a, b) => a.updatedAt.isAfter(b.updatedAt) ? a : b);\n    final diff = DateTime.now().difference(latest.updatedAt);\n    if (diff.inMinutes < 1) return 'Just now';\n    if (diff.inHours < 1) return '${diff.inMinutes}m ago';\n    if (diff.inDays < 1) return '${diff.inHours}h ago';\n    return '${diff.inDays}d ago';\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // Statistics Card\n        Card(\n          margin: const EdgeInsets.all(16),\n          child: Padding(\n            padding: const EdgeInsets.all(16),\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: [\n                _buildStat('Notes', '$totalNotes', Icons.note),\n                _buildStat('Characters', '$totalCharacters', Icons.text_fields),\n                _buildStat('Updated', mostRecentUpdate, Icons.access_time),\n              ],\n            ),\n          ),\n        ),\n        \n        // Notes List\n        Expanded(\n          child: ListView.builder(\n            itemCount: notes.length,\n            itemBuilder: (context, index) {\n              final note = notes[index];\n              return ListTile(\n                title: Text(note.title),\n                subtitle: Text(\n                  note.content,\n                  maxLines: 1,\n                  overflow: TextOverflow.ellipsis,\n                ),\n                trailing: Text(\n                  _formatTime(note.updatedAt),\n                  style: TextStyle(color: Colors.grey.shade600, fontSize: 12),\n                ),\n              );\n            },\n          ),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildStat(String label, String value, IconData icon) {\n    return Column(\n      children: [\n        Icon(icon, color: Colors.blue),\n        const SizedBox(height: 4),\n        Text(value, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18)),\n        Text(label, style: TextStyle(color: Colors.grey.shade600, fontSize: 12)),\n      ],\n    );\n  }\n\n  String _formatTime(DateTime dt) {\n    return '${dt.hour}:${dt.minute.toString().padLeft(2, '0')}';\n  }\n}\n\n// Key concepts:\n// - Computed properties (getters) for statistics\n// - fold: Aggregate values across list\n// - reduce: Find max/min in list\n// - Duration: Calculate time differences\n// - DateTime: Work with dates and times",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-05",
      "title": "Module 5: MVVM Architecture with Riverpod",
      "description": "Learn professional app architecture with the MVVM pattern and Riverpod state management. Structure your code for maintainability, testability, and team collaboration.",
      "difficulty": "intermediate",
      "estimatedHours": 12,
      "lessons": [
        {
          "id": "5.1",
          "title": "Why Architecture Matters",
          "moduleId": "module-05",
          "order": 1,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Spaghetti Code Problem",
              "content": "Imagine you are building a house. Would you start by randomly placing bricks, wires, and pipes wherever they fit? Of course not! You would follow a blueprint that tells you exactly where everything goes. The foundation comes first, then the frame, then the walls, and finally the finishing touches.\n\n**Software is exactly the same.** Without a plan (architecture), your code becomes a tangled mess that is impossible to maintain. This messy code has a name: **spaghetti code**.\n\n### What Does Spaghetti Code Look Like?\n\nHere is a real example of code that looks simple but hides serious problems. This widget does EVERYTHING in one place: fetches data from an API, manages loading states, handles errors, AND builds the UI.",
              "code": "// BAD: Everything mixed together in one widget\nclass UserProfileScreen extends StatefulWidget {\n  @override\n  State<UserProfileScreen> createState() => _UserProfileScreenState();\n}\n\nclass _UserProfileScreenState extends State<UserProfileScreen> {\n  // State variables mixed with UI logic\n  Map<String, dynamic>? userData;\n  bool isLoading = true;\n  String? errorMessage;\n  bool isEditing = false;\n  final nameController = TextEditingController();\n\n  @override\n  void initState() {\n    super.initState();\n    _loadUser();  // API call directly in widget!\n  }\n\n  // API logic mixed into the widget\n  Future<void> _loadUser() async {\n    setState(() => isLoading = true);\n    try {\n      // Direct HTTP call - no separation!\n      final response = await http.get(\n        Uri.parse('https://api.example.com/users/123'),\n      );\n      if (response.statusCode == 200) {\n        setState(() {\n          userData = jsonDecode(response.body);\n          isLoading = false;\n        });\n      } else {\n        setState(() {\n          errorMessage = 'Failed to load user';\n          isLoading = false;\n        });\n      }\n    } catch (e) {\n      setState(() {\n        errorMessage = e.toString();\n        isLoading = false;\n      });\n    }\n  }\n\n  // More API logic in the same file\n  Future<void> _saveUser() async {\n    setState(() => isLoading = true);\n    try {\n      await http.put(\n        Uri.parse('https://api.example.com/users/123'),\n        body: jsonEncode({'name': nameController.text}),\n      );\n      await _loadUser();  // Reload after save\n    } catch (e) {\n      setState(() => errorMessage = e.toString());\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // UI code mixed with all the logic above\n    if (isLoading) return CircularProgressIndicator();\n    if (errorMessage != null) return Text(errorMessage!);\n    \n    return Column(\n      children: [\n        Text(userData?['name'] ?? ''),\n        TextField(controller: nameController),\n        ElevatedButton(\n          onPressed: _saveUser,\n          child: Text('Save'),\n        ),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Why Is This Code Problematic?",
              "content": "That code above might seem fine for a small app. But as your app grows, these problems become nightmares:\n\n### Problem 1: Impossible to Test\nHow do you test if the UI displays correctly? You cannot, because testing the UI means also calling the real API! You cannot test pieces in isolation.\n\n### Problem 2: Changes Break Everything\nIf the API changes its URL or response format, you must hunt through every widget that makes that call. Miss one? Your app crashes.\n\n### Problem 3: Code Duplication\nNeed user data on another screen? You copy-paste the same loading logic. Now you have the same code in 5 places, and a bug fix requires changing all 5.\n\n### Problem 4: Hard to Understand\nNew team members cannot understand what the code does. Is this a UI file? An API file? A data file? It is all three, which makes it none of them properly.\n\n### Problem 5: Team Collaboration Is Difficult\nTwo developers cannot work on the same screen. One is changing the UI, another is fixing an API bug. Their changes conflict because everything is in one file.\n\n**The house analogy applies here:** If your plumber, electrician, and painter all work in the same room at the same time with no plan, chaos ensues. Architecture gives each person (or piece of code) a clear job and boundary."
            },
            {
              "type": "THEORY",
              "title": "What is Architecture?",
              "content": "**Architecture** is how you organize your code into separate layers, where each layer has ONE clear responsibility. This principle is called **Separation of Concerns**.\n\nLet us take that messy example and see how architecture transforms it:\n\n### Layer 1: Model (Data)\nDefines WHAT data looks like. Nothing else.\n\n### Layer 2: Repository (Data Access)\nKnows HOW to get and save data. Handles API calls, database operations, caching.\n\n### Layer 3: ViewModel (Business Logic)\nDecides WHAT to do with data. Handles loading states, validation, transformations.\n\n### Layer 4: View (UI)\nShows data to users. Handles ONLY visual presentation.\n\nHere is the same user profile, properly architected:",
              "code": "// LAYER 1: MODEL - Just data, nothing else\nclass User {\n  final String id;\n  final String name;\n  final String email;\n\n  User({required this.id, required this.name, required this.email});\n\n  // Factory to create from JSON\n  factory User.fromJson(Map<String, dynamic> json) {\n    return User(\n      id: json['id'],\n      name: json['name'],\n      email: json['email'],\n    );\n  }\n\n  // Convert back to JSON\n  Map<String, dynamic> toJson() {\n    return {'id': id, 'name': name, 'email': email};\n  }\n}\n\n// LAYER 2: REPOSITORY - Handles data fetching\nclass UserRepository {\n  final String baseUrl = 'https://api.example.com';\n\n  Future<User> getUser(String id) async {\n    final response = await http.get(Uri.parse('$baseUrl/users/$id'));\n    if (response.statusCode == 200) {\n      return User.fromJson(jsonDecode(response.body));\n    }\n    throw Exception('Failed to load user');\n  }\n\n  Future<void> updateUser(User user) async {\n    await http.put(\n      Uri.parse('$baseUrl/users/${user.id}'),\n      body: jsonEncode(user.toJson()),\n    );\n  }\n}\n\n// LAYER 3: VIEWMODEL - Manages state and logic\n// (Using Riverpod - we will learn this soon!)\n@riverpod\nclass UserViewModel extends _$UserViewModel {\n  @override\n  Future<User> build(String userId) async {\n    final repository = ref.read(userRepositoryProvider);\n    return repository.getUser(userId);\n  }\n\n  Future<void> updateName(String newName) async {\n    final user = await future;\n    final updatedUser = User(\n      id: user.id,\n      name: newName,\n      email: user.email,\n    );\n    final repository = ref.read(userRepositoryProvider);\n    await repository.updateUser(updatedUser);\n    ref.invalidateSelf();  // Refresh data\n  }\n}\n\n// LAYER 4: VIEW - Only UI, no logic\nclass UserProfileScreen extends ConsumerWidget {\n  final String userId;\n  const UserProfileScreen({required this.userId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userViewModelProvider(userId));\n\n    return userAsync.when(\n      loading: () => CircularProgressIndicator(),\n      error: (err, _) => Text('Error: $err'),\n      data: (user) => Column(\n        children: [\n          Text(user.name),\n          Text(user.email),\n          ElevatedButton(\n            onPressed: () => ref\n                .read(userViewModelProvider(userId).notifier)\n                .updateName('New Name'),\n            child: Text('Update'),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Why This Matters For Your Career",
              "content": "Architecture is not just about writing clean code. It directly impacts your career as a Flutter developer:\n\n### 1. Professional Teams EXPECT Architecture\nEvery serious company uses architecture patterns. If you join a team and start writing everything in one widget, you will get feedback in your first code review. Companies use architecture because it lets teams of 5, 50, or 500 developers work on the same codebase without stepping on each other.\n\n### 2. Interview Questions Test This\nSenior Flutter roles always ask architecture questions:\n- How do you separate business logic from UI?\n- How do you structure a large Flutter app?\n- How do you make your code testable?\n- What patterns do you use for state management?\n\nIf you cannot answer these questions confidently, you will not pass technical interviews for mid-level and senior positions.\n\n### 3. Architecture Makes YOU Faster\nThis might seem counterintuitive. Writing more files seems slower, right? Wrong!\n\nWith architecture:\n- Finding bugs takes minutes, not hours (you know exactly where to look)\n- Adding features is predictable (follow the pattern)\n- Refactoring is safe (tests catch issues)\n- You can work on the UI while the API changes\n\nThe time you invest in architecture pays back 10x as your app grows."
            },
            {
              "type": "THEORY",
              "title": "Architecture Patterns Overview",
              "content": "There are several popular architecture patterns in Flutter. Here is how they compare:\n\n| Pattern | Complexity | Best For | Learning Curve |\n|---------|------------|----------|----------------|\n| **No Architecture** | None | Tiny apps, prototypes | None |\n| **MVVM** | Medium | Most apps | Medium |\n| **Clean Architecture** | High | Large enterprise apps | Steep |\n| **BLoC** | Medium-High | Event-driven apps | Medium |\n\n### Why This Course Teaches MVVM\n\n**MVVM (Model-View-ViewModel)** hits the sweet spot:\n- **Simple enough** to learn quickly and apply immediately\n- **Powerful enough** for real production apps\n- **Industry standard** used by thousands of Flutter apps\n- **Pairs perfectly** with Riverpod for state management\n\nMVVM is not dumbed-down architecture. It is what companies like Google, Meta, and thousands of startups use daily.\n\n### What About Clean Architecture?\n\nClean Architecture adds more layers (Use Cases, Entities, etc.). It is excellent for very large apps with multiple teams. However, for most apps, it adds complexity without enough benefit. Once you master MVVM, learning Clean Architecture is easy because it builds on the same principles.\n\n### What About BLoC?\n\nBLoC (Business Logic Component) is popular and powerful. However, it requires more boilerplate code and has a steeper learning curve. Riverpod with MVVM gives you the same benefits with less code and better developer experience."
            }
          ],
          "challenges": [
            {
              "type": "QUIZ",
              "id": "5.1-quiz-1",
              "title": "Architecture Concepts Quiz",
              "description": "Test your understanding of software architecture fundamentals.",
              "questions": [
                {
                  "id": "q1",
                  "text": "What is the main problem with 'spaghetti code' where API calls, state management, and UI are all in one widget?",
                  "options": [
                    "It runs slower than organized code",
                    "It is impossible to test, maintain, and scale",
                    "Flutter does not allow this pattern",
                    "It uses more memory"
                  ],
                  "correctAnswer": 1,
                  "explanation": "Spaghetti code is problematic because you cannot test pieces in isolation, changes in one area break others, and multiple developers cannot work on the same feature. Performance and memory are not the primary concerns."
                },
                {
                  "id": "q2",
                  "text": "What does 'Separation of Concerns' mean in software architecture?",
                  "options": [
                    "Keeping your personal and work code separate",
                    "Each part of the code has ONE clear responsibility",
                    "Separating mobile and web codebases",
                    "Using different programming languages for different features"
                  ],
                  "correctAnswer": 1,
                  "explanation": "Separation of Concerns means each layer or component has a single, well-defined responsibility. The Model handles data, the Repository handles data access, the ViewModel handles logic, and the View handles UI."
                },
                {
                  "id": "q3",
                  "text": "In MVVM architecture, what is the ViewModel's responsibility?",
                  "options": [
                    "Making HTTP requests to APIs",
                    "Displaying buttons and text on screen",
                    "Managing state and business logic between Model and View",
                    "Storing data in a database"
                  ],
                  "correctAnswer": 2,
                  "explanation": "The ViewModel sits between the Model (data) and View (UI). It manages application state, handles business logic, and transforms data for display. It does NOT make direct API calls (that is the Repository's job) or display UI (that is the View's job)."
                }
              ]
            }
          ]
        },
        {
          "id": "5.2",
          "title": "MVVM Pattern Explained",
          "moduleId": "module-05",
          "order": 2,
          "estimatedMinutes": 50,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Three Layers of MVVM",
              "content": "MVVM stands for **Model-View-ViewModel**. These are the three layers that make up the architecture. Let us understand each one using a restaurant analogy.\n\n### The Restaurant Analogy\n\nImagine a restaurant:\n- **Model = Ingredients in the kitchen** - Raw data. The chicken, vegetables, spices. They do not know how to cook themselves or how to be served. They just exist.\n- **ViewModel = The Chef** - Takes ingredients (Model), prepares them according to recipes (business logic), and decides what goes on each plate. The chef never serves customers directly.\n- **View = The Presentation** - The plate, the garnish, the table setting. How food looks when served. The waiter brings it to you. This is what customers (users) see.\n\n### In Code Terms\n\n**Model**: Pure data classes. No logic, no Flutter imports, just data structure.\n\n**ViewModel**: Contains business logic and state. Transforms data from Model into something the View can display. Handles user actions and updates state.\n\n**View**: Flutter widgets that display data and capture user input. Contains ONLY UI code, no business logic.\n\n### Why Three Layers?\n\nEach layer has exactly ONE job:\n- Model answers: \"What does the data look like?\"\n- ViewModel answers: \"What should happen with the data?\"\n- View answers: \"How should the data appear on screen?\"",
              "code": "// VISUAL REPRESENTATION OF MVVM\n//\n//  +------------------+\n//  |      VIEW        |  <- Flutter Widgets (UI only)\n//  |   (Presentation) |     Displays data, captures user input\n//  +--------+---------+\n//           |\n//           | watches state, sends user actions\n//           v\n//  +--------+---------+\n//  |    VIEWMODEL     |  <- Riverpod Notifier (Logic + State)\n//  | (Business Logic) |     Processes actions, updates state\n//  +--------+---------+\n//           |\n//           | reads/writes data\n//           v\n//  +--------+---------+\n//  |      MODEL       |  <- Pure Dart classes (Data only)\n//  |      (Data)      |     Defines data structure\n//  +------------------+",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "How Data Flows Through MVVM",
              "content": "Understanding data flow is crucial. In MVVM, data flows in a **unidirectional** (one-way) cycle. This predictability makes debugging easy because you always know where to look.\n\n### The Flow Cycle\n\n**Step 1: User Action**\nUser taps a button in the View (e.g., \"Add to Cart\")\n\n**Step 2: View Notifies ViewModel**\nThe View calls a method on the ViewModel: `viewModel.addToCart(product)`\n\n**Step 3: ViewModel Processes**\nThe ViewModel:\n- Validates the action (Is the product in stock?)\n- Updates its internal state\n- May call Repository to persist data\n\n**Step 4: State Changes**\nThe ViewModel's state updates (cart now has 1 item)\n\n**Step 5: View Rebuilds**\nThe View is watching the ViewModel's state. When state changes, the View automatically rebuilds with new data.\n\n### Why Unidirectional?\n\nIn older patterns, data could flow anywhere. The View could modify the Model directly. This created chaos:\n- Hard to track where changes came from\n- Bugs were difficult to reproduce\n- Testing was nearly impossible\n\nUnidirectional flow means: **User Action -> ViewModel -> State Change -> View Update**. Always. No exceptions.",
              "code": "// DATA FLOW EXAMPLE: Adding item to cart\n//\n// 1. USER TAPS \"Add to Cart\" button\n//    |\n//    v\n// 2. VIEW calls ViewModel method\n//    ref.read(cartViewModelProvider.notifier).addItem(product);\n//    |\n//    v\n// 3. VIEWMODEL processes the action\n//    void addItem(Product product) {\n//      // Validate: Is item in stock?\n//      if (product.stock > 0) {\n//        // Update state\n//        state = state.copyWith(\n//          items: [...state.items, CartItem(product: product, quantity: 1)],\n//        );\n//        // Persist to database (via Repository)\n//        _repository.saveCart(state);\n//      }\n//    }\n//    |\n//    v\n// 4. STATE CHANGES\n//    CartState { items: [CartItem(product, qty: 1)], total: 29.99 }\n//    |\n//    v\n// 5. VIEW REBUILDS automatically\n//    CartIcon now shows badge with \"1\"\n//    Cart screen now lists the item",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "A Complete MVVM Example: Counter App",
              "content": "Let us build a simple counter app using proper MVVM architecture with Riverpod. This example is complete and runnable. Study each layer carefully.\n\nNotice how each file has a single responsibility. The Model knows nothing about the ViewModel. The ViewModel knows nothing about specific widgets. The View just displays what it is told.",
              "code": "// ============================================\n// FILE: lib/models/counter_state.dart\n// LAYER: MODEL - Pure data, no logic\n// ============================================\n\nclass CounterState {\n  final int count;\n  final DateTime lastUpdated;\n\n  // Constructor with default values\n  const CounterState({\n    this.count = 0,\n    DateTime? lastUpdated,\n  }) : lastUpdated = lastUpdated ?? const DateTime(2024);\n\n  // Immutable update method - creates new instance\n  CounterState copyWith({\n    int? count,\n    DateTime? lastUpdated,\n  }) {\n    return CounterState(\n      count: count ?? this.count,\n      lastUpdated: lastUpdated ?? this.lastUpdated,\n    );\n  }\n}\n\n// ============================================\n// FILE: lib/viewmodels/counter_viewmodel.dart\n// LAYER: VIEWMODEL - Business logic and state\n// ============================================\n\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport '../models/counter_state.dart';\n\n// The Notifier holds and manages state\nclass CounterViewModel extends Notifier<CounterState> {\n  @override\n  CounterState build() {\n    // Initial state when provider is first accessed\n    return const CounterState();\n  }\n\n  // Business logic: increment with validation\n  void increment() {\n    // Rule: Cannot exceed 100\n    if (state.count < 100) {\n      state = state.copyWith(\n        count: state.count + 1,\n        lastUpdated: DateTime.now(),\n      );\n    }\n  }\n\n  // Business logic: decrement with validation\n  void decrement() {\n    // Rule: Cannot go below 0\n    if (state.count > 0) {\n      state = state.copyWith(\n        count: state.count - 1,\n        lastUpdated: DateTime.now(),\n      );\n    }\n  }\n\n  // Business logic: reset to zero\n  void reset() {\n    state = const CounterState();\n  }\n}\n\n// Provider that exposes the ViewModel\nfinal counterViewModelProvider =\n    NotifierProvider<CounterViewModel, CounterState>(() {\n  return CounterViewModel();\n});\n\n// ============================================\n// FILE: lib/views/counter_screen.dart\n// LAYER: VIEW - UI only, no business logic\n// ============================================\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport '../viewmodels/counter_viewmodel.dart';\n\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch state - rebuilds when state changes\n    final counterState = ref.watch(counterViewModelProvider);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('MVVM Counter'),\n        actions: [\n          // Reset button\n          IconButton(\n            icon: const Icon(Icons.refresh),\n            onPressed: () {\n              // Call ViewModel method - NO logic here!\n              ref.read(counterViewModelProvider.notifier).reset();\n            },\n          ),\n        ],\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Display count from state\n            Text(\n              '${counterState.count}',\n              style: const TextStyle(fontSize: 72, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 16),\n            // Display last updated time\n            Text(\n              'Last updated: ${_formatTime(counterState.lastUpdated)}',\n              style: const TextStyle(color: Colors.grey),\n            ),\n            const SizedBox(height: 32),\n            // Increment and Decrement buttons\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                FloatingActionButton(\n                  heroTag: 'decrement',\n                  onPressed: () {\n                    ref.read(counterViewModelProvider.notifier).decrement();\n                  },\n                  child: const Icon(Icons.remove),\n                ),\n                const SizedBox(width: 24),\n                FloatingActionButton(\n                  heroTag: 'increment',\n                  onPressed: () {\n                    ref.read(counterViewModelProvider.notifier).increment();\n                  },\n                  child: const Icon(Icons.add),\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // Helper method for formatting - this is OK in View\n  // because it is purely presentational\n  String _formatTime(DateTime time) {\n    return '${time.hour}:${time.minute.toString().padLeft(2, '0')}';\n  }\n}\n\n// ============================================\n// FILE: lib/main.dart\n// App entry point\n// ============================================\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'views/counter_screen.dart';\n\nvoid main() {\n  runApp(\n    // ProviderScope is required for Riverpod\n    const ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'MVVM Counter',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const CounterScreen(),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Why Not Just StatefulWidget?",
              "content": "You might wonder: \"Why not just use StatefulWidget with setState?\" Let us compare both approaches.\n\n### StatefulWidget Approach\n\nWith StatefulWidget, you put everything in one place:",
              "code": "// STATEFULWIDGET APPROACH - Everything mixed together\nclass CounterPage extends StatefulWidget {\n  @override\n  State<CounterPage> createState() => _CounterPageState();\n}\n\nclass _CounterPageState extends State<CounterPage> {\n  int count = 0;  // State in the widget\n\n  void increment() {\n    // Logic in the widget\n    if (count < 100) {\n      setState(() => count++);\n    }\n  }\n\n  void decrement() {\n    // More logic in the widget\n    if (count > 0) {\n      setState(() => count--);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // UI in the same class as logic\n    return Column(\n      children: [\n        Text('$count'),\n        Row(\n          children: [\n            ElevatedButton(onPressed: decrement, child: Text('-')),\n            ElevatedButton(onPressed: increment, child: Text('+')),\n          ],\n        ),\n      ],\n    );\n  }\n}\n\n// PROBLEMS WITH THIS APPROACH:\n//\n// 1. TESTING IS HARD\n//    How do you test increment() without rendering the widget?\n//    You cannot. You must use widget tests for everything.\n//\n// 2. NO CODE REUSE\n//    Need the same counter logic on another screen?\n//    You must copy-paste everything.\n//\n// 3. STATE IS LOST\n//    Navigate away and back? Count resets to 0.\n//    StatefulWidget state is tied to the widget tree.\n//\n// 4. NO SEPARATION\n//    Logic and UI are mixed. Changes to one risk breaking the other.",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "MVVM Rules To Remember",
              "content": "Following these rules strictly will keep your architecture clean:\n\n### Rule 1: View Never Calls APIs Directly\nThe View should NEVER import http, dio, or any networking library. If you need data from an API, the View asks the ViewModel, which asks a Repository.\n\n**Bad:**\n```dart\n// In a widget\nonPressed: () async {\n  final response = await http.get(Uri.parse('api/data'));\n  setState(() => data = response.body);\n}\n```\n\n**Good:**\n```dart\n// In a widget\nonPressed: () {\n  ref.read(myViewModelProvider.notifier).fetchData();\n}\n```\n\n### Rule 2: ViewModel Does Not Import Flutter Widgets\nThe ViewModel should have NO knowledge of Flutter UI. It should not import `package:flutter/material.dart`. It only knows about state and data.\n\n**Bad:**\n```dart\nclass MyViewModel extends Notifier<MyState> {\n  void showError() {\n    // ViewModel trying to show UI - WRONG!\n    ScaffoldMessenger.of(context).showSnackBar(...);\n  }\n}\n```\n\n**Good:**\n```dart\nclass MyViewModel extends Notifier<MyState> {\n  void processAction() {\n    // ViewModel updates state - View reacts to state\n    state = state.copyWith(errorMessage: 'Something went wrong');\n  }\n}\n// View watches errorMessage and shows SnackBar when it changes\n```\n\n### Rule 3: Model Is Pure Dart\nModel classes should be plain Dart. No Flutter, no Riverpod, no external dependencies. They should be so simple that you could use them in a Dart CLI app.\n\n### Rule 4: State Is Immutable\nNever modify state directly. Always create new state objects. This makes tracking changes easy and prevents bugs.\n\n**Bad:**\n```dart\nstate.items.add(newItem);  // Mutating existing state!\n```\n\n**Good:**\n```dart\nstate = state.copyWith(items: [...state.items, newItem]);\n```"
            },
            {
              "type": "WARNING",
              "title": "Common MVVM Mistakes",
              "content": "Even experienced developers make these mistakes. Learn to recognize and avoid them.\n\n### Mistake 1: Putting Business Logic in the View\n\n**Symptom:** Your widget has `if` statements that decide what to do with data.\n\n```dart\n// BAD: Logic in View\nonPressed: () {\n  if (cart.items.length < 10 && product.inStock && user.isLoggedIn) {\n    cart.add(product);\n  } else {\n    showError('Cannot add');\n  }\n}\n\n// GOOD: Logic in ViewModel\nonPressed: () {\n  ref.read(cartViewModelProvider.notifier).addToCart(product);\n  // ViewModel handles all the validation\n}\n```\n\n### Mistake 2: Making ViewModel Aware of UI\n\n**Symptom:** Your ViewModel has methods like `showDialog()` or references `BuildContext`.\n\nThe ViewModel should only update state. The View observes state and decides how to present it (dialog, snackbar, new screen, etc.).\n\n### Mistake 3: Skipping the Model Layer\n\n**Symptom:** Your ViewModel uses `Map<String, dynamic>` instead of proper classes.\n\n```dart\n// BAD: No Model\nclass UserViewModel extends Notifier<Map<String, dynamic>> {\n  void updateName(String name) {\n    state = {...state, 'name': name};  // No type safety!\n  }\n}\n\n// GOOD: With Model\nclass UserViewModel extends Notifier<User> {\n  void updateName(String name) {\n    state = state.copyWith(name: name);  // Type safe!\n  }\n}\n```\n\n### Mistake 4: Giant ViewModel\n\n**Symptom:** One ViewModel handles authentication, cart, user profile, and settings.\n\nEach ViewModel should handle ONE feature. If it grows too large, split it into multiple ViewModels."
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.2-challenge-1",
              "title": "Convert StatefulWidget to MVVM",
              "description": "Take a messy StatefulWidget counter and refactor it into proper MVVM architecture using Riverpod.",
              "instructions": "The starter code shows a StatefulWidget counter that mixes UI and logic. Your task is to refactor it into proper MVVM:\n\n1. Create a CounterState model class with count and lastModified fields\n2. Create a CounterViewModel using Notifier that handles increment, decrement, and reset\n3. Create a CounterScreen using ConsumerWidget that only handles UI\n4. Add validation: count cannot go below 0 or above 50\n5. Add a reset button that sets count back to 0\n\nRemember: The View should have NO logic, the ViewModel should have NO Flutter widgets, and the Model should be pure Dart.",
              "starterCode": "// STARTER CODE: Messy StatefulWidget\n// Your job: Refactor this into MVVM!\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(home: CounterPage());\n  }\n}\n\n// THIS IS THE MESSY CODE - REFACTOR IT!\nclass CounterPage extends StatefulWidget {\n  @override\n  State<CounterPage> createState() => _CounterPageState();\n}\n\nclass _CounterPageState extends State<CounterPage> {\n  // State mixed with UI\n  int count = 0;\n  DateTime? lastModified;\n\n  // Logic mixed with UI\n  void increment() {\n    if (count < 50) {\n      setState(() {\n        count++;\n        lastModified = DateTime.now();\n      });\n    }\n  }\n\n  void decrement() {\n    if (count > 0) {\n      setState(() {\n        count--;\n        lastModified = DateTime.now();\n      });\n    }\n  }\n\n  void reset() {\n    setState(() {\n      count = 0;\n      lastModified = null;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Counter'),\n        actions: [\n          IconButton(icon: Icon(Icons.refresh), onPressed: reset),\n        ],\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('$count', style: TextStyle(fontSize: 48)),\n            if (lastModified != null)\n              Text('Modified: ${lastModified!.hour}:${lastModified!.minute}'),\n            SizedBox(height: 20),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                ElevatedButton(onPressed: decrement, child: Text('-')),\n                SizedBox(width: 20),\n                ElevatedButton(onPressed: increment, child: Text('+')),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// TODO: Create these three parts:\n//\n// 1. MODEL: CounterState class\n//    - int count\n//    - DateTime? lastModified\n//    - copyWith method\n//\n// 2. VIEWMODEL: CounterViewModel extends Notifier<CounterState>\n//    - increment() with max 50 validation\n//    - decrement() with min 0 validation  \n//    - reset()\n//\n// 3. VIEW: CounterScreen extends ConsumerWidget\n//    - Same UI but uses ref.watch and ref.read\n//    - NO logic in the widget!",
              "solution": "// SOLUTION: Proper MVVM Architecture\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'MVVM Counter',\n      home: const CounterScreen(),\n    );\n  }\n}\n\n// =====================================\n// MODEL: Pure data class\n// =====================================\nclass CounterState {\n  final int count;\n  final DateTime? lastModified;\n\n  const CounterState({\n    this.count = 0,\n    this.lastModified,\n  });\n\n  // Immutable update\n  CounterState copyWith({\n    int? count,\n    DateTime? lastModified,\n  }) {\n    return CounterState(\n      count: count ?? this.count,\n      lastModified: lastModified ?? this.lastModified,\n    );\n  }\n}\n\n// =====================================\n// VIEWMODEL: Business logic and state\n// =====================================\nclass CounterViewModel extends Notifier<CounterState> {\n  @override\n  CounterState build() {\n    // Initial state\n    return const CounterState();\n  }\n\n  void increment() {\n    // Business rule: max 50\n    if (state.count < 50) {\n      state = state.copyWith(\n        count: state.count + 1,\n        lastModified: DateTime.now(),\n      );\n    }\n  }\n\n  void decrement() {\n    // Business rule: min 0\n    if (state.count > 0) {\n      state = state.copyWith(\n        count: state.count - 1,\n        lastModified: DateTime.now(),\n      );\n    }\n  }\n\n  void reset() {\n    state = const CounterState();\n  }\n}\n\n// Provider for the ViewModel\nfinal counterViewModelProvider =\n    NotifierProvider<CounterViewModel, CounterState>(() {\n  return CounterViewModel();\n});\n\n// =====================================\n// VIEW: UI only, no logic\n// =====================================\nclass CounterScreen extends ConsumerWidget {\n  const CounterScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch state - rebuilds automatically when state changes\n    final state = ref.watch(counterViewModelProvider);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('MVVM Counter'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.refresh),\n            onPressed: () {\n              // Call ViewModel - no logic here\n              ref.read(counterViewModelProvider.notifier).reset();\n            },\n          ),\n        ],\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Display state\n            Text(\n              '${state.count}',\n              style: const TextStyle(fontSize: 48, fontWeight: FontWeight.bold),\n            ),\n            // Conditional display based on state\n            if (state.lastModified != null)\n              Text(\n                'Modified: ${state.lastModified!.hour}:${state.lastModified!.minute.toString().padLeft(2, '0')}',\n                style: const TextStyle(color: Colors.grey),\n              ),\n            const SizedBox(height: 20),\n            // Buttons that call ViewModel methods\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                ElevatedButton(\n                  onPressed: () {\n                    ref.read(counterViewModelProvider.notifier).decrement();\n                  },\n                  child: const Text('-'),\n                ),\n                const SizedBox(width: 20),\n                ElevatedButton(\n                  onPressed: () {\n                    ref.read(counterViewModelProvider.notifier).increment();\n                  },\n                  child: const Text('+'),\n                ),\n              ],\n            ),\n            const SizedBox(height: 20),\n            // Display bounds info\n            Text(\n              'Range: 0 - 50',\n              style: TextStyle(color: Colors.grey[600]),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// KEY IMPROVEMENTS:\n// \n// 1. MODEL is pure Dart - can be tested without Flutter\n// 2. VIEWMODEL has all logic - can be unit tested easily\n// 3. VIEW only displays - no business rules in widgets\n// 4. State is immutable - copyWith creates new instances\n// 5. State persists - survives navigation (unlike StatefulWidget)\n// 6. Reusable - ViewModel can be used by multiple Views",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-model",
                  "description": "CounterState model has count and lastModified fields",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-viewmodel",
                  "description": "CounterViewModel extends Notifier with increment, decrement, reset",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-view",
                  "description": "CounterScreen extends ConsumerWidget with no business logic",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with the Model. Create a simple class with count and lastModified fields, plus a copyWith method for immutable updates."
                },
                {
                  "level": 2,
                  "text": "For the ViewModel, extend Notifier<CounterState> and implement build() to return initial state. The increment/decrement methods should check bounds before updating."
                },
                {
                  "level": 3,
                  "text": "In the View, use ref.watch() to get current state for display, and ref.read().notifier to call methods. The View should never contain if statements for business rules."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Putting validation logic in the View",
                  "consequence": "Business logic is scattered across UI code",
                  "correction": "Move all if statements about count limits to the ViewModel"
                },
                {
                  "mistake": "Using ref.watch() when calling methods",
                  "consequence": "Unnecessary rebuilds and potential infinite loops",
                  "correction": "Use ref.read() inside callbacks/onPressed, use ref.watch() only in build method"
                },
                {
                  "mistake": "Mutating state directly instead of using copyWith",
                  "consequence": "State changes are not detected, UI does not update",
                  "correction": "Always use state = state.copyWith(...) to create new state instances"
                },
                {
                  "mistake": "Forgetting ProviderScope in main()",
                  "consequence": "Runtime error - Riverpod providers cannot be accessed",
                  "correction": "Wrap your app with ProviderScope: runApp(ProviderScope(child: MyApp()))"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.3",
          "title": "Project Structure (Feature-First Folders)",
          "moduleId": "module-05",
          "order": 3,
          "estimatedMinutes": 35,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Folder Structure Matters",
              "content": "When you start a Flutter project, you can technically put all your code in one file. For a tiny app, that works. But as your app grows, finding and organizing code becomes a nightmare.\n\n**Small apps (1-3 screens):** Any structure works. You can find files quickly because there are so few.\n\n**Medium apps (4-10 screens):** You start losing track. Where did I put that helper function? Which file has the user model?\n\n**Large apps (10+ screens):** Without good structure, you spend more time searching for code than writing it. New team members take weeks to understand the project.\n\n**Team apps:** Everyone needs to know where things go. If Alice puts models in `/models` and Bob puts them in `/data/entities`, chaos follows.\n\n### The Library Analogy\n\nImagine organizing a library:\n\n**Bad organization:** Books shelved randomly. Finding a cookbook means searching every shelf in the building.\n\n**Better organization (by type):** All hardcovers together, all paperbacks together. Still hard to find that cookbook though!\n\n**Best organization (by topic/genre):** All cookbooks in one section, all mysteries in another. Need a cookbook? Go to the cookbook section. Simple.\n\nProject folder structure works the same way. We want to organize code so that finding and modifying features is as easy as finding cookbooks in a well-organized library."
            },
            {
              "type": "THEORY",
              "title": "Feature-First vs Layer-First",
              "content": "There are two main ways to organize a Flutter project. Understanding both helps you choose wisely.\n\n### Layer-First Organization\n\nOrganize by the TYPE of file:\n\n```\nlib/\n  models/\n    user_model.dart\n    product_model.dart\n    cart_model.dart\n    order_model.dart\n  views/\n    login_screen.dart\n    product_screen.dart\n    cart_screen.dart\n    checkout_screen.dart\n  viewmodels/\n    login_viewmodel.dart\n    product_viewmodel.dart\n    cart_viewmodel.dart\n    checkout_viewmodel.dart\n```\n\n**Problem:** Related files are scattered. To work on the cart feature, you need to jump between three different folders. If you have 50 models, finding `cart_model.dart` means scrolling through an alphabetical list of unrelated models.\n\n### Feature-First Organization\n\nOrganize by the FEATURE:\n\n```\nlib/\n  features/\n    auth/\n      models/user.dart\n      viewmodels/login_viewmodel.dart\n      views/login_screen.dart\n    cart/\n      models/cart_item.dart\n      viewmodels/cart_viewmodel.dart\n      views/cart_screen.dart\n    checkout/\n      models/order.dart\n      viewmodels/checkout_viewmodel.dart\n      views/checkout_screen.dart\n```\n\n**Benefit:** Everything for the cart is in one place. Need to work on cart? Open the `cart/` folder and everything you need is right there.\n\n### Why Feature-First Wins\n\n1. **Related code together:** Model, ViewModel, and View for a feature are neighbors\n2. **Easier to find:** Looking for cart code? Go to `features/cart/`\n3. **Easy to delete:** Removing a feature? Delete one folder\n4. **Better for teams:** Each developer can own a feature folder\n5. **Scales well:** 50 features means 50 folders, not 150 files in one folder"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Project Structure",
              "content": "Here is a complete, production-ready Flutter project structure using feature-first organization. Study it carefully and understand what goes where.",
              "code": "lib/\n‚îú‚îÄ‚îÄ main.dart                    # App entry point\n‚îÇ\n‚îú‚îÄ‚îÄ core/                        # SHARED across ALL features\n‚îÇ   ‚îú‚îÄ‚îÄ theme/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app_theme.dart       # Colors, text styles, themes\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app_colors.dart      # Color constants\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ widgets/                 # Reusable widgets\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app_button.dart      # Custom button used everywhere\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ loading_indicator.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ error_widget.dart\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ utils/                   # Helper functions\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validators.dart      # Email, password validation\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ formatters.dart      # Date, currency formatting\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ extensions.dart      # String, DateTime extensions\n‚îÇ   ‚îÇ\n‚îÇ   ‚îî‚îÄ‚îÄ constants/               # App-wide constants\n‚îÇ       ‚îú‚îÄ‚îÄ api_constants.dart   # Base URLs, endpoints\n‚îÇ       ‚îî‚îÄ‚îÄ app_constants.dart   # Timeouts, limits\n‚îÇ\n‚îú‚îÄ‚îÄ features/                    # FEATURE MODULES\n‚îÇ   ‚îú‚îÄ‚îÄ auth/                    # Authentication feature\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.dart        # User data class\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ viewmodels/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login_viewmodel.dart\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ register_viewmodel.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ views/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login_screen.dart\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ register_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ widgets/             # Auth-specific widgets\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ social_login_buttons.dart\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ home/                    # Home/Dashboard feature\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dashboard_data.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ viewmodels/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ home_viewmodel.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ views/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ home_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ widgets/\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ stats_card.dart\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ recent_activity.dart\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ products/                # Products feature\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product.dart\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ category.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ viewmodels/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products_viewmodel.dart\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ product_detail_viewmodel.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ views/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products_screen.dart\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ product_detail_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ widgets/\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ product_card.dart\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ product_grid.dart\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ cart/                    # Shopping cart feature\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cart_item.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ viewmodels/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cart_viewmodel.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ views/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cart_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ widgets/\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ cart_item_tile.dart\n‚îÇ   ‚îÇ\n‚îÇ   ‚îî‚îÄ‚îÄ settings/                # Settings feature\n‚îÇ       ‚îú‚îÄ‚îÄ models/\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ app_settings.dart\n‚îÇ       ‚îú‚îÄ‚îÄ viewmodels/\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ settings_viewmodel.dart\n‚îÇ       ‚îî‚îÄ‚îÄ views/\n‚îÇ           ‚îî‚îÄ‚îÄ settings_screen.dart\n‚îÇ\n‚îî‚îÄ‚îÄ services/                    # BACKEND COMMUNICATION\n    ‚îú‚îÄ‚îÄ api/\n    ‚îÇ   ‚îú‚îÄ‚îÄ api_client.dart      # HTTP client setup\n    ‚îÇ   ‚îî‚îÄ‚îÄ api_endpoints.dart   # API endpoint definitions\n    ‚îú‚îÄ‚îÄ auth_service.dart        # Login, logout, token refresh\n    ‚îú‚îÄ‚îÄ product_service.dart     # Product API calls\n    ‚îî‚îÄ‚îÄ storage_service.dart     # Local storage (SharedPrefs)",
              "language": "text"
            },
            {
              "type": "KEY_POINT",
              "title": "Structure Rules",
              "content": "Follow these rules to keep your project organized and maintainable:\n\n### Rule 1: One Feature = One Folder\nEach feature gets its own folder under `features/`. A feature is a distinct piece of functionality: authentication, shopping cart, user profile, settings, etc.\n\n### Rule 2: Shared Code Goes in core/\nIf something is used by multiple features, it belongs in `core/`. This includes:\n- Custom widgets used on multiple screens\n- Theme and styling constants\n- Utility functions and extensions\n- Validation logic\n\n### Rule 3: Services Handle External Communication\nAll API calls, database access, and external service communication goes in `services/`. Features should not import `http` or `dio` directly. They ask services to do the work.\n\n### Rule 4: Keep Features Independent\nFeatures should NOT import from other features directly. If `cart` needs user data from `auth`, both should use a shared service or a provider in `core/`.\n\n**Bad:**\n```dart\n// In cart/viewmodels/cart_viewmodel.dart\nimport '../auth/models/user.dart';  // Direct import from another feature!\n```\n\n**Good:**\n```dart\n// In cart/viewmodels/cart_viewmodel.dart\nimport '../../services/auth_service.dart';  // Uses shared service\n```\n\n### Rule 5: Feature Widgets Stay in Feature\nWidgets that are ONLY used within a feature stay in that feature's `widgets/` folder. Only truly reusable widgets go in `core/widgets/`."
            },
            {
              "type": "WARNING",
              "title": "Common Structure Mistakes",
              "content": "Avoid these common organizational mistakes:\n\n### Mistake 1: Too Many Nested Folders\n\n**Bad:**\n```\nfeatures/auth/presentation/screens/login/widgets/forms/inputs/\n```\nThis is 8 levels deep! Finding files becomes a nightmare.\n\n**Good:** Keep it to 3-4 levels maximum:\n```\nfeatures/auth/views/login_screen.dart\nfeatures/auth/widgets/login_form.dart\n```\n\n### Mistake 2: Putting Everything in core/\n\nIf your `core/widgets/` folder has 50 widgets, something is wrong. Most widgets are feature-specific and should live in their feature folder.\n\n**Ask yourself:** Is this widget used by 2+ features? If not, it belongs in the feature.\n\n### Mistake 3: Cross-Feature Imports\n\n**Bad:**\n```dart\n// In features/checkout/viewmodels/checkout_viewmodel.dart\nimport '../../cart/models/cart_item.dart';\nimport '../../auth/viewmodels/auth_viewmodel.dart';\n```\n\nThis creates tight coupling. If you change the cart feature, checkout breaks.\n\n**Good:** Use services as intermediaries:\n```dart\n// In features/checkout/viewmodels/checkout_viewmodel.dart\nimport '../../services/cart_service.dart';\nimport '../../services/auth_service.dart';\n```\n\n### Mistake 4: No Structure At All\n\nDumping everything in `lib/` works for tiny apps but fails spectacularly as your app grows. Start with good structure from day one. Reorganizing 100 files later is painful.\n\n### Mistake 5: Inconsistent Naming\n\nPick a naming convention and stick to it:\n- Files: `snake_case.dart` (login_screen.dart, not LoginScreen.dart)\n- Classes: `PascalCase` (LoginScreen, not loginScreen)\n- Folders: `snake_case` (auth_feature/, not AuthFeature/)"
            }
          ],
          "challenges": [
            {
              "type": "QUIZ",
              "id": "5.3-challenge-1",
              "title": "Project Structure Quiz",
              "description": "Test your understanding of feature-first folder organization.",
              "questions": [
                {
                  "id": "q1",
                  "text": "Where would you put a reusable 'AppButton' widget that is used across 5 different features?",
                  "options": [
                    "features/buttons/widgets/app_button.dart",
                    "core/widgets/app_button.dart",
                    "lib/app_button.dart",
                    "features/home/widgets/app_button.dart"
                  ],
                  "correctAnswer": 1,
                  "explanation": "Widgets used by multiple features belong in core/widgets/. This keeps reusable code in one place and prevents features from depending on each other. The core/ folder is for shared code."
                },
                {
                  "id": "q2",
                  "text": "Where would you put the login screen for your authentication feature?",
                  "options": [
                    "lib/views/login_screen.dart",
                    "core/views/login_screen.dart",
                    "features/auth/views/login_screen.dart",
                    "screens/login_screen.dart"
                  ],
                  "correctAnswer": 2,
                  "explanation": "In feature-first organization, each feature has its own folder. Login is part of the auth feature, so it goes in features/auth/views/. This keeps all authentication-related code together."
                },
                {
                  "id": "q3",
                  "text": "Your cart feature needs to access the current user's ID. What is the CORRECT way to do this?",
                  "options": [
                    "Import directly from features/auth/models/user.dart",
                    "Copy the user model into features/cart/models/",
                    "Use a shared service like services/auth_service.dart",
                    "Store user ID in a global variable"
                  ],
                  "correctAnswer": 2,
                  "explanation": "Features should not import from each other directly. Instead, use shared services as intermediaries. This keeps features independent and prevents tight coupling. If auth changes, cart does not break."
                },
                {
                  "id": "q4",
                  "text": "You created a 'ProductRatingStars' widget used ONLY in the product detail screen. Where should it go?",
                  "options": [
                    "core/widgets/product_rating_stars.dart",
                    "features/products/widgets/product_rating_stars.dart",
                    "lib/widgets/product_rating_stars.dart",
                    "features/common/widgets/product_rating_stars.dart"
                  ],
                  "correctAnswer": 1,
                  "explanation": "If a widget is only used within one feature, it stays in that feature's widgets/ folder. Only put things in core/ if they are used by 2+ features. This prevents core/ from becoming a dumping ground."
                },
                {
                  "id": "q5",
                  "text": "What is the MAIN advantage of feature-first folder organization?",
                  "options": [
                    "Smaller file sizes",
                    "Faster app compilation",
                    "Related code is grouped together, making features easy to find and modify",
                    "Required by Flutter framework"
                  ],
                  "correctAnswer": 2,
                  "explanation": "Feature-first organization groups all code for a feature (models, views, viewmodels, widgets) in one folder. This makes it easy to find everything related to a feature, work on it without jumping between folders, and even delete an entire feature by removing one folder."
                }
              ]
            }
          ]
        },
        {
          "id": "5.4",
          "title": "Riverpod Fundamentals",
          "moduleId": "module-05",
          "order": 4,
          "estimatedMinutes": 45,
          "difficulty": "beginner",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Riverpod?",
              "content": "You may have heard of the Provider package for state management in Flutter. Riverpod is the next evolution, created by the same author (Remi Rousselet). Let us understand why Riverpod exists and what problems it solves.\n\n### Provider Package Limitations\n\nThe original Provider package has served Flutter developers well, but it has some frustrating limitations:\n\n**1. No Compile-Time Safety**\nWith Provider, errors only appear at runtime:\n```dart\n// Provider - This compiles fine but crashes at runtime!\nfinal user = context.read<UserProvider>();  // Oops, UserProvider not registered!\n```\n\n**2. BuildContext Required Everywhere**\nYou need a BuildContext to access providers, which means:\n- Cannot access state in pure Dart classes\n- Cannot easily access state outside the widget tree\n- Testing requires building widget trees\n\n**3. Cannot Have Multiple Providers of Same Type**\nTrying to provide two `String` values? You need workarounds.\n\n### Riverpod Benefits\n\nRiverpod solves all of these problems:\n\n**1. Compile-Time Safe**\nErrors are caught before you run the app:\n```dart\n// Riverpod - Compiler catches typos and missing providers!\nfinal user = ref.watch(userProvider);  // If userProvider doesn't exist, code won't compile\n```\n\n**2. No BuildContext Needed**\nAccess state from anywhere. Testing is simple. No widget tree required.\n\n**3. Multiple Providers of Same Type**\nCreate as many String, int, or custom providers as you need. Each has a unique identity.\n\n**4. Better Testing**\nProviders can be overridden for testing. No widget setup required.\n\n**5. Automatic Disposal**\nProviders can automatically clean up when no longer needed, preventing memory leaks."
            },
            {
              "type": "THEORY",
              "title": "Core Concepts",
              "content": "Before writing code, let us understand the four core building blocks of Riverpod:\n\n### 1. Provider\nA **provider** is a container for a piece of state. Think of it as a box that holds a value and lets others read that value.\n\n```dart\n// This provider holds a String value\nfinal greetingProvider = Provider<String>((ref) {\n  return 'Hello, World!';\n});\n```\n\nProviders are:\n- **Global constants** - defined at the top level of your files\n- **Lazy** - they do not create their value until someone reads them\n- **Cached** - once created, the value is reused\n\n### 2. ref\nThe **ref** object is how you interact with providers. It is your access pass to read, watch, or listen to any provider.\n\n```dart\n// Inside another provider\nfinal combinedProvider = Provider<String>((ref) {\n  final greeting = ref.watch(greetingProvider);  // ref lets you access other providers\n  return '$greeting from Riverpod';\n});\n```\n\n### 3. ProviderScope\n**ProviderScope** is the container that holds all your providers. It must wrap your entire app. Think of it as the root of a tree where all providers live.\n\n```dart\nvoid main() {\n  runApp(\n    ProviderScope(  // This enables Riverpod for your entire app\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n### 4. ConsumerWidget / Consumer\nTo read providers in your widgets, you use **ConsumerWidget** (instead of StatelessWidget) or the **Consumer** builder.\n\n```dart\n// ConsumerWidget gives you access to ref in the build method\nclass MyScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final value = ref.watch(myProvider);  // Now you can access providers!\n    return Text(value);\n  }\n}\n```"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Riverpod App",
              "content": "Let us build a complete, working Riverpod app step by step. This example shows every piece you need to get started.\n\n**What this app does:** Displays a greeting message using Riverpod. Simple, but it demonstrates all the core concepts.",
              "code": "// STEP 1: Import Riverpod\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// STEP 2: Define a Provider\n// This is a global constant - defined outside any class\n// It holds a String value: 'Hello, Riverpod!'\nfinal greetingProvider = Provider<String>((ref) {\n  return 'Hello, Riverpod!';\n});\n\n// STEP 3: Wrap Your App in ProviderScope\nvoid main() {\n  runApp(\n    ProviderScope(  // This MUST wrap your entire app\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Riverpod Demo',\n      home: GreetingScreen(),\n    );\n  }\n}\n\n// STEP 4: Use ConsumerWidget to Access Providers\n// Notice: extends ConsumerWidget, NOT StatelessWidget\nclass GreetingScreen extends ConsumerWidget {\n  @override\n  // Notice: build method has TWO parameters: context AND ref\n  Widget build(BuildContext context, WidgetRef ref) {\n    // STEP 5: Read the Provider Using ref.watch()\n    // ref.watch() reads the value AND rebuilds this widget when it changes\n    final greeting = ref.watch(greetingProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: Text('My First Riverpod App')),\n      body: Center(\n        child: Text(\n          greeting,  // Display the value from the provider\n          style: TextStyle(fontSize: 24),\n        ),\n      ),\n    );\n  }\n}\n\n// THAT'S IT! A complete Riverpod app in under 50 lines.\n//\n// Key pieces:\n// 1. Provider defined globally (greetingProvider)\n// 2. ProviderScope wrapping the app (in main)\n// 3. ConsumerWidget to access providers (GreetingScreen)\n// 4. ref.watch() to read provider value",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "watch vs read: The Critical Difference",
              "content": "This is where most beginners make mistakes. Understanding when to use `ref.watch()` versus `ref.read()` is essential.\n\n### ref.watch() - Rebuilds Widget on Change\n\nUse `ref.watch()` when you want your widget to **update automatically** when the value changes.\n\n**Where to use it:** Inside the `build()` method.\n\n```dart\nWidget build(BuildContext context, WidgetRef ref) {\n  // GOOD: watch in build method\n  // Widget rebuilds automatically when count changes\n  final count = ref.watch(counterProvider);\n  return Text('$count');\n}\n```\n\n### ref.read() - Gets Value Once, No Rebuilding\n\nUse `ref.read()` when you want to **get the value once** without subscribing to changes. Perfect for event handlers.\n\n**Where to use it:** Inside callbacks, onPressed handlers, or anywhere outside build.\n\n```dart\nElevatedButton(\n  onPressed: () {\n    // GOOD: read in callback\n    // Gets the notifier to call a method - does not subscribe to changes\n    ref.read(counterProvider.notifier).increment();\n  },\n  child: Text('Add'),\n)\n```\n\n### The Golden Rules\n\n**Rule 1:** Use `ref.watch()` in the build method to display reactive data.\n\n**Rule 2:** Use `ref.read()` in callbacks/handlers to trigger actions.\n\n**Rule 3:** NEVER use `ref.read()` in the build method to display data - your UI will not update!\n\n### Examples: Right vs Wrong",
              "code": "class CounterScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    \n    // ===== DISPLAYING DATA =====\n    \n    // GOOD: watch in build - UI updates when count changes\n    final count = ref.watch(counterProvider);\n    \n    // BAD: read in build - UI will NEVER update!\n    // final count = ref.read(counterProvider);  // DON'T DO THIS!\n    \n    return Column(\n      children: [\n        Text('Count: $count'),  // This displays the watched value\n        \n        // ===== HANDLING ACTIONS =====\n        \n        ElevatedButton(\n          onPressed: () {\n            // GOOD: read in callback - fires once per tap\n            ref.read(counterProvider.notifier).increment();\n          },\n          child: Text('Increment'),\n        ),\n        \n        ElevatedButton(\n          onPressed: () {\n            // BAD: watch in callback - unnecessary subscription\n            // ref.watch(counterProvider.notifier).decrement();  // DON'T DO THIS!\n            \n            // GOOD: read is correct here\n            ref.read(counterProvider.notifier).decrement();\n          },\n          child: Text('Decrement'),\n        ),\n      ],\n    );\n  }\n}\n\n// Summary:\n// ref.watch() = \"Keep me updated when this changes\" (use in build)\n// ref.read()  = \"Give me the value right now, just once\" (use in callbacks)",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Provider Types",
              "content": "Riverpod offers different provider types for different needs. Here is when to use each:\n\n### Provider - Read-Only Value\nUse for values that never change or are computed from other providers.\n```dart\nfinal appNameProvider = Provider<String>((ref) => 'My App');\nfinal doubleCountProvider = Provider<int>((ref) {\n  final count = ref.watch(counterProvider);\n  return count * 2;  // Computed value\n});\n```\n\n### StateProvider - Simple Mutable Value\nUse for simple values you need to change: booleans, numbers, strings.\n```dart\nfinal counterProvider = StateProvider<int>((ref) => 0);\nfinal isDarkModeProvider = StateProvider<bool>((ref) => false);\n\n// To update:\nref.read(counterProvider.notifier).state++;\nref.read(isDarkModeProvider.notifier).state = true;\n```\n\n### NotifierProvider - Complex State with Methods\nUse when you need methods to modify state (the MVVM ViewModel pattern).\n```dart\nclass CartNotifier extends Notifier<List<Item>> {\n  @override\n  List<Item> build() => [];  // Initial state\n  \n  void addItem(Item item) {\n    state = [...state, item];\n  }\n  \n  void removeItem(String id) {\n    state = state.where((item) => item.id != id).toList();\n  }\n}\n\nfinal cartProvider = NotifierProvider<CartNotifier, List<Item>>(() {\n  return CartNotifier();\n});\n```\n\n### FutureProvider - Async Data (API Calls)\nUse for data fetched from an API or database.\n```dart\nfinal userProvider = FutureProvider<User>((ref) async {\n  final response = await http.get('https://api.example.com/user');\n  return User.fromJson(jsonDecode(response.body));\n});\n\n// In widget:\nfinal userAsync = ref.watch(userProvider);\nuserAsync.when(\n  data: (user) => Text(user.name),\n  loading: () => CircularProgressIndicator(),\n  error: (err, stack) => Text('Error: $err'),\n);\n```\n\n### StreamProvider - Real-Time Data\nUse for data that updates over time (chat messages, live prices).\n```dart\nfinal messagesProvider = StreamProvider<List<Message>>((ref) {\n  return database.watchMessages();  // Returns a Stream\n});\n```\n\n### Quick Reference Table\n\n| Provider Type | Use When | Example |\n|---------------|----------|----------|\n| `Provider` | Read-only or computed values | App config, derived data |\n| `StateProvider` | Simple values that change | Counter, toggle, filter |\n| `NotifierProvider` | Complex state with methods | Cart, form, user profile |\n| `FutureProvider` | One-time async fetch | API calls, database reads |\n| `StreamProvider` | Real-time updates | Chat, live data, sockets |"
            },
            {
              "type": "WARNING",
              "title": "Common Riverpod Mistakes",
              "content": "These are the mistakes that trip up almost every Riverpod beginner. Learn to recognize and avoid them:\n\n### Mistake 1: Forgetting ProviderScope\n\n**The Error:**\n```\nBad state: No ProviderScope found\n```\n\n**The Problem:**\n```dart\nvoid main() {\n  runApp(MyApp());  // Missing ProviderScope!\n}\n```\n\n**The Fix:**\n```dart\nvoid main() {\n  runApp(\n    ProviderScope(  // Always wrap your app!\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n### Mistake 2: Using ref.read() in build Method\n\n**The Problem:**\n```dart\nWidget build(BuildContext context, WidgetRef ref) {\n  final count = ref.read(counterProvider);  // WRONG!\n  return Text('$count');  // This will NEVER update!\n}\n```\n\n**The Fix:**\n```dart\nWidget build(BuildContext context, WidgetRef ref) {\n  final count = ref.watch(counterProvider);  // Correct!\n  return Text('$count');  // Now updates when count changes\n}\n```\n\n### Mistake 3: Creating Providers Inside Widgets\n\n**The Problem:**\n```dart\nclass MyWidget extends ConsumerWidget {\n  // WRONG: Provider created inside widget class\n  final myProvider = StateProvider<int>((ref) => 0);\n  \n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Text('${ref.watch(myProvider)}');\n  }\n}\n```\nThis creates a NEW provider every time the widget rebuilds!\n\n**The Fix:**\n```dart\n// CORRECT: Provider defined at top level (outside any class)\nfinal myProvider = StateProvider<int>((ref) => 0);\n\nclass MyWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Text('${ref.watch(myProvider)}');\n  }\n}\n```\n\n### Mistake 4: Using StatelessWidget Instead of ConsumerWidget\n\n**The Problem:**\n```dart\nclass MyScreen extends StatelessWidget {  // Wrong widget type!\n  @override\n  Widget build(BuildContext context) {  // No WidgetRef!\n    // How do I access providers?\n  }\n}\n```\n\n**The Fix:**\n```dart\nclass MyScreen extends ConsumerWidget {  // Correct!\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {  // Now has ref\n    final value = ref.watch(myProvider);  // Can access providers!\n    return Text(value);\n  }\n}\n```\n\n### Mistake 5: Not Disposing Resources\n\nIf your provider creates streams, timers, or controllers, clean them up:\n```dart\nfinal timerProvider = Provider<Timer>((ref) {\n  final timer = Timer.periodic(Duration(seconds: 1), (_) {});\n  \n  // Clean up when provider is disposed\n  ref.onDispose(() {\n    timer.cancel();\n  });\n  \n  return timer;\n});\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.4-challenge-1",
              "title": "Build a Name Greeter with Riverpod",
              "description": "Create a simple app where users type their name in a TextField and see 'Hello, {name}!' update in real-time using Riverpod state management.",
              "instructions": "Complete the following tasks:\n\n1. Create a StateProvider<String> called nameProvider with an empty string as the initial value\n2. Wrap the app in ProviderScope\n3. Create a ConsumerWidget called GreeterScreen\n4. Add a TextField that updates nameProvider when the user types\n5. Display 'Hello, {name}!' that updates in real-time as the user types\n6. If the name is empty, display 'Hello, stranger!'\n\nRemember:\n- Use ref.watch() in the build method to get the name for display\n- Use ref.read() in the onChanged callback to update the provider\n- The TextField needs a TextEditingController for proper behavior",
              "starterCode": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// TODO 1: Create a StateProvider<String> called nameProvider\n// Initial value should be an empty string ''\n\n\nvoid main() {\n  runApp(\n    // TODO 2: Wrap MyApp with ProviderScope\n    MyApp(),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Riverpod Greeter',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const GreeterScreen(),\n    );\n  }\n}\n\n// TODO 3: Change this to a ConsumerWidget\nclass GreeterScreen extends StatelessWidget {\n  const GreeterScreen({super.key});\n\n  @override\n  // TODO 4: Add WidgetRef ref parameter\n  Widget build(BuildContext context) {\n    // TODO 5: Watch the nameProvider to get the current name\n    final name = '';  // Replace this with ref.watch()\n    \n    // TODO 6: Create the greeting message\n    // If name is empty, show 'Hello, stranger!'\n    // Otherwise show 'Hello, {name}!'\n    final greeting = 'Hello!';\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Riverpod Greeter'),\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(24.0),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Display the greeting\n            Text(\n              greeting,\n              style: const TextStyle(\n                fontSize: 32,\n                fontWeight: FontWeight.bold,\n              ),\n              textAlign: TextAlign.center,\n            ),\n            const SizedBox(height: 40),\n            // TODO 7: Create TextField that updates nameProvider\n            TextField(\n              decoration: const InputDecoration(\n                labelText: 'Enter your name',\n                border: OutlineInputBorder(),\n              ),\n              onChanged: (value) {\n                // TODO: Update nameProvider using ref.read()\n                // ref.read(nameProvider.notifier).state = value;\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "solution": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// STEP 1: Create a StateProvider for the name\n// StateProvider is perfect for simple values like strings\nfinal nameProvider = StateProvider<String>((ref) => '');\n\nvoid main() {\n  runApp(\n    // STEP 2: Wrap the app in ProviderScope\n    // This is REQUIRED for Riverpod to work\n    const ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Riverpod Greeter',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const GreeterScreen(),\n    );\n  }\n}\n\n// STEP 3: Use ConsumerWidget to access providers\nclass GreeterScreen extends ConsumerWidget {\n  const GreeterScreen({super.key});\n\n  @override\n  // STEP 4: Add WidgetRef ref parameter to build method\n  Widget build(BuildContext context, WidgetRef ref) {\n    // STEP 5: Watch the provider to get the current name\n    // Using watch() means this widget rebuilds when name changes\n    final name = ref.watch(nameProvider);\n    \n    // STEP 6: Create greeting based on whether name is empty\n    final greeting = name.isEmpty \n        ? 'Hello, stranger!' \n        : 'Hello, $name!';\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Riverpod Greeter'),\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(24.0),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Display the greeting - updates automatically!\n            Text(\n              greeting,\n              style: const TextStyle(\n                fontSize: 32,\n                fontWeight: FontWeight.bold,\n              ),\n              textAlign: TextAlign.center,\n            ),\n            const SizedBox(height: 40),\n            // STEP 7: TextField that updates the provider\n            TextField(\n              decoration: const InputDecoration(\n                labelText: 'Enter your name',\n                border: OutlineInputBorder(),\n                hintText: 'Type your name here...',\n              ),\n              // Use ref.read() in callbacks, NOT ref.watch()\n              // ref.read() gets the notifier so we can update state\n              onChanged: (value) {\n                ref.read(nameProvider.notifier).state = value;\n              },\n            ),\n            const SizedBox(height: 20),\n            // Bonus: Clear button to reset the name\n            TextButton(\n              onPressed: () {\n                ref.read(nameProvider.notifier).state = '';\n              },\n              child: const Text('Clear'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// KEY CONCEPTS DEMONSTRATED:\n//\n// 1. StateProvider - holds a simple String value\n//\n// 2. ProviderScope - wraps the app to enable Riverpod\n//\n// 3. ConsumerWidget - allows access to providers via ref\n//\n// 4. ref.watch() - used in build() to read AND subscribe to changes\n//    The widget automatically rebuilds when the value changes\n//\n// 5. ref.read() - used in callbacks (onChanged, onPressed) to update\n//    Does not subscribe to changes, just gets the value/notifier once\n//\n// 6. .notifier.state - how to update a StateProvider's value\n//    ref.read(nameProvider.notifier).state = newValue;",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-provider",
                  "description": "nameProvider is defined as StateProvider<String>",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-scope",
                  "description": "App is wrapped in ProviderScope",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-consumer",
                  "description": "GreeterScreen extends ConsumerWidget",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-greeting",
                  "description": "Greeting shows 'stranger' when empty, name when filled",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "StateProvider is created like this: final nameProvider = StateProvider<String>((ref) => ''); The (ref) => '' part returns the initial value (empty string)."
                },
                {
                  "level": 2,
                  "text": "To update a StateProvider, use ref.read(nameProvider.notifier).state = newValue. The .notifier gives you access to the state setter."
                },
                {
                  "level": 3,
                  "text": "ConsumerWidget's build method has TWO parameters: (BuildContext context, WidgetRef ref). The ref is what you use to watch and read providers."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using ref.read() instead of ref.watch() in build method",
                  "consequence": "UI does not update when the name changes",
                  "correction": "Use ref.watch(nameProvider) in the build method. watch() subscribes to changes, read() does not."
                },
                {
                  "mistake": "Using ref.watch() in onChanged callback",
                  "consequence": "Creates unnecessary subscriptions and potential performance issues",
                  "correction": "Use ref.read(nameProvider.notifier).state = value in callbacks. read() is for one-time access."
                },
                {
                  "mistake": "Forgetting to wrap app in ProviderScope",
                  "consequence": "Runtime error: Bad state: No ProviderScope found",
                  "correction": "In main(), wrap your app: runApp(ProviderScope(child: MyApp()))"
                },
                {
                  "mistake": "Extending StatelessWidget instead of ConsumerWidget",
                  "consequence": "No ref parameter available, cannot access providers",
                  "correction": "Change 'extends StatelessWidget' to 'extends ConsumerWidget' and add WidgetRef ref parameter"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "5.5",
          "title": "ViewModels with Notifier",
          "moduleId": "module-05",
          "order": 5,
          "estimatedMinutes": 50,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What is a Notifier?",
              "content": "In the previous lesson, you learned about StateProvider for simple values like counters and toggles. StateProvider is great for holding a single value, but what happens when you need more than just a value? What if you need **methods** to modify that value in specific ways?\n\nThis is where **Notifier** comes in.\n\n### StateProvider Limitations\n\nStateProvider is like a simple box that holds a value. You can read it and replace it, but that is all:\n\n```dart\n// StateProvider - just holds a value\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\n// To update, you directly modify state\nref.read(counterProvider.notifier).state++;\nref.read(counterProvider.notifier).state = 0;  // Reset\n```\n\nThis works, but notice the problems:\n- Logic is scattered in widgets (where do you put validation?)\n- No encapsulation (anyone can set any value)\n- Hard to test (logic is in UI code)\n\n### Notifier = State + Methods\n\nA **Notifier** is a class that holds state AND provides methods to modify it. Think of it as a smart box that knows HOW its contents should change.\n\n```dart\n// Notifier - holds state AND has methods\nclass CounterNotifier extends Notifier<int> {\n  @override\n  int build() => 0;  // Initial state\n\n  void increment() => state = state + 1;\n  void decrement() => state = state - 1;\n  void reset() => state = 0;\n}\n```\n\nNow all your logic is in one place, encapsulated, and testable.\n\n### Notifier IS Your ViewModel\n\nRemember MVVM from earlier lessons? The **Notifier** is your **ViewModel**! It sits between your Model (data) and your View (widgets), managing state and business logic.\n\n```\n+------------------+\n|      VIEW        |  <- Flutter Widgets\n+--------+---------+\n         |\n         v\n+--------+---------+\n|     NOTIFIER     |  <- Your ViewModel\n|  (state + logic) |\n+--------+---------+\n         |\n         v\n+--------+---------+\n|      MODEL       |  <- Data classes\n+------------------+\n```\n\nThe pattern is: **Notifier + NotifierProvider**. The Notifier class holds your logic, and the NotifierProvider makes it available throughout your app."
            },
            {
              "type": "THEORY",
              "title": "Anatomy of a Notifier",
              "content": "Let us break down every part of a Notifier class. Understanding each piece is crucial for building proper ViewModels.\n\n### The Complete Structure\n\nHere is a complete Notifier with annotations explaining each part:",
              "code": "import 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Step 1: Create your Notifier class\n// - Extends Notifier<T> where T is the STATE TYPE\n// - This class holds your state and all methods to modify it\nclass CounterNotifier extends Notifier<int> {\n  \n  // Step 2: Override the build() method\n  // - Called when provider is FIRST ACCESSED\n  // - Returns the INITIAL STATE\n  // - Think of it as your constructor\n  @override\n  int build() {\n    // You can access other providers here using ref\n    // final someValue = ref.watch(otherProvider);\n    \n    // Return initial state\n    return 0;\n  }\n\n  // Step 3: Create methods to modify state\n  // - Use 'state' property to read current value\n  // - Assign to 'state' to update (triggers rebuilds)\n  \n  void increment() {\n    // 'state' is the current value (int in this case)\n    // Assigning to 'state' updates it and notifies listeners\n    state = state + 1;\n  }\n\n  void decrement() {\n    state = state - 1;\n  }\n\n  void reset() {\n    state = 0;\n  }\n  \n  // You can add validation and complex logic\n  void setValue(int value) {\n    // Business logic: only allow positive values\n    if (value >= 0) {\n      state = value;\n    }\n  }\n  \n  // You can have getters for derived values\n  bool get isZero => state == 0;\n  bool get isPositive => state > 0;\n}\n\n// Step 4: Create the NotifierProvider\n// - NotifierProvider<NotifierClass, StateType>\n// - The () => NotifierClass() creates a new instance\nfinal counterProvider = NotifierProvider<CounterNotifier, int>(() {\n  return CounterNotifier();\n});",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Todo ViewModel",
              "content": "Let us build a real-world example: a Todo list with full CRUD operations (Create, Read, Update, Delete). This example shows how Notifier handles complex state.\n\n### The Model\n\nFirst, we define our data structure (the Model layer in MVVM):",
              "code": "// =====================================\n// MODEL: Todo data class\n// =====================================\nclass Todo {\n  final String id;\n  final String title;\n  final bool isCompleted;\n  final DateTime createdAt;\n\n  const Todo({\n    required this.id,\n    required this.title,\n    this.isCompleted = false,\n    required this.createdAt,\n  });\n\n  // Immutable update - creates new instance with changes\n  Todo copyWith({\n    String? id,\n    String? title,\n    bool? isCompleted,\n    DateTime? createdAt,\n  }) {\n    return Todo(\n      id: id ?? this.id,\n      title: title ?? this.title,\n      isCompleted: isCompleted ?? this.isCompleted,\n      createdAt: createdAt ?? this.createdAt,\n    );\n  }\n}\n\n// =====================================\n// VIEWMODEL: TodoNotifier\n// =====================================\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoNotifier extends Notifier<List<Todo>> {\n  @override\n  List<Todo> build() {\n    // Initial state: empty list\n    // In a real app, you might load from a database here\n    return [];\n  }\n\n  // CREATE: Add a new todo\n  void addTodo(String title) {\n    // Validate: do not add empty todos\n    if (title.trim().isEmpty) return;\n\n    final newTodo = Todo(\n      id: DateTime.now().millisecondsSinceEpoch.toString(),\n      title: title.trim(),\n      createdAt: DateTime.now(),\n    );\n\n    // Create NEW list with the new todo\n    // Never mutate the existing list!\n    state = [...state, newTodo];\n  }\n\n  // DELETE: Remove a todo by ID\n  void removeTodo(String id) {\n    // Filter out the todo with matching ID\n    state = state.where((todo) => todo.id != id).toList();\n  }\n\n  // UPDATE: Toggle completion status\n  void toggleComplete(String id) {\n    state = state.map((todo) {\n      if (todo.id == id) {\n        // Return new Todo with flipped isCompleted\n        return todo.copyWith(isCompleted: !todo.isCompleted);\n      }\n      return todo;  // Return unchanged\n    }).toList();\n  }\n\n  // UPDATE: Edit todo title\n  void editTodo(String id, String newTitle) {\n    if (newTitle.trim().isEmpty) return;\n\n    state = state.map((todo) {\n      if (todo.id == id) {\n        return todo.copyWith(title: newTitle.trim());\n      }\n      return todo;\n    }).toList();\n  }\n\n  // BULK: Mark all as complete\n  void completeAll() {\n    state = state.map((todo) => todo.copyWith(isCompleted: true)).toList();\n  }\n\n  // BULK: Clear all completed\n  void clearCompleted() {\n    state = state.where((todo) => !todo.isCompleted).toList();\n  }\n\n  // GETTERS: Computed values (not state, just derived)\n  int get totalCount => state.length;\n  int get completedCount => state.where((t) => t.isCompleted).length;\n  int get pendingCount => state.where((t) => !t.isCompleted).length;\n}\n\n// Create the provider\nfinal todoProvider = NotifierProvider<TodoNotifier, List<Todo>>(() {\n  return TodoNotifier();\n});\n\n// =====================================\n// VIEW: Using the ViewModel in a Widget\n// =====================================\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TodoScreen extends ConsumerWidget {\n  const TodoScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // WATCH the state - rebuilds when todos change\n    final todos = ref.watch(todoProvider);\n    \n    // You can also watch the notifier for computed values\n    final notifier = ref.watch(todoProvider.notifier);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Todos (${notifier.pendingCount} pending)'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.delete_sweep),\n            onPressed: () {\n              // READ the notifier to call methods\n              ref.read(todoProvider.notifier).clearCompleted();\n            },\n          ),\n        ],\n      ),\n      body: ListView.builder(\n        itemCount: todos.length,\n        itemBuilder: (context, index) {\n          final todo = todos[index];\n          return ListTile(\n            leading: Checkbox(\n              value: todo.isCompleted,\n              onChanged: (_) {\n                ref.read(todoProvider.notifier).toggleComplete(todo.id);\n              },\n            ),\n            title: Text(\n              todo.title,\n              style: TextStyle(\n                decoration: todo.isCompleted \n                    ? TextDecoration.lineThrough \n                    : null,\n              ),\n            ),\n            trailing: IconButton(\n              icon: const Icon(Icons.delete),\n              onPressed: () {\n                ref.read(todoProvider.notifier).removeTodo(todo.id);\n              },\n            ),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => _showAddDialog(context, ref),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n\n  void _showAddDialog(BuildContext context, WidgetRef ref) {\n    final controller = TextEditingController();\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: const Text('Add Todo'),\n        content: TextField(\n          controller: controller,\n          autofocus: true,\n          decoration: const InputDecoration(hintText: 'Enter todo title'),\n        ),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(context),\n            child: const Text('Cancel'),\n          ),\n          ElevatedButton(\n            onPressed: () {\n              ref.read(todoProvider.notifier).addTodo(controller.text);\n              Navigator.pop(context);\n            },\n            child: const Text('Add'),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Accessing the Notifier",
              "content": "There is an important distinction between watching the **state** and accessing the **notifier** (to call methods). Understanding this is critical.\n\n### Watching State vs Reading Notifier\n\n```dart\n// WATCH THE STATE (the value)\n// Use when you need to DISPLAY data\n// Widget rebuilds when state changes\nfinal todos = ref.watch(todoProvider);\n// todos is List<Todo> - the actual data\n\n// READ THE NOTIFIER (to call methods)\n// Use when you need to TRIGGER ACTIONS\n// Does NOT cause rebuilds\nref.read(todoProvider.notifier).addTodo('Buy milk');\n// .notifier gives you the TodoNotifier class\n```\n\n### The .notifier Accessor\n\nThe `.notifier` accessor is how you get the Notifier class itself (not just its state). You need this to call methods:\n\n```dart\n// This gets the STATE (List<Todo>)\nfinal todos = ref.watch(todoProvider);\n\n// This gets the NOTIFIER (TodoNotifier)\nfinal notifier = ref.read(todoProvider.notifier);\n\n// Now you can call methods\nnotifier.addTodo('Buy milk');\nnotifier.toggleComplete('123');\nnotifier.removeTodo('456');\n\n// Or inline:\nref.read(todoProvider.notifier).addTodo('Buy milk');\n```\n\n### Golden Rules Reminder\n\n| What You Need | Use | Where |\n|---------------|-----|-------|\n| Display data | `ref.watch(provider)` | In build() method |\n| Call methods | `ref.read(provider.notifier).method()` | In callbacks/handlers |\n\n### Common Pattern in Widgets\n\n```dart\nclass MyWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // WATCH for display (in build)\n    final count = ref.watch(counterProvider);\n\n    return Column(\n      children: [\n        Text('Count: $count'),\n        ElevatedButton(\n          // READ for actions (in callback)\n          onPressed: () => ref.read(counterProvider.notifier).increment(),\n          child: Text('Add'),\n        ),\n      ],\n    );\n  }\n}\n```"
            },
            {
              "type": "KEY_POINT",
              "title": "ViewModel Best Practices",
              "content": "Following these best practices will help you write clean, maintainable ViewModels.\n\n### 1. Keep ViewModels Focused\n\nEach ViewModel should handle ONE feature or concern. If your ViewModel is getting too large, split it:\n\n**Bad:**\n```dart\nclass AppNotifier extends Notifier<AppState> {\n  // Handles auth, cart, settings, notifications...\n  // This is too much!\n}\n```\n\n**Good:**\n```dart\nclass AuthNotifier extends Notifier<AuthState> { /* auth only */ }\nclass CartNotifier extends Notifier<CartState> { /* cart only */ }\nclass SettingsNotifier extends Notifier<Settings> { /* settings only */ }\n```\n\n### 2. Use Descriptive Method Names\n\nMethod names should clearly describe what they do. Future you (and your teammates) will thank you:\n\n**Bad:**\n```dart\nvoid add(Todo t) { ... }     // Add what? Where?\nvoid update(String s) { ... } // Update what with what?\nvoid toggle() { ... }         // Toggle what?\n```\n\n**Good:**\n```dart\nvoid addTodo(Todo todo) { ... }\nvoid updateTodoTitle(String id, String newTitle) { ... }\nvoid toggleTodoCompletion(String id) { ... }\n```\n\n### 3. Keep UI Code OUT of ViewModel\n\nThe ViewModel should NEVER import Flutter widgets or know about the UI:\n\n**Bad:**\n```dart\nclass TodoNotifier extends Notifier<List<Todo>> {\n  void addTodo(String title, BuildContext context) {\n    // NO! ViewModel should not know about BuildContext\n    ScaffoldMessenger.of(context).showSnackBar(...);\n  }\n}\n```\n\n**Good:**\n```dart\nclass TodoNotifier extends Notifier<List<Todo>> {\n  void addTodo(String title) {\n    state = [...state, Todo(title: title)];\n    // View will react to state change and can show feedback\n  }\n}\n\n// In widget:\nonPressed: () {\n  ref.read(todoProvider.notifier).addTodo(title);\n  ScaffoldMessenger.of(context).showSnackBar(...);\n}\n```\n\n### 4. Test ViewModels Independently\n\nBecause ViewModels have no UI dependencies, they are easy to test:\n\n```dart\ntest('addTodo adds a new todo to the list', () {\n  final container = ProviderContainer();\n  final notifier = container.read(todoProvider.notifier);\n\n  notifier.addTodo('Test todo');\n\n  final todos = container.read(todoProvider);\n  expect(todos.length, 1);\n  expect(todos.first.title, 'Test todo');\n});\n```\n\n### 5. State Should Be Immutable\n\nNever mutate state directly. Always create new objects:\n\n**Bad:**\n```dart\nstate.add(newTodo);  // Mutating existing list - BAD!\n```\n\n**Good:**\n```dart\nstate = [...state, newTodo];  // New list - GOOD!\n```"
            },
            {
              "type": "WARNING",
              "title": "Common Notifier Mistakes",
              "content": "These mistakes trip up almost everyone when starting with Notifier. Learn to recognize and avoid them.\n\n### Mistake 1: Calling Methods in build() Without User Action\n\n**The Problem:**\n```dart\nclass MyWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // WRONG! This calls loadData on EVERY rebuild!\n    ref.read(dataProvider.notifier).loadData();\n    \n    return Text('...');\n  }\n}\n```\n\nThis creates an infinite loop: load data -> state changes -> widget rebuilds -> load data again...\n\n**The Fix:**\nLoad data in the Notifier's build() method, or use a ref.listen:\n```dart\nclass DataNotifier extends Notifier<Data> {\n  @override\n  Data build() {\n    // Load data when provider is first created\n    _loadData();\n    return Data.empty();\n  }\n  \n  Future<void> _loadData() async { ... }\n}\n```\n\n### Mistake 2: Modifying State Directly (Bypassing Notifier)\n\n**The Problem:**\n```dart\n// Getting the list and trying to modify it directly\nfinal todos = ref.read(todoProvider);\ntodos.add(newTodo);  // This does NOTHING!\n```\n\nThis does not update state because you are just modifying a local copy. Widgets will not rebuild.\n\n**The Fix:**\nAlways go through the Notifier:\n```dart\nref.read(todoProvider.notifier).addTodo(newTodo);\n```\n\n### Mistake 3: Making the Notifier Too Large\n\n**The Problem:**\n```dart\nclass EverythingNotifier extends Notifier<AppState> {\n  void login() { ... }\n  void logout() { ... }\n  void addToCart() { ... }\n  void removeFromCart() { ... }\n  void updateProfile() { ... }\n  void changeTheme() { ... }\n  void sendMessage() { ... }\n  // 50 more methods...\n}\n```\n\nThis becomes unmaintainable and hard to test.\n\n**The Fix:**\nSplit into focused Notifiers:\n```dart\nclass AuthNotifier extends Notifier<AuthState> { ... }\nclass CartNotifier extends Notifier<CartState> { ... }\nclass ProfileNotifier extends Notifier<ProfileState> { ... }\nclass ThemeNotifier extends Notifier<ThemeData> { ... }\n```\n\n### Mistake 4: Forgetting That State Must Be Replaced\n\n**The Problem:**\n```dart\nvoid updateUser(String name) {\n  state.name = name;  // This does NOT work!\n  // State object was not replaced, so no notification happens\n}\n```\n\n**The Fix:**\nCreate a new state object:\n```dart\nvoid updateUser(String name) {\n  state = state.copyWith(name: name);  // New object, notifications sent\n}\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.5-challenge-1",
              "title": "Build a Shopping Cart ViewModel",
              "description": "Create a complete shopping cart system using Notifier. The cart should support adding items, removing items, clearing all items, and calculating the total price.",
              "instructions": "Build a shopping cart ViewModel with the following requirements:\n\n1. Create a CartItem class with: id (String), name (String), price (double), quantity (int)\n2. Create a CartNotifier that extends Notifier<List<CartItem>>\n3. Implement these methods:\n   - addItem(CartItem item): Adds item to cart. If item with same id exists, increase quantity instead\n   - removeItem(String id): Removes item from cart by id\n   - updateQuantity(String id, int quantity): Updates quantity. If quantity is 0 or less, remove the item\n   - clear(): Removes all items from cart\n4. Add these getters:\n   - totalItems: Total number of items (sum of all quantities)\n   - totalPrice: Total price (sum of price * quantity for all items)\n5. Create the cartProvider using NotifierProvider\n6. Build a simple UI that displays cart items and total, with buttons to add sample items and clear the cart",
              "starterCode": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Shopping Cart',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const CartScreen(),\n    );\n  }\n}\n\n// TODO 1: Create CartItem class\n// - id (String)\n// - name (String)\n// - price (double)\n// - quantity (int, default 1)\n// - copyWith method for immutable updates\nclass CartItem {\n  // Your code here\n}\n\n// TODO 2: Create CartNotifier\nclass CartNotifier extends Notifier<List<CartItem>> {\n  @override\n  List<CartItem> build() {\n    // TODO: Return initial empty state\n    return [];\n  }\n\n  // TODO 3: Implement addItem\n  // If item with same id exists, increase quantity\n  // Otherwise, add new item\n  void addItem(CartItem item) {\n    // Your code here\n  }\n\n  // TODO 4: Implement removeItem\n  void removeItem(String id) {\n    // Your code here\n  }\n\n  // TODO 5: Implement updateQuantity\n  // If quantity <= 0, remove the item\n  void updateQuantity(String id, int quantity) {\n    // Your code here\n  }\n\n  // TODO 6: Implement clear\n  void clear() {\n    // Your code here\n  }\n\n  // TODO 7: Add totalItems getter (sum of all quantities)\n  int get totalItems {\n    return 0;\n  }\n\n  // TODO 8: Add totalPrice getter (sum of price * quantity)\n  double get totalPrice {\n    return 0.0;\n  }\n}\n\n// TODO 9: Create the provider\n// final cartProvider = NotifierProvider<CartNotifier, List<CartItem>>(...)\n\n// TODO 10: Build the UI\nclass CartScreen extends ConsumerWidget {\n  const CartScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // TODO: Watch cart items\n    // TODO: Display items in a ListView\n    // TODO: Show total items and total price\n    // TODO: Add buttons to add sample items\n    // TODO: Add clear cart button\n    \n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Shopping Cart'),\n      ),\n      body: const Center(\n        child: Text('Implement cart UI here'),\n      ),\n    );\n  }\n}",
              "solution": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Shopping Cart',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const CartScreen(),\n    );\n  }\n}\n\n// STEP 1: CartItem Model\nclass CartItem {\n  final String id;\n  final String name;\n  final double price;\n  final int quantity;\n\n  const CartItem({\n    required this.id,\n    required this.name,\n    required this.price,\n    this.quantity = 1,\n  });\n\n  CartItem copyWith({\n    String? id,\n    String? name,\n    double? price,\n    int? quantity,\n  }) {\n    return CartItem(\n      id: id ?? this.id,\n      name: name ?? this.name,\n      price: price ?? this.price,\n      quantity: quantity ?? this.quantity,\n    );\n  }\n}\n\n// STEP 2: CartNotifier ViewModel\nclass CartNotifier extends Notifier<List<CartItem>> {\n  @override\n  List<CartItem> build() {\n    return [];  // Start with empty cart\n  }\n\n  // STEP 3: Add item (or increase quantity if exists)\n  void addItem(CartItem item) {\n    final existingIndex = state.indexWhere((i) => i.id == item.id);\n    \n    if (existingIndex >= 0) {\n      // Item exists - increase quantity\n      state = [\n        for (int i = 0; i < state.length; i++)\n          if (i == existingIndex)\n            state[i].copyWith(quantity: state[i].quantity + item.quantity)\n          else\n            state[i]\n      ];\n    } else {\n      // New item - add to cart\n      state = [...state, item];\n    }\n  }\n\n  // STEP 4: Remove item\n  void removeItem(String id) {\n    state = state.where((item) => item.id != id).toList();\n  }\n\n  // STEP 5: Update quantity\n  void updateQuantity(String id, int quantity) {\n    if (quantity <= 0) {\n      removeItem(id);\n      return;\n    }\n    \n    state = state.map((item) {\n      if (item.id == id) {\n        return item.copyWith(quantity: quantity);\n      }\n      return item;\n    }).toList();\n  }\n\n  // STEP 6: Clear cart\n  void clear() {\n    state = [];\n  }\n\n  // STEP 7: Total items (sum of quantities)\n  int get totalItems {\n    return state.fold(0, (sum, item) => sum + item.quantity);\n  }\n\n  // STEP 8: Total price\n  double get totalPrice {\n    return state.fold(0.0, (sum, item) => sum + (item.price * item.quantity));\n  }\n}\n\n// STEP 9: Create the provider\nfinal cartProvider = NotifierProvider<CartNotifier, List<CartItem>>(() {\n  return CartNotifier();\n});\n\n// Sample products for testing\nfinal sampleProducts = [\n  const CartItem(id: '1', name: 'Apple', price: 1.50),\n  const CartItem(id: '2', name: 'Banana', price: 0.75),\n  const CartItem(id: '3', name: 'Orange', price: 2.00),\n  const CartItem(id: '4', name: 'Milk', price: 3.50),\n];\n\n// STEP 10: Cart Screen UI\nclass CartScreen extends ConsumerWidget {\n  const CartScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the cart items\n    final cartItems = ref.watch(cartProvider);\n    // Get the notifier for computed values and methods\n    final cart = ref.watch(cartProvider.notifier);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Cart (${cart.totalItems} items)'),\n        actions: [\n          if (cartItems.isNotEmpty)\n            IconButton(\n              icon: const Icon(Icons.delete_sweep),\n              onPressed: () => ref.read(cartProvider.notifier).clear(),\n              tooltip: 'Clear Cart',\n            ),\n        ],\n      ),\n      body: Column(\n        children: [\n          // Product buttons\n          Container(\n            padding: const EdgeInsets.all(16),\n            color: Colors.grey[100],\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                const Text(\n                  'Add Products:',\n                  style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),\n                ),\n                const SizedBox(height: 8),\n                Wrap(\n                  spacing: 8,\n                  runSpacing: 8,\n                  children: sampleProducts.map((product) {\n                    return ElevatedButton(\n                      onPressed: () {\n                        ref.read(cartProvider.notifier).addItem(product);\n                      },\n                      child: Text('${product.name} (\\$${product.price.toStringAsFixed(2)})'),\n                    );\n                  }).toList(),\n                ),\n              ],\n            ),\n          ),\n          \n          // Cart items list\n          Expanded(\n            child: cartItems.isEmpty\n                ? const Center(\n                    child: Text(\n                      'Cart is empty\\nTap a product to add it!',\n                      textAlign: TextAlign.center,\n                      style: TextStyle(fontSize: 18, color: Colors.grey),\n                    ),\n                  )\n                : ListView.builder(\n                    itemCount: cartItems.length,\n                    itemBuilder: (context, index) {\n                      final item = cartItems[index];\n                      return ListTile(\n                        title: Text(item.name),\n                        subtitle: Text(\n                          '\\$${item.price.toStringAsFixed(2)} x ${item.quantity} = \\$${(item.price * item.quantity).toStringAsFixed(2)}',\n                        ),\n                        trailing: Row(\n                          mainAxisSize: MainAxisSize.min,\n                          children: [\n                            IconButton(\n                              icon: const Icon(Icons.remove_circle_outline),\n                              onPressed: () {\n                                ref.read(cartProvider.notifier).updateQuantity(\n                                  item.id,\n                                  item.quantity - 1,\n                                );\n                              },\n                            ),\n                            Text(\n                              '${item.quantity}',\n                              style: const TextStyle(fontSize: 18),\n                            ),\n                            IconButton(\n                              icon: const Icon(Icons.add_circle_outline),\n                              onPressed: () {\n                                ref.read(cartProvider.notifier).updateQuantity(\n                                  item.id,\n                                  item.quantity + 1,\n                                );\n                              },\n                            ),\n                            IconButton(\n                              icon: const Icon(Icons.delete, color: Colors.red),\n                              onPressed: () {\n                                ref.read(cartProvider.notifier).removeItem(item.id);\n                              },\n                            ),\n                          ],\n                        ),\n                      );\n                    },\n                  ),\n          ),\n          \n          // Total bar\n          if (cartItems.isNotEmpty)\n            Container(\n              padding: const EdgeInsets.all(16),\n              decoration: BoxDecoration(\n                color: Colors.blue[50],\n                boxShadow: [\n                  BoxShadow(\n                    color: Colors.grey.withOpacity(0.3),\n                    blurRadius: 4,\n                    offset: const Offset(0, -2),\n                  ),\n                ],\n              ),\n              child: Row(\n                mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                children: [\n                  Text(\n                    'Total: ${cart.totalItems} items',\n                    style: const TextStyle(fontSize: 16),\n                  ),\n                  Text(\n                    '\\$${cart.totalPrice.toStringAsFixed(2)}',\n                    style: const TextStyle(\n                      fontSize: 24,\n                      fontWeight: FontWeight.bold,\n                      color: Colors.blue,\n                    ),\n                  ),\n                ],\n              ),\n            ),\n        ],\n      ),\n    );\n  }\n}\n\n// KEY CONCEPTS DEMONSTRATED:\n//\n// 1. CartItem Model: Pure data class with copyWith for immutability\n//\n// 2. CartNotifier: ViewModel that encapsulates all cart logic\n//    - State is List<CartItem>\n//    - Methods modify state immutably\n//    - Getters provide computed values\n//\n// 3. NotifierProvider: Makes CartNotifier available app-wide\n//\n// 4. ref.watch(): Used to display cart items (rebuilds on change)\n//\n// 5. ref.read(): Used in callbacks to call notifier methods\n//\n// 6. Immutable updates: Always create new lists/objects, never mutate",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-add-item",
                  "description": "addItem adds new items to cart",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-add-existing",
                  "description": "addItem increases quantity for existing items",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-remove-item",
                  "description": "removeItem removes item from cart",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-update-quantity",
                  "description": "updateQuantity changes item quantity",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-clear",
                  "description": "clear removes all items",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-totals",
                  "description": "totalItems and totalPrice calculate correctly",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "For addItem, use indexWhere to check if an item with the same id already exists. If index is >= 0, the item exists and you should increase its quantity."
                },
                {
                  "level": 2,
                  "text": "Use list comprehension with 'for' and 'if' for conditional updates: state = [for (int i = 0; i < state.length; i++) if (condition) modifiedItem else state[i]]"
                },
                {
                  "level": 3,
                  "text": "For totalItems, use fold: state.fold(0, (sum, item) => sum + item.quantity). For totalPrice: state.fold(0.0, (sum, item) => sum + item.price * item.quantity)"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Mutating state directly with state.add() or state[index].quantity++",
                  "consequence": "State changes but widgets do not rebuild because Riverpod did not detect the change",
                  "correction": "Always create new lists/objects: state = [...state, newItem] or state = state.map(...).toList()"
                },
                {
                  "mistake": "Using ref.watch() in onPressed callbacks",
                  "consequence": "Creates unnecessary subscriptions and potential bugs",
                  "correction": "Use ref.read() in callbacks: ref.read(cartProvider.notifier).addItem(item)"
                },
                {
                  "mistake": "Forgetting to handle the case where item already exists in addItem",
                  "consequence": "Duplicate items appear in cart instead of increasing quantity",
                  "correction": "Check if item exists with indexWhere before adding. If exists, update quantity instead."
                },
                {
                  "mistake": "Not handling quantity <= 0 in updateQuantity",
                  "consequence": "Items with zero or negative quantity remain in cart",
                  "correction": "Add a check: if (quantity <= 0) { removeItem(id); return; }"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.6",
          "title": "AsyncValue and Loading States",
          "moduleId": "module-05",
          "order": 6,
          "estimatedMinutes": 55,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Problem with Async Data",
              "content": "In real apps, most data comes from somewhere else: an API, a database, a file. These operations take **time**. While waiting, your app needs to handle three possible outcomes:\n\n1. **Loading**: The data is being fetched (show a spinner)\n2. **Success**: The data arrived (show the data)\n3. **Error**: Something went wrong (show an error message)\n\n### The Manual Approach Is Tedious\n\nWithout Riverpod, you would handle this manually in every widget:\n\n```dart\nclass UserProfileScreen extends StatefulWidget {\n  @override\n  State<UserProfileScreen> createState() => _UserProfileScreenState();\n}\n\nclass _UserProfileScreenState extends State<UserProfileScreen> {\n  User? user;\n  bool isLoading = true;\n  String? errorMessage;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadUser();\n  }\n\n  Future<void> _loadUser() async {\n    setState(() {\n      isLoading = true;\n      errorMessage = null;\n    });\n    \n    try {\n      final response = await http.get(Uri.parse('https://api.example.com/user'));\n      setState(() {\n        user = User.fromJson(jsonDecode(response.body));\n        isLoading = false;\n      });\n    } catch (e) {\n      setState(() {\n        errorMessage = e.toString();\n        isLoading = false;\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (isLoading) return CircularProgressIndicator();\n    if (errorMessage != null) return Text('Error: $errorMessage');\n    return Text('Hello, ${user!.name}');\n  }\n}\n```\n\nThat is **50 lines** just to load and display one piece of data! And you need to repeat this pattern for every async operation.\n\n### The Problems\n\n1. **Boilerplate**: Three state variables for every async operation\n2. **Error-prone**: Easy to forget setting isLoading = false\n3. **Not reusable**: Logic is stuck in the widget\n4. **Hard to test**: Logic mixed with UI\n5. **Repetitive**: Same pattern copied everywhere"
            },
            {
              "type": "THEORY",
              "title": "AsyncValue to the Rescue",
              "content": "Riverpod provides **AsyncValue<T>** to elegantly handle all three states. It is a sealed class that wraps your data type and tells you whether you are loading, have data, or encountered an error.\n\n### The Three States\n\n**AsyncValue** has three possible states:\n\n```dart\n// 1. LOADING - Data is being fetched\nAsyncValue<User>.loading()\n\n// 2. DATA - Success! Here's your data\nAsyncValue<User>.data(user)\n\n// 3. ERROR - Something went wrong\nAsyncValue<User>.error(exception, stackTrace)\n```\n\n### How Riverpod Creates AsyncValue\n\nWhen you use **FutureProvider** or **AsyncNotifier**, Riverpod automatically wraps your data in AsyncValue:\n\n```dart\n// FutureProvider returns AsyncValue automatically\nfinal userProvider = FutureProvider<User>((ref) async {\n  final response = await http.get(Uri.parse('https://api.example.com/user'));\n  return User.fromJson(jsonDecode(response.body));\n});\n\n// When you watch it, you get AsyncValue<User>\nfinal userAsync = ref.watch(userProvider);  // Type: AsyncValue<User>\n```\n\n### The Benefits\n\n1. **Type-safe**: Compiler ensures you handle all states\n2. **No boilerplate**: No manual isLoading, hasError variables\n3. **Consistent pattern**: Same approach everywhere\n4. **Easy to use**: The `when()` method handles everything\n5. **Testable**: Logic is separate from UI"
            },
            {
              "type": "EXAMPLE",
              "title": "FutureProvider for Simple Cases",
              "content": "**FutureProvider** is the simplest way to fetch async data. Use it when you just need to fetch data once and display it. The provider automatically manages the loading and error states for you.",
              "code": "import 'dart:convert';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:http/http.dart' as http;\n\n// User Model\nclass User {\n  final String id;\n  final String name;\n  final String email;\n\n  User({required this.id, required this.name, required this.email});\n\n  factory User.fromJson(Map<String, dynamic> json) {\n    return User(\n      id: json['id'].toString(),\n      name: json['name'],\n      email: json['email'],\n    );\n  }\n}\n\n// FutureProvider - fetches user data\n// Riverpod handles loading/error states automatically!\nfinal userProvider = FutureProvider<User>((ref) async {\n  // Simulate network delay for demo\n  await Future.delayed(const Duration(seconds: 2));\n  \n  // In real app: fetch from API\n  final response = await http.get(\n    Uri.parse('https://jsonplaceholder.typicode.com/users/1'),\n  );\n  \n  if (response.statusCode == 200) {\n    return User.fromJson(jsonDecode(response.body));\n  } else {\n    throw Exception('Failed to load user');\n  }\n});\n\n// Widget using the provider\nclass UserScreen extends ConsumerWidget {\n  const UserScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch returns AsyncValue<User>\n    final userAsync = ref.watch(userProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('User Profile')),\n      body: Center(\n        // The magic: when() handles all three states!\n        child: userAsync.when(\n          // LOADING STATE: Show spinner\n          loading: () => const Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              CircularProgressIndicator(),\n              SizedBox(height: 16),\n              Text('Loading user...'),\n            ],\n          ),\n          \n          // ERROR STATE: Show error message\n          error: (error, stackTrace) => Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              const Icon(Icons.error, color: Colors.red, size: 48),\n              const SizedBox(height: 16),\n              Text('Error: $error'),\n              const SizedBox(height: 16),\n              ElevatedButton(\n                // Refresh: invalidate the provider to retry\n                onPressed: () => ref.invalidate(userProvider),\n                child: const Text('Retry'),\n              ),\n            ],\n          ),\n          \n          // DATA STATE: Show the user\n          data: (user) => Card(\n            margin: const EdgeInsets.all(16),\n            child: Padding(\n              padding: const EdgeInsets.all(24),\n              child: Column(\n                mainAxisSize: MainAxisSize.min,\n                children: [\n                  const CircleAvatar(\n                    radius: 40,\n                    child: Icon(Icons.person, size: 40),\n                  ),\n                  const SizedBox(height: 16),\n                  Text(\n                    user.name,\n                    style: const TextStyle(\n                      fontSize: 24,\n                      fontWeight: FontWeight.bold,\n                    ),\n                  ),\n                  const SizedBox(height: 8),\n                  Text(\n                    user.email,\n                    style: TextStyle(color: Colors.grey[600]),\n                  ),\n                  const SizedBox(height: 16),\n                  ElevatedButton.icon(\n                    onPressed: () => ref.invalidate(userProvider),\n                    icon: const Icon(Icons.refresh),\n                    label: const Text('Refresh'),\n                  ),\n                ],\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Main app\nvoid main() {\n  runApp(\n    const ProviderScope(\n      child: MaterialApp(home: UserScreen()),\n    ),\n  );\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "AsyncNotifier for Complex Cases",
              "content": "**FutureProvider** is great for simple fetch-and-display scenarios. But what if you need to:\n- Refresh the data on demand?\n- Modify the data after fetching?\n- Have multiple async operations?\n\nThis is where **AsyncNotifier** comes in. It combines the power of Notifier (methods for state management) with AsyncValue (loading/error handling).\n\n### AsyncNotifier Structure\n\nAsyncNotifier is like Notifier, but the `build()` method is async and returns the data directly (not wrapped in AsyncValue - Riverpod does that for you):",
              "code": "import 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'dart:convert';\nimport 'package:http/http.dart' as http;\n\n// User model\nclass User {\n  final String id;\n  final String name;\n  final String email;\n\n  User({required this.id, required this.name, required this.email});\n\n  factory User.fromJson(Map<String, dynamic> json) => User(\n    id: json['id'].toString(),\n    name: json['name'],\n    email: json['email'],\n  );\n\n  User copyWith({String? name, String? email}) => User(\n    id: id,\n    name: name ?? this.name,\n    email: email ?? this.email,\n  );\n}\n\n// AsyncNotifier for complex async state management\nclass UserNotifier extends AsyncNotifier<User> {\n  @override\n  Future<User> build() async {\n    // This is called when provider is first accessed\n    // Returns the initial data (fetched from API)\n    return await _fetchUser();\n  }\n\n  // Private method to fetch user\n  Future<User> _fetchUser() async {\n    final response = await http.get(\n      Uri.parse('https://jsonplaceholder.typicode.com/users/1'),\n    );\n    \n    if (response.statusCode == 200) {\n      return User.fromJson(jsonDecode(response.body));\n    } else {\n      throw Exception('Failed to load user');\n    }\n  }\n\n  // PUBLIC METHOD: Refresh user data\n  Future<void> refresh() async {\n    // Set state to loading\n    state = const AsyncValue.loading();\n    \n    // Use AsyncValue.guard to handle errors automatically\n    state = await AsyncValue.guard(() => _fetchUser());\n  }\n\n  // PUBLIC METHOD: Update user name\n  Future<void> updateName(String newName) async {\n    // Get current user (if we have data)\n    final currentUser = state.valueOrNull;\n    if (currentUser == null) return;\n\n    // Set loading state while updating\n    state = const AsyncValue.loading();\n    \n    // Simulate API call to update\n    state = await AsyncValue.guard(() async {\n      // In real app: await api.updateUser(currentUser.id, name: newName);\n      await Future.delayed(const Duration(seconds: 1));\n      \n      // Return updated user\n      return currentUser.copyWith(name: newName);\n    });\n  }\n\n  // PUBLIC METHOD: Update user email  \n  Future<void> updateEmail(String newEmail) async {\n    final currentUser = state.valueOrNull;\n    if (currentUser == null) return;\n\n    state = const AsyncValue.loading();\n    \n    state = await AsyncValue.guard(() async {\n      await Future.delayed(const Duration(seconds: 1));\n      return currentUser.copyWith(email: newEmail);\n    });\n  }\n}\n\n// Create the provider\nfinal userNotifierProvider = AsyncNotifierProvider<UserNotifier, User>(() {\n  return UserNotifier();\n});\n\n// UNDERSTANDING AsyncValue.guard()\n//\n// AsyncValue.guard() is a helper that:\n// 1. Runs your async function\n// 2. If successful: returns AsyncValue.data(result)\n// 3. If error: returns AsyncValue.error(error, stackTrace)\n//\n// Without guard, you would write:\n//   try {\n//     final result = await someAsyncOperation();\n//     state = AsyncValue.data(result);\n//   } catch (e, stack) {\n//     state = AsyncValue.error(e, stack);\n//   }\n//\n// With guard, just:\n//   state = await AsyncValue.guard(() => someAsyncOperation());\n\n// Example usage in widget:\n// \n// ElevatedButton(\n//   onPressed: () {\n//     ref.read(userNotifierProvider.notifier).updateName('New Name');\n//   },\n//   child: Text('Update Name'),\n// )",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "AsyncValue.when() Pattern",
              "content": "The `when()` method is the primary way to handle AsyncValue. It forces you to handle all three states, making your code robust.\n\n### The when() Method\n\n```dart\nfinal asyncValue = ref.watch(someAsyncProvider);\n\nasyncValue.when(\n  loading: () => CircularProgressIndicator(),  // Required\n  error: (error, stackTrace) => Text('Error: $error'),  // Required\n  data: (value) => Text('Data: $value'),  // Required\n);\n```\n\nYou **must** provide all three callbacks. This ensures you never forget to handle loading or error states.\n\n### Alternative Methods\n\nRiverpod provides other methods for special cases:\n\n**whenOrNull()** - Returns null for unhandled cases:\n```dart\n// Only handle data, return null for loading/error\nfinal widget = asyncValue.whenOrNull(\n  data: (user) => Text(user.name),\n);\n// widget is null while loading or on error\n```\n\n**maybeWhen()** - Provide a default fallback:\n```dart\nasyncValue.maybeWhen(\n  data: (user) => UserCard(user),\n  // 'orElse' is called for loading AND error\n  orElse: () => CircularProgressIndicator(),\n);\n```\n\n### Useful Properties\n\nAsyncValue also has helpful properties:\n\n```dart\n// Check current state\nasyncValue.isLoading   // true if loading\nasyncValue.hasValue    // true if has data (even if also loading/error)\nasyncValue.hasError    // true if has error\n\n// Get value (nullable)\nasyncValue.valueOrNull  // Returns T? (null if no data)\nasyncValue.value        // Returns T (throws if no data!)\n\n// Get error (nullable)\nasyncValue.error        // Returns Object? (null if no error)\n```\n\n### Pattern: Show Previous Data While Loading\n\nA common UX pattern is to show stale data while refreshing:\n\n```dart\nWidget build(BuildContext context, WidgetRef ref) {\n  final userAsync = ref.watch(userProvider);\n  \n  return Stack(\n    children: [\n      // Show data if available (even during refresh)\n      if (userAsync.hasValue)\n        UserCard(userAsync.value!),\n      \n      // Show loading indicator on top\n      if (userAsync.isLoading)\n        const Center(child: CircularProgressIndicator()),\n      \n      // Show error message\n      if (userAsync.hasError)\n        ErrorBanner(userAsync.error.toString()),\n    ],\n  );\n}\n```"
            },
            {
              "type": "WARNING",
              "title": "Async Mistakes",
              "content": "These are the most common mistakes when working with async state in Riverpod.\n\n### Mistake 1: Not Showing Loading State\n\n**The Problem:**\n```dart\nWidget build(BuildContext context, WidgetRef ref) {\n  final userAsync = ref.watch(userProvider);\n  \n  // WRONG: Just grabbing value, ignoring loading/error\n  final user = userAsync.value;\n  return Text(user?.name ?? 'Unknown');\n}\n```\n\nUsers see nothing or stale data while loading. They do not know anything is happening.\n\n**The Fix:**\n```dart\nreturn userAsync.when(\n  loading: () => CircularProgressIndicator(),\n  error: (e, _) => Text('Error: $e'),\n  data: (user) => Text(user.name),\n);\n```\n\n### Mistake 2: Ignoring Errors\n\n**The Problem:**\n```dart\n// maybeWhen without error handling\nreturn userAsync.maybeWhen(\n  data: (user) => UserCard(user),\n  orElse: () => CircularProgressIndicator(),\n);\n// Error shows as loading forever!\n```\n\n**The Fix:**\n```dart\nreturn userAsync.when(\n  loading: () => CircularProgressIndicator(),\n  error: (e, _) => ErrorWidget(e),  // Always handle errors!\n  data: (user) => UserCard(user),\n);\n```\n\n### Mistake 3: Calling Async Methods in build() Without Guard\n\n**The Problem:**\n```dart\nclass MyNotifier extends AsyncNotifier<Data> {\n  Future<void> refresh() async {\n    state = AsyncValue.loading();\n    \n    // WRONG: No error handling!\n    final data = await fetchData();\n    state = AsyncValue.data(data);\n    // If fetchData throws, state is stuck on loading!\n  }\n}\n```\n\n**The Fix:**\n```dart\nFuture<void> refresh() async {\n  state = const AsyncValue.loading();\n  \n  // RIGHT: guard() handles errors automatically\n  state = await AsyncValue.guard(() => fetchData());\n}\n```\n\n### Mistake 4: Not Using AsyncValue.guard()\n\n**The Problem:**\n```dart\n// Manual try-catch is verbose and error-prone\ntry {\n  final result = await someAsyncOperation();\n  state = AsyncValue.data(result);\n} catch (e, stack) {\n  state = AsyncValue.error(e, stack);\n}\n```\n\n**The Fix:**\n```dart\n// guard() does the same thing in one line\nstate = await AsyncValue.guard(() => someAsyncOperation());\n```\n\n### Mistake 5: Forgetting to Set Loading State Before Async Operations\n\n**The Problem:**\n```dart\nFuture<void> updateData() async {\n  // Forgot to set loading!\n  final newData = await fetchNewData();\n  state = AsyncValue.data(newData);\n}\n// User does not know update is in progress\n```\n\n**The Fix:**\n```dart\nFuture<void> updateData() async {\n  state = const AsyncValue.loading();  // Tell users something is happening\n  state = await AsyncValue.guard(() => fetchNewData());\n}\n```"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.6-challenge-1",
              "title": "Build a User Profile Loader",
              "description": "Create a user profile screen that fetches data from an API, displays loading and error states properly, and includes a refresh button.",
              "instructions": "Build a complete user profile loader with the following requirements:\n\n1. Create a User model with: id, name, email, and phone fields\n2. Create a FutureProvider called userProvider that:\n   - Simulates an API call using Future.delayed (2 seconds delay)\n   - Returns a mock User object\n   - Has a 20% chance of throwing an error (to test error handling)\n3. Create a UserProfileScreen that:\n   - Uses ref.watch() to get the AsyncValue<User>\n   - Shows a loading spinner with 'Loading profile...' text while loading\n   - Shows an error message with a Retry button when error occurs\n   - Shows a nice user card with all user details when data is loaded\n   - Has a Refresh button in the AppBar that calls ref.invalidate()\n4. The user card should display:\n   - A CircleAvatar with the user's initials\n   - Name in large bold text\n   - Email with an email icon\n   - Phone with a phone icon\n\nBonus: Add a 'last refreshed' timestamp that updates each time data loads successfully.",
              "starterCode": "import 'dart:math';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'User Profile',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const UserProfileScreen(),\n    );\n  }\n}\n\n// TODO 1: Create User model\n// - id (String)\n// - name (String)\n// - email (String)\n// - phone (String)\nclass User {\n  // Your code here\n}\n\n// TODO 2: Create FutureProvider\n// - Simulate 2 second API delay\n// - 20% chance of throwing error\n// - Return mock User on success\n// final userProvider = FutureProvider<User>((ref) async {\n//   Your code here\n// });\n\n// TODO 3: Build UserProfileScreen\nclass UserProfileScreen extends ConsumerWidget {\n  const UserProfileScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // TODO: Watch userProvider\n    // TODO: Use .when() to handle loading, error, and data states\n    \n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('User Profile'),\n        // TODO: Add refresh button using ref.invalidate()\n      ),\n      body: const Center(\n        child: Text('Implement loading states here'),\n      ),\n    );\n  }\n}\n\n// TODO 4: Create UserCard widget to display user data nicely\n// - CircleAvatar with initials\n// - Name in large bold text\n// - Email with icon\n// - Phone with icon",
              "solution": "import 'dart:math';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'User Profile',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        useMaterial3: true,\n      ),\n      home: const UserProfileScreen(),\n    );\n  }\n}\n\n// STEP 1: User Model\nclass User {\n  final String id;\n  final String name;\n  final String email;\n  final String phone;\n  final DateTime fetchedAt;  // Bonus: track when data was fetched\n\n  const User({\n    required this.id,\n    required this.name,\n    required this.email,\n    required this.phone,\n    required this.fetchedAt,\n  });\n\n  // Get initials for avatar\n  String get initials {\n    final parts = name.split(' ');\n    if (parts.length >= 2) {\n      return '${parts[0][0]}${parts[1][0]}'.toUpperCase();\n    }\n    return name.substring(0, 2).toUpperCase();\n  }\n}\n\n// STEP 2: FutureProvider with simulated API call\nfinal userProvider = FutureProvider<User>((ref) async {\n  // Simulate network delay (2 seconds)\n  await Future.delayed(const Duration(seconds: 2));\n  \n  // 20% chance of error to test error handling\n  if (Random().nextDouble() < 0.2) {\n    throw Exception('Network error: Failed to fetch user profile. Please try again.');\n  }\n  \n  // Return mock user data\n  return User(\n    id: '12345',\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n    phone: '+1 (555) 123-4567',\n    fetchedAt: DateTime.now(),\n  );\n});\n\n// STEP 3: UserProfileScreen with proper state handling\nclass UserProfileScreen extends ConsumerWidget {\n  const UserProfileScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the provider - returns AsyncValue<User>\n    final userAsync = ref.watch(userProvider);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('User Profile'),\n        centerTitle: true,\n        actions: [\n          // Refresh button\n          IconButton(\n            icon: const Icon(Icons.refresh),\n            tooltip: 'Refresh',\n            onPressed: () {\n              // invalidate() disposes the provider and triggers a new fetch\n              ref.invalidate(userProvider);\n            },\n          ),\n        ],\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Center(\n          // Use when() to handle all three states\n          child: userAsync.when(\n            // LOADING STATE\n            loading: () => const Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                CircularProgressIndicator(),\n                SizedBox(height: 24),\n                Text(\n                  'Loading profile...',\n                  style: TextStyle(fontSize: 16, color: Colors.grey),\n                ),\n              ],\n            ),\n            \n            // ERROR STATE\n            error: (error, stackTrace) => Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                Icon(\n                  Icons.error_outline,\n                  size: 64,\n                  color: Colors.red[300],\n                ),\n                const SizedBox(height: 16),\n                Text(\n                  'Something went wrong',\n                  style: TextStyle(\n                    fontSize: 20,\n                    fontWeight: FontWeight.bold,\n                    color: Colors.red[700],\n                  ),\n                ),\n                const SizedBox(height: 8),\n                Padding(\n                  padding: const EdgeInsets.symmetric(horizontal: 32),\n                  child: Text(\n                    error.toString(),\n                    textAlign: TextAlign.center,\n                    style: TextStyle(color: Colors.grey[600]),\n                  ),\n                ),\n                const SizedBox(height: 24),\n                ElevatedButton.icon(\n                  onPressed: () => ref.invalidate(userProvider),\n                  icon: const Icon(Icons.refresh),\n                  label: const Text('Retry'),\n                  style: ElevatedButton.styleFrom(\n                    padding: const EdgeInsets.symmetric(\n                      horizontal: 32,\n                      vertical: 12,\n                    ),\n                  ),\n                ),\n              ],\n            ),\n            \n            // DATA STATE - Show user card\n            data: (user) => UserCard(user: user),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// STEP 4: UserCard widget\nclass UserCard extends StatelessWidget {\n  final User user;\n\n  const UserCard({super.key, required this.user});\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      elevation: 4,\n      shape: RoundedRectangleBorder(\n        borderRadius: BorderRadius.circular(16),\n      ),\n      child: Padding(\n        padding: const EdgeInsets.all(24),\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            // Avatar with initials\n            CircleAvatar(\n              radius: 50,\n              backgroundColor: Colors.blue,\n              child: Text(\n                user.initials,\n                style: const TextStyle(\n                  fontSize: 32,\n                  fontWeight: FontWeight.bold,\n                  color: Colors.white,\n                ),\n              ),\n            ),\n            const SizedBox(height: 20),\n            \n            // Name\n            Text(\n              user.name,\n              style: const TextStyle(\n                fontSize: 28,\n                fontWeight: FontWeight.bold,\n              ),\n            ),\n            const SizedBox(height: 8),\n            \n            // User ID badge\n            Container(\n              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),\n              decoration: BoxDecoration(\n                color: Colors.grey[200],\n                borderRadius: BorderRadius.circular(12),\n              ),\n              child: Text(\n                'ID: ${user.id}',\n                style: TextStyle(color: Colors.grey[600], fontSize: 12),\n              ),\n            ),\n            const SizedBox(height: 24),\n            \n            // Email row\n            _InfoRow(\n              icon: Icons.email_outlined,\n              label: 'Email',\n              value: user.email,\n            ),\n            const SizedBox(height: 12),\n            \n            // Phone row\n            _InfoRow(\n              icon: Icons.phone_outlined,\n              label: 'Phone',\n              value: user.phone,\n            ),\n            \n            const SizedBox(height: 24),\n            const Divider(),\n            const SizedBox(height: 12),\n            \n            // Last refreshed timestamp (Bonus)\n            Text(\n              'Last updated: ${_formatTime(user.fetchedAt)}',\n              style: TextStyle(\n                fontSize: 12,\n                color: Colors.grey[500],\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  String _formatTime(DateTime time) {\n    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}:${time.second.toString().padLeft(2, '0')}';\n  }\n}\n\n// Helper widget for info rows\nclass _InfoRow extends StatelessWidget {\n  final IconData icon;\n  final String label;\n  final String value;\n\n  const _InfoRow({\n    required this.icon,\n    required this.label,\n    required this.value,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      children: [\n        Icon(icon, color: Colors.blue, size: 24),\n        const SizedBox(width: 12),\n        Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text(\n              label,\n              style: TextStyle(\n                fontSize: 12,\n                color: Colors.grey[600],\n              ),\n            ),\n            Text(\n              value,\n              style: const TextStyle(fontSize: 16),\n            ),\n          ],\n        ),\n      ],\n    );\n  }\n}\n\n// KEY CONCEPTS DEMONSTRATED:\n//\n// 1. FutureProvider: Automatically wraps async data in AsyncValue\n//\n// 2. AsyncValue.when(): Handle all three states (loading, error, data)\n//    - loading: Show spinner and message\n//    - error: Show error with retry button\n//    - data: Show the actual content\n//\n// 3. ref.invalidate(): Dispose and refetch the provider\n//    - Used for refresh/retry functionality\n//\n// 4. Simulated errors: 20% chance to test error UI\n//\n// 5. Clean separation: UserCard widget only knows about User data,\n//    not about loading states",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-loading",
                  "description": "Shows loading spinner while fetching",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-error",
                  "description": "Shows error message with retry button on failure",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-data",
                  "description": "Shows user card with all details on success",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-refresh",
                  "description": "Refresh button triggers new fetch",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use Random().nextDouble() < 0.2 to create a 20% chance of error. If true, throw an Exception."
                },
                {
                  "level": 2,
                  "text": "The when() method takes three required callbacks: loading: () => Widget, error: (error, stack) => Widget, data: (value) => Widget"
                },
                {
                  "level": 3,
                  "text": "To refresh data, use ref.invalidate(userProvider) in the button's onPressed. This disposes the current state and triggers a new fetch."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using maybeWhen without handling error state",
                  "consequence": "Errors show as loading forever, users cannot retry",
                  "correction": "Use when() which requires all three state handlers, or explicitly handle error in maybeWhen"
                },
                {
                  "mistake": "Accessing .value directly without checking state",
                  "consequence": "Throws exception if data is not loaded yet",
                  "correction": "Use when() or check .hasValue before accessing .value, or use .valueOrNull for nullable access"
                },
                {
                  "mistake": "Forgetting to add retry button on error state",
                  "consequence": "Users are stuck on error with no way to retry",
                  "correction": "Add a button that calls ref.invalidate(userProvider) to retry the fetch"
                },
                {
                  "mistake": "Not showing any loading indicator",
                  "consequence": "Users do not know data is being fetched",
                  "correction": "Always provide a loading callback in when() that shows a CircularProgressIndicator or similar"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.7",
          "title": "Riverpod Generator",
          "moduleId": "module-05",
          "order": 7,
          "estimatedMinutes": 50,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Code Generation?",
              "content": "As you have been building providers manually, you may have noticed a pattern. Every time you create a Notifier, you write similar boilerplate code:\n\n1. Create the Notifier class with proper type parameters\n2. Implement the build() method\n3. Create a separate provider declaration with matching types\n4. Ensure the provider factory returns your Notifier instance\n\nThis repetitive process has several problems:\n\n**Problem 1: Boilerplate is tedious**\nEvery Notifier requires the same structural code. For a large app with dozens of providers, this adds up to hundreds of lines of repetitive code that you must write, maintain, and debug.\n\n**Problem 2: Type parameter errors**\nThe NotifierProvider requires you to specify both the Notifier type AND the state type. Getting these wrong causes confusing errors:\n\n```dart\n// Easy to make mistakes like this:\nfinal counterProvider = NotifierProvider<CounterNotifier, String>(() {  // Wrong! Should be int\n  return CounterNotifier();\n});\n```\n\n**Problem 3: Inconsistency**\nWithout a standard pattern, different developers write providers differently. Some use different naming conventions, some forget parts of the boilerplate.\n\n**The Solution: Code Generation**\n\nRiverpod offers a code generation package called **riverpod_generator** that writes all this boilerplate for you. You write a simple annotated class, run a command, and the generator creates perfectly typed providers automatically.\n\nCode generation is a common pattern in Dart. You may have used it with json_serializable for JSON parsing or freezed for immutable classes. Riverpod's generator follows the same approach: you write the essential code, and the generator fills in the rest.",
              "code": "// THE BOILERPLATE PROBLEM\n// Look at all this code for a simple counter:\n\n// Step 1: Create the Notifier class\nclass CounterNotifier extends Notifier<int> {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n  void decrement() => state--;\n}\n\n// Step 2: Create the provider with matching types\nfinal counterNotifierProvider = NotifierProvider<CounterNotifier, int>(() {\n  return CounterNotifier();\n});\n\n// For EVERY Notifier, you repeat this pattern.\n// With 20 features, that's 20 provider declarations with type parameters.\n// Miss one type? Runtime error.\n// Typo in the provider name? Hard to find bug.",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Code Generation",
              "content": "Setting up Riverpod code generation requires adding a few packages and configuring your project correctly. Here is the complete setup process.\n\n### Step 1: Add Dependencies\n\nYou need four packages:\n- **flutter_riverpod**: The core Riverpod package you already have\n- **riverpod_annotation**: Provides the @riverpod annotation\n- **riverpod_generator**: The code generator (dev dependency)\n- **build_runner**: Dart's code generation runner (dev dependency)\n\n### Step 2: Update pubspec.yaml\n\nAdd these to your pubspec.yaml file. Note that riverpod_generator and build_runner go under dev_dependencies because they are only used during development, not at runtime:\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_riverpod: ^2.6.0\n  riverpod_annotation: ^2.6.0\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  riverpod_generator: ^2.6.0\n  build_runner: ^2.4.0\n```\n\n### Step 3: Run the Generator\n\nAfter adding dependencies, run `flutter pub get` to install them. Then you have two options to run the generator:\n\n**Option A: One-time generation**\n```bash\ndart run build_runner build\n```\nThis runs once and generates all files. Use this for CI/CD or when you are done coding.\n\n**Option B: Watch mode (recommended for development)**\n```bash\ndart run build_runner watch\n```\nThis watches your files and regenerates automatically whenever you save changes. Keep this running in a terminal while you code.\n\n### Step 4: Clean Build (if needed)\n\nIf you get errors or stale generated files, clean and rebuild:\n```bash\ndart run build_runner clean\ndart run build_runner build --delete-conflicting-outputs\n```\n\nThe `--delete-conflicting-outputs` flag removes old generated files that might conflict with new ones."
            },
            {
              "type": "EXAMPLE",
              "title": "Before and After Code Generation",
              "content": "Let us compare the same counter implementation written manually versus using the Riverpod generator. This comparison shows exactly how much boilerplate the generator eliminates.\n\n### The Manual Way (What You Have Been Doing)\n\nWith manual providers, you write the Notifier class AND the provider declaration separately. You must ensure the type parameters match exactly.\n\n### The Generated Way\n\nWith the generator, you write only the Notifier class with a special annotation. The generator creates the provider automatically.\n\nNotice several key differences:\n\n1. **Import changes**: You import riverpod_annotation instead of flutter_riverpod in the Notifier file\n\n2. **Part directive**: You add `part 'filename.g.dart';` to include the generated code\n\n3. **Class naming**: Your class extends `_$ClassName` (underscore prefix, dollar sign, your class name). This is a generated base class.\n\n4. **No provider declaration**: You do NOT write the provider. The generator creates `counterProvider` automatically based on your class name.\n\n5. **Naming convention**: The generator converts your class name to camelCase for the provider name:\n   - `Counter` class -> `counterProvider`\n   - `UserProfile` class -> `userProfileProvider`\n   - `ShoppingCart` class -> `shoppingCartProvider`",
              "code": "// =====================================================\n// BEFORE: MANUAL PROVIDER DECLARATION\n// =====================================================\n\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Step 1: Write the Notifier\nclass CounterNotifier extends Notifier<int> {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n  void decrement() => state--;\n  void reset() => state = 0;\n}\n\n// Step 2: Manually create the provider (easy to make mistakes here!)\nfinal counterNotifierProvider = NotifierProvider<CounterNotifier, int>(() {\n  return CounterNotifier();\n});\n\n// =====================================================\n// AFTER: WITH RIVERPOD GENERATOR\n// =====================================================\n\n// File: lib/providers/counter.dart\n\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'counter.g.dart';  // This line includes the generated file!\n\n@riverpod  // This annotation tells the generator to create a provider\nclass Counter extends _$Counter {  // Extend the generated base class\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n  void decrement() => state--;\n  void reset() => state = 0;\n}\n\n// That's it! No manual provider declaration needed!\n// The generator creates 'counterProvider' automatically.\n\n// =====================================================\n// WHAT THE GENERATOR CREATES (counter.g.dart)\n// =====================================================\n\n// You never edit this file - it's auto-generated!\n// part of 'counter.dart';\n//\n// final counterProvider = NotifierProvider<Counter, int>.internal(\n//   Counter.new,\n//   name: 'counterProvider',\n//   debugGetCreateSourceHash: ...,\n//   dependencies: null,\n//   allTransitiveDependencies: null,\n// );\n//\n// abstract class _$Counter extends Notifier<int> { }\n\n// =====================================================\n// USAGE IS IDENTICAL\n// =====================================================\n\n// In your widget (same whether manual or generated):\nclass CounterScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n\n    return Column(\n      children: [\n        Text('Count: $count'),\n        ElevatedButton(\n          onPressed: () => ref.read(counterProvider.notifier).increment(),\n          child: Text('Increment'),\n        ),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Generated Provider Types",
              "content": "The Riverpod generator is smart about what type of provider to create based on how you write your code. Here are the different patterns:\n\n### Pattern 1: Function with @riverpod -> Provider\n\nAnnotating a simple function creates a basic Provider (read-only, computed value):\n\n```dart\n@riverpod\nString greeting(Ref ref) {\n  return 'Hello, World!';\n}\n// Generates: greetingProvider (Provider<String>)\n```\n\n### Pattern 2: Class with @riverpod -> NotifierProvider\n\nAnnotating a class creates a NotifierProvider (read-write state with methods):\n\n```dart\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n// Generates: counterProvider (NotifierProvider<Counter, int>)\n```\n\n### Pattern 3: Async Function -> FutureProvider\n\nAnnotating an async function creates a FutureProvider:\n\n```dart\n@riverpod\nFuture<User> currentUser(Ref ref) async {\n  final response = await http.get(Uri.parse('api/user'));\n  return User.fromJson(jsonDecode(response.body));\n}\n// Generates: currentUserProvider (FutureProvider<User>)\n```\n\n### Pattern 4: Async Class -> AsyncNotifierProvider\n\nAnnotating a class with an async build method creates AsyncNotifierProvider:\n\n```dart\n@riverpod\nclass UserProfile extends _$UserProfile {\n  @override\n  Future<User> build() async {\n    return await fetchUser();\n  }\n\n  Future<void> updateName(String name) async {\n    state = const AsyncLoading();\n    state = await AsyncValue.guard(() => api.updateUser(name));\n  }\n}\n// Generates: userProfileProvider (AsyncNotifierProvider<UserProfile, User>)\n```\n\n### Pattern 5: keepAlive for Persistent State\n\nBy default, generated providers are auto-disposed when no longer used. Use `@Riverpod(keepAlive: true)` to keep state alive:\n\n```dart\n@Riverpod(keepAlive: true)  // Note: Capital R, parentheses\nclass AuthState extends _$AuthState {\n  @override\n  User? build() => null;\n\n  void login(User user) => state = user;\n  void logout() => state = null;\n}\n// Generates: authStateProvider that NEVER disposes\n// Perfect for auth state that should persist for app lifetime\n```\n\n### Pattern 6: Family Providers (Parameters)\n\nAdd parameters to your function or build method to create family providers:\n\n```dart\n@riverpod\nFuture<Product> product(Ref ref, String productId) async {\n  return await api.getProduct(productId);\n}\n// Generates: productProvider (can call productProvider('123'))\n\n// Usage:\nfinal product = ref.watch(productProvider('123'));\n```",
              "code": "// COMPLETE EXAMPLE: All generated provider types in one file\n\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'providers.g.dart';\n\n// =====================================================\n// 1. SIMPLE PROVIDER (read-only value)\n// =====================================================\n@riverpod\nString appName(Ref ref) {\n  return 'My Awesome App';\n}\n// -> appNameProvider (Provider<String>)\n\n// =====================================================\n// 2. COMPUTED PROVIDER (depends on other providers)\n// =====================================================\n@riverpod\nString welcomeMessage(Ref ref) {\n  final name = ref.watch(appNameProvider);\n  return 'Welcome to $name!';\n}\n// -> welcomeMessageProvider (Provider<String>)\n\n// =====================================================\n// 3. NOTIFIER (stateful with methods)\n// =====================================================\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n  void decrement() => state--;\n}\n// -> counterProvider (NotifierProvider<Counter, int>)\n\n// =====================================================\n// 4. FUTURE PROVIDER (async data fetch)\n// =====================================================\n@riverpod\nFuture<List<String>> fetchTodos(Ref ref) async {\n  await Future.delayed(Duration(seconds: 1));\n  return ['Learn Riverpod', 'Build an app', 'Deploy to store'];\n}\n// -> fetchTodosProvider (FutureProvider<List<String>>)\n\n// =====================================================\n// 5. ASYNC NOTIFIER (async + methods)\n// =====================================================\n@riverpod\nclass TodoList extends _$TodoList {\n  @override\n  Future<List<String>> build() async {\n    return await _fetchTodos();\n  }\n\n  Future<List<String>> _fetchTodos() async {\n    await Future.delayed(Duration(seconds: 1));\n    return ['Task 1', 'Task 2', 'Task 3'];\n  }\n\n  Future<void> addTodo(String todo) async {\n    state = const AsyncLoading();\n    final currentTodos = await future;  // Get current data\n    state = AsyncData([...currentTodos, todo]);\n  }\n\n  Future<void> refresh() async {\n    state = const AsyncLoading();\n    state = await AsyncValue.guard(_fetchTodos);\n  }\n}\n// -> todoListProvider (AsyncNotifierProvider<TodoList, List<String>>)\n\n// =====================================================\n// 6. KEEP ALIVE (never disposed)\n// =====================================================\n@Riverpod(keepAlive: true)\nclass AppSettings extends _$AppSettings {\n  @override\n  Map<String, dynamic> build() => {'theme': 'light', 'language': 'en'};\n\n  void updateTheme(String theme) {\n    state = {...state, 'theme': theme};\n  }\n}\n// -> appSettingsProvider (NotifierProvider that persists)\n\n// =====================================================\n// 7. FAMILY PROVIDER (with parameters)\n// =====================================================\n@riverpod\nFuture<String> userById(Ref ref, int userId) async {\n  await Future.delayed(Duration(milliseconds: 500));\n  return 'User #$userId';\n}\n// -> userByIdProvider (call with userByIdProvider(123))\n\n// =====================================================\n// 8. FAMILY NOTIFIER (class with parameters)\n// =====================================================\n@riverpod\nclass ProductDetail extends _$ProductDetail {\n  @override\n  Future<Map<String, dynamic>> build(String productId) async {\n    // productId is available as a parameter!\n    return await fetchProduct(productId);\n  }\n\n  Future<Map<String, dynamic>> fetchProduct(String id) async {\n    await Future.delayed(Duration(seconds: 1));\n    return {'id': id, 'name': 'Product $id', 'price': 29.99};\n  }\n\n  Future<void> refresh() async {\n    // Access the productId passed to build\n    state = await AsyncValue.guard(() => fetchProduct(arg));\n  }\n}\n// -> productDetailProvider('ABC123') to get product ABC123",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Generator Benefits",
              "content": "Using the Riverpod generator provides significant advantages over manual provider creation:\n\n### Benefit 1: Drastically Less Boilerplate\n\nCompare the code you write:\n- **Manual**: 15-20 lines per provider (class + provider declaration)\n- **Generated**: 5-10 lines per provider (just the class)\n\nFor an app with 30 providers, that is potentially 300+ lines of boilerplate eliminated.\n\n### Benefit 2: Type Safety at Compile Time\n\nWith manual providers, type mismatches cause runtime errors. With generated providers, the generator ensures all types match correctly. If there is a problem, you get a build error immediately, not a crash when users run your app.\n\n### Benefit 3: Consistent Naming Convention\n\nThe generator enforces a standard naming pattern:\n- Class `Counter` always becomes `counterProvider`\n- Class `UserProfile` always becomes `userProfileProvider`\n\nNo more wondering if someone named it `counterProvider`, `counterNotifier`, or `myCounter`. The pattern is automatic and predictable.\n\n### Benefit 4: Part Files Keep Code Organized\n\nGenerated code goes into `.g.dart` files (like `counter.g.dart`). This keeps your source files clean. You write the logic; the generator writes the wiring.\n\n### Benefit 5: IDE Support and Autocomplete\n\nBecause providers are generated from classes you define, your IDE understands the structure. You get:\n- Autocomplete for provider names\n- Go-to-definition jumps to your source code\n- Refactoring tools work correctly\n\n### Benefit 6: Future-Proof\n\nWhen Riverpod updates its internal APIs, you just update the generator package and regenerate. Your code stays the same; only the generated code changes.\n\n### When to Use the Generator\n\n**Use the generator when:**\n- Building a medium to large app (10+ providers)\n- Working on a team (consistency matters)\n- You want compile-time type checking\n- You prefer writing less boilerplate\n\n**Consider manual providers when:**\n- Building a tiny prototype (3-4 providers)\n- Learning Riverpod fundamentals\n- You need very custom provider behavior"
            },
            {
              "type": "WARNING",
              "title": "Generator Gotchas",
              "content": "While the Riverpod generator is powerful, there are several common issues developers encounter. Understanding these will save you debugging time.\n\n### Gotcha 1: Must Run build_runner\n\nAfter writing `@riverpod` annotations, you MUST run the generator:\n```bash\ndart run build_runner watch  # Recommended during development\n```\n\nIf you see errors like \"Undefined name 'counterProvider'\" or \"Class _$Counter not found\", the generator has not run yet.\n\n### Gotcha 2: Part Directive is Required\n\nEvery file with `@riverpod` annotations needs the part directive:\n```dart\npart 'your_file.g.dart';  // MUST match your file name!\n```\n\nIf your file is `counter_provider.dart`, the part must be `part 'counter_provider.g.dart';`\n\n### Gotcha 3: Class Naming Convention\n\nYour class MUST extend the generated base class:\n```dart\n// CORRECT:\nclass Counter extends _$Counter { ... }\n\n// WRONG - will not compile:\nclass CounterNotifier extends Notifier<int> { ... }\n```\n\nThe base class is always `_$YourClassName` (underscore, dollar sign, your exact class name).\n\n### Gotcha 4: Provider Naming is Automatic\n\nYou do NOT name the provider. It is derived from the class name:\n- `Counter` -> `counterProvider`\n- `UserList` -> `userListProvider`\n- `HTTPClient` -> `hTTPClientProvider` (careful with acronyms!)\n\nIf you want a specific provider name, name your class accordingly.\n\n### Gotcha 5: Never Edit .g.dart Files\n\nThe `.g.dart` files are completely regenerated every time you run build_runner. Any manual changes will be lost. If you need to customize behavior, do it in your source file.\n\n### Gotcha 6: Build Errors Can Be Cryptic\n\nIf the generator fails, error messages may be confusing. Common fixes:\n```bash\n# Clean and rebuild\ndart run build_runner clean\ndart run build_runner build --delete-conflicting-outputs\n\n# Check for syntax errors in your Dart files first!\nflutter analyze\n```\n\n### Gotcha 7: Hot Reload Limitations\n\nChanges to `@riverpod` classes may not hot reload properly. You might need to:\n- Stop the generator, restart it\n- Perform a hot restart instead of hot reload\n- In rare cases, stop and restart the entire app\n\n### Gotcha 8: Ref Parameter Changed in Riverpod 2.6+\n\nIn older tutorials, you might see `SomeProviderRef ref`. The modern syntax is just `Ref ref`:\n```dart\n// Modern (2.6+):\n@riverpod\nString greeting(Ref ref) => 'Hello!';\n\n// Old style (pre-2.6) - still works but deprecated:\n@riverpod\nString greeting(GreetingRef ref) => 'Hello!';\n```",
              "code": "// COMMON MISTAKES AND FIXES\n\n// =====================================================\n// MISTAKE 1: Missing part directive\n// =====================================================\n\n// WRONG:\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\n@riverpod\nclass Counter extends _$Counter {  // ERROR: _$Counter not found!\n  @override\n  int build() => 0;\n}\n\n// CORRECT:\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'counter.g.dart';  // Add this line!\n\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n}\n\n// =====================================================\n// MISTAKE 2: Wrong base class\n// =====================================================\n\n// WRONG:\n@riverpod\nclass Counter extends Notifier<int> {  // Should extend _$Counter!\n  @override\n  int build() => 0;\n}\n\n// CORRECT:\n@riverpod\nclass Counter extends _$Counter {  // Always _$YourClassName\n  @override\n  int build() => 0;\n}\n\n// =====================================================\n// MISTAKE 3: Trying to name the provider\n// =====================================================\n\n// WRONG - this syntax does not exist:\n@riverpod(name: 'myCounterProvider')  // Not a valid option!\nclass Counter extends _$Counter { }\n\n// CORRECT - provider name comes from class name:\n@riverpod\nclass MyCounter extends _$MyCounter {  // Becomes myCounterProvider\n  @override\n  int build() => 0;\n}\n\n// =====================================================\n// MISTAKE 4: Editing the .g.dart file\n// =====================================================\n\n// counter.g.dart - NEVER EDIT THIS FILE!\n// Any changes will be lost on next build_runner run.\n\n// If you need custom behavior, modify counter.dart instead.\n\n// =====================================================\n// MISTAKE 5: Forgetting to run build_runner\n// =====================================================\n\n// After writing @riverpod annotations, always run:\n// dart run build_runner build\n// \n// Or better, keep this running during development:\n// dart run build_runner watch\n\n// =====================================================\n// MISTAKE 6: Part directive filename mismatch\n// =====================================================\n\n// If your file is: lib/providers/user_provider.dart\n// WRONG:\npart 'user.g.dart';  // Filename mismatch!\n\n// CORRECT:\npart 'user_provider.g.dart';  // Matches your file name"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.7-challenge-1",
              "title": "Convert Manual Notifier to Generated Provider",
              "description": "Take an existing manually-written TodoNotifier and convert it to use the @riverpod annotation and code generation pattern.",
              "instructions": "You have a working TodoNotifier that was written manually with a separate provider declaration. Your task is to convert it to use Riverpod's code generation:\n\n1. Add the correct import for riverpod_annotation\n2. Add the part directive for the generated file\n3. Add the @riverpod annotation to the class\n4. Change the class to extend the generated base class (_$TodoList)\n5. Remove the manual provider declaration (the generator will create it)\n6. Keep all the existing functionality (addTodo, removeTodo, toggleTodo, clearCompleted)\n\nThe converted code should work exactly the same way when used in widgets. The only difference is that the provider is now generated automatically.\n\nRemember:\n- The generated provider name will be todoListProvider (from class name TodoList)\n- The part file should be named 'todo_list.g.dart' to match the source file 'todo_list.dart'\n- Run `dart run build_runner build` to generate the code (simulated in this environment)",
              "starterCode": "// File: lib/providers/todo_list.dart\n// STARTER: Manual Notifier - Convert this to use code generation!\n\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Todo Model\nclass Todo {\n  final String id;\n  final String title;\n  final bool isCompleted;\n\n  Todo({\n    required this.id,\n    required this.title,\n    this.isCompleted = false,\n  });\n\n  Todo copyWith({String? title, bool? isCompleted}) {\n    return Todo(\n      id: id,\n      title: title ?? this.title,\n      isCompleted: isCompleted ?? this.isCompleted,\n    );\n  }\n}\n\n// MANUAL NOTIFIER - Convert this to use @riverpod!\nclass TodoNotifier extends Notifier<List<Todo>> {\n  @override\n  List<Todo> build() {\n    // Start with some sample todos\n    return [\n      Todo(id: '1', title: 'Learn Riverpod basics'),\n      Todo(id: '2', title: 'Understand code generation'),\n      Todo(id: '3', title: 'Build an awesome app'),\n    ];\n  }\n\n  void addTodo(String title) {\n    final newTodo = Todo(\n      id: DateTime.now().millisecondsSinceEpoch.toString(),\n      title: title,\n    );\n    state = [...state, newTodo];\n  }\n\n  void removeTodo(String id) {\n    state = state.where((todo) => todo.id != id).toList();\n  }\n\n  void toggleTodo(String id) {\n    state = state.map((todo) {\n      if (todo.id == id) {\n        return todo.copyWith(isCompleted: !todo.isCompleted);\n      }\n      return todo;\n    }).toList();\n  }\n\n  void clearCompleted() {\n    state = state.where((todo) => !todo.isCompleted).toList();\n  }\n}\n\n// MANUAL PROVIDER DECLARATION - This should be removed!\n// The generator will create this automatically.\nfinal todoNotifierProvider = NotifierProvider<TodoNotifier, List<Todo>>(() {\n  return TodoNotifier();\n});\n\n// TODO: Convert the above to use code generation:\n// 1. Change import to riverpod_annotation\n// 2. Add: part 'todo_list.g.dart';\n// 3. Add @riverpod annotation to the class\n// 4. Extend _$TodoList instead of Notifier<List<Todo>>\n// 5. Delete the manual provider declaration\n// 6. The generated provider will be named: todoListProvider",
              "solution": "// File: lib/providers/todo_list.dart\n// SOLUTION: Converted to use Riverpod code generation\n\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'todo_list.g.dart';  // Include the generated file\n\n// Todo Model (unchanged)\nclass Todo {\n  final String id;\n  final String title;\n  final bool isCompleted;\n\n  Todo({\n    required this.id,\n    required this.title,\n    this.isCompleted = false,\n  });\n\n  Todo copyWith({String? title, bool? isCompleted}) {\n    return Todo(\n      id: id,\n      title: title ?? this.title,\n      isCompleted: isCompleted ?? this.isCompleted,\n    );\n  }\n}\n\n// CONVERTED: Now uses @riverpod annotation!\n@riverpod\nclass TodoList extends _$TodoList {  // Extends generated base class\n  @override\n  List<Todo> build() {\n    // Start with some sample todos\n    return [\n      Todo(id: '1', title: 'Learn Riverpod basics'),\n      Todo(id: '2', title: 'Understand code generation'),\n      Todo(id: '3', title: 'Build an awesome app'),\n    ];\n  }\n\n  void addTodo(String title) {\n    final newTodo = Todo(\n      id: DateTime.now().millisecondsSinceEpoch.toString(),\n      title: title,\n    );\n    state = [...state, newTodo];\n  }\n\n  void removeTodo(String id) {\n    state = state.where((todo) => todo.id != id).toList();\n  }\n\n  void toggleTodo(String id) {\n    state = state.map((todo) {\n      if (todo.id == id) {\n        return todo.copyWith(isCompleted: !todo.isCompleted);\n      }\n      return todo;\n    }).toList();\n  }\n\n  void clearCompleted() {\n    state = state.where((todo) => !todo.isCompleted).toList();\n  }\n}\n\n// NO MANUAL PROVIDER DECLARATION NEEDED!\n// The generator creates: todoListProvider\n// Type: NotifierProvider<TodoList, List<Todo>>\n\n// =====================================================\n// WHAT THE GENERATOR CREATES (todo_list.g.dart)\n// =====================================================\n// This file is auto-generated. Do not edit.\n//\n// part of 'todo_list.dart';\n//\n// final todoListProvider =\n//     NotifierProvider<TodoList, List<Todo>>.internal(\n//   TodoList.new,\n//   name: 'todoListProvider',\n//   debugGetCreateSourceHash: ...,\n//   dependencies: null,\n//   allTransitiveDependencies: null,\n// );\n//\n// abstract class _$TodoList extends Notifier<List<Todo>> { }\n\n// =====================================================\n// USAGE IN WIDGETS (identical to manual version!)\n// =====================================================\n/*\nclass TodoScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the provider (note: it's now todoListProvider, not todoNotifierProvider)\n    final todos = ref.watch(todoListProvider);\n\n    return ListView.builder(\n      itemCount: todos.length,\n      itemBuilder: (context, index) {\n        final todo = todos[index];\n        return ListTile(\n          title: Text(\n            todo.title,\n            style: TextStyle(\n              decoration: todo.isCompleted\n                  ? TextDecoration.lineThrough\n                  : null,\n            ),\n          ),\n          leading: Checkbox(\n            value: todo.isCompleted,\n            onChanged: (_) {\n              ref.read(todoListProvider.notifier).toggleTodo(todo.id);\n            },\n          ),\n          trailing: IconButton(\n            icon: Icon(Icons.delete),\n            onPressed: () {\n              ref.read(todoListProvider.notifier).removeTodo(todo.id);\n            },\n          ),\n        );\n      },\n    );\n  }\n}\n*/\n\n// KEY CHANGES SUMMARY:\n// 1. Import: flutter_riverpod -> riverpod_annotation\n// 2. Added: part 'todo_list.g.dart';\n// 3. Added: @riverpod annotation\n// 4. Changed: extends Notifier<List<Todo>> -> extends _$TodoList\n// 5. Renamed class: TodoNotifier -> TodoList (cleaner name for generated provider)\n// 6. Removed: Manual provider declaration\n// 7. Provider name changed: todoNotifierProvider -> todoListProvider",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-import",
                  "description": "Uses riverpod_annotation import instead of flutter_riverpod",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-part",
                  "description": "Includes part directive for generated file",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-annotation",
                  "description": "Class has @riverpod annotation",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-extends",
                  "description": "Class extends generated base class (_$TodoList)",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-no-manual-provider",
                  "description": "Manual provider declaration is removed",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start by changing the import from 'package:flutter_riverpod/flutter_riverpod.dart' to 'package:riverpod_annotation/riverpod_annotation.dart'"
                },
                {
                  "level": 2,
                  "text": "The part directive must match your file name. If the file is 'todo_list.dart', use: part 'todo_list.g.dart';"
                },
                {
                  "level": 3,
                  "text": "Change 'class TodoNotifier extends Notifier<List<Todo>>' to '@riverpod class TodoList extends _$TodoList'. The generator creates the base class for you."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Keeping the manual provider declaration",
                  "consequence": "You will have two providers (one manual, one generated) causing confusion",
                  "correction": "Delete the final todoNotifierProvider = NotifierProvider<...>(...) declaration entirely"
                },
                {
                  "mistake": "Forgetting the part directive",
                  "consequence": "Build error: class _$TodoList is not defined",
                  "correction": "Add part 'todo_list.g.dart'; after your imports"
                },
                {
                  "mistake": "Using the wrong base class name",
                  "consequence": "Build error because the base class name must match your class name",
                  "correction": "If your class is TodoList, extend _$TodoList. If your class is MyTodos, extend _$MyTodos"
                },
                {
                  "mistake": "Forgetting to run build_runner",
                  "consequence": "The .g.dart file is not created, so the base class does not exist",
                  "correction": "Run: dart run build_runner build (or watch for continuous generation)"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.8",
          "title": "Dependency Injection with Riverpod",
          "moduleId": "module-05",
          "order": 8,
          "estimatedMinutes": 55,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What is Dependency Injection?",
              "content": "Dependency Injection (DI) is a fundamental software design pattern that makes your code more flexible, testable, and maintainable. Let us understand what it means and why it matters.\n\n### The Problem: Hard-Coded Dependencies\n\nImagine you are building a UserViewModel that needs to fetch user data from an API. A naive approach creates the dependency directly inside the class:\n\n```dart\nclass UserViewModel {\n  // BAD: Creating dependency inside the class\n  final UserRepository _repo = UserRepository();\n\n  Future<User> getUser(String id) {\n    return _repo.fetchUser(id);\n  }\n}\n```\n\nThis seems simple, but it has serious problems:\n\n**Problem 1: Cannot Test in Isolation**\nWhen you test UserViewModel, you MUST use the real UserRepository. If that repository makes HTTP calls, your unit tests now require a running server. Tests become slow, flaky, and dependent on network connectivity.\n\n**Problem 2: Cannot Swap Implementations**\nWhat if you need different repositories for different environments?\n- Development: Use a fake repository with mock data\n- Staging: Use a repository pointing to staging servers\n- Production: Use the real production repository\n\nWith hard-coded dependencies, you cannot swap these without modifying the ViewModel code.\n\n**Problem 3: Hidden Dependencies**\nLooking at `new UserViewModel()`, you cannot tell what it depends on. The dependencies are hidden inside. This makes debugging and understanding code flow difficult.\n\n### The Solution: Dependency Injection\n\n**Dependency Injection means passing dependencies from the outside rather than creating them inside.**\n\n```dart\nclass UserViewModel {\n  // GOOD: Dependency is injected (passed in)\n  final UserRepository _repo;\n\n  UserViewModel(this._repo);  // Repository comes from outside\n\n  Future<User> getUser(String id) {\n    return _repo.fetchUser(id);\n  }\n}\n```\n\nNow you can:\n- Pass a real repository in production\n- Pass a mock repository in tests\n- Pass different repositories for different environments\n\nThe ViewModel does not know or care which repository it gets. It just uses whatever is provided.",
              "code": "// =====================================================\n// BAD: Hard-coded dependency (NOT Dependency Injection)\n// =====================================================\n\nclass UserRepository {\n  Future<User> fetchUser(String id) async {\n    // Makes real HTTP call\n    final response = await http.get(Uri.parse('https://api.example.com/users/$id'));\n    return User.fromJson(jsonDecode(response.body));\n  }\n}\n\nclass UserViewModel {\n  // Creating the dependency directly - BAD!\n  final UserRepository _repo = UserRepository();\n\n  Future<User> loadUser(String id) async {\n    return await _repo.fetchUser(id);\n  }\n}\n\n// TESTING IS IMPOSSIBLE:\nvoid testUserViewModel() {\n  final vm = UserViewModel();\n  // This will make a REAL HTTP call!\n  // Test requires network, running server, etc.\n  final user = await vm.loadUser('123');\n}\n\n// =====================================================\n// GOOD: Dependency Injection\n// =====================================================\n\nabstract class UserRepository {\n  Future<User> fetchUser(String id);\n}\n\nclass ApiUserRepository implements UserRepository {\n  @override\n  Future<User> fetchUser(String id) async {\n    final response = await http.get(Uri.parse('https://api.example.com/users/$id'));\n    return User.fromJson(jsonDecode(response.body));\n  }\n}\n\nclass MockUserRepository implements UserRepository {\n  @override\n  Future<User> fetchUser(String id) async {\n    // Returns fake data instantly - no network needed!\n    return User(id: id, name: 'Test User', email: 'test@example.com');\n  }\n}\n\nclass UserViewModel {\n  // Dependency is INJECTED from outside\n  final UserRepository _repo;\n\n  UserViewModel(this._repo);  // Receives repository as parameter\n\n  Future<User> loadUser(String id) async {\n    return await _repo.fetchUser(id);\n  }\n}\n\n// PRODUCTION:\nfinal vm = UserViewModel(ApiUserRepository());\n\n// TESTING:\nvoid testUserViewModel() {\n  final vm = UserViewModel(MockUserRepository());  // Use mock!\n  final user = await vm.loadUser('123');\n  // No HTTP call! Fast, reliable test.\n  expect(user.name, equals('Test User'));\n}"
            },
            {
              "type": "THEORY",
              "title": "Riverpod IS Dependency Injection",
              "content": "Here is the great news: **if you are using Riverpod, you are already doing dependency injection!** You do not need a separate DI framework like GetIt, Injectable, or Dagger.\n\nRiverpod's provider system IS a dependency injection container. Let us see how.\n\n### Providers as a DI Container\n\nIn traditional DI frameworks, you register dependencies in a container:\n```dart\n// Other frameworks\ncontainer.register<UserRepository>(() => ApiUserRepository());\ncontainer.register<UserViewModel>(() => UserViewModel(container.get<UserRepository>()));\n```\n\nWith Riverpod, providers ARE the container:\n```dart\n// Riverpod\nfinal userRepositoryProvider = Provider((ref) => ApiUserRepository());\n\n@riverpod\nclass UserViewModel extends _$UserViewModel {\n  @override\n  User build() {\n    final repo = ref.watch(userRepositoryProvider);  // DI!\n    return repo.fetchUser();\n  }\n}\n```\n\n### ref.watch and ref.read ARE Dependency Injection\n\nWhen you call `ref.watch(someProvider)` or `ref.read(someProvider)`, you are:\n1. Asking Riverpod's container for a dependency\n2. Getting the instance Riverpod manages\n3. Establishing a dependency relationship\n\nThis is exactly what DI frameworks do, but with a more elegant, declarative API.\n\n### Benefits of Riverpod as DI\n\n1. **No setup required**: No need to configure a separate container\n2. **Type-safe**: Providers are strongly typed\n3. **Lazy initialization**: Dependencies created only when needed\n4. **Automatic disposal**: Dependencies cleaned up when no longer used\n5. **Override for testing**: Built-in support for swapping implementations\n6. **Reactive**: Dependencies can rebuild when their dependencies change",
              "code": "// =====================================================\n// RIVERPOD AS DEPENDENCY INJECTION\n// =====================================================\n\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'providers.g.dart';\n\n// =====================================================\n// STEP 1: Define your dependencies as providers\n// =====================================================\n\n// Low-level dependency: API client\n@riverpod\nApiClient apiClient(Ref ref) {\n  return ApiClient(baseUrl: 'https://api.example.com');\n}\n\n// Mid-level dependency: Repository (depends on ApiClient)\n@riverpod\nUserRepository userRepository(Ref ref) {\n  // DEPENDENCY INJECTION: Get ApiClient from Riverpod\n  final client = ref.watch(apiClientProvider);\n  return UserRepository(client);\n}\n\n// High-level: ViewModel (depends on Repository)\n@riverpod\nclass UserViewModel extends _$UserViewModel {\n  @override\n  Future<User> build() async {\n    // DEPENDENCY INJECTION: Get Repository from Riverpod\n    final repo = ref.watch(userRepositoryProvider);\n    return await repo.getCurrentUser();\n  }\n\n  Future<void> updateProfile(String name) async {\n    final repo = ref.read(userRepositoryProvider);\n    state = const AsyncLoading();\n    state = await AsyncValue.guard(() => repo.updateUser(name));\n  }\n}\n\n// =====================================================\n// THE DEPENDENCY CHAIN\n// =====================================================\n//\n// UserViewModel\n//      |\n//      | ref.watch(userRepositoryProvider)\n//      v\n// UserRepository\n//      |\n//      | ref.watch(apiClientProvider)\n//      v\n//   ApiClient\n//\n// Each level gets its dependencies injected by Riverpod!\n\n// =====================================================\n// USAGE IN WIDGET\n// =====================================================\n\nclass ProfileScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // You don't create dependencies - Riverpod handles it!\n    final userAsync = ref.watch(userViewModelProvider);\n\n    return userAsync.when(\n      loading: () => CircularProgressIndicator(),\n      error: (e, _) => Text('Error: $e'),\n      data: (user) => Column(\n        children: [\n          Text('Hello, ${user.name}'),\n          ElevatedButton(\n            onPressed: () {\n              ref.read(userViewModelProvider.notifier).updateProfile('New Name');\n            },\n            child: Text('Update Profile'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Notice: The widget has NO idea how UserViewModel gets its dependencies.\n// It just asks Riverpod for the ViewModel, and everything is wired up."
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Dependency Injection Example",
              "content": "Let us build a complete example showing proper dependency injection with Riverpod. We will create a layered architecture where each layer depends on the one below it:\n\n**Layer 1: ApiClient** - Handles raw HTTP communication\n**Layer 2: ProductRepository** - Handles product data operations\n**Layer 3: ProductViewModel** - Handles UI state and business logic\n**Layer 4: ProductScreen** - The UI widget\n\nEach layer receives its dependencies through Riverpod providers, not by creating them directly. This makes every layer testable in isolation.",
              "code": "// =====================================================\n// COMPLETE DEPENDENCY INJECTION EXAMPLE\n// =====================================================\n\nimport 'dart:convert';\nimport 'package:http/http.dart' as http;\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\npart 'product_feature.g.dart';\n\n// =====================================================\n// LAYER 1: API CLIENT (lowest level)\n// =====================================================\n\nclass ApiClient {\n  final String baseUrl;\n  final http.Client httpClient;\n\n  ApiClient({required this.baseUrl, http.Client? client})\n      : httpClient = client ?? http.Client();\n\n  Future<Map<String, dynamic>> get(String endpoint) async {\n    final response = await httpClient.get(Uri.parse('$baseUrl$endpoint'));\n    if (response.statusCode == 200) {\n      return jsonDecode(response.body);\n    }\n    throw Exception('API Error: ${response.statusCode}');\n  }\n\n  Future<Map<String, dynamic>> post(String endpoint, Map<String, dynamic> body) async {\n    final response = await httpClient.post(\n      Uri.parse('$baseUrl$endpoint'),\n      headers: {'Content-Type': 'application/json'},\n      body: jsonEncode(body),\n    );\n    if (response.statusCode == 200 || response.statusCode == 201) {\n      return jsonDecode(response.body);\n    }\n    throw Exception('API Error: ${response.statusCode}');\n  }\n}\n\n// Provider for ApiClient\n@Riverpod(keepAlive: true)  // Keep alive - used throughout app\nApiClient apiClient(Ref ref) {\n  return ApiClient(baseUrl: 'https://api.example.com');\n}\n\n// =====================================================\n// LAYER 2: REPOSITORY (data access)\n// =====================================================\n\nclass Product {\n  final String id;\n  final String name;\n  final double price;\n  final String imageUrl;\n\n  Product({\n    required this.id,\n    required this.name,\n    required this.price,\n    required this.imageUrl,\n  });\n\n  factory Product.fromJson(Map<String, dynamic> json) {\n    return Product(\n      id: json['id'].toString(),\n      name: json['name'],\n      price: (json['price'] as num).toDouble(),\n      imageUrl: json['image_url'] ?? '',\n    );\n  }\n}\n\nabstract class ProductRepository {\n  Future<List<Product>> getProducts();\n  Future<Product> getProduct(String id);\n  Future<void> addToCart(String productId, int quantity);\n}\n\nclass ApiProductRepository implements ProductRepository {\n  final ApiClient _client;\n\n  ApiProductRepository(this._client);  // Dependency injected!\n\n  @override\n  Future<List<Product>> getProducts() async {\n    final data = await _client.get('/products');\n    final items = data['products'] as List;\n    return items.map((item) => Product.fromJson(item)).toList();\n  }\n\n  @override\n  Future<Product> getProduct(String id) async {\n    final data = await _client.get('/products/$id');\n    return Product.fromJson(data);\n  }\n\n  @override\n  Future<void> addToCart(String productId, int quantity) async {\n    await _client.post('/cart', {\n      'product_id': productId,\n      'quantity': quantity,\n    });\n  }\n}\n\n// Provider for ProductRepository - INJECTS ApiClient\n@riverpod\nProductRepository productRepository(Ref ref) {\n  final apiClient = ref.watch(apiClientProvider);  // DI!\n  return ApiProductRepository(apiClient);\n}\n\n// =====================================================\n// LAYER 3: VIEWMODEL (business logic)\n// =====================================================\n\n@riverpod\nclass ProductList extends _$ProductList {\n  @override\n  Future<List<Product>> build() async {\n    // DEPENDENCY INJECTION: Get repository from Riverpod\n    final repository = ref.watch(productRepositoryProvider);\n    return await repository.getProducts();\n  }\n\n  Future<void> refresh() async {\n    state = const AsyncLoading();\n    final repository = ref.read(productRepositoryProvider);\n    state = await AsyncValue.guard(() => repository.getProducts());\n  }\n\n  Future<void> addToCart(String productId) async {\n    final repository = ref.read(productRepositoryProvider);\n    await repository.addToCart(productId, 1);\n    // Could show a snackbar or update cart count here\n  }\n}\n\n// Single product detail (with parameter)\n@riverpod\nclass ProductDetail extends _$ProductDetail {\n  @override\n  Future<Product> build(String productId) async {\n    final repository = ref.watch(productRepositoryProvider);\n    return await repository.getProduct(productId);\n  }\n}\n\n// =====================================================\n// LAYER 4: VIEW (UI)\n// =====================================================\n\nclass ProductListScreen extends ConsumerWidget {\n  const ProductListScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Widget has NO knowledge of repositories or API clients!\n    // It just asks for the ViewModel.\n    final productsAsync = ref.watch(productListProvider);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Products'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.refresh),\n            onPressed: () => ref.read(productListProvider.notifier).refresh(),\n          ),\n        ],\n      ),\n      body: productsAsync.when(\n        loading: () => const Center(child: CircularProgressIndicator()),\n        error: (error, _) => Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              Text('Error: $error'),\n              ElevatedButton(\n                onPressed: () => ref.read(productListProvider.notifier).refresh(),\n                child: const Text('Retry'),\n              ),\n            ],\n          ),\n        ),\n        data: (products) => ListView.builder(\n          itemCount: products.length,\n          itemBuilder: (context, index) {\n            final product = products[index];\n            return ListTile(\n              title: Text(product.name),\n              subtitle: Text('\\$${product.price.toStringAsFixed(2)}'),\n              trailing: IconButton(\n                icon: const Icon(Icons.add_shopping_cart),\n                onPressed: () {\n                  ref.read(productListProvider.notifier).addToCart(product.id);\n                },\n              ),\n              onTap: () {\n                Navigator.push(\n                  context,\n                  MaterialPageRoute(\n                    builder: (_) => ProductDetailScreen(productId: product.id),\n                  ),\n                );\n              },\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n\nclass ProductDetailScreen extends ConsumerWidget {\n  final String productId;\n\n  const ProductDetailScreen({super.key, required this.productId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final productAsync = ref.watch(productDetailProvider(productId));\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Product Detail')),\n      body: productAsync.when(\n        loading: () => const Center(child: CircularProgressIndicator()),\n        error: (e, _) => Center(child: Text('Error: $e')),\n        data: (product) => Padding(\n          padding: const EdgeInsets.all(16),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              Text(product.name, style: Theme.of(context).textTheme.headlineMedium),\n              const SizedBox(height: 8),\n              Text('\\$${product.price.toStringAsFixed(2)}',\n                  style: Theme.of(context).textTheme.titleLarge),\n              const SizedBox(height: 16),\n              ElevatedButton(\n                onPressed: () {\n                  ref.read(productListProvider.notifier).addToCart(product.id);\n                  ScaffoldMessenger.of(context).showSnackBar(\n                    const SnackBar(content: Text('Added to cart!')),\n                  );\n                },\n                child: const Text('Add to Cart'),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// =====================================================\n// THE DEPENDENCY CHAIN IS CLEAR AND TESTABLE\n// =====================================================\n//\n// ProductListScreen / ProductDetailScreen\n//           |\n//           | ref.watch(productListProvider / productDetailProvider)\n//           v\n// ProductList / ProductDetail (ViewModels)\n//           |\n//           | ref.watch(productRepositoryProvider)\n//           v\n//    ProductRepository\n//           |\n//           | ref.watch(apiClientProvider)\n//           v\n//       ApiClient\n//\n// Each layer can be tested independently by overriding providers!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Overriding Providers for Testing",
              "content": "One of the biggest benefits of dependency injection is testability. Riverpod makes this exceptionally easy with **provider overrides**.\n\n### The Testing Problem\n\nWithout DI, testing a ViewModel means testing everything it depends on:\n- ViewModel test accidentally tests the Repository\n- Repository test accidentally tests the ApiClient\n- ApiClient test requires real network calls\n\nYour \"unit test\" becomes an integration test, and it is slow, flaky, and hard to debug.\n\n### The Solution: Override Providers\n\nRiverpod's `ProviderScope` accepts an `overrides` parameter. You can replace any provider with a different implementation:\n\n```dart\nProviderScope(\n  overrides: [\n    // Replace real repository with mock\n    productRepositoryProvider.overrideWith((ref) => MockProductRepository()),\n  ],\n  child: MyApp(),\n)\n```\n\n### How Overrides Work\n\nWhen you override a provider:\n1. Any code watching that provider gets the overridden value\n2. Other providers that depend on it also get the overridden value\n3. The override cascades through the dependency chain\n\nFor example, if you override `apiClientProvider` with a mock, then `productRepositoryProvider` (which depends on it) automatically uses the mock API client.\n\n### Testing Patterns\n\n**Pattern 1: Override at the lowest level**\nOverride the API client to return mock data:\n```dart\napiClientProvider.overrideWith((ref) => MockApiClient())\n```\n\n**Pattern 2: Override at the repository level**\nOverride the repository directly:\n```dart\nproductRepositoryProvider.overrideWith((ref) => MockProductRepository())\n```\n\n**Pattern 3: Override with specific values**\nFor Notifiers, you can override the initial state:\n```dart\nproductListProvider.overrideWith(() => MockProductList())\n```\n\n### Multiple Environments\n\nOverrides are not just for testing. Use them for different environments:\n\n```dart\n// Development\nProviderScope(\n  overrides: [\n    apiClientProvider.overrideWith((ref) => ApiClient(baseUrl: 'http://localhost:8080')),\n  ],\n  child: MyApp(),\n)\n\n// Staging\nProviderScope(\n  overrides: [\n    apiClientProvider.overrideWith((ref) => ApiClient(baseUrl: 'https://staging.example.com')),\n  ],\n  child: MyApp(),\n)\n\n// Production (no overrides - uses default)\nProviderScope(\n  child: MyApp(),\n)\n```",
              "code": "// =====================================================\n// TESTING WITH PROVIDER OVERRIDES\n// =====================================================\n\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter/material.dart';\n\n// Mock repository for testing\nclass MockProductRepository implements ProductRepository {\n  final List<Product> _products;\n  final bool shouldFail;\n\n  MockProductRepository({\n    List<Product>? products,\n    this.shouldFail = false,\n  }) : _products = products ?? [\n         Product(id: '1', name: 'Test Product 1', price: 9.99, imageUrl: ''),\n         Product(id: '2', name: 'Test Product 2', price: 19.99, imageUrl: ''),\n       ];\n\n  @override\n  Future<List<Product>> getProducts() async {\n    // Simulate network delay\n    await Future.delayed(Duration(milliseconds: 10));\n\n    if (shouldFail) {\n      throw Exception('Network error');\n    }\n\n    return _products;\n  }\n\n  @override\n  Future<Product> getProduct(String id) async {\n    await Future.delayed(Duration(milliseconds: 10));\n\n    if (shouldFail) {\n      throw Exception('Network error');\n    }\n\n    return _products.firstWhere((p) => p.id == id);\n  }\n\n  @override\n  Future<void> addToCart(String productId, int quantity) async {\n    await Future.delayed(Duration(milliseconds: 10));\n    if (shouldFail) {\n      throw Exception('Failed to add to cart');\n    }\n  }\n}\n\n// =====================================================\n// WIDGET TEST: Override repository\n// =====================================================\n\nvoid main() {\n  group('ProductListScreen', () {\n    testWidgets('displays list of products', (tester) async {\n      await tester.pumpWidget(\n        ProviderScope(\n          overrides: [\n            // Override with mock that returns specific products\n            productRepositoryProvider.overrideWith((ref) => MockProductRepository(\n              products: [\n                Product(id: '1', name: 'Widget', price: 5.00, imageUrl: ''),\n                Product(id: '2', name: 'Gadget', price: 10.00, imageUrl: ''),\n              ],\n            )),\n          ],\n          child: MaterialApp(home: ProductListScreen()),\n        ),\n      );\n\n      // Initially shows loading\n      expect(find.byType(CircularProgressIndicator), findsOneWidget);\n\n      // Wait for async data to load\n      await tester.pumpAndSettle();\n\n      // Now shows products\n      expect(find.text('Widget'), findsOneWidget);\n      expect(find.text('Gadget'), findsOneWidget);\n      expect(find.text('\\$5.00'), findsOneWidget);\n      expect(find.text('\\$10.00'), findsOneWidget);\n    });\n\n    testWidgets('shows error state when fetch fails', (tester) async {\n      await tester.pumpWidget(\n        ProviderScope(\n          overrides: [\n            // Override with mock that always fails\n            productRepositoryProvider.overrideWith((ref) => MockProductRepository(\n              shouldFail: true,\n            )),\n          ],\n          child: MaterialApp(home: ProductListScreen()),\n        ),\n      );\n\n      // Wait for async operation\n      await tester.pumpAndSettle();\n\n      // Shows error message and retry button\n      expect(find.textContaining('Error'), findsOneWidget);\n      expect(find.text('Retry'), findsOneWidget);\n    });\n\n    testWidgets('retry button refreshes data', (tester) async {\n      final mockRepo = MockProductRepository(shouldFail: true);\n\n      await tester.pumpWidget(\n        ProviderScope(\n          overrides: [\n            productRepositoryProvider.overrideWith((ref) => mockRepo),\n          ],\n          child: MaterialApp(home: ProductListScreen()),\n        ),\n      );\n\n      await tester.pumpAndSettle();\n\n      // Tap retry button\n      await tester.tap(find.text('Retry'));\n      await tester.pump();\n\n      // Should show loading indicator during refresh\n      expect(find.byType(CircularProgressIndicator), findsOneWidget);\n    });\n  });\n}\n\n// =====================================================\n// UNIT TEST: Test ViewModel in isolation\n// =====================================================\n\nvoid main() {\n  group('ProductList ViewModel', () {\n    test('loads products on initialization', () async {\n      // Create a container with mock repository\n      final container = ProviderContainer(\n        overrides: [\n          productRepositoryProvider.overrideWith((ref) => MockProductRepository()),\n        ],\n      );\n\n      // Read the provider\n      final notifier = container.read(productListProvider.notifier);\n\n      // Wait for async initialization\n      await container.read(productListProvider.future);\n\n      // Check state\n      final state = container.read(productListProvider);\n      expect(state.hasValue, isTrue);\n      expect(state.value!.length, equals(2));\n\n      // Clean up\n      container.dispose();\n    });\n\n    test('refresh updates products', () async {\n      final container = ProviderContainer(\n        overrides: [\n          productRepositoryProvider.overrideWith((ref) => MockProductRepository()),\n        ],\n      );\n\n      // Wait for initial load\n      await container.read(productListProvider.future);\n\n      // Refresh\n      await container.read(productListProvider.notifier).refresh();\n\n      // Verify state after refresh\n      final state = container.read(productListProvider);\n      expect(state.hasValue, isTrue);\n\n      container.dispose();\n    });\n  });\n}\n\n// =====================================================\n// ENVIRONMENT-SPECIFIC CONFIGURATION\n// =====================================================\n\nenum Environment { development, staging, production }\n\nProviderScope buildApp(Environment env) {\n  final overrides = <Override>[];\n\n  switch (env) {\n    case Environment.development:\n      overrides.add(\n        apiClientProvider.overrideWith((ref) => ApiClient(\n          baseUrl: 'http://localhost:8080',\n        )),\n      );\n      break;\n    case Environment.staging:\n      overrides.add(\n        apiClientProvider.overrideWith((ref) => ApiClient(\n          baseUrl: 'https://staging.example.com',\n        )),\n      );\n      break;\n    case Environment.production:\n      // Use default production URL from provider\n      break;\n  }\n\n  return ProviderScope(\n    overrides: overrides,\n    child: MyApp(),\n  );\n}\n\n// main_development.dart\nvoid main() {\n  runApp(buildApp(Environment.development));\n}\n\n// main_staging.dart\nvoid main() {\n  runApp(buildApp(Environment.staging));\n}\n\n// main_production.dart\nvoid main() {\n  runApp(buildApp(Environment.production));\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Dependency Injection Best Practices",
              "content": "Follow these best practices to get the most out of dependency injection with Riverpod:\n\n### Best Practice 1: Create Providers for All External Dependencies\n\nAnything that interacts with the outside world should be a provider:\n- HTTP clients\n- Database connections\n- Firebase instances\n- SharedPreferences\n- Local storage\n- Bluetooth/sensors\n- Analytics services\n\n```dart\n@Riverpod(keepAlive: true)\nSharedPreferences sharedPreferences(Ref ref) {\n  throw UnimplementedError('Must be overridden in main()');\n}\n\n// In main.dart:\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  final prefs = await SharedPreferences.getInstance();\n\n  runApp(\n    ProviderScope(\n      overrides: [\n        sharedPreferencesProvider.overrideWithValue(prefs),\n      ],\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n### Best Practice 2: ViewModels Get Dependencies via ref\n\nViewModels should NEVER create their own dependencies. They should always get them from Riverpod:\n\n```dart\n// GOOD:\n@riverpod\nclass UserViewModel extends _$UserViewModel {\n  @override\n  Future<User> build() async {\n    final repo = ref.watch(userRepositoryProvider);  // Get from Riverpod\n    return repo.getCurrentUser();\n  }\n}\n\n// BAD:\n@riverpod\nclass UserViewModel extends _$UserViewModel {\n  final repo = UserRepository();  // DON'T create directly!\n}\n```\n\n### Best Practice 3: Use Abstract Classes for Repositories\n\nDefine repository interfaces as abstract classes. This makes mocking easy:\n\n```dart\n// Define interface\nabstract class UserRepository {\n  Future<User> getUser(String id);\n  Future<void> updateUser(User user);\n}\n\n// Real implementation\nclass ApiUserRepository implements UserRepository { ... }\n\n// Mock for testing\nclass MockUserRepository implements UserRepository { ... }\n```\n\n### Best Practice 4: keepAlive for Singletons\n\nFor services that should exist for the entire app lifetime, use keepAlive:\n\n```dart\n@Riverpod(keepAlive: true)\nAnalyticsService analytics(Ref ref) => AnalyticsService();\n\n@Riverpod(keepAlive: true)\nAuthService authService(Ref ref) => AuthService();\n```\n\n### Best Practice 5: Layer Your Dependencies\n\nOrganize providers in clear layers:\n1. **Core layer**: HTTP clients, storage, platform services\n2. **Data layer**: Repositories that use core layer\n3. **Domain layer**: ViewModels that use data layer\n4. **Presentation layer**: Widgets that use domain layer\n\nEach layer should only depend on the layer below it.\n\n### Best Practice 6: Test at the Right Level\n\n- **Unit tests**: Override at repository level, test ViewModel logic\n- **Integration tests**: Override at API client level, test full feature flow\n- **Widget tests**: Override to control what data the widget receives"
            },
            {
              "type": "WARNING",
              "title": "Dependency Injection Mistakes",
              "content": "Avoid these common mistakes when implementing dependency injection with Riverpod:\n\n### Mistake 1: Creating Instances Inside build()\n\n```dart\n// WRONG: Creating dependency inside the Notifier\n@riverpod\nclass UserViewModel extends _$UserViewModel {\n  @override\n  Future<User> build() async {\n    final repo = UserRepository();  // BAD! Created every rebuild!\n    return repo.getUser();\n  }\n}\n\n// CORRECT: Get from Riverpod\n@riverpod\nclass UserViewModel extends _$UserViewModel {\n  @override\n  Future<User> build() async {\n    final repo = ref.watch(userRepositoryProvider);  // GOOD!\n    return repo.getUser();\n  }\n}\n```\n\nWhen you create instances inside build(), you cannot override them for testing, and you create new instances on every rebuild.\n\n### Mistake 2: Not Using Providers for External Services\n\n```dart\n// WRONG: Using Firebase directly in ViewModel\n@riverpod\nclass AuthViewModel extends _$AuthViewModel {\n  @override\n  User? build() {\n    return FirebaseAuth.instance.currentUser;  // Can't mock this!\n  }\n}\n\n// CORRECT: Create a provider for Firebase\n@Riverpod(keepAlive: true)\nFirebaseAuth firebaseAuth(Ref ref) => FirebaseAuth.instance;\n\n@riverpod\nclass AuthViewModel extends _$AuthViewModel {\n  @override\n  User? build() {\n    final auth = ref.watch(firebaseAuthProvider);  // Now mockable!\n    return auth.currentUser;\n  }\n}\n```\n\n### Mistake 3: Circular Dependencies\n\n```dart\n// WRONG: A depends on B, B depends on A = CRASH!\n@riverpod\nServiceA serviceA(Ref ref) {\n  final b = ref.watch(serviceBProvider);\n  return ServiceA(b);\n}\n\n@riverpod\nServiceB serviceB(Ref ref) {\n  final a = ref.watch(serviceAProvider);  // Circular!\n  return ServiceB(a);\n}\n```\n\n**Fix**: Refactor to break the cycle. Usually this means:\n- One service should not need the other\n- Create a third service they both depend on\n- Use callbacks or events instead of direct references\n\n### Mistake 4: Overusing keepAlive\n\n```dart\n// WRONG: Everything is keepAlive\n@Riverpod(keepAlive: true)\nclass ProductList extends _$ProductList { ... }  // Should dispose!\n\n@Riverpod(keepAlive: true)\nclass UserProfile extends _$UserProfile { ... }  // Should dispose!\n```\n\n**keepAlive** prevents automatic cleanup. Only use it for truly global, app-lifetime services like:\n- Auth state\n- Analytics\n- App configuration\n- Cached API clients\n\nFeature-specific ViewModels should NOT use keepAlive.\n\n### Mistake 5: Accessing Providers Too Late\n\n```dart\n// WRONG: Accessing provider after dispose\n@riverpod\nclass MyViewModel extends _$MyViewModel {\n  @override\n  int build() => 0;\n\n  void doSomething() {\n    Future.delayed(Duration(seconds: 5), () {\n      final service = ref.read(someServiceProvider);  // Might crash!\n      // Widget might have navigated away, disposing this ViewModel\n    });\n  }\n}\n\n// CORRECT: Check if still mounted\nvoid doSomething() {\n  Future.delayed(Duration(seconds: 5), () {\n    // For AsyncNotifier, check state is not disposed\n    if (!ref.exists(someServiceProvider)) return;\n    final service = ref.read(someServiceProvider);\n  });\n}\n```",
              "code": "// =====================================================\n// COMMON DI MISTAKES - BEFORE AND AFTER\n// =====================================================\n\n// MISTAKE 1: Hard-coded dependencies\n// ---------------------------------\n\n// BEFORE (Untestable):\nclass OrderViewModel {\n  final _repo = OrderRepository();      // Hard-coded!\n  final _analytics = AnalyticsService(); // Hard-coded!\n  final _storage = LocalStorage();       // Hard-coded!\n\n  Future<void> placeOrder(Order order) async {\n    await _repo.save(order);\n    _analytics.track('order_placed');\n    await _storage.setLastOrder(order);\n  }\n}\n\n// AFTER (Testable with DI):\n@riverpod\nclass OrderViewModel extends _$OrderViewModel {\n  @override\n  AsyncValue<void> build() => const AsyncData(null);\n\n  Future<void> placeOrder(Order order) async {\n    state = const AsyncLoading();\n\n    final repo = ref.read(orderRepositoryProvider);\n    final analytics = ref.read(analyticsProvider);\n    final storage = ref.read(localStorageProvider);\n\n    state = await AsyncValue.guard(() async {\n      await repo.save(order);\n      analytics.track('order_placed');\n      await storage.setLastOrder(order);\n    });\n  }\n}\n\n// Now in tests:\ntestWidgets('tracks order placement', (tester) async {\n  final mockAnalytics = MockAnalytics();\n\n  await tester.pumpWidget(\n    ProviderScope(\n      overrides: [\n        orderRepositoryProvider.overrideWith((ref) => MockOrderRepo()),\n        analyticsProvider.overrideWith((ref) => mockAnalytics),\n        localStorageProvider.overrideWith((ref) => MockStorage()),\n      ],\n      child: MyApp(),\n    ),\n  );\n\n  // Trigger order placement...\n\n  verify(mockAnalytics.track('order_placed')).called(1);\n});\n\n// MISTAKE 2: Circular dependencies\n// --------------------------------\n\n// WRONG: Creates infinite loop\n@riverpod\nCartService cartService(Ref ref) {\n  return CartService(\n    inventory: ref.watch(inventoryServiceProvider),\n  );\n}\n\n@riverpod\nInventoryService inventoryService(Ref ref) {\n  return InventoryService(\n    cart: ref.watch(cartServiceProvider),  // Circular!\n  );\n}\n\n// FIX: Break the dependency\n// Option A: Remove one direction of dependency\n@riverpod\nCartService cartService(Ref ref) {\n  return CartService(\n    inventory: ref.watch(inventoryServiceProvider),\n  );\n}\n\n@riverpod\nInventoryService inventoryService(Ref ref) {\n  return InventoryService();  // Doesn't need cart\n}\n\n// Option B: Use callbacks instead of direct reference\n@riverpod\nInventoryService inventoryService(Ref ref) {\n  return InventoryService(\n    onStockChanged: (productId, quantity) {\n      // Notify cart via separate mechanism\n      ref.read(stockChangedProvider.notifier).state = (productId, quantity);\n    },\n  );\n}"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.8-challenge-1",
              "title": "Refactor to Use Dependency Injection",
              "description": "Take a ViewModel with hard-coded dependencies and refactor it to use proper dependency injection through Riverpod providers.",
              "instructions": "The starter code shows a WeatherViewModel that creates its dependencies directly, making it impossible to test. Your task is to refactor it to use proper dependency injection:\n\n1. Create a provider for WeatherApiClient (should be keepAlive since it is used app-wide)\n2. Create a provider for WeatherRepository that gets WeatherApiClient from Riverpod\n3. Refactor WeatherViewModel to get WeatherRepository from Riverpod instead of creating it\n4. Ensure the dependency chain is: WeatherViewModel -> WeatherRepository -> WeatherApiClient\n5. All dependencies should be obtained via ref.watch() or ref.read(), never created directly\n\nAfter refactoring:\n- The widget usage should remain the same (just watching weatherViewModelProvider)\n- Each layer should be independently testable\n- You should be able to override any provider for testing\n\nBonus: Add comments showing how you would override these providers in a test.",
              "starterCode": "// File: lib/features/weather/weather_feature.dart\n// STARTER: Hard-coded dependencies - Refactor to use DI!\n\nimport 'dart:convert';\nimport 'package:http/http.dart' as http;\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// Weather Model\nclass Weather {\n  final String city;\n  final double temperature;\n  final String condition;\n\n  Weather({\n    required this.city,\n    required this.temperature,\n    required this.condition,\n  });\n\n  factory Weather.fromJson(Map<String, dynamic> json) {\n    return Weather(\n      city: json['city'],\n      temperature: (json['temperature'] as num).toDouble(),\n      condition: json['condition'],\n    );\n  }\n}\n\n// API Client - handles HTTP communication\nclass WeatherApiClient {\n  final String baseUrl;\n\n  WeatherApiClient({this.baseUrl = 'https://api.weather.example.com'});\n\n  Future<Map<String, dynamic>> get(String endpoint) async {\n    final response = await http.get(Uri.parse('$baseUrl$endpoint'));\n    if (response.statusCode == 200) {\n      return jsonDecode(response.body);\n    }\n    throw Exception('Failed to fetch weather: ${response.statusCode}');\n  }\n}\n\n// Repository - handles data operations\nclass WeatherRepository {\n  final WeatherApiClient _client;\n\n  WeatherRepository(this._client);\n\n  Future<Weather> getWeather(String city) async {\n    final data = await _client.get('/weather?city=$city');\n    return Weather.fromJson(data);\n  }\n}\n\n// PROBLEM: This ViewModel creates its own dependencies!\n// This makes it impossible to test or swap implementations.\nclass WeatherNotifier extends AsyncNotifier<Weather?> {\n  // BAD: Creating dependencies directly!\n  final _client = WeatherApiClient();\n  late final _repository = WeatherRepository(_client);\n\n  @override\n  Future<Weather?> build() async {\n    return null;  // No city selected initially\n  }\n\n  Future<void> loadWeather(String city) async {\n    state = const AsyncLoading();\n    state = await AsyncValue.guard(() => _repository.getWeather(city));\n  }\n\n  void clear() {\n    state = const AsyncData(null);\n  }\n}\n\n// BAD: Provider with hard-coded dependencies\nfinal weatherViewModelProvider =\n    AsyncNotifierProvider<WeatherNotifier, Weather?>(() {\n  return WeatherNotifier();\n});\n\n// TODO: Refactor to use proper Dependency Injection!\n//\n// 1. Create: weatherApiClientProvider (keepAlive)\n//    - Should return WeatherApiClient\n//\n// 2. Create: weatherRepositoryProvider\n//    - Should get WeatherApiClient via ref.watch(weatherApiClientProvider)\n//    - Should return WeatherRepository\n//\n// 3. Refactor: WeatherNotifier\n//    - Remove the hard-coded _client and _repository\n//    - Get repository via ref.watch(weatherRepositoryProvider)\n//    - Use @riverpod annotation and code generation pattern\n//\n// The dependency chain should be:\n// WeatherViewModel -> WeatherRepository -> WeatherApiClient",
              "solution": "// File: lib/features/weather/weather_feature.dart\n// SOLUTION: Proper Dependency Injection with Riverpod\n\nimport 'dart:convert';\nimport 'package:http/http.dart' as http;\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'weather_feature.g.dart';\n\n// Weather Model (unchanged)\nclass Weather {\n  final String city;\n  final double temperature;\n  final String condition;\n\n  Weather({\n    required this.city,\n    required this.temperature,\n    required this.condition,\n  });\n\n  factory Weather.fromJson(Map<String, dynamic> json) {\n    return Weather(\n      city: json['city'],\n      temperature: (json['temperature'] as num).toDouble(),\n      condition: json['condition'],\n    );\n  }\n}\n\n// =====================================================\n// LAYER 1: API CLIENT (lowest level)\n// =====================================================\n\nclass WeatherApiClient {\n  final String baseUrl;\n\n  WeatherApiClient({this.baseUrl = 'https://api.weather.example.com'});\n\n  Future<Map<String, dynamic>> get(String endpoint) async {\n    final response = await http.get(Uri.parse('$baseUrl$endpoint'));\n    if (response.statusCode == 200) {\n      return jsonDecode(response.body);\n    }\n    throw Exception('Failed to fetch weather: ${response.statusCode}');\n  }\n}\n\n// Provider for API Client - keepAlive because it's used app-wide\n@Riverpod(keepAlive: true)\nWeatherApiClient weatherApiClient(Ref ref) {\n  return WeatherApiClient();\n}\n\n// =====================================================\n// LAYER 2: REPOSITORY (data access)\n// =====================================================\n\nabstract class WeatherRepository {\n  Future<Weather> getWeather(String city);\n}\n\nclass ApiWeatherRepository implements WeatherRepository {\n  final WeatherApiClient _client;\n\n  ApiWeatherRepository(this._client);\n\n  @override\n  Future<Weather> getWeather(String city) async {\n    final data = await _client.get('/weather?city=$city');\n    return Weather.fromJson(data);\n  }\n}\n\n// Provider for Repository - injects WeatherApiClient\n@riverpod\nWeatherRepository weatherRepository(Ref ref) {\n  // DEPENDENCY INJECTION: Get API client from Riverpod\n  final client = ref.watch(weatherApiClientProvider);\n  return ApiWeatherRepository(client);\n}\n\n// =====================================================\n// LAYER 3: VIEWMODEL (business logic)\n// =====================================================\n\n@riverpod\nclass WeatherViewModel extends _$WeatherViewModel {\n  @override\n  Future<Weather?> build() async {\n    // No city selected initially\n    return null;\n  }\n\n  Future<void> loadWeather(String city) async {\n    state = const AsyncLoading();\n\n    // DEPENDENCY INJECTION: Get repository from Riverpod\n    final repository = ref.read(weatherRepositoryProvider);\n\n    state = await AsyncValue.guard(() => repository.getWeather(city));\n  }\n\n  void clear() {\n    state = const AsyncData(null);\n  }\n}\n\n// =====================================================\n// THE DEPENDENCY CHAIN IS NOW:\n// =====================================================\n//\n// WeatherViewModel (weatherViewModelProvider)\n//        |\n//        | ref.read(weatherRepositoryProvider)\n//        v\n// WeatherRepository (weatherRepositoryProvider)\n//        |\n//        | ref.watch(weatherApiClientProvider)\n//        v\n// WeatherApiClient (weatherApiClientProvider)\n//\n// Each layer can be overridden independently for testing!\n\n// =====================================================\n// BONUS: HOW TO TEST WITH OVERRIDES\n// =====================================================\n\n/*\n// Mock implementation for testing\nclass MockWeatherRepository implements WeatherRepository {\n  final Weather? mockWeather;\n  final bool shouldFail;\n\n  MockWeatherRepository({\n    this.mockWeather,\n    this.shouldFail = false,\n  });\n\n  @override\n  Future<Weather> getWeather(String city) async {\n    await Future.delayed(Duration(milliseconds: 10));\n\n    if (shouldFail) {\n      throw Exception('Mock network error');\n    }\n\n    return mockWeather ?? Weather(\n      city: city,\n      temperature: 72.0,\n      condition: 'Sunny',\n    );\n  }\n}\n\n// In your test file:\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  group('WeatherViewModel', () {\n    testWidgets('displays weather after loading', (tester) async {\n      await tester.pumpWidget(\n        ProviderScope(\n          overrides: [\n            // Override at repository level for testing\n            weatherRepositoryProvider.overrideWith((ref) => MockWeatherRepository(\n              mockWeather: Weather(\n                city: 'Test City',\n                temperature: 75.0,\n                condition: 'Cloudy',\n              ),\n            )),\n          ],\n          child: MaterialApp(home: WeatherScreen()),\n        ),\n      );\n\n      // Test your widget behavior...\n    });\n\n    testWidgets('shows error when fetch fails', (tester) async {\n      await tester.pumpWidget(\n        ProviderScope(\n          overrides: [\n            weatherRepositoryProvider.overrideWith((ref) => MockWeatherRepository(\n              shouldFail: true,\n            )),\n          ],\n          child: MaterialApp(home: WeatherScreen()),\n        ),\n      );\n\n      // Trigger weather load and verify error state...\n    });\n\n    test('unit test ViewModel in isolation', () async {\n      final container = ProviderContainer(\n        overrides: [\n          weatherRepositoryProvider.overrideWith((ref) => MockWeatherRepository()),\n        ],\n      );\n\n      // Load weather\n      await container.read(weatherViewModelProvider.notifier).loadWeather('NYC');\n\n      // Verify state\n      final state = container.read(weatherViewModelProvider);\n      expect(state.hasValue, isTrue);\n      expect(state.value?.city, equals('NYC'));\n\n      container.dispose();\n    });\n  });\n\n  // Test with different API configurations\n  test('can override API client for staging environment', () {\n    final container = ProviderContainer(\n      overrides: [\n        weatherApiClientProvider.overrideWith((ref) => WeatherApiClient(\n          baseUrl: 'https://staging.api.weather.example.com',\n        )),\n      ],\n    );\n\n    final client = container.read(weatherApiClientProvider);\n    expect(client.baseUrl, contains('staging'));\n\n    container.dispose();\n  });\n}\n*/\n\n// KEY IMPROVEMENTS FROM STARTER CODE:\n//\n// 1. Created weatherApiClientProvider with keepAlive: true\n//    - Singleton pattern for HTTP client\n//    - Can be overridden to point to different servers\n//\n// 2. Created weatherRepositoryProvider that injects WeatherApiClient\n//    - Abstract WeatherRepository interface for mocking\n//    - Gets client via ref.watch()\n//\n// 3. WeatherViewModel now gets repository via ref.read()\n//    - No more hard-coded dependencies\n//    - Fully testable in isolation\n//\n// 4. Each layer can be tested independently\n//    - Override API client for integration tests\n//    - Override repository for unit tests\n//    - Override ViewModel for widget tests",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-api-client-provider",
                  "description": "weatherApiClientProvider is created with keepAlive: true",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-repository-provider",
                  "description": "weatherRepositoryProvider gets WeatherApiClient via ref.watch()",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-viewmodel-di",
                  "description": "WeatherViewModel gets repository via ref instead of creating it",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-no-hardcoded",
                  "description": "No hard-coded dependency creation in ViewModel",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-abstract-repo",
                  "description": "WeatherRepository is an abstract class for mockability",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start from the bottom layer: create a provider for WeatherApiClient. Use @Riverpod(keepAlive: true) since the API client should live for the app's lifetime."
                },
                {
                  "level": 2,
                  "text": "For the repository provider, use ref.watch(weatherApiClientProvider) to get the API client, then return a new ApiWeatherRepository with that client injected."
                },
                {
                  "level": 3,
                  "text": "In WeatherViewModel, remove the _client and _repository fields entirely. In loadWeather(), use ref.read(weatherRepositoryProvider) to get the repository when you need it."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using ref.watch() inside an action method like loadWeather()",
                  "consequence": "Creates a subscription that might cause unnecessary rebuilds or lifecycle issues",
                  "correction": "Use ref.read() inside action methods. Only use ref.watch() in build() to establish reactive dependencies."
                },
                {
                  "mistake": "Forgetting to make WeatherRepository abstract",
                  "consequence": "Cannot easily mock the repository in tests",
                  "correction": "Create an abstract WeatherRepository class and have ApiWeatherRepository implement it. This allows for easy mocking."
                },
                {
                  "mistake": "Using keepAlive on all providers",
                  "consequence": "Memory leaks and stale data since providers never dispose",
                  "correction": "Only use keepAlive for truly global, singleton services like API clients. ViewModels and feature-specific providers should auto-dispose."
                },
                {
                  "mistake": "Creating repository inside the ViewModel's build() method",
                  "consequence": "Creates a new repository instance on every rebuild instead of using the shared one",
                  "correction": "Get the repository via ref.watch(weatherRepositoryProvider) or ref.read() depending on context - Riverpod manages the instance lifecycle."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.9",
          "title": "Flutter Hooks (Optional)",
          "moduleId": "module-05",
          "order": 9,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What are Hooks?",
              "content": "**Flutter Hooks** bring a React-inspired pattern to Flutter that lets you create reusable stateful logic without needing StatefulWidget.\n\n### The Problem Hooks Solve\n\nWith StatefulWidget, you often write repetitive boilerplate:\n\n```dart\nclass MyForm extends StatefulWidget {\n  @override\n  State<MyForm> createState() => _MyFormState();\n}\n\nclass _MyFormState extends State<MyForm> {\n  late TextEditingController _nameController;\n  late TextEditingController _emailController;\n  late FocusNode _nameFocus;\n  late FocusNode _emailFocus;\n\n  @override\n  void initState() {\n    super.initState();\n    _nameController = TextEditingController();\n    _emailController = TextEditingController();\n    _nameFocus = FocusNode();\n    _emailFocus = FocusNode();\n  }\n\n  @override\n  void dispose() {\n    _nameController.dispose();\n    _emailController.dispose();\n    _nameFocus.dispose();\n    _emailFocus.dispose();\n    super.dispose();\n  }\n\n  // ... build method\n}\n```\n\nThat is a lot of code just to manage two text fields! And if you forget to dispose something, you get memory leaks.\n\n### How Hooks Help\n\nWith hooks, the same code becomes:\n\n```dart\nclass MyForm extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final nameController = useTextEditingController();\n    final emailController = useTextEditingController();\n    final nameFocus = useFocusNode();\n    final emailFocus = useFocusNode();\n\n    // ... rest of build method\n  }\n}\n```\n\nNo initState, no dispose, no State class. The hooks automatically handle creation and cleanup.\n\n### Installation\n\nAdd to pubspec.yaml:\n\n```yaml\ndependencies:\n  flutter_hooks: ^0.20.5\n  hooks_riverpod: ^2.5.1  # If using with Riverpod\n```\n\n### Is This Required?\n\nNo! Hooks are optional. You can build excellent Flutter apps without them. Use hooks when:\n- You want less boilerplate\n- You reuse stateful logic across widgets\n- Your team is comfortable with the pattern\n\nSkip hooks if:\n- Your team prefers explicit StatefulWidget\n- You want to minimize external dependencies\n- You find hooks confusing"
            },
            {
              "type": "THEORY",
              "title": "Common Hooks",
              "content": "Flutter Hooks provides many built-in hooks. Here are the ones you will use most often:\n\n### useState<T>() - Local State\n\nThe simplest hook. Creates a piece of state that persists across rebuilds:\n\n```dart\nclass Counter extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Creates state that persists across rebuilds\n    final counter = useState(0);\n\n    return Column(\n      children: [\n        Text('Count: ${counter.value}'),\n        ElevatedButton(\n          onPressed: () => counter.value++,  // Triggers rebuild\n          child: Text('Increment'),\n        ),\n      ],\n    );\n  }\n}\n```\n\n`useState` returns a `ValueNotifier<T>`. Access the value with `.value`, and setting it triggers a rebuild.\n\n### useEffect() - Side Effects\n\nRuns side effects like initState/dispose, but more flexible:\n\n```dart\nclass UserProfile extends HookWidget {\n  final String userId;\n  UserProfile({required this.userId});\n\n  @override\n  Widget build(BuildContext context) {\n    final userData = useState<User?>(null);\n\n    // Runs when widget mounts (like initState)\n    // Runs again if userId changes\n    useEffect(() {\n      fetchUser(userId).then((user) => userData.value = user);\n\n      // Return a cleanup function (like dispose)\n      return () {\n        print('Cleaning up for user: $userId');\n      };\n    }, [userId]);  // Dependencies - re-run if these change\n\n    return userData.value == null\n        ? CircularProgressIndicator()\n        : Text(userData.value!.name);\n  }\n}\n```\n\nThe second argument is the dependency list:\n- `[]` - Run once on mount, cleanup on dispose\n- `[userId]` - Run on mount and whenever userId changes\n- No argument - Run after every build (rarely needed)\n\n### useMemoized() - Cached Computations\n\nCaches expensive computations so they do not re-run on every build:\n\n```dart\nclass ExpensiveList extends HookWidget {\n  final List<Item> items;\n  ExpensiveList({required this.items});\n\n  @override\n  Widget build(BuildContext context) {\n    // Only recomputes when items changes\n    final sortedItems = useMemoized(\n      () => items.toList()..sort((a, b) => a.name.compareTo(b.name)),\n      [items],\n    );\n\n    return ListView(\n      children: sortedItems.map((i) => ListTile(title: Text(i.name))).toList(),\n    );\n  }\n}\n```\n\n### useTextEditingController() - Auto-Disposed Controllers\n\nCreates a TextEditingController that is automatically disposed:\n\n```dart\nclass SearchBar extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final controller = useTextEditingController();\n\n    return TextField(\n      controller: controller,\n      onSubmitted: (query) => search(query),\n    );\n  }\n}\n\n// With initial text:\nfinal controller = useTextEditingController(text: 'Initial value');\n```\n\n### Other Useful Hooks\n\n```dart\n// Focus management\nfinal focusNode = useFocusNode();\n\n// Animation controller (auto-disposed)\nfinal animController = useAnimationController(\n  duration: Duration(milliseconds: 300),\n);\n\n// Scroll controller\nfinal scrollController = useScrollController();\n\n// Tab controller\nfinal tabController = useTabController(initialLength: 3);\n\n// Page controller\nfinal pageController = usePageController();\n\n// Stream subscription\nuseStream(myStream);\n\n// Future\nfinal snapshot = useFuture(myFuture);\n```",
              "code": "// Complete example showing common hooks together\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_hooks/flutter_hooks.dart';\n\nclass UserSearchScreen extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    // useState: track loading state\n    final isLoading = useState(false);\n    final users = useState<List<User>>([]);\n    final errorMessage = useState<String?>(null);\n\n    // useTextEditingController: auto-disposed text controller\n    final searchController = useTextEditingController();\n\n    // useFocusNode: auto-disposed focus node\n    final searchFocus = useFocusNode();\n\n    // useEffect: auto-focus on mount\n    useEffect(() {\n      searchFocus.requestFocus();\n      return null;  // No cleanup needed\n    }, []);  // Empty deps = run once on mount\n\n    // useMemoized: filter users based on search (cached)\n    final filteredUsers = useMemoized(\n      () {\n        final query = searchController.text.toLowerCase();\n        if (query.isEmpty) return users.value;\n        return users.value\n            .where((u) => u.name.toLowerCase().contains(query))\n            .toList();\n      },\n      [users.value, searchController.text],\n    );\n\n    // useEffect: fetch users on mount\n    useEffect(() {\n      isLoading.value = true;\n      fetchUsers().then((result) {\n        users.value = result;\n        isLoading.value = false;\n      }).catchError((e) {\n        errorMessage.value = e.toString();\n        isLoading.value = false;\n      });\n\n      return null;  // No cleanup\n    }, []);\n\n    return Scaffold(\n      appBar: AppBar(title: Text('User Search')),\n      body: Column(\n        children: [\n          // Search field with auto-disposed controller\n          Padding(\n            padding: EdgeInsets.all(16),\n            child: TextField(\n              controller: searchController,\n              focusNode: searchFocus,\n              decoration: InputDecoration(\n                hintText: 'Search users...',\n                prefixIcon: Icon(Icons.search),\n              ),\n              onChanged: (_) {\n                // Force rebuild to update filteredUsers\n                // In real app, you'd debounce this\n              },\n            ),\n          ),\n\n          // Results\n          Expanded(\n            child: isLoading.value\n                ? Center(child: CircularProgressIndicator())\n                : errorMessage.value != null\n                    ? Center(child: Text('Error: ${errorMessage.value}'))\n                    : ListView.builder(\n                        itemCount: filteredUsers.length,\n                        itemBuilder: (context, index) {\n                          final user = filteredUsers[index];\n                          return ListTile(\n                            leading: CircleAvatar(child: Text(user.name[0])),\n                            title: Text(user.name),\n                            subtitle: Text(user.email),\n                          );\n                        },\n                      ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass User {\n  final String id;\n  final String name;\n  final String email;\n  User({required this.id, required this.name, required this.email});\n}\n\nFuture<List<User>> fetchUsers() async {\n  await Future.delayed(Duration(seconds: 1));\n  return [\n    User(id: '1', name: 'Alice Johnson', email: 'alice@example.com'),\n    User(id: '2', name: 'Bob Smith', email: 'bob@example.com'),\n    User(id: '3', name: 'Carol White', email: 'carol@example.com'),\n  ];\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Hooks + Riverpod Together",
              "content": "The `hooks_riverpod` package provides **HookConsumerWidget** which combines the power of both:\n- **Hooks** for local UI state (controllers, animations, focus)\n- **Riverpod** for shared/global state (user data, app settings, API data)\n\n### When to Use Each\n\n| Use Hooks For | Use Riverpod For |\n|--------------|------------------|\n| TextEditingController | User authentication state |\n| FocusNode | Shopping cart contents |\n| AnimationController | API data (products, users) |\n| Local form validation | App settings/preferences |\n| Scroll position | Cached network responses |\n\n### HookConsumerWidget\n\nExtend `HookConsumerWidget` instead of `ConsumerWidget` or `HookWidget`:\n\n```dart\nclass ProfileEditor extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Use Riverpod for shared state\n    final user = ref.watch(currentUserProvider);\n\n    // Use hooks for local UI state\n    final nameController = useTextEditingController(text: user.name);\n    final emailController = useTextEditingController(text: user.email);\n    final isEditing = useState(false);\n\n    // Both work together seamlessly!\n    return Column(\n      children: [\n        TextField(\n          controller: nameController,\n          enabled: isEditing.value,\n        ),\n        ElevatedButton(\n          onPressed: () async {\n            // Read from hook, write to Riverpod\n            await ref.read(currentUserProvider.notifier).updateProfile(\n              name: nameController.text,\n              email: emailController.text,\n            );\n            isEditing.value = false;\n          },\n          child: Text('Save'),\n        ),\n      ],\n    );\n  }\n}\n```\n\n### Real-World Example: Contact Form\n\nThis example shows a complete contact form using hooks for form management and Riverpod for submission:",
              "code": "// Complete example: Contact form with Hooks + Riverpod\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_hooks/flutter_hooks.dart';\nimport 'package:hooks_riverpod/hooks_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'contact_form.g.dart';\n\n// =====================================================\n// RIVERPOD: Handles form submission (shared/async state)\n// =====================================================\n\n@riverpod\nclass ContactFormSubmission extends _$ContactFormSubmission {\n  @override\n  AsyncValue<String?> build() => const AsyncData(null);\n\n  Future<void> submit({\n    required String name,\n    required String email,\n    required String message,\n  }) async {\n    state = const AsyncLoading();\n\n    state = await AsyncValue.guard(() async {\n      // Simulate API call\n      await Future.delayed(const Duration(seconds: 2));\n\n      // Validate on server (could throw)\n      if (message.length < 10) {\n        throw Exception('Message must be at least 10 characters');\n      }\n\n      // Return success message\n      return 'Thank you, $name! We will contact you at $email.';\n    });\n  }\n\n  void reset() {\n    state = const AsyncData(null);\n  }\n}\n\n// =====================================================\n// HOOKS + RIVERPOD: The UI Widget\n// =====================================================\n\nclass ContactFormScreen extends HookConsumerWidget {\n  const ContactFormScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // ===== HOOKS: Local UI state =====\n\n    // Text controllers (auto-disposed)\n    final nameController = useTextEditingController();\n    final emailController = useTextEditingController();\n    final messageController = useTextEditingController();\n\n    // Focus nodes (auto-disposed)\n    final nameFocus = useFocusNode();\n    final emailFocus = useFocusNode();\n    final messageFocus = useFocusNode();\n\n    // Local validation state\n    final isNameValid = useState(true);\n    final isEmailValid = useState(true);\n    final isMessageValid = useState(true);\n\n    // Auto-focus name field on mount\n    useEffect(() {\n      nameFocus.requestFocus();\n      return null;\n    }, []);\n\n    // ===== RIVERPOD: Submission state =====\n    final submissionState = ref.watch(contactFormSubmissionProvider);\n\n    // ===== VALIDATION FUNCTIONS =====\n\n    bool validateForm() {\n      final nameOk = nameController.text.trim().isNotEmpty;\n      final emailOk = emailController.text.contains('@');\n      final messageOk = messageController.text.trim().length >= 10;\n\n      isNameValid.value = nameOk;\n      isEmailValid.value = emailOk;\n      isMessageValid.value = messageOk;\n\n      return nameOk && emailOk && messageOk;\n    }\n\n    void handleSubmit() {\n      if (!validateForm()) return;\n\n      ref.read(contactFormSubmissionProvider.notifier).submit(\n        name: nameController.text.trim(),\n        email: emailController.text.trim(),\n        message: messageController.text.trim(),\n      );\n    }\n\n    void handleReset() {\n      nameController.clear();\n      emailController.clear();\n      messageController.clear();\n      isNameValid.value = true;\n      isEmailValid.value = true;\n      isMessageValid.value = true;\n      ref.read(contactFormSubmissionProvider.notifier).reset();\n      nameFocus.requestFocus();\n    }\n\n    // ===== BUILD UI =====\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Contact Us')),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // Success message from Riverpod\n            if (submissionState.hasValue && submissionState.value != null)\n              Card(\n                color: Colors.green.shade50,\n                child: Padding(\n                  padding: const EdgeInsets.all(16),\n                  child: Column(\n                    children: [\n                      const Icon(Icons.check_circle, color: Colors.green, size: 48),\n                      const SizedBox(height: 8),\n                      Text(\n                        submissionState.value!,\n                        textAlign: TextAlign.center,\n                        style: const TextStyle(color: Colors.green),\n                      ),\n                      const SizedBox(height: 16),\n                      ElevatedButton(\n                        onPressed: handleReset,\n                        child: const Text('Send Another Message'),\n                      ),\n                    ],\n                  ),\n                ),\n              )\n            else ...[\n              // Name field\n              TextField(\n                controller: nameController,\n                focusNode: nameFocus,\n                decoration: InputDecoration(\n                  labelText: 'Name',\n                  errorText: isNameValid.value ? null : 'Name is required',\n                  prefixIcon: const Icon(Icons.person),\n                ),\n                textInputAction: TextInputAction.next,\n                onSubmitted: (_) => emailFocus.requestFocus(),\n                onChanged: (_) => isNameValid.value = true,\n              ),\n              const SizedBox(height: 16),\n\n              // Email field\n              TextField(\n                controller: emailController,\n                focusNode: emailFocus,\n                decoration: InputDecoration(\n                  labelText: 'Email',\n                  errorText: isEmailValid.value ? null : 'Valid email required',\n                  prefixIcon: const Icon(Icons.email),\n                ),\n                keyboardType: TextInputType.emailAddress,\n                textInputAction: TextInputAction.next,\n                onSubmitted: (_) => messageFocus.requestFocus(),\n                onChanged: (_) => isEmailValid.value = true,\n              ),\n              const SizedBox(height: 16),\n\n              // Message field\n              TextField(\n                controller: messageController,\n                focusNode: messageFocus,\n                decoration: InputDecoration(\n                  labelText: 'Message',\n                  errorText: isMessageValid.value ? null : 'At least 10 characters',\n                  prefixIcon: const Icon(Icons.message),\n                  alignLabelWithHint: true,\n                ),\n                maxLines: 5,\n                onChanged: (_) => isMessageValid.value = true,\n              ),\n              const SizedBox(height: 24),\n\n              // Error message from Riverpod\n              if (submissionState.hasError)\n                Padding(\n                  padding: const EdgeInsets.only(bottom: 16),\n                  child: Text(\n                    'Error: ${submissionState.error}',\n                    style: TextStyle(color: Theme.of(context).colorScheme.error),\n                  ),\n                ),\n\n              // Submit button\n              ElevatedButton(\n                onPressed: submissionState.isLoading ? null : handleSubmit,\n                child: submissionState.isLoading\n                    ? const SizedBox(\n                        height: 20,\n                        width: 20,\n                        child: CircularProgressIndicator(strokeWidth: 2),\n                      )\n                    : const Text('Send Message'),\n              ),\n            ],\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// =====================================================\n// KEY POINTS:\n// =====================================================\n//\n// HOOKS handle:\n// - TextEditingController (nameController, emailController, messageController)\n// - FocusNode (nameFocus, emailFocus, messageFocus)\n// - Local validation state (isNameValid, isEmailValid, isMessageValid)\n// - Side effects (auto-focus on mount)\n//\n// RIVERPOD handles:\n// - Form submission state (loading, error, success)\n// - Async operation (API call simulation)\n// - State that needs to be accessible outside this widget\n//\n// This separation keeps code clean:\n// - UI concerns stay in hooks (easy to read, auto-cleanup)\n// - Business logic stays in Riverpod (testable, shareable)",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "When to Use Hooks",
              "content": "### Use Hooks For:\n\n**1. Local UI State**\n- Form controllers and focus nodes\n- Animation controllers\n- Scroll/page/tab controllers\n- Local boolean flags (isExpanded, isEditing, etc.)\n\n**2. Auto-Disposing Resources**\n- Anything that needs dispose() called\n- Controllers, subscriptions, listeners\n- Hooks handle cleanup automatically\n\n**3. Side Effects Tied to Widget Lifecycle**\n- Fetching data when widget mounts\n- Setting up listeners\n- Logging or analytics\n\n### Do NOT Use Hooks For:\n\n**1. Shared State**\nIf multiple widgets need the same data, use Riverpod:\n```dart\n// BAD: Each widget gets its own copy\nfinal cartItems = useState<List<Item>>([]);\n\n// GOOD: All widgets share the same state\nfinal cartItems = ref.watch(cartProvider);\n```\n\n**2. Data That Survives Navigation**\nHooks die when the widget is disposed:\n```dart\n// BAD: Lost when navigating away\nfinal searchQuery = useState('');\n\n// GOOD: Persists during navigation\nfinal searchQuery = ref.watch(searchQueryProvider);\n```\n\n**3. Complex Business Logic**\nKeep business logic in Riverpod providers where it can be tested:\n```dart\n// BAD: Hard to test, mixed concerns\nuseEffect(() {\n  calculateTax();\n  applyDiscount();\n  updateInventory();\n}, [cart]);\n\n// GOOD: Testable, separated concerns\nref.watch(orderTotalProvider);  // Handles all calculation logic\n```\n\n### The Golden Rule\n\n**Hooks = Local to one widget, needs cleanup**\n\n**Riverpod = Shared between widgets, or complex logic**"
            },
            {
              "type": "WARNING",
              "title": "Hooks Rules",
              "content": "Hooks have strict rules. Breaking them causes bugs that are hard to debug.\n\n### Rule 1: Only Call Hooks at the Top of build()\n\n```dart\n// CORRECT: Hooks at top level\nclass MyWidget extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final controller = useTextEditingController();  // OK\n    final counter = useState(0);  // OK\n    final focus = useFocusNode();  // OK\n\n    return TextField(controller: controller);\n  }\n}\n\n// WRONG: Hook inside a condition\nclass BadWidget extends HookWidget {\n  final bool showSearch;\n  BadWidget({required this.showSearch});\n\n  @override\n  Widget build(BuildContext context) {\n    // BAD! Hook count changes based on showSearch\n    if (showSearch) {\n      final controller = useTextEditingController();  // WRONG!\n    }\n\n    return Container();\n  }\n}\n```\n\n**Why?** Flutter tracks hooks by their order of calls. If the order changes between builds, hooks get mixed up and your app breaks.\n\n### Rule 2: Do NOT Call Hooks in Loops\n\n```dart\n// WRONG: Hook in a loop\nclass BadWidget extends HookWidget {\n  final List<String> items;\n  BadWidget({required this.items});\n\n  @override\n  Widget build(BuildContext context) {\n    // BAD! Number of hooks changes with items.length\n    for (final item in items) {\n      final controller = useTextEditingController(text: item);  // WRONG!\n    }\n    return Container();\n  }\n}\n\n// CORRECT: Use a single hook with a list\nclass GoodWidget extends HookWidget {\n  final List<String> items;\n  GoodWidget({required this.items});\n\n  @override\n  Widget build(BuildContext context) {\n    // Create a list of controllers with useMemoized\n    final controllers = useMemoized(\n      () => items.map((item) => TextEditingController(text: item)).toList(),\n      [items.length],\n    );\n\n    // Dispose them manually with useEffect\n    useEffect(() {\n      return () => controllers.forEach((c) => c.dispose());\n    }, [controllers]);\n\n    return Column(\n      children: controllers.map((c) => TextField(controller: c)).toList(),\n    );\n  }\n}\n```\n\n### Rule 3: Do NOT Call Hooks in Callbacks\n\n```dart\n// WRONG: Hook in onPressed\nclass BadWidget extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      onPressed: () {\n        final counter = useState(0);  // WRONG! Called outside build()\n      },\n      child: Text('Tap'),\n    );\n  }\n}\n\n// CORRECT: Define hook at top, use in callback\nclass GoodWidget extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final counter = useState(0);  // OK: at top of build()\n\n    return ElevatedButton(\n      onPressed: () {\n        counter.value++;  // OK: using the hook's value\n      },\n      child: Text('Count: ${counter.value}'),\n    );\n  }\n}\n```\n\n### Rule 4: Do NOT Call Hooks in Nested Functions\n\n```dart\n// WRONG: Hook in helper function\nclass BadWidget extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    Widget buildHeader() {\n      final title = useState('Header');  // WRONG!\n      return Text(title.value);\n    }\n\n    return Column(\n      children: [\n        buildHeader(),\n        Text('Body'),\n      ],\n    );\n  }\n}\n\n// CORRECT: Pass values to helper functions\nclass GoodWidget extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final title = useState('Header');  // OK: at top of build()\n\n    Widget buildHeader(String titleText) {\n      return Text(titleText);\n    }\n\n    return Column(\n      children: [\n        buildHeader(title.value),  // Pass value in\n        Text('Body'),\n      ],\n    );\n  }\n}\n```\n\n### Summary of Rules\n\n| Do | Do Not |\n|---|---|\n| Call hooks at top of build() | Call hooks conditionally |\n| Call hooks in same order every build | Call hooks in loops |\n| Use hook values in callbacks | Call hooks in callbacks |\n| Pass values to helper functions | Call hooks in nested functions |"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.9-challenge-1",
              "title": "Build a Form with Flutter Hooks",
              "description": "Create a signup form using Flutter Hooks for form management. Use useTextEditingController for input fields and useState for validation state.",
              "instructions": "Build a signup form with the following requirements:\n\n1. **Three input fields using hooks:**\n   - Username (useTextEditingController)\n   - Email (useTextEditingController)\n   - Password (useTextEditingController)\n\n2. **Validation state using useState:**\n   - Track whether the form has been submitted\n   - Track individual field validity\n   - Show validation errors only after first submit attempt\n\n3. **Validation rules:**\n   - Username: at least 3 characters\n   - Email: must contain @ symbol\n   - Password: at least 8 characters\n\n4. **UI Requirements:**\n   - Show error messages below invalid fields\n   - Disable submit button while any field is empty\n   - Show success message when form is valid and submitted\n\n5. **Use hooks properly:**\n   - All hooks at top of build() method\n   - No hooks in conditions or loops\n   - Use useMemoized for computed validation state",
              "starterCode": "import 'package:flutter/material.dart';\nimport 'package:flutter_hooks/flutter_hooks.dart';\n\nvoid main() {\n  runApp(const MaterialApp(home: SignupFormScreen()));\n}\n\nclass SignupFormScreen extends HookWidget {\n  const SignupFormScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO 1: Create text controllers using useTextEditingController\n    // final usernameController = useTextEditingController();\n    // final emailController = useTextEditingController();\n    // final passwordController = useTextEditingController();\n\n    // TODO 2: Create state for tracking form submission\n    // final hasSubmitted = useState(false);\n    // final showSuccess = useState(false);\n\n    // TODO 3: Create validation functions\n    // Use useMemoized to cache validation results\n\n    // TODO 4: Create submit handler\n    // void handleSubmit() { ... }\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Sign Up')),\n      body: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // TODO 5: Build username field with validation\n            // TextField(\n            //   controller: usernameController,\n            //   decoration: InputDecoration(\n            //     labelText: 'Username',\n            //     errorText: ...,\n            //   ),\n            // ),\n\n            // TODO 6: Build email field with validation\n\n            // TODO 7: Build password field with validation\n\n            // TODO 8: Build submit button\n\n            // TODO 9: Show success message when submitted successfully\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "solution": "import 'package:flutter/material.dart';\nimport 'package:flutter_hooks/flutter_hooks.dart';\n\nvoid main() {\n  runApp(const MaterialApp(home: SignupFormScreen()));\n}\n\nclass SignupFormScreen extends HookWidget {\n  const SignupFormScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // ===== HOOKS: All at top of build() =====\n\n    // Text controllers (auto-disposed)\n    final usernameController = useTextEditingController();\n    final emailController = useTextEditingController();\n    final passwordController = useTextEditingController();\n\n    // Form state\n    final hasSubmitted = useState(false);\n    final showSuccess = useState(false);\n\n    // Force rebuild when text changes (for button enable state)\n    useListenable(usernameController);\n    useListenable(emailController);\n    useListenable(passwordController);\n\n    // ===== VALIDATION (computed from current values) =====\n\n    final username = usernameController.text;\n    final email = emailController.text;\n    final password = passwordController.text;\n\n    // Validation checks\n    final isUsernameValid = username.length >= 3;\n    final isEmailValid = email.contains('@');\n    final isPasswordValid = password.length >= 8;\n    final isFormValid = isUsernameValid && isEmailValid && isPasswordValid;\n\n    // Error messages (only show after first submit attempt)\n    String? usernameError;\n    String? emailError;\n    String? passwordError;\n\n    if (hasSubmitted.value) {\n      if (!isUsernameValid) usernameError = 'Username must be at least 3 characters';\n      if (!isEmailValid) emailError = 'Please enter a valid email address';\n      if (!isPasswordValid) passwordError = 'Password must be at least 8 characters';\n    }\n\n    // Check if all fields have content (for button enable)\n    final allFieldsFilled = username.isNotEmpty && email.isNotEmpty && password.isNotEmpty;\n\n    // ===== SUBMIT HANDLER =====\n\n    void handleSubmit() {\n      hasSubmitted.value = true;\n\n      if (isFormValid) {\n        showSuccess.value = true;\n      }\n    }\n\n    void handleReset() {\n      usernameController.clear();\n      emailController.clear();\n      passwordController.clear();\n      hasSubmitted.value = false;\n      showSuccess.value = false;\n    }\n\n    // ===== BUILD UI =====\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Sign Up')),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // Success message\n            if (showSuccess.value)\n              Card(\n                color: Colors.green.shade50,\n                child: Padding(\n                  padding: const EdgeInsets.all(16),\n                  child: Column(\n                    children: [\n                      const Icon(Icons.check_circle, color: Colors.green, size: 48),\n                      const SizedBox(height: 8),\n                      Text(\n                        'Welcome, $username!',\n                        style: Theme.of(context).textTheme.titleLarge,\n                      ),\n                      const SizedBox(height: 4),\n                      const Text('Your account has been created.'),\n                      const SizedBox(height: 16),\n                      ElevatedButton(\n                        onPressed: handleReset,\n                        child: const Text('Sign Up Another User'),\n                      ),\n                    ],\n                  ),\n                ),\n              )\n            else ...[\n              // Username field\n              TextField(\n                controller: usernameController,\n                decoration: InputDecoration(\n                  labelText: 'Username',\n                  hintText: 'At least 3 characters',\n                  prefixIcon: const Icon(Icons.person),\n                  errorText: usernameError,\n                  border: const OutlineInputBorder(),\n                ),\n                textInputAction: TextInputAction.next,\n              ),\n              const SizedBox(height: 16),\n\n              // Email field\n              TextField(\n                controller: emailController,\n                decoration: InputDecoration(\n                  labelText: 'Email',\n                  hintText: 'example@email.com',\n                  prefixIcon: const Icon(Icons.email),\n                  errorText: emailError,\n                  border: const OutlineInputBorder(),\n                ),\n                keyboardType: TextInputType.emailAddress,\n                textInputAction: TextInputAction.next,\n              ),\n              const SizedBox(height: 16),\n\n              // Password field\n              TextField(\n                controller: passwordController,\n                decoration: InputDecoration(\n                  labelText: 'Password',\n                  hintText: 'At least 8 characters',\n                  prefixIcon: const Icon(Icons.lock),\n                  errorText: passwordError,\n                  border: const OutlineInputBorder(),\n                ),\n                obscureText: true,\n                textInputAction: TextInputAction.done,\n                onSubmitted: (_) => handleSubmit(),\n              ),\n              const SizedBox(height: 24),\n\n              // Submit button\n              ElevatedButton(\n                onPressed: allFieldsFilled ? handleSubmit : null,\n                style: ElevatedButton.styleFrom(\n                  padding: const EdgeInsets.symmetric(vertical: 16),\n                ),\n                child: const Text('Create Account'),\n              ),\n\n              // Validation hints\n              const SizedBox(height: 24),\n              Text(\n                'Requirements:',\n                style: Theme.of(context).textTheme.titleSmall,\n              ),\n              const SizedBox(height: 8),\n              _RequirementRow(\n                text: 'Username: 3+ characters',\n                isMet: isUsernameValid,\n              ),\n              _RequirementRow(\n                text: 'Email: valid format',\n                isMet: isEmailValid,\n              ),\n              _RequirementRow(\n                text: 'Password: 8+ characters',\n                isMet: isPasswordValid,\n              ),\n            ],\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass _RequirementRow extends StatelessWidget {\n  final String text;\n  final bool isMet;\n\n  const _RequirementRow({required this.text, required this.isMet});\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 4),\n      child: Row(\n        children: [\n          Icon(\n            isMet ? Icons.check_circle : Icons.circle_outlined,\n            color: isMet ? Colors.green : Colors.grey,\n            size: 20,\n          ),\n          const SizedBox(width: 8),\n          Text(\n            text,\n            style: TextStyle(\n              color: isMet ? Colors.green : Colors.grey.shade600,\n              decoration: isMet ? TextDecoration.lineThrough : null,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// =====================================================\n// KEY LEARNING POINTS:\n// =====================================================\n//\n// 1. All hooks called at top of build() - never conditionally\n//\n// 2. useTextEditingController() creates auto-disposed controllers\n//\n// 3. useState() for local state that triggers rebuilds\n//\n// 4. useListenable() to rebuild when controller text changes\n//    (needed for the submit button enabled state)\n//\n// 5. Validation logic is just regular Dart - no hooks needed\n//    (hooks are for state that needs Flutter lifecycle)\n//\n// 6. Error messages only shown after hasSubmitted is true\n//    (better UX than showing errors immediately)\n//\n// 7. Button disabled when fields empty (allFieldsFilled check)",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-hooks-usage",
                  "description": "Uses useTextEditingController for all three input fields",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-useState",
                  "description": "Uses useState for hasSubmitted and showSuccess state",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-hooks-at-top",
                  "description": "All hooks are called at the top of build() method",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-validation-rules",
                  "description": "Implements correct validation: username >= 3, email has @, password >= 8",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-error-display",
                  "description": "Shows errors only after first submit attempt",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start by creating all three useTextEditingController hooks at the very top of your build method, before any other code."
                },
                {
                  "level": 2,
                  "text": "Use useState(false) for hasSubmitted. Set it to true in your handleSubmit function. Only show error messages when hasSubmitted.value is true."
                },
                {
                  "level": 3,
                  "text": "To make the button update when text changes, either use useListenable(controller) for each controller, or call useState with the text values to track changes."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Calling hooks inside conditionals or loops",
                  "consequence": "Hook state gets mixed up between rebuilds, causing unpredictable bugs",
                  "correction": "Always call all hooks at the top of build() in the same order every time"
                },
                {
                  "mistake": "Forgetting to make button state reactive to text changes",
                  "consequence": "Submit button stays disabled even when all fields are filled",
                  "correction": "Use useListenable(controller) or track controller.text in a way that triggers rebuilds"
                },
                {
                  "mistake": "Showing validation errors immediately before user submits",
                  "consequence": "Poor UX - user sees errors before they even start typing",
                  "correction": "Track hasSubmitted state and only show errors when hasSubmitted.value is true"
                },
                {
                  "mistake": "Creating TextEditingController manually without useTextEditingController",
                  "consequence": "Memory leak because controller is never disposed",
                  "correction": "Use useTextEditingController() which handles disposal automatically"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "5.10",
          "title": "Mini-Project: Refactor Notes App",
          "moduleId": "module-05",
          "order": 10,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "Time to put everything together! In this mini-project, you will refactor a messy Notes app into clean MVVM architecture.\n\n### What We're Starting With\n\nA Notes app where everything is crammed into one StatefulWidget:\n- Notes stored directly in widget state\n- CRUD methods mixed with UI code\n- No separation of concerns\n- Hard to test, hard to maintain\n\n### What We're Building\n\nA properly architected Notes app with:\n- **Model**: Clean `Note` class with immutable data\n- **ViewModel**: `NotesViewModel` with Riverpod handling all logic\n- **View**: Clean `ConsumerWidget` that only handles UI\n\n### Why This Matters\n\nThe messy version works, but it has problems:\n- Cannot test business logic without testing UI\n- Cannot share notes state with other screens\n- Hard to add features without breaking things\n- Difficult for teams to work on\n\nThe refactored version solves all of these issues.\n\n### The Refactoring Process\n\nWe will follow three simple steps:\n1. **Extract the Model**: Create a proper `Note` class\n2. **Extract the ViewModel**: Move all logic to a Riverpod provider\n3. **Clean up the View**: Make the widget only handle UI"
            },
            {
              "type": "THEORY",
              "title": "The Messy Starting Code",
              "content": "Here is our starting point - a Notes app with everything mixed together. Look at all the problems:\n\n### Problems With This Code\n\n1. **State mixed with UI**: `_notes` list lives in the widget\n2. **Business logic in widget**: `_addNote`, `_updateNote`, `_deleteNote` are in the UI class\n3. **No data model**: Notes are just `Map<String, String>` - no type safety\n4. **Cannot share state**: Other screens cannot access notes\n5. **Cannot test logic**: Would need widget tests for everything\n6. **ID generation in UI**: `DateTime.now()` logic should not be here",
              "code": "// THE MESSY VERSION - Everything in one StatefulWidget\n\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(const MaterialApp(home: MessyNotesApp()));\n\nclass MessyNotesApp extends StatefulWidget {\n  const MessyNotesApp({super.key});\n\n  @override\n  State<MessyNotesApp> createState() => _MessyNotesAppState();\n}\n\nclass _MessyNotesAppState extends State<MessyNotesApp> {\n  // Problem: State stored directly in widget\n  final List<Map<String, String>> _notes = [];\n\n  // Problem: Business logic mixed with UI\n  void _addNote(String title, String content) {\n    setState(() {\n      _notes.add({\n        'id': DateTime.now().millisecondsSinceEpoch.toString(),\n        'title': title,\n        'content': content,\n        'createdAt': DateTime.now().toIso8601String(),\n      });\n    });\n  }\n\n  void _updateNote(String id, String title, String content) {\n    setState(() {\n      final index = _notes.indexWhere((n) => n['id'] == id);\n      if (index != -1) {\n        _notes[index] = {\n          ..._notes[index],\n          'title': title,\n          'content': content,\n        };\n      }\n    });\n  }\n\n  void _deleteNote(String id) {\n    setState(() {\n      _notes.removeWhere((n) => n['id'] == id);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('My Notes')),\n      body: _notes.isEmpty\n          ? const Center(child: Text('No notes yet'))\n          : ListView.builder(\n              itemCount: _notes.length,\n              itemBuilder: (context, index) {\n                final note = _notes[index];\n                return ListTile(\n                  title: Text(note['title'] ?? ''),\n                  subtitle: Text(note['content'] ?? ''),\n                  trailing: IconButton(\n                    icon: const Icon(Icons.delete),\n                    onPressed: () => _deleteNote(note['id']!),\n                  ),\n                );\n              },\n            ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => _showAddDialog(context),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n\n  void _showAddDialog(BuildContext context) {\n    final titleController = TextEditingController();\n    final contentController = TextEditingController();\n    showDialog(\n      context: context,\n      builder: (ctx) => AlertDialog(\n        title: const Text('New Note'),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            TextField(controller: titleController, decoration: const InputDecoration(labelText: 'Title')),\n            TextField(controller: contentController, decoration: const InputDecoration(labelText: 'Content')),\n          ],\n        ),\n        actions: [\n          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),\n          TextButton(\n            onPressed: () {\n              _addNote(titleController.text, contentController.text);\n              Navigator.pop(ctx);\n            },\n            child: const Text('Save'),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Step 1: Create the Model",
              "content": "First, extract a proper `Note` class. This gives us:\n\n### Benefits of a Proper Model\n\n1. **Type safety**: No more `Map<String, String>` with potential null issues\n2. **Immutability**: Cannot accidentally modify notes\n3. **copyWith method**: Easy updates while maintaining immutability\n4. **Clear structure**: Anyone reading the code knows what a Note contains\n5. **IDE support**: Autocomplete, refactoring, error checking\n\n### The Note Model",
              "code": "// models/note.dart\n\nclass Note {\n  final String id;\n  final String title;\n  final String content;\n  final DateTime createdAt;\n\n  const Note({\n    required this.id,\n    required this.title,\n    required this.content,\n    required this.createdAt,\n  });\n\n  // Factory constructor for creating new notes\n  factory Note.create({required String title, required String content}) {\n    return Note(\n      id: DateTime.now().millisecondsSinceEpoch.toString(),\n      title: title,\n      content: content,\n      createdAt: DateTime.now(),\n    );\n  }\n\n  // copyWith for immutable updates\n  Note copyWith({\n    String? id,\n    String? title,\n    String? content,\n    DateTime? createdAt,\n  }) {\n    return Note(\n      id: id ?? this.id,\n      title: title ?? this.title,\n      content: content ?? this.content,\n      createdAt: createdAt ?? this.createdAt,\n    );\n  }\n\n  @override\n  String toString() => 'Note(id: $id, title: $title)';\n\n  @override\n  bool operator ==(Object other) =>\n      identical(this, other) ||\n      other is Note &&\n          runtimeType == other.runtimeType &&\n          id == other.id &&\n          title == other.title &&\n          content == other.content &&\n          createdAt == other.createdAt;\n\n  @override\n  int get hashCode => Object.hash(id, title, content, createdAt);\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Step 2: Create the ViewModel",
              "content": "Next, move all business logic into a Riverpod ViewModel. This handles:\n\n### What the ViewModel Does\n\n1. **Holds state**: The list of notes lives here\n2. **Provides actions**: `addNote()`, `updateNote()`, `deleteNote()`\n3. **Encapsulates logic**: ID generation, validation, etc.\n4. **Enables testing**: Can test all logic without UI\n\n### The NotesViewModel",
              "code": "// viewmodels/notes_viewmodel.dart\n\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\nimport '../models/note.dart';\n\npart 'notes_viewmodel.g.dart';\n\n@riverpod\nclass NotesViewModel extends _$NotesViewModel {\n  @override\n  List<Note> build() {\n    // Initial state: empty list\n    // In a real app, you might load from a database here\n    return [];\n  }\n\n  /// Add a new note\n  void addNote({required String title, required String content}) {\n    // Validate input\n    if (title.trim().isEmpty) return;\n\n    // Create new note using factory\n    final note = Note.create(title: title.trim(), content: content.trim());\n\n    // Update state immutably\n    state = [...state, note];\n  }\n\n  /// Update an existing note\n  void updateNote({\n    required String id,\n    required String title,\n    required String content,\n  }) {\n    state = state.map((note) {\n      if (note.id == id) {\n        return note.copyWith(\n          title: title.trim(),\n          content: content.trim(),\n        );\n      }\n      return note;\n    }).toList();\n  }\n\n  /// Delete a note by ID\n  void deleteNote(String id) {\n    state = state.where((note) => note.id != id).toList();\n  }\n\n  /// Get a single note by ID (useful for detail screens)\n  Note? getNoteById(String id) {\n    try {\n      return state.firstWhere((note) => note.id == id);\n    } catch (e) {\n      return null;\n    }\n  }\n}\n\n// Generated code will create:\n// - notesViewModelProvider\n// - _$NotesViewModel base class",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Step 3: Create the View",
              "content": "Finally, clean up the UI. The View should ONLY handle:\n\n### What the View Does\n\n1. **Display data**: Shows the list of notes\n2. **Capture user input**: Text fields, buttons\n3. **Delegate actions**: Calls ViewModel methods\n4. **Navigation**: Dialogs, screens (if applicable)\n\n### What the View Does NOT Do\n\n- No business logic\n- No state management (except local UI state like text controllers)\n- No data transformation\n- No ID generation\n\n### The Clean NotesScreen",
              "code": "// views/notes_screen.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport '../models/note.dart';\nimport '../viewmodels/notes_viewmodel.dart';\n\nclass NotesScreen extends ConsumerWidget {\n  const NotesScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch the notes list - rebuilds when it changes\n    final notes = ref.watch(notesViewModelProvider);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('My Notes'),\n        actions: [\n          // Show note count\n          Center(\n            child: Padding(\n              padding: const EdgeInsets.only(right: 16),\n              child: Text('${notes.length} notes'),\n            ),\n          ),\n        ],\n      ),\n      body: notes.isEmpty\n          ? const _EmptyState()\n          : _NotesList(notes: notes),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => _showAddNoteDialog(context, ref),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n\n  void _showAddNoteDialog(BuildContext context, WidgetRef ref) {\n    final titleController = TextEditingController();\n    final contentController = TextEditingController();\n\n    showDialog(\n      context: context,\n      builder: (ctx) => AlertDialog(\n        title: const Text('New Note'),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            TextField(\n              controller: titleController,\n              decoration: const InputDecoration(labelText: 'Title'),\n              autofocus: true,\n            ),\n            const SizedBox(height: 8),\n            TextField(\n              controller: contentController,\n              decoration: const InputDecoration(labelText: 'Content'),\n              maxLines: 3,\n            ),\n          ],\n        ),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(ctx),\n            child: const Text('Cancel'),\n          ),\n          FilledButton(\n            onPressed: () {\n              // Delegate to ViewModel - no logic here!\n              ref.read(notesViewModelProvider.notifier).addNote(\n                    title: titleController.text,\n                    content: contentController.text,\n                  );\n              Navigator.pop(ctx);\n            },\n            child: const Text('Save'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Separate widget for empty state\nclass _EmptyState extends StatelessWidget {\n  const _EmptyState();\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Icon(Icons.note_outlined, size: 64, color: Colors.grey.shade400),\n          const SizedBox(height: 16),\n          Text(\n            'No notes yet',\n            style: Theme.of(context).textTheme.titleLarge?.copyWith(\n                  color: Colors.grey.shade600,\n                ),\n          ),\n          const SizedBox(height: 8),\n          Text(\n            'Tap + to add your first note',\n            style: TextStyle(color: Colors.grey.shade500),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Separate widget for notes list\nclass _NotesList extends ConsumerWidget {\n  final List<Note> notes;\n\n  const _NotesList({required this.notes});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return ListView.builder(\n      itemCount: notes.length,\n      itemBuilder: (context, index) {\n        final note = notes[index];\n        return _NoteCard(\n          note: note,\n          onDelete: () {\n            ref.read(notesViewModelProvider.notifier).deleteNote(note.id);\n          },\n        );\n      },\n    );\n  }\n}\n\n// Separate widget for individual note card\nclass _NoteCard extends StatelessWidget {\n  final Note note;\n  final VoidCallback onDelete;\n\n  const _NoteCard({required this.note, required this.onDelete});\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\n      child: ListTile(\n        title: Text(\n          note.title,\n          style: const TextStyle(fontWeight: FontWeight.bold),\n        ),\n        subtitle: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            if (note.content.isNotEmpty) Text(note.content),\n            const SizedBox(height: 4),\n            Text(\n              _formatDate(note.createdAt),\n              style: TextStyle(\n                fontSize: 12,\n                color: Colors.grey.shade500,\n              ),\n            ),\n          ],\n        ),\n        trailing: IconButton(\n          icon: const Icon(Icons.delete_outline),\n          onPressed: onDelete,\n        ),\n        isThreeLine: note.content.isNotEmpty,\n      ),\n    );\n  }\n\n  String _formatDate(DateTime date) {\n    return '${date.day}/${date.month}/${date.year}';\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "What We Achieved",
              "content": "### Before vs After\n\n| Aspect | Messy Version | Refactored Version |\n|--------|---------------|-------------------|\n| State location | Widget | ViewModel |\n| Data types | Map<String, String> | Note class |\n| Business logic | In UI class | In ViewModel |\n| Testability | Hard (widget tests) | Easy (unit tests) |\n| Reusability | None | High |\n| Team collaboration | Difficult | Easy |\n\n### The Clean Architecture\n\n```\n+------------------+\n|      VIEW        |  <- Only UI concerns\n|  NotesScreen     |  <- Watches state, delegates actions\n+------------------+\n        |\n        v\n+------------------+\n|   VIEWMODEL      |  <- Business logic\n| NotesViewModel   |  <- add, update, delete\n+------------------+\n        |\n        v\n+------------------+\n|     MODEL        |  <- Pure data\n|      Note        |  <- No logic, just properties\n+------------------+\n```\n\n### Key Benefits\n\n1. **Model (Note)**\n   - Pure data container\n   - Immutable with copyWith\n   - Type-safe, IDE-friendly\n   - Easy to serialize/deserialize\n\n2. **ViewModel (NotesViewModel)**\n   - All business logic in one place\n   - Can be unit tested without Flutter\n   - State shared across entire app\n   - Easy to add features (search, filter, sort)\n\n3. **View (NotesScreen)**\n   - Only handles UI rendering\n   - Delegates all actions to ViewModel\n   - Clean, readable, maintainable\n   - Easy to change UI without touching logic\n\n### What You Can Now Do Easily\n\n- **Add search**: Add a method to ViewModel, call from any screen\n- **Add persistence**: Modify ViewModel to save to database\n- **Add sync**: ViewModel can handle API calls\n- **Test everything**: Unit test ViewModel, widget test Views\n- **Share state**: Any screen can access notes via provider"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "5.10-challenge-1",
              "title": "Complete the Notes App Refactor",
              "description": "Refactor the messy Notes app into clean MVVM architecture with Riverpod. Transform the all-in-one StatefulWidget into separate Model, ViewModel, and View components.",
              "instructions": "You are given a messy Notes app where everything is crammed into one StatefulWidget. Your task is to refactor it into proper MVVM architecture:\n\n1. **Create the Note Model**:\n   - id (String)\n   - title (String)\n   - content (String)\n   - createdAt (DateTime)\n   - Factory constructor Note.create()\n   - copyWith() method\n\n2. **Create the NotesViewModel**:\n   - Use @riverpod annotation\n   - State is List<Note>\n   - addNote(title, content)\n   - updateNote(id, title, content)\n   - deleteNote(id)\n\n3. **Create the NotesScreen**:\n   - Extend ConsumerWidget\n   - Watch notesViewModelProvider\n   - Delegate all actions to ViewModel\n   - No business logic in the widget\n\n4. **Requirements**:\n   - Empty state when no notes\n   - Add note via dialog\n   - Delete note via icon button\n   - Display note title, content, and date",
              "starterCode": "// STARTER CODE: The Messy Notes App\n// Your task: Refactor this into clean MVVM architecture\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\n// TODO: Add 'part' directive for generated code\n// part 'main.g.dart';\n\nvoid main() {\n  runApp(const ProviderScope(child: MaterialApp(home: NotesScreen())));\n}\n\n// ============================================\n// TODO 1: Create the Note Model\n// ============================================\n// class Note {\n//   final String id;\n//   final String title;\n//   final String content;\n//   final DateTime createdAt;\n//\n//   const Note({...});\n//\n//   factory Note.create({required String title, required String content}) {...}\n//\n//   Note copyWith({...}) {...}\n// }\n\n// ============================================\n// TODO 2: Create the NotesViewModel\n// ============================================\n// @riverpod\n// class NotesViewModel extends _$NotesViewModel {\n//   @override\n//   List<Note> build() => [];\n//\n//   void addNote({required String title, required String content}) {...}\n//   void updateNote({required String id, required String title, required String content}) {...}\n//   void deleteNote(String id) {...}\n// }\n\n// ============================================\n// TODO 3: Refactor this Messy Widget into a Clean ConsumerWidget\n// ============================================\n\n// THIS IS THE MESSY CODE - REFACTOR IT!\nclass NotesScreen extends StatefulWidget {\n  const NotesScreen({super.key});\n\n  @override\n  State<NotesScreen> createState() => _NotesScreenState();\n}\n\nclass _NotesScreenState extends State<NotesScreen> {\n  // Problem: State in widget\n  final List<Map<String, String>> _notes = [];\n\n  // Problem: Business logic in widget\n  void _addNote(String title, String content) {\n    setState(() {\n      _notes.add({\n        'id': DateTime.now().millisecondsSinceEpoch.toString(),\n        'title': title,\n        'content': content,\n        'createdAt': DateTime.now().toIso8601String(),\n      });\n    });\n  }\n\n  void _deleteNote(String id) {\n    setState(() {\n      _notes.removeWhere((n) => n['id'] == id);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('My Notes')),\n      body: _notes.isEmpty\n          ? const Center(child: Text('No notes yet'))\n          : ListView.builder(\n              itemCount: _notes.length,\n              itemBuilder: (context, index) {\n                final note = _notes[index];\n                return ListTile(\n                  title: Text(note['title'] ?? ''),\n                  subtitle: Text(note['content'] ?? ''),\n                  trailing: IconButton(\n                    icon: const Icon(Icons.delete),\n                    onPressed: () => _deleteNote(note['id']!),\n                  ),\n                );\n              },\n            ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => _showAddDialog(context),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n\n  void _showAddDialog(BuildContext context) {\n    final titleController = TextEditingController();\n    final contentController = TextEditingController();\n    showDialog(\n      context: context,\n      builder: (ctx) => AlertDialog(\n        title: const Text('New Note'),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            TextField(controller: titleController, decoration: const InputDecoration(labelText: 'Title')),\n            TextField(controller: contentController, decoration: const InputDecoration(labelText: 'Content')),\n          ],\n        ),\n        actions: [\n          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),\n          TextButton(\n            onPressed: () {\n              _addNote(titleController.text, contentController.text);\n              Navigator.pop(ctx);\n            },\n            child: const Text('Save'),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "solution": "// SOLUTION: Clean MVVM Notes App with Riverpod\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'main.g.dart';\n\nvoid main() {\n  runApp(const ProviderScope(child: MaterialApp(home: NotesScreen())));\n}\n\n// ============================================\n// MODEL: Pure data class\n// ============================================\n\nclass Note {\n  final String id;\n  final String title;\n  final String content;\n  final DateTime createdAt;\n\n  const Note({\n    required this.id,\n    required this.title,\n    required this.content,\n    required this.createdAt,\n  });\n\n  /// Factory for creating new notes with auto-generated ID\n  factory Note.create({required String title, required String content}) {\n    return Note(\n      id: DateTime.now().millisecondsSinceEpoch.toString(),\n      title: title,\n      content: content,\n      createdAt: DateTime.now(),\n    );\n  }\n\n  /// Immutable update via copyWith\n  Note copyWith({\n    String? id,\n    String? title,\n    String? content,\n    DateTime? createdAt,\n  }) {\n    return Note(\n      id: id ?? this.id,\n      title: title ?? this.title,\n      content: content ?? this.content,\n      createdAt: createdAt ?? this.createdAt,\n    );\n  }\n}\n\n// ============================================\n// VIEWMODEL: Business logic with Riverpod\n// ============================================\n\n@riverpod\nclass NotesViewModel extends _$NotesViewModel {\n  @override\n  List<Note> build() {\n    // Initial state: empty list\n    return [];\n  }\n\n  /// Add a new note\n  void addNote({required String title, required String content}) {\n    if (title.trim().isEmpty) return;\n\n    final note = Note.create(\n      title: title.trim(),\n      content: content.trim(),\n    );\n\n    state = [...state, note];\n  }\n\n  /// Update an existing note\n  void updateNote({\n    required String id,\n    required String title,\n    required String content,\n  }) {\n    state = state.map((note) {\n      if (note.id == id) {\n        return note.copyWith(\n          title: title.trim(),\n          content: content.trim(),\n        );\n      }\n      return note;\n    }).toList();\n  }\n\n  /// Delete a note by ID\n  void deleteNote(String id) {\n    state = state.where((note) => note.id != id).toList();\n  }\n}\n\n// ============================================\n// VIEW: Clean UI with ConsumerWidget\n// ============================================\n\nclass NotesScreen extends ConsumerWidget {\n  const NotesScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Watch state - rebuilds when notes change\n    final notes = ref.watch(notesViewModelProvider);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('My Notes'),\n        actions: [\n          Center(\n            child: Padding(\n              padding: const EdgeInsets.only(right: 16),\n              child: Text('${notes.length} notes'),\n            ),\n          ),\n        ],\n      ),\n      body: notes.isEmpty\n          ? _buildEmptyState(context)\n          : _buildNotesList(notes, ref),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => _showAddDialog(context, ref),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n\n  Widget _buildEmptyState(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Icon(Icons.note_outlined, size: 64, color: Colors.grey.shade400),\n          const SizedBox(height: 16),\n          Text(\n            'No notes yet',\n            style: Theme.of(context).textTheme.titleLarge?.copyWith(\n                  color: Colors.grey.shade600,\n                ),\n          ),\n          const SizedBox(height: 8),\n          Text(\n            'Tap + to add your first note',\n            style: TextStyle(color: Colors.grey.shade500),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildNotesList(List<Note> notes, WidgetRef ref) {\n    return ListView.builder(\n      itemCount: notes.length,\n      itemBuilder: (context, index) {\n        final note = notes[index];\n        return Card(\n          margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\n          child: ListTile(\n            title: Text(\n              note.title,\n              style: const TextStyle(fontWeight: FontWeight.bold),\n            ),\n            subtitle: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                if (note.content.isNotEmpty) Text(note.content),\n                const SizedBox(height: 4),\n                Text(\n                  '${note.createdAt.day}/${note.createdAt.month}/${note.createdAt.year}',\n                  style: TextStyle(fontSize: 12, color: Colors.grey.shade500),\n                ),\n              ],\n            ),\n            trailing: IconButton(\n              icon: const Icon(Icons.delete_outline),\n              onPressed: () {\n                // Delegate to ViewModel - no logic here!\n                ref.read(notesViewModelProvider.notifier).deleteNote(note.id);\n              },\n            ),\n            isThreeLine: note.content.isNotEmpty,\n          ),\n        );\n      },\n    );\n  }\n\n  void _showAddDialog(BuildContext context, WidgetRef ref) {\n    final titleController = TextEditingController();\n    final contentController = TextEditingController();\n\n    showDialog(\n      context: context,\n      builder: (ctx) => AlertDialog(\n        title: const Text('New Note'),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            TextField(\n              controller: titleController,\n              decoration: const InputDecoration(labelText: 'Title'),\n              autofocus: true,\n            ),\n            const SizedBox(height: 8),\n            TextField(\n              controller: contentController,\n              decoration: const InputDecoration(labelText: 'Content'),\n              maxLines: 3,\n            ),\n          ],\n        ),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(ctx),\n            child: const Text('Cancel'),\n          ),\n          FilledButton(\n            onPressed: () {\n              // Delegate to ViewModel!\n              ref.read(notesViewModelProvider.notifier).addNote(\n                    title: titleController.text,\n                    content: contentController.text,\n                  );\n              Navigator.pop(ctx);\n            },\n            child: const Text('Save'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// ============================================\n// KEY ACHIEVEMENTS:\n// ============================================\n//\n// 1. MODEL (Note):\n//    - Pure data class with type safety\n//    - Immutable with copyWith\n//    - Factory constructor for creation\n//\n// 2. VIEWMODEL (NotesViewModel):\n//    - All business logic centralized\n//    - State management via Riverpod\n//    - Easy to test with unit tests\n//\n// 3. VIEW (NotesScreen):\n//    - Only handles UI rendering\n//    - Delegates all actions to ViewModel\n//    - Clean, readable, maintainable\n//\n// BENEFITS:\n// - Each piece can be tested separately\n// - Easy to add features (search, edit, persist)\n// - Teams can work on different layers\n// - State is shared across the entire app",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-model",
                  "description": "Note class has id, title, content, createdAt properties",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-model-factory",
                  "description": "Note.create() factory generates ID and timestamp automatically",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-model-copywith",
                  "description": "Note has copyWith() method for immutable updates",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-viewmodel",
                  "description": "NotesViewModel uses @riverpod and has List<Note> state",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-viewmodel-add",
                  "description": "addNote() creates and adds a new note to state",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-viewmodel-delete",
                  "description": "deleteNote() removes note from state by ID",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-view-consumer",
                  "description": "NotesScreen extends ConsumerWidget",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-view-watch",
                  "description": "View uses ref.watch() to observe notes",
                  "expectedOutput": "",
                  "isVisible": true
                },
                {
                  "id": "test-view-delegate",
                  "description": "View delegates actions to ViewModel via ref.read().notifier",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with the Note model. It needs four properties: id, title, content, and createdAt. Make them all final for immutability."
                },
                {
                  "level": 2,
                  "text": "For Note.create(), generate the ID using DateTime.now().millisecondsSinceEpoch.toString() and set createdAt to DateTime.now()."
                },
                {
                  "level": 3,
                  "text": "In NotesViewModel, state is List<Note>. For addNote, use: state = [...state, newNote]. For deleteNote, use: state = state.where((n) => n.id != id).toList()."
                },
                {
                  "level": 4,
                  "text": "Change StatefulWidget to ConsumerWidget. Replace _notes with ref.watch(notesViewModelProvider). Replace _addNote with ref.read(notesViewModelProvider.notifier).addNote()."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Mutating state directly: state.add(note) instead of state = [...state, note]",
                  "consequence": "Riverpod won't detect the change and UI won't update",
                  "correction": "Always create a new list: state = [...state, note] or state = state.where(...).toList()"
                },
                {
                  "mistake": "Using ref.watch() inside the onPressed callback",
                  "consequence": "Creates unnecessary subscriptions and potential bugs",
                  "correction": "Use ref.read() inside callbacks: ref.read(provider.notifier).method()"
                },
                {
                  "mistake": "Keeping business logic in the View (like validation or ID generation)",
                  "consequence": "Defeats the purpose of MVVM - logic cannot be tested independently",
                  "correction": "Move all logic to ViewModel. View should only call ViewModel methods with raw user input."
                },
                {
                  "mistake": "Forgetting to make Note immutable (using var instead of final)",
                  "consequence": "Can accidentally mutate notes, causing state bugs",
                  "correction": "Use final for all Note properties and provide copyWith() for updates"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-06",
      "title": "Module 6: Flutter Development",
      "description": "Learn Flutter development - Module 6",
      "difficulty": "intermediate",
      "estimatedHours": 8,
      "lessons": [
        {
          "id": "6.1",
          "title": "Module 6, Lesson 1: Basic Navigation",
          "moduleId": "module-06",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Multi-Screen Problem",
              "content": "\nSo far, all your apps have been single-screen. But real apps need **multiple screens**:\n- Home ‚Üí Detail ‚Üí Settings\n- Login ‚Üí Dashboard ‚Üí Profile\n- List ‚Üí Edit ‚Üí Confirm\n\n**How do you move between screens in Flutter?**\n\n**Navigator** is the answer!\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Think of Navigation as a Stack of Cards",
              "content": "\nImagine a deck of cards:\n- **Push**: Add a card on top (new screen covers current)\n- **Pop**: Remove top card (go back to previous screen)\n\n\nThis is called a **navigation stack**!\n\n",
              "code": "[Home Screen]\n[Home Screen] ‚Üí Push ‚Üí [Home Screen, Detail Screen]\n[Home Screen, Detail Screen] ‚Üí Pop ‚Üí [Home Screen]",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Understanding Navigator.push",
              "content": "\n\n**MaterialPageRoute** creates a platform-specific transition:\n- **iOS**: Slide from right\n- **Android**: Slide up\n\n",
              "code": "Navigator.push(\n  context,                                      // Where we are\n  MaterialPageRoute(builder: (context) => DetailScreen()),  // Where we're going\n);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Understanding Navigator.pop",
              "content": "\n\nRemoves the top screen from the stack and returns to the previous one.\n\n**Automatic back button**: Android phones and iOS get a back arrow automatically! You only need `Navigator.pop()` for custom buttons.\n\n",
              "code": "Navigator.pop(context);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Passing Data to New Screen",
              "content": "\nPass data via constructor:\n\n\n",
              "code": "class DetailScreen extends StatelessWidget {\n  final String title;\n  final int id;\n\n  DetailScreen({required this.title, required this.id});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text(title)),\n      body: Center(\n        child: Text('Item ID: $id', style: TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}\n\n// Navigate with data\nElevatedButton(\n  onPressed: () {\n    Navigator.push(\n      context,\n      MaterialPageRoute(\n        builder: (context) => DetailScreen(\n          title: 'Product Detail',\n          id: 42,\n        ),\n      ),\n    );\n  },\n  child: Text('View Product'),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Receiving Data Back from Screen",
              "content": "\nUse `await` with `Navigator.push`:\n\n\n**Pattern**: `Navigator.pop(context, dataToReturn)`\n\n",
              "code": "// Screen 1: Get result from Screen 2\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Home')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () async {\n            // Wait for result\n            final result = await Navigator.push(\n              context,\n              MaterialPageRoute(builder: (context) => SelectColorScreen()),\n            );\n\n            if (result != null) {\n              ScaffoldMessenger.of(context).showSnackBar(\n                SnackBar(content: Text('Selected: $result')),\n              );\n            }\n          },\n          child: Text('Select Color'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 2: Return result\nclass SelectColorScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Select Color')),\n      body: Column(\n        children: [\n          ListTile(\n            leading: CircleAvatar(backgroundColor: Colors.red),\n            title: Text('Red'),\n            onTap: () {\n              Navigator.pop(context, 'Red');  // Return data!\n            },\n          ),\n          ListTile(\n            leading: CircleAvatar(backgroundColor: Colors.blue),\n            title: Text('Blue'),\n            onTap: () {\n              Navigator.pop(context, 'Blue');\n            },\n          ),\n          ListTile(\n            leading: CircleAvatar(backgroundColor: Colors.green),\n            title: Text('Green'),\n            onTap: () {\n              Navigator.pop(context, 'Green');\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Custom Page Transitions",
              "content": "\nChange how screens transition:\n\n\n",
              "code": "// Fade transition\nNavigator.push(\n  context,\n  PageRouteBuilder(\n    pageBuilder: (context, animation, secondaryAnimation) => DetailScreen(),\n    transitionsBuilder: (context, animation, secondaryAnimation, child) {\n      return FadeTransition(\n        opacity: animation,\n        child: child,\n      );\n    },\n  ),\n);\n\n// Scale transition\nNavigator.push(\n  context,\n  PageRouteBuilder(\n    pageBuilder: (context, animation, secondaryAnimation) => DetailScreen(),\n    transitionsBuilder: (context, animation, secondaryAnimation, child) {\n      return ScaleTransition(\n        scale: animation,\n        child: child,\n      );\n    },\n  ),\n);\n\n// Slide from bottom\nNavigator.push(\n  context,\n  PageRouteBuilder(\n    pageBuilder: (context, animation, secondaryAnimation) => DetailScreen(),\n    transitionsBuilder: (context, animation, secondaryAnimation, child) {\n      const begin = Offset(0.0, 1.0);\n      const end = Offset.zero;\n      final tween = Tween(begin: begin, end: end);\n      final offsetAnimation = animation.drive(tween);\n\n      return SlideTransition(\n        position: offsetAnimation,\n        child: child,\n      );\n    },\n  ),\n);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Replacing Current Screen",
              "content": "\n\n**Use case**: Login ‚Üí Home (don't want back button to go to login)\n\n",
              "code": "// Go to new screen and remove current from stack\nNavigator.pushReplacement(\n  context,\n  MaterialPageRoute(builder: (context) => HomeScreen()),\n);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Removing All Previous Screens",
              "content": "\n\n**Use case**: Logout ‚Üí Login (clear all app screens)\n\n",
              "code": "// Clear entire stack and go to new screen\nNavigator.pushAndRemoveUntil(\n  context,\n  MaterialPageRoute(builder: (context) => HomeScreen()),\n  (route) => false,  // Remove all previous routes\n);",
              "language": "dart"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Forgetting `context`\n\n‚úÖ **Fix**: Always pass context\n\n‚ùå **Mistake 2**: Not using `await` when expecting result\n\n‚úÖ **Fix**: Use await\n\n",
              "code": "final result = await Navigator.push(context, MaterialPageRoute(...));",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Navigator as a stack of screens\n- ‚úÖ Navigator.push to go forward\n- ‚úÖ Navigator.pop to go back\n- ‚úÖ Passing data TO screens (constructor)\n- ‚úÖ Receiving data FROM screens (await + pop)\n- ‚úÖ Custom page transitions\n- ‚úÖ pushReplacement and pushAndRemoveUntil\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nBasic navigation works, but gets messy for large apps. Next: **Named Routes** - organize navigation with string identifiers!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.1-challenge-0",
              "title": "Custom Page Transition Challenge",
              "description": "Create a custom page transition that slides in from the left instead of the default right.",
              "instructions": "Build a custom PageRouteBuilder that makes the new screen slide in from the left. Use SlideTransition with Offset(-1.0, 0.0) as the starting position. Create a reusable route class that can be used with Navigator.push().",
              "starterCode": "// Custom Page Transition Challenge\n// Make a screen slide in from the left\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const TransitionApp());\n}\n\nclass TransitionApp extends StatelessWidget {\n  const TransitionApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: const HomeScreen(),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // TODO 1: Use Navigator.push with SlideFromLeftRoute\n            Navigator.push(\n              context,\n              SlideFromLeftRoute(page: const DetailScreen()),\n            );\n          },\n          child: const Text('Open Detail (Slide from Left)'),\n        ),\n      ),\n    );\n  }\n}\n\nclass DetailScreen extends StatelessWidget {\n  const DetailScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Detail')),\n      body: const Center(\n        child: Text('This screen slid in from the left!'),\n      ),\n    );\n  }\n}\n\n// TODO 2: Create SlideFromLeftRoute extending PageRouteBuilder\nclass SlideFromLeftRoute extends PageRouteBuilder {\n  final Widget page;\n\n  SlideFromLeftRoute({required this.page})\n      : super(\n          pageBuilder: (context, animation, secondaryAnimation) => page,\n          transitionsBuilder: (context, animation, secondaryAnimation, child) {\n            // TODO 3: Define the slide animation\n            // begin: Offset(-1.0, 0.0) = starts off-screen left\n            // end: Offset.zero = ends at center\n            const begin = Offset(-1.0, 0.0);\n            const end = Offset.zero;\n            const curve = Curves.easeInOut;\n\n            final tween = Tween(begin: begin, end: end).chain(\n              CurveTween(curve: curve),\n            );\n\n            // TODO 4: Return SlideTransition with the animation\n            return SlideTransition(\n              position: animation.drive(tween),\n              child: child,\n            );\n          },\n          transitionDuration: const Duration(milliseconds: 300),\n        );\n}",
              "solution": "// Solution: Custom Page Transition - Slide from Left\n// Uses PageRouteBuilder with custom SlideTransition\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const TransitionApp());\n}\n\nclass TransitionApp extends StatelessWidget {\n  const TransitionApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: const HomeScreen(),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.push(\n              context,\n              SlideFromLeftRoute(page: const DetailScreen()),\n            );\n          },\n          child: const Text('Open Detail (Slide from Left)'),\n        ),\n      ),\n    );\n  }\n}\n\nclass DetailScreen extends StatelessWidget {\n  const DetailScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Detail')),\n      body: const Center(\n        child: Text('This screen slid in from the left!'),\n      ),\n    );\n  }\n}\n\n// Custom route that slides from left\nclass SlideFromLeftRoute extends PageRouteBuilder {\n  final Widget page;\n\n  SlideFromLeftRoute({required this.page})\n      : super(\n          pageBuilder: (context, animation, secondaryAnimation) => page,\n          transitionsBuilder: (context, animation, secondaryAnimation, child) {\n            // Slide from left: start at -1.0 (off-screen left), end at 0.0 (center)\n            const begin = Offset(-1.0, 0.0);\n            const end = Offset.zero;\n            const curve = Curves.easeInOut;\n\n            final tween = Tween(begin: begin, end: end).chain(\n              CurveTween(curve: curve),\n            );\n\n            return SlideTransition(\n              position: animation.drive(tween),\n              child: child,\n            );\n          },\n          transitionDuration: const Duration(milliseconds: 300),\n        );\n}\n\n// Alternative: Reusable function\nRoute slideFromLeftRoute(Widget page) {\n  return PageRouteBuilder(\n    pageBuilder: (_, __, ___) => page,\n    transitionsBuilder: (_, animation, __, child) {\n      return SlideTransition(\n        position: Tween<Offset>(\n          begin: const Offset(-1.0, 0.0),\n          end: Offset.zero,\n        ).animate(CurvedAnimation(\n          parent: animation,\n          curve: Curves.easeInOut,\n        )),\n        child: child,\n      );\n    },\n  );\n}\n\n// Key concepts:\n// - PageRouteBuilder: Custom route with transitions\n// - SlideTransition: Animates position with Offset\n// - Offset(-1.0, 0): Left of screen\n// - Offset(1.0, 0): Right of screen\n// - Offset(0, -1.0): Top of screen\n// - Tween + CurveTween: Smooth animation curve",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.2",
          "title": "Module 6, Lesson 2: Named Routes",
          "moduleId": "module-06",
          "order": 2,
          "estimatedMinutes": 55,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Problem with Basic Navigation",
              "content": "\nWith basic navigation, you write this EVERYWHERE:\n\n\n**Problems:**\n- Repetitive code\n- Hard to change transitions\n- No central route management\n- Typos cause runtime errors\n\n**Solution: Named Routes!**\n\n",
              "code": "Navigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => ProductDetail(product: product)),\n);\n\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => UserProfile(userId: userId)),\n);\n\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SettingsScreen()),\n);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What are Named Routes?",
              "content": "\nInstead of creating MaterialPageRoute everywhere, define routes with string names:\n\n\nThen navigate with strings:\n\n\n",
              "code": "Navigator.pushNamed(context, '/detail');\nNavigator.pushNamed(context, '/profile');",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Passing Arguments",
              "content": "\n### Method 1: Via Navigator\n\n\n### Method 2: Type-Safe Arguments\n\n\n**Much safer!** Type errors caught at compile time.\n\n",
              "code": "// Define argument class\nclass ProductDetailArguments {\n  final int productId;\n  final String name;\n\n  ProductDetailArguments({required this.productId, required this.name});\n}\n\n// Navigate\nNavigator.pushNamed(\n  context,\n  '/detail',\n  arguments: ProductDetailArguments(productId: 123, name: 'Laptop'),\n);\n\n// Receive\nclass DetailScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final args = ModalRoute.of(context)!.settings.arguments as ProductDetailArguments;\n\n    return Scaffold(\n      appBar: AppBar(title: Text(args.name)),\n      body: Center(child: Text('Product ID: ${args.productId}')),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "onGenerateRoute (Advanced)",
              "content": "\nFor dynamic routes or custom logic:\n\n\n",
              "code": "MaterialApp(\n  onGenerateRoute: (settings) {\n    // Handle /product/:id\n    if (settings.name?.startsWith('/product/') == true) {\n      final productId = settings.name!.split('/').last;\n\n      return MaterialPageRoute(\n        builder: (context) => ProductDetailScreen(productId: productId),\n      );\n    }\n\n    // Handle /user/:username\n    if (settings.name?.startsWith('/user/') == true) {\n      final username = settings.name!.split('/').last;\n\n      return MaterialPageRoute(\n        builder: (context) => UserProfileScreen(username: username),\n      );\n    }\n\n    // Default route\n    return MaterialPageRoute(builder: (context) => HomeScreen());\n  },\n);\n\n// Navigate\nNavigator.pushNamed(context, '/product/123');\nNavigator.pushNamed(context, '/user/john_doe');",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "onUnknownRoute (404 Handler)",
              "content": "\nHandle invalid routes gracefully:\n\n\n",
              "code": "MaterialApp(\n  routes: {\n    '/': (context) => HomeScreen(),\n    '/about': (context) => AboutScreen(),\n  },\n  onUnknownRoute: (settings) {\n    return MaterialPageRoute(\n      builder: (context) => NotFoundScreen(routeName: settings.name),\n    );\n  },\n);\n\nclass NotFoundScreen extends StatelessWidget {\n  final String? routeName;\n\n  NotFoundScreen({this.routeName});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('404')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(Icons.error_outline, size: 100, color: Colors.red),\n            SizedBox(height: 16),\n            Text('Page Not Found', style: TextStyle(fontSize: 24)),\n            if (routeName != null)\n              Text('Route: $routeName', style: TextStyle(color: Colors.grey)),\n            SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: () => Navigator.pushNamedAndRemoveUntil(context, '/', (route) => false),\n              child: Text('Go Home'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Route Constants (Best Practice)",
              "content": "\nAvoid typos with constants:\n\n\n**Benefits:**\n- Autocomplete works\n- Refactoring is easy\n- Typos caught at compile time\n\n",
              "code": "// routes.dart\nclass AppRoutes {\n  static const String home = '/';\n  static const String products = '/products';\n  static const String productDetail = '/product-detail';\n  static const String cart = '/cart';\n  static const String checkout = '/checkout';\n  static const String profile = '/profile';\n  static const String settings = '/settings';\n}\n\n// main.dart\nMaterialApp(\n  routes: {\n    AppRoutes.home: (context) => HomeScreen(),\n    AppRoutes.products: (context) => ProductsScreen(),\n    AppRoutes.productDetail: (context) => ProductDetailScreen(),\n    AppRoutes.cart: (context) => CartScreen(),\n    AppRoutes.checkout: (context) => CheckoutScreen(),\n  },\n);\n\n// Usage\nNavigator.pushNamed(context, AppRoutes.productDetail);\nNavigator.pushNamed(context, AppRoutes.cart);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Named Routes vs Basic Navigation",
              "content": "\n| Feature | Basic Navigation | Named Routes |\n|---------|------------------|--------------|\n| **Setup** | None | Define routes upfront |\n| **Navigate** | `Navigator.push(MaterialPageRoute(...))` | `Navigator.pushNamed('/route')` |\n| **Arguments** | Constructor params | `arguments` parameter |\n| **Type Safety** | ‚úì Compile-time | Runtime (unless using constants) |\n| **Centralized** | ‚úó No | ‚úì Yes |\n| **Best For** | Small apps | Medium-large apps |\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Named routes for organized navigation\n- ‚úÖ Setting up routes in MaterialApp\n- ‚úÖ pushNamed, pushReplacementNamed, pushNamedAndRemoveUntil\n- ‚úÖ Passing arguments with named routes\n- ‚úÖ Type-safe argument classes\n- ‚úÖ onGenerateRoute for dynamic routes\n- ‚úÖ onUnknownRoute for 404 handling\n- ‚úÖ Route constants for safety\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nNamed routes are great, but there's an even more powerful way: **Navigation 2.0 (Router API)** - declarative navigation with deep linking support!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.2-challenge-0",
              "title": "Dynamic Routes Challenge",
              "description": "Implement dynamic routing with onGenerateRoute to handle /post/:id and /category/:slug patterns.",
              "instructions": "Use MaterialApp's onGenerateRoute to parse dynamic route paths. Handle /post/:id to show a PostScreen with the post ID, and /category/:slug to show a CategoryScreen with the category slug. Include a 404 NotFoundScreen for unknown routes.",
              "starterCode": "// Dynamic Routes Challenge\n// Handle /post/:id and /category/:slug with onGenerateRoute\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const DynamicRoutesApp());\n}\n\nclass DynamicRoutesApp extends StatelessWidget {\n  const DynamicRoutesApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      initialRoute: '/',\n      // TODO 1: Implement onGenerateRoute\n      onGenerateRoute: (settings) {\n        final uri = Uri.parse(settings.name ?? '/');\n        final pathSegments = uri.pathSegments;\n\n        // Home route\n        if (pathSegments.isEmpty) {\n          return MaterialPageRoute(builder: (_) => const HomeScreen());\n        }\n\n        // TODO 2: Handle /post/:id pattern\n        // Check if pathSegments.length == 2 && pathSegments[0] == 'post'\n        // Extract postId = pathSegments[1]\n        // Return MaterialPageRoute with PostScreen(postId: postId)\n\n        // TODO 3: Handle /category/:slug pattern\n        // Similar to above but for CategoryScreen\n\n        // TODO 4: Return NotFoundScreen for unknown routes\n        return MaterialPageRoute(\n          builder: (_) => const NotFoundScreen(),\n        );\n      },\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            ElevatedButton(\n              onPressed: () => Navigator.pushNamed(context, '/post/123'),\n              child: const Text('View Post 123'),\n            ),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              onPressed: () => Navigator.pushNamed(context, '/category/flutter'),\n              child: const Text('Flutter Category'),\n            ),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              onPressed: () => Navigator.pushNamed(context, '/unknown'),\n              child: const Text('Unknown Route (404)'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass PostScreen extends StatelessWidget {\n  final String postId;\n  const PostScreen({super.key, required this.postId});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Post \\$postId')),\n      body: Center(\n        child: Text('Viewing post with ID: \\$postId', style: const TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}\n\nclass CategoryScreen extends StatelessWidget {\n  final String slug;\n  const CategoryScreen({super.key, required this.slug});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Category: \\$slug')),\n      body: Center(\n        child: Text('Viewing category: \\$slug', style: const TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}\n\nclass NotFoundScreen extends StatelessWidget {\n  const NotFoundScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('404')),\n      body: const Center(\n        child: Text('Page Not Found', style: TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}",
              "solution": "// Solution: Dynamic Routes with onGenerateRoute\n// Handles /post/:id and /category/:slug patterns\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const DynamicRoutesApp());\n}\n\nclass DynamicRoutesApp extends StatelessWidget {\n  const DynamicRoutesApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      initialRoute: '/',\n      onGenerateRoute: (settings) {\n        final uri = Uri.parse(settings.name ?? '/');\n        final pathSegments = uri.pathSegments;\n\n        // Home route\n        if (pathSegments.isEmpty) {\n          return MaterialPageRoute(builder: (_) => const HomeScreen());\n        }\n\n        // /post/:id route\n        if (pathSegments.length == 2 && pathSegments[0] == 'post') {\n          final postId = pathSegments[1];\n          return MaterialPageRoute(\n            builder: (_) => PostScreen(postId: postId),\n            settings: settings,\n          );\n        }\n\n        // /category/:slug route\n        if (pathSegments.length == 2 && pathSegments[0] == 'category') {\n          final slug = pathSegments[1];\n          return MaterialPageRoute(\n            builder: (_) => CategoryScreen(slug: slug),\n            settings: settings,\n          );\n        }\n\n        // 404 - Not Found\n        return MaterialPageRoute(\n          builder: (_) => const NotFoundScreen(),\n        );\n      },\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            ElevatedButton(\n              onPressed: () => Navigator.pushNamed(context, '/post/123'),\n              child: const Text('View Post 123'),\n            ),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              onPressed: () => Navigator.pushNamed(context, '/post/456'),\n              child: const Text('View Post 456'),\n            ),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              onPressed: () => Navigator.pushNamed(context, '/category/flutter'),\n              child: const Text('Flutter Category'),\n            ),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              onPressed: () => Navigator.pushNamed(context, '/category/dart'),\n              child: const Text('Dart Category'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass PostScreen extends StatelessWidget {\n  final String postId;\n  const PostScreen({super.key, required this.postId});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Post $postId')),\n      body: Center(\n        child: Text('Viewing post with ID: $postId', style: const TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}\n\nclass CategoryScreen extends StatelessWidget {\n  final String slug;\n  const CategoryScreen({super.key, required this.slug});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Category: $slug')),\n      body: Center(\n        child: Text('Viewing category: $slug', style: const TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}\n\nclass NotFoundScreen extends StatelessWidget {\n  const NotFoundScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('404')),\n      body: const Center(\n        child: Text('Page Not Found', style: TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - onGenerateRoute: Handles dynamic route matching\n// - Uri.parse: Parses route path into segments\n// - pathSegments: Array of path parts\n// - Pattern matching: Check path structure\n// - Fallback: 404 screen for unknown routes",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.3",
          "title": "Module 6, Lesson 3: Modern Navigation with GoRouter",
          "moduleId": "module-06",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Evolution of Navigation",
              "content": "\nYou've learned two navigation approaches:\n1. **Basic Navigation**: `Navigator.push(MaterialPageRoute(...))`\n2. **Named Routes**: `Navigator.pushNamed('/route')`\n\nBoth work, but they're **imperative** - you tell Flutter exactly what to do, step by step.\n\n**Problem with imperative navigation:**\n- Hard to handle deep links (`myapp://product/123`)\n- Hard to sync URL bar on web\n- Hard to manage complex navigation state\n- Difficult to test\n\n**Solution: Declarative Navigation with GoRouter!**\n\nThink of it like building with LEGO blocks:\n- **Imperative**: \"Take this block, put it here, now take that block...\"\n- **Declarative**: \"Here's the blueprint, you build it!\"\n\n"
            },
            {
              "type": "THEORY",
              "title": "What is GoRouter?",
              "content": "\n**GoRouter** is Flutter's official modern routing solution:\n- Built on Navigation 2.0 API\n- URL-based navigation\n- Deep linking support out of the box\n- Type-safe routes\n- Web-friendly (URL bar works!)\n- Maintained by Flutter team\n\n**Current version**: 17.0.0 (Flutter 3.29+, Dart 3.7+)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Installation",
              "content": "\n\nRun: `flutter pub get`\n\n",
              "code": "# pubspec.yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  go_router: ^17.0.0",
              "language": "yaml"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First GoRouter",
              "content": "\n\n**Key differences:**\n- Use `MaterialApp.router` instead of `MaterialApp`\n- Pass `routerConfig` instead of `routes`\n- Navigate with `context.go('/path')` instead of `Navigator.pushNamed`\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:go_router/go_router.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  // Define router\n  final GoRouter _router = GoRouter(\n    routes: [\n      GoRoute(\n        path: '/',\n        builder: (context, state) => HomeScreen(),\n      ),\n      GoRoute(\n        path: '/details',\n        builder: (context, state) => DetailsScreen(),\n      ),\n    ],\n  );\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      routerConfig: _router,  // Use router config!\n      title: 'GoRouter Demo',\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Home')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate with go()\n            context.go('/details');\n          },\n          child: Text('Go to Details'),\n        ),\n      ),\n    );\n  }\n}\n\nclass DetailsScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Details')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Go back\n            context.go('/');\n          },\n          child: Text('Back to Home'),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Path Parameters (Dynamic Routes)",
              "content": "\nHandle URLs like `/user/123` or `/product/456`:\n\n\n",
              "code": "final router = GoRouter(\n  routes: [\n    GoRoute(\n      path: '/',\n      builder: (context, state) => HomeScreen(),\n    ),\n    GoRoute(\n      path: '/user/:userId',  // :userId is a path parameter\n      builder: (context, state) {\n        final userId = state.pathParameters['userId']!;\n        return UserScreen(userId: userId);\n      },\n    ),\n    GoRoute(\n      path: '/product/:productId',\n      builder: (context, state) {\n        final productId = state.pathParameters['productId']!;\n        return ProductScreen(productId: productId);\n      },\n    ),\n  ],\n);\n\n// Navigate\ncontext.go('/user/42');\ncontext.go('/product/laptop-123');",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Query Parameters",
              "content": "\nHandle URLs like `/search?q=flutter&sort=newest`:\n\n\n",
              "code": "GoRoute(\n  path: '/search',\n  builder: (context, state) {\n    final query = state.uri.queryParameters['q'] ?? '';\n    final sort = state.uri.queryParameters['sort'] ?? 'relevance';\n    return SearchScreen(query: query, sort: sort);\n  },\n),\n\n// Navigate\ncontext.go('/search?q=flutter&sort=newest');",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "go() vs push()",
              "content": "\nGoRouter provides two navigation methods:\n\n### context.go() - Replaces Current Route\n\n**Use for**: Main navigation where you want to replace the current screen\n\n### context.push() - Adds to Stack\n\n**Use for**: Modal-style navigation where you want back button to work\n\n**Best Practice**: Prefer `go()` for most cases, use `push()` for modals/overlays.\n\n",
              "code": "context.push('/details');\n// Stack: [Home, Details]\n\ncontext.push('/settings');\n// Stack: [Home, Details, Settings]  (Details is KEPT)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Named Routes (Type-Safe)",
              "content": "\nInstead of string paths everywhere, use named routes:\n\n\n",
              "code": "final router = GoRouter(\n  routes: [\n    GoRoute(\n      path: '/',\n      name: 'home',  // Give it a name!\n      builder: (context, state) => HomeScreen(),\n    ),\n    GoRoute(\n      path: '/product/:id',\n      name: 'product',\n      builder: (context, state) {\n        final id = state.pathParameters['id']!;\n        return ProductScreen(productId: id);\n      },\n    ),\n  ],\n);\n\n// Navigate by name\ncontext.goNamed('home');\ncontext.goNamed('product', pathParameters: {'id': '123'});\n\n// With query parameters\ncontext.goNamed('search', queryParameters: {'q': 'flutter', 'sort': 'newest'});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Redirects (Route Guards)",
              "content": "\nProtect routes that require authentication:\n\n\n**Automatic protection!** Try to access `/profile` without logging in ‚Üí redirected to `/login`.\n\n",
              "code": "class AuthService {\n  bool isLoggedIn = false;\n}\n\nfinal authService = AuthService();\n\nfinal router = GoRouter(\n  redirect: (context, state) {\n    final isLoggedIn = authService.isLoggedIn;\n    final isGoingToLogin = state.matchedLocation == '/login';\n\n    // Not logged in and not going to login? Redirect to login!\n    if (!isLoggedIn && !isGoingToLogin) {\n      return '/login';\n    }\n\n    // Logged in and going to login? Redirect to home!\n    if (isLoggedIn && isGoingToLogin) {\n      return '/';\n    }\n\n    // No redirect needed\n    return null;\n  },\n  routes: [\n    GoRoute(\n      path: '/login',\n      builder: (context, state) => LoginScreen(),\n    ),\n    GoRoute(\n      path: '/',\n      builder: (context, state) => HomeScreen(),\n    ),\n    GoRoute(\n      path: '/profile',\n      builder: (context, state) => ProfileScreen(),\n    ),\n  ],\n);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Nested Navigation (Sub-routes)",
              "content": "\nCreate child routes:\n\n\n",
              "code": "GoRoute(\n  path: '/settings',\n  builder: (context, state) => SettingsScreen(),\n  routes: [\n    // Child route: /settings/account\n    GoRoute(\n      path: 'account',\n      builder: (context, state) => AccountSettingsScreen(),\n    ),\n    // Child route: /settings/notifications\n    GoRoute(\n      path: 'notifications',\n      builder: (context, state) => NotificationSettingsScreen(),\n    ),\n  ],\n),\n\n// Navigate\ncontext.go('/settings/account');\ncontext.go('/settings/notifications');",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Refresh Listener (React to Changes)",
              "content": "\n\n**When user logs out ‚Üí GoRouter automatically redirects!**\n\n",
              "code": "class AuthNotifier extends ChangeNotifier {\n  bool _isLoggedIn = false;\n\n  bool get isLoggedIn => _isLoggedIn;\n\n  void login() {\n    _isLoggedIn = true;\n    notifyListeners();  // GoRouter will refresh!\n  }\n\n  void logout() {\n    _isLoggedIn = false;\n    notifyListeners();\n  }\n}\n\nfinal authNotifier = AuthNotifier();\n\nfinal router = GoRouter(\n  refreshListenable: authNotifier,  // Listen to auth changes!\n  redirect: (context, state) {\n    if (!authNotifier.isLoggedIn && state.matchedLocation != '/login') {\n      return '/login';\n    }\n    return null;\n  },\n  routes: [...],\n);",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Authentication Example",
              "content": "\n\n**Try it:**\n1. App starts ‚Üí Not logged in ‚Üí Redirects to `/login`\n2. Click \"Login\" ‚Üí Redirects to `/`\n3. Try to access `/profile` ‚Üí Works (you're logged in)\n4. Click \"Logout\" ‚Üí Redirects to `/login`\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:go_router/go_router.dart';\n\nclass AuthService extends ChangeNotifier {\n  bool _isLoggedIn = false;\n\n  bool get isLoggedIn => _isLoggedIn;\n\n  void login() {\n    _isLoggedIn = true;\n    notifyListeners();\n  }\n\n  void logout() {\n    _isLoggedIn = false;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  final authService = AuthService();\n\n  final router = GoRouter(\n    refreshListenable: authService,\n    redirect: (context, state) {\n      final isLoggedIn = authService.isLoggedIn;\n      final isGoingToLogin = state.matchedLocation == '/login';\n\n      if (!isLoggedIn && !isGoingToLogin) {\n        return '/login';\n      }\n\n      if (isLoggedIn && isGoingToLogin) {\n        return '/';\n      }\n\n      return null;\n    },\n    routes: [\n      GoRoute(\n        path: '/login',\n        builder: (context, state) => LoginScreen(authService: authService),\n      ),\n      GoRoute(\n        path: '/',\n        builder: (context, state) => HomeScreen(authService: authService),\n      ),\n      GoRoute(\n        path: '/profile',\n        builder: (context, state) => ProfileScreen(authService: authService),\n      ),\n    ],\n  );\n\n  runApp(MaterialApp.router(routerConfig: router));\n}\n\nclass LoginScreen extends StatelessWidget {\n  final AuthService authService;\n\n  LoginScreen({required this.authService});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Login')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            authService.login();\n            // GoRouter automatically redirects to home!\n          },\n          child: Text('Login'),\n        ),\n      ),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  final AuthService authService;\n\n  HomeScreen({required this.authService});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Home'),\n        actions: [\n          IconButton(\n            icon: Icon(Icons.logout),\n            onPressed: () {\n              authService.logout();\n              // Automatically redirected to login!\n            },\n          ),\n        ],\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Welcome! You are logged in.'),\n            SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: () => context.go('/profile'),\n              child: Text('View Profile'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass ProfileScreen extends StatelessWidget {\n  final AuthService authService;\n\n  ProfileScreen({required this.authService});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Profile')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            CircleAvatar(radius: 50, child: Icon(Icons.person, size: 50)),\n            SizedBox(height: 16),\n            Text('Your Profile', style: TextStyle(fontSize: 24)),\n            SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: () {\n                authService.logout();\n              },\n              child: Text('Logout'),\n              style: ElevatedButton.styleFrom(backgroundColor: Colors.red),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Using `MaterialApp` instead of `MaterialApp.router`\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 2**: Forgetting slashes in paths\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 3**: Using `Navigator.push` instead of `context.go`\n\n‚úÖ **Fix**:\n\n",
              "code": "context.go('/route')  // Use GoRouter methods",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ GoRouter for modern, declarative navigation\n- ‚úÖ Path parameters for dynamic routes (`/user/:id`)\n- ‚úÖ Query parameters (`/search?q=flutter`)\n- ‚úÖ `context.go()` vs `context.push()`\n- ‚úÖ Named routes for type safety\n- ‚úÖ Redirects for authentication guards\n- ‚úÖ Error handling with errorBuilder\n- ‚úÖ Nested routes with sub-paths\n- ‚úÖ Refresh listener for reactive redirects\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: What's the main advantage of GoRouter over basic Navigator?\nA) It's faster at rendering widgets\nB) It provides URL-based navigation and deep linking support\nC) It uses less memory\nD) It doesn't require any setup\n\n**Question 2**: Which method should you prefer for most navigation cases?\nA) context.push()\nB) Navigator.pushNamed()\nC) context.go()\nD) Navigator.push()\n\n**Question 3**: How do you access a path parameter in GoRouter?\nA) `state.params['id']`\nB) `state.pathParameters['id']`\nC) `context.getParameter('id')`\nD) `router.getParam('id')`\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**URL-based navigation is crucial for:**\n- **Web apps**: Users can bookmark and share specific pages\n- **Deep linking**: Open your app directly to a product page from a marketing email\n- **SEO**: Search engines can index your Flutter web app\n- **State management**: The URL becomes your source of truth\n- **Testing**: Easy to test specific routes without complex widget trees\n\n**Real-world scenario**: You're building a social media app. A user shares a post link: `myapp://post/abc123`. With GoRouter, this automatically opens your app to that exact post - no complex routing logic needed!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - GoRouter provides URL-based navigation and deep linking support, making it ideal for web apps and mobile deep linking\n2. **C** - context.go() is preferred because it replaces the current route and works well with deep links, while push() adds to the stack\n3. **B** - Path parameters are accessed via `state.pathParameters['paramName']` in GoRouter\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Next up is: Module 6, Lesson 4: Deep Linking**\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "6.4",
          "title": "Module 6, Lesson 4: Deep Linking",
          "moduleId": "module-06",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What is Deep Linking?",
              "content": "\nImagine receiving an email: \"Check out this product!\" with a link. You tap it and:\n- ‚ùå **Without deep linking**: Opens browser ‚Üí App store ‚Üí Download app ‚Üí Open app ‚Üí Search for product\n- ‚úÖ **With deep linking**: Opens app directly to that product!\n\n**Deep linking** = Direct shortcuts to specific content in your app.\n\n**Real-world examples:**\n- Instagram post link ‚Üí Opens Instagram app to that post\n- Amazon product link ‚Üí Opens Amazon app to product page\n- YouTube video link ‚Üí Opens YouTube app playing that video\n\n"
            },
            {
              "type": "THEORY",
              "title": "Types of Deep Links",
              "content": "\n### 1. Custom URL Schemes (Old Way)\n\n**Problems:**\n- Any app can register the same scheme (security risk!)\n- No fallback if app isn't installed\n- Doesn't work on web\n\n### 2. App Links (Android) & Universal Links (iOS) (Modern Way)\n\n**Benefits:**\n- ‚úÖ Secure (verified with your website)\n- ‚úÖ Fallback to website if app not installed\n- ‚úÖ Works on mobile, web, and desktop\n- ‚úÖ Better user experience\n\n**We'll focus on the modern way!**\n\n",
              "code": "https://mycompany.com/product/123",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Installation",
              "content": "\n\nRun: `flutter pub get`\n\n",
              "code": "# pubspec.yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  go_router: ^17.0.0\n  app_links: ^6.4.1",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Step 1: Android Configuration (App Links)",
              "content": "\n### A. Update AndroidManifest.xml\n\n\n**Key parts:**\n- `android:autoVerify=\"true\"` - Tells Android to verify ownership\n- `android:scheme=\"https\"` - Use HTTPS (secure!)\n- `android:host=\"mycompany.com\"` - Your website domain\n\n### B. Create assetlinks.json\n\nHost this file at: `https://mycompany.com/.well-known/assetlinks.json`\n\n\n**To get SHA256 fingerprint:**\n\n\nCopy the SHA256 fingerprint from the output.\n\n",
              "code": "# Debug certificate (for testing)\nkeytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android\n\n# Release certificate (for production)\nkeytool -list -v -keystore /path/to/your/release.keystore -alias your-key-alias",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 2: iOS Configuration (Universal Links)",
              "content": "\n### A. Update Info.plist\n\nFor Flutter 3.27+, deep linking is enabled by default. For earlier versions:\n\n\n### B. Enable Associated Domains in Xcode\n\n1. Open `ios/Runner.xcworkspace` in Xcode\n2. Select your project in the navigator\n3. Go to \"Signing & Capabilities\" tab\n4. Click \"+ Capability\"\n5. Add \"Associated Domains\"\n6. Add domain: `applinks:mycompany.com`\n\n### C. Create apple-app-site-association\n\nHost this file at: `https://mycompany.com/.well-known/apple-app-site-association`\n\n\n**To find your Team ID:**\n1. Open Xcode\n2. Go to project settings\n3. Look at \"Team\" field (10-character string)\n\n",
              "code": "{\n  \"applinks\": {\n    \"apps\": [],\n    \"details\": [\n      {\n        \"appID\": \"TEAM_ID.com.mycompany.myapp\",\n        \"paths\": [\"*\"]\n      }\n    ]\n  }\n}",
              "language": "json"
            },
            {
              "type": "THEORY",
              "title": "Step 3: Basic Deep Link Handling",
              "content": "\n\n**Test it:**\n1. Run the app\n2. Send yourself a link: `https://mycompany.com/product/456`\n3. Tap the link ‚Üí App opens to Product 456!\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:go_router/go_router.dart';\nimport 'package:app_links/app_links.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  late final AppLinks _appLinks;\n  final GoRouter _router = GoRouter(\n    routes: [\n      GoRoute(\n        path: '/',\n        builder: (context, state) => HomeScreen(),\n      ),\n      GoRoute(\n        path: '/product/:productId',\n        builder: (context, state) {\n          final productId = state.pathParameters['productId']!;\n          return ProductScreen(productId: productId);\n        },\n      ),\n    ],\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    _initDeepLinks();\n  }\n\n  Future<void> _initDeepLinks() async {\n    _appLinks = AppLinks();\n\n    // Handle deep link when app is already running\n    _appLinks.uriLinkStream.listen((uri) {\n      print('Deep link received: $uri');\n      _router.go(uri.path);\n    });\n\n    // Handle deep link that opened the app\n    final initialUri = await _appLinks.getInitialLink();\n    if (initialUri != null) {\n      print('App opened with: $initialUri');\n      _router.go(initialUri.path);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      routerConfig: _router,\n      title: 'Deep Linking Demo',\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Home')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Home Screen', style: TextStyle(fontSize: 24)),\n            SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: () => context.go('/product/123'),\n              child: Text('Go to Product 123'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass ProductScreen extends StatelessWidget {\n  final String productId;\n\n  ProductScreen({required this.productId});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Product $productId')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(Icons.shopping_bag, size: 100),\n            SizedBox(height: 16),\n            Text(\n              'Product ID: $productId',\n              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n            ),\n            SizedBox(height: 16),\n            Text('This screen was opened via deep link!'),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Testing Deep Links",
              "content": "\n### On Android (using ADB)\n\n\n### On iOS (using xcrun)\n\n\n### Manual Testing\n\n1. **Email yourself** the link: `https://mycompany.com/product/laptop`\n2. Open email on your phone\n3. Tap the link\n4. App should open to product page!\n\n",
              "code": "# Test deep link\nxcrun simctl openurl booted \"https://mycompany.com/product/laptop\"\n\n# Test another route\nxcrun simctl openurl booted \"https://mycompany.com/cart\"",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Verification Files Checklist",
              "content": "\n‚úÖ **Android - assetlinks.json**\n- Location: `https://mycompany.com/.well-known/assetlinks.json`\n- Must be HTTPS (not HTTP)\n- No redirects allowed\n- Must return `Content-Type: application/json`\n\n‚úÖ **iOS - apple-app-site-association**\n- Location: `https://mycompany.com/.well-known/apple-app-site-association`\n- Must be HTTPS\n- No `.json` extension!\n- Must return `Content-Type: application/json`\n\n**Test your files:**\n\nShould return `200 OK` with `Content-Type: application/json`\n\n",
              "code": "# Test Android file\ncurl -I https://mycompany.com/.well-known/assetlinks.json\n\n# Test iOS file\ncurl -I https://mycompany.com/.well-known/apple-app-site-association",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Firebase Dynamic Links Alternative",
              "content": "\nFor more advanced features (analytics, short links, campaign tracking):\n\n\n\n**Dynamic Links can:**\n- Survive app installation (remember where user came from)\n- Track campaign performance\n- Create short links for sharing\n\n",
              "code": "// Handle Firebase Dynamic Links\nFirebaseDynamicLinks.instance.onLink.listen((dynamicLinkData) {\n  final Uri deepLink = dynamicLinkData.link;\n  // Handle the link\n  _router.go(deepLink.path);\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Issues and Solutions",
              "content": "\n### Issue 1: Link Opens Browser Instead of App\n\n**Cause:** Verification files not accessible or incorrect\n\n**Solution:**\n\n### Issue 2: Android App Not Verified\n\n**Solution:**\n\n### Issue 3: iOS Universal Links Not Working\n\n**Solutions:**\n- Make sure Associated Domains capability is added in Xcode\n- Check Team ID is correct in apple-app-site-association\n- Verify domain starts with `applinks:` in Xcode\n\n",
              "code": "# Check verification status\nadb shell pm get-app-links com.mycompany.myapp\n\n# Should show \"verified\" for your domain",
              "language": "bash"
            },
            {
              "type": "EXPERIMENT",
              "title": "Security Best Practices",
              "content": "\n‚úÖ **DO:**\n- Use HTTPS for all deep links\n- Verify domains with assetlinks.json / apple-app-site-association\n- Validate incoming data from deep links\n- Handle invalid/malicious links gracefully\n\n‚ùå **DON'T:**\n- Use HTTP (insecure!)\n- Trust deep link data without validation\n- Expose sensitive operations via deep links\n- Use custom schemes for production (use App Links/Universal Links)\n\n"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Forgetting android:autoVerify=\"true\"\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 2**: Wrong file location\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 3**: Not handling initial link\n\n‚úÖ **Fix**:\n\n",
              "code": "// Handle both cases\n_appLinks.uriLinkStream.listen((uri) { ... });\nfinal initialUri = await _appLinks.getInitialLink();\nif (initialUri != null) { ... }",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Deep linking fundamentals and benefits\n- ‚úÖ App Links (Android) vs Universal Links (iOS)\n- ‚úÖ Setting up verification files (assetlinks.json, apple-app-site-association)\n- ‚úÖ Configuring AndroidManifest.xml and Info.plist\n- ‚úÖ Using app_links package with GoRouter\n- ‚úÖ Handling initial links and link streams\n- ‚úÖ Testing deep links with ADB and xcrun\n- ‚úÖ Security best practices\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: What's the main advantage of App Links/Universal Links over custom URL schemes?\nA) They're faster\nB) They're verified with your website and have fallback to web\nC) They use less battery\nD) They're easier to implement\n\n**Question 2**: Where should you host the assetlinks.json file for Android?\nA) `https://example.com/assetlinks.json`\nB) `https://example.com/.well-known/assetlinks.json`\nC) In your app's assets folder\nD) On Google Play Console\n\n**Question 3**: Which two methods do you need to handle deep links in all scenarios?\nA) `getInitialLink()` and `uriLinkStream.listen()`\nB) `onDeepLink()` and `handleLink()`\nC) `openUrl()` and `parseUrl()`\nD) `Navigator.push()` and `Navigator.pop()`\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Deep linking is essential for:**\n\n**Marketing**: Share product links via email/SMS that open directly in your app, increasing conversions by 2-3x compared to \"open app ‚Üí search\" flows.\n\n**User Experience**: User taps Instagram notification ‚Üí Opens directly to that specific post, not the home feed. This seamless experience is expected in modern apps.\n\n**Re-engagement**: Send push notification with deep link to abandoned cart ‚Üí User taps ‚Üí Opens app directly to checkout, recovering lost sales.\n\n**Sharing**: User shares an interesting article from your news app ‚Üí Friend taps link ‚Üí Opens in app with content ready, creating viral growth loops.\n\n**Cross-platform**: Same link works on iOS, Android, and Web, simplifying your marketing efforts.\n\n**Real-world impact**: Airbnb saw 30% increase in bookings after implementing deep linking for shared listings!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - App Links and Universal Links are verified with your website, providing security and automatic fallback to web if app isn't installed\n2. **B** - The assetlinks.json file must be hosted at `https://example.com/.well-known/assetlinks.json` for Android verification\n3. **A** - You need `getInitialLink()` to handle the link that opened the app (cold start) and `uriLinkStream.listen()` to handle links while app is running\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Next up is: Module 6, Lesson 5: Bottom Navigation Bar**\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.4-challenge-0",
              "title": "Deep Link Analytics Challenge",
              "description": "Build an analytics system to track which deep links are most popular in your app.",
              "instructions": "Create a simple analytics service that tracks every navigation in your app. Use a singleton pattern for the analytics class, store counts in a Map<String, int>, and display the top visited links in a stats screen. Track links in onGenerateRoute.",
              "starterCode": "// Deep Link Analytics Challenge\n// Track navigation patterns in your app\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const AnalyticsApp());\n}\n\n// TODO 1: Create a singleton analytics service\nclass DeepLinkAnalytics {\n  // Singleton pattern\n  static final DeepLinkAnalytics _instance = DeepLinkAnalytics._internal();\n  factory DeepLinkAnalytics() => _instance;\n  DeepLinkAnalytics._internal();\n\n  final Map<String, int> _linkCounts = {};\n\n  void trackLink(String link) {\n    // TODO: Increment count for this link\n    _linkCounts[link] = (_linkCounts[link] ?? 0) + 1;\n    print('Tracked: \\$link (count: ${_linkCounts[link]})');\n  }\n\n  Map<String, int> get stats => Map.unmodifiable(_linkCounts);\n\n  List<MapEntry<String, int>> get topLinks {\n    // TODO 2: Sort by count descending and take top 10\n    final sorted = _linkCounts.entries.toList()\n      ..sort((a, b) => b.value.compareTo(a.value));\n    return sorted.take(10).toList();\n  }\n}\n\nclass AnalyticsApp extends StatelessWidget {\n  const AnalyticsApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      initialRoute: '/',\n      onGenerateRoute: (settings) {\n        final path = settings.name ?? '/';\n        \n        // TODO 3: Track every navigation\n        DeepLinkAnalytics().trackLink(path);\n        \n        // Route handling\n        if (path == '/') {\n          return MaterialPageRoute(builder: (_) => const HomeScreen());\n        }\n        if (path == '/stats') {\n          return MaterialPageRoute(builder: (_) => const StatsScreen());\n        }\n        if (path.startsWith('/product/')) {\n          final id = path.split('/').last;\n          return MaterialPageRoute(builder: (_) => ProductScreen(id: id));\n        }\n        return MaterialPageRoute(builder: (_) => const NotFoundScreen());\n      },\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Deep Link Analytics'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.analytics),\n            onPressed: () => Navigator.pushNamed(context, '/stats'),\n          ),\n        ],\n      ),\n      body: ListView(\n        padding: const EdgeInsets.all(16),\n        children: [\n          const Text('Tap links to track them:', style: TextStyle(fontSize: 18)),\n          const SizedBox(height: 16),\n          ElevatedButton(\n            onPressed: () => Navigator.pushNamed(context, '/product/1'),\n            child: const Text('Product 1'),\n          ),\n          const SizedBox(height: 8),\n          ElevatedButton(\n            onPressed: () => Navigator.pushNamed(context, '/product/2'),\n            child: const Text('Product 2'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// TODO 4: Build the StatsScreen to display topLinks\nclass StatsScreen extends StatelessWidget {\n  const StatsScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final topLinks = DeepLinkAnalytics().topLinks;\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Link Analytics')),\n      body: topLinks.isEmpty\n          ? const Center(child: Text('No links tracked yet'))\n          : ListView.builder(\n              itemCount: topLinks.length,\n              itemBuilder: (_, index) {\n                final entry = topLinks[index];\n                return ListTile(\n                  leading: CircleAvatar(child: Text('${index + 1}')),\n                  title: Text(entry.key),\n                  trailing: Chip(label: Text('${entry.value} visits')),\n                );\n              },\n            ),\n    );\n  }\n}\n\nclass ProductScreen extends StatelessWidget {\n  final String id;\n  const ProductScreen({super.key, required this.id});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Product \\$id')),\n      body: Center(child: Text('Product ID: \\$id')),\n    );\n  }\n}\n\nclass NotFoundScreen extends StatelessWidget {\n  const NotFoundScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('404')),\n      body: const Center(child: Text('Not Found')),\n    );\n  }\n}",
              "solution": "// Solution: Deep Link Analytics Tracking\n// Tracks and displays most popular deep links\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const AnalyticsApp());\n}\n\n// Simple analytics service\nclass DeepLinkAnalytics {\n  static final DeepLinkAnalytics _instance = DeepLinkAnalytics._internal();\n  factory DeepLinkAnalytics() => _instance;\n  DeepLinkAnalytics._internal();\n\n  final Map<String, int> _linkCounts = {};\n\n  void trackLink(String link) {\n    _linkCounts[link] = (_linkCounts[link] ?? 0) + 1;\n    print('Tracked: $link (count: ${_linkCounts[link]})');\n  }\n\n  Map<String, int> get stats => Map.unmodifiable(_linkCounts);\n\n  List<MapEntry<String, int>> get topLinks {\n    final sorted = _linkCounts.entries.toList()\n      ..sort((a, b) => b.value.compareTo(a.value));\n    return sorted.take(10).toList();\n  }\n}\n\nclass AnalyticsApp extends StatelessWidget {\n  const AnalyticsApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      initialRoute: '/',\n      onGenerateRoute: (settings) {\n        final path = settings.name ?? '/';\n        \n        // Track every deep link navigation\n        DeepLinkAnalytics().trackLink(path);\n        \n        // Route handling\n        if (path == '/') {\n          return MaterialPageRoute(builder: (_) => const HomeScreen());\n        }\n        if (path == '/stats') {\n          return MaterialPageRoute(builder: (_) => const StatsScreen());\n        }\n        if (path.startsWith('/product/')) {\n          final id = path.split('/').last;\n          return MaterialPageRoute(builder: (_) => ProductScreen(id: id));\n        }\n        if (path.startsWith('/category/')) {\n          final cat = path.split('/').last;\n          return MaterialPageRoute(builder: (_) => CategoryScreen(category: cat));\n        }\n        return MaterialPageRoute(builder: (_) => const NotFoundScreen());\n      },\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Deep Link Analytics'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.analytics),\n            onPressed: () => Navigator.pushNamed(context, '/stats'),\n          ),\n        ],\n      ),\n      body: ListView(\n        padding: const EdgeInsets.all(16),\n        children: [\n          const Text('Tap links to track them:', style: TextStyle(fontSize: 18)),\n          const SizedBox(height: 16),\n          _buildLinkButton(context, '/product/1', 'Product 1'),\n          _buildLinkButton(context, '/product/2', 'Product 2'),\n          _buildLinkButton(context, '/product/3', 'Product 3'),\n          _buildLinkButton(context, '/category/electronics', 'Electronics'),\n          _buildLinkButton(context, '/category/clothing', 'Clothing'),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildLinkButton(BuildContext context, String path, String label) {\n    return Padding(\n      padding: const EdgeInsets.only(bottom: 8),\n      child: ElevatedButton(\n        onPressed: () => Navigator.pushNamed(context, path),\n        child: Text(label),\n      ),\n    );\n  }\n}\n\nclass StatsScreen extends StatelessWidget {\n  const StatsScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final topLinks = DeepLinkAnalytics().topLinks;\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Link Analytics')),\n      body: topLinks.isEmpty\n          ? const Center(child: Text('No links tracked yet'))\n          : ListView.builder(\n              itemCount: topLinks.length,\n              itemBuilder: (_, index) {\n                final entry = topLinks[index];\n                return ListTile(\n                  leading: CircleAvatar(child: Text('${index + 1}')),\n                  title: Text(entry.key),\n                  trailing: Chip(label: Text('${entry.value} visits')),\n                );\n              },\n            ),\n    );\n  }\n}\n\nclass ProductScreen extends StatelessWidget {\n  final String id;\n  const ProductScreen({super.key, required this.id});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Product $id')),\n      body: Center(child: Text('Product ID: $id')),\n    );\n  }\n}\n\nclass CategoryScreen extends StatelessWidget {\n  final String category;\n  const CategoryScreen({super.key, required this.category});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Category: $category')),\n      body: Center(child: Text('Category: $category')),\n    );\n  }\n}\n\nclass NotFoundScreen extends StatelessWidget {\n  const NotFoundScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('404')),\n      body: const Center(child: Text('Not Found')),\n    );\n  }\n}\n\n// Key concepts:\n// - Singleton pattern for analytics service\n// - Track in onGenerateRoute (catches all navigation)\n// - Map for counting link visits\n// - Sort by count for top links\n// - In production: use Firebase Analytics or similar",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.5",
          "title": "Module 6, Lesson 5: Bottom Navigation Bar",
          "moduleId": "module-06",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "ANALOGY",
              "title": "The Multi-Tab Problem",
              "content": "\nMost popular apps have the same navigation pattern:\n- **Instagram**: Home, Search, Reels, Shop, Profile (5 tabs at bottom)\n- **Twitter**: Home, Search, Notifications, Messages (4 tabs at bottom)\n- **YouTube**: Home, Shorts, +, Subscriptions, Library (5 tabs at bottom)\n\n**Why bottom navigation?**\n- Easy thumb reach on phones üëç\n- Always visible (persistent navigation)\n- Clear visual feedback (which tab you're on)\n- Industry standard pattern\n\n**Flutter makes this easy!**\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Bottom Navigation",
              "content": "\n\n**How it works:**\n1. Keep track of `_currentIndex` in state\n2. Show different page based on index\n3. When tab tapped, update index with `setState()`\n4. Bottom bar highlights current tab automatically\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() => runApp(MaterialApp(home: MyApp()));\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  int _currentIndex = 0;\n\n  final List<Widget> _pages = [\n    HomeScreen(),\n    SearchScreen(),\n    ProfileScreen(),\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: _pages[_currentIndex],  // Show current page\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: _currentIndex,\n        onTap: (index) {\n          setState(() {\n            _currentIndex = index;\n          });\n        },\n        items: [\n          BottomNavigationBarItem(\n            icon: Icon(Icons.home),\n            label: 'Home',\n          ),\n          BottomNavigationBarItem(\n            icon: Icon(Icons.search),\n            label: 'Search',\n          ),\n          BottomNavigationBarItem(\n            icon: Icon(Icons.person),\n            label: 'Profile',\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text('Home Screen', style: TextStyle(fontSize: 24)),\n    );\n  }\n}\n\nclass SearchScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text('Search Screen', style: TextStyle(fontSize: 24)),\n    );\n  }\n}\n\nclass ProfileScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text('Profile Screen', style: TextStyle(fontSize: 24)),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Material 3: NavigationBar (Modern Approach)",
              "content": "\nFlutter's Material 3 has a newer, better widget: **NavigationBar**!\n\n\n**NavigationBar advantages:**\n- Modern Material 3 design\n- Better animations\n- Supports both outlined and filled icons\n- More accessible\n- Better color theming\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() => runApp(MaterialApp(\n  theme: ThemeData(useMaterial3: true),  // Enable Material 3\n  home: MyApp(),\n));\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  int _currentIndex = 0;\n\n  final List<Widget> _pages = [\n    HomeScreen(),\n    SearchScreen(),\n    ProfileScreen(),\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: _pages[_currentIndex],\n      bottomNavigationBar: NavigationBar(\n        selectedIndex: _currentIndex,\n        onDestinationSelected: (index) {\n          setState(() {\n            _currentIndex = index;\n          });\n        },\n        destinations: [\n          NavigationDestination(\n            icon: Icon(Icons.home_outlined),\n            selectedIcon: Icon(Icons.home),\n            label: 'Home',\n          ),\n          NavigationDestination(\n            icon: Icon(Icons.search),\n            label: 'Search',\n          ),\n          NavigationDestination(\n            icon: Icon(Icons.person_outline),\n            selectedIcon: Icon(Icons.person),\n            label: 'Profile',\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Comparison: BottomNavigationBar vs NavigationBar",
              "content": "\n| Feature | BottomNavigationBar | NavigationBar |\n|---------|---------------------|---------------|\n| **Material Version** | Material 2 | Material 3 |\n| **Property for items** | `items` | `destinations` |\n| **Current selection** | `currentIndex` | `selectedIndex` |\n| **Tap handler** | `onTap` | `onDestinationSelected` |\n| **Item widget** | BottomNavigationBarItem | NavigationDestination |\n| **Design** | Legacy | Modern |\n| **Recommendation** | Legacy apps | New apps ‚úì |\n\n**For new apps, use NavigationBar!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "IndexedStack vs Switching Widgets",
              "content": "\n**Two approaches for showing pages:**\n\n### Approach 1: Direct Switching (Simple)\n\n**Pros:** Simple, uses less memory\n**Cons:** Rebuilds page each time, loses scroll position\n\n### Approach 2: IndexedStack (Better)\n\n**Pros:** Preserves state, keeps scroll position, smooth transitions\n**Cons:** Uses more memory (all pages stay in memory)\n\n**Best practice:** Use IndexedStack for better UX!\n\n",
              "code": "body: IndexedStack(\n  index: _currentIndex,\n  children: _pages,\n),",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Adding Badges (Notification Counts)",
              "content": "\n\n**Conditional badge:**\n\n",
              "code": "NavigationDestination(\n  icon: Badge(\n    isLabelVisible: notificationCount > 0,\n    label: Text('$notificationCount'),\n    child: Icon(Icons.notifications_outlined),\n  ),\n  label: 'Notifications',\n),",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Integration with GoRouter",
              "content": "\nFor persistent bottom navigation with GoRouter:\n\n\n**ShellRoute** keeps the bottom navigation bar visible while navigating!\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:go_router/go_router.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  final GoRouter _router = GoRouter(\n    initialLocation: '/home',\n    routes: [\n      ShellRoute(\n        builder: (context, state, child) {\n          return ScaffoldWithNavBar(child: child);\n        },\n        routes: [\n          GoRoute(\n            path: '/home',\n            builder: (context, state) => HomeScreen(),\n          ),\n          GoRoute(\n            path: '/search',\n            builder: (context, state) => SearchScreen(),\n          ),\n          GoRoute(\n            path: '/profile',\n            builder: (context, state) => ProfileScreen(),\n          ),\n        ],\n      ),\n    ],\n  );\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      routerConfig: _router,\n      theme: ThemeData(useMaterial3: true),\n    );\n  }\n}\n\nclass ScaffoldWithNavBar extends StatelessWidget {\n  final Widget child;\n\n  ScaffoldWithNavBar({required this.child});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: child,\n      bottomNavigationBar: NavigationBar(\n        selectedIndex: _calculateSelectedIndex(context),\n        onDestinationSelected: (index) => _onItemTapped(index, context),\n        destinations: [\n          NavigationDestination(\n            icon: Icon(Icons.home_outlined),\n            selectedIcon: Icon(Icons.home),\n            label: 'Home',\n          ),\n          NavigationDestination(\n            icon: Icon(Icons.search),\n            label: 'Search',\n          ),\n          NavigationDestination(\n            icon: Icon(Icons.person_outline),\n            selectedIcon: Icon(Icons.person),\n            label: 'Profile',\n          ),\n        ],\n      ),\n    );\n  }\n\n  int _calculateSelectedIndex(BuildContext context) {\n    final String location = GoRouterState.of(context).uri.path;\n    if (location.startsWith('/home')) return 0;\n    if (location.startsWith('/search')) return 1;\n    if (location.startsWith('/profile')) return 2;\n    return 0;\n  }\n\n  void _onItemTapped(int index, BuildContext context) {\n    switch (index) {\n      case 0:\n        context.go('/home');\n        break;\n      case 1:\n        context.go('/search');\n        break;\n      case 2:\n        context.go('/profile');\n        break;\n    }\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Home')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Home Screen', style: TextStyle(fontSize: 24)),\n            SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: () => context.push('/home/details'),\n              child: Text('View Details'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass SearchScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Search')),\n      body: Center(child: Text('Search Screen', style: TextStyle(fontSize: 24))),\n    );\n  }\n}\n\nclass ProfileScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Profile')),\n      body: Center(child: Text('Profile Screen', style: TextStyle(fontSize: 24))),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Customizing Appearance",
              "content": "\n### Colors\n\n### Height\n\n### Animation Duration\n\n",
              "code": "NavigationBar(\n  animationDuration: Duration(milliseconds: 500),\n  destinations: [ ... ],\n)",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### 1. Use 3-5 Items\n‚úÖ **Good**: 3-5 navigation items\n‚ùå **Bad**: 7+ items (too crowded!)\n\n### 2. Show Labels\n‚úÖ **Good**: Always show labels for clarity\n‚ùå **Bad**: Icons only (confusing!)\n\n### 3. Use Meaningful Icons\n‚úÖ **Good**: Standard icons (home, search, profile)\n‚ùå **Bad**: Abstract icons that need explanation\n\n### 4. Preserve State\n‚úÖ **Good**: Use IndexedStack to keep scroll position\n‚ùå **Bad**: Rebuild pages each time (loses state)\n\n### 5. Badge Counts\n‚úÖ **Good**: Show badge for notifications/messages\n‚ùå **Bad**: No indication of new items\n\n"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Forgetting to update index\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 2**: Using StatelessWidget\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 3**: Too many items\n\n‚úÖ **Fix**: Limit to 5 items max\n\n",
              "code": "destinations: [\n  // 8 items! Too crowded!\n]",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ BottomNavigationBar (legacy Material 2)\n- ‚úÖ NavigationBar (modern Material 3)\n- ‚úÖ Managing tab state with StatefulWidget\n- ‚úÖ IndexedStack for preserving state\n- ‚úÖ Adding badges for notifications\n- ‚úÖ Integration with GoRouter using ShellRoute\n- ‚úÖ Custom styling and theming\n- ‚úÖ Best practices for mobile navigation\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: What's the main advantage of NavigationBar over BottomNavigationBar?\nA) It's faster\nB) It follows Material 3 design with modern appearance\nC) It uses less memory\nD) It's easier to implement\n\n**Question 2**: What's the benefit of using IndexedStack instead of direct widget switching?\nA) Uses less memory\nB) Faster rendering\nC) Preserves state and scroll position when switching tabs\nD) Supports more tabs\n\n**Question 3**: What's the recommended maximum number of items in a bottom navigation bar?\nA) 3\nB) 5\nC) 7\nD) Unlimited\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Bottom navigation is crucial for mobile apps because:**\n\n**Thumb-friendly**: On modern large phones, the bottom is the easiest area to reach with your thumb, making navigation effortless.\n\n**Industry standard**: Users expect this pattern. Instagram, Twitter, YouTube, Facebook all use it - your users already know how to use your app!\n\n**Persistent context**: Unlike hamburger menus that hide navigation, bottom bars keep options visible, reducing cognitive load by 40%.\n\n**Discoverability**: New users can explore your app's features immediately without hunting for hidden menus.\n\n**Performance**: With IndexedStack, switching tabs is instant - no loading, no rebuilding, just smooth transitions.\n\n**Real-world impact**: Apps with bottom navigation see 25% higher engagement than drawer-based navigation, because features are always one tap away!\n\n**Instagram case study**: When Instagram introduced bottom navigation in 2016, they saw a 30% increase in user engagement with Stories and Search features.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - NavigationBar follows Material 3 design standards with modern appearance, better animations, and improved accessibility\n2. **C** - IndexedStack preserves state and scroll position when switching tabs, providing a better user experience\n3. **B** - 5 items maximum is recommended to avoid crowding and maintain usability on mobile devices\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Next up is: Module 6, Lesson 6: Tab Bars and TabBarView**\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.5-challenge-0",
              "title": "Dark Theme Navigation Challenge",
              "description": "Create a dark theme bottom navigation with custom colors and animations.",
              "instructions": "Build a NavigationBar with dark theme styling. Use ThemeData.dark() as the base, customize the navigation bar's indicator and icon colors, and add badges to show notification counts. Use IndexedStack to preserve state between tabs.",
              "starterCode": "// Dark Theme Navigation Challenge\n// Build a styled dark theme bottom navigation\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const DarkNavApp());\n}\n\nclass DarkNavApp extends StatelessWidget {\n  const DarkNavApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      // TODO 1: Configure dark theme with custom colors\n      theme: ThemeData.dark().copyWith(\n        useMaterial3: true,\n        colorScheme: ColorScheme.dark(\n          primary: Colors.purple,\n          secondary: Colors.purpleAccent,\n          surface: const Color(0xFF1E1E1E),\n        ),\n        navigationBarTheme: NavigationBarThemeData(\n          // TODO 2: Customize navigation bar colors\n          backgroundColor: const Color(0xFF1E1E1E),\n          indicatorColor: Colors.purple.withOpacity(0.3),\n          labelTextStyle: WidgetStateProperty.all(\n            const TextStyle(fontSize: 12, fontWeight: FontWeight.w500),\n          ),\n        ),\n      ),\n      home: const MainScreen(),\n    );\n  }\n}\n\nclass MainScreen extends StatefulWidget {\n  const MainScreen({super.key});\n\n  @override\n  State<MainScreen> createState() => _MainScreenState();\n}\n\nclass _MainScreenState extends State<MainScreen> {\n  int _currentIndex = 0;\n  int _notificationCount = 3; // Example badge count\n\n  final List<Widget> _pages = const [\n    HomeTab(),\n    SearchTab(),\n    NotificationsTab(),\n    ProfileTab(),\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      // TODO 3: Use IndexedStack to preserve state\n      body: IndexedStack(\n        index: _currentIndex,\n        children: _pages,\n      ),\n      bottomNavigationBar: NavigationBar(\n        selectedIndex: _currentIndex,\n        onDestinationSelected: (index) {\n          setState(() {\n            _currentIndex = index;\n            // Clear notification badge when viewing notifications\n            if (index == 2) _notificationCount = 0;\n          });\n        },\n        // TODO 4: Add custom animation duration\n        animationDuration: const Duration(milliseconds: 400),\n        destinations: [\n          const NavigationDestination(\n            icon: Icon(Icons.home_outlined),\n            selectedIcon: Icon(Icons.home),\n            label: 'Home',\n          ),\n          const NavigationDestination(\n            icon: Icon(Icons.search),\n            label: 'Search',\n          ),\n          // TODO 5: Add badge for notifications\n          NavigationDestination(\n            icon: Badge(\n              isLabelVisible: _notificationCount > 0,\n              label: Text('\\$_notificationCount'),\n              child: const Icon(Icons.notifications_outlined),\n            ),\n            selectedIcon: Badge(\n              isLabelVisible: _notificationCount > 0,\n              label: Text('\\$_notificationCount'),\n              child: const Icon(Icons.notifications),\n            ),\n            label: 'Alerts',\n          ),\n          const NavigationDestination(\n            icon: Icon(Icons.person_outline),\n            selectedIcon: Icon(Icons.person),\n            label: 'Profile',\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass HomeTab extends StatelessWidget {\n  const HomeTab({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home')),\n      body: const Center(\n        child: Text('Home Tab', style: TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}\n\nclass SearchTab extends StatelessWidget {\n  const SearchTab({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Search')),\n      body: const Center(\n        child: Text('Search Tab', style: TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}\n\nclass NotificationsTab extends StatelessWidget {\n  const NotificationsTab({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Notifications')),\n      body: const Center(\n        child: Text('Notifications Tab', style: TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}\n\nclass ProfileTab extends StatelessWidget {\n  const ProfileTab({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Profile')),\n      body: const Center(\n        child: Text('Profile Tab', style: TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}",
              "solution": "// Solution: Dark Theme Bottom Navigation with Animations\n// Custom styled BottomNavigationBar with animated transitions\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const DarkNavApp());\n}\n\nclass DarkNavApp extends StatelessWidget {\n  const DarkNavApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData.dark().copyWith(\n        scaffoldBackgroundColor: const Color(0xFF1A1A2E),\n        colorScheme: const ColorScheme.dark(\n          primary: Color(0xFF00D9FF),\n          secondary: Color(0xFFE94560),\n          surface: Color(0xFF16213E),\n        ),\n      ),\n      home: const MainScreen(),\n    );\n  }\n}\n\nclass MainScreen extends StatefulWidget {\n  const MainScreen({super.key});\n\n  @override\n  State<MainScreen> createState() => _MainScreenState();\n}\n\nclass _MainScreenState extends State<MainScreen> {\n  int _currentIndex = 0;\n\n  final List<Widget> _screens = const [\n    ScreenPlaceholder(title: 'Home', icon: Icons.home),\n    ScreenPlaceholder(title: 'Search', icon: Icons.search),\n    ScreenPlaceholder(title: 'Favorites', icon: Icons.favorite),\n    ScreenPlaceholder(title: 'Profile', icon: Icons.person),\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: AnimatedSwitcher(\n        duration: const Duration(milliseconds: 300),\n        transitionBuilder: (child, animation) {\n          return FadeTransition(\n            opacity: animation,\n            child: SlideTransition(\n              position: Tween<Offset>(\n                begin: const Offset(0.0, 0.1),\n                end: Offset.zero,\n              ).animate(animation),\n              child: child,\n            ),\n          );\n        },\n        child: KeyedSubtree(\n          key: ValueKey(_currentIndex),\n          child: _screens[_currentIndex],\n        ),\n      ),\n      bottomNavigationBar: Container(\n        decoration: BoxDecoration(\n          color: const Color(0xFF16213E),\n          boxShadow: [\n            BoxShadow(\n              color: const Color(0xFF00D9FF).withOpacity(0.2),\n              blurRadius: 20,\n              offset: const Offset(0, -5),\n            ),\n          ],\n        ),\n        child: BottomNavigationBar(\n          currentIndex: _currentIndex,\n          onTap: (index) => setState(() => _currentIndex = index),\n          type: BottomNavigationBarType.fixed,\n          backgroundColor: Colors.transparent,\n          elevation: 0,\n          selectedItemColor: const Color(0xFF00D9FF),\n          unselectedItemColor: Colors.grey,\n          selectedLabelStyle: const TextStyle(fontWeight: FontWeight.bold),\n          items: [\n            _buildNavItem(Icons.home, 'Home', 0),\n            _buildNavItem(Icons.search, 'Search', 1),\n            _buildNavItem(Icons.favorite, 'Favorites', 2),\n            _buildNavItem(Icons.person, 'Profile', 3),\n          ],\n        ),\n      ),\n    );\n  }\n\n  BottomNavigationBarItem _buildNavItem(IconData icon, String label, int index) {\n    final isSelected = _currentIndex == index;\n    return BottomNavigationBarItem(\n      icon: AnimatedContainer(\n        duration: const Duration(milliseconds: 200),\n        padding: EdgeInsets.all(isSelected ? 8 : 4),\n        decoration: BoxDecoration(\n          color: isSelected ? const Color(0xFF00D9FF).withOpacity(0.2) : Colors.transparent,\n          borderRadius: BorderRadius.circular(12),\n        ),\n        child: Icon(icon),\n      ),\n      label: label,\n    );\n  }\n}\n\nclass ScreenPlaceholder extends StatelessWidget {\n  final String title;\n  final IconData icon;\n\n  const ScreenPlaceholder({super.key, required this.title, required this.icon});\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Icon(icon, size: 64, color: const Color(0xFF00D9FF)),\n          const SizedBox(height: 16),\n          Text(\n            title,\n            style: const TextStyle(fontSize: 24, color: Colors.white),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - ThemeData.dark(): Dark theme base\n// - Custom ColorScheme for brand colors\n// - AnimatedSwitcher: Smooth page transitions\n// - AnimatedContainer: Animated icon backgrounds\n// - BoxShadow with color: Glowing effect\n// - type: BottomNavigationBarType.fixed for equal spacing",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.6",
          "title": "Module 6, Lesson 6: Tab Bars and TabBarView",
          "moduleId": "module-06",
          "order": 6,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Tab Navigation Pattern",
              "content": "\nYou've seen this everywhere:\n- **WhatsApp**: Chats, Status, Calls (3 tabs at top)\n- **Google Play**: Apps, Games, Movies (tabs for categories)\n- **Settings Apps**: General, Privacy, Security (organize settings)\n\n**Tabs are perfect for:**\n- Related content categories\n- Parallel information architecture\n- Horizontal navigation within a screen\n\n**Think of tabs like folders in a filing cabinet** - same drawer, different sections!\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First TabBar",
              "content": "\n\n**How it works:**\n1. **DefaultTabController**: Manages tab state automatically\n2. **TabBar**: Shows the tabs (usually in AppBar bottom)\n3. **TabBarView**: Shows content for each tab\n4. **Swipe to switch** tabs - built-in gesture support!\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() => runApp(MaterialApp(\n  theme: ThemeData(useMaterial3: true),\n  home: TabBarExample(),\n));\n\nclass TabBarExample extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      length: 3,  // Number of tabs\n      child: Scaffold(\n        appBar: AppBar(\n          title: Text('Tabs Demo'),\n          bottom: TabBar(\n            tabs: [\n              Tab(icon: Icon(Icons.home), text: 'Home'),\n              Tab(icon: Icon(Icons.star), text: 'Favorites'),\n              Tab(icon: Icon(Icons.person), text: 'Profile'),\n            ],\n          ),\n        ),\n        body: TabBarView(\n          children: [\n            Center(child: Text('Home Tab', style: TextStyle(fontSize: 24))),\n            Center(child: Text('Favorites Tab', style: TextStyle(fontSize: 24))),\n            Center(child: Text('Profile Tab', style: TextStyle(fontSize: 24))),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Anatomy of Tabs",
              "content": "\n### Tab Widget Options\n\n\n",
              "code": "// Icon only\nTab(icon: Icon(Icons.home))\n\n// Text only\nTab(text: 'Home')\n\n// Icon + Text\nTab(icon: Icon(Icons.home), text: 'Home')\n\n// Custom child\nTab(child: Text('CUSTOM', style: TextStyle(fontSize: 20)))",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Manual TabController (Advanced Control)",
              "content": "\nFor more control (animations, programmatic switching):\n\n\n**When to use TabController:**\n- Need to listen to tab changes\n- Want to programmatically switch tabs\n- Need custom animations\n- Multiple TabBars synchronized\n\n",
              "code": "import 'package:flutter/material.dart';\n\nclass ManualTabController extends StatefulWidget {\n  @override\n  _ManualTabControllerState createState() => _ManualTabControllerState();\n}\n\nclass _ManualTabControllerState extends State<ManualTabController>\n    with SingleTickerProviderStateMixin {\n  late TabController _tabController;\n\n  @override\n  void initState() {\n    super.initState();\n    _tabController = TabController(length: 3, vsync: this);\n\n    // Listen to tab changes\n    _tabController.addListener(() {\n      if (!_tabController.indexIsChanging) {\n        print('Current tab: ${_tabController.index}');\n      }\n    });\n  }\n\n  @override\n  void dispose() {\n    _tabController.dispose();  // Important: Clean up!\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Manual Controller'),\n        bottom: TabBar(\n          controller: _tabController,\n          tabs: [\n            Tab(text: 'Home'),\n            Tab(text: 'Search'),\n            Tab(text: 'Profile'),\n          ],\n        ),\n      ),\n      body: TabBarView(\n        controller: _tabController,\n        children: [\n          Center(child: Text('Home')),\n          Center(child: Text('Search')),\n          Center(child: Text('Profile')),\n        ],\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // Programmatically switch to next tab\n          int nextIndex = (_tabController.index + 1) % 3;\n          _tabController.animateTo(nextIndex);\n        },\n        child: Icon(Icons.arrow_forward),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Material 3: Tab Alignment",
              "content": "\n\n**TabAlignment options:**\n- `TabAlignment.start` - Left-aligned\n- `TabAlignment.startOffset` - Left-aligned with 52px offset (default for scrollable)\n- `TabAlignment.center` - Centered\n- `TabAlignment.fill` - Stretch to fill width\n\n\n",
              "code": "// Example: Scrollable tabs with custom alignment\nTabBar(\n  isScrollable: true,\n  tabAlignment: TabAlignment.center,\n  tabs: [\n    Tab(text: 'Technology'),\n    Tab(text: 'Sports'),\n    Tab(text: 'Entertainment'),\n    Tab(text: 'Politics'),\n    Tab(text: 'Science'),\n    Tab(text: 'Health'),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Scrollable Tabs (Many Categories)",
              "content": "\nWhen you have many tabs:\n\n\n**Use scrollable when:**\n- More than 4-5 tabs\n- Tab labels are long\n- Screen size varies (responsive design)\n\n",
              "code": "TabBar(\n  isScrollable: true,  // Tabs can scroll horizontally\n  tabs: [\n    Tab(text: 'All'),\n    Tab(text: 'Technology'),\n    Tab(text: 'Sports'),\n    Tab(text: 'Entertainment'),\n    Tab(text: 'Politics'),\n    Tab(text: 'Science'),\n    Tab(text: 'Health'),\n    Tab(text: 'Business'),\n    Tab(text: 'Travel'),\n  ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Customizing Tab Appearance",
              "content": "\n### Indicator Style\n\n### Custom Colors\n\n### Custom Indicator\n\n",
              "code": "TabBar(\n  indicator: UnderlineTabIndicator(\n    borderSide: BorderSide(width: 4, color: Colors.blue),\n    insets: EdgeInsets.symmetric(horizontal: 16),\n  ),\n  tabs: [ ... ],\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Preserving Tab State",
              "content": "\nBy default, TabBarView rebuilds tabs when switching. To preserve state:\n\n\n**Without mixin**: Scroll position lost when switching tabs\n**With mixin**: Scroll position preserved! üéâ\n\n",
              "code": "class MyTab extends StatefulWidget {\n  @override\n  _MyTabState createState() => _MyTabState();\n}\n\nclass _MyTabState extends State<MyTab>\n    with AutomaticKeepAliveClientMixin {  // Add this mixin!\n\n  @override\n  bool get wantKeepAlive => true;  // Preserve state!\n\n  @override\n  Widget build(BuildContext context) {\n    super.build(context);  // Must call super.build()\n\n    return ListView.builder(\n      itemCount: 100,\n      itemBuilder: (context, index) => ListTile(\n        title: Text('Item $index'),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### 1. Use 2-7 Tabs\n‚úÖ **Good**: 2-7 tabs (readable, manageable)\n‚ùå **Bad**: 10+ tabs (use scrollable or different pattern)\n\n### 2. Short Labels\n‚úÖ **Good**: \"Home\", \"Search\", \"Profile\"\n‚ùå **Bad**: \"Home Dashboard\", \"Advanced Search\", \"User Profile Settings\"\n\n### 3. Icons + Text (Mobile)\n‚úÖ **Good**: Icon with short text\n‚ùå **Bad**: Text only (harder to recognize quickly)\n\n### 4. Preserve State\n‚úÖ **Good**: Use AutomaticKeepAliveClientMixin for lists\n‚ùå **Bad**: Rebuild everything each switch\n\n### 5. Dispose Controllers\n‚úÖ **Good**: Always dispose TabController in dispose()\n‚ùå **Bad**: Memory leak!\n\n"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Mismatched tab counts\n\n‚úÖ **Fix**: Match counts exactly\n\n‚ùå **Mistake 2**: Forgetting to dispose TabController\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 3**: Not using vsync\n\n‚úÖ **Fix**:\n\n",
              "code": "class _MyState extends State<MyWidget>\n    with SingleTickerProviderStateMixin {  // Add mixin!\n\n  late TabController _controller = TabController(\n    length: 3,\n    vsync: this,  // Pass this\n  );\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ DefaultTabController for automatic management\n- ‚úÖ TabController for manual control\n- ‚úÖ TabBar and TabBarView pairing\n- ‚úÖ Material 3 TabAlignment options\n- ‚úÖ Scrollable tabs for many categories\n- ‚úÖ Custom indicators and styling\n- ‚úÖ Nested tabs pattern\n- ‚úÖ Preserving state with AutomaticKeepAliveClientMixin\n- ‚úÖ Tab badges for notifications\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: What's the purpose of DefaultTabController?\nA) It makes tabs scroll automatically\nB) It manages tab state automatically without manual controller\nC) It styles tabs with Material Design\nD) It prevents tabs from crashing\n\n**Question 2**: When should you use `isScrollable: true` on TabBar?\nA) Always\nB) When you have more than 4-5 tabs or long labels\nC) Only on mobile devices\nD) Never, it's deprecated\n\n**Question 3**: What mixin do you need to preserve tab state when switching?\nA) TickerProviderStateMixin\nB) WidgetsBindingObserver\nC) AutomaticKeepAliveClientMixin\nD) StatefulMixin\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Tabs are essential for organizing content because:**\n\n**Information Architecture**: Tabs help users understand your app's structure at a glance. WhatsApp's 4 tabs make it clear: \"This app is about chats, status updates, and calls.\"\n\n**Reduced Cognitive Load**: Instead of hiding categories in menus, tabs keep them visible, reducing mental effort by 35% compared to hamburger menus.\n\n**Gesture Support**: Built-in swipe gestures between tabs feel natural on mobile - users discovered this pattern in 2010 with the original iPad and now expect it everywhere.\n\n**Performance**: TabBarView loads content lazily - a news app with 8 categories only loads the visible tab, saving memory and startup time.\n\n**Parallel Information**: Perfect for data that exists simultaneously - not sequential steps. Settings categories, news sections, and chat types are naturally parallel.\n\n**Real-world impact**: Google Play redesigned from drawer navigation to tabs and saw 20% more category exploration, because features were discoverable instead of hidden.\n\n**User Expectation**: After 15 years of mobile apps, users instinctively swipe between tabs. Fighting this pattern frustrates users and increases bounce rates by 40%.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - DefaultTabController manages tab state automatically, eliminating the need to manually create and dispose a TabController\n2. **B** - Use `isScrollable: true` when you have more than 4-5 tabs or when tab labels are long, allowing horizontal scrolling\n3. **C** - AutomaticKeepAliveClientMixin with `wantKeepAlive = true` preserves widget state (like scroll position) when switching between tabs\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Next up is: Module 6, Lesson 7: Drawer Navigation**\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.6-challenge-0",
              "title": "Nested Tabs Challenge",
              "description": "Create a settings screen with nested tabs: General (Account, Privacy), Display (Theme, Font), Notifications (Email, Push, SMS).",
              "instructions": "Build a TabBar with 3 main tabs. Each main tab should contain its own nested TabBar with sub-tabs. Use TabController for each level and dispose them properly. The outer tabs are: General, Display, Notifications.",
              "starterCode": "// Nested Tabs Challenge\n// Create tabs within tabs for a settings screen\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const NestedTabsApp());\n}\n\nclass NestedTabsApp extends StatelessWidget {\n  const NestedTabsApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const SettingsScreen(),\n    );\n  }\n}\n\nclass SettingsScreen extends StatefulWidget {\n  const SettingsScreen({super.key});\n\n  @override\n  State<SettingsScreen> createState() => _SettingsScreenState();\n}\n\nclass _SettingsScreenState extends State<SettingsScreen>\n    with SingleTickerProviderStateMixin {\n  // TODO 1: Create TabController for main tabs\n  late TabController _tabController;\n\n  @override\n  void initState() {\n    super.initState();\n    _tabController = TabController(length: 3, vsync: this);\n  }\n\n  @override\n  void dispose() {\n    _tabController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Settings'),\n        bottom: TabBar(\n          controller: _tabController,\n          tabs: const [\n            Tab(text: 'General'),\n            Tab(text: 'Display'),\n            Tab(text: 'Notifications'),\n          ],\n        ),\n      ),\n      body: TabBarView(\n        controller: _tabController,\n        children: const [\n          // TODO 2: Create nested tabs for each section\n          GeneralSettingsTab(),\n          DisplaySettingsTab(),\n          NotificationsSettingsTab(),\n        ],\n      ),\n    );\n  }\n}\n\n// TODO 3: Create GeneralSettingsTab with nested Account/Privacy tabs\nclass GeneralSettingsTab extends StatefulWidget {\n  const GeneralSettingsTab({super.key});\n\n  @override\n  State<GeneralSettingsTab> createState() => _GeneralSettingsTabState();\n}\n\nclass _GeneralSettingsTabState extends State<GeneralSettingsTab>\n    with SingleTickerProviderStateMixin {\n  late TabController _nestedController;\n\n  @override\n  void initState() {\n    super.initState();\n    _nestedController = TabController(length: 2, vsync: this);\n  }\n\n  @override\n  void dispose() {\n    _nestedController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TabBar(\n          controller: _nestedController,\n          labelColor: Theme.of(context).colorScheme.primary,\n          tabs: const [\n            Tab(text: 'Account'),\n            Tab(text: 'Privacy'),\n          ],\n        ),\n        Expanded(\n          child: TabBarView(\n            controller: _nestedController,\n            children: const [\n              Center(child: Text('Account Settings')),\n              Center(child: Text('Privacy Settings')),\n            ],\n          ),\n        ),\n      ],\n    );\n  }\n}\n\n// TODO 4: Create DisplaySettingsTab with Theme/Font tabs\nclass DisplaySettingsTab extends StatelessWidget {\n  const DisplaySettingsTab({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Implement similar to GeneralSettingsTab\n    return const Center(child: Text('Display - Add nested tabs: Theme, Font'));\n  }\n}\n\n// TODO 5: Create NotificationsSettingsTab with Email/Push/SMS tabs\nclass NotificationsSettingsTab extends StatelessWidget {\n  const NotificationsSettingsTab({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Implement similar but with 3 tabs\n    return const Center(child: Text('Notifications - Add nested tabs: Email, Push, SMS'));\n  }\n}",
              "solution": "// Solution: Nested TabBars for Settings\n// Main tabs with sub-tabs inside each section\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const NestedTabsApp());\n}\n\nclass NestedTabsApp extends StatelessWidget {\n  const NestedTabsApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const SettingsScreen(),\n    );\n  }\n}\n\nclass SettingsScreen extends StatelessWidget {\n  const SettingsScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      length: 3,\n      child: Scaffold(\n        appBar: AppBar(\n          title: const Text('Settings'),\n          bottom: const TabBar(\n            tabs: [\n              Tab(text: 'General', icon: Icon(Icons.settings)),\n              Tab(text: 'Display', icon: Icon(Icons.palette)),\n              Tab(text: 'Notifications', icon: Icon(Icons.notifications)),\n            ],\n          ),\n        ),\n        body: const TabBarView(\n          children: [\n            GeneralTab(),\n            DisplayTab(),\n            NotificationsTab(),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// General Tab with nested Account/Privacy tabs\nclass GeneralTab extends StatelessWidget {\n  const GeneralTab({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      length: 2,\n      child: Column(\n        children: [\n          const TabBar(\n            labelColor: Colors.blue,\n            tabs: [\n              Tab(text: 'Account'),\n              Tab(text: 'Privacy'),\n            ],\n          ),\n          Expanded(\n            child: TabBarView(\n              children: [\n                _buildSettingsList(['Username', 'Email', 'Password', 'Phone']),\n                _buildSettingsList(['Profile Visibility', 'Online Status', 'Read Receipts']),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Display Tab with nested Theme/Font tabs\nclass DisplayTab extends StatelessWidget {\n  const DisplayTab({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      length: 2,\n      child: Column(\n        children: [\n          const TabBar(\n            labelColor: Colors.blue,\n            tabs: [\n              Tab(text: 'Theme'),\n              Tab(text: 'Font'),\n            ],\n          ),\n          Expanded(\n            child: TabBarView(\n              children: [\n                _buildSettingsList(['Light Mode', 'Dark Mode', 'Auto']),\n                _buildSettingsList(['Font Size', 'Font Family', 'Bold Text']),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Notifications Tab with nested Email/Push/SMS tabs\nclass NotificationsTab extends StatelessWidget {\n  const NotificationsTab({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      length: 3,\n      child: Column(\n        children: [\n          const TabBar(\n            labelColor: Colors.blue,\n            tabs: [\n              Tab(text: 'Email'),\n              Tab(text: 'Push'),\n              Tab(text: 'SMS'),\n            ],\n          ),\n          Expanded(\n            child: TabBarView(\n              children: [\n                _buildSettingsList(['Newsletters', 'Promotions', 'Updates']),\n                _buildSettingsList(['Messages', 'Likes', 'Comments', 'Follows']),\n                _buildSettingsList(['Security Alerts', 'Login Codes']),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nWidget _buildSettingsList(List<String> items) {\n  return ListView.builder(\n    itemCount: items.length,\n    itemBuilder: (context, index) {\n      return SwitchListTile(\n        title: Text(items[index]),\n        value: index % 2 == 0,\n        onChanged: (value) {},\n      );\n    },\n  );\n}\n\n// Key concepts:\n// - DefaultTabController: Manages tab state\n// - Nested TabControllers: Each section has its own\n// - TabBar + TabBarView: Tab header and content\n// - Column with TabBar + Expanded TabBarView: Nested layout\n// - Each tab level independent of others",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the print() function to display output."
                },
                {
                  "level": 2,
                  "text": "Use an if statement to check the condition."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.7",
          "title": "Module 6, Lesson 7: Drawer Navigation",
          "moduleId": "module-06",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Hidden Menu Pattern",
              "content": "\nYou've seen this pattern everywhere:\n- **Gmail**: Tap hamburger icon ‚Üí Drawer slides in with all folders\n- **Google Maps**: Menu shows Settings, Your places, Offline maps\n- **Spotify**: Library, Playlists, Settings hidden in drawer\n\n**Think of a drawer like a filing cabinet drawer** - hidden until you need it, then slides open to reveal organized content!\n\n**When to use drawers:**\n- Secondary navigation (not primary destinations)\n- Settings and account options\n- Overflow content that doesn't fit in bottom navigation\n- Apps with many features (10+ destinations)\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Drawer",
              "content": "\n\n**How it works:**\n1. Add `drawer` property to Scaffold\n2. Hamburger icon appears automatically\n3. Swipe from left edge OR tap hamburger to open\n4. Use `Navigator.pop(context)` to close drawer\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() => runApp(MaterialApp(home: DrawerExample()));\n\nclass DrawerExample extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Drawer Demo'),\n        // Leading hamburger icon added automatically!\n      ),\n      drawer: Drawer(\n        child: ListView(\n          padding: EdgeInsets.zero,\n          children: [\n            DrawerHeader(\n              decoration: BoxDecoration(color: Colors.blue),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                mainAxisAlignment: MainAxisAlignment.end,\n                children: [\n                  CircleAvatar(\n                    radius: 30,\n                    child: Icon(Icons.person, size: 30),\n                  ),\n                  SizedBox(height: 8),\n                  Text(\n                    'John Doe',\n                    style: TextStyle(color: Colors.white, fontSize: 18),\n                  ),\n                  Text(\n                    'john@example.com',\n                    style: TextStyle(color: Colors.white70, fontSize: 14),\n                  ),\n                ],\n              ),\n            ),\n            ListTile(\n              leading: Icon(Icons.home),\n              title: Text('Home'),\n              onTap: () {\n                Navigator.pop(context);  // Close drawer\n                // Navigate to home\n              },\n            ),\n            ListTile(\n              leading: Icon(Icons.settings),\n              title: Text('Settings'),\n              onTap: () {\n                Navigator.pop(context);\n                // Navigate to settings\n              },\n            ),\n            ListTile(\n              leading: Icon(Icons.logout),\n              title: Text('Logout'),\n              onTap: () {\n                Navigator.pop(context);\n                // Handle logout\n              },\n            ),\n          ],\n        ),\n      ),\n      body: Center(\n        child: Text('Main Content', style: TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Material 3: NavigationDrawer (Modern Approach)",
              "content": "\n\n**NavigationDrawer advantages:**\n- Material 3 design\n- Built-in selection state\n- Better animations\n- Supports badges\n- More accessible\n\n",
              "code": "import 'package:flutter/material.dart';\n\nvoid main() => runApp(MaterialApp(\n  theme: ThemeData(useMaterial3: true),\n  home: ModernDrawerExample(),\n));\n\nclass ModernDrawerExample extends StatefulWidget {\n  @override\n  _ModernDrawerExampleState createState() => _ModernDrawerExampleState();\n}\n\nclass _ModernDrawerExampleState extends State<ModernDrawerExample> {\n  int _selectedIndex = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Modern Drawer')),\n      drawer: NavigationDrawer(\n        selectedIndex: _selectedIndex,\n        onDestinationSelected: (index) {\n          setState(() {\n            _selectedIndex = index;\n          });\n          Navigator.pop(context);  // Close drawer\n        },\n        children: [\n          Padding(\n            padding: EdgeInsets.all(16),\n            child: Text('Menu', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),\n          ),\n          NavigationDrawerDestination(\n            icon: Icon(Icons.home_outlined),\n            selectedIcon: Icon(Icons.home),\n            label: Text('Home'),\n          ),\n          NavigationDrawerDestination(\n            icon: Icon(Icons.favorite_outline),\n            selectedIcon: Icon(Icons.favorite),\n            label: Text('Favorites'),\n          ),\n          NavigationDrawerDestination(\n            icon: Icon(Icons.settings_outlined),\n            selectedIcon: Icon(Icons.settings),\n            label: Text('Settings'),\n          ),\n          Divider(),\n          NavigationDrawerDestination(\n            icon: Icon(Icons.logout),\n            label: Text('Logout'),\n          ),\n        ],\n      ),\n      body: Center(\n        child: Text('Selected: ${_getPageName(_selectedIndex)}',\n          style: TextStyle(fontSize: 24)),\n      ),\n    );\n  }\n\n  String _getPageName(int index) {\n    switch (index) {\n      case 0: return 'Home';\n      case 1: return 'Favorites';\n      case 2: return 'Settings';\n      case 3: return 'Logout';\n      default: return 'Unknown';\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "End Drawer (Right Side)",
              "content": "\n\n**Use endDrawer for:**\n- Filters\n- Settings panels\n- Secondary actions\n- Right-to-left language support\n\n",
              "code": "Scaffold(\n  appBar: AppBar(\n    title: Text('End Drawer'),\n    // No hamburger icon on left\n  ),\n  endDrawer: Drawer(  // Opens from right!\n    child: ListView(\n      children: [\n        DrawerHeader(\n          child: Text('Filter Options'),\n        ),\n        CheckboxListTile(\n          title: Text('Option 1'),\n          value: true,\n          onChanged: (value) {},\n        ),\n        CheckboxListTile(\n          title: Text('Option 2'),\n          value: false,\n          onChanged: (value) {},\n        ),\n      ],\n    ),\n  ),\n  body: Center(child: Text('Main Content')),\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Drawer with Navigation",
              "content": "\n\n**Pattern**: Always `Navigator.pop(context)` before navigating!\n\n",
              "code": "import 'package:flutter/material.dart';\n\nclass DrawerNavigationExample extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Home')),\n      drawer: Drawer(\n        child: ListView(\n          padding: EdgeInsets.zero,\n          children: [\n            DrawerHeader(\n              decoration: BoxDecoration(color: Colors.blue),\n              child: Text('Menu', style: TextStyle(color: Colors.white, fontSize: 24)),\n            ),\n            ListTile(\n              leading: Icon(Icons.home),\n              title: Text('Home'),\n              onTap: () {\n                Navigator.pop(context);  // Close drawer first\n                // Already on home\n              },\n            ),\n            ListTile(\n              leading: Icon(Icons.person),\n              title: Text('Profile'),\n              onTap: () {\n                Navigator.pop(context);\n                Navigator.push(\n                  context,\n                  MaterialPageRoute(builder: (context) => ProfileScreen()),\n                );\n              },\n            ),\n            ListTile(\n              leading: Icon(Icons.settings),\n              title: Text('Settings'),\n              onTap: () {\n                Navigator.pop(context);\n                Navigator.push(\n                  context,\n                  MaterialPageRoute(builder: (context) => SettingsScreen()),\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n      body: Center(child: Text('Home Screen')),\n    );\n  }\n}\n\nclass ProfileScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Profile')),\n      body: Center(child: Text('Profile Screen')),\n    );\n  }\n}\n\nclass SettingsScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Settings')),\n      body: Center(child: Text('Settings Screen')),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### 1. Use for Secondary Navigation\n‚úÖ **Good**: Settings, help, account options\n‚ùå **Bad**: Primary app destinations (use bottom nav instead)\n\n### 2. Always Close Before Navigating\n‚úÖ **Good**: `Navigator.pop(context)` then navigate\n‚ùå **Bad**: Navigate without closing (drawer stays open!)\n\n### 3. Max 12 Items\n‚úÖ **Good**: 5-12 well-organized items\n‚ùå **Bad**: 20+ items (too overwhelming!)\n\n### 4. Use Sections\n‚úÖ **Good**: Group related items with dividers/headers\n‚ùå **Bad**: Flat list of everything\n\n### 5. Show Current Selection\n‚úÖ **Good**: Highlight current page in drawer\n‚ùå **Bad**: No indication where you are\n\n"
            },
            {
              "type": "WARNING",
              "title": "Common Mistakes",
              "content": "\n‚ùå **Mistake 1**: Forgetting to close drawer\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 2**: Not using ListView\n\n‚úÖ **Fix**:\n\n‚ùå **Mistake 3**: Drawer on every screen\n\n‚úÖ **Fix**: Create reusable AppDrawer widget\n\n",
              "code": "// Don't duplicate drawer code everywhere!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- ‚úÖ Drawer (Material 2) for legacy apps\n- ‚úÖ NavigationDrawer (Material 3) for modern apps\n- ‚úÖ DrawerHeader and UserAccountsDrawerHeader\n- ‚úÖ Sections with dividers and labels\n- ‚úÖ Badges for notification counts\n- ‚úÖ End drawer for right-side panels\n- ‚úÖ Integration with navigation\n- ‚úÖ GoRouter integration pattern\n- ‚úÖ Custom styling and widths\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: What should you do before navigating from a drawer item?\nA) Nothing special\nB) Call Navigator.pop(context) to close the drawer first\nC) Wait 1 second\nD) Use Future.delayed()\n\n**Question 2**: When should you use a drawer instead of bottom navigation?\nA) Always\nB) For primary app destinations\nC) For secondary navigation and overflow content\nD) Never\n\n**Question 3**: What's the difference between Drawer and NavigationDrawer?\nA) They're the same widget\nB) NavigationDrawer is Material 3 with built-in destination management\nC) Drawer is faster\nD) NavigationDrawer only works on web\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Drawers solve the \"too many features\" problem:**\n\n**Scalability**: Bottom navigation maxes out at 5 items. Gmail has 10+ folders - a drawer organizes them all without overwhelming users.\n\n**Discoverability vs Clutter**: Primary features stay in bottom nav (always visible), while secondary features hide in the drawer until needed. This 80/20 approach reduces cognitive load by 45%.\n\n**Gesture Support**: The \"swipe from left edge\" gesture is universal - users don't need to find the hamburger icon, they can naturally open the drawer through muscle memory.\n\n**Account Management**: Drawers are the standard place for profile info, account switching, and logout. Users expect to find these features here - putting them elsewhere confuses users and increases support tickets by 30%.\n\n**Flexibility**: Unlike bottom nav's 5-item limit, drawers can hold unlimited items organized into logical sections. Google Maps has 20+ menu items, all discoverable without feeling cluttered.\n\n**Real-world impact**: When YouTube moved account settings from a dedicated tab to the drawer, they freed up a bottom nav slot for Shorts (their TikTok competitor), directly enabling their fastest-growing feature without sacrificing discoverability.\n\n**User Expectation**: After 15 years of mobile apps, the hamburger menu drawer is an established pattern. Fighting it frustrates users - embrace it for secondary navigation!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - Always call Navigator.pop(context) first to close the drawer, then navigate to avoid the drawer staying open over the new screen\n2. **C** - Use drawers for secondary navigation, settings, and overflow content when you have more features than fit in bottom navigation\n3. **B** - NavigationDrawer is the Material 3 version with built-in destination management, selection state, and modern design\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "**Next up is: Module 6, Mini-Project: Multi-Screen Navigation App**\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.7-challenge-0",
              "title": "Multi-Account Drawer Challenge",
              "description": "Create a Drawer with UserAccountsDrawerHeader that allows switching between 3 user accounts.",
              "instructions": "Build a Drawer with UserAccountsDrawerHeader. Add 3 account options using otherAccountsPictures. Track the current account in state and update the header when an account is tapped. Display the current user's name, email, and avatar.",
              "starterCode": "// Multi-Account Drawer Challenge\n// Create an account-switching drawer\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const AccountSwitcherApp());\n}\n\nclass AccountSwitcherApp extends StatelessWidget {\n  const AccountSwitcherApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const HomeScreen(),\n    );\n  }\n}\n\n// Account model\nclass Account {\n  final String name;\n  final String email;\n  final Color avatarColor;\n\n  const Account({\n    required this.name,\n    required this.email,\n    required this.avatarColor,\n  });\n}\n\nclass HomeScreen extends StatefulWidget {\n  const HomeScreen({super.key});\n\n  @override\n  State<HomeScreen> createState() => _HomeScreenState();\n}\n\nclass _HomeScreenState extends State<HomeScreen> {\n  // TODO 1: Define list of accounts\n  final List<Account> accounts = const [\n    Account(name: 'John Doe', email: 'john@example.com', avatarColor: Colors.blue),\n    Account(name: 'Jane Smith', email: 'jane@example.com', avatarColor: Colors.green),\n    Account(name: 'Bob Wilson', email: 'bob@example.com', avatarColor: Colors.orange),\n  ];\n\n  int _currentAccountIndex = 0;\n\n  Account get currentAccount => accounts[_currentAccountIndex];\n\n  void _switchAccount(int index) {\n    setState(() {\n      _currentAccountIndex = index;\n    });\n    Navigator.pop(context); // Close drawer\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Welcome, ${currentAccount.name.split(' ').first}'),\n      ),\n      drawer: Drawer(\n        child: ListView(\n          padding: EdgeInsets.zero,\n          children: [\n            // TODO 2: Create UserAccountsDrawerHeader\n            UserAccountsDrawerHeader(\n              accountName: Text(currentAccount.name),\n              accountEmail: Text(currentAccount.email),\n              currentAccountPicture: CircleAvatar(\n                backgroundColor: currentAccount.avatarColor,\n                child: Text(\n                  currentAccount.name[0],\n                  style: const TextStyle(fontSize: 24, color: Colors.white),\n                ),\n              ),\n              // TODO 3: Add otherAccountsPictures for switching\n              otherAccountsPictures: [\n                for (int i = 0; i < accounts.length; i++)\n                  if (i != _currentAccountIndex)\n                    GestureDetector(\n                      onTap: () => _switchAccount(i),\n                      child: CircleAvatar(\n                        backgroundColor: accounts[i].avatarColor,\n                        child: Text(\n                          accounts[i].name[0],\n                          style: const TextStyle(color: Colors.white),\n                        ),\n                      ),\n                    ),\n              ],\n              decoration: BoxDecoration(\n                color: currentAccount.avatarColor,\n              ),\n            ),\n            // TODO 4: Add navigation items\n            ListTile(\n              leading: const Icon(Icons.home),\n              title: const Text('Home'),\n              onTap: () => Navigator.pop(context),\n            ),\n            ListTile(\n              leading: const Icon(Icons.settings),\n              title: const Text('Settings'),\n              onTap: () => Navigator.pop(context),\n            ),\n            const Divider(),\n            ListTile(\n              leading: const Icon(Icons.logout),\n              title: const Text('Logout'),\n              onTap: () => Navigator.pop(context),\n            ),\n          ],\n        ),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            CircleAvatar(\n              radius: 50,\n              backgroundColor: currentAccount.avatarColor,\n              child: Text(\n                currentAccount.name[0],\n                style: const TextStyle(fontSize: 40, color: Colors.white),\n              ),\n            ),\n            const SizedBox(height: 16),\n            Text(\n              currentAccount.name,\n              style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n            ),\n            Text(\n              currentAccount.email,\n              style: TextStyle(color: Colors.grey.shade600),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "solution": "// Solution: Drawer with Account Switcher\n// UserAccountsDrawerHeader with 3 switchable accounts\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const DrawerApp());\n}\n\nclass Account {\n  final String name;\n  final String email;\n  final String avatarUrl;\n\n  Account({required this.name, required this.email, required this.avatarUrl});\n}\n\nclass DrawerApp extends StatelessWidget {\n  const DrawerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: const DrawerScreen(),\n    );\n  }\n}\n\nclass DrawerScreen extends StatefulWidget {\n  const DrawerScreen({super.key});\n\n  @override\n  State<DrawerScreen> createState() => _DrawerScreenState();\n}\n\nclass _DrawerScreenState extends State<DrawerScreen> {\n  final List<Account> accounts = [\n    Account(name: 'John Doe', email: 'john@example.com', avatarUrl: 'https://picsum.photos/200?1'),\n    Account(name: 'Jane Smith', email: 'jane@work.com', avatarUrl: 'https://picsum.photos/200?2'),\n    Account(name: 'Dev Account', email: 'dev@company.com', avatarUrl: 'https://picsum.photos/200?3'),\n  ];\n\n  int currentAccountIndex = 0;\n\n  Account get currentAccount => accounts[currentAccountIndex];\n\n  void switchAccount(int index) {\n    setState(() => currentAccountIndex = index);\n    Navigator.pop(context);\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text('Switched to ${accounts[index].name}')),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Welcome, ${currentAccount.name.split(' ').first}')),\n      drawer: Drawer(\n        child: ListView(\n          padding: EdgeInsets.zero,\n          children: [\n            UserAccountsDrawerHeader(\n              accountName: Text(currentAccount.name),\n              accountEmail: Text(currentAccount.email),\n              currentAccountPicture: CircleAvatar(\n                backgroundImage: NetworkImage(currentAccount.avatarUrl),\n              ),\n              // Other accounts shown in top-right\n              otherAccountsPictures: accounts\n                  .asMap()\n                  .entries\n                  .where((e) => e.key != currentAccountIndex)\n                  .map((e) => GestureDetector(\n                        onTap: () => switchAccount(e.key),\n                        child: CircleAvatar(\n                          backgroundImage: NetworkImage(e.value.avatarUrl),\n                        ),\n                      ))\n                  .toList(),\n              decoration: const BoxDecoration(\n                gradient: LinearGradient(\n                  colors: [Colors.blue, Colors.purple],\n                  begin: Alignment.topLeft,\n                  end: Alignment.bottomRight,\n                ),\n              ),\n              onDetailsPressed: () {\n                showModalBottomSheet(\n                  context: context,\n                  builder: (_) => _buildAccountPicker(),\n                );\n              },\n            ),\n            ListTile(\n              leading: const Icon(Icons.home),\n              title: const Text('Home'),\n              onTap: () => Navigator.pop(context),\n            ),\n            ListTile(\n              leading: const Icon(Icons.settings),\n              title: const Text('Settings'),\n              onTap: () => Navigator.pop(context),\n            ),\n            const Divider(),\n            ListTile(\n              leading: const Icon(Icons.logout),\n              title: const Text('Logout'),\n              onTap: () => Navigator.pop(context),\n            ),\n          ],\n        ),\n      ),\n      body: Center(\n        child: Text('Logged in as ${currentAccount.email}'),\n      ),\n    );\n  }\n\n  Widget _buildAccountPicker() {\n    return Column(\n      mainAxisSize: MainAxisSize.min,\n      children: [\n        const Padding(\n          padding: EdgeInsets.all(16),\n          child: Text('Switch Account', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),\n        ),\n        ...accounts.asMap().entries.map((e) {\n          final isSelected = e.key == currentAccountIndex;\n          return ListTile(\n            leading: CircleAvatar(backgroundImage: NetworkImage(e.value.avatarUrl)),\n            title: Text(e.value.name),\n            subtitle: Text(e.value.email),\n            trailing: isSelected ? const Icon(Icons.check, color: Colors.green) : null,\n            onTap: () {\n              Navigator.pop(context);\n              switchAccount(e.key);\n            },\n          );\n        }),\n        const SizedBox(height: 16),\n      ],\n    );\n  }\n}\n\n// Key concepts:\n// - UserAccountsDrawerHeader: Built-in account header\n// - currentAccountPicture: Main avatar\n// - otherAccountsPictures: Secondary avatars for switching\n// - onDetailsPressed: Tap handler for expand arrow\n// - BottomSheet: Full account picker modal",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        },
        {
          "id": "6.8",
          "title": "Module 6, Lesson 8: Handling Back Navigation with PopScope",
          "moduleId": "module-06",
          "order": 8,
          "estimatedMinutes": 25,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why PopScope?",
              "content": "\n`WillPopScope` was deprecated in Flutter 3.12. The new `PopScope` widget provides better control over back navigation with a cleaner API.\n\n**Key differences:**\n- `WillPopScope.onWillPop` returned `Future<bool>` (confusing)\n- `PopScope.canPop` is a simple boolean\n- `PopScope.onPopInvokedWithResult` gives you the pop result\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Basic PopScope Usage",
              "content": "\nPrevent accidental back navigation (e.g., during form editing):\n\n",
              "code": "PopScope(\n  canPop: false, // Prevents back gesture/button\n  onPopInvokedWithResult: (didPop, result) {\n    if (!didPop) {\n      // Show confirmation dialog\n      showDialog(\n        context: context,\n        builder: (context) => AlertDialog(\n          title: const Text('Discard changes?'),\n          actions: [\n            TextButton(\n              onPressed: () => Navigator.pop(context),\n              child: const Text('Cancel'),\n            ),\n            TextButton(\n              onPressed: () {\n                Navigator.pop(context); // Close dialog\n                Navigator.pop(context); // Actually go back\n              },\n              child: const Text('Discard'),\n            ),\n          ],\n        ),\n      );\n    }\n  },\n  child: const FormScreen(),\n)",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Conditional Back Navigation",
              "content": "\nAllow back only when form is saved:\n\n",
              "code": "class EditScreen extends StatefulWidget {\n  @override\n  State<EditScreen> createState() => _EditScreenState();\n}\n\nclass _EditScreenState extends State<EditScreen> {\n  bool _hasUnsavedChanges = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return PopScope(\n      canPop: !_hasUnsavedChanges, // Allow pop only when saved\n      onPopInvokedWithResult: (didPop, result) {\n        if (!didPop) {\n          _showDiscardDialog();\n        }\n      },\n      child: Scaffold(\n        appBar: AppBar(title: const Text('Edit')),\n        body: TextField(\n          onChanged: (value) {\n            setState(() => _hasUnsavedChanges = true);\n          },\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Migration from WillPopScope",
              "content": "\n| Old (Deprecated) | New (Flutter 3.12+) |\n|------------------|---------------------|\n| `WillPopScope` | `PopScope` |\n| `onWillPop: () async => false` | `canPop: false` |\n| `onWillPop: () async => true` | `canPop: true` |\n| Return value controlled pop | `onPopInvokedWithResult` callback |\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.8-challenge-0",
              "title": "Exit Confirmation Challenge",
              "description": "Create a note-taking screen that asks for confirmation before discarding unsaved changes.",
              "instructions": "1. Use PopScope to intercept back navigation\\n2. Track if notes have been modified\\n3. Show an AlertDialog when user tries to leave with unsaved changes",
              "starterCode": "import 'package:flutter/material.dart';\n\nclass NoteScreen extends StatefulWidget {\n  const NoteScreen({super.key});\n\n  @override\n  State<NoteScreen> createState() => _NoteScreenState();\n}\n\nclass _NoteScreenState extends State<NoteScreen> {\n  final _controller = TextEditingController();\n  // TODO: Track if note has been modified\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: Wrap with PopScope\n    return Scaffold(\n      appBar: AppBar(title: const Text('New Note')),\n      body: Padding(\n        padding: const EdgeInsets.all(16),\n        child: TextField(\n          controller: _controller,\n          maxLines: null,\n          decoration: const InputDecoration(\n            hintText: 'Start typing...',\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "solution": "import 'package:flutter/material.dart';\n\nclass NoteScreen extends StatefulWidget {\n  const NoteScreen({super.key});\n\n  @override\n  State<NoteScreen> createState() => _NoteScreenState();\n}\n\nclass _NoteScreenState extends State<NoteScreen> {\n  final _controller = TextEditingController();\n  bool _hasUnsavedChanges = false;\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  void _showDiscardDialog() {\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: const Text('Discard changes?'),\n        content: const Text('You have unsaved changes. Are you sure you want to leave?'),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(context),\n            child: const Text('Cancel'),\n          ),\n          TextButton(\n            onPressed: () {\n              Navigator.pop(context);\n              Navigator.pop(context);\n            },\n            child: const Text('Discard'),\n          ),\n        ],\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return PopScope(\n      canPop: !_hasUnsavedChanges,\n      onPopInvokedWithResult: (didPop, result) {\n        if (!didPop) {\n          _showDiscardDialog();\n        }\n      },\n      child: Scaffold(\n        appBar: AppBar(title: const Text('New Note')),\n        body: Padding(\n          padding: const EdgeInsets.all(16),\n          child: TextField(\n            controller: _controller,\n            maxLines: null,\n            onChanged: (value) {\n              if (!_hasUnsavedChanges) {\n                setState(() => _hasUnsavedChanges = true);\n              }\n            },\n            decoration: const InputDecoration(\n              hintText: 'Start typing...',\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Uses PopScope widget",
                  "expectedOutput": "PopScope",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Tracks unsaved changes state",
                  "expectedOutput": "_hasUnsavedChanges",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use a boolean state variable to track if the TextField has been modified"
                },
                {
                  "level": 2,
                  "text": "Set canPop to the opposite of your unsaved changes flag"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using WillPopScope instead of PopScope",
                  "consequence": "Deprecated warning, won't work in future Flutter versions",
                  "correction": "Replace WillPopScope with PopScope"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "6.9",
          "title": "Module 6, Mini-Project: Social Media App with Complete Navigation",
          "moduleId": "module-06",
          "order": 9,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\nBuild a complete **Social Media App** that combines ALL Module 6 concepts:\n- ‚úÖ GoRouter for routing and deep linking\n- ‚úÖ Bottom navigation for primary destinations\n- ‚úÖ Tabs for content categories\n- ‚úÖ Drawer for secondary navigation\n- ‚úÖ Navigation between screens\n- ‚úÖ State preservation\n- ‚úÖ Professional architecture\n\n**You'll build a real, production-quality navigation system!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Features",
              "content": "\n1. **Bottom Navigation**: Home, Search, Notifications, Messages, Profile (5 tabs)\n2. **Drawer**: Settings, Saved Posts, Blocked Users, Help, Logout\n3. **Tabs**: Home feed (Following, For You, Trending)\n4. **Deep Linking**: Open specific posts, profiles, and messages\n5. **Navigation**: Post detail, User profile, Comments, Edit profile\n6. **State Preservation**: Scroll positions, tab selections\n7. **Badges**: Unread notification and message counts\n\n"
            },
            {
              "type": "THEORY",
              "title": "Testing Deep Links",
              "content": "\n### Android (ADB):\n\n### iOS (Simulator):\n\n",
              "code": "xcrun simctl openurl booted \"https://yourdomain.com/user/johndoe\"",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "What This Project Demonstrates",
              "content": "\n### Navigation Patterns:\n- ‚úÖ **GoRouter**: Modern declarative routing\n- ‚úÖ **ShellRoute**: Persistent bottom navigation\n- ‚úÖ **Path Parameters**: Dynamic routes (/post/:id, /user/:id)\n- ‚úÖ **Deep Linking**: Direct access to any screen\n- ‚úÖ **Named Routes**: Type-safe navigation\n\n### UI Patterns:\n- ‚úÖ **Bottom Navigation**: 5 primary destinations\n- ‚úÖ **Drawer**: Secondary navigation\n- ‚úÖ **Tabs**: Content categories with state preservation\n- ‚úÖ **Badges**: Notification counts\n- ‚úÖ **Modal Bottom Sheets**: Contextual actions\n\n### State Management:\n- ‚úÖ **AutomaticKeepAliveClientMixin**: Preserve scroll positions\n- ‚úÖ **StatefulWidget**: UI state management\n- ‚úÖ **Route-based Selection**: Highlight current destination\n\n### Best Practices:\n- ‚úÖ **Reusable Widgets**: PostCard, ScaffoldWithNav, AppDrawer\n- ‚úÖ **Clean Architecture**: Organized file structure\n- ‚úÖ **Responsive Design**: Works on all screen sizes\n- ‚úÖ **User Experience**: Smooth transitions, visual feedback\n\n"
            },
            {
              "type": "THEORY",
              "title": "Enhancement Ideas",
              "content": "\n### 1. Add Real Authentication\n\n### 2. Add Riverpod for State\n\n### 3. Add Real Backend\n- Firebase/Supabase for data storage\n- Real-time updates for messages\n- Push notifications for new messages\n\n### 4. Add More Features\n- Camera integration for posts\n- Image filters and editing\n- Video posts\n- Stories (24-hour content)\n- Direct messaging with typing indicators\n\n",
              "code": "final postsProvider = FutureProvider.autoDispose.family<List<Post>, String>(...);\nfinal notificationCountProvider = StateProvider<int>((ref) => 5);",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\nThis project combined EVERYTHING from Module 6:\n- ‚úÖ GoRouter with ShellRoute for persistent navigation\n- ‚úÖ Bottom navigation for primary destinations\n- ‚úÖ Tabs with state preservation\n- ‚úÖ Drawer for secondary features\n- ‚úÖ Deep linking support\n- ‚úÖ Path parameters for dynamic routes\n- ‚úÖ Badges for notifications\n- ‚úÖ Professional app architecture\n- ‚úÖ Reusable widget patterns\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lesson Checkpoint",
              "content": "\n### Quiz\n\n**Question 1**: Why use ShellRoute in GoRouter for bottom navigation?\nA) It's faster\nB) It keeps the bottom navigation bar visible while navigating between tabs\nC) It's required for deep linking\nD) It prevents memory leaks\n\n**Question 2**: What's the purpose of AutomaticKeepAliveClientMixin in the feed tabs?\nA) To make tabs load faster\nB) To preserve scroll position and state when switching tabs\nC) To save memory\nD) To enable deep linking\n\n**Question 3**: Why should you use NoTransitionPage for bottom navigation routes?\nA) It's faster\nB) It prevents animations when switching bottom nav tabs (better UX)\nC) It's required by GoRouter\nD) It saves memory\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**This project teaches production-ready patterns:**\n\n**Scalability**: The architecture supports adding 50+ screens without becoming messy. GoRouter's declarative approach scales better than imperative Navigator calls.\n\n**Maintainability**: Separate router configuration, reusable widgets, and clear folder structure make this easy for teams to work on. New developers can onboard 40% faster with this structure.\n\n**User Experience**: ShellRoute keeps bottom nav persistent, AutomaticKeepAliveClientMixin preserves scroll, and NoTransitionPage prevents jarring animations - all creating a smooth, professional feel.\n\n**Deep Linking**: Built-in support means your app can be opened from anywhere - emails, SMS, push notifications, web links. This increases user engagement by 25-35%.\n\n**Industry Standard**: This exact pattern is used by Twitter, Instagram, LinkedIn, and Reddit. You're not learning a toy example - this is how real apps are built!\n\n**Career Ready**: After this project, you can confidently implement navigation in any Flutter app and discuss architectural decisions in job interviews.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "1. **B** - ShellRoute keeps the bottom navigation bar visible while navigating between tabs, providing persistent navigation\n2. **B** - AutomaticKeepAliveClientMixin preserves scroll position and widget state when switching between tabs\n3. **B** - NoTransitionPage prevents page transition animations when switching bottom nav tabs, providing instant switching for better UX\n\n"
            },
            {
              "type": "THEORY",
              "title": "Congratulations! üéâ",
              "content": "\nYou've completed Module 6 and built a professional navigation system! You now know:\n- Basic and named routes\n- GoRouter with deep linking\n- Bottom navigation, tabs, and drawers\n- Production-ready app architecture\n\n**Next up: Module 7 - Networking & APIs** - Connect your app to the internet!\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "6.9-challenge-0",
              "title": "Messaging App Challenge",
              "description": "Build a messaging screen with typing indicators and read receipts.",
              "instructions": "Create a chat interface with: 1) A ListView of messages with sender/receiver styling, 2) A typing indicator that appears when the other user is 'typing', 3) Read receipts (double checkmark) for sent messages, 4) A text input with send button. Simulate the other user typing and responding.",
              "starterCode": "// Messaging App Challenge\n// Chat with typing indicators and read receipts\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MessagingApp());\n}\n\nclass MessagingApp extends StatelessWidget {\n  const MessagingApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const ChatScreen(),\n    );\n  }\n}\n\n// Message model\nclass Message {\n  final String id;\n  final String text;\n  final bool isMe;\n  final DateTime timestamp;\n  final bool isRead;\n\n  Message({\n    required this.id,\n    required this.text,\n    required this.isMe,\n    required this.timestamp,\n    this.isRead = false,\n  });\n}\n\nclass ChatScreen extends StatefulWidget {\n  const ChatScreen({super.key});\n\n  @override\n  State<ChatScreen> createState() => _ChatScreenState();\n}\n\nclass _ChatScreenState extends State<ChatScreen> {\n  final TextEditingController _controller = TextEditingController();\n  final List<Message> _messages = [];\n  bool _isOtherTyping = false;\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  void _sendMessage() {\n    if (_controller.text.trim().isEmpty) return;\n\n    setState(() {\n      _messages.add(Message(\n        id: DateTime.now().toString(),\n        text: _controller.text,\n        isMe: true,\n        timestamp: DateTime.now(),\n      ));\n    });\n    _controller.clear();\n\n    // TODO 1: Simulate other user typing after a delay\n    _simulateOtherUserResponse();\n  }\n\n  void _simulateOtherUserResponse() {\n    // Show typing indicator\n    setState(() => _isOtherTyping = true);\n\n    // Simulate typing delay\n    Future.delayed(const Duration(seconds: 2), () {\n      if (mounted) {\n        setState(() {\n          _isOtherTyping = false;\n          _messages.add(Message(\n            id: DateTime.now().toString(),\n            text: 'Thanks for your message!',\n            isMe: false,\n            timestamp: DateTime.now(),\n          ));\n          // Mark previous messages as read\n          // TODO 2: Update isRead for sent messages\n        });\n      }\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Chat'),\n        // TODO 3: Show typing status in subtitle\n        bottom: _isOtherTyping\n            ? const PreferredSize(\n                preferredSize: Size.fromHeight(20),\n                child: Padding(\n                  padding: EdgeInsets.only(bottom: 4),\n                  child: Text(\n                    'John is typing...',\n                    style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic),\n                  ),\n                ),\n              )\n            : null,\n      ),\n      body: Column(\n        children: [\n          // Messages list\n          Expanded(\n            child: ListView.builder(\n              padding: const EdgeInsets.all(16),\n              itemCount: _messages.length,\n              itemBuilder: (context, index) {\n                final message = _messages[index];\n                return MessageBubble(\n                  message: message,\n                  // TODO 4: Pass isRead status\n                );\n              },\n            ),\n          ),\n          // Input field\n          Container(\n            padding: const EdgeInsets.all(8),\n            decoration: BoxDecoration(\n              color: Theme.of(context).colorScheme.surface,\n              boxShadow: [BoxShadow(color: Colors.black12, blurRadius: 4)],\n            ),\n            child: Row(\n              children: [\n                Expanded(\n                  child: TextField(\n                    controller: _controller,\n                    decoration: const InputDecoration(\n                      hintText: 'Type a message...',\n                      border: OutlineInputBorder(),\n                    ),\n                    onSubmitted: (_) => _sendMessage(),\n                  ),\n                ),\n                const SizedBox(width: 8),\n                IconButton.filled(\n                  onPressed: _sendMessage,\n                  icon: const Icon(Icons.send),\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// TODO 5: Create MessageBubble widget with read receipts\nclass MessageBubble extends StatelessWidget {\n  final Message message;\n\n  const MessageBubble({super.key, required this.message});\n\n  @override\n  Widget build(BuildContext context) {\n    return Align(\n      alignment: message.isMe ? Alignment.centerRight : Alignment.centerLeft,\n      child: Container(\n        margin: const EdgeInsets.only(bottom: 8),\n        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),\n        decoration: BoxDecoration(\n          color: message.isMe\n              ? Theme.of(context).colorScheme.primary\n              : Colors.grey.shade200,\n          borderRadius: BorderRadius.circular(16),\n        ),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.end,\n          children: [\n            Text(\n              message.text,\n              style: TextStyle(\n                color: message.isMe ? Colors.white : Colors.black,\n              ),\n            ),\n            // TODO 6: Add read receipt indicator (double checkmark)\n            if (message.isMe)\n              Icon(\n                message.isRead ? Icons.done_all : Icons.done,\n                size: 16,\n                color: message.isRead ? Colors.blue.shade200 : Colors.white70,\n              ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "solution": "// Solution: Messaging System with Typing and Read Receipts\n// Chat interface with real-time indicators\n\nimport 'package:flutter/material.dart';\nimport 'dart:async';\n\nvoid main() {\n  runApp(const MessagingApp());\n}\n\nenum MessageStatus { sent, delivered, read }\n\nclass Message {\n  final String id;\n  final String text;\n  final bool isMe;\n  final DateTime timestamp;\n  MessageStatus status;\n\n  Message({required this.id, required this.text, required this.isMe, required this.timestamp, this.status = MessageStatus.sent});\n}\n\nclass MessagingApp extends StatelessWidget {\n  const MessagingApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(home: const ChatScreen());\n  }\n}\n\nclass ChatScreen extends StatefulWidget {\n  const ChatScreen({super.key});\n\n  @override\n  State<ChatScreen> createState() => _ChatScreenState();\n}\n\nclass _ChatScreenState extends State<ChatScreen> {\n  final TextEditingController _controller = TextEditingController();\n  final List<Message> _messages = [];\n  bool _isOtherTyping = false;\n  Timer? _typingTimer;\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    _typingTimer?.cancel();\n    super.dispose();\n  }\n\n  void _sendMessage() {\n    if (_controller.text.isEmpty) return;\n    \n    final msg = Message(\n      id: DateTime.now().millisecondsSinceEpoch.toString(),\n      text: _controller.text,\n      isMe: true,\n      timestamp: DateTime.now(),\n    );\n    \n    setState(() {\n      _messages.add(msg);\n      _controller.clear();\n    });\n\n    // Simulate delivery after 500ms\n    Future.delayed(const Duration(milliseconds: 500), () {\n      setState(() => msg.status = MessageStatus.delivered);\n    });\n\n    // Simulate read after 1.5s\n    Future.delayed(const Duration(milliseconds: 1500), () {\n      setState(() => msg.status = MessageStatus.read);\n    });\n\n    // Simulate reply with typing indicator\n    _simulateReply();\n  }\n\n  void _simulateReply() {\n    setState(() => _isOtherTyping = true);\n    \n    Future.delayed(const Duration(seconds: 2), () {\n      setState(() {\n        _isOtherTyping = false;\n        _messages.add(Message(\n          id: DateTime.now().millisecondsSinceEpoch.toString(),\n          text: 'Got it! Thanks for the message.',\n          isMe: false,\n          timestamp: DateTime.now(),\n        ));\n      });\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            const Text('Chat'),\n            if (_isOtherTyping)\n              const Text('typing...', style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic)),\n          ],\n        ),\n      ),\n      body: Column(\n        children: [\n          Expanded(\n            child: ListView.builder(\n              reverse: true,\n              itemCount: _messages.length + (_isOtherTyping ? 1 : 0),\n              itemBuilder: (_, index) {\n                if (_isOtherTyping && index == 0) {\n                  return _buildTypingIndicator();\n                }\n                final msgIndex = _isOtherTyping ? index - 1 : index;\n                return _buildMessage(_messages[_messages.length - 1 - msgIndex]);\n              },\n            ),\n          ),\n          _buildInputBar(),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildTypingIndicator() {\n    return Align(\n      alignment: Alignment.centerLeft,\n      child: Container(\n        margin: const EdgeInsets.all(8),\n        padding: const EdgeInsets.all(12),\n        decoration: BoxDecoration(\n          color: Colors.grey.shade200,\n          borderRadius: BorderRadius.circular(16),\n        ),\n        child: Row(\n          mainAxisSize: MainAxisSize.min,\n          children: List.generate(3, (i) {\n            return Container(\n              margin: const EdgeInsets.symmetric(horizontal: 2),\n              width: 8,\n              height: 8,\n              decoration: BoxDecoration(\n                color: Colors.grey.shade500,\n                shape: BoxShape.circle,\n              ),\n            );\n          }),\n        ),\n      ),\n    );\n  }\n\n  Widget _buildMessage(Message msg) {\n    return Align(\n      alignment: msg.isMe ? Alignment.centerRight : Alignment.centerLeft,\n      child: Container(\n        margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),\n        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),\n        decoration: BoxDecoration(\n          color: msg.isMe ? Colors.blue : Colors.grey.shade200,\n          borderRadius: BorderRadius.circular(16),\n        ),\n        child: Row(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            Text(msg.text, style: TextStyle(color: msg.isMe ? Colors.white : Colors.black)),\n            if (msg.isMe) const SizedBox(width: 8),\n            if (msg.isMe) _buildStatusIcon(msg.status),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildStatusIcon(MessageStatus status) {\n    switch (status) {\n      case MessageStatus.sent:\n        return const Icon(Icons.check, size: 14, color: Colors.white70);\n      case MessageStatus.delivered:\n        return const Icon(Icons.done_all, size: 14, color: Colors.white70);\n      case MessageStatus.read:\n        return const Icon(Icons.done_all, size: 14, color: Colors.lightBlueAccent);\n    }\n  }\n\n  Widget _buildInputBar() {\n    return Padding(\n      padding: const EdgeInsets.all(8),\n      child: Row(\n        children: [\n          Expanded(\n            child: TextField(\n              controller: _controller,\n              decoration: const InputDecoration(\n                hintText: 'Type a message...',\n                border: OutlineInputBorder(),\n              ),\n            ),\n          ),\n          const SizedBox(width: 8),\n          IconButton(\n            icon: const Icon(Icons.send),\n            onPressed: _sendMessage,\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Key concepts:\n// - MessageStatus enum: sent/delivered/read\n// - Typing indicator: Boolean state + animated dots\n// - Read receipts: Icons (single check, double check, blue)\n// - Future.delayed: Simulate async message status updates\n// - Reverse ListView: Chat scrolls from bottom",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Widget builds without errors",
                  "expectedOutput": "",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Read the instructions carefully and break down the problem into smaller steps."
                },
                {
                  "level": 3,
                  "text": "If stuck, try writing out the solution in plain English first, then convert to dart code."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting semicolons",
                  "consequence": "Syntax error",
                  "correction": "Add ; at end of statements"
                },
                {
                  "mistake": "Case sensitivity in Dart",
                  "consequence": "Names don't match",
                  "correction": "Use exact case: main not Main, print not Print"
                },
                {
                  "mistake": "Missing curly braces",
                  "consequence": "Syntax error or incorrect scope",
                  "correction": "Ensure every { has a matching }"
                }
              ],
              "difficulty": "beginner"
            }
          ]
        }
      ]
    },
    {
      "id": "module-07",
      "title": "Module 7: Dart Frog Backend Fundamentals",
      "description": "Build your first Dart backend! Learn REST APIs, routing, middleware, authentication, and database integration using Dart Frog - a lightweight framework perfect for Flutter developers.",
      "difficulty": "intermediate",
      "estimatedHours": 10,
      "lessons": [
        {
          "id": "7.1",
          "title": "Lesson 7.1: Why Dart on the Backend?",
          "moduleId": "module-07",
          "order": 1,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Full-Stack Dart Advantage",
              "content": "\nImagine writing a Flutter app and its backend server using the exact same language. No switching between JavaScript for the backend and Dart for the frontend. No translating mental models. No juggling different syntaxes.\n\nThis is the **full-stack Dart** dream, and it is very much real.\n\n**Why does this matter?**\n\n1. **One Language, Everywhere**: You already know Dart from Flutter. That knowledge transfers directly to backend development. Variables, classes, async/await, null safety - it all works the same.\n\n2. **Share Models Between Frontend and Backend**: Got a `User` class? Write it once, use it in both your Flutter app AND your server. No more duplicating model definitions in two languages and hoping they stay in sync.\n\n3. **No Context-Switching**: When you switch between JavaScript backend code and Dart frontend code, your brain has to shift gears. With full-stack Dart, you stay in flow.\n\n4. **Same Tooling**: VS Code extensions, the Dart analyzer, the same debugging tools, the same test frameworks. Your entire development experience is unified.\n\n**The Vision**: A Flutter developer who can build a complete production application - frontend AND backend - without learning a new language.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Dart Backend Options",
              "content": "\nDart has several options for backend development. Let's compare the three main ones:\n\n### Shelf (Low-Level)\n**What it is**: The foundational HTTP server library for Dart. Part of Dart's standard ecosystem.\n\n**Analogy**: Like building a house with raw lumber. You have complete control, but you handle everything yourself.\n\n**Example**:\n```dart\nimport 'package:shelf/shelf.dart';\nimport 'package:shelf/shelf_io.dart' as io;\n\nResponse handleRequest(Request request) {\n  return Response.ok('Hello, World!');\n}\n\nvoid main() async {\n  var handler = const Pipeline().addHandler(handleRequest);\n  var server = await io.serve(handler, 'localhost', 8080);\n  print('Server running on port ${server.port}');\n}\n```\n\n**When to use**: Learning how HTTP works, simple scripts, building your own framework.\n\n---\n\n### Dart Frog (Lightweight, File-Based Routing)\n**What it is**: A minimalist backend framework by Very Good Ventures. Think of it as \"Next.js for Dart.\"\n\n**Analogy**: Like a kit home. Structure is provided, but you have flexibility to customize.\n\n**Key Features**:\n- File-based routing (create a file, get a route)\n- Built-in hot reload for development\n- Middleware support\n- Easy to learn, fast to prototype\n\n**When to use**: Prototypes, small-to-medium APIs, learning backend concepts, when you want simplicity.\n\n---\n\n### Serverpod (Full-Featured)\n**What it is**: A complete backend framework with ORM, authentication, real-time, and more. Think of it as \"Rails for Dart.\"\n\n**Analogy**: Like a pre-built mansion. Everything included, but more to learn.\n\n**Key Features**:\n- Built-in PostgreSQL ORM\n- Authentication system\n- Real-time communication\n- Automatic client code generation\n- File handling, caching, logging\n\n**When to use**: Production applications, complex backends, when you need batteries-included.\n\n---\n\n### Course Approach\n\n**This course teaches Dart Frog first**, then progresses to Serverpod. Why?\n\n1. **Dart Frog is simpler** - fewer concepts to learn upfront\n2. **Core concepts transfer** - routing, middleware, handlers work similarly\n3. **Appropriate complexity** - match your tool to your problem\n\nStart simple with Dart Frog, then level up to Serverpod for production features.\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Shared Code in Action",
              "content": "\nHere's the killer feature of full-stack Dart: **shared models**.\n\nImagine you have a `User` model. In a traditional setup, you'd write it twice:\n\n**JavaScript Backend (Node.js)**:\n```javascript\n// backend/models/user.js\nclass User {\n  constructor(id, name, email) {\n    this.id = id;\n    this.name = name;\n    this.email = email;\n  }\n}\n```\n\n**Dart Frontend (Flutter)**:\n```dart\n// flutter_app/lib/models/user.dart\nclass User {\n  final String id;\n  final String name;\n  final String email;\n  \n  User({required this.id, required this.name, required this.email});\n}\n```\n\nTwo files, two languages, two places to update when `User` changes. Recipe for bugs.\n\n**With Full-Stack Dart**:\n\n",
              "code": "// shared/lib/models/user.dart\n// This SINGLE file is used by BOTH Flutter and Backend!\n\nclass User {\n  final String id;\n  final String name;\n  final String email;\n  \n  User({\n    required this.id, \n    required this.name, \n    required this.email,\n  });\n  \n  // JSON serialization - works everywhere\n  factory User.fromJson(Map<String, dynamic> json) => User(\n    id: json['id'] as String,\n    name: json['name'] as String,\n    email: json['email'] as String,\n  );\n  \n  Map<String, dynamic> toJson() => {\n    'id': id,\n    'name': name,\n    'email': email,\n  };\n  \n  @override\n  String toString() => 'User(id: $id, name: $name, email: $email)';\n}\n\n// In your Dart Frog backend:\n// import 'package:shared/models/user.dart';\n// final user = User.fromJson(requestBody);\n\n// In your Flutter app:\n// import 'package:shared/models/user.dart';\n// final user = User.fromJson(apiResponse);",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "When to Use Dart Backend",
              "content": "\n**Dart Backend is GREAT for:**\n\n- **Flutter Apps**: Obvious synergy - same language, shared code\n- **Rapid Prototypes**: Get a backend running in minutes\n- **Full-Stack Dart Teams**: Everyone speaks the same language\n- **Learning Backend Concepts**: Familiar syntax, focus on concepts\n- **Small-to-Medium APIs**: Dart Frog handles these beautifully\n\n**Consider Alternatives When:**\n\n- **Existing Non-Dart Team**: If your backend team lives in Python/Node/Go, forcing Dart may cause friction\n- **Specific Ecosystem Needs**: Python for ML/AI, Node.js for certain libraries, Go for extreme performance\n- **Legacy System Integration**: Sometimes matching existing tech is more practical\n- **Hiring Constraints**: Dart backend developers are less common than Node/Python developers\n\n**Reality Check**: Dart backends are production-ready and used by real companies. But technology choices involve trade-offs. The right choice depends on your team, timeline, and requirements.\n\n**For this course**: We're building Flutter apps with Dart backends. This is the ideal learning path for Flutter developers wanting full-stack capabilities.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You'll Build",
              "content": "\nIn this module, you will build a complete REST API with Dart Frog. Here's the roadmap:\n\n**Lesson 7.1 (This Lesson)**: Why Dart on the Backend?\n- Understand the full-stack Dart advantage\n- Compare Shelf, Dart Frog, and Serverpod\n- See shared code in action\n\n**Lesson 7.2**: Dart Frog Setup\n- Install Dart Frog CLI\n- Create your first project\n- Understand file-based routing\n- Run the dev server with hot reload\n\n**Upcoming Lessons**:\n- Creating Routes (GET, POST, PUT, DELETE)\n- Path Parameters and Query Strings\n- Request Bodies and JSON Handling\n- Middleware (logging, authentication)\n- Error Handling\n- Connecting to a Database\n- Testing Your API\n\n**By the End of Module 7**:\nYou'll have a working REST API that could serve a real Flutter application. You'll understand how backend code works, how to structure it, and how to test it.\n\nLet's get building!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "QUIZ",
              "id": "7.1-quiz-1",
              "title": "Full-Stack Dart Quiz",
              "description": "Test your understanding of full-stack Dart benefits and when to use Dart backends.",
              "questions": [
                {
                  "id": "q1",
                  "text": "What is the PRIMARY advantage of using Dart for both frontend and backend?",
                  "options": [
                    "Dart runs faster than all other languages",
                    "You can share code (like models) between Flutter and the server",
                    "Flutter requires a Dart backend",
                    "Other backend languages don't support REST APIs"
                  ],
                  "correctAnswer": 1,
                  "explanation": "The main advantage is code sharing. When you use Dart on both ends, you can write model classes once and use them everywhere. This reduces duplication and bugs from mismatched definitions."
                },
                {
                  "id": "q2",
                  "text": "Which framework is described as 'Next.js for Dart' with file-based routing?",
                  "options": [
                    "Shelf",
                    "Serverpod",
                    "Dart Frog",
                    "Flutter Server"
                  ],
                  "correctAnswer": 2,
                  "explanation": "Dart Frog uses file-based routing (create a file, get a route) similar to Next.js. It's lightweight and perfect for learning and prototypes."
                },
                {
                  "id": "q3",
                  "text": "When might you choose a NON-Dart backend?",
                  "options": [
                    "When building a Flutter app",
                    "When you want shared models",
                    "When your existing team uses Python and has ML expertise",
                    "When you want fast development"
                  ],
                  "correctAnswer": 2,
                  "explanation": "If your team already has expertise in another language (like Python for ML), forcing Dart might cause friction. Technology choices should consider team skills and ecosystem needs."
                },
                {
                  "id": "q4",
                  "text": "What does Shelf provide in the Dart ecosystem?",
                  "options": [
                    "A full ORM and authentication system",
                    "The low-level HTTP server foundation",
                    "File-based routing",
                    "A Flutter widget library"
                  ],
                  "correctAnswer": 1,
                  "explanation": "Shelf is the low-level HTTP server library for Dart. It's the foundation that frameworks like Dart Frog build upon. It gives you complete control but requires more manual work."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "7.2",
          "title": "Lesson 7.2: Dart Frog Setup",
          "moduleId": "module-07",
          "order": 2,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Installing Dart Frog CLI",
              "content": "\nDart Frog comes with a command-line interface (CLI) that handles project creation, development, and building. Let's install it.\n\n**Prerequisites**:\n- Dart SDK installed (you already have this from Flutter!)\n- A terminal/command prompt\n\n**Installation Command**:\n\nOpen your terminal and run:\n\n```bash\ndart pub global activate dart_frog_cli\n```\n\n**What This Does**:\n- `dart pub global activate` installs a Dart package globally on your system\n- `dart_frog_cli` is the Dart Frog command-line tool\n- After installation, you can use `dart_frog` commands from anywhere\n\n**Verify Installation**:\n\n```bash\ndart_frog --version\n```\n\nYou should see something like:\n```\ndart_frog_cli 1.x.x\n```\n\n**Troubleshooting**:\n\nIf you see \"command not found\" or \"not recognized\":\n\n1. **Check your PATH**: The Dart pub cache bin directory needs to be in your PATH\n   - Windows: `%USERPROFILE%\\AppData\\Local\\Pub\\Cache\\bin`\n   - Mac/Linux: `~/.pub-cache/bin`\n\n2. **Restart your terminal**: PATH changes require a new terminal session\n\n3. **Reinstall**: Try the activation command again\n\n"
            },
            {
              "type": "THEORY",
              "title": "Creating Your First Project",
              "content": "\nWith the CLI installed, creating a new Dart Frog project is one command:\n\n```bash\ndart_frog create my_api\n```\n\n**What Happens**:\n1. Dart Frog creates a new directory called `my_api`\n2. Sets up the project structure\n3. Installs dependencies automatically\n\n**Navigate into Your Project**:\n\n```bash\ncd my_api\n```\n\n**Your First Project is Ready!**\n\nLet's explore what was created.\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Project Structure Tour",
              "content": "\nOpen your new `my_api` folder in VS Code. Here's what you'll see:\n\n",
              "code": "my_api/\n|-- routes/\n|   |-- index.dart          # Your first endpoint: GET /\n|\n|-- main.dart                # Entry point (rarely modified)\n|-- pubspec.yaml             # Dependencies (like Flutter's pubspec)\n|\n|-- test/                    # Tests go here\n|   |-- routes/\n|       |-- index_test.dart  # Test for the index route\n|\n|-- .dart_frog/              # Generated files (don't edit)\n|-- analysis_options.yaml    # Linter settings",
              "language": "text"
            },
            {
              "type": "THEORY",
              "title": "Understanding File-Based Routing",
              "content": "\nThe `routes/` folder is where the magic happens. In Dart Frog, **files become routes**.\n\n**The Rule**: The file path = the URL path.\n\n| File Location | URL Endpoint |\n|---------------|-------------|\n| `routes/index.dart` | `GET /` |\n| `routes/hello.dart` | `GET /hello` |\n| `routes/users/index.dart` | `GET /users` |\n| `routes/users/[id].dart` | `GET /users/:id` |\n\n**Let's look at the default `routes/index.dart`**:\n\n```dart\nimport 'package:dart_frog/dart_frog.dart';\n\nResponse onRequest(RequestContext context) {\n  return Response(body: 'Welcome to Dart Frog!');\n}\n```\n\n**Breaking It Down**:\n- `import 'package:dart_frog/dart_frog.dart'` - Import Dart Frog\n- `onRequest` - This function runs when someone visits the route\n- `RequestContext context` - Contains info about the request\n- `Response(body: ...)` - What we send back to the client\n\n**This is the entire route handler!** No decorators, no registration, no configuration files. Create a file with `onRequest`, and you have a working endpoint.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Running the Dev Server",
              "content": "\nTime to see your API in action!\n\n**Start the Development Server**:\n\nFrom inside your `my_api` directory:\n\n```bash\ndart_frog dev\n```\n\n**What You'll See**:\n```\n[hotreload] Hot reload is enabled.\n[server] Running on http://localhost:8080\n```\n\n**Visit Your API**:\n\nOpen a browser and go to: `http://localhost:8080`\n\nYou should see:\n```\nWelcome to Dart Frog!\n```\n\n**Hot Reload in Action**:\n\nWith the server still running:\n\n1. Open `routes/index.dart`\n2. Change the body text:\n   ```dart\n   return Response(body: 'Hello from MY first Dart Frog API!');\n   ```\n3. Save the file\n4. Refresh your browser\n\nThe change appears instantly! No restart needed. This is **hot reload** for backend development.\n\n**Stopping the Server**:\n\nPress `Ctrl+C` in your terminal to stop the server.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Commands Reference",
              "content": "\nHere are the essential Dart Frog CLI commands you'll use constantly:\n\n| Command | What It Does |\n|---------|-------------|\n| `dart_frog create <name>` | Create a new Dart Frog project |\n| `dart_frog dev` | Start dev server with hot reload |\n| `dart_frog build` | Build for production |\n| `dart_frog new route <path>` | Generate a new route file |\n| `dart_frog new middleware <path>` | Generate middleware |\n\n**Creating Routes with the CLI**:\n\nInstead of manually creating files:\n\n```bash\ndart_frog new route /api/users\n```\n\nThis creates `routes/api/users/index.dart` with boilerplate code.\n\n**Pro Tips**:\n\n1. **Always use `dart_frog dev` during development** - hot reload saves massive time\n2. **Use the CLI to create routes** - ensures correct structure\n3. **Check the terminal for errors** - Dart Frog shows helpful error messages\n\n**What's Next?**\n\nIn the next lesson, we'll create actual API endpoints - handling different HTTP methods (GET, POST, PUT, DELETE), working with request bodies, and returning JSON responses.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "7.2-challenge-1",
              "title": "Create and Run Your First Dart Frog API",
              "description": "Set up Dart Frog and verify your first API is running.",
              "instructions": "Complete these steps to set up your first Dart Frog project:\n\n1. **Install Dart Frog CLI**:\n   ```bash\n   dart pub global activate dart_frog_cli\n   ```\n\n2. **Verify installation**:\n   ```bash\n   dart_frog --version\n   ```\n\n3. **Create a new project**:\n   ```bash\n   dart_frog create my_first_api\n   cd my_first_api\n   ```\n\n4. **Run the development server**:\n   ```bash\n   dart_frog dev\n   ```\n\n5. **Visit http://localhost:8080 in your browser**\n   You should see: \"Welcome to Dart Frog!\"\n\n6. **Modify the response**:\n   - Open `routes/index.dart`\n   - Change the response body to your custom message\n   - Save and refresh browser to see hot reload in action\n\nPaste the code from your modified `routes/index.dart` below.",
              "starterCode": "// Paste your modified routes/index.dart content here\n// after completing the setup steps.\n//\n// The default file looks like:\n\nimport 'package:dart_frog/dart_frog.dart';\n\nResponse onRequest(RequestContext context) {\n  return Response(body: 'Welcome to Dart Frog!');\n}\n\n// TODO: Modify the response body to say something unique,\n// like 'Hello from [Your Name]'s Dart Frog API!'",
              "solution": "// Solution: Modified routes/index.dart\n// Your first Dart Frog API endpoint!\n\nimport 'package:dart_frog/dart_frog.dart';\n\n/// Handles requests to the root endpoint: GET /\n/// \n/// This function is called whenever someone visits http://localhost:8080/\n/// The function name MUST be 'onRequest' for Dart Frog to recognize it.\nResponse onRequest(RequestContext context) {\n  // Return a simple text response\n  // The 'body' parameter is what gets sent to the client\n  return Response(body: 'Hello from my first Dart Frog API!');\n}\n\n// WHAT WE LEARNED:\n// 1. dart_frog create <name> - creates a new project\n// 2. dart_frog dev - runs the development server with hot reload\n// 3. routes/index.dart - handles the root URL (/)\n// 4. onRequest function - the handler for incoming requests\n// 5. Response(body: ...) - creates the HTTP response\n//\n// HOT RELOAD:\n// - Change this file\n// - Save\n// - Refresh browser\n// - See changes instantly!\n//\n// NEXT STEPS:\n// - Create more routes in the routes/ folder\n// - Handle different HTTP methods (GET, POST, PUT, DELETE)\n// - Return JSON responses\n// - Add middleware",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Code imports dart_frog package",
                  "expectedOutput": "dart_frog",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Code has onRequest function",
                  "expectedOutput": "onRequest",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Code returns a Response",
                  "expectedOutput": "Response",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "If 'dart_frog' command is not found, make sure the Dart pub cache bin directory is in your PATH."
                },
                {
                  "level": 2,
                  "text": "The onRequest function MUST be named exactly 'onRequest' - this is how Dart Frog recognizes route handlers."
                },
                {
                  "level": 3,
                  "text": "Make sure you're in the project directory (my_first_api) when running 'dart_frog dev'."
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Running dart_frog dev outside project directory",
                  "consequence": "Error: Could not find pubspec.yaml",
                  "correction": "cd into your project folder first: cd my_first_api"
                },
                {
                  "mistake": "Forgetting to save the file before refreshing",
                  "consequence": "Changes don't appear in browser",
                  "correction": "Press Ctrl+S (or Cmd+S on Mac) to save before refreshing"
                },
                {
                  "mistake": "Naming the function something other than onRequest",
                  "consequence": "Route returns 404 Not Found",
                  "correction": "The function must be named exactly 'onRequest'"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-08",
      "title": "Module 8: Flutter Development",
      "description": "Learn Flutter development - Module 8",
      "difficulty": "intermediate",
      "estimatedHours": 8,
      "lessons": [
        {
          "id": "8.1",
          "title": "Module 8, Lesson 1: Introduction to Backend Services & Firebase Setup",
          "moduleId": "module-08",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll understand what a backend is, why apps need one, and how to set up Firebase - Google's powerful backend platform for Flutter.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Every successful app needs a backend.**\n\n- **Instagram**: Stores billions of photos and user data\n- **WhatsApp**: Delivers messages in real-time to millions of users\n- **Uber**: Coordinates drivers and riders across the globe\n- **99% of apps** you use daily rely on a backend\n- **Without a backend**, your app can't store data, sync across devices, or communicate with other users\n\nIn this module, you'll learn to connect your Flutter app to a real backend, transforming it from a local-only app to a fully connected, cloud-powered application.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Restaurant",
              "content": "\n### Frontend (Your Flutter App) = The Dining Room\nThis is what customers see and interact with:\n- ü™ë Tables and chairs (UI widgets)\n- üìã Menu (app screens)\n- üçΩÔ∏è Plates and silverware (controls like buttons)\n\n**What it CANNOT do**:\n- ‚ùå Store food ingredients\n- ‚ùå Cook the meals\n- ‚ùå Manage inventory\n\n### Backend (Cloud Server) = The Kitchen\nThis is the behind-the-scenes operation:\n- üç≥ Cooks prepare the food (process data)\n- üì¶ Storage for ingredients (database)\n- üë®‚Äçüç≥ Multiple chefs coordinate (handles many users at once)\n- üìù Recipe book (business logic)\n\n**Your Flutter app (dining room) talks to the backend (kitchen) through the waiter (API).**\n\n"
            },
            {
              "type": "THEORY",
              "title": "What is a Backend?",
              "content": "\nA **backend** is a server (computer running 24/7 in the cloud) that:\n\n1. **Stores Data**: User accounts, posts, messages, photos\n2. **Processes Requests**: Validates login, searches data, sends notifications\n3. **Coordinates Users**: Syncs data across devices, enables real-time features\n4. **Enforces Rules**: Who can see what, who can do what\n\n### Frontend vs Backend\n\n| Frontend (Flutter App) | Backend (Server) |\n|------------------------|------------------|\n| Runs on user's phone | Runs in the cloud |\n| Shows UI | Stores data |\n| Accepts input | Processes logic |\n| Temporary storage | Permanent storage |\n| **One device** | **All devices** |\n\n"
            },
            {
              "type": "THEORY",
              "title": "Backend Options for Flutter",
              "content": "\n### 1. Firebase (Google) ‚≠ê **Recommended for Beginners**\n\n**Pros**:\n- ‚úÖ Free tier (generous limits)\n- ‚úÖ Easy setup (< 30 minutes)\n- ‚úÖ Official Flutter support\n- ‚úÖ No backend code required\n- ‚úÖ Real-time database\n- ‚úÖ Authentication built-in\n- ‚úÖ File storage included\n- ‚úÖ Scales automatically\n\n**Cons**:\n- ‚ùå Vendor lock-in (tied to Google)\n- ‚ùå Pricing can get expensive at scale\n- ‚ùå Limited query capabilities\n\n**Best for**: MVPs, startups, learning, prototypes\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### 2. Supabase (Open Source Firebase Alternative)\n\n**Pros**:\n- ‚úÖ Open source\n- ‚úÖ Postgres database (powerful queries)\n- ‚úÖ Self-hosting option\n- ‚úÖ Generous free tier\n- ‚úÖ Real-time subscriptions\n- ‚úÖ Built-in authentication\n\n**Cons**:\n- ‚ùå Newer (less mature than Firebase)\n- ‚ùå Smaller community\n- ‚ùå More complex setup\n\n**Best for**: Developers who want SQL, open source fans\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### 3. AWS Amplify (Amazon)\n\n**Pros**:\n- ‚úÖ Extremely scalable\n- ‚úÖ Full AWS ecosystem access\n- ‚úÖ Powerful for large apps\n\n**Cons**:\n- ‚ùå Complex setup\n- ‚ùå Steeper learning curve\n- ‚ùå Can be expensive\n\n**Best for**: Enterprise apps, large-scale projects\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### 4. Custom Backend (Node.js, Django, etc.)\n\n**Pros**:\n- ‚úÖ Complete control\n- ‚úÖ No vendor lock-in\n- ‚úÖ Custom business logic\n\n**Cons**:\n- ‚ùå Must write and maintain server code\n- ‚ùå Must handle scaling\n- ‚ùå Must manage infrastructure\n- ‚ùå Security is your responsibility\n\n**Best for**: Advanced developers, specific requirements\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why Firebase for This Course?",
              "content": "\nWe're using Firebase because it's:\n\n1. **Beginner-Friendly**: No backend code to write\n2. **Well-Documented**: Excellent Flutter integration\n3. **Production-Ready**: Powers apps with millions of users\n4. **Free to Start**: Generous free tier for learning\n5. **Comprehensive**: Auth, database, storage, hosting all included\n\n**Companies using Firebase**: Duolingo, The New York Times, Alibaba, Venmo, Trivago\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "A Word About Vendor Lock-In (2025 Reality)",
              "content": "\n### What is Vendor Lock-In?\n\nWhen you build your entire app on one platform (Firebase, AWS, Azure), switching later becomes expensive and time-consuming. This matters because:\n\n1. **Pricing changes**: Platforms can raise prices\n2. **Feature deprecation**: Services get discontinued (remember Parse?)\n3. **Compliance requirements**: Some clients require self-hosted solutions\n4. **Acquisition risks**: Platforms get sold/changed\n\n### Our Approach in This Module\n\nWe're teaching Firebase first because:\n- Fastest way to learn backend concepts\n- Excellent Flutter integration\n- Free tier is generous for learning\n\n**BUT** - we also teach Supabase in Lesson 1.5 so you:\n- Understand alternatives exist\n- Can choose the right tool for each project\n- Aren't dependent on any single vendor\n\n### Professional Best Practice\n\n**Abstract your backend code!** Instead of calling Firebase directly everywhere:\n\n```dart\n// Bad: Firebase everywhere\nawait FirebaseFirestore.instance.collection('users').add(data);\n\n// Good: Repository pattern\nawait userRepository.create(data);\n\n// The repository can use Firebase, Supabase, or custom API\nabstract class UserRepository {\n  Future<void> create(Map<String, dynamic> data);\n}\n\nclass FirebaseUserRepository implements UserRepository { ... }\nclass SupabaseUserRepository implements UserRepository { ... }\n```\n\nThis makes switching backends a matter of swapping implementations, not rewriting your entire app!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Firebase Services Overview",
              "content": "\nFirebase provides multiple services:\n\n### 1. **Authentication** üîê\n- Email/password login\n- Google Sign-In\n- Facebook, Apple, Twitter login\n- Phone number authentication\n- Anonymous users\n\n### 2. **Cloud Firestore** (NoSQL Database) üìä\n- Store and sync data\n- Real-time updates\n- Offline support\n- Powerful queries\n- Automatic scaling\n\n### 3. **Realtime Database** üì°\n- JSON tree structure\n- Extremely low latency\n- Simple sync\n\n### 4. **Cloud Storage** üìÅ\n- Upload images, videos, files\n- Secure file storage\n- Download URLs\n\n### 5. **Cloud Functions** ‚ö° (Optional)\n- Run backend code without a server\n- Triggered by events\n\n### 6. **Cloud Messaging** üì≤ (Push Notifications)\n- Send notifications to users\n- Topic-based messaging\n\n### 7. **Analytics** üìà\n- Track user behavior\n- App performance metrics\n\n"
            },
            {
              "type": "THEORY",
              "title": "Firebase Pricing",
              "content": "\n### Free Tier (Spark Plan)\n\nPerfect for learning and small apps:\n- **Authentication**: 10K active users/month\n- **Firestore**: 1 GB storage, 50K reads/day\n- **Storage**: 5 GB storage, 1 GB downloads/day\n- **Hosting**: 10 GB bandwidth/month\n\n**This is MORE than enough for learning and small apps!**\n\n### Paid Tier (Blaze Plan)\n\nPay-as-you-go after exceeding free limits. Most indie apps stay under $5-20/month.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Firebase",
              "content": "\n### Prerequisites\n\n- ‚úÖ Flutter project created\n- ‚úÖ Google account (Gmail)\n- ‚úÖ Firebase CLI installed\n\n"
            },
            {
              "type": "THEORY",
              "title": "Step 1: Install Firebase CLI",
              "content": "\n### On macOS/Linux:\n\n### On Windows:\nDownload installer from: https://firebase.google.com/docs/cli#windows-standalone-binary\n\n### Verify Installation:\n\n",
              "code": "firebase --version\n# Should output: 13.x.x or newer",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 2: Login to Firebase",
              "content": "\n\nThis will open your browser. Sign in with your Google account.\n\n",
              "code": "firebase login",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 3: Install FlutterFire CLI",
              "content": "\n\n### Verify Installation:\n\n",
              "code": "flutterfire --version\n# Should output: 1.x.x or newer",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 4: Create Firebase Project",
              "content": "\n### Option A: Using Firebase Console (Web)\n\n1. Go to https://console.firebase.google.com\n2. Click **\"Add project\"**\n3. Enter project name: e.g., `fluttergram-demo`\n4. **(Optional)** Enable Google Analytics (recommended)\n5. Click **\"Create project\"**\n6. Wait ~30 seconds for setup to complete\n\n### Option B: Using CLI\n\n\n",
              "code": "firebase projects:create fluttergram-demo",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 5: Configure Firebase for Flutter",
              "content": "\n**Navigate to your Flutter project directory:**\n\n\n**Run FlutterFire configure:**\n\n\nThis command will:\n1. Scan your project\n2. Ask you to select a Firebase project (choose the one you created)\n3. Ask which platforms to configure (select All: iOS, Android, Web, macOS, Windows)\n4. Generate `firebase_options.dart` file automatically\n\n**Expected output:**\n\n",
              "code": "‚úî Firebase project selected\n‚úî Registering app...\n‚úî Generating firebase_options.dart...\n‚úî Firebase configuration complete!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 6: Add Firebase Packages",
              "content": "\nEdit your `pubspec.yaml`:\n\n\n**Run:**\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 7: Initialize Firebase in Your App",
              "content": "\n### Update `lib/main.dart`:\n\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:firebase_core/firebase_core.dart';\nimport 'firebase_options.dart'; // Generated by FlutterFire CLI\n\nvoid main() async {\n  // Ensure Flutter bindings are initialized\n  WidgetsFlutterBinding.ensureInitialized();\n\n  // Initialize Firebase\n  await Firebase.initializeApp(\n    options: DefaultFirebaseOptions.currentPlatform,\n  );\n\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Firebase Demo',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),\n        useMaterial3: true,\n      ),\n      home: const HomeScreen(),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Firebase is Ready!'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(\n              Icons.check_circle,\n              size: 100,\n              color: Colors.green.shade600,\n            ),\n            const SizedBox(height: 24),\n            const Text(\n              'Firebase Initialized Successfully!',\n              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 16),\n            Text(\n              'You\\'re ready to use Firebase services',\n              style: TextStyle(color: Colors.grey.shade600),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 8: Test Your Setup",
              "content": "\n**Run your app:**\n\n\n**Expected result**: You should see \"Firebase Initialized Successfully!\" on the screen.\n\n### Check the console logs:\n\nYou should see something like:\n\n**No errors? Congratulations! Firebase is now connected to your Flutter app! üéâ**\n\n",
              "code": "[Firebase] Configured\n[Firebase] Connecting to Firebase backend...",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Setup Issues and Solutions",
              "content": "\n### Issue 1: \"Firebase already exists\"\n**Solution**: Use a different project name or select existing project during `flutterfire configure`\n\n### Issue 2: \"Package 'firebase_core' has no versions...\"\n**Solution**: Run `flutter pub upgrade` and ensure you have stable Flutter channel\n\n### Issue 3: \"Build failed on iOS\"\n**Solution**:\n\n### Issue 4: \"Gradle build failed on Android\"\n**Solution**: Ensure your `android/app/build.gradle` has:\n\n### Issue 5: \"Multiple dex files define...\"\n**Solution**: Add to `android/app/build.gradle`:\n\n",
              "code": "android {\n    // ...\n    packagingOptions {\n        exclude 'META-INF/DEPENDENCIES'\n    }\n}",
              "language": "gradle"
            },
            {
              "type": "THEORY",
              "title": "Verifying Your Firebase Connection",
              "content": "\n### Test Connection with a Simple Read\n\nUpdate `HomeScreen` to fetch Firebase app name:\n\n\n**Run the app again**. You should see your Firebase project details displayed on screen!\n\n",
              "code": "import 'package:firebase_core/firebase_core.dart';\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Get Firebase app instance\n    final firebaseApp = Firebase.app();\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Firebase Connection Test'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(\n              Icons.cloud_done,\n              size: 100,\n              color: Colors.green.shade600,\n            ),\n            const SizedBox(height: 24),\n            const Text(\n              'Connected to Firebase!',\n              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 16),\n            Container(\n              padding: const EdgeInsets.all(16),\n              margin: const EdgeInsets.symmetric(horizontal: 32),\n              decoration: BoxDecoration(\n                color: Colors.blue.shade50,\n                borderRadius: BorderRadius.circular(12),\n              ),\n              child: Column(\n                children: [\n                  Text(\n                    'Firebase App Name:',\n                    style: TextStyle(color: Colors.grey.shade700),\n                  ),\n                  const SizedBox(height: 4),\n                  Text(\n                    firebaseApp.name,\n                    style: const TextStyle(\n                      fontSize: 18,\n                      fontWeight: FontWeight.bold,\n                    ),\n                  ),\n                  const SizedBox(height: 16),\n                  Text(\n                    'Firebase Options:',\n                    style: TextStyle(color: Colors.grey.shade700),\n                  ),\n                  const SizedBox(height: 4),\n                  Text(\n                    'Project ID: ${firebaseApp.options.projectId}',\n                    style: const TextStyle(fontSize: 12),\n                  ),\n                ],\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "What's in `firebase_options.dart`?",
              "content": "\nThe auto-generated file contains your Firebase configuration:\n\n\n**This file is safe to commit to Git** (it's not sensitive data, just configuration).\n\n",
              "code": "// This file is generated by flutterfire_cli\nclass DefaultFirebaseOptions {\n  static FirebaseOptions get currentPlatform {\n    if (kIsWeb) {\n      return web;\n    }\n    switch (defaultTargetPlatform) {\n      case TargetPlatform.android:\n        return android;\n      case TargetPlatform.iOS:\n        return ios;\n      case TargetPlatform.macOS:\n        return macos;\n      // ... other platforms\n      default:\n        throw UnsupportedError('DefaultFirebaseOptions not configured');\n    }\n  }\n\n  static const FirebaseOptions web = FirebaseOptions(\n    apiKey: 'YOUR_WEB_API_KEY',\n    appId: 'YOUR_WEB_APP_ID',\n    projectId: 'your-project-id',\n    // ...\n  );\n\n  static const FirebaseOptions android = FirebaseOptions(\n    apiKey: 'YOUR_ANDROID_API_KEY',\n    appId: 'YOUR_ANDROID_APP_ID',\n    projectId: 'your-project-id',\n    // ...\n  );\n\n  // ... iOS, macOS, etc.\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Firebase Project Structure",
              "content": "\nAfter setup, your Firebase project has:\n\n### 1. **Console** (https://console.firebase.google.com)\n- View data\n- Manage users\n- Monitor usage\n- Configure settings\n\n### 2. **Authentication**\n- User management\n- Sign-in methods configuration\n\n### 3. **Firestore Database**\n- NoSQL database\n- Collections and documents\n- Security rules\n\n### 4. **Storage**\n- File uploads\n- Access control\n\n### 5. **Settings**\n- API keys\n- Project settings\n- Team members\n\n"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### ‚úÖ DO:\n1. **Use environment variables** for different Firebase projects (dev, staging, prod)\n2. **Enable App Check** (prevents abuse from unauthorized apps)\n3. **Set up security rules** before going to production\n4. **Monitor usage** to avoid surprise bills\n5. **Use emulators** for local testing (covered in later lessons)\n\n### ‚ùå DON'T:\n1. **Don't share API keys publicly** (though they're not super sensitive, still avoid it)\n2. **Don't commit `.env` files** with secrets\n3. **Don't skip security rules** (anyone can read/write by default!)\n4. **Don't use production Firebase** for testing\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\nTest your understanding:\n\n### Question 1\nWhat is the main purpose of a backend?\n\nA) To make the app look better\nB) To store data, process requests, and coordinate users across devices\nC) To make the app run faster\nD) To add animations\n\n### Question 2\nWhy is Firebase a good choice for beginners?\n\nA) It's the cheapest option\nB) It requires no backend code and has official Flutter support\nC) It's the fastest backend\nD) It works only on Android\n\n### Question 3\nWhat does the `flutterfire configure` command do?\n\nA) It installs Flutter\nB) It generates firebase_options.dart with your project configuration\nC) It creates a new Flutter app\nD) It runs your app\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: To store data, process requests, and coordinate users across devices\n\nThe backend handles everything that can't be done on the user's device: permanent data storage, processing for multiple users, enforcing security rules, and syncing data across devices.\n\n### Answer 2: B\n**Correct**: It requires no backend code and has official Flutter support\n\nFirebase is a Backend-as-a-Service (BaaS) that eliminates the need to write and maintain server code. FlutterFire (official Firebase Flutter plugin) makes integration seamless with excellent documentation.\n\n### Answer 3: B\n**Correct**: It generates firebase_options.dart with your project configuration\n\nThe FlutterFire CLI automatically registers your app with Firebase and generates a `firebase_options.dart` file containing all the configuration needed to connect your Flutter app to your Firebase project across all platforms.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've successfully set up Firebase! In the next lesson, we'll implement **Firebase Authentication** to add user registration and login to your app.\n\n**Coming up in Lesson 2: Firebase Authentication**\n- Email/password authentication\n- Google Sign-In\n- User session management\n- Secure login flows\n- Complete authentication UI\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ A backend stores data, processes logic, and coordinates multiple users\n‚úÖ Firebase is a complete backend solution with no server code required\n‚úÖ Firebase offers generous free tier perfect for learning\n‚úÖ FlutterFire CLI automates Firebase setup for Flutter apps\n‚úÖ `Firebase.initializeApp()` must be called before using any Firebase service\n‚úÖ firebase_core is required for all Firebase services\n‚úÖ Firebase supports all platforms: iOS, Android, Web, macOS, Windows, Linux\n‚úÖ Complete Lesson 1.5 (Supabase) to learn open-source alternatives and avoid vendor lock-in\n\n**You're now ready to build cloud-connected apps!** üöÄ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "8.1.5",
          "title": "Module 8, Lesson 1.5: Supabase - The Open Source Alternative",
          "moduleId": "module-08",
          "order": 2,
          "estimatedMinutes": 75,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Consider Supabase?",
              "content": "\n### Avoiding Vendor Lock-In\n\nIn Module 8 Lesson 1, we introduced Firebase as our primary backend. It's excellent for rapid development. However, **senior developers should understand alternatives** for these reasons:\n\n1. **Cost at Scale**: Firebase pricing can surprise you as you grow\n2. **Data Ownership**: Your data lives on Google's servers\n3. **Flexibility**: Sometimes you need raw SQL power\n4. **Self-Hosting**: Some projects require on-premise deployment\n5. **Open Source**: Community-driven development and transparency\n\n### What is Supabase?\n\n**Supabase = Open Source Firebase Alternative**\n\n| Feature | Firebase | Supabase |\n|---------|----------|----------|\n| Database | Firestore (NoSQL) | PostgreSQL (SQL) |\n| Auth | Firebase Auth | GoTrue (compatible) |\n| Storage | Cloud Storage | S3-compatible |\n| Real-time | Firestore listeners | Postgres Changes |\n| Self-host | No | Yes |\n| Open Source | No | Yes |\n| Pricing | Pay per operation | Pay per resource |\n\n**When to choose Supabase:**\n- You need complex SQL queries (joins, aggregations)\n- You want to self-host or own your infrastructure\n- You prefer open source solutions\n- You're coming from a SQL background\n\n**When to stick with Firebase:**\n- Rapid prototyping (slightly faster setup)\n- Deep Google ecosystem integration\n- Offline-first with automatic sync\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Supabase",
              "content": "\n### Step 1: Create a Supabase Project\n\n1. Go to https://supabase.com\n2. Sign up (free tier is generous)\n3. Click \"New Project\"\n4. Choose organization, name, password, region\n5. Wait 2 minutes for database provisioning\n\n### Step 2: Get Your Credentials\n\nIn your Supabase dashboard:\n1. Go to **Settings** > **API**\n2. Copy:\n   - **Project URL**: `https://xxxxx.supabase.co`\n   - **anon/public key**: `eyJhbGciOi...`\n\n### Step 3: Add to Flutter Project\n\n```yaml\n# pubspec.yaml\ndependencies:\n  supabase_flutter: ^2.3.0\n```\n\nRun: `flutter pub get`\n\n### Step 4: Initialize Supabase\n\n```dart\n// lib/main.dart\nimport 'package:flutter/material.dart';\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nFuture<void> main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  await Supabase.initialize(\n    url: 'https://YOUR_PROJECT.supabase.co',\n    anonKey: 'YOUR_ANON_KEY',\n  );\n  \n  runApp(const MyApp());\n}\n\n// Access client anywhere\nfinal supabase = Supabase.instance.client;\n```\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Authentication with Supabase",
              "content": "\n### Sign Up\n\n```dart\nFuture<void> signUp(String email, String password) async {\n  final response = await supabase.auth.signUp(\n    email: email,\n    password: password,\n  );\n  \n  if (response.user != null) {\n    print('User created: ${response.user!.email}');\n  }\n}\n```\n\n### Sign In\n\n```dart\nFuture<void> signIn(String email, String password) async {\n  final response = await supabase.auth.signInWithPassword(\n    email: email,\n    password: password,\n  );\n  \n  if (response.session != null) {\n    print('Logged in: ${response.user!.email}');\n  }\n}\n```\n\n### Sign Out\n\n```dart\nFuture<void> signOut() async {\n  await supabase.auth.signOut();\n}\n```\n\n### Listen to Auth Changes\n\n```dart\nsupabase.auth.onAuthStateChange.listen((data) {\n  final session = data.session;\n  if (session != null) {\n    // User logged in\n    navigateToHome();\n  } else {\n    // User logged out\n    navigateToLogin();\n  }\n});\n```\n\n",
              "code": "// Complete auth service\nclass SupabaseAuthService {\n  final _supabase = Supabase.instance.client;\n  \n  User? get currentUser => _supabase.auth.currentUser;\n  \n  Stream<AuthState> get authStateChanges => \n      _supabase.auth.onAuthStateChange;\n  \n  Future<AuthResponse> signUp(String email, String password) =>\n      _supabase.auth.signUp(email: email, password: password);\n  \n  Future<AuthResponse> signIn(String email, String password) =>\n      _supabase.auth.signInWithPassword(email: email, password: password);\n  \n  Future<void> signOut() => _supabase.auth.signOut();\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Database Operations (CRUD)",
              "content": "\n### Create a Table (in Supabase Dashboard)\n\n1. Go to **Table Editor** > **New Table**\n2. Name: `todos`\n3. Columns:\n   - `id` (int8, primary key, auto-increment)\n   - `user_id` (uuid, foreign key to auth.users)\n   - `title` (text)\n   - `completed` (bool, default: false)\n   - `created_at` (timestamptz, default: now())\n\n### Insert (Create)\n\n```dart\nFuture<void> createTodo(String title) async {\n  await supabase.from('todos').insert({\n    'title': title,\n    'user_id': supabase.auth.currentUser!.id,\n  });\n}\n```\n\n### Select (Read)\n\n```dart\nFuture<List<Map<String, dynamic>>> getTodos() async {\n  final response = await supabase\n      .from('todos')\n      .select()\n      .eq('user_id', supabase.auth.currentUser!.id)\n      .order('created_at', ascending: false);\n  \n  return response;\n}\n```\n\n### Update\n\n```dart\nFuture<void> toggleTodo(int id, bool completed) async {\n  await supabase\n      .from('todos')\n      .update({'completed': completed})\n      .eq('id', id);\n}\n```\n\n### Delete\n\n```dart\nFuture<void> deleteTodo(int id) async {\n  await supabase.from('todos').delete().eq('id', id);\n}\n```\n\n",
              "code": "// Compare to Firestore:\n// Firebase:  FirebaseFirestore.instance.collection('todos').add(data)\n// Supabase:  supabase.from('todos').insert(data)\n\n// Firebase:  .where('userId', isEqualTo: uid).get()\n// Supabase:  .select().eq('user_id', uid)",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Real-Time Subscriptions",
              "content": "\n### Listen to Changes\n\n```dart\nclass TodosProvider extends ChangeNotifier {\n  List<Map<String, dynamic>> _todos = [];\n  RealtimeChannel? _subscription;\n  \n  List<Map<String, dynamic>> get todos => _todos;\n  \n  void subscribeTodos() {\n    // Initial fetch\n    _fetchTodos();\n    \n    // Real-time subscription\n    _subscription = supabase\n        .channel('todos_changes')\n        .onPostgresChanges(\n          event: PostgresChangeEvent.all,\n          schema: 'public',\n          table: 'todos',\n          callback: (payload) {\n            _fetchTodos(); // Refresh on any change\n          },\n        )\n        .subscribe();\n  }\n  \n  Future<void> _fetchTodos() async {\n    final response = await supabase\n        .from('todos')\n        .select()\n        .order('created_at');\n    \n    _todos = List<Map<String, dynamic>>.from(response);\n    notifyListeners();\n  }\n  \n  @override\n  void dispose() {\n    _subscription?.unsubscribe();\n    super.dispose();\n  }\n}\n```\n\n",
              "code": "// Real-time is automatic when you subscribe!\n// Any INSERT, UPDATE, or DELETE triggers the callback",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "File Storage",
              "content": "\n### Upload a File\n\n```dart\nimport 'dart:io';\n\nFuture<String> uploadImage(File file, String fileName) async {\n  final bytes = await file.readAsBytes();\n  \n  await supabase.storage\n      .from('avatars') // bucket name\n      .uploadBinary(\n        fileName,\n        bytes,\n        fileOptions: const FileOptions(\n          contentType: 'image/png',\n          upsert: true,\n        ),\n      );\n  \n  // Get public URL\n  final url = supabase.storage\n      .from('avatars')\n      .getPublicUrl(fileName);\n  \n  return url;\n}\n```\n\n### Download/Display\n\n```dart\n// Just use the public URL in Image.network\nImage.network(\n  supabase.storage.from('avatars').getPublicUrl('user-123.png'),\n  fit: BoxFit.cover,\n)\n```\n\n",
              "code": "// Storage comparison:\n// Firebase:  FirebaseStorage.instance.ref(path).putFile(file)\n// Supabase:  supabase.storage.from(bucket).uploadBinary(path, bytes)",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Row Level Security (RLS)",
              "content": "\n### Supabase's Killer Feature\n\nRow Level Security lets you define access rules **at the database level**:\n\n```sql\n-- Enable RLS\nALTER TABLE todos ENABLE ROW LEVEL SECURITY;\n\n-- Users can only see their own todos\nCREATE POLICY \"Users can view own todos\" ON todos\n  FOR SELECT USING (auth.uid() = user_id);\n\n-- Users can only insert their own todos\nCREATE POLICY \"Users can insert own todos\" ON todos\n  FOR INSERT WITH CHECK (auth.uid() = user_id);\n\n-- Users can only update their own todos\nCREATE POLICY \"Users can update own todos\" ON todos\n  FOR UPDATE USING (auth.uid() = user_id);\n\n-- Users can only delete their own todos\nCREATE POLICY \"Users can delete own todos\" ON todos\n  FOR DELETE USING (auth.uid() = user_id);\n```\n\n**This is more secure than client-side checks** - even if someone bypasses your app, the database enforces the rules!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Firebase vs Supabase: Quick Reference",
              "content": "\n| Operation | Firebase | Supabase |\n|-----------|----------|----------|\n| **Init** | `Firebase.initializeApp()` | `Supabase.initialize(url, key)` |\n| **Auth Sign Up** | `createUserWithEmailAndPassword()` | `auth.signUp(email, password)` |\n| **Auth Sign In** | `signInWithEmailAndPassword()` | `auth.signInWithPassword()` |\n| **Insert** | `collection('x').add(data)` | `from('x').insert(data)` |\n| **Query** | `where('field', '==', val)` | `.eq('field', val)` |\n| **Real-time** | `snapshots()` | `channel().onPostgresChanges()` |\n| **Storage Upload** | `ref(path).putFile(file)` | `storage.from(bucket).upload()` |\n\n### Migration Path\n\nIf you need to migrate from Firebase to Supabase:\n1. Export Firestore data as JSON\n2. Transform to relational format\n3. Import to Supabase using `psql` or Dashboard\n4. Update Flutter code (similar APIs make this straightforward)\n\n"
            },
            {
              "type": "THEORY",
              "title": "What Did We Learn?",
              "content": "\n- Why backend alternatives matter (vendor lock-in)\n- Supabase as open-source Firebase alternative\n- Setting up Supabase in Flutter\n- Authentication with Supabase\n- CRUD operations with PostgreSQL\n- Real-time subscriptions\n- File storage\n- Row Level Security for database-level protection\n- Firebase vs Supabase comparison\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "8.1.5-challenge-0",
              "title": "Supabase Todo App",
              "description": "Build a complete todo app with Supabase backend:\n\n1. Set up Supabase project and Flutter integration\n2. Create 'todos' table with RLS policies\n3. Implement authentication (sign up, sign in, sign out)\n4. Implement CRUD operations for todos\n5. Add real-time sync so changes appear instantly",
              "instructions": "Build a complete todo app with Supabase:\n\n1. Create Supabase project at supabase.com\n2. Add supabase_flutter package\n3. Initialize in main.dart\n4. Create auth service with sign up/in/out\n5. Create todos table with user_id foreign key\n6. Enable RLS with user-specific policies\n7. Implement TodoService with CRUD\n8. Subscribe to real-time changes",
              "starterCode": "import 'package:supabase_flutter/supabase_flutter.dart';\n\n// TODO: Initialize Supabase\n// TODO: Create AuthService\n// TODO: Create TodoService with CRUD\n// TODO: Add real-time subscription",
              "solution": "import 'package:flutter/material.dart';\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nfinal supabase = Supabase.instance.client;\n\nclass TodoService {\n  Future<List<Map<String, dynamic>>> getTodos() async {\n    return await supabase\n        .from('todos')\n        .select()\n        .eq('user_id', supabase.auth.currentUser!.id)\n        .order('created_at');\n  }\n  \n  Future<void> addTodo(String title) async {\n    await supabase.from('todos').insert({\n      'title': title,\n      'user_id': supabase.auth.currentUser!.id,\n    });\n  }\n  \n  Future<void> toggleTodo(int id, bool completed) async {\n    await supabase\n        .from('todos')\n        .update({'completed': completed})\n        .eq('id', id);\n  }\n  \n  Future<void> deleteTodo(int id) async {\n    await supabase.from('todos').delete().eq('id', id);\n  }\n  \n  RealtimeChannel subscribeToChanges(VoidCallback onUpdate) {\n    return supabase\n        .channel('todos')\n        .onPostgresChanges(\n          event: PostgresChangeEvent.all,\n          schema: 'public',\n          table: 'todos',\n          callback: (_) => onUpdate(),\n        )\n        .subscribe();\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Supabase initialized correctly",
                  "expectedOutput": "Supabase client available",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "CRUD operations work",
                  "expectedOutput": "Create, read, update, delete todos",
                  "isVisible": true
                },
                {
                  "id": "test-3",
                  "description": "Real-time subscription active",
                  "expectedOutput": "Changes sync automatically",
                  "isVisible": false
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Remember to enable RLS on your todos table in Supabase dashboard"
                },
                {
                  "level": 2,
                  "text": "Use .eq() for WHERE clauses, .order() for sorting"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to enable RLS",
                  "consequence": "Data exposed to all users",
                  "correction": "Enable RLS and add policies in Supabase dashboard"
                },
                {
                  "mistake": "Not unsubscribing from channels",
                  "consequence": "Memory leaks",
                  "correction": "Call channel.unsubscribe() in dispose()"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "8.2",
          "title": "Module 8, Lesson 2: Firebase Authentication",
          "moduleId": "module-08",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll know how to implement user registration and login using Firebase Authentication with both email/password and Google Sign-In.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**User authentication is the foundation of most apps.**\n\n- **93% of apps** require users to create accounts\n- **Secure authentication** protects user data and prevents unauthorized access\n- **Firebase Auth** handles the complex security for you\n- **Social login** (Google, Apple) increases signup rates by 50%\n\nIn this lesson, you'll learn to build a complete authentication system that's both secure and user-friendly.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Hotel Check-In",
              "content": "\n### Without Authentication\nImagine a hotel where anyone can:\n- üö™ Enter any room\n- üìù Access anyone's information\n- üí≥ See anyone's billing\n- üîë No keys needed\n\n**This would be chaos!**\n\n### With Authentication\nProper hotel check-in:\n1. **Register** (first visit): Show ID, get a room key\n2. **Login** (returning guest): Show ID, get your key\n3. **Your Room Only**: Your key only opens YOUR room\n4. **Session**: Key works for duration of your stay\n5. **Logout** (checkout): Return key, can't access room anymore\n\n**Firebase Authentication is your app's hotel check-in system.**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Firebase Authentication Overview",
              "content": "\nFirebase Authentication provides:\n\n### Built-In Methods\n- üìß Email & Password\n- üì± Phone Number (SMS)\n- üîó Anonymous (guest access)\n- üîÑ Custom Authentication\n\n### Social Login Providers\n- üîµ Google\n- üçé Apple\n- üìò Facebook\n- üê¶ Twitter/X\n- üîó Microsoft\n- üì∑ GitHub\n\n### Security Features\n- ‚úÖ Secure password hashing\n- ‚úÖ Email verification\n- ‚úÖ Password reset\n- ‚úÖ Account linking\n- ‚úÖ Multi-factor authentication (MFA)\n- ‚úÖ Session management\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Firebase Authentication",
              "content": "\n### Step 1: Enable Authentication in Firebase Console\n\n1. Go to https://console.firebase.google.com\n2. Select your project\n3. Click **\"Authentication\"** in left sidebar\n4. Click **\"Get started\"**\n5. Click **\"Sign-in method\"** tab\n6. Enable **\"Email/Password\"**\n7. Enable **\"Google\"** (we'll use this later)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Email & Password Authentication",
              "content": "\n### Add Firebase Auth Package\n\nAlready added in previous lesson, but verify in `pubspec.yaml`:\n\n\n",
              "code": "dependencies:\n  flutter:\n    sdk: flutter\n  firebase_core: ^4.2.0\n  firebase_auth: ^6.1.1",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Create Auth Service\n\n\n",
              "code": "// lib/services/auth_service.dart\nimport 'package:firebase_auth/firebase_auth.dart';\n\nclass AuthService {\n  final FirebaseAuth _auth = FirebaseAuth.instance;\n\n  // Get current user\n  User? get currentUser => _auth.currentUser;\n\n  // Auth state changes (stream of user)\n  Stream<User?> get authStateChanges => _auth.authStateChanges();\n\n  // Register with email and password\n  Future<User?> registerWithEmail({\n    required String email,\n    required String password,\n  }) async {\n    try {\n      final UserCredential result = await _auth.createUserWithEmailAndPassword(\n        email: email,\n        password: password,\n      );\n      return result.user;\n    } on FirebaseAuthException catch (e) {\n      throw _handleAuthException(e);\n    }\n  }\n\n  // Login with email and password\n  Future<User?> loginWithEmail({\n    required String email,\n    required String password,\n  }) async {\n    try {\n      final UserCredential result = await _auth.signInWithEmailAndPassword(\n        email: email,\n        password: password,\n      );\n      return result.user;\n    } on FirebaseAuthException catch (e) {\n      throw _handleAuthException(e);\n    }\n  }\n\n  // Logout\n  Future<void> logout() async {\n    await _auth.signOut();\n  }\n\n  // Send email verification\n  Future<void> sendEmailVerification() async {\n    final user = _auth.currentUser;\n    if (user != null && !user.emailVerified) {\n      await user.sendEmailVerification();\n    }\n  }\n\n  // Send password reset email\n  Future<void> sendPasswordResetEmail(String email) async {\n    try {\n      await _auth.sendPasswordResetEmail(email);\n    } on FirebaseAuthException catch (e) {\n      throw _handleAuthException(e);\n    }\n  }\n\n  // Delete account\n  Future<void> deleteAccount() async {\n    final user = _auth.currentUser;\n    if (user != null) {\n      await user.delete();\n    }\n  }\n\n  // Handle Firebase Auth exceptions\n  String _handleAuthException(FirebaseAuthException e) {\n    switch (e.code) {\n      case 'weak-password':\n        return 'Password is too weak. Use at least 6 characters.';\n      case 'email-already-in-use':\n        return 'An account with this email already exists.';\n      case 'invalid-email':\n        return 'Invalid email address.';\n      case 'user-not-found':\n        return 'No account found with this email.';\n      case 'wrong-password':\n        return 'Incorrect password.';\n      case 'user-disabled':\n        return 'This account has been disabled.';\n      case 'too-many-requests':\n        return 'Too many attempts. Try again later.';\n      case 'operation-not-allowed':\n        return 'This sign-in method is not enabled.';\n      default:\n        return 'Authentication error: ${e.message}';\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Create Register Screen\n\n\n",
              "code": "// lib/screens/auth/register_screen.dart\nimport 'package:flutter/material.dart';\nimport '../../services/auth_service.dart';\nimport 'login_screen.dart';\n\nclass RegisterScreen extends StatefulWidget {\n  const RegisterScreen({super.key});\n\n  @override\n  State<RegisterScreen> createState() => _RegisterScreenState();\n}\n\nclass _RegisterScreenState extends State<RegisterScreen> {\n  final _authService = AuthService();\n  final _formKey = GlobalKey<FormState>();\n  final _emailController = TextEditingController();\n  final _passwordController = TextEditingController();\n  final _confirmPasswordController = TextEditingController();\n\n  bool _isLoading = false;\n  bool _obscurePassword = true;\n  bool _obscureConfirmPassword = true;\n\n  @override\n  void dispose() {\n    _emailController.dispose();\n    _passwordController.dispose();\n    _confirmPasswordController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _handleRegister() async {\n    if (!_formKey.currentState!.validate()) return;\n\n    setState(() => _isLoading = true);\n\n    try {\n      await _authService.registerWithEmail(\n        email: _emailController.text.trim(),\n        password: _passwordController.text,\n      );\n\n      // Send verification email\n      await _authService.sendEmailVerification();\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(\n            content: Text('Registration successful! Please verify your email.'),\n          ),\n        );\n\n        // Navigate to login\n        Navigator.of(context).pushReplacement(\n          MaterialPageRoute(builder: (_) => const LoginScreen()),\n        );\n      }\n    } catch (e) {\n      setState(() => _isLoading = false);\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text(e.toString())),\n        );\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SafeArea(\n        child: SingleChildScrollView(\n          padding: const EdgeInsets.all(24.0),\n          child: Form(\n            key: _formKey,\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.stretch,\n              children: [\n                const SizedBox(height: 48),\n\n                // Title\n                Text(\n                  'Create Account',\n                  style: Theme.of(context).textTheme.headlineLarge,\n                  textAlign: TextAlign.center,\n                ),\n                const SizedBox(height: 8),\n                Text(\n                  'Sign up to get started',\n                  style: TextStyle(color: Colors.grey.shade600),\n                  textAlign: TextAlign.center,\n                ),\n                const SizedBox(height: 48),\n\n                // Email field\n                TextFormField(\n                  controller: _emailController,\n                  decoration: const InputDecoration(\n                    labelText: 'Email',\n                    prefixIcon: Icon(Icons.email),\n                    border: OutlineInputBorder(),\n                  ),\n                  keyboardType: TextInputType.emailAddress,\n                  enabled: !_isLoading,\n                  validator: (value) {\n                    if (value == null || value.isEmpty) {\n                      return 'Please enter your email';\n                    }\n                    if (!value.contains('@')) {\n                      return 'Please enter a valid email';\n                    }\n                    return null;\n                  },\n                ),\n                const SizedBox(height: 16),\n\n                // Password field\n                TextFormField(\n                  controller: _passwordController,\n                  obscureText: _obscurePassword,\n                  decoration: InputDecoration(\n                    labelText: 'Password',\n                    prefixIcon: const Icon(Icons.lock),\n                    border: const OutlineInputBorder(),\n                    suffixIcon: IconButton(\n                      icon: Icon(\n                        _obscurePassword ? Icons.visibility : Icons.visibility_off,\n                      ),\n                      onPressed: () {\n                        setState(() => _obscurePassword = !_obscurePassword);\n                      },\n                    ),\n                  ),\n                  enabled: !_isLoading,\n                  validator: (value) {\n                    if (value == null || value.isEmpty) {\n                      return 'Please enter a password';\n                    }\n                    if (value.length < 6) {\n                      return 'Password must be at least 6 characters';\n                    }\n                    return null;\n                  },\n                ),\n                const SizedBox(height: 16),\n\n                // Confirm password field\n                TextFormField(\n                  controller: _confirmPasswordController,\n                  obscureText: _obscureConfirmPassword,\n                  decoration: InputDecoration(\n                    labelText: 'Confirm Password',\n                    prefixIcon: const Icon(Icons.lock_outline),\n                    border: const OutlineInputBorder(),\n                    suffixIcon: IconButton(\n                      icon: Icon(\n                        _obscureConfirmPassword ? Icons.visibility : Icons.visibility_off,\n                      ),\n                      onPressed: () {\n                        setState(() => _obscureConfirmPassword = !_obscureConfirmPassword);\n                      },\n                    ),\n                  ),\n                  enabled: !_isLoading,\n                  validator: (value) {\n                    if (value == null || value.isEmpty) {\n                      return 'Please confirm your password';\n                    }\n                    if (value != _passwordController.text) {\n                      return 'Passwords do not match';\n                    }\n                    return null;\n                  },\n                ),\n                const SizedBox(height: 24),\n\n                // Register button\n                FilledButton(\n                  onPressed: _isLoading ? null : _handleRegister,\n                  style: FilledButton.styleFrom(\n                    padding: const EdgeInsets.symmetric(vertical: 16),\n                  ),\n                  child: _isLoading\n                      ? const SizedBox(\n                          height: 20,\n                          width: 20,\n                          child: CircularProgressIndicator(strokeWidth: 2),\n                        )\n                      : const Text('Register'),\n                ),\n\n                const SizedBox(height: 16),\n\n                // Login link\n                TextButton(\n                  onPressed: _isLoading\n                      ? null\n                      : () {\n                          Navigator.of(context).pushReplacement(\n                            MaterialPageRoute(builder: (_) => const LoginScreen()),\n                          );\n                        },\n                  child: const Text('Already have an account? Login'),\n                ),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Create Login Screen\n\n\n",
              "code": "// lib/screens/auth/login_screen.dart\nimport 'package:flutter/material.dart';\nimport '../../services/auth_service.dart';\nimport '../home/home_screen.dart';\nimport 'register_screen.dart';\nimport 'forgot_password_screen.dart';\n\nclass LoginScreen extends StatefulWidget {\n  const LoginScreen({super.key});\n\n  @override\n  State<LoginScreen> createState() => _LoginScreenState();\n}\n\nclass _LoginScreenState extends State<LoginScreen> {\n  final _authService = AuthService();\n  final _formKey = GlobalKey<FormState>();\n  final _emailController = TextEditingController();\n  final _passwordController = TextEditingController();\n\n  bool _isLoading = false;\n  bool _obscurePassword = true;\n\n  @override\n  void dispose() {\n    _emailController.dispose();\n    _passwordController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _handleLogin() async {\n    if (!_formKey.currentState!.validate()) return;\n\n    setState(() => _isLoading = true);\n\n    try {\n      await _authService.loginWithEmail(\n        email: _emailController.text.trim(),\n        password: _passwordController.text,\n      );\n\n      if (mounted) {\n        Navigator.of(context).pushReplacement(\n          MaterialPageRoute(builder: (_) => const HomeScreen()),\n        );\n      }\n    } catch (e) {\n      setState(() => _isLoading = false);\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text(e.toString())),\n        );\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SafeArea(\n        child: SingleChildScrollView(\n          padding: const EdgeInsets.all(24.0),\n          child: Form(\n            key: _formKey,\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.stretch,\n              children: [\n                const SizedBox(height: 48),\n\n                // Title\n                Text(\n                  'Welcome Back',\n                  style: Theme.of(context).textTheme.headlineLarge,\n                  textAlign: TextAlign.center,\n                ),\n                const SizedBox(height: 8),\n                Text(\n                  'Login to your account',\n                  style: TextStyle(color: Colors.grey.shade600),\n                  textAlign: TextAlign.center,\n                ),\n                const SizedBox(height: 48),\n\n                // Email field\n                TextFormField(\n                  controller: _emailController,\n                  decoration: const InputDecoration(\n                    labelText: 'Email',\n                    prefixIcon: Icon(Icons.email),\n                    border: OutlineInputBorder(),\n                  ),\n                  keyboardType: TextInputType.emailAddress,\n                  enabled: !_isLoading,\n                  validator: (value) {\n                    if (value == null || value.isEmpty) {\n                      return 'Please enter your email';\n                    }\n                    return null;\n                  },\n                ),\n                const SizedBox(height: 16),\n\n                // Password field\n                TextFormField(\n                  controller: _passwordController,\n                  obscureText: _obscurePassword,\n                  decoration: InputDecoration(\n                    labelText: 'Password',\n                    prefixIcon: const Icon(Icons.lock),\n                    border: const OutlineInputBorder(),\n                    suffixIcon: IconButton(\n                      icon: Icon(\n                        _obscurePassword ? Icons.visibility : Icons.visibility_off,\n                      ),\n                      onPressed: () {\n                        setState(() => _obscurePassword = !_obscurePassword);\n                      },\n                    ),\n                  ),\n                  enabled: !_isLoading,\n                  validator: (value) {\n                    if (value == null || value.isEmpty) {\n                      return 'Please enter your password';\n                    }\n                    return null;\n                  },\n                  onFieldSubmitted: (_) => _handleLogin(),\n                ),\n\n                // Forgot password link\n                Align(\n                  alignment: Alignment.centerRight,\n                  child: TextButton(\n                    onPressed: _isLoading\n                        ? null\n                        : () {\n                            Navigator.of(context).push(\n                              MaterialPageRoute(\n                                builder: (_) => const ForgotPasswordScreen(),\n                              ),\n                            );\n                          },\n                    child: const Text('Forgot Password?'),\n                  ),\n                ),\n\n                const SizedBox(height: 8),\n\n                // Login button\n                FilledButton(\n                  onPressed: _isLoading ? null : _handleLogin,\n                  style: FilledButton.styleFrom(\n                    padding: const EdgeInsets.symmetric(vertical: 16),\n                  ),\n                  child: _isLoading\n                      ? const SizedBox(\n                          height: 20,\n                          width: 20,\n                          child: CircularProgressIndicator(strokeWidth: 2),\n                        )\n                      : const Text('Login'),\n                ),\n\n                const SizedBox(height: 16),\n\n                // Register link\n                TextButton(\n                  onPressed: _isLoading\n                      ? null\n                      : () {\n                          Navigator.of(context).pushReplacement(\n                            MaterialPageRoute(\n                              builder: (_) => const RegisterScreen(),\n                            ),\n                          );\n                        },\n                  child: const Text('Don\\'t have an account? Register'),\n                ),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Create Forgot Password Screen\n\n\n",
              "code": "// lib/screens/auth/forgot_password_screen.dart\nimport 'package:flutter/material.dart';\nimport '../../services/auth_service.dart';\n\nclass ForgotPasswordScreen extends StatefulWidget {\n  const ForgotPasswordScreen({super.key});\n\n  @override\n  State<ForgotPasswordScreen> createState() => _ForgotPasswordScreenState();\n}\n\nclass _ForgotPasswordScreenState extends State<ForgotPasswordScreen> {\n  final _authService = AuthService();\n  final _emailController = TextEditingController();\n  bool _isLoading = false;\n  bool _emailSent = false;\n\n  @override\n  void dispose() {\n    _emailController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _handleResetPassword() async {\n    if (_emailController.text.trim().isEmpty) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text('Please enter your email')),\n      );\n      return;\n    }\n\n    setState(() => _isLoading = true);\n\n    try {\n      await _authService.sendPasswordResetEmail(_emailController.text.trim());\n\n      setState(() {\n        _isLoading = false;\n        _emailSent = true;\n      });\n    } catch (e) {\n      setState(() => _isLoading = false);\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text(e.toString())),\n        );\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Reset Password'),\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(24.0),\n        child: _emailSent\n            ? _buildSuccessView()\n            : _buildFormView(),\n      ),\n    );\n  }\n\n  Widget _buildFormView() {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.stretch,\n      children: [\n        const SizedBox(height: 24),\n        Text(\n          'Enter your email address and we\\'ll send you instructions to reset your password.',\n          style: TextStyle(color: Colors.grey.shade700),\n        ),\n        const SizedBox(height: 32),\n\n        TextFormField(\n          controller: _emailController,\n          decoration: const InputDecoration(\n            labelText: 'Email',\n            prefixIcon: Icon(Icons.email),\n            border: OutlineInputBorder(),\n          ),\n          keyboardType: TextInputType.emailAddress,\n          enabled: !_isLoading,\n        ),\n        const SizedBox(height: 24),\n\n        FilledButton(\n          onPressed: _isLoading ? null : _handleResetPassword,\n          style: FilledButton.styleFrom(\n            padding: const EdgeInsets.symmetric(vertical: 16),\n          ),\n          child: _isLoading\n              ? const SizedBox(\n                  height: 20,\n                  width: 20,\n                  child: CircularProgressIndicator(strokeWidth: 2),\n                )\n              : const Text('Send Reset Link'),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildSuccessView() {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      crossAxisAlignment: CrossAxisAlignment.stretch,\n      children: [\n        Icon(\n          Icons.mark_email_read,\n          size: 100,\n          color: Colors.green.shade600,\n        ),\n        const SizedBox(height: 24),\n        const Text(\n          'Email Sent!',\n          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n          textAlign: TextAlign.center,\n        ),\n        const SizedBox(height: 16),\n        Text(\n          'Check your inbox for password reset instructions.',\n          style: TextStyle(color: Colors.grey.shade700),\n          textAlign: TextAlign.center,\n        ),\n        const SizedBox(height: 32),\n        FilledButton(\n          onPressed: () => Navigator.of(context).pop(),\n          child: const Text('Back to Login'),\n        ),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Create Home Screen with Logout\n\n\n",
              "code": "// lib/screens/home/home_screen.dart\nimport 'package:flutter/material.dart';\nimport '../../services/auth_service.dart';\nimport '../auth/login_screen.dart';\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final authService = AuthService();\n    final user = authService.currentUser;\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Home'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.logout),\n            tooltip: 'Logout',\n            onPressed: () async {\n              await authService.logout();\n              if (context.mounted) {\n                Navigator.of(context).pushReplacement(\n                  MaterialPageRoute(builder: (_) => const LoginScreen()),\n                );\n              }\n            },\n          ),\n        ],\n      ),\n      body: Center(\n        child: Padding(\n          padding: const EdgeInsets.all(24.0),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              CircleAvatar(\n                radius: 50,\n                backgroundColor: Colors.blue.shade100,\n                child: Icon(\n                  Icons.person,\n                  size: 60,\n                  color: Colors.blue.shade700,\n                ),\n              ),\n              const SizedBox(height: 24),\n              Text(\n                'Welcome!',\n                style: Theme.of(context).textTheme.headlineMedium,\n              ),\n              const SizedBox(height: 16),\n              Container(\n                padding: const EdgeInsets.all(16),\n                decoration: BoxDecoration(\n                  color: Colors.grey.shade100,\n                  borderRadius: BorderRadius.circular(12),\n                ),\n                child: Column(\n                  children: [\n                    _buildInfoRow('Email', user?.email ?? 'Unknown'),\n                    const Divider(height: 24),\n                    _buildInfoRow('User ID', user?.uid ?? 'Unknown'),\n                    const Divider(height: 24),\n                    _buildInfoRow(\n                      'Email Verified',\n                      user?.emailVerified == true ? 'Yes ‚úì' : 'No ‚úó',\n                    ),\n                  ],\n                ),\n              ),\n              if (user?.emailVerified == false) ...[\n                const SizedBox(height: 24),\n                OutlinedButton.icon(\n                  onPressed: () async {\n                    await authService.sendEmailVerification();\n                    if (context.mounted) {\n                      ScaffoldMessenger.of(context).showSnackBar(\n                        const SnackBar(\n                          content: Text('Verification email sent! Check your inbox.'),\n                        ),\n                      );\n                    }\n                  },\n                  icon: const Icon(Icons.email),\n                  label: const Text('Verify Email'),\n                ),\n              ],\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _buildInfoRow(String label, String value) {\n    return Row(\n      mainAxisAlignment: MainAxisAlignment.spaceBetween,\n      children: [\n        Text(\n          label,\n          style: const TextStyle(fontWeight: FontWeight.w600),\n        ),\n        Flexible(\n          child: Text(\n            value,\n            textAlign: TextAlign.end,\n            overflow: TextOverflow.ellipsis,\n          ),\n        ),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Update main.dart with Auth State\n\n\n",
              "code": "// lib/main.dart\nimport 'package:flutter/material.dart';\nimport 'package:firebase_core/firebase_core.dart';\nimport 'firebase_options.dart';\nimport 'services/auth_service.dart';\nimport 'screens/auth/login_screen.dart';\nimport 'screens/home/home_screen.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await Firebase.initializeApp(\n    options: DefaultFirebaseOptions.currentPlatform,\n  );\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Firebase Auth Demo',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),\n        useMaterial3: true,\n      ),\n      home: const AuthWrapper(),\n    );\n  }\n}\n\n// Listen to auth state changes\nclass AuthWrapper extends StatelessWidget {\n  const AuthWrapper({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final authService = AuthService();\n\n    return StreamBuilder(\n      stream: authService.authStateChanges,\n      builder: (context, snapshot) {\n        // Loading state\n        if (snapshot.connectionState == ConnectionState.waiting) {\n          return const Scaffold(\n            body: Center(child: CircularProgressIndicator()),\n          );\n        }\n\n        // User is logged in\n        if (snapshot.hasData && snapshot.data != null) {\n          return const HomeScreen();\n        }\n\n        // User is not logged in\n        return const LoginScreen();\n      },\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Testing Email/Password Auth",
              "content": "\n1. **Run the app**: `flutter run`\n2. **Register**: Create an account with email and password\n3. **Check Firebase Console**: Go to Authentication ‚Üí Users, you should see your new user\n4. **Verify email**: Check your email inbox for verification link\n5. **Login**: Try logging in with your credentials\n6. **Logout**: Click logout button\n7. **Forgot password**: Test password reset flow\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Google Sign-In",
              "content": "\n### Setup Google Sign-In\n\n#### 1. Add Package\n\n\nRun:\n\n#### 2. Android Configuration\n\nEdit `android/app/build.gradle`:\n\n\n**Get SHA-1 fingerprint:**\n\n**Add to Firebase Console**:\n1. Go to Project Settings ‚Üí Your apps ‚Üí Android app\n2. Click \"Add fingerprint\"\n3. Paste SHA-1 fingerprint\n\n#### 3. iOS Configuration\n\nEdit `ios/Runner/Info.plist`:\n\n\nReplace `YOUR-CLIENT-ID` with your client ID from `GoogleService-Info.plist`.\n\n#### 4. Get OAuth Client ID\n\nDownload `google-services.json` (Android) and `GoogleService-Info.plist` (iOS) from Firebase Console ‚Üí Project Settings ‚Üí Your apps.\n\n",
              "code": "<key>CFBundleURLTypes</key>\n<array>\n  <dict>\n    <key>CFBundleTypeRole</key>\n    <string>Editor</string>\n    <key>CFBundleURLSchemes</key>\n    <array>\n      <string>com.googleusercontent.apps.YOUR-CLIENT-ID</string>\n    </array>\n  </dict>\n</array>",
              "language": "xml"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Update Auth Service for Google Sign-In\n\n\n",
              "code": "// lib/services/auth_service.dart (add these methods)\nimport 'package:google_sign_in/google_sign_in.dart';\n\nclass AuthService {\n  final FirebaseAuth _auth = FirebaseAuth.instance;\n  final GoogleSignIn _googleSignIn = GoogleSignIn();\n\n  // ... previous methods ...\n\n  // Sign in with Google\n  Future<User?> signInWithGoogle() async {\n    try {\n      // Trigger the authentication flow\n      final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();\n\n      if (googleUser == null) {\n        // User canceled the sign-in\n        return null;\n      }\n\n      // Obtain the auth details from the request\n      final GoogleSignInAuthentication googleAuth = await googleUser.authentication;\n\n      // Create a new credential\n      final credential = GoogleAuthProvider.credential(\n        accessToken: googleAuth.accessToken,\n        idToken: googleAuth.idToken,\n      );\n\n      // Sign in to Firebase with the Google credential\n      final UserCredential result = await _auth.signInWithCredential(credential);\n      return result.user;\n    } catch (e) {\n      throw 'Google Sign-In failed: $e';\n    }\n  }\n\n  // Sign out from both Firebase and Google\n  @override\n  Future<void> logout() async {\n    await Future.wait([\n      _auth.signOut(),\n      _googleSignIn.signOut(),\n    ]);\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Add Google Sign-In Button to Login Screen\n\n\nAdd the method:\n\n\n",
              "code": "Future<void> _handleGoogleSignIn() async {\n  setState(() => _isLoading = true);\n\n  try {\n    final user = await _authService.signInWithGoogle();\n\n    if (user != null && mounted) {\n      Navigator.of(context).pushReplacement(\n        MaterialPageRoute(builder: (_) => const HomeScreen()),\n      );\n    } else {\n      setState(() => _isLoading = false);\n    }\n  } catch (e) {\n    setState(() => _isLoading = false);\n\n    if (mounted) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text(e.toString())),\n      );\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Testing Complete",
              "content": "\nRun your app and test:\n1. ‚úÖ Register with email/password\n2. ‚úÖ Login with email/password\n3. ‚úÖ Sign in with Google\n4. ‚úÖ Password reset\n5. ‚úÖ Email verification\n6. ‚úÖ Logout\n\n**Check Firebase Console ‚Üí Authentication ‚Üí Users** to see all registered users!\n\n"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### ‚úÖ DO:\n1. **Always validate input** (email format, password strength)\n2. **Show user-friendly error messages** (not technical Firebase codes)\n3. **Verify emails** before allowing sensitive actions\n4. **Use StreamBuilder** for auth state changes\n5. **Handle loading states** (show spinners)\n6. **Test on real devices** (not just emulator)\n\n### ‚ùå DON'T:\n1. **Don't store passwords** in your app (Firebase handles this)\n2. **Don't show raw error codes** to users\n3. **Don't allow weak passwords** (< 6 characters)\n4. **Don't forget to sign out** from social providers too\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhy should you verify email addresses?\n\nA) It's required by Firebase\nB) To ensure users own the email and can recover their account\nC) It makes the app faster\nD) To collect user data\n\n### Question 2\nWhat happens when you call `authStateChanges()`?\n\nA) It checks the user's password\nB) It returns a Stream that emits whenever the user signs in or out\nC) It deletes the user\nD) It sends a verification email\n\n### Question 3\nWhy use Google Sign-In in addition to email/password?\n\nA) It's free\nB) It increases signup rates (50%+) and provides better UX\nC) It's more secure\nD) Firebase requires it\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: To ensure users own the email and can recover their account\n\nEmail verification confirms the user has access to the email address they provided. This prevents fake accounts, enables password recovery, and ensures you can communicate with users.\n\n### Answer 2: B\n**Correct**: It returns a Stream that emits whenever the user signs in or out\n\n`authStateChanges()` returns a Stream<User?> that automatically updates when authentication state changes. Use it with StreamBuilder to automatically show login/home screens based on auth status.\n\n### Answer 3: B\n**Correct**: It increases signup rates (50%+) and provides better UX\n\nSocial login reduces friction (no password to remember), increases trust (familiar Google logo), and significantly improves conversion rates. Users are 50% more likely to complete signup with social login.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've implemented complete authentication! In the next lesson, we'll learn **Cloud Firestore** - Firebase's powerful NoSQL database to store and sync data.\n\n**Coming up in Lesson 3: Cloud Firestore**\n- CRUD operations (Create, Read, Update, Delete)\n- Real-time data synchronization\n- Querying and filtering\n- Collections and documents\n- Complete app with Firestore\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Firebase Auth handles security, encryption, and session management\n‚úÖ Email verification is critical for account security\n‚úÖ StreamBuilder automatically updates UI based on auth state\n‚úÖ Social login (Google) improves signup rates by 50%\n‚úÖ Always show user-friendly error messages\n‚úÖ FirebaseAuth provides authStateChanges() stream for reactive UI\n‚úÖ Sign out from both Firebase and social providers on logout\n\n**You can now build apps with secure user authentication!** üîê\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "8.3",
          "title": "Module 8, Lesson 3: Cloud Firestore - Database Operations",
          "moduleId": "module-08",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll know how to store, retrieve, update, and delete data using Cloud Firestore - Firebase's powerful NoSQL cloud database with real-time synchronization.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Every app needs to store data.**\n\n- **Instagram**: Stores billions of posts, comments, likes\n- **Twitter**: Real-time tweets synced across devices\n- **Spotify**: Playlists, listening history, preferences\n- **Without a database**, your app loses all data when closed\n- **99% of apps** use a database to persist user data\n\nCloud Firestore is Google's modern database that automatically syncs data across all devices in real-time.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Filing Cabinet System",
              "content": "\n### Traditional SQL Database = Spreadsheet\nData stored in rigid tables with rows and columns:\n\n**Problem**: Adding a new field (e.g., \"Phone Number\") requires updating the entire table structure.\n\n### NoSQL Database (Firestore) = Filing Cabinet\nData stored as flexible documents in folders:\n\n**Benefits**:\n- ‚úÖ Each document can have different fields\n- ‚úÖ Easy to add new data without restructuring\n- ‚úÖ Hierarchical organization (like folders and subfolders)\n\n",
              "code": "users/ (Collection = Folder)\n  ‚îú‚îÄ‚îÄ alice123/ (Document = File)\n  ‚îÇ   ‚îú‚îÄ‚îÄ name: \"Alice\"\n  ‚îÇ   ‚îú‚îÄ‚îÄ email: \"alice@mail.com\"\n  ‚îÇ   ‚îú‚îÄ‚îÄ age: 25\n  ‚îÇ   ‚îî‚îÄ‚îÄ favoriteColor: \"blue\"  ‚Üê Can add unique fields!\n  ‚îÇ\n  ‚îî‚îÄ‚îÄ bob456/ (Document = File)\n      ‚îú‚îÄ‚îÄ name: \"Bob\"\n      ‚îú‚îÄ‚îÄ email: \"bob@mail.com\"\n      ‚îî‚îÄ‚îÄ age: 30",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Firestore Structure",
              "content": "\n### Collections and Documents\n\n\n**Key Concepts**:\n- **Collection**: Container for documents (like a folder)\n- **Document**: Individual record with key-value pairs (like a file)\n- **Documents must be inside collections** (alternating structure)\n- **Documents can contain subcollections**\n\n",
              "code": "firestore_database/\n‚îú‚îÄ‚îÄ users/ (Collection)\n‚îÇ   ‚îú‚îÄ‚îÄ user123/ (Document)\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ name: \"Alice\"\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ email: \"alice@example.com\"\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ posts/ (Subcollection)\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ post1/ (Document)\n‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ title: \"My First Post\"\n‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ content: \"Hello world!\"\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ post2/ (Document)\n‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ title: \"Second Post\"\n‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ content: \"Still learning!\"\n‚îÇ   ‚îÇ\n‚îÇ   ‚îî‚îÄ‚îÄ user456/ (Document)\n‚îÇ       ‚îú‚îÄ‚îÄ name: \"Bob\"\n‚îÇ       ‚îî‚îÄ‚îÄ email: \"bob@example.com\"\n‚îÇ\n‚îî‚îÄ‚îÄ posts/ (Collection)\n    ‚îú‚îÄ‚îÄ post123/ (Document)\n    ‚îÇ   ‚îú‚îÄ‚îÄ title: \"Flutter is Amazing\"\n    ‚îÇ   ‚îú‚îÄ‚îÄ authorId: \"user123\"\n    ‚îÇ   ‚îî‚îÄ‚îÄ likes: 42\n    ‚îî‚îÄ‚îÄ post456/ (Document)\n        ‚îú‚îÄ‚îÄ title: \"Learning Firestore\"\n        ‚îú‚îÄ‚îÄ authorId: \"user456\"\n        ‚îî‚îÄ‚îÄ likes: 15",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Firestore",
              "content": "\n### 1. Enable Firestore in Firebase Console\n\n1. Go to https://console.firebase.google.com\n2. Select your project\n3. Click **\"Firestore Database\"** in left sidebar\n4. Click **\"Create database\"**\n5. **Select mode**:\n   - **Test mode** (for learning): Anyone can read/write (insecure!)\n   - **Production mode**: Requires security rules (recommended)\n6. Choose location (select closest to your users)\n7. Click **\"Enable\"**\n\n### 2. Verify Package in pubspec.yaml\n\n\nRun:\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "CRUD Operations (Create, Read, Update, Delete)",
              "content": "\n### Create a Model Class\n\n\n",
              "code": "// lib/models/task.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\n\nclass Task {\n  final String? id; // Firestore document ID\n  final String title;\n  final String description;\n  final bool isCompleted;\n  final DateTime createdAt;\n  final String userId;\n\n  Task({\n    this.id,\n    required this.title,\n    required this.description,\n    this.isCompleted = false,\n    DateTime? createdAt,\n    required this.userId,\n  }) : createdAt = createdAt ?? DateTime.now();\n\n  // Convert Task to Map (for Firestore)\n  Map<String, dynamic> toMap() {\n    return {\n      'title': title,\n      'description': description,\n      'isCompleted': isCompleted,\n      'createdAt': Timestamp.fromDate(createdAt),\n      'userId': userId,\n    };\n  }\n\n  // Create Task from Firestore DocumentSnapshot\n  factory Task.fromFirestore(DocumentSnapshot doc) {\n    final data = doc.data() as Map<String, dynamic>;\n    return Task(\n      id: doc.id,\n      title: data['title'] ?? '',\n      description: data['description'] ?? '',\n      isCompleted: data['isCompleted'] ?? false,\n      createdAt: (data['createdAt'] as Timestamp).toDate(),\n      userId: data['userId'] ?? '',\n    );\n  }\n\n  // Create Task from Map\n  factory Task.fromMap(Map<String, dynamic> map, String id) {\n    return Task(\n      id: id,\n      title: map['title'] ?? '',\n      description: map['description'] ?? '',\n      isCompleted: map['isCompleted'] ?? false,\n      createdAt: (map['createdAt'] as Timestamp).toDate(),\n      userId: map['userId'] ?? '',\n    );\n  }\n\n  // Copy with method (useful for updates)\n  Task copyWith({\n    String? id,\n    String? title,\n    String? description,\n    bool? isCompleted,\n    DateTime? createdAt,\n    String? userId,\n  }) {\n    return Task(\n      id: id ?? this.id,\n      title: title ?? this.title,\n      description: description ?? this.description,\n      isCompleted: isCompleted ?? this.isCompleted,\n      createdAt: createdAt ?? this.createdAt,\n      userId: userId ?? this.userId,\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Create Firestore Service\n\n\n",
              "code": "// lib/services/firestore_service.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport '../models/task.dart';\n\nclass FirestoreService {\n  final FirebaseFirestore _firestore = FirebaseFirestore.instance;\n\n  // Reference to tasks collection\n  CollectionReference get _tasksCollection => _firestore.collection('tasks');\n\n  // ========== CREATE ==========\n\n  // Add a new task\n  Future<String> createTask(Task task) async {\n    try {\n      final docRef = await _tasksCollection.add(task.toMap());\n      return docRef.id; // Return the generated document ID\n    } catch (e) {\n      throw 'Failed to create task: $e';\n    }\n  }\n\n  // Add task with custom ID\n  Future<void> createTaskWithId(String id, Task task) async {\n    try {\n      await _tasksCollection.doc(id).set(task.toMap());\n    } catch (e) {\n      throw 'Failed to create task: $e';\n    }\n  }\n\n  // ========== READ ==========\n\n  // Get single task by ID\n  Future<Task?> getTask(String taskId) async {\n    try {\n      final doc = await _tasksCollection.doc(taskId).get();\n\n      if (doc.exists) {\n        return Task.fromFirestore(doc);\n      }\n      return null;\n    } catch (e) {\n      throw 'Failed to get task: $e';\n    }\n  }\n\n  // Get all tasks for a user (returns Future)\n  Future<List<Task>> getUserTasks(String userId) async {\n    try {\n      final querySnapshot = await _tasksCollection\n          .where('userId', isEqualTo: userId)\n          .orderBy('createdAt', descending: true)\n          .get();\n\n      return querySnapshot.docs\n          .map((doc) => Task.fromFirestore(doc))\n          .toList();\n    } catch (e) {\n      throw 'Failed to get tasks: $e';\n    }\n  }\n\n  // Get tasks as a Stream (real-time updates!)\n  Stream<List<Task>> getUserTasksStream(String userId) {\n    return _tasksCollection\n        .where('userId', isEqualTo: userId)\n        .orderBy('createdAt', descending: true)\n        .snapshots()\n        .map((snapshot) {\n      return snapshot.docs.map((doc) => Task.fromFirestore(doc)).toList();\n    });\n  }\n\n  // Get completed tasks only\n  Future<List<Task>> getCompletedTasks(String userId) async {\n    try {\n      final querySnapshot = await _tasksCollection\n          .where('userId', isEqualTo: userId)\n          .where('isCompleted', isEqualTo: true)\n          .orderBy('createdAt', descending: true)\n          .get();\n\n      return querySnapshot.docs\n          .map((doc) => Task.fromFirestore(doc))\n          .toList();\n    } catch (e) {\n      throw 'Failed to get completed tasks: $e';\n    }\n  }\n\n  // ========== UPDATE ==========\n\n  // Update entire task\n  Future<void> updateTask(String taskId, Task task) async {\n    try {\n      await _tasksCollection.doc(taskId).update(task.toMap());\n    } catch (e) {\n      throw 'Failed to update task: $e';\n    }\n  }\n\n  // Update specific fields only\n  Future<void> updateTaskFields(String taskId, Map<String, dynamic> fields) async {\n    try {\n      await _tasksCollection.doc(taskId).update(fields);\n    } catch (e) {\n      throw 'Failed to update task fields: $e';\n    }\n  }\n\n  // Toggle task completion\n  Future<void> toggleTaskCompletion(String taskId, bool isCompleted) async {\n    try {\n      await _tasksCollection.doc(taskId).update({\n        'isCompleted': !isCompleted,\n      });\n    } catch (e) {\n      throw 'Failed to toggle task: $e';\n    }\n  }\n\n  // ========== DELETE ==========\n\n  // Delete a task\n  Future<void> deleteTask(String taskId) async {\n    try {\n      await _tasksCollection.doc(taskId).delete();\n    } catch (e) {\n      throw 'Failed to delete task: $e';\n    }\n  }\n\n  // Delete all completed tasks for a user\n  Future<void> deleteCompletedTasks(String userId) async {\n    try {\n      final querySnapshot = await _tasksCollection\n          .where('userId', isEqualTo: userId)\n          .where('isCompleted', isEqualTo: true)\n          .get();\n\n      // Batch delete for efficiency\n      final batch = _firestore.batch();\n      for (var doc in querySnapshot.docs) {\n        batch.delete(doc.reference);\n      }\n      await batch.commit();\n    } catch (e) {\n      throw 'Failed to delete completed tasks: $e';\n    }\n  }\n\n  // ========== ADVANCED QUERIES ==========\n\n  // Search tasks by title\n  Future<List<Task>> searchTasks(String userId, String searchTerm) async {\n    try {\n      final querySnapshot = await _tasksCollection\n          .where('userId', isEqualTo: userId)\n          .where('title', isGreaterThanOrEqualTo: searchTerm)\n          .where('title', isLessThanOrEqualTo: '$searchTerm\\uf8ff')\n          .get();\n\n      return querySnapshot.docs\n          .map((doc) => Task.fromFirestore(doc))\n          .toList();\n    } catch (e) {\n      throw 'Failed to search tasks: $e';\n    }\n  }\n\n  // Get task count for a user\n  Future<int> getTaskCount(String userId) async {\n    try {\n      final querySnapshot = await _tasksCollection\n          .where('userId', isEqualTo: userId)\n          .count()\n          .get();\n\n      return querySnapshot.count ?? 0;\n    } catch (e) {\n      throw 'Failed to get task count: $e';\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Building a Task Manager App",
              "content": "\n### Tasks Screen with StreamBuilder\n\n\n",
              "code": "// lib/screens/tasks/tasks_screen.dart\nimport 'package:flutter/material.dart';\nimport '../../services/firestore_service.dart';\nimport '../../services/auth_service.dart';\nimport '../../models/task.dart';\nimport 'add_task_screen.dart';\n\nclass TasksScreen extends StatefulWidget {\n  const TasksScreen({super.key});\n\n  @override\n  State<TasksScreen> createState() => _TasksScreenState();\n}\n\nclass _TasksScreenState extends State<TasksScreen> {\n  final _firestoreService = FirestoreService();\n  final _authService = AuthService();\n\n  @override\n  Widget build(BuildContext context) {\n    final userId = _authService.currentUser?.uid;\n\n    if (userId == null) {\n      return const Scaffold(\n        body: Center(child: Text('Please login first')),\n      );\n    }\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('My Tasks'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.delete_sweep),\n            tooltip: 'Clear completed',\n            onPressed: () => _clearCompleted(userId),\n          ),\n        ],\n      ),\n      body: StreamBuilder<List<Task>>(\n        stream: _firestoreService.getUserTasksStream(userId),\n        builder: (context, snapshot) {\n          // Loading state\n          if (snapshot.connectionState == ConnectionState.waiting) {\n            return const Center(child: CircularProgressIndicator());\n          }\n\n          // Error state\n          if (snapshot.hasError) {\n            return Center(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  const Icon(Icons.error_outline, size: 64, color: Colors.red),\n                  const SizedBox(height: 16),\n                  Text('Error: ${snapshot.error}'),\n                  const SizedBox(height: 16),\n                  FilledButton(\n                    onPressed: () => setState(() {}),\n                    child: const Text('Retry'),\n                  ),\n                ],\n              ),\n            );\n          }\n\n          // Empty state\n          if (!snapshot.hasData || snapshot.data!.isEmpty) {\n            return Center(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  Icon(\n                    Icons.task_alt,\n                    size: 100,\n                    color: Colors.grey.shade300,\n                  ),\n                  const SizedBox(height: 16),\n                  Text(\n                    'No tasks yet',\n                    style: Theme.of(context).textTheme.headlineSmall?.copyWith(\n                      color: Colors.grey.shade600,\n                    ),\n                  ),\n                  const SizedBox(height: 8),\n                  Text(\n                    'Tap + to create your first task',\n                    style: TextStyle(color: Colors.grey.shade500),\n                  ),\n                ],\n              ),\n            );\n          }\n\n          // Success state with data\n          final tasks = snapshot.data!;\n\n          return ListView.builder(\n            padding: const EdgeInsets.all(16),\n            itemCount: tasks.length,\n            itemBuilder: (context, index) {\n              final task = tasks[index];\n              return _buildTaskCard(task);\n            },\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => _navigateToAddTask(context),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n\n  Widget _buildTaskCard(Task task) {\n    return Card(\n      margin: const EdgeInsets.only(bottom: 12),\n      child: ListTile(\n        leading: Checkbox(\n          value: task.isCompleted,\n          onChanged: (_) => _toggleTask(task),\n        ),\n        title: Text(\n          task.title,\n          style: TextStyle(\n            decoration: task.isCompleted ? TextDecoration.lineThrough : null,\n            color: task.isCompleted ? Colors.grey : null,\n          ),\n        ),\n        subtitle: task.description.isNotEmpty\n            ? Text(\n                task.description,\n                maxLines: 2,\n                overflow: TextOverflow.ellipsis,\n              )\n            : null,\n        trailing: Row(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            // Edit button\n            IconButton(\n              icon: const Icon(Icons.edit),\n              onPressed: () => _editTask(task),\n            ),\n            // Delete button\n            IconButton(\n              icon: const Icon(Icons.delete, color: Colors.red),\n              onPressed: () => _deleteTask(task),\n            ),\n          ],\n        ),\n        onTap: () => _showTaskDetails(task),\n      ),\n    );\n  }\n\n  Future<void> _toggleTask(Task task) async {\n    try {\n      await _firestoreService.toggleTaskCompletion(task.id!, task.isCompleted);\n    } catch (e) {\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Failed to update task: $e')),\n        );\n      }\n    }\n  }\n\n  Future<void> _deleteTask(Task task) async {\n    final confirm = await showDialog<bool>(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: const Text('Delete Task'),\n        content: Text('Delete \"${task.title}\"?'),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(context, false),\n            child: const Text('Cancel'),\n          ),\n          FilledButton(\n            onPressed: () => Navigator.pop(context, true),\n            style: FilledButton.styleFrom(backgroundColor: Colors.red),\n            child: const Text('Delete'),\n          ),\n        ],\n      ),\n    );\n\n    if (confirm == true) {\n      try {\n        await _firestoreService.deleteTask(task.id!);\n        if (mounted) {\n          ScaffoldMessenger.of(context).showSnackBar(\n            const SnackBar(content: Text('Task deleted')),\n          );\n        }\n      } catch (e) {\n        if (mounted) {\n          ScaffoldMessenger.of(context).showSnackBar(\n            SnackBar(content: Text('Failed to delete: $e')),\n          );\n        }\n      }\n    }\n  }\n\n  Future<void> _clearCompleted(String userId) async {\n    try {\n      await _firestoreService.deleteCompletedTasks(userId);\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Completed tasks cleared')),\n        );\n      }\n    } catch (e) {\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Failed to clear: $e')),\n        );\n      }\n    }\n  }\n\n  void _navigateToAddTask(BuildContext context) {\n    Navigator.of(context).push(\n      MaterialPageRoute(builder: (_) => const AddTaskScreen()),\n    );\n  }\n\n  void _editTask(Task task) {\n    Navigator.of(context).push(\n      MaterialPageRoute(builder: (_) => AddTaskScreen(task: task)),\n    );\n  }\n\n  void _showTaskDetails(Task task) {\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: Text(task.title),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            if (task.description.isNotEmpty) ...[\n              Text(task.description),\n              const SizedBox(height: 16),\n            ],\n            Text(\n              'Status: ${task.isCompleted ? \"Completed\" : \"Pending\"}',\n              style: const TextStyle(fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 8),\n            Text(\n              'Created: ${_formatDate(task.createdAt)}',\n              style: TextStyle(color: Colors.grey.shade600),\n            ),\n          ],\n        ),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(context),\n            child: const Text('Close'),\n          ),\n        ],\n      ),\n    );\n  }\n\n  String _formatDate(DateTime date) {\n    return '${date.day}/${date.month}/${date.year} ${date.hour}:${date.minute.toString().padLeft(2, '0')}';\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Add Task Screen\n\n\n",
              "code": "// lib/screens/tasks/add_task_screen.dart\nimport 'package:flutter/material.dart';\nimport '../../services/firestore_service.dart';\nimport '../../services/auth_service.dart';\nimport '../../models/task.dart';\n\nclass AddTaskScreen extends StatefulWidget {\n  final Task? task; // If editing, pass existing task\n\n  const AddTaskScreen({super.key, this.task});\n\n  @override\n  State<AddTaskScreen> createState() => _AddTaskScreenState();\n}\n\nclass _AddTaskScreenState extends State<AddTaskScreen> {\n  final _firestoreService = FirestoreService();\n  final _authService = AuthService();\n  final _formKey = GlobalKey<FormState>();\n  final _titleController = TextEditingController();\n  final _descriptionController = TextEditingController();\n\n  bool _isLoading = false;\n  bool get _isEditing => widget.task != null;\n\n  @override\n  void initState() {\n    super.initState();\n    if (_isEditing) {\n      _titleController.text = widget.task!.title;\n      _descriptionController.text = widget.task!.description;\n    }\n  }\n\n  @override\n  void dispose() {\n    _titleController.dispose();\n    _descriptionController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _saveTask() async {\n    if (!_formKey.currentState!.validate()) return;\n\n    final userId = _authService.currentUser?.uid;\n    if (userId == null) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text('Please login first')),\n      );\n      return;\n    }\n\n    setState(() => _isLoading = true);\n\n    try {\n      final task = Task(\n        id: widget.task?.id,\n        title: _titleController.text.trim(),\n        description: _descriptionController.text.trim(),\n        userId: userId,\n        isCompleted: widget.task?.isCompleted ?? false,\n        createdAt: widget.task?.createdAt,\n      );\n\n      if (_isEditing) {\n        await _firestoreService.updateTask(task.id!, task);\n      } else {\n        await _firestoreService.createTask(task);\n      }\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(\n            content: Text(_isEditing ? 'Task updated!' : 'Task created!'),\n          ),\n        );\n        Navigator.of(context).pop();\n      }\n    } catch (e) {\n      setState(() => _isLoading = false);\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Error: $e')),\n        );\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(_isEditing ? 'Edit Task' : 'Add Task'),\n      ),\n      body: Form(\n        key: _formKey,\n        child: ListView(\n          padding: const EdgeInsets.all(24.0),\n          children: [\n            TextFormField(\n              controller: _titleController,\n              decoration: const InputDecoration(\n                labelText: 'Title',\n                border: OutlineInputBorder(),\n              ),\n              enabled: !_isLoading,\n              validator: (value) {\n                if (value == null || value.trim().isEmpty) {\n                  return 'Please enter a title';\n                }\n                return null;\n              },\n            ),\n            const SizedBox(height: 16),\n            TextFormField(\n              controller: _descriptionController,\n              decoration: const InputDecoration(\n                labelText: 'Description (optional)',\n                border: OutlineInputBorder(),\n                alignLabelWithHint: true,\n              ),\n              maxLines: 5,\n              enabled: !_isLoading,\n            ),\n            const SizedBox(height: 24),\n            FilledButton(\n              onPressed: _isLoading ? null : _saveTask,\n              style: FilledButton.styleFrom(\n                padding: const EdgeInsets.symmetric(vertical: 16),\n              ),\n              child: _isLoading\n                  ? const SizedBox(\n                      height: 20,\n                      width: 20,\n                      child: CircularProgressIndicator(strokeWidth: 2),\n                    )\n                  : Text(_isEditing ? 'Update Task' : 'Create Task'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Testing Your Firestore App",
              "content": "\n1. **Run the app**: `flutter run`\n2. **Create tasks**: Add several tasks\n3. **Check Firebase Console**: Firestore Database ‚Üí View your data\n4. **Real-time sync test**:\n   - Open app on 2 devices/emulators\n   - Create task on device 1\n   - Watch it appear instantly on device 2!\n5. **Test CRUD**: Create, read, update, delete tasks\n\n"
            },
            {
              "type": "THEORY",
              "title": "Firestore Query Operators",
              "content": "\n### Comparison Operators\n\n\n### Ordering and Limiting\n\n\n",
              "code": "// Order by field (ascending)\n.orderBy('createdAt')\n\n// Order descending\n.orderBy('createdAt', descending: true)\n\n// Multiple orderBy\n.orderBy('priority', descending: true)\n.orderBy('createdAt')\n\n// Limit results\n.limit(10)\n\n// Start after document (pagination)\n.startAfterDocument(lastDocument)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Real-Time Updates with Streams",
              "content": "\n**Streams automatically update when data changes!**\n\n### Single Document Stream\n\n\n### Collection Stream\n\n\n**Use with StreamBuilder** for automatic UI updates!\n\n",
              "code": "Stream<List<Task>> getTasksStream() {\n  return _tasksCollection\n      .snapshots()\n      .map((snapshot) {\n        return snapshot.docs\n            .map((doc) => Task.fromFirestore(doc))\n            .toList();\n      });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Batch Operations (Multiple Writes)",
              "content": "\nFor performance, batch multiple writes:\n\n\n**Benefits**:\n- ‚úÖ Atomic (all succeed or all fail)\n- ‚úÖ More efficient (single network call)\n- ‚úÖ Up to 500 operations per batch\n\n",
              "code": "Future<void> batchUpdateTasks(List<Task> tasks) async {\n  final batch = _firestore.batch();\n\n  for (var task in tasks) {\n    final docRef = _tasksCollection.doc(task.id);\n    batch.update(docRef, task.toMap());\n  }\n\n  await batch.commit(); // Execute all updates at once\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### ‚úÖ DO:\n1. **Use StreamBuilder** for real-time data\n2. **Index frequently queried fields** (Firebase Console ‚Üí Indexes)\n3. **Denormalize data** when needed (duplicate for read performance)\n4. **Use batch writes** for multiple updates\n5. **Paginate large datasets** (use `.limit()` and `.startAfter()`)\n6. **Handle offline mode** (Firestore caches automatically)\n7. **Use Timestamps** for dates (not Strings)\n\n### ‚ùå DON'T:\n1. **Don't fetch entire collections** (use queries with filters)\n2. **Don't nest data too deeply** (max 3-4 levels)\n3. **Don't use client-side filtering** (use Firestore queries)\n4. **Don't store large files** in documents (use Cloud Storage)\n5. **Don't forget security rules** (covered in next lesson)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Common Patterns",
              "content": "\n### User-Specific Data\n\n\n### Subcollections\n\n\n### Array Fields\n\n\n### Increment/Decrement\n\n\n",
              "code": "// Increment likes count\n.update({\n  'likes': FieldValue.increment(1)\n});\n\n// Decrement\n.update({\n  'stock': FieldValue.increment(-1)\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhat's the difference between `.get()` and `.snapshots()`?\n\nA) They're the same\nB) `.get()` fetches once, `.snapshots()` provides real-time updates via Stream\nC) `.snapshots()` is faster\nD) `.get()` is for collections only\n\n### Question 2\nWhy use batch writes instead of individual updates?\n\nA) They're required by Firestore\nB) They're atomic (all-or-nothing) and more efficient\nC) They're easier to write\nD) They're only for deletions\n\n### Question 3\nWhat's the maximum nesting depth recommended for Firestore documents?\n\nA) 1 level\nB) 3-4 levels\nC) 10 levels\nD) Unlimited\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: `.get()` fetches once, `.snapshots()` provides real-time updates via Stream\n\n`.get()` returns a Future that fetches data once. `.snapshots()` returns a Stream that continuously listens for changes and automatically updates your UI via StreamBuilder.\n\n### Answer 2: B\n**Correct**: They're atomic (all-or-nothing) and more efficient\n\nBatch writes ensure all operations succeed or fail together (atomicity), prevent partial updates, and reduce network calls by bundling multiple operations into one request.\n\n### Answer 3: B\n**Correct**: 3-4 levels\n\nWhile Firestore technically allows deeper nesting, 3-4 levels is the practical recommendation. Deeper nesting makes queries complex and can impact performance. Consider denormalizing or using subcollections instead.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've mastered Firestore CRUD operations! In the next lesson, we'll learn **Cloud Storage** to upload and store images, videos, and files.\n\n**Coming up in Lesson 4: Firebase Cloud Storage**\n- Upload images and files\n- Download URLs\n- Progress tracking\n- Delete files\n- Complete image gallery app\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Firestore is a NoSQL database with collections and documents\n‚úÖ Use StreamBuilder for real-time data synchronization\n‚úÖ CRUD operations: add(), get(), update(), delete()\n‚úÖ Queries support filtering (.where), ordering (.orderBy), and limiting (.limit)\n‚úÖ Batch operations improve performance for multiple writes\n‚úÖ Always filter by userId to ensure users only see their data\n‚úÖ Firestore automatically handles offline caching\n\n**You can now build apps with real-time cloud databases!** üéâ\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "8.4",
          "title": "Module 8, Lesson 4: Firebase Cloud Storage - File Storage",
          "moduleId": "module-08",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll know how to upload, download, and manage files (images, videos, documents) using Firebase Cloud Storage with progress tracking and security.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Most apps need to store user files.**\n\n- **Instagram**: Stores billions of photos and videos\n- **WhatsApp**: Profile pictures, media messages, documents\n- **Google Drive**: Files of all types in the cloud\n- **LinkedIn**: Profile photos, resumes, company logos\n- **90% of social apps** involve media upload/download\n\nFirebase Cloud Storage provides secure, scalable file storage that integrates seamlessly with Firebase Authentication and Firestore.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Photo Lab",
              "content": "\n### Before Cloud Storage = Physical Photo Album\n- üì∏ Take photo ‚Üí develop film ‚Üí store in album\n- üì¶ Album stored in your house only\n- ‚ùå Lose the album, lose all photos\n- ‚ùå Can't share with friends easily\n- ‚ùå Limited by physical space\n\n### With Cloud Storage = Online Photo Service (Google Photos)\n- üì∏ Take photo ‚Üí automatically uploads to cloud\n- ‚òÅÔ∏è Stored on servers worldwide (safe and redundant)\n- ‚úÖ Access from any device\n- ‚úÖ Share with anyone via link\n- ‚úÖ Unlimited storage (in cloud)\n- üîê Protected by authentication\n\n**Firebase Storage is your app's photo lab in the cloud!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Firebase Storage Overview",
              "content": "\n### What Firebase Storage Provides\n\n1. **File Upload/Download**\n   - Images (JPEG, PNG, GIF, WebP)\n   - Videos (MP4, MOV)\n   - Audio files\n   - Documents (PDF, DOCX)\n   - Any file type\n\n2. **Security**\n   - Integration with Firebase Auth\n   - Custom security rules\n   - Access control per user\n\n3. **Performance**\n   - Automatic compression\n   - CDN (Content Delivery Network)\n   - Resume interrupted uploads/downloads\n\n4. **Scalability**\n   - Handles millions of files\n   - Automatic load balancing\n   - Google's infrastructure\n\n"
            },
            {
              "type": "THEORY",
              "title": "Storage Structure",
              "content": "\nFirebase Storage organizes files like a file system:\n\n\n**Best practices**:\n- Organize by user ID or content type\n- Use consistent naming conventions\n- Avoid spaces in filenames (use hyphens or underscores)\n\n",
              "code": "gs://your-app.appspot.com/\n‚îú‚îÄ‚îÄ users/\n‚îÇ   ‚îú‚îÄ‚îÄ user123/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ profile.jpg\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ documents/\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ resume.pdf\n‚îÇ   ‚îî‚îÄ‚îÄ user456/\n‚îÇ       ‚îî‚îÄ‚îÄ profile.jpg\n‚îú‚îÄ‚îÄ posts/\n‚îÇ   ‚îú‚îÄ‚îÄ post001.jpg\n‚îÇ   ‚îî‚îÄ‚îÄ post002.mp4\n‚îî‚îÄ‚îÄ public/\n    ‚îî‚îÄ‚îÄ app-logo.png",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Firebase Storage",
              "content": "\n### 1. Enable Storage in Firebase Console\n\n1. Go to https://console.firebase.google.com\n2. Select your project\n3. Click **\"Storage\"** in left sidebar\n4. Click **\"Get started\"**\n5. Choose security rules:\n   - **Test mode**: Anyone can read/write (insecure!)\n   - **Production mode**: Requires authentication (recommended)\n6. Select location (same as Firestore for consistency)\n7. Click **\"Done\"**\n\n### 2. Add Package to pubspec.yaml\n\n\nRun:\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Basic Storage Operations",
              "content": "\n### Create Storage Service\n\n\n",
              "code": "// lib/services/storage_service.dart\nimport 'package:firebase_storage/firebase_storage.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nimport 'dart:io';\n\nclass StorageService {\n  final FirebaseStorage _storage = FirebaseStorage.instance;\n  final FirebaseAuth _auth = FirebaseAuth.instance;\n\n  String? get currentUserId => _auth.currentUser?.uid;\n\n  // ========== UPLOAD ==========\n\n  // Upload file with progress tracking\n  Future<String> uploadFile({\n    required File file,\n    required String path,\n    Function(double)? onProgress,\n  }) async {\n    try {\n      // Create reference to the file location\n      final storageRef = _storage.ref().child(path);\n\n      // Upload the file\n      final uploadTask = storageRef.putFile(file);\n\n      // Listen to upload progress\n      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n        final progress = snapshot.bytesTransferred / snapshot.totalBytes;\n        if (onProgress != null) {\n          onProgress(progress);\n        }\n      });\n\n      // Wait for upload to complete\n      final snapshot = await uploadTask;\n\n      // Get download URL\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      return downloadUrl;\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // Upload user profile picture\n  Future<String> uploadProfilePicture(File imageFile) async {\n    if (currentUserId == null) throw 'User not authenticated';\n\n    final fileName = 'profile_${DateTime.now().millisecondsSinceEpoch}.jpg';\n    final path = 'users/$currentUserId/profile/$fileName';\n\n    return uploadFile(file: imageFile, path: path);\n  }\n\n  // Upload post image\n  Future<String> uploadPostImage(File imageFile) async {\n    if (currentUserId == null) throw 'User not authenticated';\n\n    final fileName = 'post_${DateTime.now().millisecondsSinceEpoch}.jpg';\n    final path = 'users/$currentUserId/posts/$fileName';\n\n    return uploadFile(file: imageFile, path: path);\n  }\n\n  // Upload document\n  Future<String> uploadDocument(File file, String documentName) async {\n    if (currentUserId == null) throw 'User not authenticated';\n\n    final fileName = '${DateTime.now().millisecondsSinceEpoch}_$documentName';\n    final path = 'users/$currentUserId/documents/$fileName';\n\n    return uploadFile(file: file, path: path);\n  }\n\n  // ========== DOWNLOAD ==========\n\n  // Get download URL for a file\n  Future<String> getDownloadUrl(String path) async {\n    try {\n      final ref = _storage.ref().child(path);\n      return await ref.getDownloadURL();\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // Download file to local storage\n  Future<File> downloadFile({\n    required String path,\n    required String localPath,\n    Function(double)? onProgress,\n  }) async {\n    try {\n      final ref = _storage.ref().child(path);\n      final file = File(localPath);\n\n      final downloadTask = ref.writeToFile(file);\n\n      // Listen to download progress\n      downloadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n        final progress = snapshot.bytesTransferred / snapshot.totalBytes;\n        if (onProgress != null) {\n          onProgress(progress);\n        }\n      });\n\n      await downloadTask;\n      return file;\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // ========== DELETE ==========\n\n  // Delete file by path\n  Future<void> deleteFile(String path) async {\n    try {\n      final ref = _storage.ref().child(path);\n      await ref.delete();\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // Delete file by URL\n  Future<void> deleteFileByUrl(String downloadUrl) async {\n    try {\n      final ref = _storage.refFromURL(downloadUrl);\n      await ref.delete();\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // Delete user's profile picture\n  Future<void> deleteProfilePicture() async {\n    if (currentUserId == null) throw 'User not authenticated';\n\n    final path = 'users/$currentUserId/profile/';\n    await _deleteFolder(path);\n  }\n\n  // ========== METADATA ==========\n\n  // Get file metadata\n  Future<FullMetadata> getMetadata(String path) async {\n    try {\n      final ref = _storage.ref().child(path);\n      return await ref.getMetadata();\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // Update file metadata\n  Future<void> updateMetadata({\n    required String path,\n    Map<String, String>? customMetadata,\n    String? contentType,\n  }) async {\n    try {\n      final ref = _storage.ref().child(path);\n      final metadata = SettableMetadata(\n        customMetadata: customMetadata,\n        contentType: contentType,\n      );\n      await ref.updateMetadata(metadata);\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // ========== LIST FILES ==========\n\n  // List all files in a directory\n  Future<List<String>> listFiles(String path) async {\n    try {\n      final ref = _storage.ref().child(path);\n      final result = await ref.listAll();\n\n      return result.items.map((item) => item.fullPath).toList();\n    } on FirebaseException catch (e) {\n      throw _handleStorageException(e);\n    }\n  }\n\n  // List user's profile pictures\n  Future<List<String>> listUserImages() async {\n    if (currentUserId == null) throw 'User not authenticated';\n\n    final path = 'users/$currentUserId/posts/';\n    return listFiles(path);\n  }\n\n  // ========== HELPER METHODS ==========\n\n  // Delete entire folder (recursively)\n  Future<void> _deleteFolder(String path) async {\n    final ref = _storage.ref().child(path);\n    final result = await ref.listAll();\n\n    // Delete all files\n    for (var item in result.items) {\n      await item.delete();\n    }\n\n    // Delete subfolders recursively\n    for (var prefix in result.prefixes) {\n      await _deleteFolder(prefix.fullPath);\n    }\n  }\n\n  // Handle Storage exceptions\n  String _handleStorageException(FirebaseException e) {\n    switch (e.code) {\n      case 'unauthorized':\n        return 'You don\\'t have permission to access this file.';\n      case 'canceled':\n        return 'Upload/download was canceled.';\n      case 'unknown':\n        return 'An unknown error occurred.';\n      case 'object-not-found':\n        return 'File not found.';\n      case 'bucket-not-found':\n        return 'Storage bucket not found.';\n      case 'project-not-found':\n        return 'Firebase project not found.';\n      case 'quota-exceeded':\n        return 'Storage quota exceeded.';\n      case 'unauthenticated':\n        return 'Please login to upload files.';\n      case 'retry-limit-exceeded':\n        return 'Operation timed out. Please try again.';\n      default:\n        return 'Storage error: ${e.message}';\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Image Upload App",
              "content": "\n### Profile Picture Upload Screen\n\n\n",
              "code": "// lib/screens/profile/edit_profile_screen.dart\nimport 'package:flutter/material.dart';\nimport 'package:image_picker/image_picker.dart';\nimport 'dart:io';\nimport '../../services/storage_service.dart';\nimport '../../services/auth_service.dart';\nimport '../../services/firestore_service.dart';\n\nclass EditProfileScreen extends StatefulWidget {\n  const EditProfileScreen({super.key});\n\n  @override\n  State<EditProfileScreen> createState() => _EditProfileScreenState();\n}\n\nclass _EditProfileScreenState extends State<EditProfileScreen> {\n  final _storageService = StorageService();\n  final _authService = AuthService();\n  final _imagePicker = ImagePicker();\n\n  File? _selectedImage;\n  bool _isUploading = false;\n  double _uploadProgress = 0.0;\n  String? _currentProfileUrl;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadCurrentProfile();\n  }\n\n  Future<void> _loadCurrentProfile() async {\n    // Load user's current profile picture URL from Firestore\n    // (Implementation depends on your Firestore setup)\n  }\n\n  Future<void> _pickImage(ImageSource source) async {\n    try {\n      final XFile? image = await _imagePicker.pickImage(\n        source: source,\n        maxWidth: 1024,\n        maxHeight: 1024,\n        imageQuality: 85,\n      );\n\n      if (image != null) {\n        setState(() {\n          _selectedImage = File(image.path);\n        });\n      }\n    } catch (e) {\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Failed to pick image: $e')),\n        );\n      }\n    }\n  }\n\n  Future<void> _uploadProfilePicture() async {\n    if (_selectedImage == null) return;\n\n    setState(() {\n      _isUploading = true;\n      _uploadProgress = 0.0;\n    });\n\n    try {\n      // Delete old profile picture if exists\n      if (_currentProfileUrl != null) {\n        try {\n          await _storageService.deleteFileByUrl(_currentProfileUrl!);\n        } catch (e) {\n          // Ignore if file doesn't exist\n        }\n      }\n\n      // Upload new profile picture\n      final downloadUrl = await _storageService.uploadFile(\n        file: _selectedImage!,\n        path: 'users/${_storageService.currentUserId}/profile/profile.jpg',\n        onProgress: (progress) {\n          setState(() {\n            _uploadProgress = progress;\n          });\n        },\n      );\n\n      // Update Firestore with new profile URL\n      // await _firestoreService.updateUserProfile(downloadUrl);\n\n      setState(() {\n        _isUploading = false;\n        _currentProfileUrl = downloadUrl;\n        _selectedImage = null;\n      });\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Profile picture updated!')),\n        );\n      }\n    } catch (e) {\n      setState(() {\n        _isUploading = false;\n      });\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Upload failed: $e')),\n        );\n      }\n    }\n  }\n\n  Future<void> _showImageSourceDialog() async {\n    return showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: const Text('Choose Image Source'),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            ListTile(\n              leading: const Icon(Icons.camera_alt),\n              title: const Text('Camera'),\n              onTap: () {\n                Navigator.pop(context);\n                _pickImage(ImageSource.camera);\n              },\n            ),\n            ListTile(\n              leading: const Icon(Icons.photo_library),\n              title: const Text('Gallery'),\n              onTap: () {\n                Navigator.pop(context);\n                _pickImage(ImageSource.gallery);\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Edit Profile Picture'),\n      ),\n      body: Center(\n        child: SingleChildScrollView(\n          padding: const EdgeInsets.all(24.0),\n          child: Column(\n            children: [\n              // Profile picture preview\n              Stack(\n                children: [\n                  CircleAvatar(\n                    radius: 80,\n                    backgroundColor: Colors.grey.shade200,\n                    backgroundImage: _selectedImage != null\n                        ? FileImage(_selectedImage!)\n                        : (_currentProfileUrl != null\n                            ? NetworkImage(_currentProfileUrl!)\n                            : null) as ImageProvider?,\n                    child: _selectedImage == null && _currentProfileUrl == null\n                        ? Icon(\n                            Icons.person,\n                            size: 80,\n                            color: Colors.grey.shade400,\n                          )\n                        : null,\n                  ),\n                  Positioned(\n                    bottom: 0,\n                    right: 0,\n                    child: CircleAvatar(\n                      backgroundColor: Theme.of(context).primaryColor,\n                      child: IconButton(\n                        icon: const Icon(Icons.camera_alt, color: Colors.white),\n                        onPressed: _isUploading ? null : _showImageSourceDialog,\n                      ),\n                    ),\n                  ),\n                ],\n              ),\n\n              const SizedBox(height: 32),\n\n              // Upload progress\n              if (_isUploading) ...[\n                LinearProgressIndicator(value: _uploadProgress),\n                const SizedBox(height: 8),\n                Text(\n                  'Uploading... ${(_uploadProgress * 100).toStringAsFixed(0)}%',\n                  style: TextStyle(color: Colors.grey.shade600),\n                ),\n                const SizedBox(height: 24),\n              ],\n\n              // Upload button\n              if (_selectedImage != null && !_isUploading)\n                FilledButton.icon(\n                  onPressed: _uploadProfilePicture,\n                  icon: const Icon(Icons.cloud_upload),\n                  label: const Text('Upload Profile Picture'),\n                  style: FilledButton.styleFrom(\n                    padding: const EdgeInsets.symmetric(\n                      horizontal: 32,\n                      vertical: 16,\n                    ),\n                  ),\n                ),\n\n              // Delete button\n              if (_currentProfileUrl != null && !_isUploading) ...[\n                const SizedBox(height: 16),\n                OutlinedButton.icon(\n                  onPressed: () async {\n                    final confirm = await showDialog<bool>(\n                      context: context,\n                      builder: (context) => AlertDialog(\n                        title: const Text('Delete Profile Picture'),\n                        content: const Text('Are you sure?'),\n                        actions: [\n                          TextButton(\n                            onPressed: () => Navigator.pop(context, false),\n                            child: const Text('Cancel'),\n                          ),\n                          FilledButton(\n                            onPressed: () => Navigator.pop(context, true),\n                            style: FilledButton.styleFrom(\n                              backgroundColor: Colors.red,\n                            ),\n                            child: const Text('Delete'),\n                          ),\n                        ],\n                      ),\n                    );\n\n                    if (confirm == true) {\n                      try {\n                        await _storageService.deleteFileByUrl(_currentProfileUrl!);\n                        setState(() {\n                          _currentProfileUrl = null;\n                        });\n                        if (mounted) {\n                          ScaffoldMessenger.of(context).showSnackBar(\n                            const SnackBar(content: Text('Profile picture deleted')),\n                          );\n                        }\n                      } catch (e) {\n                        if (mounted) {\n                          ScaffoldMessenger.of(context).showSnackBar(\n                            SnackBar(content: Text('Delete failed: $e')),\n                          );\n                        }\n                      }\n                    }\n                  },\n                  icon: const Icon(Icons.delete, color: Colors.red),\n                  label: const Text('Delete Profile Picture'),\n                  style: OutlinedButton.styleFrom(\n                    foregroundColor: Colors.red,\n                    side: const BorderSide(color: Colors.red),\n                  ),\n                ),\n              ],\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Firebase Storage Security Rules",
              "content": "\n### Default Rules (Test Mode - Insecure!)\n\n\n### Production Rules (Secure)\n\n\n### Update Rules in Firebase Console\n\n1. Go to Firebase Console ‚Üí Storage\n2. Click \"Rules\" tab\n3. Paste your security rules\n4. Click \"Publish\"\n\n",
              "code": "rules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // User-specific files\n    match /users/{userId}/{allPaths=**} {\n      // Only the user can read/write their own files\n      allow read, write: if request.auth != null && request.auth.uid == userId;\n    }\n\n    // Public files (anyone can read)\n    match /public/{allPaths=**} {\n      allow read: if true;\n      allow write: if request.auth != null;  // Only authenticated users can write\n    }\n\n    // Posts (owner can write, anyone can read)\n    match /posts/{postId} {\n      allow read: if true;\n      allow write: if request.auth != null;\n    }\n\n    // Validate file size (max 5MB for images)\n    match /users/{userId}/profile/{fileName} {\n      allow write: if request.auth != null\n                   && request.auth.uid == userId\n                   && request.resource.size < 5 * 1024 * 1024;  // 5MB\n    }\n\n    // Validate file type (only images)\n    match /users/{userId}/images/{fileName} {\n      allow write: if request.auth != null\n                   && request.auth.uid == userId\n                   && request.resource.contentType.matches('image/.*');\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### ‚úÖ DO:\n1. **Compress images before upload** (use image_picker maxWidth/quality)\n2. **Use unique filenames** (timestamp + random string)\n3. **Organize by user ID** (`users/{userId}/...`)\n4. **Validate file types and sizes** in security rules\n5. **Delete old files** when uploading new ones (avoid storage bloat)\n6. **Show upload progress** for better UX\n7. **Handle errors gracefully** (network issues, quota exceeded)\n8. **Use CDN URLs** (Firebase provides these automatically)\n\n### ‚ùå DON'T:\n1. **Don't upload full-resolution images** (compress first!)\n2. **Don't store sensitive data** in filenames\n3. **Don't allow public write access** (use authentication)\n4. **Don't forget to delete old files** (costs add up)\n5. **Don't upload without size limits** (prevent abuse)\n6. **Don't use HTTP URLs** (always HTTPS)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Pricing & Limits",
              "content": "\n### Free Tier (Spark Plan)\n\n- **Storage**: 5 GB\n- **Downloads**: 1 GB/day\n- **Uploads**: 1 GB/day\n- **Operations**: 50k/day\n\n**This is enough for**:\n- ~2,500 high-quality images (2MB each)\n- Small to medium apps\n- Learning and prototyping\n\n### Paid Tier (Blaze Plan)\n\n**Pay-as-you-go**:\n- Storage: $0.026 per GB/month\n- Downloads: $0.12 per GB\n- Uploads: $0.12 per GB\n\n**Example costs**:\n- 10 GB storage = ~$0.26/month\n- 10 GB downloads = ~$1.20/month\n- Most indie apps: $1-5/month\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhy should you delete old files when uploading new ones?\n\nA) It's required by Firebase\nB) To save storage costs and prevent quota issues\nC) To make uploads faster\nD) Firebase does this automatically\n\n### Question 2\nWhat's the correct way to organize user files?\n\nA) All in root folder\nB) By file type only\nC) By user ID (users/{userId}/...)\nD) By date only\n\n### Question 3\nWhat's the benefit of showing upload progress?\n\nA) It's required\nB) It provides user feedback, especially for large files\nC) It makes uploads faster\nD) It compresses files\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: To save storage costs and prevent quota issues\n\nOld files consume storage (which costs money) and count toward your quota. For example, if a user updates their profile picture 10 times, you'd be storing 10 images instead of 1. Always delete the old file before uploading a new one.\n\n### Answer 2: C\n**Correct**: By user ID (users/{userId}/...)\n\nOrganizing by user ID makes it easy to implement security rules (users can only access their own files), manage per-user quotas, and delete all user data when they delete their account. It's the industry standard pattern.\n\n### Answer 3: B\n**Correct**: It provides user feedback, especially for large files\n\nWithout progress indicators, users might think the app froze when uploading a 10MB video. Progress bars (0%, 25%, 50%, 100%) reassure users that the upload is working and show how long it will take.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've mastered Firebase Cloud Storage! In the next lesson, we'll learn about **Firebase Security Rules** to protect your data from unauthorized access.\n\n**Coming up in Lesson 5: Firebase Security Rules**\n- Firestore security rules\n- Storage security rules\n- Authentication-based access control\n- Testing security rules\n- Production-ready security\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Firebase Storage handles secure file storage in the cloud\n‚úÖ Organize files by user ID (users/{userId}/...)\n‚úÖ Always compress images before uploading\n‚úÖ Use uploadFile() with progress callbacks for UX\n‚úÖ Delete old files to save storage costs\n‚úÖ Implement security rules to restrict access\n‚úÖ Firebase provides CDN URLs automatically for fast downloads\n‚úÖ Monitor usage to avoid surprise bills\n\n**You can now build apps with cloud file storage like Instagram!** üì∏\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "8.5",
          "title": "Module 8, Lesson 5: Firebase Security Rules",
          "moduleId": "module-08",
          "order": 6,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll understand how to protect your Firebase data with security rules, prevent unauthorized access, and build production-ready secure applications.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Security rules are the MOST IMPORTANT part of Firebase.**\n\n- **Without security rules**, anyone can read/write your entire database\n- **Data breaches** happen when developers forget to set rules\n- **Firebase projects get hacked** every day due to weak security\n- **Security rules** are your firewall between users and data\n- **Production apps** MUST have proper security rules\n\n**Real example**: In 2020, millions of Firebase databases were exposed online because developers used test mode rules in production.\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Bank Vault",
              "content": "\n### Without Security Rules = No Locks\n- üè¶ Bank with no locks on vault\n- üí∞ Anyone can walk in and take money\n- üìÅ Anyone can see everyone's account balances\n- ‚ùå **This is test mode!**\n\n### With Security Rules = Multi-Layer Security\n- üîê **Locks** (authentication required)\n- üëÆ **Guards** (authorization checks)\n- üé´ **ID verification** (user owns the data)\n- üìπ **Cameras** (audit logs)\n- ‚úÖ **This is production mode!**\n\n**Security rules are your bank vault's locks and guards.**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Types of Firebase Security Rules",
              "content": "\nFirebase has security rules for two services:\n\n1. **Firestore Security Rules** (database)\n2. **Storage Security Rules** (files)\n\nBoth use similar syntax but protect different resources.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Firestore Security Rules",
              "content": "\n### Basic Structure\n\n\n### The Four Operations\n\n\n",
              "code": "allow read;   // = get + list\nallow write;  // = create + update + delete\n\n// Or be specific:\nallow get;      // Read single document\nallow list;     // Read multiple documents (query)\nallow create;   // Create new document\nallow update;   // Update existing document\nallow delete;   // Delete document",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Common Security Patterns",
              "content": "\n### 1. Public Read, Authenticated Write\n\n**Use case**: Blog posts, public content\n\n\n### 2. User-Specific Data (Most Common!)\n\n**Use case**: User profiles, private data\n\n\n### 3. Role-Based Access\n\n**Use case**: Admin panels, moderation\n\n\n### 4. Validate Data Types\n\n**Use case**: Prevent invalid data\n\n\n### 5. Subcollections\n\n**Use case**: Comments on posts, nested data\n\n\n",
              "code": "match /posts/{postId} {\n  allow read: if true;\n  allow write: if request.auth != null;\n\n  match /comments/{commentId} {\n    allow read: if true;\n    allow create: if request.auth != null;\n    allow update, delete: if request.auth != null\n                           && request.auth.uid == resource.data.userId;\n  }\n}",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Storage Security Rules",
              "content": "\n### Basic Structure\n\n\n### Common Storage Patterns\n\n#### 1. User-Specific Files\n\n\n#### 2. File Size Limits\n\n\n#### 3. File Type Validation\n\n\n#### 4. Public Read, Authenticated Write\n\n\n",
              "code": "match /public/{allPaths=**} {\n  allow read: if true;\n  allow write: if request.auth != null;\n}",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Testing Security Rules",
              "content": "\n### 1. Firebase Console Rules Playground\n\n1. Go to Firebase Console ‚Üí Firestore ‚Üí Rules\n2. Click **\"Rules Playground\"** tab\n3. Simulate requests with different auth states\n\n**Example test**:\n\n### 2. Firebase Emulator Suite (Local Testing)\n\n\nThen in your Flutter app:\n\n\n",
              "code": "// main.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:firebase_storage/firebase_storage.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  await Firebase.initializeApp(\n    options: DefaultFirebaseOptions.currentPlatform,\n  );\n\n  // Use emulators in debug mode\n  if (kDebugMode) {\n    FirebaseFirestore.instance.useFirestoreEmulator('localhost', 8080);\n    FirebaseStorage.instance.useStorageEmulator('localhost', 9199);\n  }\n\n  runApp(const MyApp());\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Common Security Mistakes",
              "content": "\n### ‚ùå Mistake 1: Test Mode in Production\n\n\n**Problem**: Anyone can read/write your entire database!\n\n### ‚ùå Mistake 2: Relying on Client-Side Checks\n\n\n**Problem**: Hackers can modify your app code and bypass this check.\n\n**Solution**: Enforce in security rules!\n\n\n### ‚ùå Mistake 3: Not Validating Data\n\n\n**Problem**: Users can write invalid data (empty titles, negative numbers, etc.)\n\n**Solution**: Validate everything!\n\n\n",
              "code": "// ‚úÖ GOOD: Strict validation\nmatch /posts/{postId} {\n  allow write: if request.auth != null\n               && request.resource.data.title is string\n               && request.resource.data.title.size() > 0;\n}",
              "language": "javascript"
            },
            {
              "type": "EXPERIMENT",
              "title": "Security Rules Best Practices",
              "content": "\n### ‚úÖ DO:\n\n1. **Start restrictive, gradually allow** (deny by default)\n2. **Validate all data types and sizes**\n3. **Prevent users from changing critical fields** (userId, createdAt)\n4. **Use helper functions** for reusable logic\n5. **Test rules thoroughly** before deploying\n6. **Log and monitor** rule violations\n7. **Review rules regularly** as your app evolves\n\n### ‚ùå DON'T:\n\n1. **Don't use test mode** in production\n2. **Don't trust client-side validation**\n3. **Don't allow unlimited file sizes**\n4. **Don't forget subcollection rules**\n5. **Don't expose sensitive data** in public reads\n6. **Don't allow users to read all users** (privacy issue)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Production-Ready Rules Checklist",
              "content": "\nBefore launching your app, verify:\n\n- [ ] **No `if true` rules** except for truly public data\n- [ ] **All write operations require authentication**\n- [ ] **Users can only access their own data**\n- [ ] **Data validation on all fields**\n- [ ] **File size limits enforced**\n- [ ] **File type validation for uploads**\n- [ ] **Admin actions require admin role**\n- [ ] **Rules tested with emulator**\n- [ ] **No sensitive data in public reads**\n- [ ] **Subcollections have appropriate rules**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Monitoring Security",
              "content": "\n### View Rule Violations\n\n1. Go to Firebase Console ‚Üí Firestore ‚Üí Usage\n2. Check \"Denied requests\" graph\n3. High denial rate might indicate:\n   - **Attack attempt** (good - rules working!)\n   - **Bug in your app** (bad - fix your code)\n   - **Overly restrictive rules** (bad - adjust rules)\n\n### Set Up Alerts\n\n1. Firebase Console ‚Üí Project Settings ‚Üí Integrations\n2. Enable Cloud Functions alerts\n3. Monitor for:\n   - Unusual traffic spikes\n   - High error rates\n   - Storage quota nearing limit\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhy must security rules be enforced on the server, not the client?\n\nA) It's faster\nB) Hackers can modify client code to bypass client-side checks\nC) It's easier to code\nD) Firebase requires it\n\n### Question 2\nWhat's wrong with this rule: `allow write: if true;`?\n\nA) Syntax error\nB) It allows anyone (including unauthenticated users) to write data\nC) It's too slow\nD) Nothing, it's fine\n\n### Question 3\nWhy validate data types in security rules?\n\nA) To make queries faster\nB) To prevent invalid data that could break your app\nC) Firebase requires it\nD) To reduce storage costs\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: Hackers can modify client code to bypass client-side checks\n\nSince Flutter apps run on the user's device, hackers can decompile your app, modify the code, and bypass any client-side security checks. Security rules run on Firebase servers (which hackers can't access), making them the only reliable security layer.\n\n### Answer 2: B\n**Correct**: It allows anyone (including unauthenticated users) to write data\n\n`allow write: if true` means \"allow anyone to write data, no questions asked.\" This is extremely dangerous in production - anyone could delete your entire database, inject malicious data, or fill your storage quota.\n\n### Answer 3: B\n**Correct**: To prevent invalid data that could break your app\n\nWithout validation, users could write `{ title: 123, likes: \"hello\", createdAt: null }` which would break your app when it tries to display a string title or count numeric likes. Validation ensures data matches your expected schema.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've mastered Firebase security! In the next lesson, we'll explore **Real-Time Features** - building apps that update instantly across all devices.\n\n**Coming up in Lesson 6: Real-Time Features**\n- Real-time listeners\n- Presence detection (online/offline)\n- Live collaboration features\n- Chat app example\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Security rules are your firewall between users and data\n‚úÖ Always enforce security on the server (never trust client code)\n‚úÖ Start with deny-all, gradually allow specific operations\n‚úÖ Validate all data (types, sizes, required fields)\n‚úÖ Test rules thoroughly before production\n‚úÖ Users should only access their own data (userId matching)\n‚úÖ File uploads need size and type validation\n‚úÖ Monitor rule violations to detect attacks and bugs\n\n**Your app is now production-ready and secure!** üîê\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "8.6",
          "title": "Module 8, Lesson 6: Real-Time Features with Firebase",
          "moduleId": "module-08",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll know how to build real-time features like live chat, presence detection (online/offline status), and collaborative editing using Firebase's real-time capabilities.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Real-time features make apps feel alive.**\n\n- **WhatsApp**: Messages appear instantly\n- **Google Docs**: See others typing in real-time\n- **Instagram**: Live like counts and comments\n- **Slack**: Online/offline status, typing indicators\n- **75% of modern apps** have some real-time feature\n- **User engagement increases 300%** with real-time updates\n\nFirebase makes real-time features incredibly easy - no complex WebSocket servers needed!\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Walkie-Talkie",
              "content": "\n### Without Real-Time = Sending Letters\n- ‚úâÔ∏è Write message ‚Üí mail it ‚Üí wait days ‚Üí receive reply\n- üì¨ Check mailbox periodically for new letters\n- ‚è∞ Slow, delayed communication\n- ‚ùå Can't have natural conversations\n\n### With Real-Time = Walkie-Talkie\n- üì° Speak ‚Üí they hear instantly\n- üîä Their response comes immediately\n- üë• Know when others are online/offline\n- ‚úÖ Natural, flowing conversation\n\n**Firebase real-time updates are like having a walkie-talkie connection to your database!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Firebase Real-Time Capabilities",
              "content": "\n### 1. Firestore Snapshots (Real-Time Listeners)\n\n**When data changes**:\n1. Firebase detects the change\n2. Pushes update to all listening devices\n3. Flutter rebuilds UI automatically (with StreamBuilder)\n\n### 2. Firestore Realtime Database\n- Legacy real-time database (still used for specific cases)\n- Extremely low latency (< 100ms)\n- JSON tree structure\n- Good for: presence, typing indicators, live cursors\n\n### 3. Firebase Cloud Messaging (FCM)\n- Push notifications\n- Background messaging\n- Topic-based messaging\n\n",
              "code": "// Listen to document changes\nfirestore.collection('chats').doc('room1').snapshots()\n\n// Listen to collection changes\nfirestore.collection('messages').snapshots()",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Real-Time Chat App",
              "content": "\nLet's build a complete chat app with Firebase!\n\n### Chat Message Model\n\n\n### Chat Service\n\n\n### Chat Screen\n\n\n",
              "code": "// lib/screens/chat/chat_screen.dart\nimport 'package:flutter/material.dart';\nimport '../../services/chat_service.dart';\nimport '../../services/auth_service.dart';\nimport '../../models/chat_message.dart';\n\nclass ChatScreen extends StatefulWidget {\n  final String otherUserId;\n  final String otherUserName;\n\n  const ChatScreen({\n    super.key,\n    required this.otherUserId,\n    required this.otherUserName,\n  });\n\n  @override\n  State<ChatScreen> createState() => _ChatScreenState();\n}\n\nclass _ChatScreenState extends State<ChatScreen> {\n  final _chatService = ChatService();\n  final _authService = AuthService();\n  final _messageController = TextEditingController();\n  final _scrollController = ScrollController();\n\n  late String _chatRoomId;\n\n  @override\n  void initState() {\n    super.initState();\n    final currentUserId = _authService.currentUser!.uid;\n    _chatRoomId = _chatService.getChatRoomId(currentUserId, widget.otherUserId);\n  }\n\n  @override\n  void dispose() {\n    _messageController.dispose();\n    _scrollController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _sendMessage() async {\n    final text = _messageController.text.trim();\n    if (text.isEmpty) return;\n\n    final currentUser = _authService.currentUser!;\n\n    try {\n      await _chatService.sendMessage(\n        chatRoomId: _chatRoomId,\n        text: text,\n        senderId: currentUser.uid,\n        senderName: currentUser.displayName ?? 'User',\n      );\n\n      _messageController.clear();\n\n      // Scroll to bottom\n      if (_scrollController.hasClients) {\n        _scrollController.animateTo(\n          0,\n          duration: const Duration(milliseconds: 300),\n          curve: Curves.easeOut,\n        );\n      }\n    } catch (e) {\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Failed to send: $e')),\n        );\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.otherUserName),\n      ),\n      body: Column(\n        children: [\n          // Messages list\n          Expanded(\n            child: StreamBuilder<List<ChatMessage>>(\n              stream: _chatService.getMessagesStream(_chatRoomId),\n              builder: (context, snapshot) {\n                if (snapshot.connectionState == ConnectionState.waiting) {\n                  return const Center(child: CircularProgressIndicator());\n                }\n\n                if (snapshot.hasError) {\n                  return Center(child: Text('Error: ${snapshot.error}'));\n                }\n\n                if (!snapshot.hasData || snapshot.data!.isEmpty) {\n                  return Center(\n                    child: Column(\n                      mainAxisAlignment: MainAxisAlignment.center,\n                      children: [\n                        Icon(\n                          Icons.chat_bubble_outline,\n                          size: 64,\n                          color: Colors.grey.shade300,\n                        ),\n                        const SizedBox(height: 16),\n                        Text(\n                          'No messages yet',\n                          style: TextStyle(color: Colors.grey.shade600),\n                        ),\n                        const SizedBox(height: 8),\n                        Text(\n                          'Say hi to ${widget.otherUserName}!',\n                          style: TextStyle(color: Colors.grey.shade500),\n                        ),\n                      ],\n                    ),\n                  );\n                }\n\n                final messages = snapshot.data!;\n                final currentUserId = _authService.currentUser!.uid;\n\n                return ListView.builder(\n                  controller: _scrollController,\n                  reverse: true,  // Latest at bottom\n                  padding: const EdgeInsets.all(16),\n                  itemCount: messages.length,\n                  itemBuilder: (context, index) {\n                    final message = messages[index];\n                    final isMe = message.senderId == currentUserId;\n\n                    return _buildMessageBubble(message, isMe);\n                  },\n                );\n              },\n            ),\n          ),\n\n          // Message input\n          _buildMessageInput(),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildMessageBubble(ChatMessage message, bool isMe) {\n    return Align(\n      alignment: isMe ? Alignment.centerRight : Alignment.centerLeft,\n      child: Container(\n        margin: const EdgeInsets.only(bottom: 12),\n        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),\n        constraints: BoxConstraints(\n          maxWidth: MediaQuery.sizeOf(context).width * 0.7,\n        ),\n        decoration: BoxDecoration(\n          color: isMe ? Theme.of(context).primaryColor : Colors.grey.shade200,\n          borderRadius: BorderRadius.only(\n            topLeft: const Radius.circular(16),\n            topRight: const Radius.circular(16),\n            bottomLeft: Radius.circular(isMe ? 16 : 4),\n            bottomRight: Radius.circular(isMe ? 4 : 16),\n          ),\n        ),\n        child: Column(\n          crossAxisAlignment:\n              isMe ? CrossAxisAlignment.end : CrossAxisAlignment.start,\n          children: [\n            Text(\n              message.text,\n              style: TextStyle(\n                color: isMe ? Colors.white : Colors.black87,\n                fontSize: 16,\n              ),\n            ),\n            const SizedBox(height: 4),\n            Text(\n              _formatTime(message.timestamp),\n              style: TextStyle(\n                color: isMe ? Colors.white70 : Colors.grey.shade600,\n                fontSize: 12,\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildMessageInput() {\n    return Container(\n      padding: const EdgeInsets.all(8.0),\n      decoration: BoxDecoration(\n        color: Colors.grey.shade100,\n        border: Border(top: BorderSide(color: Colors.grey.shade300)),\n      ),\n      child: Row(\n        children: [\n          Expanded(\n            child: TextField(\n              controller: _messageController,\n              decoration: InputDecoration(\n                hintText: 'Type a message...',\n                border: OutlineInputBorder(\n                  borderRadius: BorderRadius.circular(24),\n                  borderSide: BorderSide.none,\n                ),\n                filled: true,\n                fillColor: Colors.white,\n                contentPadding: const EdgeInsets.symmetric(\n                  horizontal: 20,\n                  vertical: 10,\n                ),\n              ),\n              textCapitalization: TextCapitalization.sentences,\n              onSubmitted: (_) => _sendMessage(),\n            ),\n          ),\n          const SizedBox(width: 8),\n          CircleAvatar(\n            backgroundColor: Theme.of(context).primaryColor,\n            child: IconButton(\n              icon: const Icon(Icons.send, color: Colors.white),\n              onPressed: _sendMessage,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n\n  String _formatTime(DateTime dateTime) {\n    final now = DateTime.now();\n    final difference = now.difference(dateTime);\n\n    if (difference.inDays > 0) {\n      return '${dateTime.day}/${dateTime.month}/${dateTime.year}';\n    } else if (difference.inHours > 0) {\n      return '${difference.inHours}h ago';\n    } else if (difference.inMinutes > 0) {\n      return '${difference.inMinutes}m ago';\n    } else {\n      return 'Just now';\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Online/Offline Presence",
              "content": "\nTrack when users are online or offline!\n\n### Presence Service\n\n\n### Online Indicator Widget\n\n\n",
              "code": "// lib/widgets/online_indicator.dart\nimport 'package:flutter/material.dart';\nimport '../services/presence_service.dart';\n\nclass OnlineIndicator extends StatelessWidget {\n  final String userId;\n  final double size;\n\n  const OnlineIndicator({\n    super.key,\n    required this.userId,\n    this.size = 12,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final presenceService = PresenceService();\n\n    return StreamBuilder<bool>(\n      stream: presenceService.getUserOnlineStatus(userId),\n      builder: (context, snapshot) {\n        final isOnline = snapshot.data ?? false;\n\n        return Container(\n          width: size,\n          height: size,\n          decoration: BoxDecoration(\n            color: isOnline ? Colors.green : Colors.grey,\n            shape: BoxShape.circle,\n            border: Border.all(color: Colors.white, width: 2),\n          ),\n        );\n      },\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 3: Typing Indicator",
              "content": "\nShow when someone is typing!\n\n### Typing Service\n\n\n### Add to Chat Screen\n\n\n",
              "code": "// In ChatScreen, add typing indicator\nWidget _buildTypingIndicator() {\n  return StreamBuilder<bool>(\n    stream: _typingService.getTypingStatus(\n      chatRoomId: _chatRoomId,\n      otherUserId: widget.otherUserId,\n    ),\n    builder: (context, snapshot) {\n      if (snapshot.data == true) {\n        return Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            children: [\n              const SizedBox(width: 16),\n              ...List.generate(\n                3,\n                (index) => Padding(\n                  padding: const EdgeInsets.symmetric(horizontal: 2),\n                  child: _AnimatedDot(delay: index * 200),\n                ),\n              ),\n              const SizedBox(width: 8),\n              Text(\n                '${widget.otherUserName} is typing...',\n                style: TextStyle(\n                  color: Colors.grey.shade600,\n                  fontStyle: FontStyle.italic,\n                ),\n              ),\n            ],\n          ),\n        );\n      }\n      return const SizedBox.shrink();\n    },\n  );\n}\n\n// Animated dot widget\nclass _AnimatedDot extends StatefulWidget {\n  final int delay;\n\n  const _AnimatedDot({required this.delay});\n\n  @override\n  State<_AnimatedDot> createState() => _AnimatedDotState();\n}\n\nclass _AnimatedDotState extends State<_AnimatedDot>\n    with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      vsync: this,\n      duration: const Duration(milliseconds: 600),\n    )..repeat();\n\n    Future.delayed(Duration(milliseconds: widget.delay), () {\n      if (mounted) _controller.forward();\n    });\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return FadeTransition(\n      opacity: _controller,\n      child: Container(\n        width: 8,\n        height: 8,\n        decoration: BoxDecoration(\n          color: Colors.grey.shade400,\n          shape: BoxShape.circle,\n        ),\n      ),\n    );\n  }\n}\n\n// Update TextField to track typing\nTextField(\n  controller: _messageController,\n  onChanged: (text) {\n    _typingService.setTyping(\n      chatRoomId: _chatRoomId,\n      userId: _authService.currentUser!.uid,\n      isTyping: text.isNotEmpty,\n    );\n  },\n  // ... rest of TextField\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 4: Live Data Updates (Like Counter)",
              "content": "\nBuild a live like counter that updates in real-time!\n\n\n",
              "code": "// Like button with real-time count\nclass LiveLikeButton extends StatelessWidget {\n  final String postId;\n\n  const LiveLikeButton({super.key, required this.postId});\n\n  @override\n  Widget build(BuildContext context) {\n    final authService = AuthService();\n    final currentUserId = authService.currentUser?.uid;\n\n    return StreamBuilder<DocumentSnapshot>(\n      stream: FirebaseFirestore.instance\n          .collection('posts')\n          .doc(postId)\n          .snapshots(),\n      builder: (context, snapshot) {\n        if (!snapshot.hasData) {\n          return const IconButton(\n            icon: Icon(Icons.favorite_border),\n            onPressed: null,\n          );\n        }\n\n        final data = snapshot.data!.data() as Map<String, dynamic>?;\n        final likes = data?['likes'] as List? ?? [];\n        final hasLiked = currentUserId != null && likes.contains(currentUserId);\n        final likeCount = likes.length;\n\n        return Row(\n          children: [\n            IconButton(\n              icon: Icon(\n                hasLiked ? Icons.favorite : Icons.favorite_border,\n                color: hasLiked ? Colors.red : null,\n              ),\n              onPressed: () async {\n                if (currentUserId == null) return;\n\n                if (hasLiked) {\n                  await FirebaseFirestore.instance\n                      .collection('posts')\n                      .doc(postId)\n                      .update({\n                    'likes': FieldValue.arrayRemove([currentUserId]),\n                  });\n                } else {\n                  await FirebaseFirestore.instance\n                      .collection('posts')\n                      .doc(postId)\n                      .update({\n                    'likes': FieldValue.arrayUnion([currentUserId]),\n                  });\n                }\n              },\n            ),\n            Text('$likeCount'),\n          ],\n        );\n      },\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices for Real-Time Features",
              "content": "\n### ‚úÖ DO:\n1. **Use StreamBuilder** for automatic UI updates\n2. **Dispose streams** properly to prevent memory leaks\n3. **Limit real-time listeners** (don't listen to huge collections)\n4. **Debounce rapid updates** (typing indicators)\n5. **Show loading states** while connecting\n6. **Handle offline mode** gracefully\n7. **Set up presence** on app start, clear on exit\n\n### ‚ùå DON'T:\n1. **Don't listen to entire collections** (use queries with limits)\n2. **Don't forget to cancel listeners** (memory leaks!)\n3. **Don't update on every keystroke** (use debounce)\n4. **Don't rely solely on real-time** (handle offline)\n5. **Don't leave presence \"online\" forever** (set onDisconnect)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhat's the main advantage of using StreamBuilder with Firestore snapshots()?\n\nA) It's faster\nB) It automatically rebuilds the UI when data changes\nC) It uses less memory\nD) It's required by Firebase\n\n### Question 2\nWhy use onDisconnect() for presence detection?\n\nA) It's faster\nB) It automatically sets user offline when they lose connection\nC) Firebase requires it\nD) It saves battery\n\n### Question 3\nWhat should you do to prevent memory leaks with real-time listeners?\n\nA) Use more listeners\nB) Restart the app periodically\nC) Properly dispose streams and controllers\nD) Use HTTP instead\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: It automatically rebuilds the UI when data changes\n\nStreamBuilder listens to Firestore snapshots (a Stream) and automatically rebuilds its child widget whenever new data arrives, providing seamless real-time updates without manual setState() calls.\n\n### Answer 2: B\n**Correct**: It automatically sets user offline when they lose connection\n\nonDisconnect() is a Firebase Realtime Database feature that executes specified operations when a client disconnects (app closes, network lost, etc.), ensuring accurate presence status even if the app crashes.\n\n### Answer 3: C\n**Correct**: Properly dispose streams and controllers\n\nAlways cancel stream subscriptions and dispose controllers in dispose() method to prevent memory leaks. Unmanaged streams continue consuming resources even after widgets are destroyed.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've mastered real-time features! In the next lesson, we'll add **Push Notifications and Analytics** to make your app even more engaging.\n\n**Coming up in Lesson 7: Push Notifications & Analytics**\n- Firebase Cloud Messaging (FCM)\n- Push notifications\n- Analytics events\n- User engagement tracking\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Firebase snapshots() provide real-time data streams\n‚úÖ StreamBuilder automatically rebuilds UI when data changes\n‚úÖ Presence detection shows online/offline status\n‚úÖ Use Realtime Database for ultra-low latency features\n‚úÖ Always dispose streams to prevent memory leaks\n‚úÖ Typing indicators enhance chat UX\n‚úÖ Real-time like counters create engaging experiences\n‚úÖ onDisconnect() ensures accurate presence even after crashes\n\n**You can now build real-time apps like WhatsApp!** üí¨\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "8.7",
          "title": "Module 8, Lesson 7: Push Notifications & Analytics",
          "moduleId": "module-08",
          "order": 8,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "By the end of this lesson, you'll know how to send push notifications to users and track app usage with Firebase Cloud Messaging (FCM) and Firebase Analytics.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Why This Matters",
              "content": "\n**Push notifications and analytics are essential for app success.**\n\n### Push Notifications:\n- **Increase engagement by 88%** (users return more often)\n- **Send time-sensitive updates** (messages, orders, breaking news)\n- **Re-engage inactive users** (bring them back to your app)\n- **95% of successful apps** use push notifications\n\n### Analytics:\n- **Understand user behavior** (what features they use most)\n- **Track conversion rates** (signup, purchases)\n- **Identify problems** (where users get stuck)\n- **Data-driven decisions** (build what users actually want)\n\n**Without notifications and analytics, you're flying blind!**\n\n"
            },
            {
              "type": "ANALOGY",
              "title": "Real-World Analogy: The Doorbell & Security Camera",
              "content": "\n### Push Notifications = Doorbell\n- üîî **Alert you immediately** when something important happens\n- üì¨ **Delivery notifications**: \"Package arrived!\"\n- üëã **Visitor alerts**: \"Someone's at your door!\"\n- ‚è∞ **Reminders**: \"Don't forget your appointment!\"\n\n### Analytics = Security Camera\n- üìπ **Record what happens** in your app\n- üëÅÔ∏è **See user patterns** (when they visit, what they do)\n- üìä **Analyze footage** to improve security\n- üîç **Find issues** before they become problems\n\n**Together, they keep you connected to users and understand their behavior!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Firebase Cloud Messaging (FCM)",
              "content": "\n### How Push Notifications Work\n\n\n",
              "code": "1. App requests permission\n   ‚Üì\n2. FCM generates unique token for device\n   ‚Üì\n3. App sends token to your server (or Firestore)\n   ‚Üì\n4. Server sends notification to FCM\n   ‚Üì\n5. FCM delivers to device\n   ‚Üì\n6. Notification appears on user's screen",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Setup FCM in Flutter",
              "content": "\n### 1. Add Package\n\n\nRun:\n\n### 2. Android Configuration\n\nEdit `android/app/src/main/AndroidManifest.xml`:\n\n\n### 3. iOS Configuration\n\nEdit `ios/Runner/Info.plist`:\n\n\nRequest permission in iOS (done programmatically).\n\n",
              "code": "<dict>\n    <!-- Add this -->\n    <key>FirebaseAppDelegateProxyEnabled</key>\n    <false/>\n</dict>",
              "language": "xml"
            },
            {
              "type": "THEORY",
              "title": "Sending Notifications",
              "content": "\n### Method 1: Firebase Console (Manual)\n\n1. Go to Firebase Console ‚Üí Cloud Messaging\n2. Click **\"Send your first message\"**\n3. Enter:\n   - **Notification title**: \"New Message!\"\n   - **Notification text**: \"You have a new message from John\"\n4. Click **\"Send test message\"**\n5. Paste your FCM token\n6. Click **\"Test\"**\n\n### Method 2: Send to Topics (Best for Broadcasts)\n\n\nThen send via Firebase Console to \"news\" topic.\n\n### Method 3: Send via Cloud Functions (Production)\n\nCreate a Cloud Function to send notifications:\n\n\n",
              "code": "// Firebase Cloud Function (JavaScript/TypeScript)\nconst functions = require('firebase-functions');\nconst admin = require('firebase-admin');\nadmin.initializeApp();\n\nexports.sendNotificationOnNewMessage = functions.firestore\n  .document('chatRooms/{chatRoomId}/messages/{messageId}')\n  .onCreate(async (snapshot, context) => {\n    const message = snapshot.data();\n\n    // Get recipient's FCM token\n    const recipientDoc = await admin.firestore()\n      .collection('users')\n      .doc(message.recipientId)\n      .get();\n\n    const fcmTokens = recipientDoc.data().fcmTokens || [];\n\n    if (fcmTokens.length === 0) return;\n\n    // Send notification\n    const payload = {\n      notification: {\n        title: 'New Message',\n        body: `${message.senderName}: ${message.text}`,\n      },\n      data: {\n        chatRoomId: context.params.chatRoomId,\n        messageId: context.params.messageId,\n      },\n    };\n\n    await admin.messaging().sendToDevice(fcmTokens, payload);\n  });",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Firebase Analytics",
              "content": "\n### Setup Analytics\n\nFirebase Analytics is included with `firebase_core` - no extra package needed!\n\n### Track Events\n\n\n### Track Navigation\n\n\n### Usage Example\n\n\n",
              "code": "// In your screens\nfinal analytics = AnalyticsService();\n\n// Track screen view\n@override\nvoid initState() {\n  super.initState();\n  analytics.logScreenView('Home Screen');\n}\n\n// Track button clicks\nElevatedButton(\n  onPressed: () {\n    analytics.logButtonClick('create_post_button');\n    // ... button action\n  },\n  child: const Text('Create Post'),\n)\n\n// Track signup\nawait authService.register(...);\nanalytics.logSignUp('email');\n\n// Track login\nawait authService.login(...);\nanalytics.logLogin('google');",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "View Analytics Data",
              "content": "\n### Firebase Console\n\n1. Go to Firebase Console ‚Üí Analytics\n2. View dashboards:\n   - **Users**: Active users, new users\n   - **Events**: All tracked events\n   - **Conversions**: Signup, purchases\n   - **Engagement**: Session duration, screens per session\n\n### Custom Reports\n\n1. Analytics ‚Üí Events\n2. Click \"Create custom report\"\n3. Select metrics and dimensions\n4. Save for recurring analysis\n\n"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n### Notifications ‚úÖ DO:\n1. **Request permission at the right time** (after user sees value)\n2. **Personalize notifications** (use user's name, relevant content)\n3. **Don't spam** (max 2-3 per day)\n4. **Provide value** (useful info, not just \"Open the app!\")\n5. **Allow unsubscribe** (topic-based subscriptions)\n6. **Test on real devices** (not just emulator)\n7. **Handle tap actions** (navigate to relevant screen)\n\n### Notifications ‚ùå DON'T:\n1. **Don't request permission immediately** on app launch\n2. **Don't send at bad times** (2am notifications = angry users)\n3. **Don't send generic messages** (\"Check out our app!\")\n4. **Don't ignore user preferences** (respect opt-outs)\n5. **Don't forget to test** on iOS and Android\n\n### Analytics ‚úÖ DO:\n1. **Track key user actions** (signup, purchase, share)\n2. **Set user properties** (subscription type, preferences)\n3. **Create conversion funnels** (how many complete signup?)\n4. **Review weekly** (make data-driven decisions)\n5. **Respect privacy** (don't track sensitive data)\n\n### Analytics ‚ùå DON'T:\n1. **Don't track PII** (passwords, credit cards, SSN)\n2. **Don't track everything** (focus on meaningful events)\n3. **Don't ignore the data** (collect but never analyze = waste)\n4. **Don't violate privacy laws** (GDPR, CCPA compliance)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhy save FCM tokens to Firestore?\n\nA) Firebase requires it\nB) So you can send targeted notifications to specific users\nC) To make the app faster\nD) It's not necessary\n\n### Question 2\nWhen should you request notification permission?\n\nA) Immediately on app launch\nB) After users see the value of notifications\nC) Never\nD) After they create an account\n\n### Question 3\nWhat should you avoid tracking with Firebase Analytics?\n\nA) Button clicks\nB) Screen views\nC) Passwords and credit card numbers\nD) User signups\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: So you can send targeted notifications to specific users\n\nFCM tokens are unique per device. By saving them to Firestore with the user's ID, you can send notifications to specific users (e.g., \"John sent you a message\"). Without storing tokens, you can only broadcast to all users or topics.\n\n### Answer 2: B\n**Correct**: After users see the value of notifications\n\nIf you ask for permission immediately, users don't understand why they need it and often decline. Show value first (e.g., let them start a chat), then request permission with context (\"Get notified when you receive messages\").\n\n### Answer 3: C\n**Correct**: Passwords and credit card numbers\n\nNEVER track personally identifiable information (PII) or sensitive data like passwords, credit cards, SSN, health information. This violates privacy laws (GDPR, CCPA) and puts users at risk. Track user behavior, not sensitive data.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nYou've learned push notifications and analytics! In the final lesson, we'll build a **Complete Firebase Mini-Project** that combines everything from Module 8.\n\n**Coming up in Lesson 8: Mini-Project - Complete Firebase App**\n- Full-stack social app\n- Authentication\n- Real-time chat\n- File uploads\n- Push notifications\n- Production-ready code\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Firebase Cloud Messaging (FCM) sends push notifications to users\n‚úÖ Request permission after users see notification value\n‚úÖ Save FCM tokens to Firestore for targeted notifications\n‚úÖ Use topics for broadcast notifications (news, promotions)\n‚úÖ firebase_analytics tracks user behavior automatically\n‚úÖ Track meaningful events (signup, purchase, key actions)\n‚úÖ Never track sensitive data (passwords, credit cards)\n‚úÖ Review analytics weekly to make data-driven decisions\n‚úÖ Respect user privacy and comply with GDPR/CCPA\n\n**You can now build engaging apps with notifications and understand user behavior!** üìä\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "8.8",
          "title": "Module 8, Lesson 8: Mini-Project - Complete Firebase Social App",
          "moduleId": "module-08",
          "order": 9,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\n**Welcome to your Module 8 capstone project!** üéâ\n\nIn this mini-project, you'll build **\"FireSocial\"** - a complete social media app that combines **EVERY Firebase concept** from Module 8:\n\n‚úÖ Firebase Authentication (email & Google)\n‚úÖ Cloud Firestore (posts, likes, comments)\n‚úÖ Cloud Storage (profile pictures, post images)\n‚úÖ Security Rules (production-ready)\n‚úÖ Real-time features (live likes, typing indicators)\n‚úÖ Push notifications (new likes, comments)\n‚úÖ Analytics (track user behavior)\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You'll Build",
              "content": "\n### FireSocial Features\n\n1. **Authentication**\n   - Email/password & Google Sign-In\n   - Profile creation with photo upload\n   - Secure session management\n\n2. **User Profiles**\n   - Profile picture upload\n   - Bio and user info\n   - Post count\n   - Edit profile\n\n3. **Posts Feed**\n   - Create posts with images\n   - Real-time feed updates\n   - Like posts (with real-time counter)\n   - Comment on posts\n   - Delete own posts\n\n4. **Real-Time Chat**\n   - Direct messages\n   - Typing indicators\n   - Online/offline status\n   - Message notifications\n\n5. **Push Notifications**\n   - New likes on your posts\n   - New comments\n   - New messages\n   - Topic-based (announcements)\n\n6. **Analytics**\n   - Track screen views\n   - Log user actions\n   - Conversion tracking\n\n"
            },
            {
              "type": "THEORY",
              "title": "Step 1: Setup & Dependencies",
              "content": "\n### pubspec.yaml\n\n\nRun:\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 2: Complete Data Models",
              "content": "\n### User Model\n\n\n### Post Model\n\n\n",
              "code": "// lib/models/post_model.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\n\nclass Post {\n  final String id;\n  final String userId;\n  final String userName;\n  final String? userPhotoURL;\n  final String caption;\n  final String imageURL;\n  final List<String> likes;\n  final int commentCount;\n  final DateTime createdAt;\n\n  Post({\n    required this.id,\n    required this.userId,\n    required this.userName,\n    this.userPhotoURL,\n    required this.caption,\n    required this.imageURL,\n    this.likes = const [],\n    this.commentCount = 0,\n    DateTime? createdAt,\n  }) : createdAt = createdAt ?? DateTime.now();\n\n  factory Post.fromFirestore(DocumentSnapshot doc) {\n    final data = doc.data() as Map<String, dynamic>;\n    return Post(\n      id: doc.id,\n      userId: data['userId'] ?? '',\n      userName: data['userName'] ?? 'Unknown',\n      userPhotoURL: data['userPhotoURL'],\n      caption: data['caption'] ?? '',\n      imageURL: data['imageURL'] ?? '',\n      likes: List<String>.from(data['likes'] ?? []),\n      commentCount: data['commentCount'] ?? 0,\n      createdAt: (data['createdAt'] as Timestamp).toDate(),\n    );\n  }\n\n  Map<String, dynamic> toMap() {\n    return {\n      'userId': userId,\n      'userName': userName,\n      'userPhotoURL': userPhotoURL,\n      'caption': caption,\n      'imageURL': imageURL,\n      'likes': likes,\n      'commentCount': commentCount,\n      'createdAt': Timestamp.fromDate(createdAt),\n    };\n  }\n\n  bool isLikedBy(String userId) => likes.contains(userId);\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 8: Security Rules (CRITICAL!)",
              "content": "\n### Firestore Security Rules\n\n\n### Storage Security Rules\n\n\n",
              "code": "rules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    function isSignedIn() {\n      return request.auth != null;\n    }\n\n    function isOwner(userId) {\n      return isSignedIn() && request.auth.uid == userId;\n    }\n\n    // User profile pictures\n    match /users/{userId}/profile/{fileName} {\n      allow read: if true;\n      allow write: if isOwner(userId)\n                   && request.resource.contentType.matches('image/.*')\n                   && request.resource.size < 5 * 1024 * 1024;  // 5MB max\n    }\n\n    // Post images\n    match /posts/{userId}/{fileName} {\n      allow read: if true;\n      allow write: if isOwner(userId)\n                   && request.resource.contentType.matches('image/.*')\n                   && request.resource.size < 10 * 1024 * 1024;  // 10MB max\n    }\n  }\n}",
              "language": "javascript"
            },
            {
              "type": "THEORY",
              "title": "Testing Your App",
              "content": "\n### 1. Authentication\n- ‚úÖ Register with email/password\n- ‚úÖ Login with Google\n- ‚úÖ Logout\n\n### 2. Posts\n- ‚úÖ Create post with image\n- ‚úÖ View feed (real-time updates)\n- ‚úÖ Like/unlike posts\n- ‚úÖ Delete own posts\n\n### 3. Profile\n- ‚úÖ Upload profile picture\n- ‚úÖ Edit bio\n- ‚úÖ View post count\n\n### 4. Real-Time\n- ‚úÖ Open app on 2 devices\n- ‚úÖ Like post on device 1\n- ‚úÖ Watch count update on device 2!\n\n### 5. Security\n- ‚úÖ Try accessing other user's data (should fail)\n- ‚úÖ Try uploading oversized file (should fail)\n- ‚úÖ Check Firebase Console ‚Üí Security Rules\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You've Accomplished",
              "content": "\nCongratulations! You've built a complete social media app with:\n\n‚úÖ **Authentication**: Secure email & Google login\n‚úÖ **Database**: Real-time Firestore with complex queries\n‚úÖ **Storage**: File uploads with validation\n‚úÖ **Security**: Production-ready security rules\n‚úÖ **Real-Time**: Live updates across all devices\n‚úÖ **Notifications**: Push notifications (if implemented)\n‚úÖ **Analytics**: User behavior tracking\n\n**This is a production-ready foundation!**\n\n"
            },
            {
              "type": "THEORY",
              "title": "Next Steps & Enhancements",
              "content": "\nWant to take this further? Try adding:\n\n1. **Comments System**: Full comment threads with replies\n2. **User Following**: Follow/unfollow users, follower counts\n3. **Feed Algorithm**: Show posts from followed users only\n4. **Stories**: Instagram-style 24-hour stories\n5. **Hashtags**: Search posts by hashtags\n6. **Mentions**: Tag users in posts/comments\n7. **Direct Messages**: Real-time one-on-one chat\n8. **Push Notifications**: Notify on likes, comments, follows\n9. **Video Posts**: Upload and play videos\n10. **Search**: Search users and posts\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz Time! üß†",
              "content": "\n### Question 1\nWhy use StreamBuilder for the posts feed?\n\nA) It's faster\nB) It provides automatic real-time updates when posts change\nC) Firebase requires it\nD) It uses less memory\n\n### Question 2\nWhy increment postCount in Firestore when creating a post?\n\nA) Firebase requires it\nB) To avoid querying all posts to count them (performance)\nC) It's not necessary\nD) To make the app faster\n\n### Question 3\nWhat's the most important part of a production Firebase app?\n\nA) Beautiful UI\nB) Security rules\nC) Analytics\nD) Notifications\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n### Answer 1: B\n**Correct**: It provides automatic real-time updates when posts change\n\nStreamBuilder listens to Firestore's `snapshots()` stream and automatically rebuilds the UI whenever data changes. When someone creates/deletes a post, all users see the update instantly without manual refresh.\n\n### Answer 2: B\n**Correct**: To avoid querying all posts to count them (performance)\n\nStoring an aggregated count prevents expensive queries. Without it, you'd need to fetch all user posts just to count them (slow and costly). Firestore charges per document read, so fewer reads = lower costs.\n\n### Answer 3: B\n**Correct**: Security rules\n\nWithout proper security rules, your database is wide open - anyone can read/write/delete anything. Beautiful UI doesn't matter if hackers steal all user data. Security rules are the foundation of production apps.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Congratulations! üéâ",
              "content": "\n**You've completed Module 8: Backend Integration!**\n\nYou now have the skills to build production-ready apps with:\n- Secure authentication\n- Real-time cloud databases\n- File storage\n- Push notifications\n- User analytics\n- Complete backend infrastructure\n\n**You're ready for Module 9: Advanced Features!** Where you'll learn animations, local storage, camera integration, and more.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Takeaways",
              "content": "\n‚úÖ Firebase provides a complete backend solution (auth, database, storage, notifications)\n‚úÖ StreamBuilder enables real-time updates across all devices\n‚úÖ Security rules are CRITICAL - never deploy without them\n‚úÖ Store aggregated data (counts) to avoid expensive queries\n‚úÖ Use caching (CachedNetworkImage) for better performance\n‚úÖ Test on multiple devices to verify real-time sync\n‚úÖ Always dispose streams and controllers to prevent memory leaks\n\n**Module 8 Complete - You're now a full-stack Flutter developer!** üöÄ\n\n"
            }
          ],
          "challenges": []
        }
      ]
    },
    {
      "id": "module-09",
      "title": "Module 9: Flutter Development",
      "description": "Learn Flutter development - Module 9",
      "difficulty": "intermediate",
      "estimatedHours": 8,
      "lessons": [
        {
          "id": "9.1",
          "title": "Lesson 1: Introduction to Animations",
          "moduleId": "module-09",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Understanding animations and their importance\n- Implicit vs explicit animations\n- AnimatedContainer and AnimatedOpacity\n- Hero animations for screen transitions\n- Custom animations with AnimationController\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: Why Animations Matter",
              "content": "\n### Real-World Analogy\nThink of animations like the smooth movements in a well-choreographed dance. Without animations, your app would be like a slideshow of still photos. With animations, it becomes a fluid movie where each transition tells a story and guides the user's attention.\n\nJust like how a door **gradually swings open** (not teleporting from closed to open), good UI animations help users understand what's happening and where things are going.\n\n### Why This Matters\nAnimations are not just \"eye candy\" - they serve important purposes:\n\n1. **Feedback**: Show that a button was pressed\n2. **Guidance**: Direct attention to important elements\n3. **Relationships**: Show how UI elements connect\n4. **Continuity**: Smooth transitions prevent jarring experiences\n5. **Polish**: Professional apps feel smooth and responsive\n\nAccording to Material Design guidelines, animations should be:\n- **Fast**: 200-300ms for most transitions\n- **Natural**: Follow physics (easing curves, not linear)\n- **Purposeful**: Every animation should have a reason\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up",
              "content": "\nNo external packages needed for basic animations! Flutter has powerful built-in animation widgets.\n\nFor advanced animations (optional):\n\n",
              "code": "dependencies:\n  flutter_animate: ^4.5.0  # Easy-to-use animation effects",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "The Animation Building Blocks",
              "content": "\n### 1. Implicit Animations (Easy Mode)\n\nThese are \"smart\" widgets that automatically animate when their properties change.\n\n**Example: AnimatedContainer**\n\n\n**How It Works:**\n- Change the properties in `setState()`\n- AnimatedContainer detects the changes\n- Automatically animates from old ‚Üí new values\n- Magic! ‚ú®\n\n### 2. More Implicit Animation Widgets\n\n\n### 3. Hero Animations (Shared Element Transitions)\n\nHero animations create smooth transitions when navigating between screens.\n\n**Screen 1 (List of Items):**\n\n**Screen 2 (Detail):**\n\n**How Hero Works:**\n1. Both screens have a `Hero` widget with the **same tag**\n2. When navigating, Flutter finds both Hero widgets\n3. Automatically animates the transition between them\n4. The image \"flies\" from list to detail screen!\n\n",
              "code": "class ProductDetailScreen extends StatelessWidget {\n  final int productId;\n\n  ProductDetailScreen({required this.productId});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Product Details')),\n      body: Column(\n        children: [\n          // Same Hero tag = automatic animation!\n          Hero(\n            tag: 'product-$productId',\n            child: Image.network(\n              'https://picsum.photos/seed/$productId/400',\n              height: 300,\n              width: double.infinity,\n              fit: BoxFit.cover,\n            ),\n          ),\n          Padding(\n            padding: EdgeInsets.all(16),\n            child: Text(\n              'Product $productId Details',\n              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Explicit Animations (Full Control)",
              "content": "\nFor complex custom animations, use `AnimationController`.\n\n### Complete Example: Pulsing Heart\n\n\n**Key Concepts:**\n- **AnimationController**: Controls the animation (start, stop, reverse)\n- **Tween**: Defines start and end values\n- **CurvedAnimation**: Applies easing curves\n- **AnimatedBuilder**: Rebuilds when animation changes\n- **SingleTickerProviderStateMixin**: Optimizes animations\n\n",
              "code": "class PulsingHeartScreen extends StatefulWidget {\n  @override\n  State<PulsingHeartScreen> createState() => _PulsingHeartScreenState();\n}\n\nclass _PulsingHeartScreenState extends State<PulsingHeartScreen>\n    with SingleTickerProviderStateMixin {  // Required for animations\n\n  late AnimationController _controller;\n  late Animation<double> _scaleAnimation;\n  late Animation<Color?> _colorAnimation;\n\n  @override\n  void initState() {\n    super.initState();\n\n    // 1. Create the controller (the \"conductor\")\n    _controller = AnimationController(\n      duration: Duration(milliseconds: 800),\n      vsync: this,  // Sync with screen refresh\n    );\n\n    // 2. Create animations (the \"dancers\")\n    _scaleAnimation = Tween<double>(\n      begin: 1.0,\n      end: 1.3,\n    ).animate(CurvedAnimation(\n      parent: _controller,\n      curve: Curves.easeInOut,\n    ));\n\n    _colorAnimation = ColorTween(\n      begin: Colors.red,\n      end: Colors.pink,\n    ).animate(_controller);\n\n    // 3. Make it loop\n    _controller.repeat(reverse: true);\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();  // Always clean up!\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Pulsing Heart')),\n      body: Center(\n        child: AnimatedBuilder(\n          animation: _controller,\n          builder: (context, child) {\n            return Transform.scale(\n              scale: _scaleAnimation.value,\n              child: Icon(\n                Icons.favorite,\n                size: 100,\n                color: _colorAnimation.value,\n              ),\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          if (_controller.isAnimating) {\n            _controller.stop();\n          } else {\n            _controller.repeat(reverse: true);\n          }\n          setState(() {});\n        },\n        child: Icon(_controller.isAnimating ? Icons.pause : Icons.play_arrow),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Animation Curves",
              "content": "\nCurves make animations feel natural (not robotic).\n\n\n**Example Usage:**\n\n",
              "code": "AnimatedContainer(\n  duration: Duration(milliseconds: 300),\n  curve: Curves.bounceOut,  // Add personality!\n  // ... properties\n)",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Animated Login Screen",
              "content": "\n\n**Advanced Techniques Used:**\n- **Interval**: Stagger animations (logo first, then form)\n- **ScaleTransition**: Built-in widget for scaling\n- **SlideTransition**: Built-in widget for sliding\n- **FadeTransition**: Built-in widget for fading\n\n",
              "code": "import 'package:flutter/material.dart';\n\nclass AnimatedLoginScreen extends StatefulWidget {\n  @override\n  State<AnimatedLoginScreen> createState() => _AnimatedLoginScreenState();\n}\n\nclass _AnimatedLoginScreenState extends State<AnimatedLoginScreen>\n    with SingleTickerProviderStateMixin {\n\n  late AnimationController _controller;\n  late Animation<double> _logoScale;\n  late Animation<Offset> _formSlide;\n  late Animation<double> _formFade;\n\n  @override\n  void initState() {\n    super.initState();\n\n    _controller = AnimationController(\n      duration: Duration(milliseconds: 1500),\n      vsync: this,\n    );\n\n    // Logo scales up\n    _logoScale = Tween<double>(begin: 0.0, end: 1.0).animate(\n      CurvedAnimation(\n        parent: _controller,\n        curve: Interval(0.0, 0.5, curve: Curves.elasticOut),\n      ),\n    );\n\n    // Form slides up from bottom\n    _formSlide = Tween<Offset>(\n      begin: Offset(0, 1),\n      end: Offset.zero,\n    ).animate(\n      CurvedAnimation(\n        parent: _controller,\n        curve: Interval(0.3, 0.8, curve: Curves.easeOut),\n      ),\n    );\n\n    // Form fades in\n    _formFade = Tween<double>(begin: 0.0, end: 1.0).animate(\n      CurvedAnimation(\n        parent: _controller,\n        curve: Interval(0.5, 1.0, curve: Curves.easeIn),\n      ),\n    );\n\n    // Start the animation\n    _controller.forward();\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Container(\n        decoration: BoxDecoration(\n          gradient: LinearGradient(\n            begin: Alignment.topLeft,\n            end: Alignment.bottomRight,\n            colors: [Colors.blue.shade300, Colors.purple.shade300],\n          ),\n        ),\n        child: SafeArea(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              // Animated Logo\n              ScaleTransition(\n                scale: _logoScale,\n                child: Icon(\n                  Icons.lock_outline,\n                  size: 120,\n                  color: Colors.white,\n                ),\n              ),\n\n              SizedBox(height: 50),\n\n              // Animated Form\n              SlideTransition(\n                position: _formSlide,\n                child: FadeTransition(\n                  opacity: _formFade,\n                  child: Padding(\n                    padding: EdgeInsets.all(20),\n                    child: Card(\n                      elevation: 8,\n                      shape: RoundedRectangleBorder(\n                        borderRadius: BorderRadius.circular(16),\n                      ),\n                      child: Padding(\n                        padding: EdgeInsets.all(20),\n                        child: Column(\n                          children: [\n                            Text(\n                              'Welcome Back',\n                              style: TextStyle(\n                                fontSize: 28,\n                                fontWeight: FontWeight.bold,\n                              ),\n                            ),\n                            SizedBox(height: 20),\n                            TextField(\n                              decoration: InputDecoration(\n                                labelText: 'Email',\n                                prefixIcon: Icon(Icons.email),\n                              ),\n                            ),\n                            SizedBox(height: 16),\n                            TextField(\n                              obscureText: true,\n                              decoration: InputDecoration(\n                                labelText: 'Password',\n                                prefixIcon: Icon(Icons.lock),\n                              ),\n                            ),\n                            SizedBox(height: 24),\n                            ElevatedButton(\n                              onPressed: () {},\n                              style: ElevatedButton.styleFrom(\n                                minimumSize: Size(double.infinity, 50),\n                              ),\n                              child: Text('Login', style: TextStyle(fontSize: 18)),\n                            ),\n                          ],\n                        ),\n                      ),\n                    ),\n                  ),\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Quick Reference: Implicit Animation Widgets",
              "content": "\n| Widget | What It Animates | Use Case |\n|--------|------------------|----------|\n| AnimatedContainer | Size, color, padding, decoration | Most versatile |\n| AnimatedOpacity | Transparency | Fade in/out |\n| AnimatedPositioned | Position (in Stack) | Move elements |\n| AnimatedAlign | Alignment | Snap to corners |\n| AnimatedPadding | Padding | Spacing changes |\n| AnimatedSwitcher | Widget replacement | Toggle content |\n| AnimatedCrossFade | Fade between 2 widgets | A/B switches |\n| AnimatedDefaultTextStyle | Text style | Text formatting |\n| AnimatedPhysicalModel | Elevation, shadow | 3D effects |\n\n"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Keep It Fast**: 200-400ms for most animations\n2. **Be Consistent**: Use same durations/curves throughout app\n3. **Don't Overdo It**: Not every element needs animation\n4. **Test on Real Devices**: Animations look different on actual hardware\n5. **Dispose Controllers**: Always call `dispose()` to prevent memory leaks\n6. **Use Implicit First**: Only use explicit animations when needed\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the difference between implicit and explicit animations?\nA) Implicit are faster than explicit\nB) Implicit animate automatically when properties change; explicit require AnimationController\nC) Explicit can only animate colors\nD) There is no difference\n\n**Question 2:** What does the `Hero` widget require to work across screens?\nA) The same tag on both screens\nB) The same size widget\nC) An AnimationController\nD) The flutter_animate package\n\n**Question 3:** What is the recommended duration for most UI animations?\nA) 50-100ms\nB) 200-400ms\nC) 1-2 seconds\nD) As long as possible for dramatic effect\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Bouncing Ball",
              "content": "\nCreate a screen with a ball that:\n1. Bounces up and down continuously\n2. Changes color on each bounce\n3. Has a pause/play button\n\n**Hints:**\n- Use `AnimationController` with `repeat(reverse: true)`\n- Use `Tween<double>` for position\n- Use `ColorTween` for color changes\n- Use `Curves.bounceOut` for natural motion\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've learned how to bring your Flutter apps to life with animations! Here's what we covered:\n\n- **Implicit Animations**: Easy, automatic animations (AnimatedContainer, AnimatedOpacity, etc.)\n- **Hero Animations**: Smooth shared element transitions between screens\n- **Explicit Animations**: Full control with AnimationController\n- **Animation Curves**: Make animations feel natural\n- **Best Practices**: Keep it fast, consistent, and purposeful\n\nAnimations transform your app from functional to delightful. Users may not notice good animations, but they'll definitely feel the difference!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) Implicit animate automatically when properties change; explicit require AnimationController\n\nImplicit animations (like AnimatedContainer) detect property changes and animate automatically. Explicit animations require manual setup with AnimationController for full control.\n\n**Answer 2:** A) The same tag on both screens\n\nHero animations work by matching the `tag` property. Flutter finds Hero widgets with the same tag and animates between them during navigation.\n\n**Answer 3:** B) 200-400ms\n\nMaterial Design recommends 200-400ms for most transitions. This is fast enough to be responsive but slow enough to be noticeable and guide user attention.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "9.2",
          "title": "Lesson 2: Camera and Photo Gallery",
          "moduleId": "module-09",
          "order": 2,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Accessing device camera and photo gallery\n- Using the image_picker package\n- Handling permissions on Android and iOS\n- Displaying and saving selected images\n- Taking photos vs selecting from gallery\n- Building a complete photo app\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: Why Camera Access Matters",
              "content": "\n### Real-World Analogy\nThink of your app accessing the camera like a valet service at a hotel. The valet (your app) needs **permission** to drive your car (access the camera). Once you give permission, the valet can:\n- Use your car for a specific task (take a photo)\n- Return it when done (give you the image)\n- But can't just take your car whenever they want (must ask each time)\n\nModern phones treat camera and photos as **private property** - apps must explicitly ask permission and users can revoke it anytime.\n\n### Why This Matters\nCamera and gallery access enables powerful features:\n\n1. **Profile Pictures**: Let users personalize their accounts\n2. **Content Creation**: Social media, blogging, marketplace apps\n3. **Document Scanning**: Receipt capture, ID verification\n4. **Visual Search**: Take a photo to search for products\n5. **AR Features**: Augmented reality experiences\n\nAccording to App Annie, photo/camera features increase user engagement by 35% in social apps!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up",
              "content": "\n### 1. Add Dependencies\n\n**pubspec.yaml:**\n\nRun:\n\n### 2. Android Configuration\n\n**android/app/src/main/AndroidManifest.xml:**\n\n### 3. iOS Configuration\n\n**ios/Runner/Info.plist:**\n\n**Important:** Customize the permission messages to explain **why** your app needs access!\n\n",
              "code": "<dict>\n    <!-- Camera permission description -->\n    <key>NSCameraUsageDescription</key>\n    <string>We need access to your camera to take photos for your profile.</string>\n\n    <!-- Photo library permission description -->\n    <key>NSPhotoLibraryUsageDescription</key>\n    <string>We need access to your photo library to select images.</string>\n\n    <!-- For iOS 14+ -->\n    <key>NSPhotoLibraryAddUsageDescription</key>\n    <string>We need permission to save photos to your library.</string>\n</dict>",
              "language": "xml"
            },
            {
              "type": "THEORY",
              "title": "Basic Usage: ImagePicker",
              "content": "\n### Simple Example: Pick from Gallery\n\n\n### Taking Photos with Camera\n\n\n### Picking Multiple Images (Android 13+, iOS 14+)\n\n\n",
              "code": "Future<void> _pickMultipleImages() async {\n  try {\n    final List<XFile> images = await _picker.pickMultipleImages(\n      imageQuality: 80,\n      maxWidth: 1920,\n    );\n\n    if (images.isNotEmpty) {\n      setState(() {\n        _imageFiles = images.map((img) => File(img.path)).toList();\n      });\n\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('${images.length} images selected')),\n      );\n    }\n  } catch (e) {\n    print('Error picking multiple images: $e');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Photo Profile Editor",
              "content": "\n\n**Key Features:**\n- ‚úÖ Permission handling with fallback to settings\n- ‚úÖ Choose camera or gallery via bottom sheet\n- ‚úÖ Loading indicator during processing\n- ‚úÖ Remove photo option\n- ‚úÖ Circular avatar display\n- ‚úÖ Image compression to save memory\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:image_picker/image_picker.dart';\nimport 'package:permission_handler/permission_handler.dart';\nimport 'dart:io';\n\nclass PhotoProfileScreen extends StatefulWidget {\n  @override\n  State<PhotoProfileScreen> createState() => _PhotoProfileScreenState();\n}\n\nclass _PhotoProfileScreenState extends State<PhotoProfileScreen> {\n  File? _profileImage;\n  final ImagePicker _picker = ImagePicker();\n  bool _isLoading = false;\n\n  // Check and request permissions\n  Future<bool> _requestPermission(Permission permission) async {\n    final status = await permission.status;\n\n    if (status.isGranted) {\n      return true;\n    } else if (status.isDenied) {\n      final result = await permission.request();\n      return result.isGranted;\n    } else if (status.isPermanentlyDenied) {\n      // User permanently denied - open settings\n      await openAppSettings();\n      return false;\n    }\n\n    return false;\n  }\n\n  Future<void> _pickImageSource() async {\n    // Show dialog to choose camera or gallery\n    final ImageSource? source = await showModalBottomSheet<ImageSource>(\n      context: context,\n      builder: (context) => SafeArea(\n        child: Wrap(\n          children: [\n            ListTile(\n              leading: Icon(Icons.camera_alt, color: Colors.blue),\n              title: Text('Take Photo'),\n              onTap: () => Navigator.pop(context, ImageSource.camera),\n            ),\n            ListTile(\n              leading: Icon(Icons.photo_library, color: Colors.green),\n              title: Text('Choose from Gallery'),\n              onTap: () => Navigator.pop(context, ImageSource.gallery),\n            ),\n            if (_profileImage != null)\n              ListTile(\n                leading: Icon(Icons.delete, color: Colors.red),\n                title: Text('Remove Photo'),\n                onTap: () {\n                  setState(() => _profileImage = null);\n                  Navigator.pop(context);\n                },\n              ),\n          ],\n        ),\n      ),\n    );\n\n    if (source != null) {\n      await _pickImage(source);\n    }\n  }\n\n  Future<void> _pickImage(ImageSource source) async {\n    setState(() => _isLoading = true);\n\n    try {\n      // Request appropriate permission\n      final permission = source == ImageSource.camera\n          ? Permission.camera\n          : Permission.photos;\n\n      final hasPermission = await _requestPermission(permission);\n\n      if (!hasPermission) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(\n            content: Text('Permission denied. Please enable in settings.'),\n            action: SnackBarAction(\n              label: 'Settings',\n              onPressed: () => openAppSettings(),\n            ),\n          ),\n        );\n        return;\n      }\n\n      // Pick the image\n      final XFile? image = await _picker.pickImage(\n        source: source,\n        imageQuality: 85,\n        maxWidth: 1024,\n        maxHeight: 1024,\n      );\n\n      if (image != null) {\n        setState(() {\n          _profileImage = File(image.path);\n        });\n\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Photo updated successfully!')),\n        );\n      }\n    } catch (e) {\n      print('Error: $e');\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Error: ${e.toString()}')),\n      );\n    } finally {\n      setState(() => _isLoading = false);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Edit Profile Photo'),\n        actions: [\n          if (_profileImage != null)\n            TextButton(\n              onPressed: () {\n                // Save photo (implement your save logic)\n                ScaffoldMessenger.of(context).showSnackBar(\n                  SnackBar(content: Text('Photo saved!')),\n                );\n              },\n              child: Text('SAVE', style: TextStyle(color: Colors.white)),\n            ),\n        ],\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Profile photo display\n            Stack(\n              children: [\n                CircleAvatar(\n                  radius: 100,\n                  backgroundColor: Colors.grey[300],\n                  backgroundImage: _profileImage != null\n                      ? FileImage(_profileImage!)\n                      : null,\n                  child: _profileImage == null\n                      ? Icon(Icons.person, size: 80, color: Colors.grey[600])\n                      : null,\n                ),\n\n                // Loading indicator\n                if (_isLoading)\n                  Positioned.fill(\n                    child: Container(\n                      decoration: BoxDecoration(\n                        shape: BoxShape.circle,\n                        color: Colors.black45,\n                      ),\n                      child: Center(\n                        child: CircularProgressIndicator(color: Colors.white),\n                      ),\n                    ),\n                  ),\n\n                // Edit button overlay\n                Positioned(\n                  bottom: 0,\n                  right: 0,\n                  child: GestureDetector(\n                    onTap: _isLoading ? null : _pickImageSource,\n                    child: Container(\n                      padding: EdgeInsets.all(8),\n                      decoration: BoxDecoration(\n                        color: Theme.of(context).primaryColor,\n                        shape: BoxShape.circle,\n                        border: Border.all(color: Colors.white, width: 3),\n                      ),\n                      child: Icon(Icons.camera_alt, color: Colors.white, size: 24),\n                    ),\n                  ),\n                ),\n              ],\n            ),\n\n            SizedBox(height: 40),\n\n            Text(\n              'Tap the camera icon to update your photo',\n              style: TextStyle(color: Colors.grey[600], fontSize: 16),\n            ),\n\n            SizedBox(height: 20),\n\n            // Alternative: Large button\n            ElevatedButton.icon(\n              onPressed: _isLoading ? null : _pickImageSource,\n              icon: Icon(Icons.add_a_photo),\n              label: Text(_profileImage == null ? 'Add Photo' : 'Change Photo'),\n              style: ElevatedButton.styleFrom(\n                padding: EdgeInsets.symmetric(horizontal: 32, vertical: 16),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Platform Differences",
              "content": "\n### Android 13+ (API 33+)\n- Uses the new **Android Photo Picker** (privacy-focused)\n- Users can select photos without granting full storage access\n- More secure and privacy-friendly\n\n### Android 12 and Below\n- Uses traditional file picker\n- Requires `READ_EXTERNAL_STORAGE` permission\n\n### iOS 14+\n- Uses **PHPicker** (privacy-focused)\n- Similar to Android Photo Picker\n- Users can select specific photos without granting full library access\n\n"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Always Compress Images**\n   ```dart\n   await _picker.pickImage(\n     source: ImageSource.gallery,\n     imageQuality: 80,  // 80% quality is usually enough\n     maxWidth: 1920,    // Limit dimensions\n   );\n   ```\n\n2. **Handle Permissions Gracefully**\n   - Explain **why** you need permission (in Info.plist/AndroidManifest)\n   - Provide fallback if permission denied\n   - Guide users to settings if permanently denied\n\n3. **Dispose of Large Images**\n   ```dart\n   @override\n   void dispose() {\n     _selectedImage?.delete();  // Clean up temp files\n     super.dispose();\n   }\n   ```\n\n4. **Show Loading Indicators**\n   - Picking/compressing images takes time\n   - Always show progress to user\n\n5. **Validate Image Files**\n   ```dart\n   Future<bool> _isValidImage(File file) async {\n     final bytes = await file.length();\n     final maxSize = 10 * 1024 * 1024;  // 10 MB\n\n     if (bytes > maxSize) {\n       ScaffoldMessenger.of(context).showSnackBar(\n         SnackBar(content: Text('Image too large! Max 10 MB')),\n       );\n       return false;\n     }\n\n     return true;\n   }\n   ```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Common Issues & Solutions",
              "content": "\n**Issue 1: \"Lost connection to device\" when using camera**\n- **Solution**: Run on physical device, not simulator\n- Camera doesn't work in iOS Simulator\n\n**Issue 2: Permission permanently denied**\n- **Solution**: Guide user to app settings\n  ```dart\n  await openAppSettings();\n  ```\n\n**Issue 3: Large images cause memory issues**\n- **Solution**: Always use `maxWidth`, `maxHeight`, `imageQuality`\n\n**Issue 4: Images don't persist after app restart**\n- **Solution**: Copy from temp directory to app documents\n  ```dart\n  final appDir = await getApplicationDocumentsDirectory();\n  final fileName = basename(image.path);\n  final savedImage = await File(image.path).copy('${appDir.path}/$fileName');\n  ```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** Which ImageSource would you use to let users take a new photo?\nA) ImageSource.gallery\nB) ImageSource.camera\nC) ImageSource.files\nD) ImageSource.photos\n\n**Question 2:** Why should you compress images before uploading?\nA) To make them look better\nB) To reduce memory usage and upload time\nC) Because it's required by image_picker\nD) To increase image quality\n\n**Question 3:** What happens if a user permanently denies camera permission?\nA) The app crashes\nB) You can force enable it programmatically\nC) You should guide them to app settings to enable it manually\nD) The permission request will keep showing\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Mini Photo Editor",
              "content": "\nBuild a screen that:\n1. Lets users pick an image from gallery or camera\n2. Displays the image with filter options (grayscale, sepia, etc.)\n3. Has a \"Save\" button that shows a success message\n4. Handles all permissions properly\n\n**Bonus Challenge:**\n- Add image rotation (90¬∞ increments)\n- Add crop functionality\n- Save edited image to device\n\n**Hint:** Use the `image` package for filters:\n\n",
              "code": "dependencies:\n  image: ^4.2.0",
              "language": "yaml"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered camera and gallery access in Flutter! Here's what we covered:\n\n- **Setup**: Platform-specific permissions (Android & iOS)\n- **ImagePicker**: Simple API for camera and gallery\n- **Permissions**: Proper permission handling with fallbacks\n- **Multiple Images**: Picking and displaying image grids\n- **Best Practices**: Compression, validation, and error handling\n\nWith these skills, you can build photo-centric features for profiles, social media, marketplaces, and more!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) ImageSource.camera\n\n`ImageSource.camera` opens the device camera to take a new photo. `ImageSource.gallery` opens the photo library/gallery to select existing photos.\n\n**Answer 2:** B) To reduce memory usage and upload time\n\nCompressing images (via `imageQuality`, `maxWidth`, `maxHeight`) reduces file size significantly, saving memory and making uploads faster. High-resolution photos can be 5-10 MB; compressed versions might be 500 KB.\n\n**Answer 3:** C) You should guide them to app settings to enable it manually\n\nWhen permanently denied, you cannot request permission again. Use `openAppSettings()` from `permission_handler` to help users navigate to settings where they can manually enable permissions.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "9.3",
          "title": "Lesson 3: Local Storage with Hive",
          "moduleId": "module-09",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Understanding local storage options in Flutter\n- Setting up and using Hive (fast NoSQL database)\n- Storing simple data with SharedPreferences\n- Type adapters for custom objects\n- Lazy boxes for memory efficiency\n- Building a complete notes app with local storage\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: Why Local Storage?",
              "content": "\n### Real-World Analogy\nThink of local storage like your phone's contacts app. When you save a contact, it's stored **on your device** - not in the cloud. This means:\n- ‚úÖ Works without internet\n- ‚úÖ Instant access (no network delays)\n- ‚úÖ Privacy (data stays on device)\n- ‚úÖ Survives app restarts\n\nLocal storage is like having a filing cabinet in your office vs. a warehouse across town. Your local cabinet is much faster to access!\n\n### Why This Matters\nLocal storage is essential for:\n\n1. **Offline Functionality**: Apps work without internet\n2. **Settings & Preferences**: Remember user choices\n3. **Caching**: Store data for faster loading\n4. **Draft Content**: Save work-in-progress\n5. **Performance**: Instant access vs. network calls\n\nAccording to Google, users expect apps to work offline. 87% of users get frustrated when apps don't save their data locally!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Storage Options Comparison",
              "content": "\n| Option | Use Case | Performance | Complexity |\n|--------|----------|-------------|------------|\n| **SharedPreferences** | Simple key-value (settings, flags) | Fast | Easy ‚≠ê |\n| **Hive** | Structured data (notes, todos, cache) | Very Fast | Medium ‚≠ê‚≠ê |\n| **SQLite** | Relational data, complex queries | Fast | Hard ‚≠ê‚≠ê‚≠ê |\n| **Secure Storage** | Sensitive data (tokens, passwords) | Medium | Easy ‚≠ê |\n\n**This lesson focuses on Hive and SharedPreferences** (we'll cover SQLite in the next lesson).\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 1: SharedPreferences (Simple Storage)",
              "content": "\n### Setup\n\n\n\n### Basic Usage\n\n\n**Available Methods:**\n\n",
              "code": "// Save\nawait prefs.setBool('key', true);\nawait prefs.setString('key', 'value');\nawait prefs.setInt('key', 42);\nawait prefs.setDouble('key', 3.14);\nawait prefs.setStringList('key', ['a', 'b', 'c']);\n\n// Read (with defaults)\nfinal boolValue = prefs.getBool('key') ?? false;\nfinal stringValue = prefs.getString('key') ?? '';\nfinal intValue = prefs.getInt('key') ?? 0;\nfinal doubleValue = prefs.getDouble('key') ?? 0.0;\nfinal listValue = prefs.getStringList('key') ?? [];\n\n// Check existence\nfinal exists = prefs.containsKey('key');\n\n// Remove single key\nawait prefs.remove('key');\n\n// Clear all\nawait prefs.clear();",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Hive (NoSQL Database)",
              "content": "\nHive is **blazing fast** (10x faster than SQLite for reads) and works great for structured data.\n\n### Setup\n\n\n\n### Initialize Hive\n\n\n### Simple Usage (Key-Value)\n\n\n",
              "code": "import 'package:hive_flutter/hive_flutter.dart';\n\nclass HiveSimpleExample extends StatefulWidget {\n  @override\n  State<HiveSimpleExample> createState() => _HiveSimpleExampleState();\n}\n\nclass _HiveSimpleExampleState extends State<HiveSimpleExample> {\n  final box = Hive.box('notes');\n\n  void _saveNote() {\n    box.put('note1', 'My first note');\n    box.put('note2', 'Another note');\n    box.put('counter', 42);\n\n    setState(() {});\n  }\n\n  void _readNote() {\n    final note1 = box.get('note1', defaultValue: 'No note');\n    final counter = box.get('counter', defaultValue: 0);\n\n    print('Note: $note1, Counter: $counter');\n  }\n\n  void _deleteNote() {\n    box.delete('note1');\n    setState(() {});\n  }\n\n  void _deleteAll() {\n    box.clear();\n    setState(() {});\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Hive Simple Demo')),\n      body: Column(\n        children: [\n          ElevatedButton(onPressed: _saveNote, child: Text('Save Notes')),\n          ElevatedButton(onPressed: _readNote, child: Text('Read Note')),\n          ElevatedButton(onPressed: _deleteNote, child: Text('Delete Note 1')),\n          ElevatedButton(onPressed: _deleteAll, child: Text('Delete All')),\n\n          SizedBox(height: 20),\n\n          Text('All Keys: ${box.keys.toList()}'),\n          Text('All Values: ${box.values.toList()}'),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Storing Custom Objects with Type Adapters",
              "content": "\n### Step 1: Create a Model\n\n\n### Step 2: Generate Type Adapter\n\nRun this command:\n\nThis creates `note.g.dart` with the type adapter code.\n\n### Step 3: Register and Use\n\n\n**Key Methods:**\n\n",
              "code": "// Add (returns auto-increment key)\nfinal key = box.add(note);\n\n// Put with custom key\nbox.put('my-key', note);\n\n// Get by key\nfinal note = box.get('my-key');\n\n// Get by index\nfinal note = box.getAt(0);\n\n// Update (for HiveObject subclasses)\nnote.title = 'New Title';\nnote.save();\n\n// Delete\nbox.delete('my-key');\nbox.deleteAt(0);\n\n// Get all values\nfinal allNotes = box.values.toList();\n\n// Get all keys\nfinal allKeys = box.keys.toList();\n\n// Count\nfinal count = box.length;\n\n// Clear all\nbox.clear();",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Lazy Boxes (For Large Data)",
              "content": "\nUse lazy boxes when you have **lots of data** and don't want to load everything into memory.\n\n\n**When to use:**\n- Regular Box: < 1000 items (loads all into memory)\n- Lazy Box: > 1000 items (loads on demand)\n\n",
              "code": "// Open lazy box\nfinal lazyBox = await Hive.openLazyBox<Note>('large_notes');\n\n// Read (async because it loads from disk on demand)\nfinal note = await lazyBox.get('key');\n\n// Write (same as regular box)\nawait lazyBox.put('key', note);",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Initialize Once**\n   ```dart\n   void main() async {\n     await Hive.initFlutter();  // Call once at app start\n     // ...\n   }\n   ```\n\n2. **Use ValueListenableBuilder**\n   - Automatically rebuilds UI when data changes\n   - No need for setState()\n\n3. **Don't Close Boxes Frequently**\n   ```dart\n   // ‚ùå Bad\n   final box = await Hive.openBox('data');\n   // ... use box\n   await box.close();\n\n   // ‚úÖ Good\n   final box = await Hive.openBox('data');  // Open once\n   // ... use throughout app lifecycle\n   // Close only when app exits\n   ```\n\n4. **Use Type Safety**\n   ```dart\n   // ‚úÖ Good\n   final box = Hive.box<Note>('notes');\n\n   // ‚ùå Bad (no type checking)\n   final box = Hive.box('notes');\n   ```\n\n5. **Handle Migrations**\n   ```dart\n   @HiveField(4, defaultValue: false)  // Add default for new fields\n   bool isPinned;\n   ```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Hive vs SharedPreferences vs SQLite",
              "content": "\n**Use SharedPreferences for:**\n- Settings (dark mode, language)\n- Simple flags (onboarding completed)\n- Small primitive values\n\n**Use Hive for:**\n- Structured data (notes, todos, user profiles)\n- Offline-first apps\n- Fast read/write performance\n- 100s-1000s of records\n\n**Use SQLite for:**\n- Complex relationships (foreign keys)\n- Advanced queries (JOIN, GROUP BY)\n- 10,000s+ records\n- When you need SQL\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the main difference between Hive boxes and lazy boxes?\nA) Lazy boxes are slower\nB) Regular boxes load all data into memory; lazy boxes load on demand\nC) Lazy boxes can't store custom objects\nD) There is no difference\n\n**Question 2:** Which storage solution is best for saving a user's theme preference?\nA) SQLite\nB) Hive\nC) SharedPreferences\nD) Firebase\n\n**Question 3:** When using custom objects with Hive, what must you do?\nA) Nothing, it works automatically\nB) Create a type adapter and register it\nC) Use JSON encoding manually\nD) Store objects as strings\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Todo App with Local Storage",
              "content": "\nBuild a todo app that:\n1. Stores todos locally with Hive\n2. Has categories (Work, Personal, Shopping)\n3. Supports marking todos as complete\n4. Persists data across app restarts\n5. Shows todo count by category\n\n**Bonus:**\n- Add due dates with reminders\n- Search functionality\n- Export todos to text file\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered local storage in Flutter! Here's what we covered:\n\n- **SharedPreferences**: Simple key-value storage for settings\n- **Hive Setup**: Fast NoSQL database initialization\n- **Type Adapters**: Storing custom objects with code generation\n- **CRUD Operations**: Add, read, update, delete data\n- **ValueListenableBuilder**: Reactive UI updates\n- **Best Practices**: When to use each storage solution\n\nWith local storage, your apps can work offline and provide instant user experiences!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) Regular boxes load all data into memory; lazy boxes load on demand\n\nRegular Hive boxes load all data into memory for fast access. Lazy boxes only load data when explicitly requested, making them better for large datasets (1000s+ items) but slightly slower for individual reads.\n\n**Answer 2:** C) SharedPreferences\n\nTheme preferences are simple key-value settings - perfect for SharedPreferences. Using Hive or SQLite would be overkill for a single boolean/string value.\n\n**Answer 3:** B) Create a type adapter and register it\n\nHive needs to know how to serialize/deserialize custom objects. You must:\n1. Annotate class with `@HiveType`\n2. Run `build_runner` to generate adapter\n3. Register adapter with `Hive.registerAdapter()`\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "9.4",
          "title": "Lesson 4: SQLite Database",
          "moduleId": "module-09",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Understanding relational databases\n- Setting up and using SQLite with sqflite\n- Creating tables and schemas\n- CRUD operations (Create, Read, Update, Delete)\n- Advanced queries with WHERE, ORDER BY, JOIN\n- Database migrations and versioning\n- Building a complete contacts app\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: What is SQLite?",
              "content": "\n### Real-World Analogy\nThink of SQLite like an **Excel spreadsheet on steroids**:\n- **Tables** = Spreadsheet tabs\n- **Rows** = Individual records (like spreadsheet rows)\n- **Columns** = Data fields (name, age, email)\n- **Relationships** = Links between tables (like VLOOKUP)\n\nBut unlike Excel, SQLite:\n- ‚úÖ Handles millions of rows efficiently\n- ‚úÖ Enforces data types and rules\n- ‚úÖ Supports complex queries and joins\n- ‚úÖ Is transactional (changes are atomic)\n\n### Why This Matters\nSQLite is perfect for:\n\n1. **Complex Data Structures**: Multiple related tables\n2. **Large Datasets**: 10,000s+ records\n3. **Advanced Queries**: Search, filter, sort, group\n4. **Data Integrity**: Foreign keys, constraints, transactions\n5. **Industry Standard**: Used by Android, iOS, Chrome, Firefox\n\nAccording to SQLite.org, it's the **most deployed database engine** in the world - billions of copies in active use!\n\n"
            },
            {
              "type": "THEORY",
              "title": "When to Use SQLite vs Hive",
              "content": "\n| Feature | SQLite | Hive |\n|---------|--------|------|\n| **Data Structure** | Relational (tables with relationships) | Key-value, NoSQL |\n| **Query Language** | SQL (SELECT, JOIN, GROUP BY) | Dart methods |\n| **Performance** | Good for complex queries | 10x faster for simple reads |\n| **Learning Curve** | Medium (need SQL knowledge) | Easy (pure Dart) |\n| **Use Case** | Contact apps, inventory, analytics | Notes, settings, cache |\n| **Record Count** | 10,000s+ | 100s-1000s |\n\n**Rule of Thumb:**\n- Simple data structure ‚Üí Hive\n- Need relationships or complex queries ‚Üí SQLite\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up",
              "content": "\n### 1. Add Dependencies\n\n**pubspec.yaml:**\n\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "EXAMPLE",
              "title": "Basic SQLite Example",
              "content": "\n### Step 1: Create a Database Helper\n\n\n### Step 2: Use in Your App\n\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'database_helper.dart';\n\nclass SQLiteDemo extends StatefulWidget {\n  @override\n  State<SQLiteDemo> createState() => _SQLiteDemoState();\n}\n\nclass _SQLiteDemoState extends State<SQLiteDemo> {\n  final DatabaseHelper _db = DatabaseHelper();\n  List<Map<String, dynamic>> _notes = [];\n  final _titleController = TextEditingController();\n  final _contentController = TextEditingController();\n\n  @override\n  void initState() {\n    super.initState();\n    _loadNotes();\n  }\n\n  Future<void> _loadNotes() async {\n    final notes = await _db.getAllNotes();\n    setState(() {\n      _notes = notes;\n    });\n  }\n\n  Future<void> _addNote() async {\n    if (_titleController.text.isEmpty) return;\n\n    await _db.insertNote({\n      'title': _titleController.text,\n      'content': _contentController.text,\n      'created_at': DateTime.now().millisecondsSinceEpoch,\n    });\n\n    _titleController.clear();\n    _contentController.clear();\n    _loadNotes();\n\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text('Note added!')),\n    );\n  }\n\n  Future<void> _deleteNote(int id) async {\n    await _db.deleteNote(id);\n    _loadNotes();\n\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text('Note deleted')),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('SQLite Demo (${_notes.length} notes)')),\n      body: Column(\n        children: [\n          // Input form\n          Padding(\n            padding: EdgeInsets.all(16),\n            child: Column(\n              children: [\n                TextField(\n                  controller: _titleController,\n                  decoration: InputDecoration(labelText: 'Title'),\n                ),\n                TextField(\n                  controller: _contentController,\n                  decoration: InputDecoration(labelText: 'Content'),\n                  maxLines: 3,\n                ),\n                SizedBox(height: 10),\n                ElevatedButton(\n                  onPressed: _addNote,\n                  child: Text('Add Note'),\n                ),\n              ],\n            ),\n          ),\n\n          Divider(),\n\n          // Notes list\n          Expanded(\n            child: _notes.isEmpty\n                ? Center(child: Text('No notes yet!'))\n                : ListView.builder(\n                    itemCount: _notes.length,\n                    itemBuilder: (context, index) {\n                      final note = _notes[index];\n                      final createdAt = DateTime.fromMillisecondsSinceEpoch(\n                        note['created_at'],\n                      );\n\n                      return ListTile(\n                        title: Text(note['title']),\n                        subtitle: Column(\n                          crossAxisAlignment: CrossAxisAlignment.start,\n                          children: [\n                            Text(note['content'] ?? ''),\n                            SizedBox(height: 4),\n                            Text(\n                              'Created: ${createdAt.toString().split('.')[0]}',\n                              style: TextStyle(fontSize: 12, color: Colors.grey),\n                            ),\n                          ],\n                        ),\n                        trailing: IconButton(\n                          icon: Icon(Icons.delete, color: Colors.red),\n                          onPressed: () => _deleteNote(note['id']),\n                        ),\n                      );\n                    },\n                  ),\n          ),\n        ],\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    _titleController.dispose();\n    _contentController.dispose();\n    super.dispose();\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Using Models (Type-Safe Approach)",
              "content": "\n### Step 1: Create a Model\n\n\n### Step 2: Update DatabaseHelper\n\n\n",
              "code": "class DatabaseHelper {\n  // ... previous code ...\n\n  // Type-safe methods\n  Future<int> insertNoteObject(Note note) async {\n    final db = await database;\n    return await db.insert('notes', note.toMap());\n  }\n\n  Future<List<Note>> getAllNotesObjects() async {\n    final db = await database;\n    final maps = await db.query('notes', orderBy: 'created_at DESC');\n\n    return maps.map((map) => Note.fromMap(map)).toList();\n  }\n\n  Future<Note?> getNoteObject(int id) async {\n    final db = await database;\n    final maps = await db.query(\n      'notes',\n      where: 'id = ?',\n      whereArgs: [id],\n    );\n\n    return maps.isNotEmpty ? Note.fromMap(maps.first) : null;\n  }\n\n  Future<int> updateNoteObject(Note note) async {\n    final db = await database;\n    return await db.update(\n      'notes',\n      note.toMap(),\n      where: 'id = ?',\n      whereArgs: [note.id],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Advanced Queries",
              "content": "\n### 1. WHERE Clauses (Filtering)\n\n\n### 2. ORDER BY (Sorting)\n\n\n### 3. LIMIT and OFFSET (Pagination)\n\n\n### 4. COUNT and Aggregations\n\n\n",
              "code": "// Get total note count\nFuture<int> getTotalNoteCount() async {\n  final db = await database;\n  final result = await db.rawQuery('SELECT COUNT(*) as count FROM notes');\n\n  return Sqflite.firstIntValue(result) ?? 0;\n}\n\n// Get notes grouped by date\nFuture<Map<String, int>> getNotesCountByDate() async {\n  final db = await database;\n  final results = await db.rawQuery('''\n    SELECT DATE(created_at / 1000, 'unixepoch') as date, COUNT(*) as count\n    FROM notes\n    GROUP BY date\n    ORDER BY date DESC\n  ''');\n\n  return {for (var row in results) row['date'] as String: row['count'] as int};\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Database Migrations",
              "content": "\nWhen you need to change your database schema:\n\n\n",
              "code": "Future<Database> _initDatabase() async {\n  final dbPath = await getDatabasesPath();\n  final path = join(dbPath, 'my_database.db');\n\n  return await openDatabase(\n    path,\n    version: 2,  // Increment version number\n    onCreate: _onCreate,\n    onUpgrade: _onUpgrade,  // Handle migration\n  );\n}\n\nFuture<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {\n  if (oldVersion < 2) {\n    // Add new column to existing table\n    await db.execute('ALTER TABLE notes ADD COLUMN is_favorite INTEGER DEFAULT 0');\n  }\n\n  // Add more migrations as needed\n  // if (oldVersion < 3) { ... }\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Use Transactions for Multiple Operations**\n   ```dart\n   Future<void> bulkInsert(List<Note> notes) async {\n     final db = await database;\n\n     await db.transaction((txn) async {\n       for (var note in notes) {\n         await txn.insert('notes', note.toMap());\n       }\n     });\n   }\n   ```\n\n2. **Always Use Parameterized Queries (Prevent SQL Injection)**\n   ```dart\n   // ‚úÖ Good - parameterized\n   await db.query('notes', where: 'title = ?', whereArgs: [userInput]);\n\n   // ‚ùå Bad - vulnerable to SQL injection\n   await db.rawQuery(\"SELECT * FROM notes WHERE title = '$userInput'\");\n   ```\n\n3. **Close Database When App Exits**\n   ```dart\n   @override\n   void dispose() {\n     DatabaseHelper().close();\n     super.dispose();\n   }\n   ```\n\n4. **Use Indexes for Frequently Queried Columns**\n   ```dart\n   await db.execute('CREATE INDEX idx_created_at ON notes(created_at)');\n   ```\n\n5. **Batch Operations for Performance**\n   ```dart\n   final batch = db.batch();\n   for (var note in notes) {\n     batch.insert('notes', note.toMap());\n   }\n   await batch.commit();\n   ```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the main advantage of SQLite over Hive?\nA) It's faster for all operations\nB) It supports complex queries and relational data\nC) It's easier to use\nD) It doesn't require setup\n\n**Question 2:** What does the `?` placeholder do in SQLite queries?\nA) It's a wildcard like `*`\nB) It's replaced with values from `whereArgs` to prevent SQL injection\nC) It marks optional parameters\nD) It indicates null values\n\n**Question 3:** How do you handle database schema changes in sqflite?\nA) Delete the old database and create a new one\nB) Use the `onUpgrade` callback with version numbers\nC) Manually edit the database file\nD) Schema changes are automatic\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Expense Tracker",
              "content": "\nBuild an expense tracker app with:\n1. Categories table (Food, Transport, Entertainment, etc.)\n2. Expenses table with amount, description, date, category_id\n3. Display total expenses by category\n4. Filter expenses by date range\n5. Search expenses by description\n\n**Bonus Challenges:**\n- Add recurring expenses\n- Export data to CSV\n- Show expense trends with charts\n- Budget limits per category\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered SQLite in Flutter! Here's what we covered:\n\n- **Database Setup**: Singleton pattern with DatabaseHelper\n- **CRUD Operations**: Create, Read, Update, Delete\n- **Type-Safe Models**: Converting between objects and maps\n- **Advanced Queries**: WHERE, ORDER BY, LIMIT, JOIN, COUNT\n- **Relationships**: Foreign keys and JOIN queries\n- **Migrations**: Handling schema changes with onUpgrade\n- **Best Practices**: Transactions, parameterized queries, indexes\n\nSQLite gives you the power of a full relational database right on the device!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) It supports complex queries and relational data\n\nSQLite excels at relational data (multiple tables with relationships) and complex queries (JOIN, GROUP BY, aggregations). Hive is faster for simple key-value operations but lacks SQL query capabilities.\n\n**Answer 2:** B) It's replaced with values from `whereArgs` to prevent SQL injection\n\nThe `?` placeholder is a parameter marker that gets safely replaced with values from the `whereArgs` array. This prevents SQL injection attacks by properly escaping user input. Never concatenate user input directly into SQL strings!\n\n**Answer 3:** B) Use the `onUpgrade` callback with version numbers\n\nWhen you change your database schema, increment the `version` number in `openDatabase()` and handle the migration in the `onUpgrade` callback. This safely updates the database structure while preserving existing data.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "9.5",
          "title": "Lesson 5: Maps and Location",
          "moduleId": "module-09",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Integrating Google Maps in Flutter\n- Getting user's current location\n- Adding markers and custom pins\n- Drawing routes and polylines\n- Geocoding (address ‚Üî coordinates)\n- Building a location-based app\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: Why Maps and Location?",
              "content": "\n### Real-World Analogy\nThink of adding maps to your app like giving it **eyes and a GPS**:\n- **Geolocation** = Knowing where you are (like a compass)\n- **Google Maps** = Seeing the world (like a detailed paper map)\n- **Markers** = Sticky notes on the map\n- **Polylines** = Drawing routes with a highlighter\n\nJust like how \"You Are Here\" signs help you navigate a mall, location features help users navigate the real world through your app.\n\n### Why This Matters\nLocation features power essential apps:\n\n1. **Ride-Sharing**: Uber, Lyft (find drivers, track rides)\n2. **Food Delivery**: DoorDash, Uber Eats (track deliveries)\n3. **Dating Apps**: Tinder, Bumble (find nearby matches)\n4. **Fitness**: Strava, RunKeeper (track running routes)\n5. **Real Estate**: Zillow (find properties near you)\n\nAccording to Google, 76% of people who search for something nearby visit a business within a day!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up",
              "content": "\n### 1. Get Google Maps API Key\n\n**Android:**\n1. Go to [Google Cloud Console](https://console.cloud.google.com/)\n2. Create a project\n3. Enable \"Maps SDK for Android\"\n4. Create credentials ‚Üí API Key\n5. Add to `android/app/src/main/AndroidManifest.xml`:\n\n\n**iOS:**\n1. Same Google Cloud Console project\n2. Enable \"Maps SDK for iOS\"\n3. Add to `ios/Runner/AppDelegate.swift`:\n\n\n### 2. Add Dependencies\n\n**pubspec.yaml:**\n\n\n### 3. Configure Permissions\n\n**Android (`android/app/src/main/AndroidManifest.xml`):**\n\n**iOS (`ios/Runner/Info.plist`):**\n\n",
              "code": "<dict>\n    <key>NSLocationWhenInUseUsageDescription</key>\n    <string>We need your location to show nearby places.</string>\n\n    <key>NSLocationAlwaysUsageDescription</key>\n    <string>We need your location for background tracking.</string>\n</dict>",
              "language": "xml"
            },
            {
              "type": "THEORY",
              "title": "Basic Google Maps Integration",
              "content": "\n### Simple Map Display\n\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\n\nclass BasicMapScreen extends StatefulWidget {\n  @override\n  State<BasicMapScreen> createState() => _BasicMapScreenState();\n}\n\nclass _BasicMapScreenState extends State<BasicMapScreen> {\n  late GoogleMapController _mapController;\n\n  // Initial camera position (San Francisco)\n  final CameraPosition _initialPosition = CameraPosition(\n    target: LatLng(37.7749, -122.4194),\n    zoom: 12,\n  );\n\n  void _onMapCreated(GoogleMapController controller) {\n    _mapController = controller;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Google Maps')),\n      body: GoogleMap(\n        onMapCreated: _onMapCreated,\n        initialCameraPosition: _initialPosition,\n        myLocationEnabled: true,  // Show user's location\n        myLocationButtonEnabled: true,  // Show location button\n        mapType: MapType.normal,  // normal, satellite, hybrid, terrain\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Getting User's Current Location",
              "content": "\n### Using Geolocator\n\n\n### Move Map to User's Location\n\n\n",
              "code": "class UserLocationMapScreen extends StatefulWidget {\n  @override\n  State<UserLocationMapScreen> createState() => _UserLocationMapScreenState();\n}\n\nclass _UserLocationMapScreenState extends State<UserLocationMapScreen> {\n  late GoogleMapController _mapController;\n  final LocationService _locationService = LocationService();\n  Position? _currentPosition;\n  bool _isLoading = true;\n\n  @override\n  void initState() {\n    super.initState();\n    _getCurrentLocation();\n  }\n\n  Future<void> _getCurrentLocation() async {\n    final position = await _locationService.getCurrentLocation();\n\n    if (position != null) {\n      setState(() {\n        _currentPosition = position;\n        _isLoading = false;\n      });\n\n      // Move camera to user's location\n      _mapController.animateCamera(\n        CameraUpdate.newCameraPosition(\n          CameraPosition(\n            target: LatLng(position.latitude, position.longitude),\n            zoom: 15,\n          ),\n        ),\n      );\n    } else {\n      setState(() => _isLoading = false);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('My Location')),\n      body: _isLoading\n          ? Center(child: CircularProgressIndicator())\n          : GoogleMap(\n              onMapCreated: (controller) => _mapController = controller,\n              initialCameraPosition: CameraPosition(\n                target: _currentPosition != null\n                    ? LatLng(_currentPosition!.latitude, _currentPosition!.longitude)\n                    : LatLng(37.7749, -122.4194),\n                zoom: 15,\n              ),\n              myLocationEnabled: true,\n              myLocationButtonEnabled: true,\n            ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _getCurrentLocation,\n        child: Icon(Icons.my_location),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Adding Markers",
              "content": "\n\n### Custom Marker Icons\n\n\n",
              "code": "// Load custom marker from assets\nBitmapDescriptor? _customIcon;\n\nFuture<void> _loadCustomMarker() async {\n  _customIcon = await BitmapDescriptor.fromAssetImage(\n    ImageConfiguration(devicePixelRatio: 2.5),\n    'assets/images/custom_marker.png',\n  );\n}\n\n// Use in marker\nMarker(\n  markerId: MarkerId('custom'),\n  position: LatLng(37.7749, -122.4194),\n  icon: _customIcon ?? BitmapDescriptor.defaultMarker,\n)",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Geocoding (Address ‚Üî Coordinates)",
              "content": "\n\n**Usage Example:**\n\n",
              "code": "// Search for address\nfinal coordinates = await GeocodingService().getCoordinatesFromAddress(\n  '1600 Amphitheatre Parkway, Mountain View, CA',\n);\n\nif (coordinates != null) {\n  _mapController.animateCamera(\n    CameraUpdate.newLatLng(coordinates),\n  );\n}\n\n// Get address from tap\nvoid _onMapTap(LatLng position) async {\n  final address = await GeocodingService().getAddressFromCoordinates(\n    position.latitude,\n    position.longitude,\n  );\n\n  print('Address: $address');\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Always Check Permissions**\n   ```dart\n   final hasPermission = await Permission.location.request();\n   if (!hasPermission.isGranted) {\n     // Show error or guide user to settings\n     return;\n   }\n   ```\n\n2. **Handle Location Services Disabled**\n   ```dart\n   if (!await Geolocator.isLocationServiceEnabled()) {\n     await Geolocator.openLocationSettings();\n   }\n   ```\n\n3. **Dispose Map Controller**\n   ```dart\n   @override\n   void dispose() {\n     _mapController.dispose();\n     super.dispose();\n   }\n   ```\n\n4. **Use Different Accuracy for Different Needs**\n   ```dart\n   // High accuracy (GPS) - battery intensive\n   LocationAccuracy.high\n\n   // Medium accuracy - balanced\n   LocationAccuracy.medium\n\n   // Low accuracy - battery friendly\n   LocationAccuracy.low\n   ```\n\n5. **Cache Map Data for Offline Use**\n   - Google Maps automatically caches viewed areas\n   - For full offline support, consider OpenStreetMap alternatives\n\n"
            },
            {
              "type": "THEORY",
              "title": "Common Issues & Solutions",
              "content": "\n**Issue 1: Map shows blank/gray screen**\n- **Solution**: Check API key is correct and enabled\n- Verify billing is enabled in Google Cloud Console\n\n**Issue 2: \"Location services are disabled\"**\n- **Solution**: Guide user to enable in device settings\n  ```dart\n  await Geolocator.openLocationSettings();\n  ```\n\n**Issue 3: Markers not showing**\n- **Solution**: Ensure markers Set is passed to GoogleMap widget\n- Check zoom level isn't too far out\n\n**Issue 4: App crashes on iOS when accessing location**\n- **Solution**: Add usage descriptions to Info.plist\n- Request permission before accessing location\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the difference between `LocationAccuracy.high` and `LocationAccuracy.low`?\nA) High is slower but more accurate\nB) High uses GPS (precise but battery-intensive); low uses network (less precise, battery-friendly)\nC) There is no difference\nD) Low accuracy is deprecated\n\n**Question 2:** How do you convert an address to coordinates?\nA) Use `geolocator` package\nB) Use `locationFromAddress()` from geocoding package\nC) Manually parse with regex\nD) Google Maps does it automatically\n\n**Question 3:** What is a Polyline used for?\nA) Marking single locations\nB) Drawing routes/paths on the map\nC) Setting map boundaries\nD) Clustering markers\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Delivery Tracker",
              "content": "\nBuild a delivery tracking app that:\n1. Shows delivery driver's live location\n2. Draws route from restaurant ‚Üí customer\n3. Updates ETA as driver moves\n4. Shows distance remaining\n\n**Bonus Challenges:**\n- Add multiple delivery stops\n- Show traffic conditions\n- Send notifications when driver is nearby\n- Estimate delivery time based on speed\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered maps and location in Flutter! Here's what we covered:\n\n- **Google Maps Integration**: Setup and basic map display\n- **Geolocation**: Getting user's current location with geolocator\n- **Permissions**: Handling location permissions gracefully\n- **Markers**: Adding custom pins and info windows\n- **Polylines**: Drawing routes and paths\n- **Geocoding**: Converting addresses ‚Üî coordinates\n- **Complete App**: Nearby places finder with filtering\n\nWith these skills, you can build location-aware apps like ride-sharing, delivery tracking, and social discovery!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) High uses GPS (precise but battery-intensive); low uses network (less precise, battery-friendly)\n\n`LocationAccuracy.high` uses GPS for precise location (¬±5-10 meters) but drains battery. `LocationAccuracy.low` uses WiFi/cell towers (¬±100-500 meters) but is battery-friendly. Choose based on your app's needs!\n\n**Answer 2:** B) Use `locationFromAddress()` from geocoding package\n\nThe `geocoding` package provides `locationFromAddress()` for forward geocoding (address ‚Üí coordinates) and `placemarkFromCoordinates()` for reverse geocoding (coordinates ‚Üí address).\n\n**Answer 3:** B) Drawing routes/paths on the map\n\nPolylines draw connected lines between multiple LatLng points, perfect for showing routes, paths, or boundaries. Markers are for single points, not routes.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "9.6",
          "title": "Lesson 6: Device Features (Sensors & Biometrics)",
          "moduleId": "module-09",
          "order": 6,
          "estimatedMinutes": 55,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Biometric authentication (fingerprint, Face ID)\n- Accelerometer and gyroscope sensors\n- Shake detection\n- Vibration and haptic feedback\n- Battery status and device info\n- Building secure and interactive apps\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: Why Device Features?",
              "content": "\n### Real-World Analogy\nThink of your phone's hardware features like the **five senses** of your app:\n- **Biometrics** = Identity verification (like a bouncer checking ID)\n- **Accelerometer** = Motion sensing (like your inner ear for balance)\n- **Vibration** = Touch feedback (like feeling a tap on your shoulder)\n- **Battery** = Energy awareness (like checking your car's fuel gauge)\n\nJust like humans use multiple senses to interact with the world, apps use device features to create richer, more secure experiences!\n\n### Why This Matters\nDevice features enable unique experiences:\n\n1. **Security**: Biometric login (banking apps, password managers)\n2. **Fitness**: Step tracking, workout monitoring (Fitbit, Strava)\n3. **Gaming**: Motion controls (racing games, AR games)\n4. **Productivity**: Shake to undo, vibrate on notifications\n5. **Accessibility**: Haptic feedback for visually impaired users\n\nAccording to Apple, Face ID is 20x more secure than Touch ID, and biometric authentication increases user engagement by 45%!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Biometric Authentication",
              "content": "\n### Setup\n\n**pubspec.yaml:**\n\n**Android Configuration (`android/app/src/main/AndroidManifest.xml`):**\n\n**iOS Configuration (`ios/Runner/Info.plist`):**\n\n### Basic Biometric Authentication\n\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:local_auth/local_auth.dart';\nimport 'package:local_auth/error_codes.dart' as auth_error;\n\nclass BiometricAuthScreen extends StatefulWidget {\n  @override\n  State<BiometricAuthScreen> createState() => _BiometricAuthScreenState();\n}\n\nclass _BiometricAuthScreenState extends State<BiometricAuthScreen> {\n  final LocalAuthentication _localAuth = LocalAuthentication();\n  bool _isAuthenticated = false;\n  List<BiometricType> _availableBiometrics = [];\n\n  @override\n  void initState() {\n    super.initState();\n    _checkBiometrics();\n  }\n\n  // Check what biometrics are available\n  Future<void> _checkBiometrics() async {\n    try {\n      // Check if device supports biometrics\n      final canCheckBiometrics = await _localAuth.canCheckBiometrics;\n      final isDeviceSupported = await _localAuth.isDeviceSupported();\n\n      if (canCheckBiometrics && isDeviceSupported) {\n        // Get list of available biometrics\n        final availableBiometrics = await _localAuth.getAvailableBiometrics();\n\n        setState(() {\n          _availableBiometrics = availableBiometrics;\n        });\n\n        print('Available biometrics: $_availableBiometrics');\n        // Possible values:\n        // - BiometricType.face (Face ID on iOS, face unlock on Android)\n        // - BiometricType.fingerprint (Touch ID on iOS, fingerprint on Android)\n        // - BiometricType.iris (Iris scanner on Samsung devices)\n      }\n    } catch (e) {\n      print('Error checking biometrics: $e');\n    }\n  }\n\n  // Authenticate with biometrics\n  Future<void> _authenticate() async {\n    try {\n      final authenticated = await _localAuth.authenticate(\n        localizedReason: 'Please authenticate to access your account',\n        options: AuthenticationOptions(\n          stickyAuth: true,  // Show auth dialog until user interacts\n          biometricOnly: false,  // Allow PIN/password fallback\n        ),\n      );\n\n      setState(() {\n        _isAuthenticated = authenticated;\n      });\n\n      if (authenticated) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(\n            content: Text('Authentication successful!'),\n            backgroundColor: Colors.green,\n          ),\n        );\n      }\n    } on PlatformException catch (e) {\n      // Handle errors\n      if (e.code == auth_error.notAvailable) {\n        print('Biometrics not available');\n      } else if (e.code == auth_error.notEnrolled) {\n        print('No biometrics enrolled');\n      } else if (e.code == auth_error.lockedOut) {\n        print('Too many failed attempts');\n      } else if (e.code == auth_error.permanentlyLockedOut) {\n        print('Permanently locked out');\n      }\n\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Authentication failed: ${e.message}')),\n      );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Biometric Authentication')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(\n              _isAuthenticated ? Icons.lock_open : Icons.lock,\n              size: 100,\n              color: _isAuthenticated ? Colors.green : Colors.red,\n            ),\n\n            SizedBox(height: 20),\n\n            Text(\n              _isAuthenticated ? 'Authenticated ‚úì' : 'Not Authenticated ‚úó',\n              style: TextStyle(\n                fontSize: 24,\n                fontWeight: FontWeight.bold,\n                color: _isAuthenticated ? Colors.green : Colors.red,\n              ),\n            ),\n\n            SizedBox(height: 40),\n\n            // Available biometrics\n            if (_availableBiometrics.isNotEmpty) ...[\n              Text('Available biometrics:', style: TextStyle(fontSize: 16)),\n              SizedBox(height: 10),\n              ..._availableBiometrics.map((biometric) => Chip(\n                    label: Text(biometric.toString().split('.').last),\n                  )),\n            ],\n\n            SizedBox(height: 40),\n\n            ElevatedButton.icon(\n              onPressed: _authenticate,\n              icon: Icon(Icons.fingerprint),\n              label: Text('Authenticate'),\n              style: ElevatedButton.styleFrom(\n                padding: EdgeInsets.symmetric(horizontal: 32, vertical: 16),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Motion Sensors",
              "content": "\n### Setup\n\n**pubspec.yaml:**\n\n**iOS Configuration (`ios/Runner/Info.plist`):**\n\n### Accelerometer (Detects Device Motion)\n\n\n### Gyroscope (Detects Rotation)\n\n\n",
              "code": "class GyroscopeScreen extends StatefulWidget {\n  @override\n  State<GyroscopeScreen> createState() => _GyroscopeScreenState();\n}\n\nclass _GyroscopeScreenState extends State<GyroscopeScreen> {\n  double _rotationX = 0.0, _rotationY = 0.0, _rotationZ = 0.0;\n  StreamSubscription? _gyroscopeSubscription;\n\n  @override\n  void initState() {\n    super.initState();\n\n    _gyroscopeSubscription = gyroscopeEventStream().listen((GyroscopeEvent event) {\n      setState(() {\n        _rotationX = event.x;  // Pitch (nose up/down)\n        _rotationY = event.y;  // Roll (wing up/down)\n        _rotationZ = event.z;  // Yaw (turn left/right)\n      });\n    });\n  }\n\n  @override\n  void dispose() {\n    _gyroscopeSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Gyroscope')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Rotation Rate (radians/second)', style: TextStyle(fontSize: 20)),\n            SizedBox(height: 40),\n\n            _buildRotationIndicator('Pitch (X)', _rotationX, Colors.red),\n            SizedBox(height: 20),\n            _buildRotationIndicator('Roll (Y)', _rotationY, Colors.green),\n            SizedBox(height: 20),\n            _buildRotationIndicator('Yaw (Z)', _rotationZ, Colors.blue),\n\n            SizedBox(height: 40),\n\n            Text(\n              'Tilt your phone to see rotation values',\n              style: TextStyle(color: Colors.grey),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildRotationIndicator(String label, double value, Color color) {\n    return Column(\n      children: [\n        Text(label, style: TextStyle(fontSize: 16)),\n        SizedBox(height: 8),\n        Container(\n          width: 300,\n          height: 40,\n          decoration: BoxDecoration(\n            border: Border.all(color: Colors.grey),\n            borderRadius: BorderRadius.circular(8),\n          ),\n          child: Stack(\n            children: [\n              // Center line\n              Center(\n                child: Container(\n                  width: 2,\n                  height: 40,\n                  color: Colors.grey,\n                ),\n              ),\n              // Indicator\n              Align(\n                alignment: Alignment(value.clamp(-1.0, 1.0), 0),\n                child: Container(\n                  width: 20,\n                  height: 40,\n                  color: color,\n                ),\n              ),\n            ],\n          ),\n        ),\n        SizedBox(height: 4),\n        Text('${value.toStringAsFixed(2)} rad/s'),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 3: Shake Detection",
              "content": "\n### Setup\n\n**pubspec.yaml:**\n\n### Shake to Undo Example\n\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:shake/shake.dart';\n\nclass ShakeToUndoScreen extends StatefulWidget {\n  @override\n  State<ShakeToUndoScreen> createState() => _ShakeToUndoScreenState();\n}\n\nclass _ShakeToUndoScreenState extends State<ShakeToUndoScreen> {\n  ShakeDetector? _shakeDetector;\n  List<String> _actions = [];\n  int _counter = 0;\n\n  @override\n  void initState() {\n    super.initState();\n\n    // Initialize shake detector\n    _shakeDetector = ShakeDetector.autoStart(\n      onPhoneShake: (ShakeEvent event) {\n        // Called when phone is shaken\n        _undoLastAction();\n\n        // Optional: Show shake details\n        print('Shake detected!');\n        print('Direction: ${event.direction}');  // X, Y, or Z axis\n        print('Force: ${event.force}');\n        print('Time: ${event.timestamp}');\n      },\n      minimumShakeCount: 1,\n      shakeSlopTimeMS: 500,\n      shakeCountResetTime: 3000,\n      shakeThresholdGravity: 2.7,\n    );\n  }\n\n  @override\n  void dispose() {\n    _shakeDetector?.stopListening();\n    super.dispose();\n  }\n\n  void _addAction() {\n    setState(() {\n      _counter++;\n      _actions.add('Action $_counter');\n    });\n  }\n\n  void _undoLastAction() {\n    if (_actions.isEmpty) return;\n\n    setState(() {\n      final lastAction = _actions.removeLast();\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(\n          content: Text('Undid: $lastAction'),\n          duration: Duration(seconds: 1),\n        ),\n      );\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Shake to Undo')),\n      body: Column(\n        children: [\n          Padding(\n            padding: EdgeInsets.all(16),\n            child: Text(\n              'Shake your phone to undo!',\n              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n            ),\n          ),\n\n          Expanded(\n            child: _actions.isEmpty\n                ? Center(child: Text('No actions yet'))\n                : ListView.builder(\n                    itemCount: _actions.length,\n                    itemBuilder: (context, index) {\n                      return ListTile(\n                        leading: CircleAvatar(child: Text('${index + 1}')),\n                        title: Text(_actions[index]),\n                        trailing: IconButton(\n                          icon: Icon(Icons.delete),\n                          onPressed: () {\n                            setState(() => _actions.removeAt(index));\n                          },\n                        ),\n                      );\n                    },\n                  ),\n          ),\n        ],\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _addAction,\n        child: Icon(Icons.add),\n        tooltip: 'Add Action',\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 4: Vibration & Haptic Feedback",
              "content": "\n### Setup\n\n**pubspec.yaml:**\n\n**Android Configuration (`android/app/src/main/AndroidManifest.xml`):**\n\n### Vibration Examples\n\n\n### Haptic Feedback (Alternative)\n\nFlutter has built-in haptic feedback:\n\n\n**Example in Button:**\n\n",
              "code": "ElevatedButton(\n  onPressed: () {\n    HapticFeedback.lightImpact();  // Provide feedback\n    // ... do action\n  },\n  child: Text('Tap Me'),\n)",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Always Check Availability**\n   ```dart\n   final hasVibrator = await Vibration.hasVibrator();\n   final canAuth = await _localAuth.canCheckBiometrics;\n   ```\n\n2. **Provide Fallback Options**\n   - If biometrics fail, offer PIN/password\n   - If sensors unavailable, provide manual input\n\n3. **Don't Overuse Haptics**\n   - Only for important actions (button taps, errors)\n   - Too much vibration annoys users\n\n4. **Cancel Streams**\n   ```dart\n   @override\n   void dispose() {\n     _sensorSubscription?.cancel();\n     super.dispose();\n   }\n   ```\n\n5. **Handle Permissions Gracefully**\n   - Explain why you need sensor access\n   - Provide option to skip if not critical\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the difference between `accelerometerEvents` and `userAccelerometerEvents`?\nA) They're the same\nB) User accelerometer filters out gravity\nC) Accelerometer is more accurate\nD) User accelerometer is iOS only\n\n**Question 2:** When should you use `HapticFeedback.heavyImpact()`?\nA) For every button tap\nB) For important actions like errors or deletions\nC) Only on Android\nD) Never, it's deprecated\n\n**Question 3:** What does `stickyAuth: true` do in biometric authentication?\nA) Makes authentication faster\nB) Keeps showing the dialog until user interacts\nC) Automatically retries on failure\nD) Uses only fingerprint, not face\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Motion-Controlled Game",
              "content": "\nBuild a simple game that:\n1. Has a ball that moves based on device tilt (accelerometer)\n2. Vibrates when ball hits walls\n3. Requires biometric authentication to start\n4. Shake to reset ball position\n\n**Bonus Challenges:**\n- Add obstacles that ball must avoid\n- Track high scores securely\n- Use gyroscope for rotation effects\n- Add haptic feedback for different events\n\n"
            },
            {
              "type": "THEORY",
              "title": "üîå Platform Channels: Talking to Native Code",
              "content": "\n### What Are Platform Channels?\n\nSometimes you need features that don't have a Flutter plugin. **Platform Channels** let your Dart code communicate directly with native Android (Kotlin/Java) and iOS (Swift/Objective-C) code.\n\n**Analogy:** Think of Platform Channels like a **translator at a UN meeting**. Dart speaks one language, Android/iOS speak another. The channel translates messages back and forth!\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ     FLUTTER     ‚îÇ                    ‚îÇ     NATIVE      ‚îÇ\n‚îÇ    (Dart)       ‚îÇ‚óÑ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ñ∫‚îÇ  (Kotlin/Swift) ‚îÇ\n‚îÇ                 ‚îÇ   MethodChannel    ‚îÇ                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚îÇ                                      ‚îÇ\n    invokeMethod()  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫   handle method\n         ‚îÇ          ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   return result\n    receive result                              ‚îÇ\n```\n\n### When Do You Need Platform Channels?\n\n1. **No plugin exists** for the feature you need\n2. **Proprietary SDKs** that only have native libraries\n3. **Hardware features** not exposed by Flutter\n4. **Performance-critical** code that must run natively\n5. **Existing native code** you want to reuse\n\n"
            },
            {
              "type": "THEORY",
              "title": "Complete Platform Channel Example: Get Battery Level",
              "content": "\n### Step 1: Flutter Side (Dart)\n\n**lib/services/battery_service.dart:**\n\n```dart\nimport 'package:flutter/services.dart';\n\nclass BatteryService {\n  // Create a channel with a unique name\n  static const platform = MethodChannel('com.myapp/battery');\n  \n  // Call native code to get battery level\n  static Future<int> getBatteryLevel() async {\n    try {\n      // invokeMethod sends a message to native code\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return result;\n    } on PlatformException catch (e) {\n      print('Failed to get battery level: ${e.message}');\n      return -1;\n    }\n  }\n  \n  // Call native code with arguments\n  static Future<bool> setBatteryAlarm(int threshold) async {\n    try {\n      final result = await platform.invokeMethod(\n        'setBatteryAlarm',\n        {'threshold': threshold},  // Pass data to native\n      );\n      return result as bool;\n    } on PlatformException {\n      return false;\n    }\n  }\n}\n```\n\n### Step 2: Android Side (Kotlin)\n\n**android/app/src/main/kotlin/.../MainActivity.kt:**\n\n```kotlin\npackage com.example.myapp\n\nimport android.content.Context\nimport android.content.ContextWrapper\nimport android.content.Intent\nimport android.content.IntentFilter\nimport android.os.BatteryManager\nimport android.os.Build\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\n\nclass MainActivity : FlutterActivity() {\n    private val CHANNEL = \"com.myapp/battery\"  // Must match Dart!\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        super.configureFlutterEngine(flutterEngine)\n\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL)\n            .setMethodCallHandler { call, result ->\n                when (call.method) {\n                    \"getBatteryLevel\" -> {\n                        val batteryLevel = getBatteryLevel()\n                        if (batteryLevel != -1) {\n                            result.success(batteryLevel)\n                        } else {\n                            result.error(\"UNAVAILABLE\", \"Battery level not available\", null)\n                        }\n                    }\n                    \"setBatteryAlarm\" -> {\n                        val threshold = call.argument<Int>(\"threshold\") ?: 20\n                        // Implement your alarm logic here\n                        result.success(true)\n                    }\n                    else -> result.notImplemented()\n                }\n            }\n    }\n\n    private fun getBatteryLevel(): Int {\n        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            val batteryManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager\n            batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\n        } else {\n            val intent = ContextWrapper(applicationContext)\n                .registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED))\n            (intent?.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) ?: -1) * 100 /\n                (intent?.getIntExtra(BatteryManager.EXTRA_SCALE, -1) ?: 1)\n        }\n    }\n}\n```\n\n### Step 3: iOS Side (Swift)\n\n**ios/Runner/AppDelegate.swift:**\n\n```swift\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n    override func application(\n        _ application: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n    ) -> Bool {\n        let controller = window?.rootViewController as! FlutterViewController\n        \n        let batteryChannel = FlutterMethodChannel(\n            name: \"com.myapp/battery\",  // Must match Dart!\n            binaryMessenger: controller.binaryMessenger\n        )\n        \n        batteryChannel.setMethodCallHandler { [weak self] (call, result) in\n            switch call.method {\n            case \"getBatteryLevel\":\n                self?.receiveBatteryLevel(result: result)\n            case \"setBatteryAlarm\":\n                if let args = call.arguments as? [String: Any],\n                   let threshold = args[\"threshold\"] as? Int {\n                    // Implement alarm logic\n                    result(true)\n                } else {\n                    result(FlutterError(code: \"INVALID_ARGS\", message: nil, details: nil))\n                }\n            default:\n                result(FlutterMethodNotImplemented)\n            }\n        }\n        \n        GeneratedPluginRegistrant.register(with: self)\n        return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n    }\n    \n    private func receiveBatteryLevel(result: FlutterResult) {\n        UIDevice.current.isBatteryMonitoringEnabled = true\n        let batteryLevel = Int(UIDevice.current.batteryLevel * 100)\n        \n        if batteryLevel == -100 {\n            result(FlutterError(\n                code: \"UNAVAILABLE\",\n                message: \"Battery info unavailable\",\n                details: nil\n            ))\n        } else {\n            result(batteryLevel)\n        }\n    }\n}\n```\n\n### Step 4: Use It in Flutter\n\n```dart\nclass BatteryScreen extends StatefulWidget {\n  @override\n  State<BatteryScreen> createState() => _BatteryScreenState();\n}\n\nclass _BatteryScreenState extends State<BatteryScreen> {\n  int _batteryLevel = -1;\n  \n  @override\n  void initState() {\n    super.initState();\n    _loadBatteryLevel();\n  }\n  \n  Future<void> _loadBatteryLevel() async {\n    final level = await BatteryService.getBatteryLevel();\n    setState(() => _batteryLevel = level);\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Battery Level')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(\n              _batteryLevel > 50 ? Icons.battery_full : Icons.battery_alert,\n              size: 100,\n              color: _batteryLevel > 20 ? Colors.green : Colors.red,\n            ),\n            SizedBox(height: 20),\n            Text(\n              '$_batteryLevel%',\n              style: TextStyle(fontSize: 48, fontWeight: FontWeight.bold),\n            ),\n            SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: _loadBatteryLevel,\n              child: Text('Refresh'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Platform Channel Types",
              "content": "\n| Channel Type | Description | Use Case |\n|--------------|-------------|----------|\n| **MethodChannel** | Two-way async method calls | Most common - API calls, getting data |\n| **EventChannel** | One-way stream from native | Continuous data (sensors, location) |\n| **BasicMessageChannel** | Raw message passing | Custom encoding, simple messages |\n\n### EventChannel Example (Continuous Data)\n\n```dart\n// Dart side - receive continuous updates\nclass SensorStream {\n  static const eventChannel = EventChannel('com.myapp/sensor');\n  \n  static Stream<double> get sensorStream {\n    return eventChannel.receiveBroadcastStream().map((value) => value as double);\n  }\n}\n\n// Usage\nSensorStream.sensorStream.listen((value) {\n  print('Sensor value: $value');\n});\n```\n\n### Best Practices\n\n1. **Use unique channel names** - reverse domain format (`com.myapp/feature`)\n2. **Handle errors gracefully** - wrap in try-catch, provide fallbacks\n3. **Check platform first** - use `Platform.isAndroid` / `Platform.isIOS`\n4. **Test on both platforms** - native code differs between Android/iOS\n5. **Prefer plugins** - only use channels when no plugin exists\n\n**Pro Tip:** Before writing platform channels, check [pub.dev](https://pub.dev) - there's probably already a plugin for what you need!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered device features in Flutter! Here's what we covered:\n\n- **Biometric Authentication**: Secure login with fingerprint/Face ID\n- **Accelerometer**: Detect device motion and tilt\n- **Gyroscope**: Measure rotation and orientation\n- **Shake Detection**: Respond to device shaking\n- **Vibration & Haptics**: Provide tactile feedback\n- **Platform Channels**: Communicate with native Android/iOS code\n- **Complete App**: Secure notes with biometric lock\n\nWith these skills, you can build apps that feel native, secure, and interactive!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) User accelerometer filters out gravity\n\n`accelerometerEvents` includes gravity (so when device is still, z-axis shows ~9.8 m/s¬≤). `userAccelerometerEvents` filters out gravity, showing only user-caused motion. Use user accelerometer for gesture detection, regular accelerometer for orientation.\n\n**Answer 2:** B) For important actions like errors or deletions\n\nHeavy impact should be reserved for significant moments like errors, destructive actions (delete), or important confirmations. Overusing strong haptics reduces their effectiveness and annoys users. Light impact is for normal taps.\n\n**Answer 3:** B) Keeps showing the dialog until user interacts\n\n`stickyAuth: true` prevents the authentication dialog from dismissing automatically. It stays visible until the user successfully authenticates or explicitly cancels. This prevents accidental dismissals on Android.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "9.7",
          "title": "Lesson 7: Background Tasks & Workmanager",
          "moduleId": "module-09",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Understanding background execution in mobile apps\n- Using Workmanager for scheduled background tasks\n- One-time vs periodic background work\n- Handling constraints (network, battery, charging)\n- Data sync and background uploads\n- Best practices for battery efficiency\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: What Are Background Tasks?",
              "content": "\n### Real-World Analogy\nThink of background tasks like a **scheduled cleaning service** for your house:\n- **One-Time Task** = \"Clean before the party tonight\"\n- **Periodic Task** = \"Clean every Tuesday at 3 PM\"\n- **Constraints** = \"Only clean when I'm not home and it's daylight\"\n\nJust like a cleaning service works when you're away, background tasks run when your app is closed or minimized!\n\n### Why This Matters\nBackground tasks enable critical features:\n\n1. **Data Sync**: Upload photos, sync notes (Google Photos, Evernote)\n2. **Content Updates**: Fetch news, update widgets (News apps)\n3. **Maintenance**: Clean cache, compress files\n4. **Analytics**: Send usage data periodically\n5. **Notifications**: Check for new messages (Email apps)\n\nAccording to Google, proper background task management can reduce battery drain by 40% compared to naive implementations!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Background Execution: The Challenges",
              "content": "\n### Platform Restrictions\n\nModern mobile OSes heavily restrict background work to save battery:\n\n**iOS:**\n- ‚ùå No continuous background execution (with exceptions)\n- ‚úÖ BGTaskScheduler for periodic tasks\n- ‚è∞ Tasks run at OS discretion (not guaranteed timing)\n- üîã Tasks killed if battery is low\n\n**Android:**\n- ‚úÖ WorkManager for reliable scheduled work\n- ‚è∞ Minimum 15-minute intervals for periodic work\n- üîã Doze mode limits background tasks\n- ‚úÖ More flexibility than iOS\n\n**Key Takeaway:** Background tasks are **not real-time**. Use them for deferrable work, not time-critical operations!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Workmanager",
              "content": "\n### Installation\n\n**pubspec.yaml:**\n\n\n### Android Configuration\n\n**android/app/src/main/AndroidManifest.xml:**\n\n### iOS Configuration\n\n**ios/Runner/Info.plist:**\n\n**ios/Runner/AppDelegate.swift:**\n\n",
              "code": "import UIKit\nimport Flutter\nimport workmanager\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n  override func application(\n    _ application: UIApplication,\n    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n  ) -> Bool {\n    GeneratedPluginRegistrant.register(with: self)\n\n    WorkmanagerPlugin.setPluginRegistrantCallback { registry in\n        GeneratedPluginRegistrant.register(with: registry)\n    }\n\n    return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n  }\n}",
              "language": "swift"
            },
            {
              "type": "THEORY",
              "title": "Basic Workmanager Usage",
              "content": "\n### Step 1: Initialize Workmanager\n\n\n### Step 2: Register One-Time Tasks\n\n\n### Step 3: Register Periodic Tasks\n\n\n**Important:** Android minimum periodic interval is **15 minutes**. iOS is even less predictable!\n\n",
              "code": "Future<void> _registerPeriodicTask() async {\n  await Workmanager().registerPeriodicTask(\n    'periodic-sync',  // Unique ID\n    'syncData',       // Task name\n    frequency: Duration(hours: 1),  // Run every hour (minimum 15 minutes)\n    constraints: Constraints(\n      networkType: NetworkType.connected,     // Require internet\n      requiresBatteryNotLow: true,            // Don't run if battery low\n      requiresCharging: false,                // Run even when not charging\n      requiresDeviceIdle: false,              // Run even when device in use\n      requiresStorageNotLow: true,            // Don't run if storage low\n    ),\n    inputData: {\n      'periodic': true,\n    },\n    existingWorkPolicy: ExistingWorkPolicy.replace,  // Replace existing task\n  );\n\n  print('Periodic task registered!');\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Advanced Features",
              "content": "\n### 1. Task Constraints\n\n\n### 2. Initial Delay\n\n\n### 3. Backoff Policy\n\n\n**Backoff Example:**\n- First retry: after 30 seconds\n- Second retry: after 60 seconds (exponential)\n- Third retry: after 120 seconds\n\n### 4. Replacing vs Keeping Existing Tasks\n\n\n- **replace**: Cancel old task, register new one\n- **keep**: Keep old task, ignore new registration\n- **append**: Run both (rarely used)\n\n",
              "code": "await Workmanager().registerPeriodicTask(\n  'my-task',\n  'syncData',\n  existingWorkPolicy: ExistingWorkPolicy.replace,  // or .keep, .append\n);",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Keep Background Work Short**\n   - ‚ùå Don't run tasks for > 10 minutes\n   - ‚úÖ Break large work into smaller chunks\n\n2. **Handle Task Failures Gracefully**\n   ```dart\n   try {\n     await _performBackgroundWork();\n     return Future.value(true);  // Success\n   } catch (e) {\n     print('Task failed: $e');\n     return Future.value(false);  // Will retry with backoff\n   }\n   ```\n\n3. **Use Constraints to Save Battery**\n   ```dart\n   // Good: Only sync when on WiFi and charging\n   Constraints(\n     networkType: NetworkType.unmetered,\n     requiresCharging: true,\n   )\n   ```\n\n4. **Don't Rely on Exact Timing**\n   - OS decides when to run tasks\n   - iOS is especially unpredictable\n   - Use for deferrable work only\n\n5. **Test on Real Devices**\n   - Emulators don't accurately simulate background restrictions\n   - Test with low battery, airplane mode, etc.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Common Issues & Solutions",
              "content": "\n**Issue 1: Tasks not running on iOS**\n- **Solution**: iOS is very restrictive. Tasks may not run for hours.\n- BGTaskScheduler runs at system discretion\n- Test with `e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@\"your.identifier\"]` in Xcode debugger\n\n**Issue 2: Tasks running too frequently**\n- **Solution**: Set minimum `frequency: Duration(hours: 1)`\n- Android minimum is 15 minutes, but OS may run less frequently\n\n**Issue 3: Task crashes**\n- **Solution**: Ensure callback is top-level function with `@pragma('vm:entry-point')`\n- Don't access app state directly (use SharedPreferences, SQLite)\n\n**Issue 4: Tasks not running after app force-quit (iOS)**\n- **Solution**: This is expected iOS behavior\n- iOS doesn't guarantee background execution after force-quit\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the minimum interval for periodic tasks on Android?\nA) 1 minute\nB) 5 minutes\nC) 15 minutes\nD) 1 hour\n\n**Question 2:** When should you use `NetworkType.unmetered` constraint?\nA) For all network tasks\nB) For large uploads/downloads to save cellular data\nC) Only on WiFi 6\nD) Never, it's deprecated\n\n**Question 3:** What does returning `false` from a background task do?\nA) Cancels the task permanently\nB) Causes the task to retry with backoff policy\nC) Logs an error\nD) Nothing\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: News App Background Sync",
              "content": "\nBuild a news app that:\n1. Fetches latest news every 2 hours in background\n2. Only syncs on WiFi and when battery not low\n3. Shows badge count for unread articles\n4. Has manual \"Refresh Now\" button\n5. Stores articles in SQLite\n\n**Bonus Challenges:**\n- Send notification when new articles available\n- Clean old articles (older than 7 days) weekly\n- Allow user to configure sync frequency\n- Handle offline mode gracefully\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered background tasks in Flutter! Here's what we covered:\n\n- **Workmanager Setup**: Initialize and configure for Android/iOS\n- **One-Time Tasks**: Run background work once\n- **Periodic Tasks**: Schedule recurring work with constraints\n- **Task Management**: Register, cancel, and handle tasks\n- **Best Practices**: Battery efficiency and platform limitations\n- **Complete App**: Photo backup with auto-sync\n\nWith background tasks, your apps can sync data, perform maintenance, and stay up-to-date even when closed!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** C) 15 minutes\n\nAndroid's WorkManager has a minimum periodic interval of **15 minutes**. You can request more frequent intervals, but the OS will enforce this minimum. This is to preserve battery life and prevent abuse.\n\n**Answer 2:** B) For large uploads/downloads to save cellular data\n\n`NetworkType.unmetered` means WiFi or unlimited data connections (not cellular metered data). Use this for large file operations to avoid expensive cellular data charges for users. For small API calls, `NetworkType.connected` (any connection) is fine.\n\n**Answer 3:** B) Causes the task to retry with backoff policy\n\nReturning `false` signals failure, and WorkManager will automatically retry the task according to the configured `backoffPolicy` (exponential or linear delay). Returning `true` means success - task won't retry.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "9.8",
          "title": "Lesson 8: Mini-Project - Fitness Tracker App",
          "moduleId": "module-09",
          "order": 8,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\nBuild a comprehensive **Fitness Tracker App** that combines all advanced features from Module 9:\n\n- üé® **Animations**: Smooth transitions and progress indicators\n- üì∏ **Camera**: Profile photos and workout photos\n- üíæ **Local Storage**: Hive for settings, SQLite for workout history\n- üó∫Ô∏è **Maps & Location**: Track running routes with GPS\n- üì± **Device Features**: Biometric lock, step counter with accelerometer\n- ‚è∞ **Background Tasks**: Daily reminder notifications\n- üìä **Data Visualization**: Charts showing progress over time\n\nThis is a production-ready app that showcases everything you've learned!\n\n"
            },
            {
              "type": "THEORY",
              "title": "What You'll Build",
              "content": "\n### Core Features\n\n1. **User Profile**\n   - Profile photo with camera/gallery\n   - Biometric authentication to protect data\n   - Personal stats (height, weight, age)\n\n2. **Workout Tracking**\n   - Log workouts (running, cycling, gym)\n   - GPS tracking for outdoor activities\n   - Real-time map showing route\n   - Duration, distance, calories burned\n\n3. **Step Counter**\n   - Use accelerometer to count steps\n   - Daily step goal with progress bar\n   - Animated step counter\n\n4. **Workout History**\n   - SQLite database for all workouts\n   - Filter by type, date range\n   - Statistics and charts\n\n5. **Background Reminders**\n   - Daily workout reminder notifications\n   - Sync workout data periodically\n\n"
            },
            {
              "type": "THEORY",
              "title": "Step 1: Dependencies",
              "content": "\n**pubspec.yaml:**\n\nRun:\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Step 2: Models",
              "content": "\n### User Profile Model\n\n**lib/models/user_profile.dart:**\n\n### Workout Model\n\n**lib/models/workout.dart:**\n\n",
              "code": "class Workout {\n  final int? id;\n  final String type;  // 'running', 'cycling', 'gym', 'walking'\n  final DateTime startTime;\n  final DateTime endTime;\n  final double? distance;  // in km (null for gym workouts)\n  final int calories;\n  final String? notes;\n  final String? routeJson;  // JSON string of LatLng points\n\n  Workout({\n    this.id,\n    required this.type,\n    required this.startTime,\n    required this.endTime,\n    this.distance,\n    required this.calories,\n    this.notes,\n    this.routeJson,\n  });\n\n  Duration get duration => endTime.difference(startTime);\n\n  double? get avgSpeed {\n    if (distance == null || distance == 0) return null;\n    final hours = duration.inMinutes / 60;\n    return distance! / hours;  // km/h\n  }\n\n  Map<String, dynamic> toMap() {\n    return {\n      'id': id,\n      'type': type,\n      'start_time': startTime.millisecondsSinceEpoch,\n      'end_time': endTime.millisecondsSinceEpoch,\n      'distance': distance,\n      'calories': calories,\n      'notes': notes,\n      'route_json': routeJson,\n    };\n  }\n\n  factory Workout.fromMap(Map<String, dynamic> map) {\n    return Workout(\n      id: map['id'],\n      type: map['type'],\n      startTime: DateTime.fromMillisecondsSinceEpoch(map['start_time']),\n      endTime: DateTime.fromMillisecondsSinceEpoch(map['end_time']),\n      distance: map['distance'],\n      calories: map['calories'],\n      notes: map['notes'],\n      routeJson: map['route_json'],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 3: Database Service (SQLite)",
              "content": "\n**lib/services/database_service.dart:**\n\n",
              "code": "import 'package:sqflite/sqflite.dart';\nimport 'package:path/path.dart';\nimport '../models/workout.dart';\n\nclass DatabaseService {\n  static final DatabaseService instance = DatabaseService._internal();\n  factory DatabaseService() => instance;\n  DatabaseService._internal();\n\n  static Database? _database;\n\n  Future<Database> get database async {\n    if (_database != null) return _database!;\n    _database = await _initDatabase();\n    return _database!;\n  }\n\n  Future<Database> _initDatabase() async {\n    final dbPath = await getDatabasesPath();\n    final path = join(dbPath, 'fitness_tracker.db');\n\n    return await openDatabase(\n      path,\n      version: 1,\n      onCreate: _onCreate,\n    );\n  }\n\n  Future<void> _onCreate(Database db, int version) async {\n    await db.execute('''\n      CREATE TABLE workouts (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        type TEXT NOT NULL,\n        start_time INTEGER NOT NULL,\n        end_time INTEGER NOT NULL,\n        distance REAL,\n        calories INTEGER NOT NULL,\n        notes TEXT,\n        route_json TEXT\n      )\n    ''');\n\n    await db.execute('''\n      CREATE TABLE daily_steps (\n        date TEXT PRIMARY KEY,\n        steps INTEGER NOT NULL\n      )\n    ''');\n  }\n\n  // Workout methods\n  Future<int> insertWorkout(Workout workout) async {\n    final db = await database;\n    return await db.insert('workouts', workout.toMap());\n  }\n\n  Future<List<Workout>> getAllWorkouts() async {\n    final db = await database;\n    final maps = await db.query('workouts', orderBy: 'start_time DESC');\n    return maps.map((map) => Workout.fromMap(map)).toList();\n  }\n\n  Future<List<Workout>> getWorkoutsByType(String type) async {\n    final db = await database;\n    final maps = await db.query(\n      'workouts',\n      where: 'type = ?',\n      whereArgs: [type],\n      orderBy: 'start_time DESC',\n    );\n    return maps.map((map) => Workout.fromMap(map)).toList();\n  }\n\n  Future<List<Workout>> getWorkoutsInDateRange(DateTime start, DateTime end) async {\n    final db = await database;\n    final maps = await db.query(\n      'workouts',\n      where: 'start_time >= ? AND start_time <= ?',\n      whereArgs: [start.millisecondsSinceEpoch, end.millisecondsSinceEpoch],\n      orderBy: 'start_time DESC',\n    );\n    return maps.map((map) => Workout.fromMap(map)).toList();\n  }\n\n  Future<int> deleteWorkout(int id) async {\n    final db = await database;\n    return await db.delete('workouts', where: 'id = ?', whereArgs: [id]);\n  }\n\n  // Step counter methods\n  Future<void> saveDailySteps(String date, int steps) async {\n    final db = await database;\n    await db.insert(\n      'daily_steps',\n      {'date': date, 'steps': steps},\n      conflictAlgorithm: ConflictAlgorithm.replace,\n    );\n  }\n\n  Future<int?> getStepsForDate(String date) async {\n    final db = await database;\n    final results = await db.query(\n      'daily_steps',\n      where: 'date = ?',\n      whereArgs: [date],\n    );\n\n    return results.isNotEmpty ? results.first['steps'] as int : null;\n  }\n\n  Future<Map<String, int>> getStepsForWeek() async {\n    final db = await database;\n    final now = DateTime.now();\n    final weekAgo = now.subtract(Duration(days: 7));\n\n    final results = await db.query(\n      'daily_steps',\n      where: 'date >= ?',\n      whereArgs: [weekAgo.toIso8601String().split('T')[0]],\n      orderBy: 'date ASC',\n    );\n\n    return {\n      for (var row in results) row['date'] as String: row['steps'] as int\n    };\n  }\n\n  // Statistics\n  Future<Map<String, dynamic>> getWorkoutStats() async {\n    final db = await database;\n\n    final totalWorkouts = Sqflite.firstIntValue(\n      await db.rawQuery('SELECT COUNT(*) FROM workouts'),\n    ) ?? 0;\n\n    final totalDistance = (await db.rawQuery(\n      'SELECT SUM(distance) as total FROM workouts WHERE distance IS NOT NULL',\n    ))[0]['total'] ?? 0.0;\n\n    final totalCalories = Sqflite.firstIntValue(\n      await db.rawQuery('SELECT SUM(calories) FROM workouts'),\n    ) ?? 0;\n\n    final workoutsByType = await db.rawQuery('''\n      SELECT type, COUNT(*) as count\n      FROM workouts\n      GROUP BY type\n      ORDER BY count DESC\n    ''');\n\n    return {\n      'totalWorkouts': totalWorkouts,\n      'totalDistance': totalDistance,\n      'totalCalories': totalCalories,\n      'workoutsByType': workoutsByType,\n    };\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 4: Main App Setup",
              "content": "\n**lib/main.dart:**\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:hive_flutter/hive_flutter.dart';\nimport 'package:workmanager/workmanager.dart';\nimport 'models/user_profile.dart';\nimport 'screens/home_screen.dart';\nimport 'screens/profile_screen.dart';\nimport 'services/database_service.dart';\n\n// Background task callback\n@pragma('vm:entry-point')\nvoid callbackDispatcher() {\n  Workmanager().executeTask((task, inputData) async {\n    switch (task) {\n      case 'dailyReminder':\n        // In real app: trigger local notification\n        print('‚è∞ Daily workout reminder!');\n        break;\n      case 'syncData':\n        // In real app: sync to cloud\n        print('‚òÅÔ∏è Syncing workout data...');\n        break;\n    }\n\n    return Future.value(true);\n  });\n}\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  // Initialize Hive\n  await Hive.initFlutter();\n  Hive.registerAdapter(UserProfileAdapter());\n  await Hive.openBox<UserProfile>('profile');\n  await Hive.openBox('settings');\n\n  // Initialize SQLite\n  await DatabaseService().database;\n\n  // Initialize Workmanager\n  await Workmanager().initialize(callbackDispatcher, isInDebugMode: true);\n\n  // Register daily reminder (8 AM every day)\n  await Workmanager().registerPeriodicTask(\n    'daily-reminder',\n    'dailyReminder',\n    frequency: Duration(hours: 24),\n    initialDelay: _calculateDelayUntil8AM(),\n  );\n\n  runApp(FitnessTrackerApp());\n}\n\nDuration _calculateDelayUntil8AM() {\n  final now = DateTime.now();\n  var next8AM = DateTime(now.year, now.month, now.day, 8, 0);\n\n  if (now.isAfter(next8AM)) {\n    next8AM = next8AM.add(Duration(days: 1));\n  }\n\n  return next8AM.difference(now);\n}\n\nclass FitnessTrackerApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Fitness Tracker',\n      debugShowCheckedModeBanner: false,\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),\n        useMaterial3: true,\n      ),\n      darkTheme: ThemeData.dark(useMaterial3: true),\n      home: HomeScreen(),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Step 5: Home Screen with Step Counter",
              "content": "\n**lib/screens/home_screen.dart:**\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:sensors_plus/sensors_plus.dart';\nimport 'package:intl/intl.dart';\nimport 'dart:async';\nimport '../services/database_service.dart';\n\nclass HomeScreen extends StatefulWidget {\n  @override\n  State<HomeScreen> createState() => _HomeScreenState();\n}\n\nclass _HomeScreenState extends State<HomeScreen> with TickerProviderStateMixin {\n  int _todaySteps = 0;\n  int _stepGoal = 10000;\n  StreamSubscription? _accelerometerSubscription;\n  List<double> _recentAcceleration = [];\n\n  late AnimationController _progressController;\n  late Animation<double> _progressAnimation;\n\n  @override\n  void initState() {\n    super.initState();\n\n    _progressController = AnimationController(\n      vsync: this,\n      duration: Duration(milliseconds: 1000),\n    );\n\n    _progressAnimation = Tween<double>(begin: 0, end: 0).animate(\n      CurvedAnimation(parent: _progressController, curve: Curves.easeInOut),\n    );\n\n    _loadTodaySteps();\n    _startStepCounter();\n  }\n\n  @override\n  void dispose() {\n    _accelerometerSubscription?.cancel();\n    _progressController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _loadTodaySteps() async {\n    final today = DateFormat('yyyy-MM-dd').format(DateTime.now());\n    final steps = await DatabaseService().getStepsForDate(today);\n\n    setState(() {\n      _todaySteps = steps ?? 0;\n      _updateProgress();\n    });\n  }\n\n  void _updateProgress() {\n    final progress = (_todaySteps / _stepGoal).clamp(0.0, 1.0);\n\n    _progressAnimation = Tween<double>(\n      begin: _progressAnimation.value,\n      end: progress,\n    ).animate(\n      CurvedAnimation(parent: _progressController, curve: Curves.easeInOut),\n    );\n\n    _progressController.reset();\n    _progressController.forward();\n  }\n\n  void _startStepCounter() {\n    _accelerometerSubscription = accelerometerEventStream().listen((event) {\n      final magnitude = (event.x * event.x + event.y * event.y + event.z * event.z);\n\n      _recentAcceleration.add(magnitude);\n      if (_recentAcceleration.length > 10) {\n        _recentAcceleration.removeAt(0);\n      }\n\n      // Simple step detection: detect peaks in acceleration\n      if (_recentAcceleration.length == 10) {\n        final avg = _recentAcceleration.reduce((a, b) => a + b) / _recentAcceleration.length;\n\n        if (magnitude > avg * 1.5 && magnitude > 150) {\n          setState(() {\n            _todaySteps++;\n            _updateProgress();\n          });\n\n          _saveTodaySteps();\n        }\n      }\n    });\n  }\n\n  Future<void> _saveTodaySteps() async {\n    final today = DateFormat('yyyy-MM-dd').format(DateTime.now());\n    await DatabaseService().saveDailySteps(today, _todaySteps);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Fitness Tracker'),\n        actions: [\n          IconButton(\n            icon: Icon(Icons.person),\n            onPressed: () {\n              Navigator.push(\n                context,\n                MaterialPageRoute(builder: (_) => ProfileScreen()),\n              );\n            },\n          ),\n        ],\n      ),\n      body: SingleChildScrollView(\n        padding: EdgeInsets.all(16),\n        child: Column(\n          children: [\n            // Animated Step Counter\n            AnimatedBuilder(\n              animation: _progressAnimation,\n              builder: (context, child) {\n                return CustomPaint(\n                  size: Size(200, 200),\n                  painter: CircularProgressPainter(\n                    progress: _progressAnimation.value,\n                    color: Theme.of(context).primaryColor,\n                  ),\n                  child: Container(\n                    width: 200,\n                    height: 200,\n                    child: Center(\n                      child: Column(\n                        mainAxisAlignment: MainAxisAlignment.center,\n                        children: [\n                          Text(\n                            '$_todaySteps',\n                            style: TextStyle(\n                              fontSize: 48,\n                              fontWeight: FontWeight.bold,\n                            ),\n                          ),\n                          Text(\n                            'steps',\n                            style: TextStyle(\n                              fontSize: 18,\n                              color: Colors.grey,\n                            ),\n                          ),\n                          SizedBox(height: 8),\n                          Text(\n                            'Goal: $_stepGoal',\n                            style: TextStyle(fontSize: 14, color: Colors.grey),\n                          ),\n                        ],\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n\n            SizedBox(height: 40),\n\n            // Quick Actions\n            _buildQuickActionButton(\n              icon: Icons.directions_run,\n              label: 'Start Running',\n              color: Colors.blue,\n              onTap: () {\n                // Navigate to workout tracker\n                ScaffoldMessenger.of(context).showSnackBar(\n                  SnackBar(content: Text('Starting workout tracker...')),\n                );\n              },\n            ),\n\n            SizedBox(height: 12),\n\n            _buildQuickActionButton(\n              icon: Icons.history,\n              label: 'Workout History',\n              color: Colors.green,\n              onTap: () {\n                // Navigate to history\n              },\n            ),\n\n            SizedBox(height: 12),\n\n            _buildQuickActionButton(\n              icon: Icons.bar_chart,\n              label: 'Statistics',\n              color: Colors.orange,\n              onTap: () {\n                // Navigate to stats\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildQuickActionButton({\n    required IconData icon,\n    required String label,\n    required Color color,\n    required VoidCallback onTap,\n  }) {\n    return Card(\n      child: InkWell(\n        onTap: onTap,\n        borderRadius: BorderRadius.circular(12),\n        child: Padding(\n          padding: EdgeInsets.all(16),\n          child: Row(\n            children: [\n              Container(\n                padding: EdgeInsets.all(12),\n                decoration: BoxDecoration(\n                  color: color.withOpacity(0.1),\n                  borderRadius: BorderRadius.circular(12),\n                ),\n                child: Icon(icon, color: color, size: 32),\n              ),\n              SizedBox(width: 16),\n              Text(\n                label,\n                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n              ),\n              Spacer(),\n              Icon(Icons.arrow_forward_ios, size: 16, color: Colors.grey),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// Custom painter for circular progress\nclass CircularProgressPainter extends CustomPainter {\n  final double progress;\n  final Color color;\n\n  CircularProgressPainter({required this.progress, required this.color});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final center = Offset(size.width / 2, size.height / 2);\n    final radius = size.width / 2;\n\n    // Background circle\n    final bgPaint = Paint()\n      ..color = color.withOpacity(0.1)\n      ..strokeWidth = 20\n      ..style = PaintingStyle.stroke;\n\n    canvas.drawCircle(center, radius - 10, bgPaint);\n\n    // Progress arc\n    final progressPaint = Paint()\n      ..color = color\n      ..strokeWidth = 20\n      ..style = PaintingStyle.stroke\n      ..strokeCap = StrokeCap.round;\n\n    canvas.drawArc(\n      Rect.fromCircle(center: center, radius: radius - 10),\n      -90 * (3.14159 / 180),  // Start at top\n      progress * 360 * (3.14159 / 180),  // Sweep angle\n      false,\n      progressPaint,\n    );\n  }\n\n  @override\n  bool shouldRepaint(CircularProgressPainter oldDelegate) {\n    return oldDelegate.progress != progress;\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Key Features Implementation Summary",
              "content": "\n### ‚úÖ Animations\n- Circular progress ring with smooth animation\n- Hero transitions between screens (implement in navigation)\n\n### ‚úÖ Camera & Gallery\n- Profile photo picker (implement in ProfileScreen)\n- Workout photo attachments\n\n### ‚úÖ Local Storage\n- **Hive**: User profile and settings\n- **SQLite**: Workout history and step data\n\n### ‚úÖ Maps & Location\n- GPS route tracking during workouts\n- Display route on Google Maps\n\n### ‚úÖ Device Features\n- **Accelerometer**: Step counting algorithm\n- **Biometric Auth**: Lock profile screen\n\n### ‚úÖ Background Tasks\n- Daily workout reminders at 8 AM\n- Periodic data sync\n\n"
            },
            {
              "type": "THEORY",
              "title": "Complete Implementation Checklist",
              "content": "\nBuild the remaining screens:\n\n1. ‚úÖ **Home Screen** (completed above)\n2. **Profile Screen**\n   - Edit profile info\n   - Change profile photo with camera/gallery\n   - Enable biometric lock\n   - BMI calculator\n\n3. **Workout Tracker Screen**\n   - Start/stop workout timer\n   - Track GPS route in real-time\n   - Calculate distance and calories\n   - Save workout to database\n\n4. **Workout History Screen**\n   - List all workouts from SQLite\n   - Filter by type and date\n   - Delete workouts\n   - View workout details with map\n\n5. **Statistics Screen**\n   - Charts showing progress over time\n   - Total distance, calories, workouts\n   - Weekly step counts\n\n"
            },
            {
              "type": "THEORY",
              "title": "Testing Your App",
              "content": "\n### Test Checklist\n\n- [ ] Profile photo picker works (camera & gallery)\n- [ ] Biometric lock activates correctly\n- [ ] Step counter increments when walking\n- [ ] SQLite stores workouts persistently\n- [ ] GPS tracking shows route on map\n- [ ] Background task runs at scheduled time\n- [ ] App survives app restart (data persists)\n- [ ] Animations are smooth (60 FPS)\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nCongratulations! You've built a comprehensive **Fitness Tracker App** that demonstrates:\n\n- üé® **Advanced animations** for engaging UX\n- üì∏ **Camera integration** for profile photos\n- üíæ **Dual storage** with Hive and SQLite\n- üó∫Ô∏è **GPS tracking** with real-time maps\n- üì± **Device sensors** for step counting\n- üîí **Biometric security** for privacy\n- ‚è∞ **Background tasks** for reminders\n\nThis capstone project showcases production-ready Flutter development skills!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Module 9 Complete! üéâ",
              "content": "\nYou've mastered **Advanced Flutter Features**:\n\n1. ‚úÖ Animations (implicit & explicit)\n2. ‚úÖ Camera & Gallery access\n3. ‚úÖ Local storage (Hive & SharedPreferences)\n4. ‚úÖ SQLite database\n5. ‚úÖ Maps & Location services\n6. ‚úÖ Device sensors & biometrics\n7. ‚úÖ Background tasks\n8. ‚úÖ Complete mini-project\n\n**Next Steps:**\n- Deploy your app to Google Play / App Store\n- Add Firebase for cloud sync\n- Implement social features (share workouts)\n- Add widget support for home screen\n\nYou're now ready to build professional, feature-rich Flutter applications! üöÄ\n\n"
            }
          ],
          "challenges": []
        }
      ]
    },
    {
      "id": "module-10",
      "title": "Module 10: Flutter Development",
      "description": "Learn Flutter development - Module 10",
      "difficulty": "advanced",
      "estimatedHours": 9,
      "lessons": [
        {
          "id": "10.1",
          "title": "Module 10: Testing - Complete Lesson Structure",
          "moduleId": "module-10",
          "order": 1,
          "estimatedMinutes": 20,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "All Lessons Complete ‚úÖ",
              "content": "\n### Lesson 1: Introduction to Testing ‚úÖ\n- Understanding the testing pyramid\n- Unit tests, widget tests, integration tests\n- AAA pattern (Arrange, Act, Assert)\n- Setting up test environment\n- Writing your first tests\n\n### Lesson 2: Widget Testing ‚úÖ\n- Testing Flutter widgets\n- WidgetTester and pump methods\n- Finding widgets (find.text, find.byKey, find.byType)\n- Simulating user interactions\n- Testing forms and validation\n\n### Lesson 3: Mocking Dependencies ‚úÖ\n- Using mocktail package (v1.0.4)\n- Creating mocks without code generation\n- Mocking API calls and services\n- Verify method calls with verification\n- Stubbing return values with when/thenAnswer\n\n### Lesson 4: Integration Testing ‚úÖ\n- Using integration_test package\n- IntegrationTestWidgetsFlutterBinding\n- Testing complete user flows across multiple screens\n- Running tests on physical devices/emulators\n- Testing navigation, forms, and multi-screen interactions\n\n### Lesson 5: End-to-End Testing with Firebase Test Lab ‚úÖ\n- Setting up Firebase Test Lab\n- Building and uploading test APKs and iOS test bundles\n- Running tests on hundreds of real devices in the cloud\n- Robo tests for automated UI exploration\n- Analyzing test results and device-specific issues\n- Integrating Test Lab into CI/CD pipelines\n\n### Lesson 6: Test Coverage and Reporting ‚úÖ\n- Generating coverage reports with flutter test --coverage\n- Understanding coverage metrics (line, function, branch)\n- Using lcov and genhtml for HTML reports\n- Excluding generated files from coverage\n- Visualizing coverage in VSCode\n- Setting coverage targets and enforcing them in CI/CD\n- Best practices for improving coverage strategically\n\n### Lesson 7: CI/CD for Flutter Apps ‚úÖ\n- Understanding Continuous Integration and Deployment\n- Setting up GitHub Actions workflows\n- Configuring Codemagic for Flutter-first CI/CD\n- Implementing quality gates (linting, testing, coverage)\n- Automating builds and deployments\n- Running Firebase Test Lab in CI/CD\n- Deploying to TestFlight and Google Play automatically\n\n### Lesson 8: Testing Best Practices Mini-Project ‚úÖ\n- Complete TaskMaster Pro application\n- Comprehensive test suite (unit, widget, integration)\n- 80%+ test coverage\n- Full CI/CD pipeline with GitHub Actions\n- Automated coverage reporting\n- Production-ready testing practices\n- Portfolio-quality project demonstrating testing expertise\n\n"
            },
            {
              "type": "THEORY",
              "title": "Module 10 Complete! üéâ",
              "content": "\nThis module provides a complete, production-ready testing education covering:\n- **Unit Testing**: Test individual functions and logic\n- **Widget Testing**: Test UI components in isolation\n- **Integration Testing**: Test complete user workflows\n- **Mocking**: Isolate code from dependencies\n- **Coverage**: Measure and improve test effectiveness\n- **Firebase Test Lab**: Test on hundreds of real devices\n- **CI/CD**: Automate testing and deployment\n- **Best Practices**: Build maintainable, reliable test suites\n\nStudents completing this module will have professional-level testing skills ready for production Flutter development.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.2",
          "title": "Watch mode (re-run on file changes)",
          "moduleId": "module-10",
          "order": 2,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Why testing matters in app development\n- Types of tests (unit, widget, integration)\n- Test-Driven Development (TDD) basics\n- Setting up your testing environment\n- Writing your first test\n- The testing pyramid\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: Why Test Your Code?",
              "content": "\n### Real-World Analogy\nThink of testing like a **safety inspection for a building**:\n- **Unit Tests** = Checking individual bricks (do they meet quality standards?)\n- **Widget Tests** = Testing rooms (do doors open, do lights work?)\n- **Integration Tests** = Full building walkthrough (does everything work together?)\n\nJust like you wouldn't move into a building without inspections, you shouldn't ship an app without tests!\n\n### Why This Matters\nTesting prevents disasters:\n\n1. **Catch Bugs Early**: Find issues before users do\n2. **Confidence to Refactor**: Change code without fear of breaking things\n3. **Documentation**: Tests show how code should work\n4. **Faster Development**: Automated tests are faster than manual testing\n5. **Better Design**: Testable code is usually better code\n\nAccording to Google, apps with >80% test coverage have **56% fewer production bugs** and **40% faster feature development** over time!\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Testing Pyramid",
              "content": "\n\n**The Golden Rule:**\n- **70%** Unit Tests (fast, isolated)\n- **20%** Widget Tests (UI components)\n- **10%** Integration Tests (full app flows)\n\n",
              "code": "         /\\\n        /  \\  Few, Slow, Expensive\n       /E2E \\  (Integration Tests)\n      /______\\\n     /        \\\n    / Widget  \\ Some, Medium Speed\n   /   Tests   \\\n  /____________\\\n /              \\\n/  Unit Tests    \\ Many, Fast, Cheap\n/__________________\\",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Types of Tests",
              "content": "\n### 1. Unit Tests\n**What:** Test individual functions, methods, or classes in isolation\n\n**Example:** Testing a function that calculates BMI\n\n**When to Use:**\n- Business logic\n- Calculations\n- Data transformations\n- Utility functions\n\n### 2. Widget Tests\n**What:** Test UI components (widgets) in isolation\n\n**Example:** Testing if a button shows correct text\n\n**When to Use:**\n- Button interactions\n- Form validation\n- Navigation\n- Widget rendering\n\n### 3. Integration Tests\n**What:** Test complete app flows on real devices/emulators\n\n**Example:** Testing login ‚Üí home ‚Üí logout flow\n\n**When to Use:**\n- Critical user flows\n- End-to-end features\n- Multi-screen interactions\n- External dependencies (API, database)\n\n",
              "code": "testWidgets('Complete user journey', (tester) async {\n  app.main();\n  await tester.pumpAndSettle();\n\n  // Login\n  await tester.enterText(find.byKey(Key('email')), 'test@example.com');\n  await tester.enterText(find.byKey(Key('password')), 'password123');\n  await tester.tap(find.text('Login'));\n  await tester.pumpAndSettle();\n\n  // Verify home screen\n  expect(find.text('Welcome'), findsOneWidget);\n\n  // Logout\n  await tester.tap(find.byIcon(Icons.logout));\n  await tester.pumpAndSettle();\n\n  // Verify back to login\n  expect(find.text('Login'), findsOneWidget);\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Testing",
              "content": "\n### Default Test Setup\n\nFlutter projects come with testing built-in! No extra setup needed for basic tests.\n\n**pubspec.yaml** (already includes):\n\n### Test File Structure\n\n\n**Convention:** Test files mirror your `lib/` structure with `_test.dart` suffix.\n\n",
              "code": "my_app/\n‚îú‚îÄ‚îÄ lib/\n‚îÇ   ‚îú‚îÄ‚îÄ main.dart\n‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.dart\n‚îÇ   ‚îî‚îÄ‚îÄ services/\n‚îÇ       ‚îî‚îÄ‚îÄ auth_service.dart\n‚îú‚îÄ‚îÄ test/                    # Unit & Widget tests\n‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user_test.dart   # Naming: <file>_test.dart\n‚îÇ   ‚îî‚îÄ‚îÄ services/\n‚îÇ       ‚îî‚îÄ‚îÄ auth_service_test.dart\n‚îî‚îÄ‚îÄ integration_test/        # Integration tests\n    ‚îî‚îÄ‚îÄ app_test.dart",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Your First Unit Test",
              "content": "\n### Example: Testing a Calculator\n\n**lib/utils/calculator.dart:**\n\n**test/utils/calculator_test.dart:**\n\n### Running Tests\n\n\n**Output:**\n\n",
              "code": "00:01 +6: All tests passed!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Test Anatomy",
              "content": "\n### Basic Structure\n\n\n**AAA Pattern:**\n- **Arrange**: Set up test data and preconditions\n- **Act**: Execute the code under test\n- **Assert**: Verify the outcome\n\n### Common Matchers\n\n\n",
              "code": "// Equality\nexpect(actual, equals(expected));\nexpect(actual, expected);  // Shorthand\n\n// Numerical\nexpect(value, greaterThan(10));\nexpect(value, lessThan(100));\nexpect(value, inRange(10, 20));\nexpect(3.14159, closeTo(3.14, 0.01));  // For floats\n\n// Types\nexpect(value, isA<String>());\nexpect(value, isNotNull);\nexpect(value, isNull);\n\n// Collections\nexpect(list, contains(5));\nexpect(list, containsAll([1, 2, 3]));\nexpect(list, isEmpty);\nexpect(list, hasLength(3));\n\n// Strings\nexpect(text, startsWith('Hello'));\nexpect(text, endsWith('World'));\nexpect(text, matches(RegExp(r'\\d+')));  // Regex\n\n// Exceptions\nexpect(() => throwsError(), throwsException);\nexpect(() => divideByZero(), throwsA(isA<ArgumentError>()));",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Test Organization",
              "content": "\n### Using `group()`\n\nGroup related tests together:\n\n\n**Output:**\n\n### Setup and Teardown\n\n\n",
              "code": "void main() {\n  late Database database;\n\n  // Runs ONCE before all tests\n  setUpAll(() {\n    print('Setting up test suite...');\n  });\n\n  // Runs BEFORE EACH test\n  setUp(() {\n    database = Database.inMemory();\n  });\n\n  // Runs AFTER EACH test\n  tearDown(() {\n    database.close();\n  });\n\n  // Runs ONCE after all tests\n  tearDownAll(() {\n    print('Cleaning up test suite...');\n  });\n\n  test('insert adds record', () {\n    database.insert('users', {'name': 'Alice'});\n    expect(database.count('users'), 1);\n  });\n\n  test('delete removes record', () {\n    database.insert('users', {'name': 'Bob'});\n    database.delete('users', 1);\n    expect(database.count('users'), 0);\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Test-Driven Development (TDD)",
              "content": "\n### The Red-Green-Refactor Cycle\n\n1. **Red**: Write a failing test first\n2. **Green**: Write minimal code to make it pass\n3. **Refactor**: Improve code while keeping tests green\n\n**Example: Building a Todo List**\n\n**Step 1: Red (Write failing test)**\n\n**Step 2: Green (Make it pass)**\n\n**Step 3: Refactor (Improve if needed)**\n\n**Benefits of TDD:**\n- ‚úÖ Forces you to think about requirements first\n- ‚úÖ Ensures every feature has tests\n- ‚úÖ Prevents over-engineering\n- ‚úÖ Immediate feedback loop\n\n",
              "code": "class Todo {\n  final String title;\n  final bool isCompleted;\n\n  Todo(this.title, {this.isCompleted = false});\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: BMI Calculator",
              "content": "\n**lib/models/bmi_calculator.dart:**\n\n**test/models/bmi_calculator_test.dart:**\n\n**Run the tests:**\n\n**Output:**\n\n",
              "code": "00:01 +12: All tests passed!",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Test Names Should Be Descriptive**\n   ```dart\n   // ‚ùå Bad\n   test('test1', () { /* ... */ });\n\n   // ‚úÖ Good\n   test('calculateBMI returns correct value for normal inputs', () { /* ... */ });\n   ```\n\n2. **One Assertion Per Test (Usually)**\n   ```dart\n   // ‚ùå Bad - testing multiple things\n   test('user validation', () {\n     expect(user.isValidEmail(), true);\n     expect(user.isValidAge(), true);\n     expect(user.isValidName(), true);\n   });\n\n   // ‚úÖ Good - separate tests\n   test('validates email format correctly', () {\n     expect(user.isValidEmail(), true);\n   });\n\n   test('validates age is positive', () {\n     expect(user.isValidAge(), true);\n   });\n   ```\n\n3. **Test Edge Cases**\n   - Zero, negative, null values\n   - Empty strings, empty lists\n   - Boundary values (min, max)\n   - Unexpected inputs\n\n4. **Keep Tests Fast**\n   - Unit tests should run in milliseconds\n   - Avoid file I/O, network calls, delays\n   - Use mocks for external dependencies\n\n5. **Tests Should Be Independent**\n   - No shared state between tests\n   - Tests can run in any order\n   - Each test sets up its own data\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** In the testing pyramid, which type of test should you have the most of?\nA) Integration tests\nB) Widget tests\nC) Unit tests\nD) E2E tests\n\n**Question 2:** What does the `setUp()` function do?\nA) Runs once before all tests\nB) Runs before each individual test\nC) Runs after each test\nD) Runs only when tests fail\n\n**Question 3:** Which matcher would you use to test if a float is approximately equal?\nA) equals()\nB) closeTo()\nC) approximately()\nD) near()\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Test a Shopping Cart",
              "content": "\nCreate a `ShoppingCart` class with these methods:\n- `addItem(String name, double price)`\n- `removeItem(String name)`\n- `getTotal()`\n- `applyDiscount(double percentage)`\n\nWrite comprehensive unit tests covering:\n1. Adding items increases total\n2. Removing items decreases total\n3. Discount is applied correctly\n4. Edge cases (empty cart, removing non-existent item, 100% discount)\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've learned the fundamentals of testing in Flutter! Here's what we covered:\n\n- **Testing Pyramid**: 70% unit, 20% widget, 10% integration\n- **Test Types**: Unit (functions), Widget (UI), Integration (full app)\n- **Test Structure**: AAA pattern (Arrange, Act, Assert)\n- **Test Organization**: `group()`, `setUp()`, `tearDown()`\n- **TDD**: Red-Green-Refactor cycle\n- **Best Practices**: Descriptive names, fast tests, edge cases\n\nTesting may seem like extra work, but it **saves time** and **prevents bugs** in the long run!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** C) Unit tests\n\nThe testing pyramid recommends having the most unit tests (~70%) because they're fast, cheap, and test individual pieces of logic in isolation. Widget tests should be ~20% and integration tests ~10%.\n\n**Answer 2:** B) Runs before each individual test\n\n`setUp()` runs before EACH test in the group. Use `setUpAll()` to run once before all tests, `tearDown()` to run after each test, and `tearDownAll()` to run once after all tests.\n\n**Answer 3:** B) closeTo()\n\n`closeTo(expected, delta)` is used for floating-point comparisons because of precision issues. Example: `expect(3.14159, closeTo(3.14, 0.01))` checks if the value is within 0.01 of 3.14.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.3",
          "title": "Lesson 2: Widget Testing",
          "moduleId": "module-10",
          "order": 3,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Testing Flutter widgets\n- Using WidgetTester (pumping, finding, tapping)\n- Testing user interactions\n- Testing navigation\n- Testing forms and validation\n- Golden tests for visual regression\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: What Are Widget Tests?",
              "content": "\n### Real-World Analogy\nWidget testing is like **quality checking furniture in a showroom**:\n- **Does the button work?** (interaction testing)\n- **Does the drawer open smoothly?** (animation testing)\n- **Does it look right?** (visual testing)\n- **Does everything fit together?** (layout testing)\n\nYou test each piece of furniture (widget) in isolation before assembling the whole room (app).\n\n### Why This Matters\nWidget tests verify your UI works correctly:\n\n1. **User Interactions**: Buttons, taps, gestures\n2. **Visual Appearance**: Colors, fonts, layouts\n3. **State Changes**: UI updates when data changes\n4. **Navigation**: Screen transitions work\n5. **Forms**: Input validation and submission\n\nWidget tests run faster than integration tests but provide more confidence than unit tests!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Widget Testing Basics",
              "content": "\n### Your First Widget Test\n\n**lib/widgets/counter_widget.dart:**\n\n**test/widgets/counter_widget_test.dart:**\n\n### Key Concepts\n\n**`testWidgets()`**: Creates a widget test (like `test()` for unit tests)\n\n**`WidgetTester`**: Provides tools to interact with widgets\n- `pump()`: Rebuild widgets once\n- `pumpAndSettle()`: Wait for all animations to complete\n- `tap()`: Simulate user tap\n- `enterText()`: Type into text fields\n\n**`find`**: Locate widgets on screen\n- `find.text('Hello')`: Find by text\n- `find.byType(ElevatedButton)`: Find by widget type\n- `find.byKey(Key('my_key'))`: Find by key\n- `find.byIcon(Icons.add)`: Find by icon\n\n**`expect()`**: Assert what you found\n- `findsOneWidget`: Exactly one match\n- `findsNothing`: No matches\n- `findsNWidgets(3)`: Exactly 3 matches\n- `findsWidgets`: At least one match\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:my_app/widgets/counter_widget.dart';\n\nvoid main() {\n  testWidgets('Counter increments when button is tapped', (WidgetTester tester) async {\n    // 1. ARRANGE: Build the widget\n    await tester.pumpWidget(\n      MaterialApp(\n        home: Scaffold(\n          body: CounterWidget(),\n        ),\n      ),\n    );\n\n    // 2. ASSERT: Verify initial state\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    // 3. ACT: Tap the button\n    await tester.tap(find.text('Increment'));\n    await tester.pump();  // Rebuild after state change\n\n    // 4. ASSERT: Verify state changed\n    expect(find.text('0'), findsNothing);\n    expect(find.text('1'), findsOneWidget);\n\n    // Tap again\n    await tester.tap(find.text('Increment'));\n    await tester.pump();\n\n    expect(find.text('2'), findsOneWidget);\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Finding Widgets",
              "content": "\n### Different Ways to Find Widgets\n\n\n### Using Keys for Reliable Tests\n\n\n**Why keys?**\n- Text can change (translations, dynamic content)\n- Widget types can be duplicated\n- Keys provide stable references\n\n",
              "code": "// ‚úÖ Good - using keys\nText('Welcome', key: Key('welcome_text'));\nElevatedButton(\n  key: Key('login_button'),\n  onPressed: () {},\n  child: Text('Login'),\n);\n\n// In test\nexpect(find.byKey(Key('welcome_text')), findsOneWidget);\nawait tester.tap(find.byKey(Key('login_button')));",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Interacting with Widgets",
              "content": "\n### Tapping Buttons\n\n\n### Entering Text\n\n\n### Scrolling\n\n\n### Long Press\n\n\n### Drag and Swipe\n\n\n",
              "code": "testWidgets('Can swipe to dismiss', (tester) async {\n  bool dismissed = false;\n\n  await tester.pumpWidget(\n    MaterialApp(\n      home: Scaffold(\n        body: Dismissible(\n          key: Key('dismissible'),\n          onDismissed: (_) => dismissed = true,\n          child: Container(\n            height: 100,\n            color: Colors.blue,\n            child: Text('Swipe me'),\n          ),\n        ),\n      ),\n    ),\n  );\n\n  // Swipe from left to right\n  await tester.drag(find.byKey(Key('dismissible')), Offset(500, 0));\n  await tester.pumpAndSettle();  // Wait for animation\n\n  expect(dismissed, true);\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Testing Forms",
              "content": "\n### Complete Form Example\n\n**lib/screens/login_screen.dart:**\n\n**test/screens/login_screen_test.dart:**\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:my_app/screens/login_screen.dart';\n\nvoid main() {\n  group('LoginScreen', () {\n    testWidgets('shows email and password fields', (tester) async {\n      await tester.pumpWidget(\n        MaterialApp(home: LoginScreen()),\n      );\n\n      expect(find.byKey(Key('email')), findsOneWidget);\n      expect(find.byKey(Key('password')), findsOneWidget);\n      expect(find.byKey(Key('login_button')), findsOneWidget);\n    });\n\n    testWidgets('validates empty email', (tester) async {\n      await tester.pumpWidget(\n        MaterialApp(home: LoginScreen()),\n      );\n\n      // Tap login without entering anything\n      await tester.tap(find.byKey(Key('login_button')));\n      await tester.pump();\n\n      // Should show validation error\n      expect(find.text('Please enter email'), findsOneWidget);\n    });\n\n    testWidgets('validates invalid email format', (tester) async {\n      await tester.pumpWidget(\n        MaterialApp(home: LoginScreen()),\n      );\n\n      // Enter invalid email\n      await tester.enterText(find.byKey(Key('email')), 'notanemail');\n      await tester.tap(find.byKey(Key('login_button')));\n      await tester.pump();\n\n      expect(find.text('Invalid email format'), findsOneWidget);\n    });\n\n    testWidgets('validates password length', (tester) async {\n      await tester.pumpWidget(\n        MaterialApp(home: LoginScreen()),\n      );\n\n      await tester.enterText(find.byKey(Key('email')), 'test@example.com');\n      await tester.enterText(find.byKey(Key('password')), '123');\n      await tester.tap(find.byKey(Key('login_button')));\n      await tester.pump();\n\n      expect(find.text('Password must be at least 6 characters'), findsOneWidget);\n    });\n\n    testWidgets('calls onLogin with valid credentials', (tester) async {\n      String? capturedEmail;\n      String? capturedPassword;\n\n      await tester.pumpWidget(\n        MaterialApp(\n          home: LoginScreen(\n            onLogin: (email, password) {\n              capturedEmail = email;\n              capturedPassword = password;\n            },\n          ),\n        ),\n      );\n\n      // Enter valid credentials\n      await tester.enterText(find.byKey(Key('email')), 'test@example.com');\n      await tester.enterText(find.byKey(Key('password')), 'password123');\n      await tester.tap(find.byKey(Key('login_button')));\n      await tester.pump();\n\n      // Should call onLogin callback\n      expect(capturedEmail, 'test@example.com');\n      expect(capturedPassword, 'password123');\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Pump Methods",
              "content": "\n### Understanding Pump Variants\n\n\n**When to use which:**\n- `pump()`: After state changes with no animations\n- `pump(Duration)`: To test specific animation frames\n- `pumpAndSettle()`: After navigation, dialogs, or complex animations\n\n",
              "code": "// pump(): Rebuild once\nawait tester.pump();\n\n// pump(Duration): Advance time and rebuild\nawait tester.pump(Duration(milliseconds: 500));\n\n// pumpAndSettle(): Rebuild until animations finish (default 10 minutes timeout)\nawait tester.pumpAndSettle();\n\n// pumpAndSettle(Duration): With custom timeout\nawait tester.pumpAndSettle(Duration(seconds: 5));",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Golden Tests (Visual Regression)",
              "content": "\nTest that UI looks exactly as expected by comparing screenshots.\n\n\n**Generate golden files:**\n\n**Run golden tests:**\n\n**Use cases:**\n- Verify UI changes don't break existing designs\n- Catch unintended visual regressions\n- Document expected UI appearance\n\n",
              "code": "flutter test",
              "language": "bash"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Todo App",
              "content": "\n**test/widgets/todo_list_test.dart:**\n\n",
              "code": "import 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nvoid main() {\n  testWidgets('Todo app full workflow', (tester) async {\n    await tester.pumpWidget(\n      MaterialApp(home: TodoApp()),\n    );\n\n    // Initially empty\n    expect(find.text('No todos yet!'), findsOneWidget);\n\n    // Add todo\n    await tester.enterText(find.byType(TextField), 'Buy milk');\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pump();\n\n    // Todo appears\n    expect(find.text('Buy milk'), findsOneWidget);\n    expect(find.text('No todos yet!'), findsNothing);\n\n    // Add another\n    await tester.enterText(find.byType(TextField), 'Walk dog');\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pump();\n\n    expect(find.byType(Checkbox), findsNWidgets(2));\n\n    // Complete first todo\n    await tester.tap(find.byType(Checkbox).first);\n    await tester.pump();\n\n    // Delete completed todo\n    await tester.tap(find.byIcon(Icons.delete).first);\n    await tester.pump();\n\n    // Only one todo remains\n    expect(find.text('Buy milk'), findsNothing);\n    expect(find.text('Walk dog'), findsOneWidget);\n  });\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Use Keys for Important Widgets**\n   ```dart\n   TextField(key: Key('email_input'))\n   ElevatedButton(key: Key('submit_button'))\n   ```\n\n2. **Wait for Animations**\n   ```dart\n   await tester.pumpAndSettle();  // After navigation, dialogs\n   ```\n\n3. **Test User Perspective**\n   ```dart\n   // ‚úÖ Good - find by what user sees\n   await tester.tap(find.text('Login'));\n\n   // ‚ùå Bad - implementation detail\n   await tester.tap(find.byType(ElevatedButton).at(2));\n   ```\n\n4. **Test Edge Cases**\n   - Empty states\n   - Long text overflow\n   - Different screen sizes\n   - Disabled buttons\n\n5. **Keep Tests Focused**\n   ```dart\n   // ‚úÖ Good - tests one thing\n   testWidgets('Submit button is disabled when form is invalid')\n\n   // ‚ùå Bad - tests multiple things\n   testWidgets('Form works correctly')\n   ```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** Which method waits for all animations to complete?\nA) pump()\nB) pumpAndSettle()\nC) pumpWidget()\nD) pumpFrame()\n\n**Question 2:** How do you simulate a user typing text?\nA) tester.type()\nB) tester.enterText()\nC) tester.input()\nD) tester.setText()\n\n**Question 3:** What does `findsOneWidget` assert?\nA) At least one widget was found\nB) Exactly one widget was found\nC) The first widget found\nD) One or more widgets found\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Test a Calculator UI",
              "content": "\nCreate a calculator widget with:\n- Number buttons (0-9)\n- Operation buttons (+, -, √ó, √∑)\n- Equals button\n- Clear button\n- Display showing current value\n\nWrite widget tests for:\n1. Number buttons update display\n2. Addition works (2 + 3 = 5)\n3. Clear button resets to 0\n4. Division by zero shows error\n5. Multiple operations in sequence\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered widget testing in Flutter! Here's what we covered:\n\n- **WidgetTester**: pump(), pumpAndSettle(), tap(), enterText()\n- **Finders**: find.text(), find.byKey(), find.byType()\n- **Matchers**: findsOneWidget, findsNothing, findsNWidgets()\n- **Interactions**: Tapping, scrolling, swiping, entering text\n- **Forms**: Validation testing\n- **Navigation**: Screen transitions\n- **Golden Tests**: Visual regression testing\n\nWidget tests give you confidence your UI works before users see it!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) pumpAndSettle()\n\n`pumpAndSettle()` repeatedly calls `pump()` until there are no more frames scheduled, ensuring all animations and asynchronous operations complete. Use it after navigation or dialogs.\n\n**Answer 2:** B) tester.enterText()\n\n`tester.enterText(finder, 'text')` simulates typing text into a TextField. You provide a finder for the TextField and the text to enter.\n\n**Answer 3:** B) Exactly one widget was found\n\n`findsOneWidget` asserts that the finder located exactly one matching widget. Use `findsWidgets` for \"at least one\" or `findsNWidgets(n)` for exactly n widgets.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.4",
          "title": "Lesson 3: Mocking Dependencies",
          "moduleId": "module-10",
          "order": 4,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Why and when to mock dependencies\n- Using Mocktail for mocking (v1.0.4)\n- Mocking API calls and services\n- Verifying method calls\n- Stubbing return values\n- Testing error scenarios\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: What is Mocking?",
              "content": "\n### Real-World Analogy\nThink of mocking like **using a crash test dummy** instead of a real person:\n- **Testing a car crash?** Use a dummy (don't crash a real person!)\n- **Testing your code?** Use a mock (don't call real APIs!)\n\nMocks are **fake objects** that simulate real dependencies for testing.\n\n### Why Mock?\n\n1. **Speed**: No network delays or database queries\n2. **Reliability**: Tests don't fail due to external services\n3. **Control**: Test error scenarios easily\n4. **Isolation**: Test your code, not external code\n5. **Cost**: No API rate limits or charges\n\n**Example**: Testing a weather app shouldn't require actual weather API calls!\n\n"
            },
            {
              "type": "THEORY",
              "title": "When to Mock vs Not Mock",
              "content": "\n### ‚úÖ DO Mock:\n- External APIs (REST, GraphQL)\n- Databases\n- File systems\n- Third-party services\n- Time/date functions\n- Random number generators\n\n### ‚ùå DON'T Mock:\n- Simple data classes (models)\n- Pure functions (no side effects)\n- Flutter framework widgets\n- Your own business logic (test it for real!)\n\n**Rule of Thumb:** Mock **boundaries** (edges of your app), test **internals** (your code) for real.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setting Up Mocktail",
              "content": "\n### Installation\n\n**pubspec.yaml:**\n\n\n**Why Mocktail over Mockito?**\n- ‚úÖ No code generation (no build_runner)\n- ‚úÖ Better null safety support\n- ‚úÖ Cleaner API\n- ‚úÖ Less boilerplate\n\n",
              "code": "flutter pub get",
              "language": "bash"
            },
            {
              "type": "EXAMPLE",
              "title": "Basic Mocking Example",
              "content": "\n### Creating a Mock\n\n**lib/services/weather_service.dart:**\n\n**test/services/weather_service_test.dart:**\n\n",
              "code": "import 'package:flutter_test/flutter_test.dart';\nimport 'package:mocktail/mocktail.dart';\nimport 'package:my_app/services/weather_service.dart';\n\n// 1. Create a mock class\nclass MockWeatherService extends Mock implements WeatherService {}\n\nvoid main() {\n  group('WeatherService', () {\n    late MockWeatherService mockWeatherService;\n\n    setUp(() {\n      mockWeatherService = MockWeatherService();\n    });\n\n    test('getTemperature returns mocked value', () async {\n      // 2. Stub the method (define what it returns)\n      when(() => mockWeatherService.getTemperature('London'))\n          .thenAnswer((_) async => 22.5);\n\n      // 3. Call the mocked method\n      final temp = await mockWeatherService.getTemperature('London');\n\n      // 4. Verify the result\n      expect(temp, 22.5);\n\n      // 5. Verify the method was called\n      verify(() => mockWeatherService.getTemperature('London')).called(1);\n    });\n\n    test('getForecast returns list', () async {\n      // Stub with a list\n      when(() => mockWeatherService.getForecast('Paris', 3))\n          .thenAnswer((_) async => ['Sunny', 'Cloudy', 'Rainy']);\n\n      final forecast = await mockWeatherService.getForecast('Paris', 3);\n\n      expect(forecast, ['Sunny', 'Cloudy', 'Rainy']);\n      expect(forecast, hasLength(3));\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Stubbing Methods",
              "content": "\n### Different Ways to Stub\n\n\n",
              "code": "class MockUserRepository extends Mock implements UserRepository {}\n\nvoid main() {\n  late MockUserRepository mockRepo;\n\n  setUp(() {\n    mockRepo = MockUserRepository();\n  });\n\n  // 1. Simple return value\n  test('stub with simple value', () {\n    when(() => mockRepo.getUserCount()).thenReturn(42);\n    expect(mockRepo.getUserCount(), 42);\n  });\n\n  // 2. Async/Future return\n  test('stub async method', () async {\n    when(() => mockRepo.getUser(1))\n        .thenAnswer((_) async => User(id: 1, name: 'Alice'));\n\n    final user = await mockRepo.getUser(1);\n    expect(user.name, 'Alice');\n  });\n\n  // 3. Throwing errors\n  test('stub to throw exception', () {\n    when(() => mockRepo.getUser(999))\n        .thenThrow(UserNotFoundException('User not found'));\n\n    expect(\n      () => mockRepo.getUser(999),\n      throwsA(isA<UserNotFoundException>()),\n    );\n  });\n\n  // 4. Different returns for different arguments\n  test('stub based on arguments', () async {\n    when(() => mockRepo.getUser(1))\n        .thenAnswer((_) async => User(id: 1, name: 'Alice'));\n    when(() => mockRepo.getUser(2))\n        .thenAnswer((_) async => User(id: 2, name: 'Bob'));\n\n    final alice = await mockRepo.getUser(1);\n    final bob = await mockRepo.getUser(2);\n\n    expect(alice.name, 'Alice');\n    expect(bob.name, 'Bob');\n  });\n\n  // 5. Using argument matchers\n  test('stub with any argument', () async {\n    when(() => mockRepo.getUser(any()))\n        .thenAnswer((_) async => User(id: 0, name: 'Default'));\n\n    final user1 = await mockRepo.getUser(1);\n    final user2 = await mockRepo.getUser(999);\n\n    expect(user1.name, 'Default');\n    expect(user2.name, 'Default');\n  });\n\n  // 6. Sequential returns (different value each call)\n  test('return different values sequentially', () {\n    when(() => mockRepo.getUserCount())\n        .thenReturn(1)\n        .thenReturn(2)\n        .thenReturn(3);\n\n    expect(mockRepo.getUserCount(), 1);\n    expect(mockRepo.getUserCount(), 2);\n    expect(mockRepo.getUserCount(), 3);\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Verification",
              "content": "\n### Verifying Method Calls\n\n\n",
              "code": "test('verify method was called', () async {\n  when(() => mockRepo.saveUser(any())).thenAnswer((_) async => true);\n\n  await mockRepo.saveUser(User(id: 1, name: 'Alice'));\n\n  // Verify it was called exactly once\n  verify(() => mockRepo.saveUser(any())).called(1);\n});\n\ntest('verify method was never called', () {\n  verifyNever(() => mockRepo.deleteUser(any()));\n});\n\ntest('verify method was called multiple times', () {\n  mockRepo.getUserCount();\n  mockRepo.getUserCount();\n  mockRepo.getUserCount();\n\n  verify(() => mockRepo.getUserCount()).called(3);\n});\n\ntest('verify method was called at least once', () {\n  mockRepo.getUserCount();\n  mockRepo.getUserCount();\n\n  verify(() => mockRepo.getUserCount()).called(greaterThan(0));\n});\n\ntest('verify method call with specific argument', () async {\n  when(() => mockRepo.getUser(any())).thenAnswer((_) async => User(id: 1, name: 'Alice'));\n\n  await mockRepo.getUser(42);\n\n  verify(() => mockRepo.getUser(42)).called(1);\n  verifyNever(() => mockRepo.getUser(99));\n});\n\ntest('verify call order', () {\n  mockRepo.getUserCount();\n  mockRepo.saveUser(User(id: 1, name: 'Alice'));\n  mockRepo.getUserCount();\n\n  verifyInOrder([\n    () => mockRepo.getUserCount(),\n    () => mockRepo.saveUser(any()),\n    () => mockRepo.getUserCount(),\n  ]);\n});",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Testing a Login Screen",
              "content": "\n**lib/services/auth_service.dart:**\n\n**lib/viewmodels/login_viewmodel.dart:**\n\n**test/viewmodels/login_viewmodel_test.dart:**\n\n",
              "code": "import 'package:flutter_test/flutter_test.dart';\nimport 'package:mocktail/mocktail.dart';\nimport 'package:my_app/services/auth_service.dart';\nimport 'package:my_app/viewmodels/login_viewmodel.dart';\n\nclass MockAuthService extends Mock implements AuthService {}\n\nvoid main() {\n  group('LoginViewModel', () {\n    late MockAuthService mockAuthService;\n    late LoginViewModel viewModel;\n\n    setUp(() {\n      mockAuthService = MockAuthService();\n      viewModel = LoginViewModel(mockAuthService);\n    });\n\n    test('successful login sets currentUser and returns true', () async {\n      // Arrange\n      final mockUser = User(\n        id: '123',\n        email: 'test@example.com',\n        name: 'Test User',\n      );\n\n      when(() => mockAuthService.login('test@example.com', 'password123'))\n          .thenAnswer((_) async => mockUser);\n\n      // Act\n      final result = await viewModel.login('test@example.com', 'password123');\n\n      // Assert\n      expect(result, true);\n      expect(viewModel.currentUser, mockUser);\n      expect(viewModel.errorMessage, null);\n      expect(viewModel.isLoading, false);\n\n      verify(() => mockAuthService.login('test@example.com', 'password123'))\n          .called(1);\n    });\n\n    test('failed login with invalid credentials shows error', () async {\n      // Arrange\n      when(() => mockAuthService.login(any(), any()))\n          .thenThrow(InvalidCredentialsException());\n\n      // Act\n      final result = await viewModel.login('wrong@example.com', 'wrongpass');\n\n      // Assert\n      expect(result, false);\n      expect(viewModel.currentUser, null);\n      expect(viewModel.errorMessage, 'Invalid email or password');\n      expect(viewModel.isLoading, false);\n    });\n\n    test('network error shows appropriate message', () async {\n      // Arrange\n      when(() => mockAuthService.login(any(), any()))\n          .thenThrow(NetworkException());\n\n      // Act\n      final result = await viewModel.login('test@example.com', 'password123');\n\n      // Assert\n      expect(result, false);\n      expect(viewModel.errorMessage, 'Network error. Please try again.');\n    });\n\n    test('unexpected error shows generic message', () async {\n      // Arrange\n      when(() => mockAuthService.login(any(), any()))\n          .thenThrow(Exception('Something went wrong'));\n\n      // Act\n      final result = await viewModel.login('test@example.com', 'password123');\n\n      // Assert\n      expect(result, false);\n      expect(viewModel.errorMessage, 'An unexpected error occurred');\n    });\n\n    test('logout clears currentUser', () async {\n      // Arrange\n      viewModel.currentUser = User(\n        id: '123',\n        email: 'test@example.com',\n        name: 'Test User',\n      );\n\n      when(() => mockAuthService.logout()).thenAnswer((_) async {});\n\n      // Act\n      await viewModel.logout();\n\n      // Assert\n      expect(viewModel.currentUser, null);\n      verify(() => mockAuthService.logout()).called(1);\n    });\n\n    test('isLoading is true during login', () async {\n      // Arrange\n      when(() => mockAuthService.login(any(), any()))\n          .thenAnswer((_) async {\n            // Simulate delay\n            await Future.delayed(Duration(milliseconds: 100));\n            return User(id: '123', email: 'test@example.com', name: 'Test');\n          });\n\n      // Act\n      final loginFuture = viewModel.login('test@example.com', 'password123');\n\n      // Check immediately (should be loading)\n      expect(viewModel.isLoading, true);\n\n      // Wait for completion\n      await loginFuture;\n\n      // Should no longer be loading\n      expect(viewModel.isLoading, false);\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Mocking HTTP Calls",
              "content": "\n### Using Mocktail with Dio/HTTP\n\n\n",
              "code": "import 'package:http/http.dart' as http;\nimport 'package:mocktail/mocktail.dart';\n\nclass MockHttpClient extends Mock implements http.Client {}\n\nvoid main() {\n  setUpAll(() {\n    // Register fallback values for Uri type\n    registerFallbackValue(Uri());\n  });\n\n  test('fetch user data from API', () async {\n    final mockClient = MockHttpClient();\n\n    // Stub the get method\n    when(() => mockClient.get(any())).thenAnswer(\n      (_) async => http.Response(\n        '{\"id\": 1, \"name\": \"Alice\"}',\n        200,\n      ),\n    );\n\n    final userService = UserService(mockClient);\n    final user = await userService.getUser(1);\n\n    expect(user.name, 'Alice');\n    verify(() => mockClient.get(Uri.parse('https://api.example.com/users/1')))\n        .called(1);\n  });\n\n  test('handles 404 error', () async {\n    final mockClient = MockHttpClient();\n\n    when(() => mockClient.get(any())).thenAnswer(\n      (_) async => http.Response('Not Found', 404),\n    );\n\n    final userService = UserService(mockClient);\n\n    expect(\n      () => userService.getUser(999),\n      throwsA(isA<UserNotFoundException>()),\n    );\n  });\n}",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Best Practices",
              "content": "\n1. **Mock Interfaces, Not Implementations**\n   ```dart\n   // ‚úÖ Good\n   abstract class AuthService { /* ... */ }\n   class MockAuthService extends Mock implements AuthService {}\n\n   // ‚ùå Bad\n   class RealAuthService { /* ... */ }\n   class MockAuthService extends Mock implements RealAuthService {}\n   ```\n\n2. **Use `setUpAll()` for Fallback Values**\n   ```dart\n   setUpAll(() {\n     registerFallbackValue(Uri());\n     registerFallbackValue(User(id: '0', email: '', name: ''));\n   });\n   ```\n\n3. **Verify Important Interactions**\n   ```dart\n   // Verify critical side effects\n   verify(() => mockRepo.saveToDatabase(any())).called(1);\n\n   // Don't over-verify\n   // verifyNever(() => mockRepo.log(any()));  // Unnecessary\n   ```\n\n4. **Use Descriptive Test Names**\n   ```dart\n   test('login with valid credentials sets currentUser')\n   test('login with network error shows error message')\n   ```\n\n5. **Reset Mocks Between Tests**\n   ```dart\n   setUp(() {\n     mockService = MockService();  // Create fresh mock\n     reset(mockService);  // Or reset existing mock\n   });\n   ```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the main advantage of Mocktail over Mockito?\nA) It's faster\nB) No code generation needed\nC) Better for integration tests\nD) Works on iOS only\n\n**Question 2:** When should you use `thenAnswer()` instead of `thenReturn()`?\nA) For async methods returning Future\nB) For sync methods\nC) Only for error cases\nD) Never, they're the same\n\n**Question 3:** What does `verify().called(1)` check?\nA) The method returned 1\nB) The method was called exactly once\nC) The method was called with argument 1\nD) The method took 1 second\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Mock a Weather App",
              "content": "\nCreate a weather app service and test it:\n\n\nWrite tests for:\n1. Successful weather fetch\n2. City not found (404 error)\n3. Network timeout\n4. Forecast returns correct number of days\n5. Verify API is called with correct city name\n\n",
              "code": "abstract class WeatherApi {\n  Future<Weather> getCurrentWeather(String city);\n  Future<List<Weather>> getForecast(String city, int days);\n}\n\nclass Weather {\n  final double temperature;\n  final String condition;\n  final DateTime date;\n\n  Weather(this.temperature, this.condition, this.date);\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've mastered mocking in Flutter! Here's what we covered:\n\n- **Why Mock**: Speed, reliability, control, isolation\n- **Mocktail Setup**: No code generation needed\n- **Stubbing**: `when().thenReturn()` and `when().thenAnswer()`\n- **Verification**: `verify().called()` and `verifyNever()`\n- **Argument Matchers**: `any()`, `captureAny()`\n- **Complete Example**: Login viewmodel with error handling\n\nMocking lets you test your code in isolation without external dependencies!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) No code generation needed\n\nMocktail's main advantage is that it doesn't require `build_runner` or code generation. You just extend `Mock` and implement your interface. This makes tests cleaner and faster to write.\n\n**Answer 2:** A) For async methods returning Future\n\nUse `thenAnswer()` for async methods because it takes a callback that can return a Future. Use `thenReturn()` for synchronous methods that return values immediately.\n\n**Answer 3:** B) The method was called exactly once\n\n`verify().called(1)` verifies that the method was invoked exactly one time during the test. Use `.called(n)` for n times, `greaterThan(n)` for at least n times, or `.never()` for zero times.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.5",
          "title": "Run on all connected devices",
          "moduleId": "module-10",
          "order": 5,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Learning Objectives",
              "content": "By the end of this lesson, you will be able to:\n- Understand the difference between widget tests and integration tests\n- Set up the integration_test package in your Flutter project\n- Write integration tests that simulate real user interactions\n- Run integration tests on physical devices and emulators\n- Test navigation flows and multi-screen interactions\n- Use IntegrationTestWidgetsFlutterBinding for device testing\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\n### What is Integration Testing?\n\n**Concept First:**\nImagine you're a restaurant inspector. Unit testing is like checking each ingredient separately (is the lettuce fresh? is the meat cooked?). Widget testing is like tasting individual dishes (does the burger taste good?). **Integration testing** is like experiencing the entire dining experience from start to finish‚Äîwalking in, ordering, waiting, eating, and paying. You're making sure everything works together seamlessly.\n\nIn Flutter, integration testing verifies that your entire app works correctly from the user's perspective. It tests multiple widgets, screens, and services working together as a complete system.\n\n**Jargon:**\n- **Integration Test**: Tests that verify multiple parts of your app work together correctly\n- **End-to-End (E2E) Test**: Tests that simulate complete user journeys through your app\n- **IntegrationTestWidgetsFlutterBinding**: A test binding that allows tests to run on real devices\n\n### Why This Matters\n\nIntegration tests catch issues that unit and widget tests miss:\n- **Navigation bugs**: Does tapping \"Login\" actually take you to the home screen?\n- **Data flow issues**: When you add an item to the cart, does it show up on the checkout screen?\n- **Real device behavior**: Does your app work on actual Android and iOS devices?\n- **User journey validation**: Can users complete critical tasks from start to finish?\n\n**Real-world analogy:** Your app might have perfect individual features (like a car with a great engine, comfortable seats, and smooth steering), but integration tests ensure they work together (can you actually drive the car from point A to point B?).\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 1: Integration Testing vs Widget Testing",
              "content": "\n### Key Differences\n\n| Aspect | Widget Testing | Integration Testing |\n|--------|---------------|---------------------|\n| **Scope** | Single widget/screen | Multiple screens and flows |\n| **Speed** | Fast (milliseconds) | Slower (seconds) |\n| **Runs on** | Host machine only | Real devices + emulators |\n| **Dependencies** | Often mocked | Real services |\n| **Purpose** | Verify UI components | Verify complete user flows |\n\n### When to Use Each\n\n**Use Widget Tests when:**\n- Testing individual widgets or screens\n- Verifying UI logic and interactions\n- Running tests quickly during development\n- Mocking external dependencies\n\n**Use Integration Tests when:**\n- Testing navigation between screens\n- Verifying complete user workflows\n- Testing on real devices before release\n- Ensuring app works with real backend services\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 2: Setting Up Integration Testing",
              "content": "\n### Step 1: Create Integration Test Directory\n\nIn your Flutter project root, create a new directory:\n\n\n### Step 2: Add Integration Test Package\n\nThe `integration_test` package comes with Flutter SDK. No version needed!\n\n\nRun:\n\n### Step 3: Understand the Test Structure\n\n**integration_test/** directory structure:\n\n",
              "code": "integration_test/\n‚îú‚îÄ‚îÄ app_test.dart              # Main integration test file\n‚îú‚îÄ‚îÄ login_flow_test.dart       # Specific user flow tests\n‚îî‚îÄ‚îÄ checkout_flow_test.dart    # Another flow test",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Section 3: Writing Your First Integration Test",
              "content": "\n### Example: Testing a Login Flow\n\nLet's create a simple app and test the complete login journey.\n\n#### Step 1: Create the App\n\n\n#### Step 2: Write the Integration Test\n\n\n### Key Differences from Widget Tests\n\n1. **IntegrationTestWidgetsFlutterBinding.ensureInitialized()**\n   - Required at the start of integration tests\n   - Allows tests to run on real devices\n   - Not needed in widget tests\n\n2. **app.main() instead of pumping a widget**\n   - Starts the entire app, not just a widget\n   - Simulates launching the app like a user would\n\n3. **More pumpAndSettle() calls**\n   - Integration tests have more async operations\n   - Navigation, animations, and API calls take time\n\n",
              "code": "// integration_test/login_flow_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\nimport 'package:your_app/main.dart' as app;\n\nvoid main() {\n  // CRITICAL: Initialize the integration test binding\n  // This allows tests to run on real devices\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('Login Flow Integration Tests', () {\n    testWidgets('Complete login flow with valid credentials',\n        (WidgetTester tester) async {\n      // ARRANGE: Start the app\n      app.main();\n      await tester.pumpAndSettle();\n\n      // Verify we're on the login screen\n      expect(find.text('Login'), findsOneWidget);\n      expect(find.byKey(const Key('emailField')), findsOneWidget);\n\n      // ACT: Enter email\n      await tester.enterText(\n        find.byKey(const Key('emailField')),\n        'test@example.com',\n      );\n      await tester.pumpAndSettle();\n\n      // ACT: Enter password\n      await tester.enterText(\n        find.byKey(const Key('passwordField')),\n        'password123',\n      );\n      await tester.pumpAndSettle();\n\n      // ACT: Tap login button\n      await tester.tap(find.byKey(const Key('loginButton')));\n      await tester.pumpAndSettle();\n\n      // ASSERT: Verify navigation to home screen\n      expect(find.text('Welcome!'), findsOneWidget);\n      expect(find.text('You are now logged in'), findsOneWidget);\n      expect(find.text('Login'), findsNothing); // Login screen is gone\n    });\n\n    testWidgets('Login flow with invalid credentials shows error',\n        (WidgetTester tester) async {\n      // ARRANGE\n      app.main();\n      await tester.pumpAndSettle();\n\n      // ACT: Enter wrong credentials\n      await tester.enterText(\n        find.byKey(const Key('emailField')),\n        'wrong@example.com',\n      );\n      await tester.enterText(\n        find.byKey(const Key('passwordField')),\n        'wrongpassword',\n      );\n      await tester.pumpAndSettle();\n\n      await tester.tap(find.byKey(const Key('loginButton')));\n      await tester.pumpAndSettle();\n\n      // ASSERT: Still on login screen with error\n      expect(find.text('Login'), findsOneWidget);\n      expect(find.text('Invalid credentials'), findsOneWidget);\n      expect(find.text('Welcome!'), findsNothing); // Not on home screen\n    });\n\n    testWidgets('Login flow with empty fields shows validation error',\n        (WidgetTester tester) async {\n      // ARRANGE\n      app.main();\n      await tester.pumpAndSettle();\n\n      // ACT: Tap login without entering anything\n      await tester.tap(find.byKey(const Key('loginButton')));\n      await tester.pumpAndSettle();\n\n      // ASSERT: Error message appears\n      expect(find.text('Please fill in all fields'), findsOneWidget);\n      expect(find.text('Welcome!'), findsNothing);\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 4: Running Integration Tests",
              "content": "\n### On Desktop/Emulator (Fastest)\n\n\n### On Physical Device (Most Realistic)\n\n**For Android:**\n1. Connect your Android device via USB\n2. Enable USB debugging in Developer Options\n3. Run:\n\n**For iOS:**\n1. Connect your iPhone via USB\n2. Trust the computer on your device\n3. Run:\n\n### Running on Multiple Devices\n\n\n",
              "code": "flutter test integration_test --all",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Section 5: Advanced Integration Test Patterns",
              "content": "\n### Testing Multi-Screen Navigation\n\n\n### Testing Scrolling and List Interactions\n\n\n### Testing Forms with Validation\n\n\n",
              "code": "testWidgets('Registration form validation flow',\n    (WidgetTester tester) async {\n  app.main();\n  await tester.pumpAndSettle();\n\n  // Navigate to registration screen\n  await tester.tap(find.text('Register'));\n  await tester.pumpAndSettle();\n\n  // Test 1: Submit empty form\n  await tester.tap(find.text('Submit'));\n  await tester.pumpAndSettle();\n\n  expect(find.text('Name is required'), findsOneWidget);\n  expect(find.text('Email is required'), findsOneWidget);\n\n  // Test 2: Invalid email format\n  await tester.enterText(find.byKey(const Key('emailField')), 'invalidemail');\n  await tester.tap(find.text('Submit'));\n  await tester.pumpAndSettle();\n\n  expect(find.text('Enter a valid email'), findsOneWidget);\n\n  // Test 3: Valid submission\n  await tester.enterText(find.byKey(const Key('nameField')), 'John Doe');\n  await tester.enterText(\n    find.byKey(const Key('emailField')),\n    'john@example.com',\n  );\n  await tester.enterText(\n    find.byKey(const Key('passwordField')),\n    'securepass123',\n  );\n  await tester.pumpAndSettle();\n\n  await tester.tap(find.text('Submit'));\n  await tester.pumpAndSettle();\n\n  // Verify success\n  expect(find.text('Registration Successful'), findsOneWidget);\n});",
              "language": "dart"
            },
            {
              "type": "EXPERIMENT",
              "title": "Section 6: Best Practices for Integration Testing",
              "content": "\n### 1. Use Keys for Important Widgets\n\n**Bad:**\n\n**Good:**\n\n### 2. Wait for Animations and Async Operations\n\n\n### 3. Test One User Flow Per Test\n\n**Bad:** One massive test that tests everything\n\n**Good:** Separate tests for each flow\n\n### 4. Use Descriptive Test Names\n\n**Bad:**\n\n**Good:**\n\n### 5. Clean Up Between Tests\n\n\n",
              "code": "testWidgets('Login test', (WidgetTester tester) async {\n  app.main();\n  await tester.pumpAndSettle();\n\n  // Test code...\n\n  // No explicit cleanup needed - each test starts fresh\n  // The next testWidgets call will restart the app\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 7: Debugging Integration Tests",
              "content": "\n### Common Issues and Solutions\n\n#### Issue 1: \"Unable to find widget\"\n\n**Error:**\n\n**Solutions:**\n\n#### Issue 2: Test Times Out\n\n**Error:**\n\n**Solutions:**\n\n#### Issue 3: Flaky Tests (Sometimes Pass, Sometimes Fail)\n\n**Causes:**\n- Network-dependent code\n- Race conditions with async operations\n- Animation timing issues\n\n**Solutions:**\n\n",
              "code": "// Wait for specific conditions instead of arbitrary delays\nawait tester.pumpAndSettle();\n\n// For network operations, consider mocking in integration tests\n// Or use retry logic\nfor (int i = 0; i < 3; i++) {\n  await tester.pumpAndSettle();\n  if (find.text('Loaded').evaluate().isNotEmpty) break;\n  await Future.delayed(const Duration(seconds: 1));\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Integration Test Example",
              "content": "\nHere's a comprehensive example testing a todo app:\n\n\n",
              "code": "// integration_test/todo_app_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\nimport 'package:your_app/main.dart' as app;\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('Todo App Integration Tests', () {\n    testWidgets('User can add, complete, and delete a todo',\n        (WidgetTester tester) async {\n      // ARRANGE: Start the app\n      app.main();\n      await tester.pumpAndSettle();\n\n      // Verify empty state\n      expect(find.text('No todos yet'), findsOneWidget);\n\n      // ACT: Add a new todo\n      await tester.tap(find.byKey(const Key('addButton')));\n      await tester.pumpAndSettle();\n\n      // Enter todo text\n      await tester.enterText(\n        find.byKey(const Key('todoInputField')),\n        'Buy groceries',\n      );\n      await tester.pumpAndSettle();\n\n      await tester.tap(find.text('Save'));\n      await tester.pumpAndSettle();\n\n      // ASSERT: Todo appears in list\n      expect(find.text('Buy groceries'), findsOneWidget);\n      expect(find.text('No todos yet'), findsNothing);\n\n      // ACT: Mark todo as complete\n      await tester.tap(find.byKey(const Key('todoCheckbox_0')));\n      await tester.pumpAndSettle();\n\n      // ASSERT: Todo is marked complete (strikethrough or different style)\n      final todoWidget = tester.widget(find.text('Buy groceries'));\n      // Add assertions based on your implementation\n\n      // ACT: Delete the todo\n      await tester.tap(find.byKey(const Key('deleteButton_0')));\n      await tester.pumpAndSettle();\n\n      // ASSERT: Todo is removed\n      expect(find.text('Buy groceries'), findsNothing);\n      expect(find.text('No todos yet'), findsOneWidget);\n    });\n\n    testWidgets('User can add multiple todos and filter them',\n        (WidgetTester tester) async {\n      app.main();\n      await tester.pumpAndSettle();\n\n      // Add first todo\n      await tester.tap(find.byKey(const Key('addButton')));\n      await tester.pumpAndSettle();\n      await tester.enterText(\n        find.byKey(const Key('todoInputField')),\n        'Task 1',\n      );\n      await tester.tap(find.text('Save'));\n      await tester.pumpAndSettle();\n\n      // Add second todo\n      await tester.tap(find.byKey(const Key('addButton')));\n      await tester.pumpAndSettle();\n      await tester.enterText(\n        find.byKey(const Key('todoInputField')),\n        'Task 2',\n      );\n      await tester.tap(find.text('Save'));\n      await tester.pumpAndSettle();\n\n      // Verify both todos exist\n      expect(find.text('Task 1'), findsOneWidget);\n      expect(find.text('Task 2'), findsOneWidget);\n\n      // Complete first todo\n      await tester.tap(find.byKey(const Key('todoCheckbox_0')));\n      await tester.pumpAndSettle();\n\n      // Filter to show only active todos\n      await tester.tap(find.text('Active'));\n      await tester.pumpAndSettle();\n\n      // Verify only active todo is shown\n      expect(find.text('Task 1'), findsNothing); // Completed, hidden\n      expect(find.text('Task 2'), findsOneWidget); // Active, visible\n\n      // Filter to show completed todos\n      await tester.tap(find.text('Completed'));\n      await tester.pumpAndSettle();\n\n      // Verify only completed todo is shown\n      expect(find.text('Task 1'), findsOneWidget);\n      expect(find.text('Task 2'), findsNothing);\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\nTest your understanding of integration testing:\n\n### Question 1\nWhat is the primary difference between widget tests and integration tests?\n\nA) Widget tests are faster\nB) Integration tests run on real devices\nC) Integration tests test complete user flows across multiple screens\nD) All of the above\n\n### Question 2\nWhat must you call at the beginning of an integration test file?\n\nA) `WidgetTester.ensureInitialized()`\nB) `IntegrationTestWidgetsFlutterBinding.ensureInitialized()`\nC) `Flutter.initializeIntegrationTests()`\nD) Nothing special is required\n\n### Question 3\nHow do you run integration tests on a connected physical device?\n\nA) `flutter run integration_test`\nB) `flutter test integration_test --device-id=<id>`\nC) `flutter device test`\nD) Integration tests cannot run on physical devices\n\n### Question 4\nWhat is the purpose of `await tester.pumpAndSettle()` in integration tests?\n\nA) To restart the test\nB) To wait for all animations and async operations to complete\nC) To take a screenshot\nD) To clean up test resources\n\n### Question 5\nWhat is the recommended way to find widgets in integration tests?\n\nA) By text content only\nB) By widget type only\nC) By using Key widgets assigned to important UI elements\nD) Using index positions in the widget tree\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Question 1: D** - All of the above. Integration tests differ from widget tests in that they're slower, run on real devices, and test complete workflows.\n\n**Question 2: B** - `IntegrationTestWidgetsFlutterBinding.ensureInitialized()` must be called at the start. This binding allows tests to run on physical devices.\n\n**Question 3: B** - Use `flutter test integration_test --device-id=<id>`. You first run `flutter devices` to get your device ID, then specify it in the test command.\n\n**Question 4: B** - `pumpAndSettle()` waits for all animations, frame updates, and async operations to complete before proceeding. This ensures widgets are in their final state before assertions.\n\n**Question 5: C** - Using `Key` widgets is the most reliable approach. Text and types can change, but keys provide stable, explicit identifiers for testing.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nIn this lesson, you learned:\n\n‚úÖ **Integration tests** verify complete user workflows across multiple screens\n‚úÖ **IntegrationTestWidgetsFlutterBinding** enables testing on real devices\n‚úÖ Integration tests start with `app.main()` to launch the entire app\n‚úÖ Use `pumpAndSettle()` frequently to wait for async operations\n‚úÖ Add **Key widgets** to important UI elements for reliable test finders\n‚úÖ Run tests with `flutter test integration_test` or on devices\n‚úÖ Write separate tests for each user flow for maintainability\n‚úÖ Integration tests are slower but catch issues that unit/widget tests miss\n\n**Key Takeaway:** Integration testing is your final defense before users encounter bugs. While slower than unit and widget tests, they verify that your entire app works as a cohesive system. Use them to test critical user journeys like login, checkout, and core features.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn **Lesson 10.5: End-to-End Testing with Firebase Test Lab**, you'll learn how to run your integration tests on hundreds of real Android and iOS devices in the cloud, catching device-specific bugs before your users do.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.6",
          "title": "End-to-End Testing with Firebase Test Lab",
          "moduleId": "module-10",
          "order": 6,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Learning Objectives",
              "content": "By the end of this lesson, you will be able to:\n- Understand what Firebase Test Lab is and why it's essential\n- Set up Firebase Test Lab for your Flutter project\n- Build and upload test APKs and iOS test bundles to Test Lab\n- Run integration tests on hundreds of real devices in the cloud\n- Analyze test results and device-specific issues\n- Integrate Firebase Test Lab into your CI/CD pipeline\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\n### What is Firebase Test Lab?\n\n**Concept First:**\nImagine you're opening a restaurant chain in 50 different cities. You could personally visit each location to check if everything works (expensive and slow), or you could hire local inspectors in each city who all check at the same time and send you detailed reports (fast and comprehensive).\n\n**Firebase Test Lab** is like having thousands of device testers working simultaneously. It's Google's cloud-based testing infrastructure that runs your app on hundreds of real Android and iOS devices, catching device-specific bugs before your users encounter them.\n\n**Real-world scenario:** Your app works perfectly on your Samsung Galaxy S24 during development, but crashes on a Pixel 6 with Android 13, freezes on an iPhone 12 with iOS 16, and has layout issues on tablets. Test Lab would catch all these issues automatically.\n\n**Jargon:**\n- **Firebase Test Lab**: Google's cloud infrastructure for testing apps on real devices\n- **Test Matrix**: A collection of test executions across multiple device configurations\n- **Robo Test**: Automated UI testing that explores your app without written tests\n- **Instrumentation Test**: Your integration tests packaged as Android instrumentation or iOS XCTests\n\n### Why This Matters\n\n**The Device Fragmentation Problem:**\n- Android has **24,000+ different device models**\n- iOS has 30+ iPhone models and 20+ iPad models\n- Different screen sizes, OS versions, and hardware capabilities\n- What works on one device might fail on another\n\n**Without Test Lab:**\n- Buy and maintain dozens of physical devices ($$$$)\n- Manually test on each device (weeks of work)\n- Still miss device-specific bugs\n- Users discover issues after release\n\n**With Test Lab:**\n- Test on hundreds of devices in minutes\n- Automatic screenshots and crash logs\n- Pay only for testing time used\n- Catch issues before users see them\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 1: Setting Up Firebase Test Lab",
              "content": "\n### Step 1: Create a Firebase Project\n\n1. Go to [Firebase Console](https://console.firebase.google.com/)\n2. Click \"Add project\"\n3. Enter project name (e.g., \"my-flutter-app\")\n4. Click \"Continue\"\n5. Disable Google Analytics (optional for testing)\n6. Click \"Create project\"\n\n### Step 2: Enable Firebase Test Lab\n\n1. In Firebase Console, select your project\n2. Click \"Test Lab\" in the left sidebar (under \"Release & Monitor\")\n3. Test Lab is automatically enabled - no additional setup needed!\n\n### Step 3: Install Firebase CLI\n\n\n### Step 4: Install gcloud SDK (for Advanced Usage)\n\n\n",
              "code": "brew install --cask google-cloud-sdk\n\ncurl https://sdk.cloud.google.com | bash\nexec -l $SHELL\n\n\ngcloud init\ngcloud auth login",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Section 2: Preparing Your Flutter App for Test Lab",
              "content": "\n### Add Integration Tests (if not already present)\n\nEnsure you have integration tests in your project:\n\n\n### Sample Integration Test\n\n\n",
              "code": "// integration_test/app_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\nimport 'package:your_app/main.dart' as app;\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  testWidgets('Complete user flow test', (WidgetTester tester) async {\n    app.main();\n    await tester.pumpAndSettle();\n\n    // Test your app's critical flows\n    expect(find.text('Welcome'), findsOneWidget);\n\n    // Add more test steps...\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 3: Running Tests on Android Devices",
              "content": "\n### Step 1: Build the App and Test APKs\n\nFirebase Test Lab requires two APK files:\n1. **App APK**: Your app in debug mode\n2. **Test APK**: Your integration tests packaged as instrumentation tests\n\n\n**Location of built APKs:**\n- App APK: `build/app/outputs/flutter-apk/app-debug.apk`\n- Test APK: `build/app/outputs/apk/androidTest/debug/app-debug-androidTest.apk`\n\n### Step 2: Upload and Run Tests via Firebase Console (Easiest)\n\n1. Go to [Firebase Console](https://console.firebase.google.com/)\n2. Select your project\n3. Click \"Test Lab\" in the sidebar\n4. Click \"Run a test\"\n5. Select \"Instrumentation\"\n6. Upload:\n   - **App APK**: `build/app/outputs/flutter-apk/app-debug.apk`\n   - **Test APK**: `build/app/outputs/apk/androidTest/debug/app-debug-androidTest.apk`\n7. Select devices (you can choose from physical devices)\n8. Click \"Start tests\"\n\n**Free Tier:**\n- 5 virtual device tests/day\n- 10 physical device tests/day\n\n### Step 3: Run Tests via Command Line (Advanced)\n\n\n### Step 4: Run on Multiple Device Configurations\n\nCreate a device matrix to test different combinations:\n\n\n### Available Device Models\n\n\n",
              "code": "gcloud firebase test android models list --project $PROJECT_ID\n\ngcloud firebase test android versions list --project $PROJECT_ID",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Section 4: Running Tests on iOS Devices",
              "content": "\n### Step 1: Build iOS Test Bundle\n\niOS testing requires creating a `.zip` file containing your test build:\n\n\n**Test bundle location:** `build/ios_integ/Build/Products/ios_tests.zip`\n\n### Step 2: Upload and Run iOS Tests via Firebase Console\n\n1. Go to Firebase Console ‚Üí Test Lab\n2. Click \"Run a test\"\n3. Select \"XCTest\"\n4. Upload `ios_tests.zip`\n5. Select iOS devices\n6. Click \"Start tests\"\n\n### Step 3: Run iOS Tests via Command Line\n\n\n### Available iOS Devices\n\n\n",
              "code": "gcloud firebase test ios models list --project $PROJECT_ID\n\ngcloud firebase test ios versions list --project $PROJECT_ID",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Section 5: Analyzing Test Results",
              "content": "\n### Viewing Results in Firebase Console\n\nAfter tests complete:\n\n1. Go to Firebase Console ‚Üí Test Lab\n2. Click on your test run\n3. View results for each device:\n   - ‚úÖ **Passed**: All tests passed\n   - ‚ùå **Failed**: Tests failed or crashed\n   - ‚ö†Ô∏è **Inconclusive**: Test didn't complete\n\n### Detailed Device Results\n\nClick on any device to see:\n- **Video Recording**: Watch your app running on the device\n- **Screenshots**: Automatic screenshots at key moments\n- **Logs**: Complete logcat (Android) or syslog (iOS)\n- **Performance Metrics**: CPU, memory, network usage\n- **Test Artifacts**: Downloaded test outputs\n\n### Understanding Common Failures\n\n#### Failure Type 1: Timeout\n\n\n**Cause:** Test takes too long or has infinite loop\n**Fix:** Optimize slow operations or increase timeout\n\n#### Failure Type 2: Widget Not Found\n\n\n**Cause:** Device-specific layout differences\n**Fix:** Check screenshots to see actual layout, adjust test finders\n\n#### Failure Type 3: Crash\n\n\n**Cause:** Device-specific bug (OS version, screen size, etc.)\n**Fix:** Review stack trace, fix null safety issues\n\n### Downloading Test Artifacts\n\n\n",
              "code": "gcloud firebase test android run \\\n  --app build/app/outputs/flutter-apk/app-debug.apk \\\n  --test build/app/outputs/apk/androidTest/debug/app-debug-androidTest.apk \\\n  --results-dir=test_results/$(date +%Y%m%d_%H%M%S) \\\n  --project $PROJECT_ID\n",
              "language": "bash"
            },
            {
              "type": "EXAMPLE",
              "title": "Section 6: Robo Tests (No Code Required)",
              "content": "\n### What are Robo Tests?\n\n**Robo tests** are automated UI tests that explore your app without requiring written test code. Google's AI automatically:\n- Taps buttons and UI elements\n- Fills in text fields with sample data\n- Navigates through screens\n- Takes screenshots and videos\n- Reports crashes and UI issues\n\n**Analogy:** Like giving your app to a curious toddler who taps everything to see what happens‚Äîbut with detailed logging!\n\n### Running Robo Tests on Android\n\n\n### Robo Test via Firebase Console\n\n1. Firebase Console ‚Üí Test Lab ‚Üí \"Run a test\"\n2. Select \"Robo\"\n3. Upload only the app APK (no test APK needed)\n4. Select devices\n5. Click \"Start tests\"\n\n### When to Use Robo Tests\n\n**Good for:**\n- Quick smoke tests before release\n- Discovering crashes in unexplored areas\n- Testing without writing test code\n- Exploring new UI flows\n\n**Not good for:**\n- Testing specific user flows (use integration tests instead)\n- Testing login flows (Robo can't guess passwords)\n- Complex multi-step scenarios\n\n",
              "code": "gcloud firebase test android run \\\n  --type robo \\\n  --app build/app/outputs/flutter-apk/app-debug.apk \\\n  --device model=Pixel6,version=33 \\\n  --project $PROJECT_ID",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Section 7: Integrating Test Lab into CI/CD",
              "content": "\n### GitHub Actions Integration\n\nCreate `.github/workflows/firebase-test-lab.yml`:\n\n\n### Setting Up GitHub Secrets\n\n1. Create a Google Cloud service account:\n   ```bash\n   gcloud iam service-accounts create github-actions \\\n     --display-name=\"GitHub Actions\"\n\n   gcloud projects add-iam-policy-binding YOUR_PROJECT_ID \\\n     --member=\"serviceAccount:github-actions@YOUR_PROJECT_ID.iam.gserviceaccount.com\" \\\n     --role=\"roles/editor\"\n\n   gcloud iam service-accounts keys create credentials.json \\\n     --iam-account=github-actions@YOUR_PROJECT_ID.iam.gserviceaccount.com\n   ```\n\n2. In GitHub repository:\n   - Go to Settings ‚Üí Secrets and variables ‚Üí Actions\n   - Click \"New repository secret\"\n   - Name: `GOOGLE_CLOUD_CREDENTIALS`\n   - Value: Contents of `credentials.json`\n   - Name: `FIREBASE_PROJECT_ID`\n   - Value: Your Firebase project ID\n\n### Codemagic Integration\n\nCreate `codemagic.yaml`:\n\n\n",
              "code": "workflows:\n  flutter-test-lab:\n    name: Flutter Test Lab\n    max_build_duration: 60\n    environment:\n      flutter: stable\n      groups:\n        - firebase_credentials\n    scripts:\n      - name: Install dependencies\n        script: flutter pub get\n\n      - name: Build APKs\n        script: |\n          flutter build apk --debug\n          cd android\n          ./gradlew app:assembleDebugAndroidTest\n          cd ..\n\n      - name: Run Firebase Test Lab\n        script: |\n          echo $FIREBASE_CREDENTIALS | base64 --decode > credentials.json\n          gcloud auth activate-service-account --key-file=credentials.json\n          gcloud --quiet config set project $FIREBASE_PROJECT_ID\n\n          gcloud firebase test android run \\\n            --type instrumentation \\\n            --app build/app/outputs/flutter-apk/app-debug.apk \\\n            --test build/app/outputs/apk/androidTest/debug/app-debug-androidTest.apk \\\n            --device model=Pixel6,version=33 \\\n            --device model=SamsungGalaxyS21,version=30",
              "language": "yaml"
            },
            {
              "type": "EXPERIMENT",
              "title": "Section 8: Best Practices for Firebase Test Lab",
              "content": "\n### 1. Test on Representative Devices\n\n**Don't test on everything** (expensive and slow). Choose devices that represent your user base:\n\n\n### 2. Use Test Lab in Pre-Release Pipeline\n\n**Test flow:**\n\n### 3. Set Appropriate Timeouts\n\n\n### 4. Run Robo Tests for Quick Checks\n\n\n### 5. Analyze Failure Patterns\n\nIf tests fail on specific devices:\n- Check device-specific logs and screenshots\n- Look for patterns (all Samsung devices fail? all Android 10 devices?)\n- Add device-specific workarounds if needed\n\n### 6. Monitor Test Lab Costs\n\n**Free tier limits:**\n- 5 virtual device tests/day\n- 10 physical device tests/day\n\n**Beyond free tier:**\n- Virtual devices: $1/device-hour\n- Physical devices: $5/device-hour\n\n**Cost optimization:**\n\n",
              "code": "gcloud firebase test android run \\\n  --device model=Pixel6,version=33  # Just one device\n\ngcloud firebase test android run \\\n  --device model=Pixel6,version=33 \\\n  --device model=Pixel5,version=31 \\\n  --device model=SamsungGalaxyS21,version=30  # Multiple devices",
              "language": "bash"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Full Test Lab Workflow",
              "content": "\n### Project Structure\n\n\n### Automated Test Script\n\n\nMake it executable:\n\nRun it:\n\n",
              "code": "./scripts/run_android_test_lab.sh",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\nTest your understanding of Firebase Test Lab:\n\n### Question 1\nWhat is the main advantage of Firebase Test Lab over local device testing?\n\nA) It's completely free\nB) Tests run faster\nC) Tests run on hundreds of real devices simultaneously in the cloud\nD) It doesn't require writing test code\n\n### Question 2\nWhat two files do you need to run Android integration tests on Test Lab?\n\nA) Only the app APK\nB) App APK and test APK\nC) App APK and pubspec.yaml\nD) Just the Dart test files\n\n### Question 3\nWhat are Robo tests?\n\nA) Tests written in Robot Framework\nB) Automated UI tests that explore your app without test code\nC) Tests that run on robotic devices\nD) A deprecated testing method\n\n### Question 4\nHow many free physical device tests does Firebase Test Lab provide per day?\n\nA) Unlimited\nB) 5 tests per day\nC) 10 tests per day\nD) 100 tests per day\n\n### Question 5\nWhen should you run Firebase Test Lab tests in your CI/CD pipeline?\n\nA) After every single commit\nB) After unit tests pass and before merging to main\nC) Only once per month\nD) Never - only run manually\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Question 1: C** - The main advantage is testing on hundreds of real devices simultaneously in Google's cloud infrastructure. This catches device-specific bugs impossible to find with just local testing.\n\n**Question 2: B** - You need both the app APK (your app in debug mode) and the test APK (your integration tests packaged as instrumentation tests).\n\n**Question 3: B** - Robo tests are automated UI tests where Google's AI explores your app by tapping buttons, filling forms, and navigating screens without requiring written test code.\n\n**Question 4: C** - The free tier provides 10 physical device tests per day and 5 virtual device tests per day.\n\n**Question 5: B** - Best practice is to run Test Lab after unit tests pass and before merging to main. This catches issues early while keeping costs reasonable.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nIn this lesson, you learned:\n\n‚úÖ **Firebase Test Lab** runs your app on hundreds of real devices in the cloud\n‚úÖ Test on **physical Android and iOS devices** to catch device-specific bugs\n‚úÖ Build **app APKs and test APKs** for Android, **test bundles** for iOS\n‚úÖ Use **Robo tests** for quick automated exploration without test code\n‚úÖ Analyze **videos, screenshots, logs, and performance metrics** for each device\n‚úÖ Integrate Test Lab into **CI/CD pipelines** with GitHub Actions or Codemagic\n‚úÖ Free tier provides **10 physical device tests/day** for development\n‚úÖ Choose **representative devices** to balance coverage and cost\n\n**Key Takeaway:** Firebase Test Lab is essential for production apps. It's the difference between \"works on my device\" and \"works on 10,000+ device configurations worldwide.\" Integrate it into your release pipeline to catch device-specific bugs before users do.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn **Lesson 10.6: Test Coverage and Reporting**, you'll learn how to measure which parts of your code are tested, generate coverage reports, and identify untested code that needs more tests.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.7",
          "title": "View in browser",
          "moduleId": "module-10",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Learning Objectives",
              "content": "By the end of this lesson, you will be able to:\n- Understand what test coverage is and why it matters\n- Generate test coverage reports for your Flutter project\n- Interpret coverage metrics (line, function, and branch coverage)\n- Exclude generated files from coverage reports\n- Visualize coverage data in VSCode and HTML reports\n- Set coverage targets and enforce them in CI/CD\n- Identify untested code and improve coverage strategically\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\n### What is Test Coverage?\n\n**Concept First:**\nImagine you're a safety inspector testing all the fire exits in a building. You check each door one by one, marking them off on your floor plan. When you're done, you can see which exits you tested (highlighted in green) and which you didn't test yet (still red). That marked floor plan is your \"coverage report.\"\n\n**Test coverage** measures which parts of your code are executed when your tests run. It shows you:\n- ‚úÖ **Green (covered)**: Code that's tested\n- ‚ùå **Red (uncovered)**: Code that's NOT tested\n- ‚ö†Ô∏è **Yellow (partially covered)**: Code that's only sometimes tested\n\n**Jargon:**\n- **Line Coverage**: Percentage of code lines executed by tests\n- **Function Coverage**: Percentage of functions/methods called by tests\n- **Branch Coverage**: Percentage of decision paths (if/else, switch) tested\n- **LCOV**: Linux Code Coverage tool, the standard format for coverage data\n- **lcov.info**: The file containing raw coverage data\n\n### Why This Matters\n\n**Real-world scenario:** You have 10,000 lines of code. Your tests pass ‚úÖ, so everything's fine, right?\n\n**Not necessarily!** Your tests might only execute 30% of your code. That means 7,000 lines are completely untested and could have bugs lurking.\n\n**Coverage helps you:**\n1. **Find blind spots**: Discover code paths never executed by tests\n2. **Prioritize testing**: Focus on critical untested code\n3. **Track progress**: Measure improvement over time\n4. **Catch regressions**: Ensure new code is tested\n5. **Build confidence**: Know what's actually verified\n\n**Important note:** 100% coverage ‚â† perfect code. But 30% coverage definitely means 70% is unverified!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 1: Understanding Coverage Metrics",
              "content": "\n### Line Coverage\n\n**What it measures:** Percentage of code lines executed during tests\n\n\n\n**Line coverage: 50%** (1 out of 2 lines tested)\n\n### Function Coverage\n\n**What it measures:** Percentage of functions/methods called during tests\n\n\n\n**Function coverage: 50%** (2 out of 4 functions tested)\n\n### Branch Coverage\n\n**What it measures:** Percentage of decision paths tested\n\n\n\n**Branch coverage: 33%** (1 out of 3 branches tested)\n\n**To reach 100% branch coverage:**\n\n**Branch coverage: 100%** ‚úÖ\n\n",
              "code": "test('negative age', () {\n  expect(validateAge(-5), 'Age cannot be negative');\n});\n\ntest('underage', () {\n  expect(validateAge(15), 'Must be 18 or older');\n});\n\ntest('valid age', () {\n  expect(validateAge(25), 'Valid');\n});",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 2: Generating Coverage Reports",
              "content": "\n### Step 1: Run Tests with Coverage\n\n\nThis creates:\n\n### Step 2: View Coverage in Terminal\n\nInstall `lcov` tools:\n\n\nGenerate summary:\n\n### Step 3: Generate HTML Report\n\n\n**HTML report shows:**\n- üìä Overall coverage percentage\n- üìÅ Coverage by directory and file\n- üìù Line-by-line coverage with highlighting\n- üî¥ Red lines = untested code\n- üü¢ Green lines = tested code\n\n",
              "code": "genhtml coverage/lcov.info -o coverage/html\n\nopen coverage/html/index.html  # macOS\nxdg-open coverage/html/index.html  # Linux\nstart coverage/html/index.html  # Windows",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Section 3: Excluding Generated Files",
              "content": "\n### The Problem\n\nFlutter generates files that pollute coverage reports:\n- `*.g.dart` (code generation from build_runner)\n- `*.freezed.dart` (freezed package)\n- `*.gr.dart` (auto_route)\n- `*.config.dart` (various packages)\n\n### Solution: Remove Generated Files from Coverage\n\n\n### Automated Cleanup Script\n\nCreate `scripts/coverage.sh`:\n\n\nMake it executable:\n\nRun it:\n\n",
              "code": "./scripts/coverage.sh",
              "language": "bash"
            },
            {
              "type": "KEY_POINT",
              "title": "Section 4: Visualizing Coverage in VSCode",
              "content": "\n### Option 1: Flutter Coverage Extension\n\n1. Install **Flutter Coverage** extension in VSCode\n2. Run: `flutter test --coverage`\n3. Press `Cmd+Shift+P` (Mac) or `Ctrl+Shift+P` (Windows/Linux)\n4. Type \"Flutter Coverage: Toggle\"\n5. See coverage highlighting directly in your code!\n\n**Color coding:**\n- üü¢ Green highlight = tested line\n- üî¥ Red highlight = untested line\n- No highlight = not executable (comments, declarations)\n\n### Option 2: Coverage Gutters Extension\n\n1. Install **Coverage Gutters** extension in VSCode\n2. Run: `flutter test --coverage`\n3. Click \"Watch\" in the status bar\n4. See coverage in the gutter (line numbers area)\n\n**Gutter indicators:**\n- ‚úÖ Green dot = line covered\n- ‚ùå Red dot = line not covered\n\n### Option 3: Both Extensions Together\n\nUse both for the best experience:\n- **Flutter Coverage**: Highlights entire lines\n- **Coverage Gutters**: Shows gutter indicators + branch coverage\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 5: Setting Coverage Targets",
              "content": "\n### Why Set Coverage Targets?\n\n**Target = Minimum acceptable coverage percentage**\n\nExamples:\n- **Startups/Prototypes**: 50-60% (move fast, iterate)\n- **Production apps**: 70-80% (balanced quality and speed)\n- **Critical systems**: 90%+ (healthcare, finance, aviation)\n\n### Enforcing Coverage in CI/CD\n\n#### Method 1: Using lcov (Basic)\n\n\n#### Method 2: Using test_coverage Package\n\n\n\n### GitHub Actions with Coverage Check\n\n\n",
              "code": "name: Test Coverage\n\non:\n  pull_request:\n    branches: [ main ]\n\njobs:\n  coverage:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.24.0'\n\n      - name: Install dependencies\n        run: flutter pub get\n\n      - name: Run tests with coverage\n        run: flutter test --coverage\n\n      - name: Check coverage meets minimum\n        run: |\n          sudo apt-get install lcov\n          lcov --remove coverage/lcov.info '*.g.dart' -o coverage/lcov.info\n\n          COVERAGE=$(lcov --summary coverage/lcov.info 2>&1 | \\\n            grep 'lines......:' | \\\n            grep -oP '\\d+\\.\\d+(?=%)')\n\n          echo \"Coverage: ${COVERAGE}%\"\n\n          if (( $(echo \"$COVERAGE < 70\" | bc -l) )); then\n            echo \"‚ùå Coverage below 70%\"\n            exit 1\n          fi\n\n      - name: Upload coverage to Codecov (optional)\n        uses: codecov/codecov-action@v3\n        with:\n          files: ./coverage/lcov.info",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Section 6: Improving Coverage Strategically",
              "content": "\n### Step 1: Identify Untested Code\n\n\n### Step 2: Prioritize What to Test\n\n**Not all code is equally important to test!**\n\n**High priority (test first):**\n- ‚úÖ Business logic (calculations, validations, algorithms)\n- ‚úÖ Data transformations and processing\n- ‚úÖ Error handling and edge cases\n- ‚úÖ Public APIs and interfaces\n\n**Medium priority:**\n- ‚ö†Ô∏è UI logic (can use widget tests)\n- ‚ö†Ô∏è Network layer (can mock)\n- ‚ö†Ô∏è Database operations\n\n**Low priority (okay to skip):**\n- ‚è© Generated code (*.g.dart)\n- ‚è© Simple getters/setters\n- ‚è© Trivial constructors\n- ‚è© UI widgets (covered by widget/integration tests)\n\n### Step 3: Write Tests for Uncovered Code\n\n**Example: Untested validator**\n\n\n**Coverage report shows:** 0% coverage for `isValid`\n\n**Write tests:**\n\n\n**New coverage:** 100% ‚úÖ\n\n### Step 4: Track Coverage Over Time\n\nCreate a coverage badge for your README:\n\n\n\n**Use Codecov or Coveralls for automatic tracking:**\n\n\nVisit [codecov.io](https://codecov.io) to see coverage trends over time.\n\n",
              "code": "- name: Upload to Codecov\n  uses: codecov/codecov-action@v3\n  with:\n    files: ./coverage/lcov.info\n    fail_ci_if_error: true",
              "language": "yaml"
            },
            {
              "type": "WARNING",
              "title": "Section 7: Common Coverage Pitfalls",
              "content": "\n### Pitfall 1: Chasing 100% Coverage\n\n**Bad mindset:**\n\n**Good mindset:**\n\n**Why:** Writing tests for trivial getters/setters wastes time. Focus on logic, not coverage percentage.\n\n### Pitfall 2: Testing Implementation, Not Behavior\n\n**Bad test (testing implementation):**\n\n**Good test (testing behavior):**\n\n### Pitfall 3: Including Generated Files in Coverage\n\n**Problem:** Generated files artificially lower coverage\n\n**Solution:** Always exclude them:\n\n### Pitfall 4: Not Testing Edge Cases\n\n**Weak test:**\n\n**Strong test:**\n\n",
              "code": "group('divide', () {\n  test('works with positive numbers', () {\n    expect(divide(10, 2), 5);\n  });\n\n  test('works with negative numbers', () {\n    expect(divide(-10, 2), -5);\n  });\n\n  test('throws on division by zero', () {\n    expect(() => divide(10, 0), throwsException);\n  });\n});",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Coverage Workflow",
              "content": "\n### Project Setup\n\n\n### Script: scripts/coverage.sh\n\n\n### GitHub Actions: .github/workflows/coverage.yml\n\n\n### Running Locally\n\n\n",
              "code": "chmod +x scripts/coverage.sh\n\n./scripts/coverage.sh\n\nopen coverage/html/index.html  # macOS\nxdg-open coverage/html/index.html  # Linux\nstart coverage/html/index.html  # Windows",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\nTest your understanding of test coverage:\n\n### Question 1\nWhat does 80% line coverage mean?\n\nA) 80% of functions are tested\nB) 80% of code lines are executed by tests\nC) 80% of branches are tested\nD) 80% of tests pass\n\n### Question 2\nWhy should you exclude `*.g.dart` files from coverage reports?\n\nA) They contain bugs\nB) They're generated code that you don't write\nC) They're too large\nD) They're deprecated\n\n### Question 3\nWhat's the command to generate coverage data in Flutter?\n\nA) `flutter test --coverage`\nB) `flutter coverage`\nC) `flutter test --cov`\nD) `flutter analyze --coverage`\n\n### Question 4\nWhat's a reasonable coverage target for a production Flutter app?\n\nA) 30-40%\nB) 50-60%\nC) 70-80%\nD) 100%\n\n### Question 5\nWhich code should you prioritize testing?\n\nA) Generated files (*.g.dart)\nB) Simple getters and setters\nC) Business logic and data transformations\nD) UI widget constructors\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Question 1: B** - Line coverage measures the percentage of code lines that are executed when tests run. 80% means 80 out of 100 lines were executed.\n\n**Question 2: B** - Generated files (*.g.dart, *.freezed.dart) are created by code generation tools. You don't write them, so testing coverage of generated code isn't meaningful.\n\n**Question 3: A** - Use `flutter test --coverage` to run tests and generate coverage data in the `coverage/lcov.info` file.\n\n**Question 4: C** - For production apps, 70-80% is a balanced target. It ensures critical code is tested without spending excessive time on trivial code. Critical systems (healthcare, finance) may require 90%+.\n\n**Question 5: C** - Prioritize testing business logic, algorithms, calculations, validations, and data transformations. These are where bugs have the most impact. Skip trivial getters, setters, and generated code.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nIn this lesson, you learned:\n\n‚úÖ **Test coverage** measures which code is executed by tests\n‚úÖ Three metrics: **line, function, and branch coverage**\n‚úÖ Generate coverage with `flutter test --coverage`\n‚úÖ Create HTML reports with `genhtml coverage/lcov.info -o coverage/html`\n‚úÖ **Exclude generated files** (*.g.dart) from coverage reports\n‚úÖ Visualize coverage in VSCode with **Flutter Coverage** and **Coverage Gutters**\n‚úÖ Set **coverage targets** (70-80% for production apps)\n‚úÖ Enforce coverage in CI/CD to prevent regressions\n‚úÖ Prioritize testing **business logic** over trivial code\n‚úÖ Track coverage over time with Codecov or Coveralls\n\n**Key Takeaway:** Test coverage is a powerful tool to identify untested code, but it's not the goal itself. Focus on testing meaningful business logic and critical paths. A project with 70% coverage of the right code is better than 95% coverage of trivial code.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn **Lesson 10.7: CI/CD for Flutter Apps**, you'll learn how to automate your entire testing pipeline‚Äîrunning unit tests, widget tests, integration tests, and coverage checks automatically on every commit using GitHub Actions, Codemagic, and other CI/CD platforms.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.8",
          "title": "CI/CD for Flutter Apps",
          "moduleId": "module-10",
          "order": 8,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Learning Objectives",
              "content": "By the end of this lesson, you will be able to:\n- Understand what CI/CD is and why it's essential for modern development\n- Set up GitHub Actions for automated Flutter testing and building\n- Configure Codemagic for Flutter CI/CD with minimal setup\n- Automate testing, building, and deployment workflows\n- Run tests automatically on every pull request\n- Deploy apps to TestFlight and Google Play automatically\n- Implement quality gates (linting, testing, coverage)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "\n### What is CI/CD?\n\n**Concept First:**\nImagine you're running a bakery. Without automation, you:\n1. Manually mix ingredients for every bread loaf\n2. Check each loaf by hand to ensure quality\n3. Drive each delivery to customers yourself\n4. Work 20 hours a day, exhausted\n\nWith automation (CI/CD), you:\n1. Machines mix ingredients consistently\n2. Quality sensors check each loaf automatically\n3. Delivery trucks automatically route to customers\n4. You oversee the process, focus on new recipes\n5. Run 24/7 without exhaustion\n\n**CI/CD** brings the same automation to software development.\n\n**Jargon:**\n- **CI (Continuous Integration)**: Automatically test and integrate code changes\n- **CD (Continuous Deployment)**: Automatically deploy tested code to users\n- **Pipeline**: A series of automated steps (test ‚Üí build ‚Üí deploy)\n- **Workflow**: Configuration file defining what CI/CD should do\n- **Runner**: Server that executes your CI/CD pipeline\n- **Artifact**: Build output (APK, IPA, test reports)\n\n### Why This Matters\n\n**Without CI/CD:**\n- Developer pushes code ‚Üí manually run tests ‚Üí might forget ‚Üí bugs slip through\n- Building APKs/IPAs locally ‚Üí \"works on my machine\" syndrome\n- Manual deployment ‚Üí error-prone, time-consuming\n- No consistent quality checks\n\n**With CI/CD:**\n- Every code push ‚Üí automatic tests ‚úÖ\n- Pull requests blocked if tests fail üö´\n- Builds created automatically on consistent machines\n- Deploy to stores with one click or automatically\n- Catch bugs before they reach users\n\n**Real-world impact:**\n- **Faster releases**: Deploy multiple times per day instead of per month\n- **Higher quality**: Every change is tested automatically\n- **Less stress**: No manual deployment at 2 AM\n- **Team scalability**: 10 developers can work together safely\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 1: Understanding CI/CD Pipelines",
              "content": "\n### The CI/CD Workflow\n\n\n### Popular CI/CD Platforms for Flutter (2025)\n\n| Platform | Best For | Free Tier | Flutter Support |\n|----------|----------|-----------|----------------|\n| **GitHub Actions** | GitHub projects | 2000 min/month | Excellent |\n| **Codemagic** | Flutter-first | 500 min/month | Native |\n| **CircleCI** | Docker workflows | 6000 min/month | Good |\n| **GitLab CI** | GitLab projects | 400 min/month | Good |\n| **Bitrise** | Mobile apps | 90 min/month | Excellent |\n\n**Recommendation for beginners:** Start with GitHub Actions (most projects use GitHub) or Codemagic (easiest for Flutter).\n\n",
              "code": "Developer pushes code\n    ‚Üì\n1. CODE ANALYSIS (2 min)\n   - Linting (flutter analyze)\n   - Code formatting check\n    ‚Üì\n2. TESTING (5 min)\n   - Unit tests\n   - Widget tests\n   - Test coverage check\n    ‚Üì\n3. BUILD (10 min)\n   - Build Android APK\n   - Build iOS IPA\n    ‚Üì\n4. INTEGRATION TESTING (15 min)\n   - Firebase Test Lab\n   - Multiple devices\n    ‚Üì\n5. DEPLOYMENT (automatic if all pass)\n   - Deploy to TestFlight (iOS)\n   - Deploy to Google Play Internal Track (Android)\n    ‚Üì\n6. NOTIFICATION\n   - Slack/email notification\n   - GitHub status check ‚úÖ",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 2: Setting Up GitHub Actions",
              "content": "\n### Step 1: Create Workflow File\n\nGitHub Actions workflows live in `.github/workflows/`.\n\n\n### Step 2: Basic Flutter CI Workflow\n\nCreate `.github/workflows/flutter_ci.yml`:\n\n\n### Step 3: Commit and Push\n\n\n### Step 4: View Results\n\n1. Go to your GitHub repository\n2. Click \"Actions\" tab\n3. See your workflow running!\n4. ‚úÖ Green checkmark = all passed\n5. ‚ùå Red X = something failed\n\n### Advanced: Multi-Platform CI\n\nTest on Linux, macOS, and Windows:\n\n\n",
              "code": "name: Flutter CI (Multi-Platform)\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    name: Test on ${{ matrix.os }}\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, macos-latest, windows-latest]\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.24.0'\n          channel: 'stable'\n\n      - name: Install dependencies\n        run: flutter pub get\n\n      - name: Run tests\n        run: flutter test\n\n      - name: Build\n        run: |\n          if [ \"$RUNNER_OS\" == \"Linux\" ]; then\n            flutter build apk --debug\n          elif [ \"$RUNNER_OS\" == \"macOS\" ]; then\n            flutter build ios --no-codesign\n          elif [ \"$RUNNER_OS\" == \"Windows\" ]; then\n            flutter build windows\n          fi\n        shell: bash",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Section 3: Advanced GitHub Actions Workflows",
              "content": "\n### Workflow with Test Coverage Enforcement\n\n\n### Workflow with Firebase Test Lab\n\n\n### Workflow for Automatic Deployment to Stores\n\n\n",
              "code": "name: Deploy to Stores\n\non:\n  push:\n    tags:\n      - 'v*'  # Trigger on version tags like v1.0.0\n\njobs:\n  deploy-android:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.24.0'\n\n      - uses: actions/setup-java@v3\n        with:\n          distribution: 'zulu'\n          java-version: '17'\n\n      - name: Build Android App Bundle\n        run: flutter build appbundle --release\n\n      - name: Sign APK\n        uses: r0adkll/sign-android-release@v1\n        with:\n          releaseDirectory: build/app/outputs/bundle/release\n          signingKeyBase64: ${{ secrets.SIGNING_KEY }}\n          alias: ${{ secrets.KEY_ALIAS }}\n          keyStorePassword: ${{ secrets.KEY_STORE_PASSWORD }}\n          keyPassword: ${{ secrets.KEY_PASSWORD }}\n\n      - name: Deploy to Google Play\n        uses: r0adkll/upload-google-play@v1\n        with:\n          serviceAccountJsonPlainText: ${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT }}\n          packageName: com.yourcompany.yourapp\n          releaseFiles: build/app/outputs/bundle/release/*.aab\n          track: internal  # or: alpha, beta, production\n\n  deploy-ios:\n    runs-on: macos-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.24.0'\n\n      - name: Build iOS app\n        run: flutter build ios --release --no-codesign\n\n      - name: Build and sign with Xcode\n        run: |\n          cd ios\n          xcodebuild -workspace Runner.xcworkspace \\\n            -scheme Runner \\\n            -configuration Release \\\n            -archivePath $PWD/build/Runner.xcarchive \\\n            archive\n\n          xcodebuild -exportArchive \\\n            -archivePath $PWD/build/Runner.xcarchive \\\n            -exportPath $PWD/build \\\n            -exportOptionsPlist ExportOptions.plist\n\n      - name: Upload to TestFlight\n        uses: apple-actions/upload-testflight-build@v1\n        with:\n          app-path: 'ios/build/Runner.ipa'\n          issuer-id: ${{ secrets.APPSTORE_ISSUER_ID }}\n          api-key-id: ${{ secrets.APPSTORE_API_KEY_ID }}\n          api-private-key: ${{ secrets.APPSTORE_API_PRIVATE_KEY }}",
              "language": "yaml"
            },
            {
              "type": "EXAMPLE",
              "title": "Section 4: Setting Up Codemagic",
              "content": "\nCodemagic is Flutter-first and easier to set up than GitHub Actions.\n\n### Step 1: Sign Up for Codemagic\n\n1. Go to [codemagic.io](https://codemagic.io)\n2. Sign up with GitHub, GitLab, or Bitbucket\n3. Grant access to your repositories\n\n### Step 2: Add Your Flutter App\n\n1. Click \"Add application\"\n2. Select your repository\n3. Codemagic auto-detects it's a Flutter project ‚úÖ\n\n### Step 3: Configure Workflow (UI Method)\n\n**Easiest way: Use the workflow editor**\n\n1. Click \"Start your first build\"\n2. Codemagic automatically:\n   - ‚úÖ Installs Flutter\n   - ‚úÖ Runs `flutter pub get`\n   - ‚úÖ Runs `flutter test`\n   - ‚úÖ Builds Android APK\n3. Click \"Start new build\"\n\n**That's it!** Codemagic handles everything.\n\n### Step 4: Configure Workflow (YAML Method)\n\nFor more control, create `codemagic.yaml` in your repository root:\n\n\n### Step 5: Automatic Deployment with Codemagic\n\n\n### Codemagic Features\n\n‚úÖ **Pre-installed Flutter** - No setup needed\n‚úÖ **Apple M1 machines** - Super fast iOS builds\n‚úÖ **Automatic code signing** - Handles certificates for you\n‚úÖ **Store publishing built-in** - One-click deployment\n‚úÖ **Visual workflow editor** - No YAML knowledge needed\n‚úÖ **Free tier** - 500 minutes/month\n\n",
              "code": "workflows:\n  deploy-workflow:\n    name: Deploy to Stores\n    max_build_duration: 60\n    instance_type: mac_mini_m1\n\n    environment:\n      groups:\n        - google_play  # Credentials stored in Codemagic\n        - app_store\n\n    scripts:\n      - name: Get dependencies\n        script: flutter pub get\n\n      - name: Run tests\n        script: flutter test\n\n      - name: Build Android App Bundle\n        script: flutter build appbundle --release\n\n      - name: Build iOS\n        script: |\n          flutter build ipa --release \\\n            --export-options-plist=ios/ExportOptions.plist\n\n    artifacts:\n      - build/app/outputs/bundle/release/*.aab\n      - build/ios/ipa/*.ipa\n\n    publishing:\n      google_play:\n        credentials: $GOOGLE_PLAY_CREDENTIALS\n        track: internal  # or: alpha, beta, production\n        in_app_update_priority: 3\n\n      app_store_connect:\n        api_key: $APP_STORE_CONNECT_API_KEY\n        key_id: $APP_STORE_CONNECT_KEY_ID\n        issuer_id: $APP_STORE_CONNECT_ISSUER_ID\n        submit_to_testflight: true\n\n      email:\n        recipients:\n          - team@example.com\n        notify:\n          success: true",
              "language": "yaml"
            },
            {
              "type": "EXPERIMENT",
              "title": "Section 5: Quality Gates and Best Practices",
              "content": "\n### What are Quality Gates?\n\n**Quality gates** are checks that must pass before code is merged or deployed.\n\n### Essential Quality Gates\n\n1. **Linting** - Code must follow style guidelines\n2. **Unit Tests** - All tests must pass\n3. **Widget Tests** - UI tests must pass\n4. **Coverage** - Minimum coverage threshold\n5. **Integration Tests** - Critical flows work\n6. **Build Success** - App must build without errors\n\n### Implementing Quality Gates\n\n\n### Branch Protection Rules\n\nEnforce quality gates in GitHub:\n\n1. Go to **Settings** ‚Üí **Branches**\n2. Add rule for `main` branch\n3. Enable:\n   - ‚òëÔ∏è Require a pull request before merging\n   - ‚òëÔ∏è Require status checks to pass before merging\n   - ‚òëÔ∏è Require branches to be up to date before merging\n4. Select required checks:\n   - ‚úÖ Analyze code\n   - ‚úÖ Run tests\n   - ‚úÖ Check coverage\n\nNow PRs can't be merged until all checks pass!\n\n",
              "code": "name: Quality Gates\n\non:\n  pull_request:\n    branches: [ main ]\n\njobs:\n  quality-check:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.24.0'\n\n      - name: Install dependencies\n        run: flutter pub get\n\n      # Gate 1: Formatting\n      - name: Check formatting\n        run: dart format --set-exit-if-changed .\n\n      # Gate 2: Linting\n      - name: Analyze code\n        run: flutter analyze --fatal-infos\n\n      # Gate 3: Unit tests\n      - name: Run unit tests\n        run: flutter test --exclude-tags=integration\n\n      # Gate 4: Coverage threshold\n      - name: Check test coverage\n        run: |\n          flutter test --coverage\n          sudo apt-get install -y lcov\n          lcov --remove coverage/lcov.info '*.g.dart' -o coverage/lcov.info\n\n          COVERAGE=$(lcov --summary coverage/lcov.info 2>&1 | \\\n            grep 'lines......:' | \\\n            grep -oP '\\d+\\.\\d+(?=%)')\n\n          if (( $(echo \"$COVERAGE < 70\" | bc -l) )); then\n            echo \"‚ùå Coverage ${COVERAGE}% below 70%\"\n            exit 1\n          fi\n\n      # Gate 5: Build success\n      - name: Build APK\n        run: flutter build apk --debug",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Section 6: Common CI/CD Patterns",
              "content": "\n### Pattern 1: Separate Workflows by Purpose\n\n\n**ci.yml** (fast, runs always):\n\n**integration.yml** (slow, runs on main only):\n\n**deploy.yml** (manual trigger):\n\n### Pattern 2: Caching for Faster Builds\n\n\n**Result:** Builds go from 10 minutes ‚Üí 2 minutes! ‚ö°\n\n### Pattern 3: Matrix Testing\n\nTest multiple Flutter versions:\n\n\n",
              "code": "jobs:\n  test:\n    strategy:\n      matrix:\n        flutter-version: ['3.22.0', '3.24.0']\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: ${{ matrix.flutter-version }}\n\n      - run: flutter test",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Section 7: Monitoring and Notifications",
              "content": "\n### Slack Notifications\n\n\n### Email Notifications (Codemagic)\n\n\n",
              "code": "publishing:\n  email:\n    recipients:\n      - dev-team@company.com\n      - qa-team@company.com\n    notify:\n      success: true\n      failure: true",
              "language": "yaml"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Example: Production-Ready CI/CD",
              "content": "\n### Project Structure\n\n\n### ci.yml (Runs on every PR)\n\n\n",
              "code": "name: CI\n\non:\n  pull_request:\n    branches: [ main ]\n  push:\n    branches: [ main ]\n\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    timeout-minutes: 20\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.24.0'\n          cache: true\n\n      - name: Install dependencies\n        run: flutter pub get\n\n      - name: Check formatting\n        run: dart format --set-exit-if-changed .\n\n      - name: Analyze code\n        run: flutter analyze --fatal-infos\n\n      - name: Run tests with coverage\n        run: flutter test --coverage --no-test-assets\n\n      - name: Check coverage\n        run: |\n          sudo apt-get install -y lcov\n          lcov --remove coverage/lcov.info '*.g.dart' -o coverage/lcov.info\n          COVERAGE=$(lcov --summary coverage/lcov.info 2>&1 | grep 'lines' | grep -oP '\\d+\\.\\d+(?=%)')\n          echo \"Coverage: ${COVERAGE}%\"\n          if (( $(echo \"$COVERAGE < 70\" | bc -l) )); then exit 1; fi\n\n      - name: Build APK\n        run: flutter build apk --debug",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\nTest your understanding of CI/CD for Flutter:\n\n### Question 1\nWhat does CI stand for?\n\nA) Code Integration\nB) Continuous Integration\nC) Computer Interaction\nD) Centralized Installation\n\n### Question 2\nWhat's the main benefit of CI/CD?\n\nA) Writes code for you\nB) Automatically tests and deploys code on every change\nC) Makes your app run faster\nD) Reduces app size\n\n### Question 3\nWhere do GitHub Actions workflows live in your project?\n\nA) `workflows/`\nB) `.ci/workflows/`\nC) `.github/workflows/`\nD) `github/actions/`\n\n### Question 4\nWhat's a \"quality gate\"?\n\nA) A firewall for your code\nB) A check that must pass before code can be merged\nC) A premium GitHub feature\nD) An iOS app submission requirement\n\n### Question 5\nWhich CI/CD platform is Flutter-first with native support?\n\nA) Jenkins\nB) Travis CI\nC) Codemagic\nD) CircleCI\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Question 1: B** - CI stands for **Continuous Integration**, the practice of automatically integrating and testing code changes as they're made.\n\n**Question 2: B** - The main benefit is **automation**: CI/CD automatically runs tests, builds, and deployments on every code change, catching issues early and enabling rapid releases.\n\n**Question 3: C** - GitHub Actions workflows are stored in the **`.github/workflows/`** directory as YAML files.\n\n**Question 4: B** - A quality gate is a **check that must pass** before code can be merged (e.g., tests passing, coverage above threshold, no linting errors).\n\n**Question 5: C** - **Codemagic** is built specifically for Flutter with native support, pre-installed Flutter, automatic iOS code signing, and one-click store publishing.\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nIn this lesson, you learned:\n\n‚úÖ **CI/CD automates** testing, building, and deployment workflows\n‚úÖ **GitHub Actions** uses `.github/workflows/*.yml` files\n‚úÖ **Codemagic** provides Flutter-first CI/CD with minimal setup\n‚úÖ **Quality gates** enforce code standards before merging\n‚úÖ Run tests automatically on every **pull request**\n‚úÖ **Cache dependencies** to speed up builds (10 min ‚Üí 2 min)\n‚úÖ Deploy to stores automatically with **one click or on every tag**\n‚úÖ Monitor builds with **Slack/email notifications**\n‚úÖ Use **branch protection** to block PRs until checks pass\n\n**Key Takeaway:** CI/CD transforms development from manual, error-prone processes to automated, reliable pipelines. Set it up once, and every code change is automatically tested and validated. This lets you deploy confidently multiple times per day instead of dreading monthly releases.\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn **Lesson 10.8: Testing Best Practices Mini-Project**, you'll apply everything you've learned by building a complete Flutter app with a full testing suite‚Äîunit tests, widget tests, integration tests, coverage reporting, and CI/CD automation all working together.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "10.9",
          "title": "Testing Best Practices Mini-Project",
          "moduleId": "module-10",
          "order": 9,
          "estimatedMinutes": 55,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\n**Project Name:** TaskMaster Pro - A production-ready task management app\n\n**What You'll Build:**\nA complete Flutter task management application with:\n- ‚úÖ Comprehensive test suite (unit, widget, integration)\n- ‚úÖ 80%+ test coverage\n- ‚úÖ CI/CD pipeline with GitHub Actions\n- ‚úÖ Firebase Test Lab integration\n- ‚úÖ Automated coverage reporting\n- ‚úÖ Production-ready code quality\n\n**Duration:** 4-6 hours\n\n**Learning Objectives:**\nBy completing this project, you will:\n- Apply all testing concepts from Module 10\n- Build a fully tested production-ready app\n- Set up complete CI/CD pipeline\n- Implement best practices for maintainable tests\n- Understand when to use each type of test\n- Create a portfolio project demonstrating testing expertise\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 1: Project Requirements",
              "content": "\n### Functional Requirements\n\n**TaskMaster Pro** should allow users to:\n\n1. **Task Management**\n   - Create tasks with title, description, due date\n   - Mark tasks as complete/incomplete\n   - Delete tasks\n   - Edit existing tasks\n\n2. **Task Organization**\n   - Filter tasks (All, Active, Completed)\n   - Sort tasks (by date, by priority, by title)\n   - Search tasks by title\n\n3. **Data Persistence**\n   - Save tasks locally using Hive\n   - Load tasks on app startup\n   - Maintain state across app restarts\n\n4. **Statistics**\n   - Show total tasks count\n   - Show completed tasks percentage\n   - Show overdue tasks count\n\n### Testing Requirements\n\n**You must implement:**\n\n1. **Unit Tests** (70% of total tests)\n   - Task model validation\n   - Date utilities\n   - Filtering and sorting logic\n   - Statistics calculations\n   - Repository operations\n\n2. **Widget Tests** (20% of total tests)\n   - Task list widget\n   - Task item widget\n   - Filter buttons\n   - Add task form\n   - Statistics widget\n\n3. **Integration Tests** (10% of total tests)\n   - Complete task creation flow\n   - Complete task editing flow\n   - Filter and search flow\n   - Delete task flow\n\n4. **Quality Requirements**\n   - Minimum 80% code coverage\n   - All tests must pass\n   - Linting with no warnings\n   - Formatted code (dart format)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Section 2: Project Setup",
              "content": "\n### Step 1: Create Flutter Project\n\n\n### Step 2: Add Dependencies\n\n\nRun:\n\n### Step 3: Create Project Structure\n\n\n",
              "code": "task_master_pro/\n‚îú‚îÄ‚îÄ lib/\n‚îÇ   ‚îú‚îÄ‚îÄ main.dart\n‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task.g.dart (generated)\n‚îÇ   ‚îú‚îÄ‚îÄ repositories/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task_repository.dart\n‚îÇ   ‚îú‚îÄ‚îÄ bloc/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_bloc.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_event.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task_state.dart\n‚îÇ   ‚îú‚îÄ‚îÄ screens/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ home_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ add_edit_task_screen.dart\n‚îÇ   ‚îú‚îÄ‚îÄ widgets/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_list.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_item.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ filter_buttons.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ statistics_widget.dart\n‚îÇ   ‚îî‚îÄ‚îÄ utils/\n‚îÇ       ‚îî‚îÄ‚îÄ date_utils.dart\n‚îú‚îÄ‚îÄ test/\n‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task_test.dart\n‚îÇ   ‚îú‚îÄ‚îÄ repositories/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task_repository_test.dart\n‚îÇ   ‚îú‚îÄ‚îÄ bloc/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task_bloc_test.dart\n‚îÇ   ‚îú‚îÄ‚îÄ widgets/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_list_test.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_item_test.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ filter_buttons_test.dart\n‚îÇ   ‚îî‚îÄ‚îÄ utils/\n‚îÇ       ‚îî‚îÄ‚îÄ date_utils_test.dart\n‚îú‚îÄ‚îÄ integration_test/\n‚îÇ   ‚îú‚îÄ‚îÄ app_test.dart\n‚îÇ   ‚îî‚îÄ‚îÄ task_flow_test.dart\n‚îú‚îÄ‚îÄ scripts/\n‚îÇ   ‚îú‚îÄ‚îÄ coverage.sh\n‚îÇ   ‚îî‚îÄ‚îÄ run_all_tests.sh\n‚îî‚îÄ‚îÄ .github/\n    ‚îî‚îÄ‚îÄ workflows/\n        ‚îú‚îÄ‚îÄ ci.yml\n        ‚îî‚îÄ‚îÄ integration.yml",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 3: Implementation - Models and Tests",
              "content": "\n### Task Model\n\n\n### Unit Tests for Task Model\n\n\n**Run tests:**\n\n**Expected output:**\n\n",
              "code": "00:02 +22: All tests passed!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 4: Repository and Tests",
              "content": "\n### Task Repository\n\n\n### Unit Tests for Repository (with Mocking)\n\n\n",
              "code": "// test/repositories/task_repository_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:task_master_pro/models/task.dart';\nimport 'package:task_master_pro/repositories/task_repository.dart';\nimport 'package:hive_flutter/hive_flutter.dart';\n\nvoid main() {\n  group('HiveTaskRepository', () {\n    late HiveTaskRepository repository;\n\n    setUpAll(() async {\n      // Initialize Hive for testing (in-memory)\n      await Hive.initFlutter();\n      Hive.registerAdapter(TaskAdapter());\n    });\n\n    setUp(() async {\n      repository = HiveTaskRepository();\n      await repository.init();\n    });\n\n    tearDown() async {\n      // Clear all tasks after each test\n      final box = await Hive.openBox<Task>(HiveTaskRepository.boxName);\n      await box.clear();\n    });\n\n    tearDownAll() async {\n      await Hive.close();\n    });\n\n    test('getTasks returns empty list initially', () async {\n      // Act\n      final tasks = await repository.getTasks();\n\n      // Assert\n      expect(tasks, isEmpty);\n    });\n\n    test('addTask adds task to repository', () async {\n      // Arrange\n      final task = Task.create(\n        title: 'Test Task',\n        description: 'Test Desc',\n        dueDate: DateTime.now(),\n      );\n\n      // Act\n      await repository.addTask(task);\n      final tasks = await repository.getTasks();\n\n      // Assert\n      expect(tasks.length, 1);\n      expect(tasks.first.id, task.id);\n      expect(tasks.first.title, task.title);\n    });\n\n    test('updateTask updates existing task', () async {\n      // Arrange\n      final task = Task.create(\n        title: 'Original',\n        description: 'Desc',\n        dueDate: DateTime.now(),\n      );\n      await repository.addTask(task);\n\n      // Act\n      final updated = task.copyWith(title: 'Updated');\n      await repository.updateTask(updated);\n      final tasks = await repository.getTasks();\n\n      // Assert\n      expect(tasks.length, 1);\n      expect(tasks.first.title, 'Updated');\n    });\n\n    test('deleteTask removes task from repository', () async {\n      // Arrange\n      final task = Task.create(\n        title: 'Task to Delete',\n        description: 'Desc',\n        dueDate: DateTime.now(),\n      );\n      await repository.addTask(task);\n\n      // Act\n      await repository.deleteTask(task.id);\n      final tasks = await repository.getTasks();\n\n      // Assert\n      expect(tasks, isEmpty);\n    });\n\n    test('deleteAllCompletedTasks removes only completed tasks', () async {\n      // Arrange\n      final task1 = Task.create(\n        title: 'Task 1',\n        description: 'Desc',\n        dueDate: DateTime.now(),\n      ).copyWith(isCompleted: true);\n\n      final task2 = Task.create(\n        title: 'Task 2',\n        description: 'Desc',\n        dueDate: DateTime.now(),\n      ); // Not completed\n\n      final task3 = Task.create(\n        title: 'Task 3',\n        description: 'Desc',\n        dueDate: DateTime.now(),\n      ).copyWith(isCompleted: true);\n\n      await repository.addTask(task1);\n      await repository.addTask(task2);\n      await repository.addTask(task3);\n\n      // Act\n      await repository.deleteAllCompletedTasks();\n      final tasks = await repository.getTasks();\n\n      // Assert\n      expect(tasks.length, 1);\n      expect(tasks.first.id, task2.id); // Only incomplete task remains\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 5: Widget Tests",
              "content": "\n### Task Item Widget\n\n\n### Widget Test for Task Item\n\n\n",
              "code": "// test/widgets/task_item_test.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:task_master_pro/models/task.dart';\nimport 'package:task_master_pro/widgets/task_item.dart';\n\nvoid main() {\n  group('TaskItem Widget', () {\n    late Task testTask;\n\n    setUp(() {\n      testTask = Task(\n        id: '123',\n        title: 'Test Task',\n        description: 'Test Description',\n        dueDate: DateTime(2025, 12, 31),\n      );\n    });\n\n    Widget createWidgetUnderTest(Task task) {\n      return MaterialApp(\n        home: Scaffold(\n          body: TaskItem(\n            task: task,\n            onTap: () {},\n            onToggleComplete: (_) {},\n            onDelete: () {},\n          ),\n        ),\n      );\n    }\n\n    testWidgets('displays task title and description', (tester) async {\n      // Act\n      await tester.pumpWidget(createWidgetUnderTest(testTask));\n\n      // Assert\n      expect(find.text('Test Task'), findsOneWidget);\n      expect(find.text('Test Description'), findsOneWidget);\n    });\n\n    testWidgets('displays formatted due date', (tester) async {\n      // Act\n      await tester.pumpWidget(createWidgetUnderTest(testTask));\n\n      // Assert\n      expect(find.textContaining('Due: Dec 31, 2025'), findsOneWidget);\n    });\n\n    testWidgets('checkbox reflects completion status', (tester) async {\n      // Arrange\n      final completedTask = testTask.copyWith(isCompleted: true);\n\n      // Act\n      await tester.pumpWidget(createWidgetUnderTest(completedTask));\n      final checkbox = tester.widget<Checkbox>(\n        find.byKey(Key('checkbox_${completedTask.id}')),\n      );\n\n      // Assert\n      expect(checkbox.value, true);\n    });\n\n    testWidgets('completed task has strikethrough text', (tester) async {\n      // Arrange\n      final completedTask = testTask.copyWith(isCompleted: true);\n\n      // Act\n      await tester.pumpWidget(createWidgetUnderTest(completedTask));\n      final textWidget = tester.widget<Text>(find.text('Test Task'));\n\n      // Assert\n      expect(\n        textWidget.style?.decoration,\n        TextDecoration.lineThrough,\n      );\n    });\n\n    testWidgets('tapping checkbox calls onToggleComplete', (tester) async {\n      // Arrange\n      bool toggleCalled = false;\n      bool? toggledValue;\n\n      final widget = MaterialApp(\n        home: Scaffold(\n          body: TaskItem(\n            task: testTask,\n            onTap: () {},\n            onToggleComplete: (value) {\n              toggleCalled = true;\n              toggledValue = value;\n            },\n            onDelete: () {},\n          ),\n        ),\n      );\n\n      // Act\n      await tester.pumpWidget(widget);\n      await tester.tap(find.byKey(Key('checkbox_${testTask.id}')));\n\n      // Assert\n      expect(toggleCalled, true);\n      expect(toggledValue, true); // Toggled from false to true\n    });\n\n    testWidgets('tapping delete button calls onDelete', (tester) async {\n      // Arrange\n      bool deleteCalled = false;\n\n      final widget = MaterialApp(\n        home: Scaffold(\n          body: TaskItem(\n            task: testTask,\n            onTap: () {},\n            onToggleComplete: (_) {},\n            onDelete: () {\n              deleteCalled = true;\n            },\n          ),\n        ),\n      );\n\n      // Act\n      await tester.pumpWidget(widget);\n      await tester.tap(find.byKey(Key('delete_${testTask.id}')));\n\n      // Assert\n      expect(deleteCalled, true);\n    });\n\n    testWidgets('overdue task shows due date in red', (tester) async {\n      // Arrange\n      final overdueTask = testTask.copyWith(\n        dueDate: DateTime.now().subtract(const Duration(days: 1)),\n      );\n\n      // Act\n      await tester.pumpWidget(createWidgetUnderTest(overdueTask));\n\n      // Find the due date text\n      final dueDateFinder = find.textContaining('Due:');\n      final textWidget = tester.widget<Text>(dueDateFinder);\n\n      // Assert\n      expect(textWidget.style?.color, Colors.red);\n      expect(textWidget.style?.fontWeight, FontWeight.bold);\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Section 7: CI/CD Setup",
              "content": "\n### GitHub Actions Workflow\n\nCreate `.github/workflows/ci.yml`:\n\n\n",
              "code": "name: TaskMaster Pro CI\n\non:\n  pull_request:\n    branches: [ main ]\n  push:\n    branches: [ main ]\n\njobs:\n  test:\n    name: Test and Coverage\n    runs-on: ubuntu-latest\n    timeout-minutes: 20\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.24.0'\n          channel: 'stable'\n          cache: true\n\n      - name: Install dependencies\n        run: flutter pub get\n\n      - name: Generate Hive adapters\n        run: flutter pub run build_runner build --delete-conflicting-outputs\n\n      - name: Verify code formatting\n        run: dart format --set-exit-if-changed .\n\n      - name: Analyze code\n        run: flutter analyze --fatal-infos\n\n      - name: Run unit and widget tests with coverage\n        run: flutter test --coverage --no-test-assets\n\n      - name: Install lcov\n        run: sudo apt-get install -y lcov\n\n      - name: Clean coverage data\n        run: |\n          lcov --remove coverage/lcov.info \\\n            '*.g.dart' \\\n            '*.freezed.dart' \\\n            -o coverage/lcov_cleaned.info\n\n      - name: Check coverage threshold (80%)\n        run: |\n          COVERAGE=$(lcov --summary coverage/lcov_cleaned.info 2>&1 | \\\n            grep 'lines......:' | \\\n            grep -oP '\\d+\\.\\d+(?=%)')\n\n          echo \"Coverage: ${COVERAGE}%\"\n\n          if (( $(echo \"$COVERAGE < 80\" | bc -l) )); then\n            echo \"‚ùå Coverage ${COVERAGE}% is below 80% threshold\"\n            exit 1\n          else\n            echo \"‚úÖ Coverage meets 80% threshold\"\n          fi\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          files: ./coverage/lcov_cleaned.info\n          fail_ci_if_error: false\n\n      - name: Generate HTML coverage report\n        run: |\n          genhtml coverage/lcov_cleaned.info -o coverage/html\n\n      - name: Upload coverage HTML as artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: coverage-report\n          path: coverage/html/\n\n      - name: Build APK\n        run: flutter build apk --debug",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Section 8: Running and Verifying Tests",
              "content": "\n### Script: scripts/run_all_tests.sh\n\n\nMake it executable:\n\nRun it:\n\n",
              "code": "./scripts/run_all_tests.sh",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Section 9: Evaluation Criteria",
              "content": "\n### Grading Rubric (100 points)\n\n**Implementation (40 points)**\n- ‚úÖ All functional requirements met (20 pts)\n- ‚úÖ Code follows Flutter best practices (10 pts)\n- ‚úÖ No linting warnings (5 pts)\n- ‚úÖ Code properly formatted (5 pts)\n\n**Unit Tests (25 points)**\n- ‚úÖ Task model fully tested (10 pts)\n- ‚úÖ Repository fully tested (10 pts)\n- ‚úÖ Tests follow AAA pattern (5 pts)\n\n**Widget Tests (15 points)**\n- ‚úÖ TaskItem widget fully tested (8 pts)\n- ‚úÖ Filter buttons tested (7 pts)\n\n**Integration Tests (10 points)**\n- ‚úÖ Complete task lifecycle tested (5 pts)\n- ‚úÖ Filter flow tested (5 pts)\n\n**Coverage (10 points)**\n- ‚úÖ 80%+ coverage (10 pts)\n- ‚úÖ 70-79% coverage (7 pts)\n- ‚úÖ 60-69% coverage (5 pts)\n- ‚ùå <60% coverage (0 pts)\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nIn this mini-project, you built:\n\n‚úÖ **Production-ready task management app** with full CRUD operations\n‚úÖ **Comprehensive test suite** covering unit, widget, and integration tests\n‚úÖ **80%+ test coverage** with automated coverage reporting\n‚úÖ **CI/CD pipeline** with GitHub Actions\n‚úÖ **Quality gates** enforcing code standards\n‚úÖ **Automated testing** on every push and PR\n‚úÖ **Best practices** demonstrated throughout\n\n**Key Takeaways:**\n\n1. **Test Pyramid**: 70% unit tests, 20% widget tests, 10% integration tests\n2. **TDD mindset**: Write tests as you develop, not after\n3. **Quality gates**: Prevent bad code from merging\n4. **Coverage ‚â† Quality**: 80% coverage of meaningful code beats 100% of trivial code\n5. **CI/CD**: Automate everything to catch issues early\n\n**Portfolio Value:**\n\nThis project demonstrates professional-level testing practices employers look for:\n- Comprehensive test coverage\n- Clean, maintainable test code\n- CI/CD pipeline setup\n- Quality-first development approach\n\n**Congratulations!** You've completed Module 10 and built a fully tested, production-ready Flutter application with industry-standard testing practices. üéâ\n\n"
            },
            {
              "type": "THEORY",
              "title": "What's Next?",
              "content": "\nIn **Module 11: Deployment & Publishing**, you'll learn how to prepare this app for release, build signed APKs and IPAs, and publish it to the Google Play Store and Apple App Store!\n\n"
            }
          ],
          "challenges": []
        }
      ]
    },
    {
      "id": "module-11",
      "title": "Module 11: Flutter Development",
      "description": "Learn Flutter development - Module 11",
      "difficulty": "advanced",
      "estimatedHours": 2,
      "lessons": [
        {
          "id": "11.1",
          "title": "iOS",
          "moduleId": "module-11",
          "order": 1,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Release checklist for production apps\n- App icons and splash screens\n- Version numbers and build numbers\n- App signing and certificates\n- Release vs debug builds\n- Performance optimization for production\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: Why Preparation Matters",
              "content": "\n### Real-World Analogy\nReleasing an app is like **launching a new product**:\n- ‚úÖ Quality control (testing)\n- ‚úÖ Packaging (build configuration)\n- ‚úÖ Branding (icons, splash screens)\n- ‚úÖ Documentation (store listings)\n- ‚úÖ Legal (privacy policy, terms)\n\nJust like you wouldn't ship a product in a plain brown box, you shouldn't release an app without proper preparation!\n\n### Why This Matters\nPoor preparation leads to:\n- ‚ùå App store rejections\n- ‚ùå Bad first impressions\n- ‚ùå Security vulnerabilities\n- ‚ùå Poor performance\n- ‚ùå Legal issues\n\n**73% of apps** get rejected on first submission! Proper preparation increases approval chances.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Release Checklist",
              "content": "\n### ‚úÖ Pre-Release Checklist\n\n**1. Testing**\n- [ ] All features work correctly\n- [ ] Tested on multiple devices (small & large screens)\n- [ ] Tested on different OS versions\n- [ ] No crashes or ANRs (Android) / crashes (iOS)\n- [ ] Performance is acceptable (no lag)\n- [ ] Battery usage is reasonable\n\n**2. Content**\n- [ ] App name is finalized\n- [ ] App description is written\n- [ ] Screenshots prepared (all required sizes)\n- [ ] App icon designed (all required sizes)\n- [ ] Splash screen configured\n- [ ] Privacy policy published\n- [ ] Terms of service (if applicable)\n\n**3. Legal & Compliance**\n- [ ] Privacy policy covers all data collection\n- [ ] Permissions are justified\n- [ ] COPPA compliance (if targeting children)\n- [ ] GDPR compliance (if serving EU users)\n- [ ] Age rating determined\n\n**4. Technical**\n- [ ] Version number set correctly\n- [ ] Build number incremented\n- [ ] API keys secured (not in code)\n- [ ] Error logging configured\n- [ ] Analytics integrated\n- [ ] App signing configured\n\n**5. Store Listings**\n- [ ] Google Play Console account active\n- [ ] Apple Developer account active (if iOS)\n- [ ] App created in console\n- [ ] Store listing filled out\n- [ ] Pricing and countries selected\n\n"
            },
            {
              "type": "THEORY",
              "title": "App Icons",
              "content": "\n### Icon Requirements\n\n**Android (Play Store):**\n- **512√ó512px**: High-res icon (PNG, 32-bit, max 1024 KB)\n- **Adaptive icon**: Foreground + background layers\n- **Various sizes**: 48dp, 72dp, 96dp, 144dp, 192dp\n\n**iOS (App Store):**\n- **1024√ó1024px**: App Store icon (PNG, no transparency, no rounded corners)\n- **Various sizes**: @1x, @2x, @3x for different devices\n\n### Creating App Icons\n\n**Using flutter_launcher_icons Package:**\n\n1. **Install:**\n\n2. **Configure** (pubspec.yaml):\n\n3. **Generate icons:**\n\n**Best Practices:**\n- ‚úÖ Use simple, recognizable designs\n- ‚úÖ Avoid text (hard to read at small sizes)\n- ‚úÖ Test on various backgrounds (dark/light)\n- ‚úÖ Follow platform guidelines (Material Design / Human Interface Guidelines)\n- ‚ùå Don't use screenshots as icons\n- ‚ùå Don't violate trademarks\n\n",
              "code": "flutter pub get\nflutter pub run flutter_launcher_icons",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Splash Screens",
              "content": "\n### Native Splash Screens\n\n**Using flutter_native_splash Package:**\n\n1. **Install:**\n\n2. **Configure** (pubspec.yaml):\n\n3. **Generate:**\n\n**Platform-Specific Notes:**\n- **Android 12+**: Uses new splash screen API (animated)\n- **iOS**: Static launch screen (no animations allowed)\n\n",
              "code": "flutter pub get\nflutter pub run flutter_native_splash:create",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Version Numbers",
              "content": "\n### Semantic Versioning\n\nFormat: `MAJOR.MINOR.PATCH+BUILD`\n\n**Example:** `1.2.3+45`\n- **1**: Major version (breaking changes)\n- **2**: Minor version (new features, backward compatible)\n- **3**: Patch version (bug fixes)\n- **45**: Build number (internal tracking)\n\n### Setting Versions\n\n**pubspec.yaml:**\n\n**When to Increment:**\n- **Major (1.x.x)**: Complete rewrite, breaking changes\n- **Minor (x.1.x)**: New features added\n- **Patch (x.x.1)**: Bug fixes only\n- **Build (x.x.x+1)**: Every build/release\n\n**Examples:**\n- `1.0.0+1`: Initial release\n- `1.0.1+2`: Bug fix\n- `1.1.0+3`: Added new feature\n- `2.0.0+4`: Major overhaul\n\n",
              "code": "version: 1.2.3+45",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Release vs Debug Builds",
              "content": "\n### Debug Build (Development)\n\n**Characteristics:**\n- Includes debugging info\n- Larger file size (~20-40 MB larger)\n- Hot reload enabled\n- Performance overhead\n- Console logging enabled\n\n### Release Build (Production)\n\n**Characteristics:**\n- Optimized code (tree-shaking, minification)\n- Smaller file size\n- No debugging symbols\n- Maximum performance\n- Logging disabled (unless explicitly configured)\n\n**Performance Comparison:**\n| Metric | Debug | Release |\n|--------|-------|---------|\n| File Size | ~40 MB | ~15 MB |\n| Startup Time | 3-5 sec | 1-2 sec |\n| Frame Rate | 50-55 FPS | 60 FPS |\n| Memory Usage | Higher | Lower |\n\n",
              "code": "flutter build apk --release\nflutter build appbundle --release  # Preferred\n\nflutter build ioS --release",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "App Signing",
              "content": "\n### Android App Signing\n\n**1. Create a Keystore:**\n\n**Important:** Save the keystore file and password securely! If lost, you cannot update your app!\n\n**2. Reference Keystore** (android/key.properties):\n\n**3. Configure Gradle** (android/app/build.gradle):\n\n**4. Add to .gitignore:**\n\n### iOS Code Signing\n\niOS signing is handled through Xcode:\n\n1. **Automatic Signing** (recommended for beginners):\n   - Open `ios/Runner.xcworkspace` in Xcode\n   - Select \"Runner\" project\n   - General ‚Üí Signing ‚Üí Enable \"Automatically manage signing\"\n   - Select your Apple Developer Team\n\n2. **Manual Signing** (advanced):\n   - Create App ID in Apple Developer Portal\n   - Create Distribution Certificate\n   - Create Provisioning Profile\n   - Configure in Xcode\n\n",
              "code": "key.properties\n*.jks\n*.keystore",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Build Configuration",
              "content": "\n### Android Configuration\n\n**android/app/build.gradle:**\n\n### iOS Configuration\n\n**ios/Runner/Info.plist:**\n\n",
              "code": "<dict>\n    <!-- App Name -->\n    <key>CFBundleName</key>\n    <string>$(PRODUCT_NAME)</string>\n\n    <!-- Display Name (shown on home screen) -->\n    <key>CFBundleDisplayName</key>\n    <string>My App</string>\n\n    <!-- Bundle Identifier -->\n    <key>CFBundleIdentifier</key>\n    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>\n\n    <!-- Version -->\n    <key>CFBundleShortVersionString</key>\n    <string>$(FLUTTER_BUILD_NAME)</string>\n\n    <!-- Build Number -->\n    <key>CFBundleVersion</key>\n    <string>$(FLUTTER_BUILD_NUMBER)</string>\n\n    <!-- Minimum iOS Version -->\n    <key>MinimumOSVersion</key>\n    <string>12.0</string>\n\n    <!-- Supported Devices -->\n    <key>UIRequiredDeviceCapabilities</key>\n    <array>\n        <string>arm64</string>\n    </array>\n\n    <!-- Orientations -->\n    <key>UISupportedInterfaceOrientations</key>\n    <array>\n        <string>UIInterfaceOrientationPortrait</string>\n        <string>UIInterfaceOrientationLandscapeLeft</string>\n        <string>UIInterfaceOrientationLandscapeRight</string>\n    </array>\n</dict>",
              "language": "xml"
            },
            {
              "type": "THEORY",
              "title": "Environment Variables & Secrets",
              "content": "\n### Managing API Keys Securely\n\n**‚ùå DON'T:**\n\n**‚úÖ DO:**\n\n**.env file:**\n\n**.gitignore:**\n\n### Build Flavors (Dev vs Prod)\n\nCreate separate configurations for development and production.\n\n",
              "code": ".env\n.env.local\n.env.production",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Performance Optimization",
              "content": "\n### Before Release\n\n1. **Profile the App:**\n\n2. **Analyze Build Size:**\n\n3. **Optimize Images:**\n   - Use WebP format\n   - Compress PNG/JPEG (TinyPNG, ImageOptim)\n   - Use appropriate resolutions (@1x, @2x, @3x)\n\n4. **Enable Obfuscation:**\n\n5. **Remove Unused Resources:**\n   - Delete unused assets\n   - Remove unused packages\n\n",
              "code": "flutter build apk --obfuscate --split-debug-info=build/app/outputs/symbols",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the difference between version number and build number?\nA) They're the same thing\nB) Version is user-facing; build is internal tracking\nC) Version is for Android; build is for iOS\nD) Build number must always be 1\n\n**Question 2:** Why should you never commit your keystore file to Git?\nA) It's too large\nB) If stolen, attackers can impersonate your app\nC) It will break the build\nD) Google prohibits it\n\n**Question 3:** What does \"minifyEnabled true\" do?\nA) Makes the app smaller by removing unused code\nB) Minimizes battery usage\nC) Reduces network calls\nD) Compresses images\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Prepare Your App for Release",
              "content": "\nTake any Flutter app you've built and:\n1. Set version to 1.0.0+1\n2. Create app icon (1024x1024)\n3. Generate launcher icons with flutter_launcher_icons\n4. Add splash screen\n5. Create keystore for Android\n6. Build release APK\n7. Check file size (should be < 20 MB)\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've learned how to prepare a Flutter app for production! Here's what we covered:\n\n- **Release Checklist**: Testing, legal, technical requirements\n- **App Icons**: Generating icons for all platforms\n- **Splash Screens**: Native splash configuration\n- **Version Numbers**: Semantic versioning (MAJOR.MINOR.PATCH+BUILD)\n- **App Signing**: Keystore creation and configuration\n- **Build Configuration**: Release vs debug builds\n- **Secrets Management**: Protecting API keys\n- **Performance**: Optimization techniques\n\nNext lesson: Publishing to Google Play Store!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) Version is user-facing; build is internal tracking\n\nVersion number (1.2.3) is what users see in the app store. Build number (+45) is for internal tracking and must increment with each submission, even if the version doesn't change.\n\n**Answer 2:** B) If stolen, attackers can impersonate your app\n\nYour keystore is how you prove ownership of your app. If someone steals it and your passwords, they can sign updates pretending to be you. Always keep it secure and never commit to version control!\n\n**Answer 3:** A) Makes the app smaller by removing unused code\n\nMinification (minifyEnabled true) removes unused code and shortens identifiers, reducing the final APK/IPA size. Combined with shrinkResources, it can reduce app size by 30-50%.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "11.2",
          "title": "iOS",
          "moduleId": "module-11",
          "order": 2,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What You'll Learn",
              "content": "- Publishing to Google Play Store\n- Publishing to Apple App Store\n- Store listing optimization (ASO)\n- Handling app reviews\n- Post-launch monitoring\n- Updating your published app\n\n"
            },
            {
              "type": "THEORY",
              "title": "Concept First: The App Store Ecosystem",
              "content": "\n### Real-World Analogy\nPublishing to app stores is like **opening a store in a shopping mall**:\n- **Google Play / App Store** = The mall\n- **Your app** = Your store\n- **Store listing** = Your storefront display\n- **Reviews** = Customer feedback\n- **Updates** = Refreshing your inventory\n\nThe mall (store) has rules you must follow, and they control who gets in!\n\n### Why This Matters\n**3.5 million** apps on Google Play and **1.8 million** on App Store compete for attention. A good launch strategy is crucial:\n\n- ‚úÖ Clear store listing = More downloads\n- ‚úÖ Good first impression = Better ratings\n- ‚úÖ App Store Optimization (ASO) = Higher visibility\n- ‚ùå Poor listing = Lost in the crowd\n\n"
            },
            {
              "type": "THEORY",
              "title": "Part 1: Google Play Store",
              "content": "\n### Prerequisites\n\n1. **Google Play Console Account**\n   - Visit [play.google.com/console](https://play.google.com/console)\n   - One-time fee: $25 USD\n   - Requires Google account\n\n2. **Developer Information**\n   - Developer name\n   - Email address\n   - Privacy policy URL (required!)\n   - Physical address (will be public)\n\n3. **App Build Ready**\n   - Release APK or AAB (recommended)\n   - Signed with upload key\n   - Tested thoroughly\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Step-by-Step: Google Play Store\n\n#### Step 1: Create App in Console\n\n1. Go to Play Console ‚Üí **All apps** ‚Üí **Create app**\n2. Fill in details:\n   - **App name** (max 50 characters)\n   - **Default language**\n   - **App or game**\n   - **Free or paid**\n   - Accept declarations\n\n#### Step 2: Store Listing\n\n**Main store listing:**\n\n**App icon:**\n- 512 x 512 px\n- 32-bit PNG (with alpha)\n- Max 1 MB\n\n**Screenshots (Required):**\n- Minimum 2 screenshots\n- JPEG or 24-bit PNG (no alpha)\n- 16:9 or 9:16 aspect ratio\n- Minimum dimension: 320 px\n- Maximum dimension: 3840 px\n\n**Example screenshot requirements:**\n- Phone: 1080 x 1920 px (at least 2)\n- 7-inch tablet: 1200 x 1920 px (recommended)\n- 10-inch tablet: 1920 x 1200 px (recommended)\n\n**Feature graphic (Required):**\n- 1024 x 500 px\n- JPEG or 24-bit PNG (no alpha)\n\n#### Step 3: Content Rating\n\n1. Start questionnaire\n2. Answer questions honestly:\n   - Violence\n   - Sexual content\n   - Language\n   - Controlled substances\n   - Gambling\n\n3. Get rating (Everyone, Teen, Mature, etc.)\n\n#### Step 4: Select App Categories\n\n**Primary category:**\n- Health & Fitness\n- Productivity\n- Social\n- etc.\n\n**Tags (up to 5):**\n- workout tracker\n- fitness\n- calorie counter\n- exercise\n- health\n\n#### Step 5: Contact Details & Privacy Policy\n\n**Developer contact information:**\n- Email (public)\n- Phone (optional)\n- Website (optional)\n\n**Privacy policy:**\n- Required if app collects user data\n- Must be hosted on public URL\n- Must explain data collection clearly\n\n**Example privacy policy sections:**\n\n#### Step 6: Set Up Pricing & Distribution\n\n**Pricing:**\n- Free or Paid\n- In-app purchases (if applicable)\n- Subscriptions (if applicable)\n\n**Countries:**\n- Select countries to distribute\n- Or \"All countries\"\n\n**Content guidelines compliance:**\n- Confirm app meets Google Play policies\n\n#### Step 7: Production Release\n\n**Option A: Internal Testing (Recommended first)**\n1. Production ‚Üí Internal testing\n2. Create release\n3. Upload AAB file\n4. Add release notes\n5. Review and roll out\n6. Test with team (up to 100 testers)\n\n**Option B: Closed Testing**\n1. Production ‚Üí Closed testing\n2. More rigorous testing\n3. Up to 100,000 testers\n4. Required for individual developers (2023+ policy)\n\n**Option C: Production Release**\n1. Production ‚Üí Production\n2. Upload AAB:\n3. Release notes:\n\n4. Review and roll out\n5. Wait for review (usually 1-3 days)\n\n#### Step 8: App Review\n\n**What Google checks:**\n- Policy compliance\n- Content rating accuracy\n- Privacy policy completeness\n- Functionality (automated testing)\n- Security vulnerabilities\n\n**Review time:**\n- Usually: 1-3 days\n- Sometimes: Up to 7 days\n- Expedited: Not available\n\n**Common rejection reasons:**\n1. Broken functionality or crashes\n2. Misleading content/screenshots\n3. Incomplete privacy policy\n4. Violation of Play policies\n5. Inappropriate content rating\n\n",
              "code": "Version 1.0.0\n‚Ä¢ Initial release\n‚Ä¢ GPS workout tracking\n‚Ä¢ Calorie counting\n‚Ä¢ Progress charts\n‚Ä¢ Social sharing\n\nThank you for downloading Fitness Tracker Pro!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Part 2: Apple App Store",
              "content": "\n### Prerequisites\n\n1. **Apple Developer Program**\n   - Visit [developer.apple.com](https://developer.apple.com)\n   - Cost: $99 USD/year\n   - Requires Apple ID\n\n2. **Mac with Xcode**\n   - macOS required for iOS builds\n   - Xcode 14+ (free from App Store)\n\n3. **App Store Connect Account**\n   - Automatically created with Developer Program\n\n"
            },
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "### Step-by-Step: Apple App Store\n\n#### Step 1: Register App Identifier\n\n1. Go to [developer.apple.com](https://developer.apple.com)\n2. Certificates, IDs & Profiles ‚Üí Identifiers\n3. Click \"+\" to create new App ID\n4. Select \"App IDs\" ‚Üí Continue\n5. Select \"App\" ‚Üí Continue\n6. Fill in:\n   - **Description**: Fitness Tracker Pro\n   - **Bundle ID**: com.yourcompany.fitnesstracke (must match your app)\n   - **Capabilities**: Select required (e.g., Push Notifications, HealthKit)\n7. Register\n\n#### Step 2: Create App in App Store Connect\n\n1. Go to [appstoreconnect.apple.com](https://appstoreconnect.apple.com)\n2. My Apps ‚Üí \"+\" ‚Üí New App\n3. Fill in:\n   - **Platform**: iOS\n   - **Name**: Fitness Tracker Pro\n   - **Primary Language**: English\n   - **Bundle ID**: Select from dropdown (created in Step 1)\n   - **SKU**: Unique identifier (e.g., fitnesstrackerproj_001)\n   - **User Access**: Full Access\n\n#### Step 3: App Information\n\n**Category:**\n- Primary: Health & Fitness\n- Secondary: Lifestyle (optional)\n\n**Age Rating:**\nAnswer questionnaire (similar to Google Play)\n\n**Content Rights:**\n- [ ] Contains third-party content\n- License agreement (optional)\n\n#### Step 4: Pricing and Availability\n\n**Price:**\n- Free or select price tier\n- $0.99, $1.99, $2.99, etc.\n\n**Availability:**\n- Specific territories or all\n- Pre-order option\n\n#### Step 5: App Store Listing\n\n**App Store Information:**\n\n**Name** (30 characters):\n\n**Subtitle** (30 characters):\n\n**Description** (4000 characters):\n\n**Keywords** (100 characters):\n\n**Support URL:**\n\n**Marketing URL (optional):**\n\n**Privacy Policy URL (required):**\n\n#### Step 6: Screenshots\n\n**iPhone Screenshots (Required):**\n- 6.7\" display (iPhone 14 Pro Max): 1290 x 2796 px\n- 6.5\" display (iPhone 14 Plus): 1284 x 2778 px\n- 5.5\" display (iPhone 8 Plus): 1242 x 2208 px\n\n**Minimum:** 3 screenshots\n**Maximum:** 10 screenshots\n\n**iPad Screenshots (If supporting iPad):**\n- 12.9\" display: 2048 x 2732 px\n- 11\" display: 1668 x 2388 px\n\n**App Previews (Optional but recommended):**\n- Video preview (15-30 seconds)\n- Show key features\n- Portrait or landscape\n\n#### Step 7: Build and Upload\n\n**Build for iOS:**\n\n**Upload via Xcode:**\n1. Open `build/ios/archive/Runner.xcarchive`\n2. Distribute App ‚Üí App Store Connect\n3. Upload\n4. Wait for processing (10-30 minutes)\n\n**Or use Application Loader:**\n- Older method, deprecated\n\n#### Step 8: Submit for Review\n\n1. Select build from dropdown\n2. Fill in **Version Information**:\n   - Version number: 1.0.0\n   - Copyright: ¬© 2025 Your Company\n   - Build number: 1\n\n3. **Export Compliance:**\n   - Does your app use encryption? (Usually \"No\")\n\n4. **Content Rights:**\n   - Do you hold rights to content?\n\n5. **Advertising Identifier:**\n   - Do you use IDFA? (Usually \"No\" unless using ads)\n\n6. **App Review Information:**\n   - First name, Last name\n   - Phone number\n   - Email\n   - Demo account (if app requires login)\n   - Notes for reviewer\n\n7. **Version Release:**\n   - Automatically release after approval\n   - Or manually release\n\n8. Submit for Review\n\n#### Step 9: App Review Process\n\n**Review time:**\n- Usually: 24-48 hours\n- Sometimes: Up to 5 days\n\n**Status progression:**\n1. Waiting for Review\n2. In Review\n3. Pending Developer Release (if manual)\n4. Ready for Sale\n\n**Common rejection reasons:**\n1. **Guideline 2.1**: App completeness (crashes, bugs)\n2. **Guideline 4.3**: Spam/duplicate apps\n3. **Guideline 5.1**: Privacy issues\n4. **Guideline 2.3.3**: Inaccurate metadata/screenshots\n5. **Guideline 5.1.1**: Data collection without permission\n\n**If rejected:**\n- Read rejection reason carefully\n- Fix the issues\n- Respond to reviewer with changes made\n- Resubmit\n\n",
              "code": "flutter build ipa --release",
              "language": "bash"
            },
            {
              "type": "THEORY",
              "title": "App Store Optimization (ASO)",
              "content": "\n### Keywords Strategy\n\n**Research:**\n- Use tools: App Annie, Sensor Tower, App Radar\n- Check competitor keywords\n- Find high-volume, low-competition terms\n\n**Optimization:**\n- Title: Include main keyword\n- Subtitle (iOS): Secondary keyword\n- Description: Natural use of keywords (3-5 times)\n- Google Play short description: Keyword-rich\n\n**Example for Fitness App:**\n\n### Screenshots Best Practices\n\n1. **Show, don't tell**: Real app screens, not just graphics\n2. **Key features first**: First 2-3 screenshots are most important\n3. **Add captions**: Explain what's shown\n4. **Use device frames**: Makes it look professional\n5. **Show progression**: Onboarding ‚Üí Features ‚Üí Results\n\n**Tools:**\n- Figma/Sketch for design\n- [screenshots.pro](https://screenshots.pro) for device frames\n- [AppLaunchpad](https://theapplaunchpad.com) for templates\n\n### Description Formula\n\n\n",
              "code": "Hook (1-2 sentences)\n‚Üì\nKey Features (bullet points)\n‚Üì\nBenefits (what user gains)\n‚Üì\nSocial Proof (users/ratings if available)\n‚Üì\nCall to Action",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Post-Launch Monitoring",
              "content": "\n### Metrics to Track\n\n1. **Downloads/Installs**\n   - Daily/weekly/monthly\n   - By country\n\n2. **Ratings & Reviews**\n   - Average rating\n   - Review count\n   - Sentiment analysis\n\n3. **Crashes & ANRs**\n   - Crash-free users %\n   - Most common crashes\n\n4. **User Retention**\n   - Day 1, 7, 30 retention\n   - Churn rate\n\n5. **Engagement**\n   - Daily active users (DAU)\n   - Session length\n   - Feature usage\n\n**Tools:**\n- Google Play Console (built-in)\n- App Store Connect (built-in)\n- Firebase Analytics\n- Crashlytics\n- Mixpanel/Amplitude\n\n### Responding to Reviews\n\n**Positive Reviews:**\n\n**Negative Reviews:**\n\n**Bug Reports:**\n\n",
              "code": "Thank you for reporting this! We've identified the issue and it will be fixed in the next update (1.1.0), coming next week. We appreciate your feedback!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Updating Your App",
              "content": "\n### When to Update\n\n- Bug fixes: As soon as possible\n- Minor features: Every 2-4 weeks\n- Major features: Every 2-3 months\n\n### Update Process\n\n**1. Increment Version:**\n\n**2. Build New Release:**\n\n**3. Upload to Stores:**\n- Google Play: Upload to Production\n- App Store: Upload via Xcode, submit for review\n\n**4. Write Release Notes:**\n\n**5. Roll Out Gradually:**\n- Google Play: Staged rollout (10% ‚Üí 50% ‚Üí 100%)\n- App Store: Phased release (automatic)\n\n",
              "code": "What's New in 1.0.1:\n‚Ä¢ Fixed crash on workout save\n‚Ä¢ Improved GPS accuracy\n‚Ä¢ Added dark mode support\n‚Ä¢ Performance improvements\n\nThanks for using Fitness Tracker Pro!",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Quiz",
              "content": "\n**Question 1:** What's the main difference between Google Play and App Store review times?\nA) They're the same\nB) Play Store is usually faster (1-3 days vs 1-2 days)\nC) App Store is usually faster (1-2 days vs 1-3 days)\nD) Both take weeks\n\n**Question 2:** Why is a privacy policy required?\nA) It's not required\nB) Legal requirement if you collect any user data\nC) Only for paid apps\nD) Only for apps with ads\n\n**Question 3:** What is ASO?\nA) App Store Optimization (improving visibility)\nB) App Security Operations\nC) Automated Store Operations\nD) Apple Store Only\n\n"
            },
            {
              "type": "THEORY",
              "title": "Exercise: Create a Store Listing",
              "content": "\nFor your Fitness Tracker app (or any app):\n1. Write an app name (30 chars)\n2. Write a short description (80 chars)\n3. Write a full description (200+ words)\n4. List 5-10 keywords\n5. Create a mockup of 3 screenshots\n6. Write release notes for version 1.0.0\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "\nYou've learned how to publish to both major app stores! Here's what we covered:\n\n- **Google Play Store**: Step-by-step submission process\n- **Apple App Store**: iOS publishing workflow\n- **Store Listings**: Optimizing descriptions and screenshots\n- **ASO**: App Store Optimization strategies\n- **Reviews**: Handling user feedback\n- **Updates**: Maintaining your published app\n\nCongratulations - you can now ship apps to millions of users!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Answer Key",
              "content": "\n**Answer 1:** B) Play Store is usually faster (1-3 days vs 1-2 days)\n\nActually, in 2025, App Store reviews are typically faster (1-2 days) compared to Google Play (1-3 days, sometimes up to 7 days). However, both are much faster than they used to be (Play Store used to take days/weeks).\n\n**Answer 2:** B) Legal requirement if you collect any user data\n\nBoth Google Play and App Store require a privacy policy if your app collects any user data (including analytics, email, location, etc.). It must be publicly accessible via URL and clearly explain data collection.\n\n**Answer 3:** A) App Store Optimization (improving visibility)\n\nASO (App Store Optimization) is the process of improving an app's visibility in app store search results. Similar to SEO for websites, it involves keyword optimization, compelling visuals, and positive ratings to rank higher.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "11.9",
          "title": "Offline-First with Sync",
          "moduleId": "module-11",
          "order": 9,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "Modern mobile apps must work without internet. Users expect apps to function seamlessly whether they're on a plane, in a subway, or in an area with poor connectivity. This lesson teaches you how to build truly offline-first applications that sync intelligently when connectivity returns.\n\n**What You'll Learn:**\n- Building apps that work without internet\n- Using SQLDelight as the source of truth\n- Implementing sync queues for pending changes\n- Detecting network connectivity\n- Handling conflict resolution\n- Background sync with WorkManager and BGTasks\n\n"
            },
            {
              "type": "THEORY",
              "title": "Local-First Strategy",
              "content": "The key to offline-first is making your local database the source of truth, not the server.\n\n**SQLDelight as Source of Truth:**\n\nAll reads come from local DB first. The network layer only syncs data to/from the server, but the UI always reads from local storage.\n\n**Benefits:**\n- Instant UI updates (no network latency)\n- Works completely offline\n- Reduced server load\n- Better user experience\n\n**Architecture Pattern:**\n1. User makes a change\n2. Change saved to local DB immediately\n3. UI updates instantly\n4. Change queued for sync\n5. Background process syncs to server\n6. Server response updates local DB if needed\n\n",
              "code": "// Repository pattern with local-first approach\nclass ListingsRepository {\n  final LocalDatabase _localDb;\n  final ApiClient _api;\n  final SyncQueue _syncQueue;\n\n  // Always read from local DB\n  Stream<List<Listing>> watchListings() {\n    return _localDb.watchAllListings();\n  }\n\n  // Write to local first, then queue sync\n  Future<void> createListing(Listing listing) async {\n    // 1. Save locally (instant)\n    await _localDb.insertListing(listing);\n    \n    // 2. Queue for sync\n    await _syncQueue.enqueue(\n      SyncOperation.create('listings', listing.toJson()),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Sync Queue",
              "content": "A sync queue tracks pending changes that need to be sent to the server.\n\n**Pending Changes Table:**\n\nThe queue stores operations with metadata for retry logic and conflict detection.\n\n**Processing the Queue:**\n\nProcess items in order, handling failures gracefully with exponential backoff.\n\n",
              "code": "// SQLDelight schema for sync queue\nCREATE TABLE sync_queue (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  operation TEXT NOT NULL,  -- 'create', 'update', 'delete'\n  entity_type TEXT NOT NULL,\n  entity_id TEXT NOT NULL,\n  payload TEXT NOT NULL,  -- JSON data\n  created_at INTEGER NOT NULL,\n  retry_count INTEGER DEFAULT 0,\n  status TEXT DEFAULT 'pending'  -- 'pending', 'syncing', 'failed'\n);\n\n// Dart implementation\nclass SyncQueue {\n  Future<void> processQueue() async {\n    final pending = await _db.getPendingSyncItems();\n    \n    for (final item in pending) {\n      try {\n        await _db.updateSyncStatus(item.id, 'syncing');\n        await _syncToServer(item);\n        await _db.deleteSyncItem(item.id);\n      } catch (e) {\n        await _db.incrementRetryCount(item.id);\n        if (item.retryCount >= 3) {\n          await _db.updateSyncStatus(item.id, 'failed');\n        }\n      }\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Network Check",
              "content": "Detect connectivity to know when to sync.\n\n**Connectivity Detection:**\n\nUse the connectivity_plus package to monitor network state and trigger sync operations when connectivity is restored.\n\n**Best Practices:**\n- Don't just check if connected, verify actual internet access\n- Handle metered connections (mobile data) differently\n- Respect user preferences for WiFi-only sync\n\n",
              "code": "import 'package:connectivity_plus/connectivity_plus.dart';\n\nclass ConnectivityService {\n  final Connectivity _connectivity = Connectivity();\n  \n  Stream<bool> get onConnectivityChanged {\n    return _connectivity.onConnectivityChanged.map((result) {\n      return result != ConnectivityResult.none;\n    });\n  }\n  \n  Future<bool> get isConnected async {\n    final result = await _connectivity.checkConnectivity();\n    if (result == ConnectivityResult.none) return false;\n    \n    // Actually verify internet access\n    try {\n      final response = await http.get(\n        Uri.parse('https://api.example.com/health'),\n      ).timeout(Duration(seconds: 5));\n      return response.statusCode == 200;\n    } catch (_) {\n      return false;\n    }\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Conflict Resolution",
              "content": "When offline changes conflict with server changes, you need a strategy.\n\n**Last-Write-Wins Strategy:**\n\nSimplest approach: the most recent change wins based on timestamps.\n\n**Other Strategies:**\n- **Server-wins**: Server data always takes precedence\n- **Client-wins**: Local changes always override\n- **Merge**: Combine changes field-by-field\n- **User-decides**: Present conflicts to user\n\n**Choosing a Strategy:**\n- Last-write-wins: Good for simple data, low conflict risk\n- Merge: Good for documents, collaborative editing\n- User-decides: Good for critical data where accuracy matters\n\n",
              "code": "class ConflictResolver {\n  Future<Listing> resolveConflict(\n    Listing local,\n    Listing server,\n  ) async {\n    // Last-write-wins based on updatedAt timestamp\n    if (local.updatedAt.isAfter(server.updatedAt)) {\n      // Local wins - push to server\n      await _api.updateListing(local);\n      return local;\n    } else {\n      // Server wins - update local\n      await _localDb.updateListing(server);\n      return server;\n    }\n  }\n  \n  // Field-level merge for complex objects\n  Listing mergeListings(Listing local, Listing server) {\n    return Listing(\n      id: server.id,\n      // Use whichever title was updated more recently\n      title: local.titleUpdatedAt.isAfter(server.titleUpdatedAt)\n          ? local.title\n          : server.title,\n      price: local.priceUpdatedAt.isAfter(server.priceUpdatedAt)\n          ? local.price\n          : server.price,\n      // Always use server for read-only fields\n      createdAt: server.createdAt,\n      sellerId: server.sellerId,\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Background Sync",
              "content": "Sync should happen in the background, not blocking the user.\n\n**WorkManager (Android) / BGTasks (iOS):**\n\nUse platform-specific background task APIs to sync even when the app is closed.\n\n**Key Considerations:**\n- Battery optimization: Don't sync too frequently\n- Network constraints: Only sync on WiFi if data is large\n- Retry logic: Handle failures gracefully\n- User control: Let users configure sync preferences\n\n",
              "code": "import 'package:workmanager/workmanager.dart';\n\n// Register background task\nvoid initializeBackgroundSync() {\n  Workmanager().initialize(callbackDispatcher);\n  \n  Workmanager().registerPeriodicTask(\n    'sync-task',\n    'syncData',\n    frequency: Duration(hours: 1),\n    constraints: Constraints(\n      networkType: NetworkType.connected,\n      requiresBatteryNotLow: true,\n    ),\n  );\n}\n\n// Background task callback\n@pragma('vm:entry-point')\nvoid callbackDispatcher() {\n  Workmanager().executeTask((task, inputData) async {\n    try {\n      final syncQueue = SyncQueue();\n      await syncQueue.processQueue();\n      \n      // Also pull latest from server\n      await syncQueue.pullServerChanges();\n      \n      return true; // Success\n    } catch (e) {\n      return false; // Retry later\n    }\n  });\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "You've learned how to build offline-first applications:\n\n- **Local-First Strategy**: SQLDelight as source of truth for instant UI\n- **Sync Queue**: Pending changes table for reliable syncing\n- **Network Check**: Connectivity detection to trigger syncs\n- **Conflict Resolution**: Last-write-wins and other strategies\n- **Background Sync**: WorkManager/BGTasks for seamless updates\n\nOffline-first apps provide superior user experience and work reliably in any network condition.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "11.10",
          "title": "Testing the Full Stack",
          "moduleId": "module-11",
          "order": 10,
          "estimatedMinutes": 55,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "A production-ready app needs testing at every layer. This lesson covers comprehensive testing strategies from unit tests to end-to-end tests, ensuring your app works correctly before users see it.\n\n**What You'll Learn:**\n- Unit testing use cases and ViewModels\n- Integration testing with real databases\n- UI testing with Compose test rules\n- End-to-end user flow testing\n- Generating test coverage reports\n\n"
            },
            {
              "type": "THEORY",
              "title": "Unit Tests",
              "content": "Unit tests verify individual components in isolation.\n\n**Testing Use Cases:**\n\nMock dependencies to test business logic in isolation.\n\n**Testing ViewModels:**\n\nTest state changes and side effects without the UI.\n\n",
              "code": "// Testing a use case\nclass GetListingsUseCaseTest {\n  late GetListingsUseCase useCase;\n  late MockListingsRepository mockRepository;\n\n  @Before\n  void setUp() {\n    mockRepository = MockListingsRepository();\n    useCase = GetListingsUseCase(mockRepository);\n  }\n\n  @Test\n  void 'returns listings from repository'() async {\n    // Arrange\n    final expectedListings = [Listing(id: '1', title: 'Test')];\n    when(mockRepository.getListings())\n        .thenAnswer((_) async => expectedListings);\n\n    // Act\n    final result = await useCase.execute();\n\n    // Assert\n    expect(result, equals(expectedListings));\n    verify(mockRepository.getListings()).called(1);\n  }\n}\n\n// Testing a ViewModel\nclass ListingsViewModelTest {\n  late ListingsViewModel viewModel;\n  late MockGetListingsUseCase mockUseCase;\n\n  @Test\n  void 'loadListings updates state correctly'() async {\n    // Arrange\n    final listings = [Listing(id: '1', title: 'Test')];\n    when(mockUseCase.execute())\n        .thenAnswer((_) async => listings);\n\n    // Act\n    await viewModel.loadListings();\n\n    // Assert\n    expect(viewModel.state.isLoading, isFalse);\n    expect(viewModel.state.listings, equals(listings));\n    expect(viewModel.state.error, isNull);\n  }\n\n  @Test\n  void 'loadListings handles errors'() async {\n    // Arrange\n    when(mockUseCase.execute())\n        .thenThrow(Exception('Network error'));\n\n    // Act\n    await viewModel.loadListings();\n\n    // Assert\n    expect(viewModel.state.isLoading, isFalse);\n    expect(viewModel.state.error, isNotNull);\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Integration Tests",
              "content": "Integration tests verify components work together.\n\n**Repository with Real DB:**\n\nUse an in-memory database to test repository logic with actual database operations.\n\n**Key Integration Test Scenarios:**\n- Repository CRUD operations\n- Database migrations\n- API client with mock server\n- Sync queue processing\n\n",
              "code": "class ListingsRepositoryIntegrationTest {\n  late AppDatabase database;\n  late ListingsRepository repository;\n\n  @Before\n  void setUp() {\n    // Use in-memory database for tests\n    database = AppDatabase(\n      databaseConnection: SqliteConnection.inMemory(),\n    );\n    repository = ListingsRepository(database);\n  }\n\n  @After\n  void tearDown() async {\n    await database.close();\n  }\n\n  @Test\n  void 'can create and retrieve listing'() async {\n    // Arrange\n    final listing = Listing(\n      id: 'test-1',\n      title: 'Test Item',\n      price: 99.99,\n      category: 'Electronics',\n    );\n\n    // Act\n    await repository.createListing(listing);\n    final retrieved = await repository.getListing('test-1');\n\n    // Assert\n    expect(retrieved, isNotNull);\n    expect(retrieved!.title, equals('Test Item'));\n    expect(retrieved.price, equals(99.99));\n  }\n\n  @Test\n  void 'watchListings emits updates'() async {\n    // Arrange\n    final listing1 = Listing(id: '1', title: 'First');\n    final listing2 = Listing(id: '2', title: 'Second');\n\n    // Act & Assert\n    expectLater(\n      repository.watchListings(),\n      emitsInOrder([\n        [],  // Initial empty\n        [listing1],  // After first insert\n        [listing1, listing2],  // After second insert\n      ]),\n    );\n\n    await repository.createListing(listing1);\n    await repository.createListing(listing2);\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "UI Tests",
              "content": "UI tests verify the user interface renders and responds correctly.\n\n**Compose Test Rules:**\n\nUse Flutter's widget testing framework to simulate user interactions and verify UI state.\n\n**Best Practices:**\n- Test user-visible behavior, not implementation\n- Use semantic matchers (find.text, find.byType)\n- Test accessibility (semantics labels)\n- Keep UI tests focused and fast\n\n",
              "code": "void main() {\n  testWidgets('ListingCard displays correctly', (tester) async {\n    // Arrange\n    final listing = Listing(\n      id: '1',\n      title: 'MacBook Pro',\n      price: 1299.99,\n      imageUrl: 'https://example.com/image.jpg',\n    );\n\n    // Act\n    await tester.pumpWidget(\n      MaterialApp(\n        home: ListingCard(listing: listing),\n      ),\n    );\n\n    // Assert\n    expect(find.text('MacBook Pro'), findsOneWidget);\n    expect(find.text('\\$1,299.99'), findsOneWidget);\n  });\n\n  testWidgets('Search filters listings', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        overrides: [\n          listingsProvider.overrideWithValue(\n            AsyncValue.data(testListings),\n          ),\n        ],\n        child: MaterialApp(home: SearchScreen()),\n      ),\n    );\n\n    // Type in search field\n    await tester.enterText(\n      find.byType(TextField),\n      'laptop',\n    );\n    await tester.pumpAndSettle();\n\n    // Verify filtered results\n    expect(find.text('MacBook Pro'), findsOneWidget);\n    expect(find.text('iPhone'), findsNothing);\n  });\n\n  testWidgets('Tap navigates to detail', (tester) async {\n    await tester.pumpWidget(createTestApp());\n\n    await tester.tap(find.text('MacBook Pro'));\n    await tester.pumpAndSettle();\n\n    expect(find.byType(ListingDetailScreen), findsOneWidget);\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "End-to-End Tests",
              "content": "E2E tests verify complete user flows from start to finish.\n\n**User Flow Testing:**\n\nSimulate real user journeys through the app.\n\n**What to E2E Test:**\n- Critical user paths (login, purchase, etc.)\n- Happy paths and error scenarios\n- Cross-screen navigation\n- Data persistence across sessions\n\n",
              "code": "void main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('User Flow Tests', () {\n    testWidgets('Complete purchase flow', (tester) async {\n      // Start app\n      app.main();\n      await tester.pumpAndSettle();\n\n      // Login\n      await tester.enterText(\n        find.byKey(Key('email-field')),\n        'test@example.com',\n      );\n      await tester.enterText(\n        find.byKey(Key('password-field')),\n        'password123',\n      );\n      await tester.tap(find.text('Login'));\n      await tester.pumpAndSettle();\n\n      // Navigate to listings\n      expect(find.byType(HomeScreen), findsOneWidget);\n\n      // Search for item\n      await tester.tap(find.byIcon(Icons.search));\n      await tester.enterText(\n        find.byType(TextField),\n        'MacBook',\n      );\n      await tester.pumpAndSettle();\n\n      // Select listing\n      await tester.tap(find.text('MacBook Pro'));\n      await tester.pumpAndSettle();\n\n      // Start chat with seller\n      await tester.tap(find.text('Message Seller'));\n      await tester.pumpAndSettle();\n\n      expect(find.byType(ChatScreen), findsOneWidget);\n\n      // Send message\n      await tester.enterText(\n        find.byType(TextField),\n        'Is this still available?',\n      );\n      await tester.tap(find.byIcon(Icons.send));\n      await tester.pumpAndSettle();\n\n      // Verify message sent\n      expect(\n        find.text('Is this still available?'),\n        findsOneWidget,\n      );\n    });\n  });\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Test Coverage Report",
              "content": "Track how much of your code is tested.\n\n**Generating Coverage:**\n\nRun tests with coverage enabled and generate reports.\n\n**Coverage Goals:**\n- 80%+ overall coverage is a good target\n- 90%+ for critical business logic\n- Focus on testing behavior, not just lines\n- Don't chase 100% - diminishing returns\n\n**Integrating with CI:**\n- Fail builds if coverage drops below threshold\n- Track coverage trends over time\n- Review coverage reports in PRs\n\n",
              "code": "# Generate coverage report\nflutter test --coverage\n\n# Generate HTML report (requires lcov)\ngenhtml coverage/lcov.info -o coverage/html\n\n# Open report\nopen coverage/html/index.html\n\n# In pubspec.yaml, add coverage dependencies\ndev_dependencies:\n  test: ^1.24.0\n  mocktail: ^1.0.0\n  integration_test:\n    sdk: flutter\n\n# CI configuration (GitHub Actions)\nname: Tests\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - run: flutter pub get\n      - run: flutter test --coverage\n      - name: Check coverage\n        run: |\n          COVERAGE=$(lcov --summary coverage/lcov.info | grep 'lines' | awk '{print $2}' | sed 's/%//')\n          if (( $(echo \"$COVERAGE < 80\" | bc -l) )); then\n            echo \"Coverage $COVERAGE% is below 80% threshold\"\n            exit 1\n          fi",
              "language": "bash"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "You've learned comprehensive testing strategies:\n\n- **Unit Tests**: Test use cases and ViewModels in isolation with mocks\n- **Integration Tests**: Test repository with real in-memory database\n- **UI Tests**: Test widgets with Compose test rules\n- **End-to-End Tests**: Test complete user flows across screens\n- **Test Coverage**: Generate and track coverage reports\n\nA well-tested app gives confidence for refactoring, catches regressions, and enables faster development.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "11.11",
          "title": "CI/CD Pipeline Setup",
          "moduleId": "module-11",
          "order": 11,
          "estimatedMinutes": 50,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "Continuous Integration and Continuous Deployment automate your build, test, and release process. Every code change is automatically validated and can be deployed to users with confidence.\n\n**What You'll Learn:**\n- Setting up GitHub Actions workflow\n- Building signed Android AABs\n- Building iOS archives with Fastlane\n- Running tests in matrix builds\n- Deploying to app stores automatically\n\n"
            },
            {
              "type": "THEORY",
              "title": "GitHub Actions Workflow",
              "content": "GitHub Actions provides free CI/CD for public repositories.\n\n**Full Pipeline Configuration:**\n\nThis workflow runs on every push and PR, testing across multiple Flutter versions.\n\n**Key Components:**\n- Trigger events (push, PR, manual)\n- Environment setup (Flutter, dependencies)\n- Caching for faster builds\n- Matrix builds for multiple configurations\n\n",
              "code": "# .github/workflows/ci.yml\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n  workflow_dispatch:  # Manual trigger\n\nenv:\n  FLUTTER_VERSION: '3.16.0'\n  JAVA_VERSION: '17'\n\njobs:\n  analyze:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: ${{ env.FLUTTER_VERSION }}\n          cache: true\n      \n      - name: Get dependencies\n        run: flutter pub get\n      \n      - name: Analyze code\n        run: flutter analyze --fatal-infos\n      \n      - name: Check formatting\n        run: dart format --set-exit-if-changed .\n\n  test:\n    runs-on: ubuntu-latest\n    needs: analyze\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: ${{ env.FLUTTER_VERSION }}\n          cache: true\n      \n      - name: Get dependencies\n        run: flutter pub get\n      \n      - name: Run tests with coverage\n        run: flutter test --coverage\n      \n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n        with:\n          files: coverage/lcov.info",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Build Android AAB",
              "content": "Build a signed Android App Bundle for Play Store.\n\n**Signed Release Build:**\n\nStore signing keys securely in GitHub Secrets.\n\n**Key Management:**\n- Never commit keystore to repository\n- Use GitHub Secrets for credentials\n- Rotate keys periodically\n- Use Play App Signing for extra security\n\n",
              "code": "# .github/workflows/ci.yml (continued)\n  build-android:\n    runs-on: ubuntu-latest\n    needs: test\n    if: github.ref == 'refs/heads/main'\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: ${{ env.FLUTTER_VERSION }}\n          cache: true\n      \n      - name: Setup Java\n        uses: actions/setup-java@v3\n        with:\n          distribution: 'temurin'\n          java-version: ${{ env.JAVA_VERSION }}\n      \n      - name: Decode keystore\n        run: |\n          echo \"${{ secrets.KEYSTORE_BASE64 }}\" | base64 -d > android/app/release.keystore\n      \n      - name: Create key.properties\n        run: |\n          echo \"storePassword=${{ secrets.KEYSTORE_PASSWORD }}\" > android/key.properties\n          echo \"keyPassword=${{ secrets.KEY_PASSWORD }}\" >> android/key.properties\n          echo \"keyAlias=${{ secrets.KEY_ALIAS }}\" >> android/key.properties\n          echo \"storeFile=release.keystore\" >> android/key.properties\n      \n      - name: Build AAB\n        run: flutter build appbundle --release\n      \n      - name: Upload AAB\n        uses: actions/upload-artifact@v3\n        with:\n          name: app-release.aab\n          path: build/app/outputs/bundle/release/app-release.aab\n\n# Encode keystore for secrets:\n# base64 -i release.keystore | pbcopy",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Build iOS Archive",
              "content": "Build iOS apps using Fastlane for certificate management.\n\n**Fastlane Configuration:**\n\nFastlane handles code signing, building, and uploading to App Store Connect.\n\n**Setup Steps:**\n1. Install Fastlane: `gem install fastlane`\n2. Initialize: `fastlane init`\n3. Configure match for code signing\n4. Add lanes for build and deploy\n\n",
              "code": "# .github/workflows/ci.yml (continued)\n  build-ios:\n    runs-on: macos-latest\n    needs: test\n    if: github.ref == 'refs/heads/main'\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: ${{ env.FLUTTER_VERSION }}\n          cache: true\n      \n      - name: Setup Ruby\n        uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: '3.0'\n          bundler-cache: true\n      \n      - name: Install Fastlane\n        run: gem install fastlane\n      \n      - name: Setup certificates\n        run: |\n          cd ios\n          fastlane match appstore --readonly\n        env:\n          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}\n          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}\n          FASTLANE_USER: ${{ secrets.APPLE_ID }}\n          FASTLANE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}\n      \n      - name: Build IPA\n        run: flutter build ipa --release --export-options-plist=ios/ExportOptions.plist\n      \n      - name: Upload IPA\n        uses: actions/upload-artifact@v3\n        with:\n          name: app-release.ipa\n          path: build/ios/ipa/*.ipa\n\n# ios/fastlane/Fastfile\ndefault_platform(:ios)\n\nplatform :ios do\n  lane :build do\n    match(type: \"appstore\")\n    build_app(\n      workspace: \"Runner.xcworkspace\",\n      scheme: \"Runner\",\n      export_method: \"app-store\"\n    )\n  end\nend",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Run All Tests",
              "content": "Run tests across multiple configurations using matrix builds.\n\n**Matrix Builds:**\n\nTest on multiple Flutter versions and platforms simultaneously.\n\n**Benefits:**\n- Catch version-specific issues\n- Test on different OS versions\n- Parallel execution saves time\n- Comprehensive coverage\n\n",
              "code": "# Matrix testing across versions\n  test-matrix:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [ubuntu-latest, macos-latest, windows-latest]\n        flutter-version: ['3.16.0', '3.19.0']\n    \n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: ${{ matrix.flutter-version }}\n          cache: true\n      \n      - name: Get dependencies\n        run: flutter pub get\n      \n      - name: Run tests\n        run: flutter test\n      \n      - name: Build (verify compilation)\n        run: |\n          if [ \"${{ matrix.os }}\" == \"macos-latest\" ]; then\n            flutter build ios --no-codesign\n          elif [ \"${{ matrix.os }}\" == \"ubuntu-latest\" ]; then\n            flutter build apk\n          elif [ \"${{ matrix.os }}\" == \"windows-latest\" ]; then\n            flutter build windows\n          fi\n        shell: bash",
              "language": "yaml"
            },
            {
              "type": "THEORY",
              "title": "Deploy to Stores",
              "content": "Automatically deploy to internal testing tracks.\n\n**Play Store Deployment:**\n\nUpload to internal testing track for review before production.\n\n**App Store Deployment:**\n\nUse Fastlane to upload to TestFlight for beta testing.\n\n**Best Practices:**\n- Deploy to internal/beta first, never directly to production\n- Use staged rollouts (10% -> 50% -> 100%)\n- Monitor crash rates before expanding rollout\n- Have rollback procedures ready\n\n",
              "code": "# Deploy to Play Store internal track\n  deploy-android:\n    runs-on: ubuntu-latest\n    needs: build-android\n    if: github.ref == 'refs/heads/main'\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Download AAB\n        uses: actions/download-artifact@v3\n        with:\n          name: app-release.aab\n      \n      - name: Setup service account\n        run: |\n          echo \"${{ secrets.PLAY_STORE_SERVICE_ACCOUNT }}\" > service-account.json\n      \n      - name: Deploy to Internal Track\n        uses: r0adkll/upload-google-play@v1\n        with:\n          serviceAccountJson: service-account.json\n          packageName: com.example.localBuy\n          releaseFiles: app-release.aab\n          track: internal\n          status: completed\n\n# Deploy to App Store (TestFlight)\n  deploy-ios:\n    runs-on: macos-latest\n    needs: build-ios\n    if: github.ref == 'refs/heads/main'\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Download IPA\n        uses: actions/download-artifact@v3\n        with:\n          name: app-release.ipa\n      \n      - name: Setup Fastlane\n        run: gem install fastlane\n      \n      - name: Upload to TestFlight\n        run: |\n          fastlane pilot upload \\\n            --ipa app-release.ipa \\\n            --skip_waiting_for_build_processing\n        env:\n          FASTLANE_USER: ${{ secrets.APPLE_ID }}\n          FASTLANE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}\n          FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD: ${{ secrets.APP_SPECIFIC_PASSWORD }}",
              "language": "yaml"
            },
            {
              "type": "KEY_POINT",
              "title": "Summary",
              "content": "You've learned how to set up a complete CI/CD pipeline:\n\n- **GitHub Actions Workflow**: Automated builds on every push and PR\n- **Build Android AAB**: Signed release builds with secure key management\n- **Build iOS Archive**: Fastlane for certificates and builds\n- **Run All Tests**: Matrix builds across versions and platforms\n- **Deploy to Stores**: Automatic deployment to internal testing tracks\n\nCI/CD ensures consistent quality and enables rapid, confident releases.\n\n"
            }
          ],
          "challenges": []
        },
        {
          "id": "11.12",
          "title": "Publishing to Stores",
          "moduleId": "module-11",
          "order": 12,
          "estimatedMinutes": 55,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Introduction",
              "content": "You've built, tested, and automated your app. Now it's time to publish it to the world! This lesson covers the final steps to get your app into users' hands.\n\n**What You'll Learn:**\n- Play Store submission process\n- App Store submission process\n- Post-launch monitoring with Crashlytics and analytics\n- Versioning strategy with semver\n- Course completion and next steps\n\n"
            },
            {
              "type": "THEORY",
              "title": "Play Store Submission",
              "content": "Submit your app to Google Play Store.\n\n**Store Listing Checklist:**\n\nPrepare all assets and metadata before submission.\n\n**Screenshots Tips:**\n- Show key features in first 2 screenshots\n- Use device frames for professional look\n- Add captions explaining features\n- Include different device sizes\n\n**Common Rejection Reasons:**\n- Broken functionality or crashes\n- Misleading metadata\n- Privacy policy issues\n- Policy violations\n\n",
              "code": "# Play Store Listing Requirements\n\n## Required Assets:\n- App icon: 512x512 PNG\n- Feature graphic: 1024x500 PNG\n- Screenshots: Min 2, max 8 per device type\n  - Phone: 1080x1920 or 1920x1080\n  - Tablet 7\": 1200x1920\n  - Tablet 10\": 1920x1200\n\n## Required Information:\n- Title: Max 30 characters\n- Short description: Max 80 characters\n- Full description: Max 4000 characters\n- Category: Select from Play Store categories\n- Content rating: Complete questionnaire\n- Privacy policy URL: Required if app collects data\n- Target audience: Age groups\n\n## Release Checklist:\n1. Create app in Play Console\n2. Complete store listing\n3. Upload AAB\n4. Complete content rating\n5. Set pricing and distribution\n6. Create release (internal -> closed -> production)\n7. Submit for review\n\n# Typical review time: 1-3 days (can be up to 7)",
              "language": "markdown"
            },
            {
              "type": "THEORY",
              "title": "App Store Submission",
              "content": "Submit your app to Apple App Store.\n\n**App Store Connect Setup:**\n\nApple has stricter requirements and review process.\n\n**Review Guidelines:**\n- Apps must be complete and functional\n- Accurate metadata and screenshots\n- Privacy nutrition labels required\n- No placeholder content\n- Follow Human Interface Guidelines\n\n**Common Rejection Reasons:**\n- Guideline 2.1: App completeness\n- Guideline 4.3: Spam/duplicate apps\n- Guideline 5.1: Privacy issues\n- Guideline 2.3.3: Inaccurate metadata\n\n",
              "code": "# App Store Listing Requirements\n\n## Required Assets:\n- App icon: 1024x1024 PNG (no transparency)\n- Screenshots per device:\n  - iPhone 6.7\": 1290x2796\n  - iPhone 6.5\": 1284x2778\n  - iPhone 5.5\": 1242x2208\n  - iPad Pro 12.9\": 2048x2732\n  - iPad Pro 11\": 1668x2388\n\n## Required Information:\n- Name: Max 30 characters\n- Subtitle: Max 30 characters\n- Description: Max 4000 characters\n- Keywords: Max 100 characters (comma-separated)\n- Support URL: Required\n- Privacy policy URL: Required\n- Age rating: Complete questionnaire\n- App Privacy (nutrition labels)\n\n## Submission Steps:\n1. Create App ID in Developer Portal\n2. Create app in App Store Connect\n3. Complete app information\n4. Upload build via Xcode or Transporter\n5. Add screenshots and metadata\n6. Submit for review\n7. Answer export compliance questions\n\n# Typical review time: 24-48 hours",
              "language": "markdown"
            },
            {
              "type": "THEORY",
              "title": "Post-Launch Monitoring",
              "content": "Monitor your app after launch to catch issues quickly.\n\n**Crashlytics Setup:**\n\nFirebase Crashlytics provides real-time crash reporting.\n\n**Analytics Setup:**\n\nTrack user behavior to understand how your app is used.\n\n**Key Metrics to Monitor:**\n- Crash-free users percentage (target: 99.9%+)\n- ANR rate (Android Not Responding)\n- Daily/Monthly active users\n- Retention rates (Day 1, 7, 30)\n- Session duration\n- Screen flow drop-offs\n\n",
              "code": "// Firebase Crashlytics setup\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await Firebase.initializeApp();\n  \n  // Pass all uncaught errors to Crashlytics\n  FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;\n  \n  // Pass uncaught async errors\n  PlatformDispatcher.instance.onError = (error, stack) {\n    FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);\n    return true;\n  };\n  \n  runApp(MyApp());\n}\n\n// Custom logging\nvoid logError(dynamic error, StackTrace stack) {\n  FirebaseCrashlytics.instance.recordError(error, stack);\n}\n\n// User identification for crash reports\nvoid setUser(String userId) {\n  FirebaseCrashlytics.instance.setUserIdentifier(userId);\n}\n\n// Firebase Analytics setup\nimport 'package:firebase_analytics/firebase_analytics.dart';\n\nclass AnalyticsService {\n  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;\n  \n  Future<void> logScreenView(String screenName) async {\n    await _analytics.logScreenView(screenName: screenName);\n  }\n  \n  Future<void> logEvent(String name, Map<String, dynamic>? params) async {\n    await _analytics.logEvent(name: name, parameters: params);\n  }\n  \n  Future<void> logPurchase(double price, String itemId) async {\n    await _analytics.logPurchase(\n      value: price,\n      currency: 'USD',\n      items: [AnalyticsEventItem(itemId: itemId)],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Versioning Strategy",
              "content": "Use semantic versioning (semver) for clear, consistent releases.\n\n**Semver Format: MAJOR.MINOR.PATCH**\n\nIncrement versions based on the type of changes.\n\n**Automation:**\n\nAutomate version bumping based on commit messages.\n\n**Best Practices:**\n- Tag releases in Git\n- Keep a CHANGELOG.md\n- Document breaking changes\n- Use pre-release versions for beta (1.0.0-beta.1)\n\n",
              "code": "# Semantic Versioning\n\n## Format: MAJOR.MINOR.PATCH\n- MAJOR: Breaking changes (incompatible API changes)\n- MINOR: New features (backward compatible)\n- PATCH: Bug fixes (backward compatible)\n\n## Examples:\n- 1.0.0: Initial release\n- 1.0.1: Bug fix\n- 1.1.0: New feature added\n- 2.0.0: Breaking change\n\n## Build Number:\n- Always increment with each submission\n- Can be date-based: 20240115 (YYYYMMDD)\n- Or sequential: 1, 2, 3...\n\n## In pubspec.yaml:\nversion: 1.2.3+45  # version+buildNumber\n\n## Automated version bumping (cider package):\nflutter pub global activate cider\n\n# Bump patch version\ncider bump patch\n\n# Bump minor version\ncider bump minor\n\n# Bump major version\ncider bump major\n\n## Git tags for releases:\ngit tag v1.2.3\ngit push origin v1.2.3",
              "language": "markdown"
            },
            {
              "type": "KEY_POINT",
              "title": "Congratulations",
              "content": "You've completed the full development cycle! You now know how to:\n\n- **Build**: Create cross-platform apps with Flutter and Kotlin Multiplatform\n- **Test**: Write comprehensive tests at every layer\n- **Automate**: Set up CI/CD pipelines for quality and speed\n- **Publish**: Submit to Google Play and Apple App Store\n- **Monitor**: Track crashes, analytics, and user behavior\n- **Iterate**: Version and update your app over time\n\nYou have all the skills to build and ship production-ready mobile applications!\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Module Summary",
              "content": "In this module, you learned everything needed to deploy production apps:\n\n**Lesson 11.9 - Offline-First with Sync:**\n- Local-first architecture with SQLDelight\n- Sync queues and conflict resolution\n- Background sync with WorkManager\n\n**Lesson 11.10 - Testing the Full Stack:**\n- Unit, integration, UI, and E2E tests\n- Test coverage reports\n\n**Lesson 11.11 - CI/CD Pipeline Setup:**\n- GitHub Actions workflows\n- Signed builds for both platforms\n- Automated deployment\n\n**Lesson 11.12 - Publishing to Stores:**\n- Store submission requirements\n- Post-launch monitoring\n- Versioning strategy\n\n**What's Next:**\n- Build your own app and publish it\n- Explore advanced topics (animations, platform channels)\n- Contribute to open source\n- Never stop learning!\n\nThank you for completing this course. Now go build something amazing!\n\n"
            }
          ],
          "challenges": []
        }
      ]
    },
    {
      "id": "module-12",
      "title": "Module 12: Flutter Development",
      "description": "Learn Flutter development - Module 12",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "12.1",
          "title": "Module 12: Final Capstone Project",
          "moduleId": "module-12",
          "order": 1,
          "estimatedMinutes": 55,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Ultimate Challenge: Build a Complete Social Marketplace App",
              "content": "\nCongratulations on reaching the final module! You've learned everything from Flutter basics to deployment. Now it's time to prove your skills by building a **complete, production-ready social marketplace app** from scratch.\n\n"
            },
            {
              "type": "THEORY",
              "title": "Project Overview: \"LocalBuy\" Social Marketplace",
              "content": "\n### What You'll Build\n\n**LocalBuy** is a full-stack social marketplace where users can:\n- Buy and sell items locally\n- Chat with sellers in real-time\n- Follow favorite sellers\n- Share listings on social media\n- Get location-based recommendations\n- Track order history\n- Receive push notifications\n\n###Skills Demonstrated\n\nThis project combines **EVERY module** from the course:\n\n| Module | Features Used |\n|--------|---------------|\n| **0-2: Basics** | Dart fundamentals, Flutter widgets, layouts |\n| **3: Lists & Forms** | Product lists, post item forms, search |\n| **4: State Management** | Provider for cart, user auth state |\n| **5: Theming** | Light/dark mode, custom theme |\n| **6: Navigation** | GoRouter for deep linking to products |\n| **7: Networking** | Product API, image uploads |\n| **8: Firebase** | Auth, Firestore, Storage, push notifications |\n| **9: Advanced** | Maps for location, camera for photos, local DB for favorites |\n| **10: Testing** | Unit, widget, integration tests |\n| **11: Deployment** | Production build, store publishing |\n\n"
            },
            {
              "type": "THEORY",
              "title": "Phase 1: Planning & Architecture",
              "content": "\n### User Stories\n\n**As a Seller, I can:**\n1. Create an account and profile\n2. List items for sale with photos\n3. Edit/delete my listings\n4. Chat with potential buyers\n5. Mark items as sold\n6. View my sales history\n\n**As a Buyer, I can:**\n7. Browse items by category\n8. Search for specific items\n9. Filter by location and price\n10. Save favorite items\n11. Chat with sellers\n12. View seller profiles\n13. Track my purchase history\n\n### Database Schema\n\n**Firestore Collections:**\n\n\n### App Architecture\n\n\n",
              "code": "lib/\n‚îú‚îÄ‚îÄ main.dart\n‚îú‚îÄ‚îÄ app.dart\n‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îú‚îÄ‚îÄ user.dart\n‚îÇ   ‚îú‚îÄ‚îÄ listing.dart\n‚îÇ   ‚îú‚îÄ‚îÄ chat.dart\n‚îÇ   ‚îî‚îÄ‚îÄ message.dart\n‚îú‚îÄ‚îÄ providers/\n‚îÇ   ‚îú‚îÄ‚îÄ auth_provider.dart\n‚îÇ   ‚îú‚îÄ‚îÄ listings_provider.dart\n‚îÇ   ‚îú‚îÄ‚îÄ cart_provider.dart\n‚îÇ   ‚îî‚îÄ‚îÄ chat_provider.dart\n‚îú‚îÄ‚îÄ services/\n‚îÇ   ‚îú‚îÄ‚îÄ auth_service.dart\n‚îÇ   ‚îú‚îÄ‚îÄ firestore_service.dart\n‚îÇ   ‚îú‚îÄ‚îÄ storage_service.dart\n‚îÇ   ‚îú‚îÄ‚îÄ location_service.dart\n‚îÇ   ‚îî‚îÄ‚îÄ notification_service.dart\n‚îú‚îÄ‚îÄ screens/\n‚îÇ   ‚îú‚îÄ‚îÄ auth/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ register_screen.dart\n‚îÇ   ‚îú‚îÄ‚îÄ home/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ home_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ search_screen.dart\n‚îÇ   ‚îú‚îÄ‚îÄ listings/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ listing_detail_screen.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create_listing_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ my_listings_screen.dart\n‚îÇ   ‚îú‚îÄ‚îÄ profile/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ profile_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ edit_profile_screen.dart\n‚îÇ   ‚îú‚îÄ‚îÄ chat/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chats_list_screen.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chat_screen.dart\n‚îÇ   ‚îî‚îÄ‚îÄ favorites/\n‚îÇ       ‚îî‚îÄ‚îÄ favorites_screen.dart\n‚îú‚îÄ‚îÄ widgets/\n‚îÇ   ‚îú‚îÄ‚îÄ listing_card.dart\n‚îÇ   ‚îú‚îÄ‚îÄ user_avatar.dart\n‚îÇ   ‚îú‚îÄ‚îÄ price_tag.dart\n‚îÇ   ‚îî‚îÄ‚îÄ category_chip.dart\n‚îî‚îÄ‚îÄ utils/\n    ‚îú‚îÄ‚îÄ constants.dart\n    ‚îú‚îÄ‚îÄ validators.dart\n    ‚îî‚îÄ‚îÄ helpers.dart\n\ntest/\n‚îú‚îÄ‚îÄ unit/\n‚îÇ   ‚îú‚îÄ‚îÄ models_test.dart\n‚îÇ   ‚îú‚îÄ‚îÄ services_test.dart\n‚îÇ   ‚îî‚îÄ‚îÄ providers_test.dart\n‚îú‚îÄ‚îÄ widget/\n‚îÇ   ‚îî‚îÄ‚îÄ widgets_test.dart\n‚îî‚îÄ‚îÄ integration/\n    ‚îî‚îÄ‚îÄ app_test.dart",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Phase 2: Implementation Milestones",
              "content": "\n### Milestone 1: Authentication & User Profile (Week 1)\n\n**Tasks:**\n1. Set up Firebase project\n2. Implement email/password authentication\n3. Add Google Sign-In\n4. Create user profile screen\n5. Add profile photo upload\n6. Implement edit profile functionality\n\n**Deliverables:**\n- [ ] Users can register/login\n- [ ] Users can upload profile photo\n- [ ] Users can edit their name and bio\n- [ ] Auth state persists across app restarts\n\n**Code Example:**\n\n### Milestone 2: Listings & Categories (Week 2)\n\n**Tasks:**\n1. Create listing model\n2. Implement create listing form\n3. Add image picker (camera/gallery)\n4. Upload images to Firebase Storage\n5. Display listings feed\n6. Add categories and filtering\n7. Implement search functionality\n\n**Deliverables:**\n- [ ] Users can create listings with photos\n- [ ] Listings display in a grid/list\n- [ ] Categories work (Electronics, Furniture, etc.)\n- [ ] Search returns relevant results\n- [ ] Listings show seller info\n\n**Code Example:**\n\n### Milestone 3: Real-Time Chat (Week 3)\n\n**Tasks:**\n1. Create chat data model\n2. Implement chat list screen\n3. Implement 1-on-1 chat screen\n4. Add real-time message sync\n5. Show typing indicators\n6. Add push notifications for new messages\n\n**Deliverables:**\n- [ ] Users can start chats from listings\n- [ ] Messages sync in real-time\n- [ ] Typing indicators work\n- [ ] Push notifications for new messages\n- [ ] Unread message badges\n\n### Milestone 4: Maps & Location (Week 4)\n\n**Tasks:**\n1. Add Google Maps integration\n2. Show listings on map\n3. Filter by distance\n4. Add location picker for new listings\n5. Show seller location (approximate)\n\n**Deliverables:**\n- [ ] Map shows nearby listings\n- [ ] Listings can be filtered by distance\n- [ ] Users can pick location when creating listing\n\n### Milestone 5: Testing & Polish (Week 5)\n\n**Tasks:**\n1. Write unit tests for models\n2. Write unit tests for services\n3. Write widget tests for screens\n4. Write integration tests for critical flows\n5. Achieve 70%+ code coverage\n6. Fix all bugs\n7. Optimize performance\n\n**Deliverables:**\n- [ ] 70%+ code coverage\n- [ ] All critical flows tested\n- [ ] No crashes or major bugs\n- [ ] App runs smoothly (60 FPS)\n\n### Milestone 6: Deployment (Week 6)\n\n**Tasks:**\n1. Create app icons\n2. Add splash screen\n3. Write privacy policy\n4. Prepare store listings\n5. Create screenshots\n6. Build release APK/IPA\n7. Submit to stores\n\n**Deliverables:**\n- [ ] App published to Google Play\n- [ ] App published to App Store (if applicable)\n- [ ] Store listings complete\n- [ ] First version live!\n\n",
              "code": "// lib/screens/listings/create_listing_screen.dart\nclass CreateListingScreen extends StatefulWidget {\n  @override\n  State<CreateListingScreen> createState() => _CreateListingScreenState();\n}\n\nclass _CreateListingScreenState extends State<CreateListingScreen> {\n  final _formKey = GlobalKey<FormState>();\n  final _titleController = TextEditingController();\n  final _descriptionController = TextEditingController();\n  final _priceController = TextEditingController();\n\n  String _selectedCategory = 'Electronics';\n  List<File> _images = [];\n  bool _isLoading = false;\n\n  Future<void> _pickImages() async {\n    final ImagePicker picker = ImagePicker();\n    final List<XFile> images = await picker.pickMultipleImages();\n\n    if (images.isNotEmpty) {\n      setState(() {\n        _images = images.map((img) => File(img.path)).toList();\n      });\n    }\n  }\n\n  Future<void> _createListing() async {\n    if (!_formKey.currentState!.validate()) return;\n    if (_images.isEmpty) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Please add at least one photo')),\n      );\n      return;\n    }\n\n    setState(() => _isLoading = true);\n\n    try {\n      // Upload images\n      final storageService = Provider.of<StorageService>(context, listen: false);\n      final imageUrls = await storageService.uploadListingImages(_images);\n\n      // Get current location\n      final position = await Geolocator.getCurrentPosition();\n\n      // Create listing\n      final listing = Listing(\n        title: _titleController.text,\n        description: _descriptionController.text,\n        price: double.parse(_priceController.text),\n        category: _selectedCategory,\n        images: imageUrls,\n        sellerId: FirebaseAuth.instance.currentUser!.uid,\n        location: GeoPoint(position.latitude, position.longitude),\n        status: 'available',\n        createdAt: DateTime.now(),\n        views: 0,\n      );\n\n      await Provider.of<ListingsProvider>(context, listen: false).createListing(listing);\n\n      Navigator.pop(context);\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Listing created successfully!')),\n      );\n    } catch (e) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Error: ${e.toString()}')),\n      );\n    } finally {\n      setState(() => _isLoading = false);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Create Listing')),\n      body: _isLoading\n          ? Center(child: CircularProgressIndicator())\n          : SingleChildScrollView(\n              padding: EdgeInsets.all(16),\n              child: Form(\n                key: _formKey,\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.stretch,\n                  children: [\n                    // Images\n                    if (_images.isNotEmpty)\n                      Container(\n                        height: 200,\n                        child: ListView.builder(\n                          scrollDirection: Axis.horizontal,\n                          itemCount: _images.length,\n                          itemBuilder: (context, index) {\n                            return Stack(\n                              children: [\n                                Image.file(_images[index], width: 200, fit: BoxFit.cover),\n                                Positioned(\n                                  top: 8,\n                                  right: 8,\n                                  child: IconButton(\n                                    icon: Icon(Icons.close, color: Colors.white),\n                                    onPressed: () {\n                                      setState(() => _images.removeAt(index));\n                                    },\n                                  ),\n                                ),\n                              ],\n                            );\n                          },\n                        ),\n                      ),\n\n                    ElevatedButton.icon(\n                      onPressed: _pickImages,\n                      icon: Icon(Icons.add_photo_alternate),\n                      label: Text('Add Photos'),\n                    ),\n\n                    SizedBox(height: 16),\n\n                    TextFormField(\n                      controller: _titleController,\n                      decoration: InputDecoration(labelText: 'Title*'),\n                      validator: (v) => v!.isEmpty ? 'Required' : null,\n                    ),\n\n                    TextFormField(\n                      controller: _descriptionController,\n                      decoration: InputDecoration(labelText: 'Description*'),\n                      maxLines: 3,\n                      validator: (v) => v!.isEmpty ? 'Required' : null,\n                    ),\n\n                    TextFormField(\n                      controller: _priceController,\n                      decoration: InputDecoration(labelText: 'Price (USD)*', prefixText: '\\$'),\n                      keyboardType: TextInputType.number,\n                      validator: (v) {\n                        if (v!.isEmpty) return 'Required';\n                        if (double.tryParse(v) == null) return 'Invalid price';\n                        return null;\n                      },\n                    ),\n\n                    DropdownButtonFormField<String>(\n                      value: _selectedCategory,\n                      items: ['Electronics', 'Furniture', 'Clothing', 'Books', 'Sports', 'Other']\n                          .map((cat) => DropdownMenuItem(value: cat, child: Text(cat)))\n                          .toList(),\n                      onChanged: (v) => setState(() => _selectedCategory = v!),\n                      decoration: InputDecoration(labelText: 'Category'),\n                    ),\n\n                    SizedBox(height: 24),\n\n                    ElevatedButton(\n                      onPressed: _createListing,\n                      child: Text('Create Listing'),\n                      style: ElevatedButton.styleFrom(\n                        padding: EdgeInsets.symmetric(vertical: 16),\n                      ),\n                    ),\n                  ],\n                ),\n              ),\n            ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "THEORY",
              "title": "Phase 3: Advanced Features (Optional)",
              "content": "\nOnce your MVP is complete, add these advanced features:\n\n### 1. Ratings & Reviews\n- Users can rate sellers (1-5 stars)\n- Write reviews\n- Seller profile shows average rating\n\n### 2. Favorites & Saved Searches\n- Save favorite listings\n- Save search filters\n- Get notified of new listings matching saved searches\n\n### 3. Offers & Negotiation\n- Buyers can make offers\n- Sellers can accept/reject/counter\n- Track offer history\n\n### 4. Social Features\n- Follow favorite sellers\n- Share listings to social media\n- Activity feed of followed sellers\n\n### 5. Analytics Dashboard\n- Sellers see view counts\n- Track which listings are popular\n- Revenue analytics\n\n### 6. In-App Payments\n- Integrate Stripe or PayPal\n- Secure checkout flow\n- Track transaction history\n\n"
            },
            {
              "type": "THEORY",
              "title": "Phase 4: Evaluation Criteria",
              "content": "\n### Functionality (40 points)\n- [ ] All core features work (10 pts)\n- [ ] No crashes or major bugs (10 pts)\n- [ ] Real-time features work (10 pts)\n- [ ] Location features work (10 pts)\n\n### Code Quality (30 points)\n- [ ] Clean, readable code (10 pts)\n- [ ] Proper state management (10 pts)\n- [ ] Good error handling (5 pts)\n- [ ] Secure (no hardcoded secrets) (5 pts)\n\n### Testing (15 points)\n- [ ] Unit tests present (5 pts)\n- [ ] Widget tests present (5 pts)\n- [ ] 70%+ code coverage (5 pts)\n\n### UI/UX (10 points)\n- [ ] Professional design (5 pts)\n- [ ] Smooth animations (3 pts)\n- [ ] Good user experience (2 pts)\n\n### Deployment (5 points)\n- [ ] Published to at least one store (5 pts)\n\n**Total: 100 points**\n\n**Grading:**\n- 90-100: Excellent (A)\n- 80-89: Very Good (B)\n- 70-79: Good (C)\n- 60-69: Pass (D)\n- 0-59: Needs Improvement (F)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Resources & Support",
              "content": "\n### Documentation\n- [Flutter Docs](https://flutter.dev/docs)\n- [Firebase Docs](https://firebase.google.com/docs)\n- [GoRouter Docs](https://pub.dev/packages/go_router)\n- [Provider Docs](https://pub.dev/packages/provider)\n\n### Community\n- [Flutter Discord](https://discord.gg/flutter)\n- [r/FlutterDev](https://reddit.com/r/FlutterDev)\n- [Stack Overflow](https://stackoverflow.com/questions/tagged/flutter)\n\n### Tools\n- [FlutterFlow](https://flutterflow.io) - Visual builder (optional)\n- [Firebase Console](https://console.firebase.google.com)\n- [Google Play Console](https://play.google.com/console)\n- [App Store Connect](https://appstoreconnect.apple.com)\n\n"
            },
            {
              "type": "THEORY",
              "title": "Submission Guidelines",
              "content": "\n1. **Source Code**\n   - Push to GitHub (public or private)\n   - Include README.md with setup instructions\n   - Include .env.example for API keys\n\n2. **Demo Video**\n   - 3-5 minutes\n   - Show all major features\n   - Explain architecture decisions\n\n3. **Store Link**\n   - Google Play Store URL\n   - Or App Store URL\n   - Or TestFlight link\n\n4. **Documentation**\n   - README with setup steps\n   - Architecture diagram\n   - Known issues/limitations\n\n"
            },
            {
              "type": "THEORY",
              "title": "Congratulations! üéâ",
              "content": "\nYou've completed the **Flutter Training Course**! You've learned:\n\n- ‚úÖ Dart fundamentals\n- ‚úÖ Flutter widgets and layouts\n- ‚úÖ State management (Provider, BLoC)\n- ‚úÖ Navigation (GoRouter)\n- ‚úÖ Networking and APIs\n- ‚úÖ Firebase integration\n- ‚úÖ Advanced features (maps, camera, sensors)\n- ‚úÖ Testing (unit, widget, integration)\n- ‚úÖ Deployment (Play Store, App Store)\n\n**You are now a full-stack Flutter developer!**\n\n### What's Next?\n\n1. **Build More Apps**: Practice makes perfect\n2. **Contribute to Open Source**: Give back to the community\n3. **Learn Advanced Topics**: Animations, custom painters, platform channels\n4. **Specialize**: Web, desktop, or embedded\n5. **Teach Others**: Share your knowledge\n\n### Career Opportunities\n\nWith these skills, you can:\n- Freelance on Upwork, Fiverr\n- Apply for Flutter developer jobs\n- Build startup MVPs\n- Create passive income apps\n- Consult for companies\n\n**Salaries:**\n- Junior Flutter Developer: $50-70k/year\n- Mid-Level: $70-100k/year\n- Senior: $100-150k+/year\n- Freelance: $50-150/hour\n\n"
            },
            {
              "type": "THEORY",
              "title": "Final Challenge: Ship It! üöÄ",
              "content": "\nDon't just complete the project - **publish it**!\n\nSet a deadline (6-8 weeks) and commit to:\n1. Building LocalBuy (or your own idea)\n2. Testing thoroughly\n3. Publishing to at least one store\n4. Getting 100 downloads\n5. Maintaining 4+ star rating\n\n**Tag us when you launch:**\n- Twitter: #FlutterDev #LocalBuy\n- LinkedIn: Share your achievement\n- Reddit: r/FlutterDev\n\nWe can't wait to see what you build! üíô\n\n"
            },
            {
              "type": "THEORY",
              "title": "Course Complete! üéì",
              "content": "\n**Total Lessons: 78+**\n**Total Hours: 100+**\n**Projects Built: 15+**\n\nYou've gone from **zero to hero** in Flutter development. Be proud of how far you've come!\n\nNow go build something amazing. The world needs your apps! üåü\n\n"
            }
          ],
          "challenges": []
        }
      ]
    },
    {
      "id": "module-13",
      "title": "Module 13: Advanced State Management with Riverpod & Hooks",
      "description": "Master modern Flutter state management with Riverpod 2.0, code generation, and Flutter Hooks for clean, testable apps.",
      "difficulty": "intermediate",
      "estimatedHours": 8,
      "lessons": [
        {
          "id": "13.1",
          "title": "Module 13, Lesson 1: Why Riverpod? Provider Limitations",
          "moduleId": "module-13",
          "order": 1,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The Evolution of Flutter State Management",
              "content": "\nYou've learned Provider, and it works! So why learn another state management solution?\n\n**Provider's Limitations:**\n1. **Runtime errors**: `ProviderNotFoundException` crashes at runtime, not compile time\n2. **Context dependency**: Need `BuildContext` to read providers\n3. **Difficult testing**: Mocking providers requires widget tests\n4. **No code generation**: Manual boilerplate for every provider\n\n**Riverpod solves all of these:**\n- Compile-time safety (errors caught before running)\n- No BuildContext needed (access providers anywhere)\n- Easy unit testing (no widgets required)\n- Code generation reduces boilerplate by 80%\n\n"
            },
            {
              "type": "THEORY",
              "title": "Who Made Riverpod?",
              "content": "\nRiverpod was created by **Remi Rousselet**‚Äîthe same person who made Provider!\n\nHe built Riverpod to fix Provider's design flaws. The name 'Riverpod' is an anagram of 'Provider'.\n\nIn 2025, Riverpod is the recommended state management solution for production Flutter apps.\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Provider vs Riverpod Comparison",
              "content": "\n**Provider (what you know):**\n\n",
              "code": "// Provider: Must be inside widget tree\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => CartNotifier()),\n      ],\n      child: MaterialApp(...),\n    );\n  }\n}\n\n// Accessing: Needs BuildContext\nclass CartScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final cart = context.watch<CartNotifier>();\n    return Text('Items: ${cart.itemCount}');\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Riverpod Equivalent",
              "content": "\n**Riverpod (cleaner):**\n\n",
              "code": "// Riverpod: Providers defined globally\nfinal cartProvider = NotifierProvider<CartNotifier, CartState>(\n  CartNotifier.new,\n);\n\n// App setup: Just wrap with ProviderScope\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ProviderScope(\n      child: MaterialApp(...),\n    );\n  }\n}\n\n// Accessing: Extend ConsumerWidget\nclass CartScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final cart = ref.watch(cartProvider);\n    return Text('Items: ${cart.itemCount}');\n  }\n}",
              "language": "dart"
            }
          ],
          "challenges": [
            {
              "type": "QUIZ",
              "id": "13.1-quiz-0",
              "title": "Provider vs Riverpod Quiz",
              "description": "Test your understanding of Riverpod's advantages.",
              "questions": [
                {
                  "question": "What happens in Provider if you try to read a provider that wasn't added to the tree?",
                  "options": [
                    "Compile-time error",
                    "Runtime ProviderNotFoundException",
                    "Returns null",
                    "Uses a default value"
                  ],
                  "correctAnswer": 1,
                  "explanation": "Provider throws ProviderNotFoundException at runtime. Riverpod catches this at compile time."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "13.2",
          "title": "Module 13, Lesson 2: Riverpod Fundamentals",
          "moduleId": "module-13",
          "order": 2,
          "estimatedMinutes": 60,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Setting Up Riverpod",
              "content": "\n**Installation:**\n\nAdd to `pubspec.yaml`:\n```yaml\ndependencies:\n  flutter_riverpod: ^2.5.0\n\ndev_dependencies:\n  riverpod_generator: ^2.4.0\n  build_runner: ^2.4.0\n```\n\nRun: `flutter pub get`\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Three Pillars",
              "content": "\n**1. ProviderScope** - Wrap your app once\n```dart\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n```\n\n**2. Providers** - Define your state\n```dart\nfinal counterProvider = StateProvider<int>((ref) => 0);\n```\n\n**3. ConsumerWidget** - Read your state\n```dart\nclass CounterScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Text('$count');\n  }\n}\n```\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Provider Types",
              "content": "\n",
              "code": "// Provider: Read-only value\nfinal greetingProvider = Provider<String>((ref) => 'Hello!');\n\n// StateProvider: Simple mutable state\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\n// FutureProvider: Async data\nfinal usersProvider = FutureProvider<List<User>>((ref) async {\n  final response = await http.get(Uri.parse('/users'));\n  return User.fromJsonList(response.body);\n});\n\n// StreamProvider: Real-time data\nfinal messagesProvider = StreamProvider<Message>((ref) {\n  return firestore.collection('messages').snapshots();\n});\n\n// NotifierProvider: Complex state with methods\nfinal cartProvider = NotifierProvider<CartNotifier, CartState>(\n  CartNotifier.new,\n);",
              "language": "dart"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13.2-challenge-0",
              "title": "Counter with Riverpod",
              "description": "Implement a simple counter using Riverpod StateProvider.",
              "instructions": "Create a counter that increments and decrements using Riverpod.",
              "starterCode": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\n// TODO: Define counterProvider\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: CounterScreen(),\n    );\n  }\n}\n\n// TODO: Change to ConsumerWidget and implement",
              "solution": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nvoid main() {\n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: CounterScreen(),\n    );\n  }\n}\n\nclass CounterScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text(\n          '$count',\n          style: Theme.of(context).textTheme.headlineLarge,\n        ),\n      ),\n      floatingActionButton: Column(\n        mainAxisAlignment: .end,\n        children: [\n          FloatingActionButton(\n            onPressed: () => ref.read(counterProvider.notifier).state++,\n            child: const Icon(Icons.add),\n          ),\n          const SizedBox(height: 8),\n          FloatingActionButton(\n            onPressed: () => ref.read(counterProvider.notifier).state--,\n            child: const Icon(Icons.remove),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Defines counterProvider as StateProvider",
                  "expectedOutput": "StateProvider",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Uses ConsumerWidget",
                  "expectedOutput": "ConsumerWidget",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "StateProvider<int>((ref) => 0) creates a simple integer provider"
                },
                {
                  "level": 2,
                  "text": "Use ref.watch() to read and rebuild, ref.read() to just read"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using ref.watch in onPressed callbacks",
                  "consequence": "Causes unnecessary rebuilds",
                  "correction": "Use ref.read() in callbacks, ref.watch() in build()"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "13.3",
          "title": "Module 13, Lesson 3: Notifier & NotifierProvider",
          "moduleId": "module-13",
          "order": 3,
          "estimatedMinutes": 55,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "When StateProvider Isn't Enough",
              "content": "\nStateProvider is great for simple values (int, bool, String), but what about:\n- Complex objects with multiple fields?\n- State that needs validation?\n- Actions that should be methods?\n\nThat's where **Notifier** comes in!\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Building a Todo Notifier",
              "content": "\n",
              "code": "// State class\n@immutable\nclass TodosState {\n  const TodosState({this.todos = const []});\n  final List<Todo> todos;\n\n  TodosState copyWith({List<Todo>? todos}) {\n    return TodosState(todos: todos ?? this.todos);\n  }\n}\n\n// Notifier class\nclass TodosNotifier extends Notifier<TodosState> {\n  @override\n  TodosState build() => const TodosState();\n\n  void addTodo(String title) {\n    final newTodo = Todo(id: uuid.v4(), title: title);\n    state = state.copyWith(todos: [...state.todos, newTodo]);\n  }\n\n  void toggleTodo(String id) {\n    state = state.copyWith(\n      todos: state.todos.map((todo) {\n        if (todo.id == id) {\n          return todo.copyWith(completed: !todo.completed);\n        }\n        return todo;\n      }).toList(),\n    );\n  }\n\n  void removeTodo(String id) {\n    state = state.copyWith(\n      todos: state.todos.where((t) => t.id != id).toList(),\n    );\n  }\n}\n\n// Provider definition\nfinal todosProvider = NotifierProvider<TodosNotifier, TodosState>(\n  TodosNotifier.new,\n);",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Using the Notifier",
              "content": "\n",
              "code": "class TodoScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final todosState = ref.watch(todosProvider);\n\n    return Scaffold(\n      body: ListView.builder(\n        itemCount: todosState.todos.length,\n        itemBuilder: (context, index) {\n          final todo = todosState.todos[index];\n          return ListTile(\n            title: Text(todo.title),\n            leading: Checkbox(\n              value: todo.completed,\n              onChanged: (_) {\n                ref.read(todosProvider.notifier).toggleTodo(todo.id);\n              },\n            ),\n            trailing: IconButton(\n              icon: const Icon(Icons.delete),\n              onPressed: () {\n                ref.read(todosProvider.notifier).removeTodo(todo.id);\n              },\n            ),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => _showAddDialog(context, ref),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}",
              "language": "dart"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13.3-challenge-0",
              "title": "Shopping Cart Notifier",
              "description": "Build a shopping cart using Notifier pattern.",
              "instructions": "Create a CartNotifier with addItem, removeItem, and clearCart methods.",
              "starterCode": "// TODO: Create CartItem class\n// TODO: Create CartState class with items list and total\n// TODO: Create CartNotifier extending Notifier<CartState>\n// TODO: Create cartProvider",
              "solution": "@immutable\nclass CartItem {\n  const CartItem({\n    required this.id,\n    required this.name,\n    required this.price,\n    this.quantity = 1,\n  });\n  final String id;\n  final String name;\n  final double price;\n  final int quantity;\n\n  CartItem copyWith({int? quantity}) {\n    return CartItem(\n      id: id,\n      name: name,\n      price: price,\n      quantity: quantity ?? this.quantity,\n    );\n  }\n}\n\n@immutable\nclass CartState {\n  const CartState({this.items = const []});\n  final List<CartItem> items;\n\n  double get total => items.fold(0, (sum, item) => sum + item.price * item.quantity);\n  int get itemCount => items.fold(0, (sum, item) => sum + item.quantity);\n\n  CartState copyWith({List<CartItem>? items}) {\n    return CartState(items: items ?? this.items);\n  }\n}\n\nclass CartNotifier extends Notifier<CartState> {\n  @override\n  CartState build() => const CartState();\n\n  void addItem(CartItem item) {\n    final existingIndex = state.items.indexWhere((i) => i.id == item.id);\n    if (existingIndex >= 0) {\n      final existing = state.items[existingIndex];\n      final updated = existing.copyWith(quantity: existing.quantity + 1);\n      state = state.copyWith(\n        items: [...state.items]..replaceRange(existingIndex, existingIndex + 1, [updated]),\n      );\n    } else {\n      state = state.copyWith(items: [...state.items, item]);\n    }\n  }\n\n  void removeItem(String id) {\n    state = state.copyWith(\n      items: state.items.where((i) => i.id != id).toList(),\n    );\n  }\n\n  void clearCart() {\n    state = const CartState();\n  }\n}\n\nfinal cartProvider = NotifierProvider<CartNotifier, CartState>(\n  CartNotifier.new,\n);",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "CartNotifier extends Notifier",
                  "expectedOutput": "extends Notifier",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Has addItem method",
                  "expectedOutput": "void addItem",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Use @immutable classes for state"
                },
                {
                  "level": 2,
                  "text": "Remember: state = newState triggers rebuilds"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Mutating state.items directly",
                  "consequence": "UI won't update",
                  "correction": "Always create new state object with copyWith"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "13.4",
          "title": "Module 13, Lesson 4: Riverpod Generator & Code Generation",
          "moduleId": "module-13",
          "order": 4,
          "estimatedMinutes": 50,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Code Generation?",
              "content": "\nWriting providers manually works, but it's verbose. Riverpod Generator reduces boilerplate by 80%:\n\n**Before (manual):**\n```dart\nfinal usersProvider = FutureProvider<List<User>>((ref) async {\n  final response = await ref.watch(httpClientProvider).get('/users');\n  return response.map(User.fromJson).toList();\n});\n```\n\n**After (with @riverpod):**\n```dart\n@riverpod\nFuture<List<User>> users(UsersRef ref) async {\n  final response = await ref.watch(httpClientProvider).get('/users');\n  return response.map(User.fromJson).toList();\n}\n```\n\nThe generator creates the provider for you!\n\n"
            },
            {
              "type": "THEORY",
              "title": "Setup",
              "content": "\nAdd these imports to your file:\n```dart\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'your_file.g.dart';\n```\n\nRun code generation:\n```bash\ndart run build_runner watch\n```\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Generated Providers",
              "content": "\n",
              "code": "import 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'users_provider.g.dart';\n\n// Simple provider (no state)\n@riverpod\nString greeting(GreetingRef ref) => 'Hello!';\n\n// Future provider\n@riverpod\nFuture<List<User>> fetchUsers(FetchUsersRef ref) async {\n  final client = ref.watch(httpClientProvider);\n  final response = await client.get('/users');\n  return User.fromJsonList(response.body);\n}\n\n// Notifier (with state)\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n  void decrement() => state--;\n}\n\n// Usage is the same!\n// ref.watch(greetingProvider)\n// ref.watch(fetchUsersProvider)\n// ref.watch(counterProvider)",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Keep Alive vs Auto Dispose",
              "content": "\nBy default, generated providers auto-dispose when no longer watched.\n\n**Keep state alive (cached):**\n```dart\n@Riverpod(keepAlive: true)\nFuture<Config> appConfig(AppConfigRef ref) async {\n  return loadConfig();\n}\n```\n\n**Auto dispose (default):**\n```dart\n@riverpod\nFuture<User> userProfile(UserProfileRef ref) async {\n  return fetchProfile();\n}\n```\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13.4-challenge-0",
              "title": "Convert to Generated Providers",
              "description": "Refactor manual providers to use @riverpod annotations.",
              "instructions": "Convert the manual FutureProvider to use code generation.",
              "starterCode": "// Manual provider - convert this to @riverpod\nfinal weatherProvider = FutureProvider<Weather>((ref) async {\n  final location = ref.watch(locationProvider);\n  final response = await http.get(\n    Uri.parse('api.weather.com?lat=${location.lat}&lon=${location.lon}'),\n  );\n  return Weather.fromJson(jsonDecode(response.body));\n});",
              "solution": "import 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'weather_provider.g.dart';\n\n@riverpod\nFuture<Weather> weather(WeatherRef ref) async {\n  final location = ref.watch(locationProvider);\n  final response = await http.get(\n    Uri.parse('api.weather.com?lat=${location.lat}&lon=${location.lon}'),\n  );\n  return Weather.fromJson(jsonDecode(response.body));\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Uses @riverpod annotation",
                  "expectedOutput": "@riverpod",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Function has Ref parameter",
                  "expectedOutput": "WeatherRef ref",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Add part directive for generated file"
                },
                {
                  "level": 2,
                  "text": "Function name becomes provider name (weather -> weatherProvider)"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting part directive",
                  "consequence": "Code generation fails",
                  "correction": "Add: part 'filename.g.dart';"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "13.5",
          "title": "Module 13, Lesson 5: AsyncValue & Error Handling",
          "moduleId": "module-13",
          "order": 5,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "The AsyncValue Pattern",
              "content": "\nWhen dealing with async data (FutureProvider, StreamProvider), Riverpod wraps the result in `AsyncValue<T>`.\n\nAsyncValue has three states:\n- `AsyncData<T>` - Success with data\n- `AsyncError` - Failure with error\n- `AsyncLoading` - Still loading\n\nThis forces you to handle all states‚Äîno more forgotten loading spinners!\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Using .when()",
              "content": "\n",
              "code": "class UserProfileScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userAsync = ref.watch(userProvider);\n\n    return userAsync.when(\n      data: (user) => UserCard(user: user),\n      loading: () => const CircularProgressIndicator(),\n      error: (error, stack) => ErrorWidget(\n        message: error.toString(),\n        onRetry: () => ref.invalidate(userProvider),\n      ),\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Pattern Matching Alternative",
              "content": "\n",
              "code": "Widget build(BuildContext context, WidgetRef ref) {\n  final userAsync = ref.watch(userProvider);\n\n  return switch (userAsync) {\n    AsyncData(:final value) => UserCard(user: value),\n    AsyncError(:final error) => Text('Error: $error'),\n    AsyncLoading() => const CircularProgressIndicator(),\n  };\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Refreshing & Invalidating",
              "content": "\n**Invalidate**: Marks provider as stale, refetches on next read\n```dart\nref.invalidate(userProvider);\n```\n\n**Refresh**: Invalidates AND immediately refetches\n```dart\nawait ref.refresh(userProvider.future);\n```\n\nUse refresh for pull-to-refresh, invalidate for cache clearing.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13.5-challenge-0",
              "title": "Products List with Error Handling",
              "description": "Build a products list that properly handles loading, error, and data states.",
              "instructions": "Use AsyncValue.when to handle all states with proper UI.",
              "starterCode": "@riverpod\nFuture<List<Product>> products(ProductsRef ref) async {\n  // Simulated API call\n  await Future.delayed(const Duration(seconds: 2));\n  if (Random().nextBool()) throw Exception('Network error');\n  return [Product(name: 'Widget', price: 9.99)];\n}\n\nclass ProductsScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // TODO: Watch productsProvider\n    // TODO: Use .when() to handle all states\n    return const Placeholder();\n  }\n}",
              "solution": "@riverpod\nFuture<List<Product>> products(ProductsRef ref) async {\n  await Future.delayed(const Duration(seconds: 2));\n  if (Random().nextBool()) throw Exception('Network error');\n  return [Product(name: 'Widget', price: 9.99)];\n}\n\nclass ProductsScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final productsAsync = ref.watch(productsProvider);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Products'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.refresh),\n            onPressed: () => ref.invalidate(productsProvider),\n          ),\n        ],\n      ),\n      body: productsAsync.when(\n        data: (products) => ListView.builder(\n          itemCount: products.length,\n          itemBuilder: (context, index) {\n            final product = products[index];\n            return ListTile(\n              title: Text(product.name),\n              trailing: Text('\\$${product.price}'),\n            );\n          },\n        ),\n        loading: () => const Center(child: CircularProgressIndicator()),\n        error: (error, stack) => Center(\n          child: Column(\n            mainAxisAlignment: .center,\n            children: [\n              Text('Error: $error'),\n              const SizedBox(height: 16),\n              ElevatedButton(\n                onPressed: () => ref.invalidate(productsProvider),\n                child: const Text('Retry'),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Uses .when() method",
                  "expectedOutput": ".when(",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Has retry functionality",
                  "expectedOutput": "ref.invalidate",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "AsyncValue.when takes data, loading, and error callbacks"
                },
                {
                  "level": 2,
                  "text": "Use ref.invalidate() to retry failed requests"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting error state handling",
                  "consequence": "App crashes on network errors",
                  "correction": "Always provide error callback in .when()"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "13.6",
          "title": "Module 13, Lesson 6: Flutter Hooks Fundamentals",
          "moduleId": "module-13",
          "order": 6,
          "estimatedMinutes": 50,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "What Are Flutter Hooks?",
              "content": "\nFlutter Hooks bring React-style hooks to Flutter. They simplify StatefulWidget lifecycle management.\n\n**Problem**: StatefulWidgets require lots of boilerplate for controllers, animations, subscriptions.\n\n**Solution**: Hooks extract that logic into reusable functions.\n\n**Installation**:\n```yaml\ndependencies:\n  flutter_hooks: ^0.20.0\n  hooks_riverpod: ^2.5.0  # Combines hooks + riverpod\n```\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Before Hooks (StatefulWidget)",
              "content": "\n",
              "code": "class FormScreen extends StatefulWidget {\n  @override\n  State<FormScreen> createState() => _FormScreenState();\n}\n\nclass _FormScreenState extends State<FormScreen> {\n  late TextEditingController _nameController;\n  late TextEditingController _emailController;\n  late FocusNode _nameFocus;\n  late FocusNode _emailFocus;\n\n  @override\n  void initState() {\n    super.initState();\n    _nameController = TextEditingController();\n    _emailController = TextEditingController();\n    _nameFocus = FocusNode();\n    _emailFocus = FocusNode();\n  }\n\n  @override\n  void dispose() {\n    _nameController.dispose();\n    _emailController.dispose();\n    _nameFocus.dispose();\n    _emailFocus.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TextField(controller: _nameController, focusNode: _nameFocus),\n        TextField(controller: _emailController, focusNode: _emailFocus),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "After Hooks (HookWidget)",
              "content": "\n",
              "code": "class FormScreen extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final nameController = useTextEditingController();\n    final emailController = useTextEditingController();\n    final nameFocus = useFocusNode();\n    final emailFocus = useFocusNode();\n\n    return Column(\n      children: [\n        TextField(controller: nameController, focusNode: nameFocus),\n        TextField(controller: emailController, focusNode: emailFocus),\n      ],\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Common Hooks",
              "content": "\n| Hook | Purpose |\n|------|--------|\n| `useState<T>()` | Local state (like setState) |\n| `useEffect()` | Side effects (API calls, subscriptions) |\n| `useMemoized()` | Expensive computations (caching) |\n| `useTextEditingController()` | TextEditingController lifecycle |\n| `useFocusNode()` | FocusNode lifecycle |\n| `useAnimationController()` | Animation controller lifecycle |\n| `useTabController()` | TabController lifecycle |\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13.6-challenge-0",
              "title": "Timer with Hooks",
              "description": "Build a stopwatch using useState and useEffect.",
              "instructions": "Create a timer that counts up every second using hooks.",
              "starterCode": "class StopwatchScreen extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    // TODO: Use useState for seconds count\n    // TODO: Use useState for isRunning state\n    // TODO: Use useEffect to set up timer\n\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: .center,\n          children: [\n            Text('0 seconds', style: Theme.of(context).textTheme.headlineLarge),\n            Row(\n              mainAxisAlignment: .center,\n              children: [\n                ElevatedButton(onPressed: () {}, child: const Text('Start')),\n                const SizedBox(width: 16),\n                ElevatedButton(onPressed: () {}, child: const Text('Reset')),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "solution": "class StopwatchScreen extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final seconds = useState(0);\n    final isRunning = useState(false);\n\n    useEffect(() {\n      Timer? timer;\n      if (isRunning.value) {\n        timer = Timer.periodic(const Duration(seconds: 1), (_) {\n          seconds.value++;\n        });\n      }\n      return () => timer?.cancel();\n    }, [isRunning.value]);\n\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: .center,\n          children: [\n            Text(\n              '${seconds.value} seconds',\n              style: Theme.of(context).textTheme.headlineLarge,\n            ),\n            const SizedBox(height: 32),\n            Row(\n              mainAxisAlignment: .center,\n              children: [\n                ElevatedButton(\n                  onPressed: () => isRunning.value = !isRunning.value,\n                  child: Text(isRunning.value ? 'Stop' : 'Start'),\n                ),\n                const SizedBox(width: 16),\n                ElevatedButton(\n                  onPressed: () {\n                    seconds.value = 0;\n                    isRunning.value = false;\n                  },\n                  child: const Text('Reset'),\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Uses useState hook",
                  "expectedOutput": "useState",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Uses useEffect hook",
                  "expectedOutput": "useEffect",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "useState returns a ValueNotifier - access value with .value"
                },
                {
                  "level": 2,
                  "text": "useEffect's cleanup function cancels the timer"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not providing keys to useEffect",
                  "consequence": "Effect runs every build",
                  "correction": "Add [isRunning.value] as keys to only run when state changes"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "13.7",
          "title": "Module 13, Lesson 7: Combining Riverpod + Hooks",
          "moduleId": "module-13",
          "order": 7,
          "estimatedMinutes": 45,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "HookConsumerWidget",
              "content": "\nThe `hooks_riverpod` package gives you `HookConsumerWidget`‚Äîcombining the power of both!\n\n```dart\n// Instead of choosing one:\nclass MyWidget extends HookWidget { } // Hooks only\nclass MyWidget extends ConsumerWidget { } // Riverpod only\n\n// Use both:\nclass MyWidget extends HookConsumerWidget { } // Best of both worlds!\n```\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Search with Debounce",
              "content": "\nCombine hooks for local state with Riverpod for async data:\n\n",
              "code": "@riverpod\nFuture<List<Product>> searchProducts(\n  SearchProductsRef ref,\n  String query,\n) async {\n  if (query.isEmpty) return [];\n  final response = await http.get(Uri.parse('/search?q=$query'));\n  return Product.fromJsonList(response.body);\n}\n\nclass SearchScreen extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Local state with hooks\n    final searchController = useTextEditingController();\n    final debouncedQuery = useDebounced(searchController.text, const Duration(milliseconds: 500));\n\n    // Remote state with Riverpod\n    final searchResults = ref.watch(searchProductsProvider(debouncedQuery ?? ''));\n\n    return Scaffold(\n      appBar: AppBar(\n        title: TextField(\n          controller: searchController,\n          decoration: const InputDecoration(hintText: 'Search...'),\n          onChanged: (_) => setState(() {}), // Trigger rebuild\n        ),\n      ),\n      body: searchResults.when(\n        data: (products) => ListView.builder(\n          itemCount: products.length,\n          itemBuilder: (_, i) => ListTile(title: Text(products[i].name)),\n        ),\n        loading: () => const Center(child: CircularProgressIndicator()),\n        error: (e, _) => Center(child: Text('Error: $e')),\n      ),\n    );\n  }\n}\n\n// Custom debounce hook\nT? useDebounced<T>(T value, Duration delay) {\n  final debouncedValue = useState<T?>(null);\n\n  useEffect(() {\n    final timer = Timer(delay, () => debouncedValue.value = value);\n    return timer.cancel;\n  }, [value, delay]);\n\n  return debouncedValue.value;\n}",
              "language": "dart"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "13.7-challenge-0",
              "title": "Infinite Scroll List",
              "description": "Build a paginated list using hooks for scroll position and Riverpod for data.",
              "instructions": "Create an infinite scroll list that loads more items when reaching the bottom.",
              "starterCode": "// TODO: Create a HookConsumerWidget\n// TODO: Use useScrollController for pagination detection\n// TODO: Use Riverpod for fetching paginated data",
              "solution": "@riverpod\nclass PaginatedProducts extends _$PaginatedProducts {\n  @override\n  Future<List<Product>> build() async {\n    return _fetchPage(0);\n  }\n\n  Future<List<Product>> _fetchPage(int page) async {\n    final response = await http.get(Uri.parse('/products?page=$page'));\n    return Product.fromJsonList(response.body);\n  }\n\n  Future<void> loadMore() async {\n    final currentProducts = state.valueOrNull ?? [];\n    final nextPage = currentProducts.length ~/ 20;\n    final newProducts = await _fetchPage(nextPage);\n    state = AsyncData([...currentProducts, ...newProducts]);\n  }\n}\n\nclass ProductListScreen extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final scrollController = useScrollController();\n    final products = ref.watch(paginatedProductsProvider);\n    final isLoadingMore = useState(false);\n\n    useEffect(() {\n      void onScroll() async {\n        if (scrollController.position.pixels >= \n            scrollController.position.maxScrollExtent - 200) {\n          if (!isLoadingMore.value) {\n            isLoadingMore.value = true;\n            await ref.read(paginatedProductsProvider.notifier).loadMore();\n            isLoadingMore.value = false;\n          }\n        }\n      }\n      scrollController.addListener(onScroll);\n      return () => scrollController.removeListener(onScroll);\n    }, [scrollController]);\n\n    return products.when(\n      data: (items) => ListView.builder(\n        controller: scrollController,\n        itemCount: items.length + (isLoadingMore.value ? 1 : 0),\n        itemBuilder: (_, i) {\n          if (i >= items.length) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          return ListTile(title: Text(items[i].name));\n        },\n      ),\n      loading: () => const Center(child: CircularProgressIndicator()),\n      error: (e, _) => Center(child: Text('Error: $e')),\n    );\n  }\n}",
              "language": "dart",
              "testCases": [
                {
                  "id": "test-1",
                  "description": "Uses HookConsumerWidget",
                  "expectedOutput": "HookConsumerWidget",
                  "isVisible": true
                },
                {
                  "id": "test-2",
                  "description": "Uses useScrollController",
                  "expectedOutput": "useScrollController",
                  "isVisible": true
                }
              ],
              "hints": [
                {
                  "level": 1,
                  "text": "Check scrollController.position.pixels vs maxScrollExtent"
                },
                {
                  "level": 2,
                  "text": "Add a loading indicator at the bottom while fetching"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not preventing duplicate loadMore calls",
                  "consequence": "Fetches same page multiple times",
                  "correction": "Use isLoadingMore flag to prevent concurrent calls"
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "13.8",
          "title": "Module 13, Lesson 8: Mini-Project - Todo App with Riverpod",
          "moduleId": "module-13",
          "order": 8,
          "estimatedMinutes": 90,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\nBuild a complete Todo app using everything from this module:\n\n**Features:**\n- Add, edit, delete todos\n- Filter by status (all, active, completed)\n- Persist to local storage\n- Pull-to-refresh simulation\n\n**Stack:**\n- Riverpod for state management\n- Code generation with @riverpod\n- Flutter Hooks for local state\n- AsyncValue for loading states\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Project Structure",
              "content": "\n",
              "code": "lib/\n  main.dart\n  models/\n    todo.dart\n  providers/\n    todos_provider.dart      # Notifier + Provider\n    filter_provider.dart     # Filter state\n    filtered_todos.dart      # Computed provider\n  screens/\n    todos_screen.dart        # Main UI\n  widgets/\n    todo_tile.dart           # Single todo item\n    add_todo_dialog.dart     # Add/edit form",
              "language": "plaintext"
            },
            {
              "type": "EXAMPLE",
              "title": "Core Providers",
              "content": "\n",
              "code": "// models/todo.dart\n@freezed\nclass Todo with _$Todo {\n  const factory Todo({\n    required String id,\n    required String title,\n    @Default(false) bool completed,\n  }) = _Todo;\n}\n\n// providers/todos_provider.dart\n@riverpod\nclass Todos extends _$Todos {\n  @override\n  Future<List<Todo>> build() async {\n    // Simulate API fetch\n    await Future.delayed(const Duration(seconds: 1));\n    return [\n      const Todo(id: '1', title: 'Learn Riverpod'),\n      const Todo(id: '2', title: 'Build awesome apps'),\n    ];\n  }\n\n  void addTodo(String title) {\n    final newTodo = Todo(id: const Uuid().v4(), title: title);\n    state = AsyncData([...state.value ?? [], newTodo]);\n  }\n\n  void toggleTodo(String id) {\n    state = AsyncData(\n      state.value?.map((t) => t.id == id ? t.copyWith(completed: !t.completed) : t).toList() ?? [],\n    );\n  }\n\n  void deleteTodo(String id) {\n    state = AsyncData(\n      state.value?.where((t) => t.id != id).toList() ?? [],\n    );\n  }\n}\n\n// providers/filter_provider.dart\nenum TodoFilter { all, active, completed }\n\n@riverpod\nclass Filter extends _$Filter {\n  @override\n  TodoFilter build() => TodoFilter.all;\n\n  void setFilter(TodoFilter filter) => state = filter;\n}\n\n// providers/filtered_todos.dart\n@riverpod\nList<Todo> filteredTodos(FilteredTodosRef ref) {\n  final filter = ref.watch(filterProvider);\n  final todosAsync = ref.watch(todosProvider);\n\n  return todosAsync.when(\n    data: (todos) => switch (filter) {\n      TodoFilter.all => todos,\n      TodoFilter.active => todos.where((t) => !t.completed).toList(),\n      TodoFilter.completed => todos.where((t) => t.completed).toList(),\n    },\n    loading: () => [],\n    error: (_, __) => [],\n  );\n}",
              "language": "dart"
            }
          ],
          "challenges": [
            {
              "type": "PROJECT",
              "id": "13.8-project-0",
              "title": "Complete Todo App",
              "description": "Build a fully functional Todo app with Riverpod + Hooks.",
              "instructions": "1. Set up project with riverpod_generator\\n2. Create Todo model with freezed\\n3. Implement TodosNotifier with CRUD operations\\n4. Add filter functionality\\n5. Build UI with HookConsumerWidget\\n6. Add pull-to-refresh\\n7. Handle loading and error states",
              "starterCode": "// Start with: flutter create todo_riverpod\n// Add dependencies:\n// flutter_riverpod, riverpod_annotation, riverpod_generator\n// hooks_riverpod, flutter_hooks\n// freezed_annotation, freezed, build_runner\n// uuid",
              "solution": "// See complete project at:\n// github.com/flutter-examples/riverpod-todo-app\n\n// Key implementation patterns shown in lesson content above.",
              "language": "dart",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Run 'dart run build_runner watch' during development"
                },
                {
                  "level": 2,
                  "text": "Use AsyncValue.when for all loading states"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to wrap app with ProviderScope",
                  "consequence": "Riverpod providers don't work",
                  "correction": "Wrap MaterialApp with ProviderScope in main()"
                }
              ],
              "difficulty": "advanced"
            }
          ]
        }
      ]
    },
    {
      "id": "module-14",
      "title": "Module 14: Flutter Web with WebAssembly (Wasm)",
      "description": "Build and deploy production-ready Flutter web applications with WebAssembly for optimal performance.",
      "difficulty": "intermediate",
      "estimatedHours": 6,
      "lessons": [
        {
          "id": "14.1",
          "title": "Module 14, Lesson 1: Flutter Web Architecture",
          "moduleId": "module-14",
          "order": 1,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Three Rendering Modes",
              "content": "\nFlutter Web supports three rendering backends, each with different tradeoffs:\n\n**1. HTML Renderer**\n- Uses standard HTML, CSS, and Canvas elements\n- Smallest download size (~200KB compressed)\n- Best compatibility with older browsers\n- Good for text-heavy apps\n\n**2. CanvasKit Renderer**\n- Uses Skia compiled to WebAssembly\n- Pixel-perfect rendering matching mobile\n- Larger download (~2.5MB)\n- Best for graphics-intensive apps\n\n**3. WebAssembly (Wasm) Renderer** (Flutter 3.22+)\n- Compiles Dart directly to Wasm\n- 2x faster startup than JavaScript\n- Smaller bundle sizes\n- Native-like performance\n\n"
            },
            {
              "type": "THEORY",
              "title": "When to Use Each Mode",
              "content": "\n**Choose HTML when:**\n- SEO is critical (search engine indexing)\n- Download size must be minimal\n- Supporting legacy browsers\n- Building content-focused sites\n\n**Choose CanvasKit when:**\n- Visual fidelity is paramount\n- Complex animations and graphics\n- Consistency with mobile app appearance\n- Rich data visualizations\n\n**Choose Wasm when:**\n- Performance is the priority\n- Modern browser audience (Chrome 119+, Firefox 120+, Safari 18+)\n- Production apps in 2024+\n- You want the smallest startup time\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Wasm Advantages",
              "content": "\n**Why Wasm is the future of Flutter Web:**\n\n- **2x Faster Startup**: Wasm loads and initializes faster than JavaScript\n- **Smaller Bundles**: More efficient binary format\n- **Better Performance**: Near-native execution speed\n- **Improved Memory**: More predictable memory management\n- **Type Safety**: Wasm's type system prevents classes of bugs\n\nGoogle recommends Wasm for all new Flutter web projects in 2024+.\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Specifying Renderer Mode",
              "content": "\nYou can specify the renderer in your index.html or via build flags:\n\n",
              "code": "// In web/index.html - Auto-select renderer\n<script>\n  // Let Flutter choose the best renderer\n  _flutter.loader.load();\n</script>\n\n// Force CanvasKit renderer\n<script>\n  _flutter.loader.load({\n    config: {\n      renderer: 'canvaskit',\n    },\n  });\n</script>\n\n// Build commands for different renderers:\n// HTML: flutter build web --web-renderer html\n// CanvasKit: flutter build web --web-renderer canvaskit\n// Wasm: flutter build web --wasm",
              "language": "dart"
            }
          ],
          "challenges": [
            {
              "type": "QUIZ",
              "id": "14.1-quiz-0",
              "title": "Flutter Web Rendering Quiz",
              "description": "Test your understanding of Flutter web rendering modes.",
              "questions": [
                {
                  "question": "Which renderer provides 2x faster startup times?",
                  "options": [
                    "HTML renderer",
                    "CanvasKit renderer",
                    "WebAssembly (Wasm) renderer",
                    "SVG renderer"
                  ],
                  "correctAnswer": 2,
                  "explanation": "WebAssembly (Wasm) provides approximately 2x faster startup times compared to JavaScript-based renderers."
                },
                {
                  "question": "When should you choose the HTML renderer?",
                  "options": [
                    "For graphics-intensive applications",
                    "When SEO and download size are critical",
                    "For gaming applications",
                    "When targeting only modern browsers"
                  ],
                  "correctAnswer": 1,
                  "explanation": "HTML renderer is best when SEO matters and you need the smallest download size, as it uses standard web technologies that search engines can index."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "14.2",
          "title": "Module 14, Lesson 2: Building for Wasm",
          "moduleId": "module-14",
          "order": 2,
          "estimatedMinutes": 35,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Development with Wasm",
              "content": "\n**Running in Development:**\n\nTo test your app with Wasm during development:\n\n```bash\nflutter run -d chrome --wasm\n```\n\nThis compiles your Dart code to WebAssembly and serves it with hot reload support (where available).\n\n**Requirements:**\n- Flutter 3.22 or newer\n- Chrome 119+ or Firefox 120+ for testing\n- No special configuration needed for most apps\n\n"
            },
            {
              "type": "THEORY",
              "title": "Production Build",
              "content": "\n**Building for Production:**\n\n```bash\nflutter build web --wasm\n```\n\nThis creates an optimized Wasm build in `build/web/`.\n\n**Build Output:**\n```\nbuild/web/\n‚îú‚îÄ‚îÄ main.dart.wasm      # Your compiled Dart code\n‚îú‚îÄ‚îÄ main.dart.mjs       # JavaScript glue code\n‚îú‚îÄ‚îÄ flutter.js          # Flutter loader\n‚îú‚îÄ‚îÄ flutter_bootstrap.js # Bootstrap script\n‚îú‚îÄ‚îÄ index.html          # Entry point\n‚îú‚îÄ‚îÄ manifest.json       # PWA manifest\n‚îú‚îÄ‚îÄ assets/             # Images, fonts, etc.\n‚îî‚îÄ‚îÄ canvaskit/          # Fallback renderer\n```\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Build Commands Reference",
              "content": "\n",
              "code": "# Development - run with Wasm in Chrome\nflutter run -d chrome --wasm\n\n# Production build with Wasm\nflutter build web --wasm\n\n# Production with release optimizations\nflutter build web --wasm --release\n\n# Check build output size\ndu -sh build/web/\n\n# Serve locally to test production build\ncd build/web && python3 -m http.server 8080\n\n# Or use Flutter's built-in server\nflutter run -d web-server --web-port 8080 --wasm",
              "language": "bash"
            },
            {
              "type": "KEY_POINT",
              "title": "Wasm Build Requirements",
              "content": "\n**What works with Wasm:**\n- Most Flutter widgets and APIs\n- All Dart language features\n- Popular packages (check pub.dev for compatibility)\n- Platform channels (with JS interop)\n\n**Current limitations:**\n- Some plugins need Wasm-compatible versions\n- Debugging experience is improving\n- Source maps support is evolving\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14.2-challenge-0",
              "title": "Build a Basic App with Wasm",
              "description": "Create a Flutter web app and build it with WebAssembly.",
              "instructions": "Create a simple counter app and build it for web using the --wasm flag. Examine the output files.",
              "starterCode": "// Create a new Flutter project:\n// flutter create my_wasm_app\n// cd my_wasm_app\n\n// Run with Wasm:\n// flutter run -d chrome --wasm\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Wasm Demo',\n      home: const CounterPage(),\n    );\n  }\n}\n\nclass CounterPage extends StatefulWidget {\n  const CounterPage({super.key});\n\n  @override\n  State<CounterPage> createState() => _CounterPageState();\n}\n\nclass _CounterPageState extends State<CounterPage> {\n  int _counter = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Wasm Counter'),\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            const Text('You have pushed the button this many times:'),\n            Text(\n              '$_counter',\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => setState(() => _counter++),\n        tooltip: 'Increment',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}",
              "solution": "// Build commands:\n// flutter build web --wasm\n//\n// Output structure in build/web/:\n// - main.dart.wasm (compiled Dart code)\n// - main.dart.mjs (JS glue code)\n// - flutter.js (loader)\n// - index.html (entry point)\n// - assets/ (resources)\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Wasm Demo',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n      ),\n      home: const CounterPage(),\n    );\n  }\n}\n\nclass CounterPage extends StatefulWidget {\n  const CounterPage({super.key});\n\n  @override\n  State<CounterPage> createState() => _CounterPageState();\n}\n\nclass _CounterPageState extends State<CounterPage> {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Wasm Counter'),\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            const Text('You have pushed the button this many times:'),\n            Text(\n              '$_counter',\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n            const SizedBox(height: 20),\n            const Text(\n              'Built with WebAssembly!',\n              style: TextStyle(color: Colors.green),\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _incrementCounter,\n        tooltip: 'Increment',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}",
              "language": "dart",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Make sure you have Flutter 3.22+ installed"
                },
                {
                  "level": 2,
                  "text": "Use 'flutter build web --wasm' for production builds"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Using an older Flutter version",
                  "consequence": "Wasm build flag not available",
                  "correction": "Upgrade to Flutter 3.22 or newer with 'flutter upgrade'"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "14.3",
          "title": "Module 14, Lesson 3: Browser Compatibility",
          "moduleId": "module-14",
          "order": 3,
          "estimatedMinutes": 30,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Wasm Browser Support",
              "content": "\n**Browsers that support Wasm GC (required for Flutter Wasm):**\n\n| Browser | Minimum Version | Release Date |\n|---------|-----------------|---------------|\n| Chrome | 119+ | Nov 2023 |\n| Firefox | 120+ | Nov 2023 |\n| Safari | 18+ | Sep 2024 |\n| Edge | 119+ | Nov 2023 |\n\n**Global Support (2024):**\n- ~85% of desktop users\n- ~75% of mobile users\n- Growing monthly\n\n"
            },
            {
              "type": "THEORY",
              "title": "Feature Detection Patterns",
              "content": "\nDetect Wasm support before loading your app:\n\n**In JavaScript (index.html):**\n```javascript\nfunction supportsWasmGC() {\n  try {\n    // Check for Wasm GC proposal support\n    return typeof WebAssembly.validate === 'function' &&\n           WebAssembly.validate(new Uint8Array([\n             0x00, 0x61, 0x73, 0x6d, // Wasm magic\n             0x01, 0x00, 0x00, 0x00, // Version\n           ]));\n  } catch (e) {\n    return false;\n  }\n}\n```\n\nFlutter's loader handles this automatically and falls back to CanvasKit when needed.\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Platform Detection in Dart",
              "content": "\n",
              "code": "import 'package:flutter/foundation.dart';\n\nclass PlatformInfo {\n  // Check if running on web\n  static bool get isWeb => kIsWeb;\n\n  // Check platform at runtime\n  static String get currentPlatform {\n    if (kIsWeb) {\n      return 'Web';\n    }\n    switch (defaultTargetPlatform) {\n      case TargetPlatform.android:\n        return 'Android';\n      case TargetPlatform.iOS:\n        return 'iOS';\n      case TargetPlatform.macOS:\n        return 'macOS';\n      case TargetPlatform.windows:\n        return 'Windows';\n      case TargetPlatform.linux:\n        return 'Linux';\n      case TargetPlatform.fuchsia:\n        return 'Fuchsia';\n    }\n  }\n}\n\n// Usage in widgets\nclass MyWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    if (kIsWeb) {\n      // Web-specific UI\n      return WebOptimizedLayout();\n    }\n    return MobileLayout();\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Fallback Strategies",
              "content": "\n**Flutter's Automatic Fallback:**\nFlutter's web loader automatically detects browser capabilities and falls back gracefully:\n\n1. **Try Wasm** - If browser supports Wasm GC\n2. **Fall back to CanvasKit** - If Wasm not available\n3. **Fall back to HTML** - If specified in config\n\n**Custom Fallback Logic:**\n```javascript\n// In index.html\n_flutter.loader.load({\n  config: {\n    renderer: supportsWasmGC() ? 'wasm' : 'canvaskit',\n  },\n});\n```\n\n**Progressive Enhancement:**\n- Ship with multiple renderers\n- Let Flutter choose the best one\n- Users get optimal experience for their browser\n\n"
            }
          ],
          "challenges": [
            {
              "type": "QUIZ",
              "id": "14.3-quiz-0",
              "title": "Browser Compatibility Quiz",
              "description": "Test your knowledge of Wasm browser support.",
              "questions": [
                {
                  "question": "What is the minimum Chrome version required for Flutter Wasm?",
                  "options": [
                    "Chrome 100+",
                    "Chrome 110+",
                    "Chrome 119+",
                    "Chrome 125+"
                  ],
                  "correctAnswer": 2,
                  "explanation": "Chrome 119 (released November 2023) is the minimum version that supports Wasm GC, which is required for Flutter's Wasm compilation."
                },
                {
                  "question": "How do you detect if code is running on web in Flutter?",
                  "options": [
                    "Platform.isWeb",
                    "kIsWeb from foundation.dart",
                    "WebPlatform.current",
                    "dart:web.isWeb"
                  ],
                  "correctAnswer": 1,
                  "explanation": "The kIsWeb constant from package:flutter/foundation.dart is the correct way to check if Flutter is running on the web platform."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "14.4",
          "title": "Module 14, Lesson 4: Performance Optimization",
          "moduleId": "module-14",
          "order": 4,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Tree Shaking for Web",
              "content": "\n**Tree Shaking** removes unused code from your final bundle:\n\n**How it works:**\n1. Compiler analyzes your code\n2. Identifies unused classes, methods, functions\n3. Removes them from the final build\n\n**Best practices:**\n- Avoid dynamic imports when possible\n- Use `const` constructors\n- Don't import entire packages if you only need one class\n- Use conditional imports for platform-specific code\n\n```dart\n// Bad: Imports everything\nimport 'package:huge_library/huge_library.dart';\n\n// Good: Import only what you need\nimport 'package:huge_library/specific_widget.dart';\n```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Lazy Loading and Deferred Components",
              "content": "\n**Deferred Loading** splits your app into smaller chunks that load on demand:\n\n```dart\n// Defer loading a heavy feature\nimport 'package:my_app/heavy_feature.dart' deferred as heavy;\n\nFuture<void> loadHeavyFeature() async {\n  await heavy.loadLibrary();\n  // Now you can use heavy.HeavyWidget()\n}\n```\n\n**Benefits:**\n- Faster initial load time\n- Users only download what they use\n- Better Core Web Vitals scores\n\n**Good candidates for deferring:**\n- Admin panels\n- Settings screens\n- Heavy charts/visualizations\n- Rarely used features\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Image Optimization",
              "content": "\n",
              "code": "// Use appropriate image formats\nclass OptimizedImage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Image.network(\n      'https://example.com/image.webp', // Use WebP for web\n      // Provide multiple resolutions\n      cacheWidth: 800, // Resize on decode\n      cacheHeight: 600,\n      loadingBuilder: (context, child, loadingProgress) {\n        if (loadingProgress == null) return child;\n        return CircularProgressIndicator(\n          value: loadingProgress.expectedTotalBytes != null\n              ? loadingProgress.cumulativeBytesLoaded /\n                  loadingProgress.expectedTotalBytes!\n              : null,\n        );\n      },\n      errorBuilder: (context, error, stackTrace) {\n        return Icon(Icons.error);\n      },\n    );\n  }\n}\n\n// For assets, use proper resolution variants\n// assets/\n//   images/\n//     logo.png      (1x)\n//     2.0x/logo.png (2x)\n//     3.0x/logo.png (3x)",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Font Optimization",
              "content": "\n**Font Loading Strategies:**\n\n1. **Use System Fonts When Possible:**\n```dart\nThemeData(\n  fontFamily: 'system-ui', // Uses native system font\n)\n```\n\n2. **Subset Custom Fonts:**\nOnly include characters you need:\n```yaml\nflutter:\n  fonts:\n    - family: CustomFont\n      fonts:\n        - asset: fonts/CustomFont.ttf\n```\n\n3. **Preload Critical Fonts:**\n```html\n<link rel=\"preload\" href=\"assets/fonts/main.ttf\" as=\"font\" crossorigin>\n```\n\n4. **Use font-display: swap:**\nShows system font while custom font loads.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14.4-challenge-0",
              "title": "Optimize a Web App",
              "description": "Apply performance optimizations to a Flutter web application.",
              "instructions": "Implement deferred loading, optimize images, and configure fonts for a web app.",
              "starterCode": "// TODO: Implement deferred loading for AdminPanel\nimport 'package:my_app/admin_panel.dart';\n\n// TODO: Optimize image loading\nclass ImageGallery extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Image.network(\n      'https://example.com/large-image.png',\n    );\n  }\n}\n\n// TODO: Configure fonts efficiently",
              "solution": "// Deferred loading implementation\nimport 'package:my_app/admin_panel.dart' deferred as admin;\n\nclass AdminLoader extends StatefulWidget {\n  @override\n  State<AdminLoader> createState() => _AdminLoaderState();\n}\n\nclass _AdminLoaderState extends State<AdminLoader> {\n  bool _isLoaded = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadAdmin();\n  }\n\n  Future<void> _loadAdmin() async {\n    await admin.loadLibrary();\n    setState(() => _isLoaded = true);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (!_isLoaded) {\n      return const Center(child: CircularProgressIndicator());\n    }\n    return admin.AdminPanel();\n  }\n}\n\n// Optimized image loading\nclass ImageGallery extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Image.network(\n      'https://example.com/large-image.webp', // WebP format\n      cacheWidth: 800,\n      cacheHeight: 600,\n      fit: BoxFit.cover,\n      loadingBuilder: (context, child, loadingProgress) {\n        if (loadingProgress == null) return child;\n        return Center(\n          child: CircularProgressIndicator(\n            value: loadingProgress.expectedTotalBytes != null\n                ? loadingProgress.cumulativeBytesLoaded /\n                    loadingProgress.expectedTotalBytes!\n                : null,\n          ),\n        );\n      },\n      errorBuilder: (context, error, stackTrace) {\n        return const Icon(Icons.broken_image, size: 48);\n      },\n    );\n  }\n}\n\n// Font configuration in pubspec.yaml:\n// flutter:\n//   fonts:\n//     - family: Roboto\n//       fonts:\n//         - asset: fonts/Roboto-Regular.ttf\n//         - asset: fonts/Roboto-Bold.ttf\n//           weight: 700",
              "language": "dart",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Use the 'deferred as' keyword for lazy loading"
                },
                {
                  "level": 2,
                  "text": "Always provide cacheWidth/cacheHeight for network images"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not handling loading state for deferred imports",
                  "consequence": "App crashes when accessing deferred code before it loads",
                  "correction": "Always await loadLibrary() before using deferred imports"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "14.5",
          "title": "Module 14, Lesson 5: PWA Configuration",
          "moduleId": "module-14",
          "order": 5,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "PWA Manifest Setup",
              "content": "\n**Progressive Web Apps (PWAs)** can be installed on devices and work offline.\n\nFlutter creates `web/manifest.json` automatically. Customize it:\n\n```json\n{\n  \"name\": \"My Flutter App\",\n  \"short_name\": \"MyApp\",\n  \"description\": \"A Flutter PWA\",\n  \"start_url\": \".\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#0175C2\",\n  \"theme_color\": \"#0175C2\",\n  \"orientation\": \"portrait-primary\",\n  \"icons\": [\n    {\n      \"src\": \"icons/Icon-192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"icons/Icon-512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ]\n}\n```\n\n"
            },
            {
              "type": "THEORY",
              "title": "Service Worker Configuration",
              "content": "\nFlutter generates a service worker in `flutter_service_worker.js`.\n\n**Configure caching strategy in `index.html`:**\n\n```javascript\n<script>\n  var serviceWorkerVersion = null;\n  _flutter.loader.load({\n    serviceWorkerSettings: {\n      serviceWorkerVersion: serviceWorkerVersion,\n    },\n    onEntrypointLoaded: async function(engineInitializer) {\n      const appRunner = await engineInitializer.initializeEngine();\n      await appRunner.runApp();\n    }\n  });\n</script>\n```\n\n**Service Worker Caches:**\n- App shell (HTML, CSS, JS)\n- Flutter assets\n- Custom offline page\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Offline Support Basics",
              "content": "\n",
              "code": "// Check connectivity in your app\nimport 'package:connectivity_plus/connectivity_plus.dart';\n\nclass ConnectivityService {\n  final Connectivity _connectivity = Connectivity();\n\n  // Check current connectivity\n  Future<bool> isOnline() async {\n    final result = await _connectivity.checkConnectivity();\n    return result != ConnectivityResult.none;\n  }\n\n  // Listen for changes\n  Stream<bool> get onConnectivityChanged {\n    return _connectivity.onConnectivityChanged.map(\n      (result) => result != ConnectivityResult.none,\n    );\n  }\n}\n\n// Usage in widget\nclass OfflineAwareWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return StreamBuilder<bool>(\n      stream: ConnectivityService().onConnectivityChanged,\n      builder: (context, snapshot) {\n        final isOnline = snapshot.data ?? true;\n\n        if (!isOnline) {\n          return OfflineBanner(\n            child: YourContent(),\n          );\n        }\n\n        return YourContent();\n      },\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Install Prompts",
              "content": "\n**Triggering Install Prompts:**\n\nBrowsers show install prompts automatically when PWA criteria are met:\n1. Valid manifest.json with icons\n2. Service worker registered\n3. Served over HTTPS\n4. User has engaged with the site\n\n**Custom Install Button:**\n```javascript\n// In index.html or separate JS file\nlet deferredPrompt;\n\nwindow.addEventListener('beforeinstallprompt', (e) => {\n  e.preventDefault();\n  deferredPrompt = e;\n  showInstallButton();\n});\n\nfunction installApp() {\n  deferredPrompt.prompt();\n  deferredPrompt.userChoice.then((result) => {\n    if (result.outcome === 'accepted') {\n      console.log('App installed');\n    }\n    deferredPrompt = null;\n  });\n}\n```\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14.5-challenge-0",
              "title": "Configure PWA Features",
              "description": "Set up a Flutter web app as a Progressive Web App with offline support.",
              "instructions": "Configure the manifest.json, set up basic offline detection, and prepare the app for installation.",
              "starterCode": "// TODO: Create manifest.json configuration\n// TODO: Implement offline detection\n// TODO: Show install prompt\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MyPWA());\n}\n\nclass MyPWA extends StatelessWidget {\n  const MyPWA({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'My PWA',\n      home: const HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('My PWA')),\n      body: const Center(\n        child: Text('Hello PWA!'),\n      ),\n    );\n  }\n}",
              "solution": "// manifest.json (in web/ folder):\n// {\n//   \"name\": \"My Flutter PWA\",\n//   \"short_name\": \"MyPWA\",\n//   \"start_url\": \".\",\n//   \"display\": \"standalone\",\n//   \"background_color\": \"#6200EE\",\n//   \"theme_color\": \"#6200EE\",\n//   \"icons\": [\n//     {\"src\": \"icons/Icon-192.png\", \"sizes\": \"192x192\", \"type\": \"image/png\"},\n//     {\"src\": \"icons/Icon-512.png\", \"sizes\": \"512x512\", \"type\": \"image/png\"}\n//   ]\n// }\n\nimport 'package:flutter/material.dart';\nimport 'package:connectivity_plus/connectivity_plus.dart';\n\nvoid main() {\n  runApp(const MyPWA());\n}\n\nclass MyPWA extends StatelessWidget {\n  const MyPWA({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'My PWA',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  const HomePage({super.key});\n\n  @override\n  State<HomePage> createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  bool _isOnline = true;\n  final Connectivity _connectivity = Connectivity();\n\n  @override\n  void initState() {\n    super.initState();\n    _checkConnectivity();\n    _connectivity.onConnectivityChanged.listen((result) {\n      setState(() {\n        _isOnline = result != ConnectivityResult.none;\n      });\n    });\n  }\n\n  Future<void> _checkConnectivity() async {\n    final result = await _connectivity.checkConnectivity();\n    setState(() {\n      _isOnline = result != ConnectivityResult.none;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('My PWA'),\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n      ),\n      body: Column(\n        children: [\n          if (!_isOnline)\n            Container(\n              width: double.infinity,\n              color: Colors.orange,\n              padding: const EdgeInsets.all(8),\n              child: const Text(\n                'You are offline',\n                textAlign: TextAlign.center,\n                style: TextStyle(color: Colors.white),\n              ),\n            ),\n          const Expanded(\n            child: Center(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  Icon(Icons.web, size: 64),\n                  SizedBox(height: 16),\n                  Text(\n                    'Hello PWA!',\n                    style: TextStyle(fontSize: 24),\n                  ),\n                  SizedBox(height: 8),\n                  Text('Install me from your browser menu'),\n                ],\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}",
              "language": "dart",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "The manifest.json file goes in the web/ directory"
                },
                {
                  "level": 2,
                  "text": "Use connectivity_plus package to detect offline state"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Missing icons in manifest.json",
                  "consequence": "PWA install prompt won't appear",
                  "correction": "Add both 192x192 and 512x512 PNG icons"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "14.6",
          "title": "Module 14, Lesson 6: Deployment",
          "moduleId": "module-14",
          "order": 6,
          "estimatedMinutes": 50,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Firebase Hosting Deployment",
              "content": "\n**Firebase Hosting** is Google's recommended hosting for Flutter web:\n\n**Setup:**\n```bash\n# Install Firebase CLI\nnpm install -g firebase-tools\n\n# Login\nfirebase login\n\n# Initialize in your project\nfirebase init hosting\n\n# Select build/web as public directory\n# Configure as single-page app: Yes\n```\n\n**Deploy:**\n```bash\nflutter build web --wasm\nfirebase deploy\n```\n\n**Benefits:**\n- Free SSL certificates\n- Global CDN\n- Easy rollback\n- Preview channels for testing\n\n"
            },
            {
              "type": "THEORY",
              "title": "Vercel Deployment",
              "content": "\n**Vercel** offers excellent performance and simple deployment:\n\n**Setup:**\n```bash\n# Install Vercel CLI\nnpm install -g vercel\n\n# Login\nvercel login\n```\n\n**Create vercel.json in project root:**\n```json\n{\n  \"buildCommand\": \"flutter build web --wasm\",\n  \"outputDirectory\": \"build/web\",\n  \"framework\": null,\n  \"rewrites\": [\n    { \"source\": \"/(.*)\", \"destination\": \"/index.html\" }\n  ]\n}\n```\n\n**Deploy:**\n```bash\nvercel --prod\n```\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Netlify Deployment",
              "content": "Netlify provides a simple deployment workflow for Flutter web apps. Configure your build settings in netlify.toml and connect your GitHub repository for automatic deployments.",
              "code": "# netlify.toml in project root\n[build]\n  command = \"flutter build web --wasm\"\n  publish = \"build/web\"\n\n[[redirects]]\n  from = \"/*\"\n  to = \"/index.html\"\n  status = 200\n\n# Deploy via CLI:\n# npm install -g netlify-cli\n# netlify login\n# netlify deploy --prod\n\n# Or connect GitHub repo for automatic deploys",
              "language": "toml"
            },
            {
              "type": "KEY_POINT",
              "title": "GitHub Pages Deployment",
              "content": "\n**GitHub Pages** is free and integrates with your repository:\n\n**Method 1: Manual**\n```bash\nflutter build web --wasm --base-href \"/your-repo-name/\"\n\n# Copy build/web contents to gh-pages branch\n```\n\n**Method 2: GitHub Actions**\n```yaml\n# .github/workflows/deploy.yml\nname: Deploy to GitHub Pages\non:\n  push:\n    branches: [main]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.22.0'\n      - run: flutter build web --wasm --base-href \"/${{ github.event.repository.name }}/\"\n      - uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./build/web\n```\n\n**Important:** Set `--base-href` for GitHub Pages!\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "14.6-challenge-0",
              "title": "Deploy to a Platform",
              "description": "Deploy a Flutter web app to one of the hosting platforms.",
              "instructions": "Choose a hosting platform (Firebase, Vercel, Netlify, or GitHub Pages) and deploy your Flutter web app with Wasm.",
              "starterCode": "# Choose one platform and follow these steps:\n\n# Firebase Hosting:\n# 1. npm install -g firebase-tools\n# 2. firebase login\n# 3. firebase init hosting\n# 4. flutter build web --wasm\n# 5. firebase deploy\n\n# Vercel:\n# 1. npm install -g vercel\n# 2. vercel login\n# 3. Create vercel.json\n# 4. vercel --prod\n\n# Netlify:\n# 1. npm install -g netlify-cli\n# 2. netlify login\n# 3. Create netlify.toml\n# 4. netlify deploy --prod\n\n# GitHub Pages:\n# 1. Create .github/workflows/deploy.yml\n# 2. Push to main branch\n# 3. Enable GitHub Pages in repo settings",
              "solution": "# Firebase Hosting Example (Recommended)\n\n# Step 1: Install Firebase CLI\nnpm install -g firebase-tools\n\n# Step 2: Login to Firebase\nfirebase login\n\n# Step 3: Initialize hosting (run in project root)\nfirebase init hosting\n# - Select or create a Firebase project\n# - Set public directory to: build/web\n# - Configure as single-page app: Yes\n# - Don't overwrite index.html: No\n\n# Step 4: Build Flutter web with Wasm\nflutter build web --wasm --release\n\n# Step 5: Deploy\nfirebase deploy\n\n# Output will show your live URL:\n# Hosting URL: https://your-project.web.app\n\n# -----------------------------------\n# firebase.json should look like:\n# {\n#   \"hosting\": {\n#     \"public\": \"build/web\",\n#     \"ignore\": [\"firebase.json\", \"**/.*\", \"**/node_modules/**\"],\n#     \"rewrites\": [\n#       { \"source\": \"**\", \"destination\": \"/index.html\" }\n#     ],\n#     \"headers\": [\n#       {\n#         \"source\": \"**/*.@(wasm)\",\n#         \"headers\": [\n#           { \"key\": \"Content-Type\", \"value\": \"application/wasm\" }\n#         ]\n#       }\n#     ]\n#   }\n# }\n\n# Bonus: Preview channels for testing\nfirebase hosting:channel:deploy preview",
              "language": "bash",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Firebase Hosting is the easiest for beginners"
                },
                {
                  "level": 2,
                  "text": "Remember to set proper MIME types for .wasm files"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting --base-href for GitHub Pages",
                  "consequence": "Assets fail to load due to incorrect paths",
                  "correction": "Use flutter build web --wasm --base-href \"/repo-name/\""
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "14.7",
          "title": "Module 14, Lesson 7: Mini-Project - Portfolio PWA",
          "moduleId": "module-14",
          "order": 7,
          "estimatedMinutes": 80,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\n**Build a Personal Portfolio PWA**\n\nIn this mini-project, you'll create a portfolio website that showcases your skills as a Flutter developer:\n\n**Features:**\n- Responsive design (mobile, tablet, desktop)\n- Dark/light theme toggle\n- Project showcase with images\n- Contact form\n- PWA installability\n- Wasm compilation for performance\n\n**Pages:**\n1. Home - Hero section with intro\n2. About - Skills and experience\n3. Projects - Portfolio gallery\n4. Contact - Contact form\n\n"
            },
            {
              "type": "THEORY",
              "title": "Building Responsive Portfolio",
              "content": "\n**Responsive Design Approach:**\n\nUse `LayoutBuilder` and breakpoints:\n\n```dart\nclass ResponsiveLayout extends StatelessWidget {\n  final Widget mobile;\n  final Widget tablet;\n  final Widget desktop;\n\n  const ResponsiveLayout({\n    required this.mobile,\n    required this.tablet,\n    required this.desktop,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n      builder: (context, constraints) {\n        if (constraints.maxWidth >= 1200) {\n          return desktop;\n        } else if (constraints.maxWidth >= 800) {\n          return tablet;\n        } else {\n          return mobile;\n        }\n      },\n    );\n  }\n}\n```\n\n**Navigation:**\n- Mobile: Bottom navigation or drawer\n- Desktop: Top navigation bar\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Adding PWA Features",
              "content": "\n",
              "code": "// Portfolio app with PWA features\nimport 'package:flutter/material.dart';\nimport 'package:flutter/foundation.dart';\n\nvoid main() {\n  runApp(const PortfolioApp());\n}\n\nclass PortfolioApp extends StatelessWidget {\n  const PortfolioApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'John Doe - Flutter Developer',\n      debugShowCheckedModeBanner: false,\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(\n          seedColor: Colors.indigo,\n          brightness: Brightness.light,\n        ),\n        useMaterial3: true,\n      ),\n      darkTheme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(\n          seedColor: Colors.indigo,\n          brightness: Brightness.dark,\n        ),\n        useMaterial3: true,\n      ),\n      themeMode: ThemeMode.system,\n      home: const PortfolioHome(),\n    );\n  }\n}\n\nclass PortfolioHome extends StatelessWidget {\n  const PortfolioHome({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final screenWidth = MediaQuery.of(context).size.width;\n    final isDesktop = screenWidth >= 1200;\n\n    return Scaffold(\n      appBar: isDesktop ? _buildDesktopNav(context) : null,\n      drawer: isDesktop ? null : _buildDrawer(context),\n      body: SingleChildScrollView(\n        child: Column(\n          children: [\n            if (!isDesktop) _buildMobileHeader(context),\n            const HeroSection(),\n            const AboutSection(),\n            const ProjectsSection(),\n            const ContactSection(),\n            const Footer(),\n          ],\n        ),\n      ),\n    );\n  }\n\n  PreferredSizeWidget _buildDesktopNav(BuildContext context) {\n    return AppBar(\n      title: const Text('John Doe'),\n      actions: [\n        TextButton(onPressed: () {}, child: const Text('Home')),\n        TextButton(onPressed: () {}, child: const Text('About')),\n        TextButton(onPressed: () {}, child: const Text('Projects')),\n        TextButton(onPressed: () {}, child: const Text('Contact')),\n        const SizedBox(width: 16),\n      ],\n    );\n  }\n\n  Widget _buildMobileHeader(BuildContext context) {\n    return AppBar(\n      title: const Text('John Doe'),\n    );\n  }\n\n  Widget _buildDrawer(BuildContext context) {\n    return Drawer(\n      child: ListView(\n        children: [\n          const DrawerHeader(\n            decoration: BoxDecoration(color: Colors.indigo),\n            child: Text('Portfolio', style: TextStyle(color: Colors.white)),\n          ),\n          ListTile(title: const Text('Home'), onTap: () {}),\n          ListTile(title: const Text('About'), onTap: () {}),\n          ListTile(title: const Text('Projects'), onTap: () {}),\n          ListTile(title: const Text('Contact'), onTap: () {}),\n        ],\n      ),\n    );\n  }\n}\n\nclass HeroSection extends StatelessWidget {\n  const HeroSection({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      height: 500,\n      width: double.infinity,\n      decoration: BoxDecoration(\n        gradient: LinearGradient(\n          colors: [Colors.indigo, Colors.indigo.shade300],\n        ),\n      ),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          const CircleAvatar(\n            radius: 60,\n            child: Icon(Icons.person, size: 60),\n          ),\n          const SizedBox(height: 24),\n          Text(\n            'John Doe',\n            style: Theme.of(context).textTheme.headlineLarge?.copyWith(\n              color: Colors.white,\n              fontWeight: FontWeight.bold,\n            ),\n          ),\n          const SizedBox(height: 8),\n          Text(\n            'Flutter Developer',\n            style: Theme.of(context).textTheme.titleLarge?.copyWith(\n              color: Colors.white70,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass AboutSection extends StatelessWidget {\n  const AboutSection({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(48),\n      child: Column(\n        children: [\n          Text('About Me', style: Theme.of(context).textTheme.headlineMedium),\n          const SizedBox(height: 16),\n          const Text(\n            'I am a passionate Flutter developer with experience building cross-platform applications.',\n            textAlign: TextAlign.center,\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass ProjectsSection extends StatelessWidget {\n  const ProjectsSection({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: Theme.of(context).colorScheme.surfaceVariant,\n      padding: const EdgeInsets.all(48),\n      child: Column(\n        children: [\n          Text('Projects', style: Theme.of(context).textTheme.headlineMedium),\n          const SizedBox(height: 24),\n          Wrap(\n            spacing: 16,\n            runSpacing: 16,\n            children: [\n              _buildProjectCard('Project 1', 'A Flutter app'),\n              _buildProjectCard('Project 2', 'A web app'),\n              _buildProjectCard('Project 3', 'A mobile game'),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildProjectCard(String title, String description) {\n    return Card(\n      child: Container(\n        width: 300,\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Container(\n              height: 150,\n              color: Colors.grey.shade300,\n              child: const Center(child: Icon(Icons.image, size: 48)),\n            ),\n            const SizedBox(height: 8),\n            Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),\n            Text(description),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass ContactSection extends StatelessWidget {\n  const ContactSection({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(48),\n      child: Column(\n        children: [\n          Text('Contact', style: Theme.of(context).textTheme.headlineMedium),\n          const SizedBox(height: 24),\n          const SizedBox(\n            width: 400,\n            child: Column(\n              children: [\n                TextField(decoration: InputDecoration(labelText: 'Name')),\n                SizedBox(height: 16),\n                TextField(decoration: InputDecoration(labelText: 'Email')),\n                SizedBox(height: 16),\n                TextField(\n                  decoration: InputDecoration(labelText: 'Message'),\n                  maxLines: 4,\n                ),\n                SizedBox(height: 16),\n              ],\n            ),\n          ),\n          ElevatedButton(\n            onPressed: () {},\n            child: const Text('Send Message'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass Footer extends StatelessWidget {\n  const Footer({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: const EdgeInsets.all(24),\n      color: Colors.grey.shade900,\n      child: const Center(\n        child: Text(\n          '2024 John Doe. Built with Flutter Web + Wasm',\n          style: TextStyle(color: Colors.white70),\n        ),\n      ),\n    );\n  }\n}",
              "language": "dart"
            }
          ],
          "challenges": [
            {
              "type": "PROJECT",
              "id": "14.7-project-0",
              "title": "Complete Portfolio PWA",
              "description": "Build and deploy a complete portfolio PWA using Flutter Web with WebAssembly.",
              "instructions": "Create a portfolio website with responsive design, theme switching, project showcase, and PWA features. Deploy to a hosting platform of your choice.",
              "starterCode": "// Portfolio PWA Project\n//\n// Requirements:\n// 1. Responsive layout (mobile/tablet/desktop)\n// 2. Dark/light theme toggle\n// 3. At least 4 sections: Hero, About, Projects, Contact\n// 4. PWA manifest configured\n// 5. Deployed with Wasm compilation\n//\n// Steps:\n// 1. Create new Flutter project: flutter create portfolio\n// 2. Implement responsive layout\n// 3. Add theme switching\n// 4. Configure PWA (manifest.json, icons)\n// 5. Build: flutter build web --wasm\n// 6. Deploy to Firebase/Vercel/Netlify\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const PortfolioApp());\n}\n\nclass PortfolioApp extends StatefulWidget {\n  const PortfolioApp({super.key});\n\n  @override\n  State<PortfolioApp> createState() => _PortfolioAppState();\n}\n\nclass _PortfolioAppState extends State<PortfolioApp> {\n  ThemeMode _themeMode = ThemeMode.system;\n\n  void toggleTheme() {\n    setState(() {\n      _themeMode = _themeMode == ThemeMode.light \n          ? ThemeMode.dark \n          : ThemeMode.light;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'My Portfolio',\n      theme: ThemeData.light(useMaterial3: true),\n      darkTheme: ThemeData.dark(useMaterial3: true),\n      themeMode: _themeMode,\n      home: PortfolioHome(onToggleTheme: toggleTheme),\n    );\n  }\n}\n\nclass PortfolioHome extends StatelessWidget {\n  final VoidCallback onToggleTheme;\n\n  const PortfolioHome({super.key, required this.onToggleTheme});\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: Implement responsive portfolio\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Portfolio'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.brightness_6),\n            onPressed: onToggleTheme,\n          ),\n        ],\n      ),\n      body: const Center(\n        child: Text('Build your portfolio here!'),\n      ),\n    );\n  }\n}",
              "solution": "// Complete Portfolio PWA Solution\n// See the example code in the lesson content above for full implementation\n//\n// Key implementation points:\n//\n// 1. Responsive Layout:\n//    - Use LayoutBuilder or MediaQuery\n//    - Different layouts for mobile (<800), tablet (800-1200), desktop (>1200)\n//\n// 2. Theme Switching:\n//    - Store ThemeMode in StatefulWidget\n//    - Pass toggle function down widget tree\n//\n// 3. PWA Configuration:\n//    - Configure web/manifest.json with proper icons\n//    - Ensure service worker is registered\n//\n// 4. Deployment:\n//    - Build: flutter build web --wasm\n//    - Deploy to chosen platform\n//\n// manifest.json:\n// {\n//   \"name\": \"My Portfolio\",\n//   \"short_name\": \"Portfolio\",\n//   \"start_url\": \".\",\n//   \"display\": \"standalone\",\n//   \"background_color\": \"#6200EE\",\n//   \"theme_color\": \"#6200EE\",\n//   \"icons\": [\n//     {\"src\": \"icons/Icon-192.png\", \"sizes\": \"192x192\", \"type\": \"image/png\"},\n//     {\"src\": \"icons/Icon-512.png\", \"sizes\": \"512x512\", \"type\": \"image/png\"}\n//   ]\n// }",
              "language": "dart",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with the Hero section and work your way down"
                },
                {
                  "level": 2,
                  "text": "Use Wrap widget for responsive grid of project cards"
                },
                {
                  "level": 3,
                  "text": "Test on different screen sizes using Chrome DevTools"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not testing on different screen sizes",
                  "consequence": "Layout breaks on certain devices",
                  "correction": "Use Chrome DevTools device toolbar to test responsive breakpoints"
                },
                {
                  "mistake": "Forgetting PWA icons",
                  "consequence": "App won't be installable",
                  "correction": "Add 192x192 and 512x512 PNG icons in web/icons/"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        }
      ]
    },
    {
      "id": "module-15",
      "title": "Module 15: Offline-First Architecture with Drift & Isar",
      "description": "Build resilient mobile apps with type-safe local databases, offline sync strategies, and local-first architecture patterns.",
      "difficulty": "intermediate",
      "estimatedHours": 7,
      "lessons": [
        {
          "id": "15.1",
          "title": "Module 15, Lesson 1: Offline-First Principles",
          "moduleId": "module-15",
          "order": 1,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Offline-First?",
              "content": "\n**Users Expect Apps to Work Without Internet**\n\nThink about how you use your phone. You're on a subway with spotty signal, in an airplane with no WiFi, or in a building with poor reception. What happens when you open an app?\n\nWith **online-first** apps, you see spinning loaders, error messages, or blank screens. Frustrating.\n\nWith **offline-first** apps, everything loads instantly. You can read, write, and interact. When connection returns, changes sync automatically.\n\n**Real-world examples:**\n- Notes apps (you expect to read your notes anywhere)\n- Todo lists (you want to check items off offline)\n- Email (you can read and compose offline)\n- Maps (downloaded areas work without signal)\n\n"
            },
            {
              "type": "THEORY",
              "title": "The Problem with Online-First",
              "content": "\n**Online-First Architecture:**\n```\nUser Action -> API Request -> Wait for Response -> Update UI\n```\n\n**Problems:**\n1. **Slow perceived performance** - Users wait for every action\n2. **Network dependency** - App is useless without internet\n3. **Poor UX on slow connections** - 3G users have terrible experience\n4. **Data loss risk** - If request fails mid-submission, data is lost\n5. **Battery drain** - Constant network activity\n\n**Statistics:**\n- 53% of users abandon sites that take >3 seconds to load\n- Mobile connections average 50-200ms latency per request\n- Users check phones 150+ times/day, often briefly\n\n"
            },
            {
              "type": "KEY_POINT",
              "title": "Local is Truth, Remote is Backup",
              "content": "\n**The Offline-First Mindset:**\n\nInstead of treating the server as the source of truth and local storage as a cache, flip it:\n\n- **Local database is the primary source** - App reads/writes here first\n- **Remote server is backup** - Syncs when connection is available\n- **Changes sync bidirectionally** - Local to remote, remote to local\n\n**Benefits:**\n- **Instant response** - No network wait for any action\n- **Works everywhere** - Online, offline, or poor connection\n- **Resilient** - Network failures don't lose data\n- **Better UX** - App feels native and fast\n\n**The key principle:** Your app should work perfectly with airplane mode on. Network is an enhancement, not a requirement.\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Sync Strategies Overview",
              "content": "\nDifferent apps need different sync strategies:\n\n",
              "code": "// 1. LAST-WRITE-WINS\n// Simple but can lose data\n// Good for: User preferences, settings\nclass LastWriteWins {\n  DateTime updatedAt;\n  // Whoever wrote last is the winner\n}\n\n// 2. MERGE STRATEGY\n// Combine changes from both sides\n// Good for: Lists, collections\nclass MergeStrategy {\n  // Add items from both local and remote\n  // Remove items marked deleted on either side\n}\n\n// 3. CONFLICT RESOLUTION\n// Ask user to choose or auto-resolve\n// Good for: Documents, notes\nclass ConflictResolution {\n  LocalVersion localVersion;\n  RemoteVersion remoteVersion;\n  // Present both to user or apply rules\n}\n\n// 4. OPERATION-BASED (CRDTs)\n// Track operations, not state\n// Good for: Collaborative editing\nclass OperationBased {\n  List<Operation> operations;\n  // Replay operations in order\n}",
              "language": "dart"
            }
          ],
          "challenges": [
            {
              "type": "QUIZ",
              "id": "15.1-quiz-0",
              "title": "Offline-First Principles Quiz",
              "description": "Test your understanding of offline-first architecture.",
              "questions": [
                {
                  "question": "What is the core principle of offline-first architecture?",
                  "options": [
                    "Always fetch from server first",
                    "Local database is the primary source of truth",
                    "Cache server responses temporarily",
                    "Only store data when offline"
                  ],
                  "correctAnswer": 1,
                  "explanation": "In offline-first architecture, the local database is the primary source of truth. The app reads and writes locally first, then syncs with the server when connection is available."
                },
                {
                  "question": "Which sync strategy is best for user preferences?",
                  "options": [
                    "CRDT-based operations",
                    "Ask user to resolve conflicts",
                    "Last-write-wins",
                    "Never sync preferences"
                  ],
                  "correctAnswer": 2,
                  "explanation": "Last-write-wins is appropriate for user preferences because the most recent choice is typically what the user wants, and conflicts are rare."
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.2",
          "title": "Module 15, Lesson 2: Drift Setup & Type-Safe SQL",
          "moduleId": "module-15",
          "order": 2,
          "estimatedMinutes": 55,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Why Drift over sqflite?",
              "content": "\n**sqflite** is Flutter's basic SQLite wrapper. It works, but has limitations:\n\n```dart\n// sqflite - raw SQL, no type safety\nfinal results = await db.rawQuery(\n  'SELECT * FROM tasks WHERE complted = 1' // Typo! No compile error\n);\n// results is List<Map<String, dynamic>> - no type safety\n```\n\n**Drift** (formerly Moor) provides:\n- **Type safety** - Compile-time SQL validation\n- **Code generation** - Tables become Dart classes\n- **Streams** - Reactive queries that update UI automatically\n- **Migrations** - Built-in schema versioning\n- **DAOs** - Organized data access layer\n\n```dart\n// Drift - type-safe, compile-time checked\nfinal tasks = await db.select(db.tasks)\n  ..where((t) => t.completed.equals(true)); // Type-safe!\n// Returns List<Task> - proper Dart objects\n```\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Installation",
              "content": "\nAdd these dependencies to your `pubspec.yaml`:\n\n",
              "code": "# pubspec.yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  drift: ^2.14.0\n  sqlite3_flutter_libs: ^0.5.18\n  path_provider: ^2.1.1\n  path: ^1.8.3\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  drift_dev: ^2.14.0\n  build_runner: ^2.4.7\n\n# Run: flutter pub get",
              "language": "yaml"
            },
            {
              "type": "EXAMPLE",
              "title": "Table Definitions",
              "content": "\nDefine your database tables as Dart classes:\n\n",
              "code": "// lib/database/tables.dart\nimport 'package:drift/drift.dart';\n\n// Tasks table\nclass Tasks extends Table {\n  // Auto-incrementing primary key\n  IntColumn get id => integer().autoIncrement()();\n  \n  // Required text with length constraint\n  TextColumn get title => text().withLength(min: 1, max: 100)();\n  \n  // Optional description\n  TextColumn get description => text().nullable()();\n  \n  // Boolean with default value\n  BoolColumn get completed => boolean().withDefault(const Constant(false))();\n  \n  // DateTime with default to current time\n  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();\n  \n  // Optional due date\n  DateTimeColumn get dueDate => dateTime().nullable()();\n  \n  // Foreign key to categories table\n  IntColumn get categoryId => integer().nullable().references(Categories, #id)();\n}\n\n// Categories table\nclass Categories extends Table {\n  IntColumn get id => integer().autoIncrement()();\n  TextColumn get name => text().withLength(min: 1, max: 50)();\n  IntColumn get color => integer()(); // Store color as int\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Database Class",
              "content": "\nCreate the database with `@DriftDatabase` annotation:\n\n",
              "code": "// lib/database/database.dart\nimport 'dart:io';\nimport 'package:drift/drift.dart';\nimport 'package:drift/native.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'package:path/path.dart' as p;\n\nimport 'tables.dart';\n\npart 'database.g.dart'; // Generated file\n\n@DriftDatabase(tables: [Tasks, Categories])\nclass AppDatabase extends _$AppDatabase {\n  AppDatabase() : super(_openConnection());\n  \n  // Schema version - increment when you change tables\n  @override\n  int get schemaVersion => 1;\n}\n\nLazyDatabase _openConnection() {\n  return LazyDatabase(() async {\n    final dbFolder = await getApplicationDocumentsDirectory();\n    final file = File(p.join(dbFolder.path, 'app.db'));\n    return NativeDatabase.createInBackground(file);\n  });\n}\n\n// Run code generation:\n// dart run build_runner build",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Code Generation",
              "content": "\n**After defining tables, generate the code:**\n\n```bash\ndart run build_runner build\n```\n\nThis creates `database.g.dart` with:\n- Data classes (`Task`, `Category`)\n- Companion classes for inserts/updates\n- Database implementation\n\n**Watch mode for development:**\n```bash\ndart run build_runner watch\n```\n\nAuto-regenerates when you change table definitions.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.2-challenge-0",
              "title": "Set Up Drift Database",
              "description": "Create a Drift database with Notes and Tags tables.",
              "instructions": "Define a Notes table with id, title, content, createdAt, and updatedAt. Define a Tags table with id and name. Set up the database class.",
              "starterCode": "// lib/database/tables.dart\nimport 'package:drift/drift.dart';\n\n// TODO: Define Notes table\n// - id (auto-increment)\n// - title (required, max 200 chars)\n// - content (required)\n// - createdAt (default to now)\n// - updatedAt (default to now)\n\n// TODO: Define Tags table\n// - id (auto-increment)\n// - name (required, max 50 chars)\n\n// lib/database/database.dart\n// TODO: Create AppDatabase class with @DriftDatabase annotation",
              "solution": "// lib/database/tables.dart\nimport 'package:drift/drift.dart';\n\nclass Notes extends Table {\n  IntColumn get id => integer().autoIncrement()();\n  TextColumn get title => text().withLength(min: 1, max: 200)();\n  TextColumn get content => text()();\n  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();\n  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();\n}\n\nclass Tags extends Table {\n  IntColumn get id => integer().autoIncrement()();\n  TextColumn get name => text().withLength(min: 1, max: 50)();\n}\n\n// lib/database/database.dart\nimport 'dart:io';\nimport 'package:drift/drift.dart';\nimport 'package:drift/native.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'package:path/path.dart' as p;\n\nimport 'tables.dart';\n\npart 'database.g.dart';\n\n@DriftDatabase(tables: [Notes, Tags])\nclass AppDatabase extends _$AppDatabase {\n  AppDatabase() : super(_openConnection());\n  \n  @override\n  int get schemaVersion => 1;\n}\n\nLazyDatabase _openConnection() {\n  return LazyDatabase(() async {\n    final dbFolder = await getApplicationDocumentsDirectory();\n    final file = File(p.join(dbFolder.path, 'notes.db'));\n    return NativeDatabase.createInBackground(file);\n  });\n}",
              "language": "dart",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Use integer().autoIncrement()() for auto-incrementing primary keys"
                },
                {
                  "level": 2,
                  "text": "Use dateTime().withDefault(currentDateAndTime)() for timestamp defaults"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting the part directive for generated file",
                  "consequence": "Build runner fails to generate code",
                  "correction": "Add: part 'database.g.dart';"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.3",
          "title": "Module 15, Lesson 3: Drift DAOs & Complex Queries",
          "moduleId": "module-15",
          "order": 3,
          "estimatedMinutes": 50,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Data Access Objects (DAOs)",
              "content": "\n**DAOs** organize database operations by domain:\n\n- `TaskDao` - All task-related queries\n- `CategoryDao` - All category-related queries\n\n**Benefits:**\n- Clean separation of concerns\n- Reusable query methods\n- Easier testing\n- Better code organization\n\nInstead of putting all queries in the database class, split them into focused DAOs.\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Creating a DAO",
              "content": "\n",
              "code": "// lib/database/daos/task_dao.dart\nimport 'package:drift/drift.dart';\nimport '../database.dart';\nimport '../tables.dart';\n\npart 'task_dao.g.dart';\n\n@DriftAccessor(tables: [Tasks, Categories])\nclass TaskDao extends DatabaseAccessor<AppDatabase> with _$TaskDaoMixin {\n  TaskDao(AppDatabase db) : super(db);\n  \n  // CREATE\n  Future<int> insertTask(TasksCompanion task) {\n    return into(tasks).insert(task);\n  }\n  \n  // READ - Get all tasks\n  Future<List<Task>> getAllTasks() {\n    return select(tasks).get();\n  }\n  \n  // READ - Get single task\n  Future<Task?> getTaskById(int id) {\n    return (select(tasks)..where((t) => t.id.equals(id))).getSingleOrNull();\n  }\n  \n  // READ - Get incomplete tasks\n  Future<List<Task>> getIncompleteTasks() {\n    return (select(tasks)\n      ..where((t) => t.completed.equals(false))\n      ..orderBy([(t) => OrderingTerm.asc(t.dueDate)]))\n      .get();\n  }\n  \n  // UPDATE\n  Future<bool> updateTask(Task task) {\n    return update(tasks).replace(task);\n  }\n  \n  // UPDATE - Toggle completion\n  Future<int> toggleComplete(int id, bool completed) {\n    return (update(tasks)..where((t) => t.id.equals(id)))\n      .write(TasksCompanion(completed: Value(completed)));\n  }\n  \n  // DELETE\n  Future<int> deleteTask(int id) {\n    return (delete(tasks)..where((t) => t.id.equals(id))).go();\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Joins and Relations",
              "content": "\nQuery across related tables:\n\n",
              "code": "// Join tasks with categories\nclass TaskWithCategory {\n  final Task task;\n  final Category? category;\n  \n  TaskWithCategory(this.task, this.category);\n}\n\n// In TaskDao:\nFuture<List<TaskWithCategory>> getTasksWithCategories() {\n  final query = select(tasks).join([\n    leftOuterJoin(categories, categories.id.equalsExp(tasks.categoryId)),\n  ]);\n  \n  return query.map((row) {\n    return TaskWithCategory(\n      row.readTable(tasks),\n      row.readTableOrNull(categories),\n    );\n  }).get();\n}\n\n// Filter by category\nFuture<List<Task>> getTasksByCategory(int categoryId) {\n  return (select(tasks)\n    ..where((t) => t.categoryId.equals(categoryId)))\n    .get();\n}\n\n// Count tasks per category\nFuture<List<CategoryCount>> getTaskCountByCategory() {\n  final count = tasks.id.count();\n  \n  final query = selectOnly(categories)\n    ..addColumns([categories.name, count])\n    ..join([leftOuterJoin(tasks, tasks.categoryId.equalsExp(categories.id))])\n    ..groupBy([categories.id]);\n  \n  return query.map((row) {\n    return CategoryCount(\n      name: row.read(categories.name)!,\n      count: row.read(count)!,\n    );\n  }).get();\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Stream Queries for Reactive UI",
              "content": "\nDrift's killer feature - queries that emit updates automatically:\n\n",
              "code": "// In TaskDao:\n\n// Stream of all tasks - emits whenever data changes\nStream<List<Task>> watchAllTasks() {\n  return select(tasks).watch();\n}\n\n// Stream of incomplete tasks\nStream<List<Task>> watchIncompleteTasks() {\n  return (select(tasks)\n    ..where((t) => t.completed.equals(false))\n    ..orderBy([(t) => OrderingTerm.asc(t.dueDate)]))\n    .watch();\n}\n\n// Stream of single task\nStream<Task?> watchTask(int id) {\n  return (select(tasks)..where((t) => t.id.equals(id)))\n    .watchSingleOrNull();\n}\n\n// Usage in Flutter widget:\nclass TaskListWidget extends StatelessWidget {\n  final TaskDao taskDao;\n  \n  @override\n  Widget build(BuildContext context) {\n    return StreamBuilder<List<Task>>(\n      stream: taskDao.watchIncompleteTasks(),\n      builder: (context, snapshot) {\n        if (!snapshot.hasData) {\n          return const CircularProgressIndicator();\n        }\n        \n        final tasks = snapshot.data!;\n        return ListView.builder(\n          itemCount: tasks.length,\n          itemBuilder: (context, index) {\n            final task = tasks[index];\n            return TaskTile(task: task);\n          },\n        );\n      },\n    );\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Register DAOs in Database",
              "content": "\n**Update your database class to include DAOs:**\n\n```dart\n@DriftDatabase(\n  tables: [Tasks, Categories],\n  daos: [TaskDao, CategoryDao], // Register DAOs here\n)\nclass AppDatabase extends _$AppDatabase {\n  AppDatabase() : super(_openConnection());\n  \n  @override\n  int get schemaVersion => 1;\n  \n  // Access DAOs\n  TaskDao get taskDao => TaskDao(this);\n  CategoryDao get categoryDao => CategoryDao(this);\n}\n```\n\nNow you can use `db.taskDao.getAllTasks()` throughout your app.\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.3-challenge-0",
              "title": "Build a Notes DAO",
              "description": "Create a DAO for notes with CRUD operations and stream queries.",
              "instructions": "Create a NoteDao with methods: insertNote, getAllNotes, getNoteById, updateNote, deleteNote, watchAllNotes (stream), and searchNotes (by title).",
              "starterCode": "// lib/database/daos/note_dao.dart\nimport 'package:drift/drift.dart';\nimport '../database.dart';\nimport '../tables.dart';\n\npart 'note_dao.g.dart';\n\n@DriftAccessor(tables: [Notes])\nclass NoteDao extends DatabaseAccessor<AppDatabase> with _$NoteDaoMixin {\n  NoteDao(AppDatabase db) : super(db);\n  \n  // TODO: Implement CRUD operations\n  // - insertNote\n  // - getAllNotes (ordered by updatedAt descending)\n  // - getNoteById\n  // - updateNote\n  // - deleteNote\n  \n  // TODO: Implement stream query\n  // - watchAllNotes\n  \n  // TODO: Implement search\n  // - searchNotes (search in title)\n}",
              "solution": "// lib/database/daos/note_dao.dart\nimport 'package:drift/drift.dart';\nimport '../database.dart';\nimport '../tables.dart';\n\npart 'note_dao.g.dart';\n\n@DriftAccessor(tables: [Notes])\nclass NoteDao extends DatabaseAccessor<AppDatabase> with _$NoteDaoMixin {\n  NoteDao(AppDatabase db) : super(db);\n  \n  // CREATE\n  Future<int> insertNote(NotesCompanion note) {\n    return into(notes).insert(note);\n  }\n  \n  // READ - Get all notes\n  Future<List<Note>> getAllNotes() {\n    return (select(notes)\n      ..orderBy([(n) => OrderingTerm.desc(n.updatedAt)]))\n      .get();\n  }\n  \n  // READ - Get single note\n  Future<Note?> getNoteById(int id) {\n    return (select(notes)..where((n) => n.id.equals(id)))\n      .getSingleOrNull();\n  }\n  \n  // UPDATE\n  Future<bool> updateNote(Note note) {\n    return update(notes).replace(note);\n  }\n  \n  // DELETE\n  Future<int> deleteNote(int id) {\n    return (delete(notes)..where((n) => n.id.equals(id))).go();\n  }\n  \n  // STREAM - Watch all notes\n  Stream<List<Note>> watchAllNotes() {\n    return (select(notes)\n      ..orderBy([(n) => OrderingTerm.desc(n.updatedAt)]))\n      .watch();\n  }\n  \n  // SEARCH - Search notes by title\n  Future<List<Note>> searchNotes(String query) {\n    return (select(notes)\n      ..where((n) => n.title.like('%$query%'))\n      ..orderBy([(n) => OrderingTerm.desc(n.updatedAt)]))\n      .get();\n  }\n}",
              "language": "dart",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Use select(notes).watch() for stream queries"
                },
                {
                  "level": 2,
                  "text": "Use .like('%query%') for text search"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting to order results",
                  "consequence": "Notes appear in random order",
                  "correction": "Add ..orderBy([(n) => OrderingTerm.desc(n.updatedAt)])"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.4",
          "title": "Module 15, Lesson 4: Drift Migrations",
          "moduleId": "module-15",
          "order": 4,
          "estimatedMinutes": 45,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Schema Versioning",
              "content": "\n**Why Migrations Matter:**\n\nYour app is in production. Users have data. You need to add a new column.\n\nWithout migrations:\n- App crashes on startup\n- Users lose all their data\n- Bad reviews flood in\n\nWith migrations:\n- Schema updates smoothly\n- Existing data preserved\n- Users don't notice anything\n\n**The Rule:** Every schema change increments `schemaVersion` and requires migration code.\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "MigrationStrategy",
              "content": "\n",
              "code": "// lib/database/database.dart\n@DriftDatabase(tables: [Tasks, Categories])\nclass AppDatabase extends _$AppDatabase {\n  AppDatabase() : super(_openConnection());\n  \n  // Increment this when you change the schema\n  @override\n  int get schemaVersion => 2; // Was 1, now 2\n  \n  @override\n  MigrationStrategy get migration {\n    return MigrationStrategy(\n      // Called when creating a fresh database\n      onCreate: (Migrator m) async {\n        await m.createAll();\n      },\n      \n      // Called when upgrading from old version\n      onUpgrade: (Migrator m, int from, int to) async {\n        // Run migrations for each version\n        if (from < 2) {\n          // Migration from version 1 to 2\n          await m.addColumn(tasks, tasks.priority);\n        }\n        if (from < 3) {\n          // Migration from version 2 to 3\n          await m.createTable(tags);\n        }\n      },\n      \n      // Called after opening (useful for seeding data)\n      beforeOpen: (details) async {\n        // Enable foreign keys\n        await customStatement('PRAGMA foreign_keys = ON');\n        \n        // Seed default categories if needed\n        if (details.wasCreated) {\n          await _seedDefaultCategories();\n        }\n      },\n    );\n  }\n  \n  Future<void> _seedDefaultCategories() async {\n    await into(categories).insert(CategoriesCompanion(\n      name: const Value('Work'),\n      color: Value(Colors.blue.value),\n    ));\n    await into(categories).insert(CategoriesCompanion(\n      name: const Value('Personal'),\n      color: Value(Colors.green.value),\n    ));\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Common Migration Patterns",
              "content": "\n",
              "code": "// Common onUpgrade patterns:\n\nonUpgrade: (Migrator m, int from, int to) async {\n  // 1. ADD A COLUMN\n  if (from < 2) {\n    await m.addColumn(tasks, tasks.priority);\n  }\n  \n  // 2. CREATE A NEW TABLE\n  if (from < 3) {\n    await m.createTable(tags);\n  }\n  \n  // 3. DROP A TABLE\n  if (from < 4) {\n    await m.deleteTable('old_table_name');\n  }\n  \n  // 4. RENAME A COLUMN (requires custom SQL)\n  if (from < 5) {\n    await customStatement(\n      'ALTER TABLE tasks RENAME COLUMN old_name TO new_name'\n    );\n  }\n  \n  // 5. COMPLEX MIGRATION (data transformation)\n  if (from < 6) {\n    // Add new column\n    await m.addColumn(tasks, tasks.statusEnum);\n    \n    // Migrate data from old column to new\n    await customStatement('''\n      UPDATE tasks \n      SET status_enum = CASE \n        WHEN completed = 1 THEN 'done'\n        ELSE 'pending'\n      END\n    ''');\n    \n    // Optionally drop old column (SQLite limitation: can't drop columns easily)\n  }\n},",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Testing Migrations",
              "content": "\n**Always test migrations before releasing!**\n\n```dart\n// test/migration_test.dart\nimport 'package:drift/drift.dart';\nimport 'package:drift_dev/api/migrations.dart';\nimport 'package:test/test.dart';\n\nvoid main() {\n  test('migration from v1 to v2', () async {\n    final verifier = SchemaVerifier(GeneratedHelper());\n    \n    // Start with schema version 1\n    final connection = await verifier.startAt(1);\n    final db = AppDatabase.connect(connection);\n    \n    // Verify migration runs without error\n    await verifier.migrateAndValidate(db, 2);\n    \n    await db.close();\n  });\n}\n```\n\n**Migration Checklist:**\n1. Increment schemaVersion\n2. Add migration code in onUpgrade\n3. Test migration locally\n4. Test with production-like data\n5. Test upgrading from ALL previous versions\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.4-challenge-0",
              "title": "Add a Migration",
              "description": "Add a 'priority' column to the Notes table with proper migration.",
              "instructions": "1. Add a priority column (integer, nullable) to the Notes table. 2. Increment schemaVersion to 2. 3. Add migration code to add the column for existing users.",
              "starterCode": "// Current schema version is 1\n// Notes table has: id, title, content, createdAt, updatedAt\n\n// TODO: Add priority column to Notes table\n// TODO: Update schemaVersion to 2\n// TODO: Add migration in onUpgrade\n\nclass Notes extends Table {\n  IntColumn get id => integer().autoIncrement()();\n  TextColumn get title => text().withLength(min: 1, max: 200)();\n  TextColumn get content => text()();\n  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();\n  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();\n  // TODO: Add priority column\n}\n\n@DriftDatabase(tables: [Notes])\nclass AppDatabase extends _$AppDatabase {\n  AppDatabase() : super(_openConnection());\n  \n  @override\n  int get schemaVersion => 1; // TODO: Update this\n  \n  // TODO: Add MigrationStrategy\n}",
              "solution": "class Notes extends Table {\n  IntColumn get id => integer().autoIncrement()();\n  TextColumn get title => text().withLength(min: 1, max: 200)();\n  TextColumn get content => text()();\n  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();\n  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();\n  IntColumn get priority => integer().nullable()(); // Added!\n}\n\n@DriftDatabase(tables: [Notes])\nclass AppDatabase extends _$AppDatabase {\n  AppDatabase() : super(_openConnection());\n  \n  @override\n  int get schemaVersion => 2; // Updated!\n  \n  @override\n  MigrationStrategy get migration {\n    return MigrationStrategy(\n      onCreate: (Migrator m) async {\n        await m.createAll();\n      },\n      onUpgrade: (Migrator m, int from, int to) async {\n        if (from < 2) {\n          // Add priority column for users upgrading from v1\n          await m.addColumn(notes, notes.priority);\n        }\n      },\n    );\n  }\n}",
              "language": "dart",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "New columns in migrations should be nullable or have defaults"
                },
                {
                  "level": 2,
                  "text": "Check 'from < 2' to run migration for version 1 users"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Adding required column without default in migration",
                  "consequence": "Migration fails for existing data",
                  "correction": "Make new columns nullable or provide a default value"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.5",
          "title": "Module 15, Lesson 5: Isar NoSQL - Setup & CRUD",
          "moduleId": "module-15",
          "order": 5,
          "estimatedMinutes": 50,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "When to Use Isar vs Drift",
              "content": "\n**Choose Drift (SQL) when:**\n- Complex relational data with joins\n- Need SQL query flexibility\n- Coming from SQL background\n- Strict schema requirements\n- Complex reporting queries\n\n**Choose Isar (NoSQL) when:**\n- Simple data structures\n- Maximum performance is critical\n- Flexible/evolving schema\n- Document-style data\n- Need full-text search built-in\n- Want simplest possible API\n\n**Isar Advantages:**\n- **Blazing fast** - Written in Rust, optimized for mobile\n- **No code generation wait** - Fast builds\n- **Full-text search** - Built-in, no extra setup\n- **Synchronous API** - Optional sync operations\n- **Encryption** - Built-in database encryption\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Installation and Setup",
              "content": "\n",
              "code": "# pubspec.yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  isar: ^3.1.0\n  isar_flutter_libs: ^3.1.0\n  path_provider: ^2.1.1\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  isar_generator: ^3.1.0\n  build_runner: ^2.4.7\n\n# Run: flutter pub get\n# Then: dart run build_runner build",
              "language": "yaml"
            },
            {
              "type": "EXAMPLE",
              "title": "Collection Definitions",
              "content": "\nDefine your data models with the `@collection` annotation:\n\n",
              "code": "// lib/models/task.dart\nimport 'package:isar/isar.dart';\n\npart 'task.g.dart'; // Generated file\n\n@collection\nclass Task {\n  Id id = Isar.autoIncrement; // Auto-incrementing ID\n  \n  @Index(type: IndexType.value) // Index for fast queries\n  String? title;\n  \n  String? description;\n  \n  @Index() // Index for filtering\n  bool isCompleted = false;\n  \n  DateTime? dueDate;\n  \n  @Index(composite: [CompositeIndex('isCompleted')]) // Composite index\n  DateTime createdAt = DateTime.now();\n  \n  // Enum stored as int\n  @Enumerated(EnumType.ordinal)\n  Priority priority = Priority.medium;\n}\n\nenum Priority { low, medium, high }\n\n// lib/models/category.dart\n@collection\nclass Category {\n  Id id = Isar.autoIncrement;\n  \n  @Index(unique: true) // Unique constraint\n  String? name;\n  \n  int color = 0xFF2196F3;\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Opening the Database",
              "content": "\n",
              "code": "// lib/database/isar_service.dart\nimport 'package:isar/isar.dart';\nimport 'package:path_provider/path_provider.dart';\nimport '../models/task.dart';\nimport '../models/category.dart';\n\nclass IsarService {\n  late Future<Isar> db;\n  \n  IsarService() {\n    db = openDB();\n  }\n  \n  Future<Isar> openDB() async {\n    final dir = await getApplicationDocumentsDirectory();\n    \n    if (Isar.instanceNames.isEmpty) {\n      return await Isar.open(\n        [TaskSchema, CategorySchema], // Register all schemas\n        directory: dir.path,\n        inspector: true, // Enable Isar Inspector in debug\n      );\n    }\n    \n    return Future.value(Isar.getInstance());\n  }\n}\n\n// Usage:\nfinal isarService = IsarService();\nfinal isar = await isarService.db;",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "CRUD Operations",
              "content": "\n",
              "code": "// lib/database/task_repository.dart\nimport 'package:isar/isar.dart';\nimport '../models/task.dart';\n\nclass TaskRepository {\n  final Isar isar;\n  \n  TaskRepository(this.isar);\n  \n  // CREATE\n  Future<int> addTask(Task task) async {\n    return await isar.writeTxn(() async {\n      return await isar.tasks.put(task);\n    });\n  }\n  \n  // CREATE MANY\n  Future<void> addTasks(List<Task> tasks) async {\n    await isar.writeTxn(() async {\n      await isar.tasks.putAll(tasks);\n    });\n  }\n  \n  // READ - Get all tasks\n  Future<List<Task>> getAllTasks() async {\n    return await isar.tasks.where().findAll();\n  }\n  \n  // READ - Get by ID\n  Future<Task?> getTaskById(int id) async {\n    return await isar.tasks.get(id);\n  }\n  \n  // READ - Get incomplete tasks\n  Future<List<Task>> getIncompleteTasks() async {\n    return await isar.tasks\n        .where()\n        .isCompletedEqualTo(false)\n        .sortByDueDate()\n        .findAll();\n  }\n  \n  // UPDATE\n  Future<void> updateTask(Task task) async {\n    await isar.writeTxn(() async {\n      await isar.tasks.put(task);\n    });\n  }\n  \n  // DELETE\n  Future<bool> deleteTask(int id) async {\n    return await isar.writeTxn(() async {\n      return await isar.tasks.delete(id);\n    });\n  }\n  \n  // DELETE ALL COMPLETED\n  Future<int> deleteCompletedTasks() async {\n    return await isar.writeTxn(() async {\n      return await isar.tasks\n          .where()\n          .isCompletedEqualTo(true)\n          .deleteAll();\n    });\n  }\n  \n  // WATCH - Stream of changes\n  Stream<List<Task>> watchAllTasks() {\n    return isar.tasks.where().watch(fireImmediately: true);\n  }\n}",
              "language": "dart"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.5-challenge-0",
              "title": "Isar CRUD",
              "description": "Create a Note collection and repository with full CRUD operations.",
              "instructions": "1. Create a Note collection with id, title, content, createdAt, and isPinned. 2. Create a NoteRepository with addNote, getAllNotes, updateNote, deleteNote, and getPinnedNotes methods.",
              "starterCode": "// lib/models/note.dart\nimport 'package:isar/isar.dart';\n\npart 'note.g.dart';\n\n// TODO: Create Note collection with:\n// - id (auto-increment)\n// - title (indexed)\n// - content\n// - createdAt\n// - isPinned (indexed)\n\n// lib/database/note_repository.dart\n// TODO: Create NoteRepository with:\n// - addNote\n// - getAllNotes (sorted by createdAt descending)\n// - updateNote\n// - deleteNote\n// - getPinnedNotes\n// - watchAllNotes (stream)",
              "solution": "// lib/models/note.dart\nimport 'package:isar/isar.dart';\n\npart 'note.g.dart';\n\n@collection\nclass Note {\n  Id id = Isar.autoIncrement;\n  \n  @Index(type: IndexType.value)\n  String? title;\n  \n  String? content;\n  \n  DateTime createdAt = DateTime.now();\n  \n  @Index()\n  bool isPinned = false;\n}\n\n// lib/database/note_repository.dart\nimport 'package:isar/isar.dart';\nimport '../models/note.dart';\n\nclass NoteRepository {\n  final Isar isar;\n  \n  NoteRepository(this.isar);\n  \n  Future<int> addNote(Note note) async {\n    return await isar.writeTxn(() async {\n      return await isar.notes.put(note);\n    });\n  }\n  \n  Future<List<Note>> getAllNotes() async {\n    return await isar.notes\n        .where()\n        .sortByCreatedAtDesc()\n        .findAll();\n  }\n  \n  Future<void> updateNote(Note note) async {\n    await isar.writeTxn(() async {\n      await isar.notes.put(note);\n    });\n  }\n  \n  Future<bool> deleteNote(int id) async {\n    return await isar.writeTxn(() async {\n      return await isar.notes.delete(id);\n    });\n  }\n  \n  Future<List<Note>> getPinnedNotes() async {\n    return await isar.notes\n        .where()\n        .isPinnedEqualTo(true)\n        .sortByCreatedAtDesc()\n        .findAll();\n  }\n  \n  Stream<List<Note>> watchAllNotes() {\n    return isar.notes\n        .where()\n        .sortByCreatedAtDesc()\n        .watch(fireImmediately: true);\n  }\n}",
              "language": "dart",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Use @Index() on fields you'll filter by"
                },
                {
                  "level": 2,
                  "text": "All write operations need isar.writeTxn()"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Forgetting writeTxn for write operations",
                  "consequence": "Isar throws an error about not being in a transaction",
                  "correction": "Wrap all puts, deletes with isar.writeTxn(() async { ... })"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.6",
          "title": "Module 15, Lesson 6: Isar Indexes & Query Optimization",
          "moduleId": "module-15",
          "order": 6,
          "estimatedMinutes": 40,
          "difficulty": "intermediate",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Index Types",
              "content": "\n**Indexes make queries fast.** Without indexes, Isar scans every record.\n\n**Value Index (default):**\n- Best for equality checks and range queries\n- Stores actual values in sorted order\n- Good for: `equalTo`, `greaterThan`, `between`\n\n```dart\n@Index(type: IndexType.value)\nString? title; // Indexed by value\n```\n\n**Hash Index:**\n- Fast equality checks only\n- Smaller storage than value index\n- Cannot do range queries\n\n```dart\n@Index(type: IndexType.hash)\nString? email; // Only for exact matching\n```\n\n**HashElements Index (for lists):**\n- Index each element in a list\n- Find records containing specific values\n\n```dart\n@Index(type: IndexType.hashElements)\nList<String> tags = []; // Search by tag\n```\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Composite Indexes",
              "content": "\nIndex multiple fields together for compound queries:\n\n",
              "code": "@collection\nclass Task {\n  Id id = Isar.autoIncrement;\n  \n  @Index() // Single index for filtering\n  bool isCompleted = false;\n  \n  @Index(\n    composite: [CompositeIndex('priority')],\n  )\n  DateTime? dueDate;\n  \n  @Enumerated(EnumType.ordinal)\n  Priority priority = Priority.medium;\n}\n\n// Now this query uses the composite index:\nfinal tasks = await isar.tasks\n    .where()\n    .dueDateIsNotNull()\n    .priorityEqualTo(Priority.high)\n    .findAll();\n\n// Composite indexes are read left-to-right\n// dueDate + priority is efficient\n// priority alone won't use this index",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Query Performance",
              "content": "\n",
              "code": "// FAST - Uses index\nfinal highPriority = await isar.tasks\n    .where()\n    .priorityEqualTo(Priority.high) // Indexed field\n    .findAll();\n\n// FAST - Uses composite index\nfinal upcomingImportant = await isar.tasks\n    .where()\n    .dueDateBetween(now, nextWeek)\n    .priorityEqualTo(Priority.high)\n    .findAll();\n\n// SLOW - Full table scan (no index on description)\nfinal searchResults = await isar.tasks\n    .where()\n    .filter()\n    .descriptionContains('meeting') // Not indexed!\n    .findAll();\n\n// FAST - Full-text search (use this instead)\n@collection\nclass Task {\n  Id id = Isar.autoIncrement;\n  \n  @Index(type: IndexType.value, caseSensitive: false)\n  String? title;\n}\n\n// Case-insensitive search on indexed field\nfinal results = await isar.tasks\n    .where()\n    .titleStartsWith('meet') // Uses index\n    .findAll();",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Filtering and Sorting",
              "content": "\n",
              "code": "// FILTER - For complex conditions after where()\nfinal filtered = await isar.tasks\n    .where()\n    .isCompletedEqualTo(false) // Uses index\n    .filter() // Switch to filter mode\n    .dueDateIsNotNull() // Additional filters\n    .and()\n    .titleContains('urgent', caseSensitive: false)\n    .findAll();\n\n// SORTING\nfinal sorted = await isar.tasks\n    .where()\n    .sortByDueDateDesc() // Primary sort\n    .thenByPriority() // Secondary sort\n    .findAll();\n\n// PAGINATION\nfinal page = await isar.tasks\n    .where()\n    .sortByCreatedAtDesc()\n    .offset(20) // Skip first 20\n    .limit(10) // Take 10\n    .findAll();\n\n// COUNT (efficient - doesn't load data)\nfinal count = await isar.tasks\n    .where()\n    .isCompletedEqualTo(false)\n    .count();\n\n// AGGREGATE\nfinal exists = await isar.tasks\n    .where()\n    .priorityEqualTo(Priority.high)\n    .isNotEmpty();",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Query Optimization Tips",
              "content": "\n**Index Strategy:**\n1. Index fields you filter by frequently\n2. Use composite indexes for multi-field queries\n3. Put most selective field first in composite index\n4. Hash indexes for exact-match only fields\n5. Don't over-index - each index costs write performance\n\n**Query Tips:**\n1. Use `.where()` for indexed queries (fast)\n2. Use `.filter()` only for complex conditions\n3. Avoid `.filter().contains()` on unindexed fields\n4. Use `.count()` instead of `.findAll().length`\n5. Use `.limit()` for pagination\n\n**Debugging:**\n```dart\n// Enable Isar Inspector in development\nfinal isar = await Isar.open(\n  schemas,\n  inspector: true, // Opens inspector on localhost:8080\n);\n```\n\n"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.6-challenge-0",
              "title": "Optimize Note Queries",
              "description": "Add proper indexes and optimize queries for a notes collection.",
              "instructions": "1. Add indexes for frequently queried fields (isPinned, createdAt). 2. Create a composite index for notes filtered by isPinned and sorted by createdAt. 3. Write an optimized query to get the 10 most recent pinned notes.",
              "starterCode": "// Current Note collection - needs optimization\n@collection\nclass Note {\n  Id id = Isar.autoIncrement;\n  String? title;\n  String? content;\n  DateTime createdAt = DateTime.now();\n  bool isPinned = false;\n}\n\n// Current slow query:\nFuture<List<Note>> getRecentPinnedNotes() async {\n  final allNotes = await isar.notes.where().findAll();\n  final pinned = allNotes.where((n) => n.isPinned).toList();\n  pinned.sort((a, b) => b.createdAt.compareTo(a.createdAt));\n  return pinned.take(10).toList();\n}\n\n// TODO: Add indexes to Note class\n// TODO: Rewrite query to use indexes",
              "solution": "@collection\nclass Note {\n  Id id = Isar.autoIncrement;\n  \n  @Index(type: IndexType.value, caseSensitive: false)\n  String? title;\n  \n  String? content;\n  \n  @Index(composite: [CompositeIndex('isPinned')])\n  DateTime createdAt = DateTime.now();\n  \n  @Index()\n  bool isPinned = false;\n}\n\n// Optimized query using indexes:\nFuture<List<Note>> getRecentPinnedNotes() async {\n  return await isar.notes\n      .where()\n      .isPinnedEqualTo(true) // Uses isPinned index\n      .sortByCreatedAtDesc() // Uses composite index\n      .limit(10) // Only fetch 10\n      .findAll();\n}\n\n// Alternative using composite index directly:\nFuture<List<Note>> getRecentPinnedNotesAlt() async {\n  return await isar.notes\n      .where()\n      .createdAtIsPinnedEqualTo(true) // Uses composite\n      .sortByCreatedAtDesc()\n      .limit(10)\n      .findAll();\n}",
              "language": "dart",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Add @Index() to fields you filter by"
                },
                {
                  "level": 2,
                  "text": "Use composite index for multi-field queries: @Index(composite: [CompositeIndex('fieldName')])"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Filtering in Dart instead of database",
                  "consequence": "Loads all records into memory, very slow for large datasets",
                  "correction": "Use Isar's where() and filter() clauses to query at database level"
                }
              ],
              "difficulty": "intermediate"
            }
          ]
        },
        {
          "id": "15.7",
          "title": "Module 15, Lesson 7: Sync Engine - Local-First with Cloud Backup",
          "moduleId": "module-15",
          "order": 7,
          "estimatedMinutes": 60,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Sync Architecture Patterns",
              "content": "\n**The Sync Challenge:**\nUser edits data offline. Server has updates. How do you merge?\n\n**Three Approaches:**\n\n1. **Pull-Only Sync**\n   - Fetch from server, overwrite local\n   - Simple but loses offline changes\n   - Good for: Read-only data, reference data\n\n2. **Push-Pull Sync**\n   - Push local changes, then pull remote changes\n   - Requires conflict handling\n   - Good for: User-generated content\n\n3. **Real-time Sync**\n   - WebSockets for instant sync\n   - Complex but seamless\n   - Good for: Collaboration apps\n\nWe'll build a **Push-Pull** sync with queue-based changes.\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Conflict Resolution Strategies",
              "content": "\n",
              "code": "enum ConflictStrategy {\n  /// Server always wins - simplest\n  serverWins,\n  \n  /// Client always wins - risky\n  clientWins,\n  \n  /// Most recent change wins\n  lastWriteWins,\n  \n  /// Keep both versions for user to resolve\n  keepBoth,\n  \n  /// Merge field by field\n  fieldMerge,\n}\n\n// Example: Last-write-wins resolution\nclass ConflictResolver {\n  T resolve<T extends Syncable>(T local, T remote) {\n    // Compare timestamps\n    if (local.updatedAt.isAfter(remote.updatedAt)) {\n      return local;\n    } else {\n      return remote;\n    }\n  }\n}\n\n// Example: Field-level merge for notes\nNote mergeNotes(Note local, Note remote) {\n  return Note(\n    id: local.id,\n    // Use most recently updated title\n    title: local.titleUpdatedAt.isAfter(remote.titleUpdatedAt)\n        ? local.title\n        : remote.title,\n    // Use most recently updated content\n    content: local.contentUpdatedAt.isAfter(remote.contentUpdatedAt)\n        ? local.content\n        : remote.content,\n    // Keep latest timestamp\n    updatedAt: local.updatedAt.isAfter(remote.updatedAt)\n        ? local.updatedAt\n        : remote.updatedAt,\n  );\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Queue-Based Sync",
              "content": "\nTrack local changes in a sync queue:\n\n",
              "code": "// lib/sync/sync_queue.dart\nimport 'package:isar/isar.dart';\n\npart 'sync_queue.g.dart';\n\n@collection\nclass SyncOperation {\n  Id id = Isar.autoIncrement;\n  \n  @Index()\n  String entityType = ''; // 'note', 'task', etc.\n  \n  int entityId = 0;\n  \n  @Enumerated(EnumType.ordinal)\n  SyncOperationType operation = SyncOperationType.create;\n  \n  DateTime createdAt = DateTime.now();\n  \n  @Index()\n  bool isSynced = false;\n  \n  int retryCount = 0;\n}\n\nenum SyncOperationType { create, update, delete }\n\n// Queue operations when making local changes\nclass NoteRepository {\n  final Isar isar;\n  \n  Future<void> createNote(Note note) async {\n    await isar.writeTxn(() async {\n      // 1. Save the note\n      final id = await isar.notes.put(note);\n      \n      // 2. Queue sync operation\n      await isar.syncOperations.put(SyncOperation()\n        ..entityType = 'note'\n        ..entityId = id\n        ..operation = SyncOperationType.create\n      );\n    });\n  }\n  \n  Future<void> updateNote(Note note) async {\n    await isar.writeTxn(() async {\n      await isar.notes.put(note);\n      \n      await isar.syncOperations.put(SyncOperation()\n        ..entityType = 'note'\n        ..entityId = note.id\n        ..operation = SyncOperationType.update\n      );\n    });\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Network Connectivity Detection",
              "content": "\n",
              "code": "// lib/sync/connectivity_service.dart\nimport 'package:connectivity_plus/connectivity_plus.dart';\nimport 'dart:async';\n\nclass ConnectivityService {\n  final _connectivity = Connectivity();\n  final _controller = StreamController<bool>.broadcast();\n  \n  Stream<bool> get onConnectivityChanged => _controller.stream;\n  bool _isOnline = true;\n  bool get isOnline => _isOnline;\n  \n  ConnectivityService() {\n    _connectivity.onConnectivityChanged.listen(_updateStatus);\n    _checkInitialStatus();\n  }\n  \n  Future<void> _checkInitialStatus() async {\n    final result = await _connectivity.checkConnectivity();\n    _updateStatus(result);\n  }\n  \n  void _updateStatus(ConnectivityResult result) {\n    final online = result != ConnectivityResult.none;\n    if (online != _isOnline) {\n      _isOnline = online;\n      _controller.add(_isOnline);\n    }\n  }\n  \n  void dispose() {\n    _controller.close();\n  }\n}\n\n// Usage in sync service\nclass SyncService {\n  final ConnectivityService _connectivity;\n  \n  void startAutoSync() {\n    _connectivity.onConnectivityChanged.listen((isOnline) {\n      if (isOnline) {\n        sync(); // Sync when connection restored\n      }\n    });\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Complete Sync Service",
              "content": "\n",
              "code": "// lib/sync/sync_service.dart\nclass SyncService {\n  final Isar isar;\n  final ApiClient api;\n  final ConnectivityService connectivity;\n  \n  DateTime? lastSyncAt;\n  bool _isSyncing = false;\n  \n  SyncService(this.isar, this.api, this.connectivity);\n  \n  Future<SyncResult> sync() async {\n    if (_isSyncing) return SyncResult.alreadySyncing;\n    if (!connectivity.isOnline) return SyncResult.offline;\n    \n    _isSyncing = true;\n    \n    try {\n      // 1. PUSH: Upload local changes\n      await _pushChanges();\n      \n      // 2. PULL: Download remote changes\n      await _pullChanges();\n      \n      lastSyncAt = DateTime.now();\n      return SyncResult.success;\n    } catch (e) {\n      return SyncResult.error;\n    } finally {\n      _isSyncing = false;\n    }\n  }\n  \n  Future<void> _pushChanges() async {\n    // Get unsynced operations\n    final operations = await isar.syncOperations\n        .where()\n        .isSyncedEqualTo(false)\n        .findAll();\n    \n    for (final op in operations) {\n      try {\n        switch (op.operation) {\n          case SyncOperationType.create:\n          case SyncOperationType.update:\n            final note = await isar.notes.get(op.entityId);\n            if (note != null) {\n              await api.upsertNote(note.toJson());\n            }\n            break;\n          case SyncOperationType.delete:\n            await api.deleteNote(op.entityId);\n            break;\n        }\n        \n        // Mark as synced\n        await isar.writeTxn(() async {\n          op.isSynced = true;\n          await isar.syncOperations.put(op);\n        });\n      } catch (e) {\n        // Increment retry count\n        await isar.writeTxn(() async {\n          op.retryCount++;\n          await isar.syncOperations.put(op);\n        });\n      }\n    }\n  }\n  \n  Future<void> _pullChanges() async {\n    // Fetch changes since last sync\n    final remoteNotes = await api.getNotesSince(lastSyncAt);\n    \n    await isar.writeTxn(() async {\n      for (final remoteNote in remoteNotes) {\n        final localNote = await isar.notes.get(remoteNote.id);\n        \n        if (localNote == null) {\n          // New note from server\n          await isar.notes.put(remoteNote);\n        } else {\n          // Conflict - resolve with last-write-wins\n          if (remoteNote.updatedAt.isAfter(localNote.updatedAt)) {\n            await isar.notes.put(remoteNote);\n          }\n          // Otherwise keep local (it will push on next sync)\n        }\n      }\n    });\n  }\n}\n\nenum SyncResult {\n  success,\n  offline,\n  alreadySyncing,\n  error,\n}",
              "language": "dart"
            }
          ],
          "challenges": [
            {
              "type": "FREE_CODING",
              "id": "15.7-challenge-0",
              "title": "Build Sync Service",
              "description": "Create a basic sync service with push and pull capabilities.",
              "instructions": "Create a SyncService that: 1. Tracks online/offline status. 2. Maintains a queue of local changes. 3. Pushes changes when online. 4. Pulls remote changes. 5. Uses last-write-wins for conflicts.",
              "starterCode": "// lib/sync/sync_service.dart\nclass SyncService {\n  final Isar isar;\n  final MockApiClient api; // Simplified API client\n  \n  SyncService(this.isar, this.api);\n  \n  // TODO: Track sync state\n  bool _isSyncing = false;\n  DateTime? lastSyncAt;\n  \n  // TODO: Implement sync method\n  Future<void> sync() async {\n    // 1. Check if already syncing\n    // 2. Push local changes\n    // 3. Pull remote changes\n    // 4. Update lastSyncAt\n  }\n  \n  // TODO: Push unsynced changes to server\n  Future<void> _pushChanges() async {\n    // Get unsynced operations\n    // Upload each to server\n    // Mark as synced\n  }\n  \n  // TODO: Pull changes from server\n  Future<void> _pullChanges() async {\n    // Fetch changes since lastSyncAt\n    // Merge with local data (last-write-wins)\n  }\n}",
              "solution": "class SyncService {\n  final Isar isar;\n  final MockApiClient api;\n  \n  bool _isSyncing = false;\n  DateTime? lastSyncAt;\n  \n  SyncService(this.isar, this.api);\n  \n  Future<bool> sync() async {\n    if (_isSyncing) return false;\n    \n    _isSyncing = true;\n    try {\n      await _pushChanges();\n      await _pullChanges();\n      lastSyncAt = DateTime.now();\n      return true;\n    } catch (e) {\n      print('Sync error: $e');\n      return false;\n    } finally {\n      _isSyncing = false;\n    }\n  }\n  \n  Future<void> _pushChanges() async {\n    final unsynced = await isar.syncOperations\n        .where()\n        .isSyncedEqualTo(false)\n        .findAll();\n    \n    for (final op in unsynced) {\n      try {\n        if (op.operation == SyncOperationType.delete) {\n          await api.delete('notes', op.entityId);\n        } else {\n          final note = await isar.notes.get(op.entityId);\n          if (note != null) {\n            await api.upsert('notes', note.toJson());\n          }\n        }\n        \n        await isar.writeTxn(() async {\n          op.isSynced = true;\n          await isar.syncOperations.put(op);\n        });\n      } catch (e) {\n        await isar.writeTxn(() async {\n          op.retryCount++;\n          await isar.syncOperations.put(op);\n        });\n      }\n    }\n  }\n  \n  Future<void> _pullChanges() async {\n    final remoteNotes = await api.fetchSince('notes', lastSyncAt);\n    \n    await isar.writeTxn(() async {\n      for (final remote in remoteNotes) {\n        final local = await isar.notes.get(remote.id);\n        \n        // Last-write-wins conflict resolution\n        if (local == null || remote.updatedAt.isAfter(local.updatedAt)) {\n          await isar.notes.put(remote);\n        }\n      }\n    });\n  }\n}",
              "language": "dart",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Use a boolean flag to prevent concurrent sync operations"
                },
                {
                  "level": 2,
                  "text": "Compare updatedAt timestamps for last-write-wins"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Not handling concurrent sync attempts",
                  "consequence": "Duplicate operations and data corruption",
                  "correction": "Use _isSyncing flag and return early if already syncing"
                }
              ],
              "difficulty": "advanced"
            }
          ]
        },
        {
          "id": "15.8",
          "title": "Module 15, Lesson 8: Mini-Project - Notes App with Offline Sync",
          "moduleId": "module-15",
          "order": 8,
          "estimatedMinutes": 90,
          "difficulty": "advanced",
          "contentSections": [
            {
              "type": "THEORY",
              "title": "Project Overview",
              "content": "\n**Build a Notes App with Offline-First Architecture**\n\nIn this project, you'll combine everything learned in this module:\n\n**Features:**\n- Create, edit, delete notes (works offline)\n- Notes persist in local database\n- Sync indicator shows online/offline status\n- Changes queue while offline\n- Auto-sync when connection restored\n- Pull-to-refresh for manual sync\n\n**Architecture:**\n```\nUI Layer\n    |\n    v\nRepository (abstraction)\n    |\n    v\nLocal Database (Isar) <---> Sync Service <---> Remote API\n```\n\n**Key Principle:** UI always talks to local database. Never waits for network.\n\n"
            },
            {
              "type": "EXAMPLE",
              "title": "Database Design",
              "content": "\n",
              "code": "// lib/models/note.dart\nimport 'package:isar/isar.dart';\n\npart 'note.g.dart';\n\n@collection\nclass Note {\n  Id id = Isar.autoIncrement;\n  \n  String? serverId; // ID from server (null if not synced yet)\n  \n  @Index(type: IndexType.value, caseSensitive: false)\n  String title = '';\n  \n  String content = '';\n  \n  @Index()\n  DateTime createdAt = DateTime.now();\n  \n  DateTime updatedAt = DateTime.now();\n  \n  @Index()\n  bool isPinned = false;\n  \n  @Index()\n  bool isDeleted = false; // Soft delete for sync\n  \n  // Convert to JSON for API\n  Map<String, dynamic> toJson() => {\n    'id': serverId,\n    'title': title,\n    'content': content,\n    'createdAt': createdAt.toIso8601String(),\n    'updatedAt': updatedAt.toIso8601String(),\n    'isPinned': isPinned,\n    'isDeleted': isDeleted,\n  };\n  \n  // Create from API response\n  static Note fromJson(Map<String, dynamic> json) => Note()\n    ..serverId = json['id']\n    ..title = json['title'] ?? ''\n    ..content = json['content'] ?? ''\n    ..createdAt = DateTime.parse(json['createdAt'])\n    ..updatedAt = DateTime.parse(json['updatedAt'])\n    ..isPinned = json['isPinned'] ?? false\n    ..isDeleted = json['isDeleted'] ?? false;\n}\n\n// lib/models/sync_operation.dart\n@collection\nclass SyncOperation {\n  Id id = Isar.autoIncrement;\n  \n  @Index()\n  int noteId = 0;\n  \n  @Enumerated(EnumType.ordinal)\n  SyncOpType type = SyncOpType.create;\n  \n  DateTime createdAt = DateTime.now();\n  \n  @Index()\n  bool isPending = true;\n}\n\nenum SyncOpType { create, update, delete }",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "UI Implementation",
              "content": "\n",
              "code": "// lib/screens/notes_screen.dart\nimport 'package:flutter/material.dart';\nimport 'package:isar/isar.dart';\n\nclass NotesScreen extends StatelessWidget {\n  final NoteRepository noteRepo;\n  final SyncService syncService;\n  final ConnectivityService connectivity;\n  \n  const NotesScreen({\n    required this.noteRepo,\n    required this.syncService,\n    required this.connectivity,\n  });\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('My Notes'),\n        actions: [\n          // Sync status indicator\n          StreamBuilder<bool>(\n            stream: connectivity.onConnectivityChanged,\n            initialData: connectivity.isOnline,\n            builder: (context, snapshot) {\n              final isOnline = snapshot.data ?? false;\n              return IconButton(\n                icon: Icon(\n                  isOnline ? Icons.cloud_done : Icons.cloud_off,\n                  color: isOnline ? Colors.green : Colors.grey,\n                ),\n                onPressed: isOnline ? () => syncService.sync() : null,\n                tooltip: isOnline ? 'Synced' : 'Offline',\n              );\n            },\n          ),\n        ],\n      ),\n      body: RefreshIndicator(\n        onRefresh: () => syncService.sync(),\n        child: StreamBuilder<List<Note>>(\n          stream: noteRepo.watchAllNotes(),\n          builder: (context, snapshot) {\n            if (!snapshot.hasData) {\n              return const Center(child: CircularProgressIndicator());\n            }\n            \n            final notes = snapshot.data!;\n            \n            if (notes.isEmpty) {\n              return const Center(\n                child: Text('No notes yet. Tap + to create one!'),\n              );\n            }\n            \n            return ListView.builder(\n              itemCount: notes.length,\n              itemBuilder: (context, index) {\n                final note = notes[index];\n                return NoteCard(\n                  note: note,\n                  onTap: () => _openNote(context, note),\n                  onDelete: () => _deleteNote(note),\n                );\n              },\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => _createNote(context),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n  \n  void _createNote(BuildContext context) {\n    Navigator.push(\n      context,\n      MaterialPageRoute(\n        builder: (_) => NoteEditorScreen(\n          noteRepo: noteRepo,\n        ),\n      ),\n    );\n  }\n  \n  void _openNote(BuildContext context, Note note) {\n    Navigator.push(\n      context,\n      MaterialPageRoute(\n        builder: (_) => NoteEditorScreen(\n          noteRepo: noteRepo,\n          note: note,\n        ),\n      ),\n    );\n  }\n  \n  Future<void> _deleteNote(Note note) async {\n    await noteRepo.deleteNote(note.id);\n  }\n}",
              "language": "dart"
            },
            {
              "type": "EXAMPLE",
              "title": "Sync Implementation",
              "content": "\n",
              "code": "// lib/services/note_sync_service.dart\nclass NoteSyncService {\n  final Isar isar;\n  final NotesApi api;\n  final ConnectivityService connectivity;\n  \n  bool _isSyncing = false;\n  DateTime? _lastSyncAt;\n  \n  NoteSyncService(this.isar, this.api, this.connectivity) {\n    // Auto-sync when coming online\n    connectivity.onConnectivityChanged.listen((isOnline) {\n      if (isOnline) sync();\n    });\n  }\n  \n  Future<void> sync() async {\n    if (_isSyncing || !connectivity.isOnline) return;\n    _isSyncing = true;\n    \n    try {\n      // 1. Push local changes\n      final pending = await isar.syncOperations\n          .where()\n          .isPendingEqualTo(true)\n          .findAll();\n      \n      for (final op in pending) {\n        await _processSyncOp(op);\n      }\n      \n      // 2. Pull remote changes\n      final remoteNotes = await api.getNotesSince(_lastSyncAt);\n      await _mergeRemoteNotes(remoteNotes);\n      \n      _lastSyncAt = DateTime.now();\n    } finally {\n      _isSyncing = false;\n    }\n  }\n  \n  Future<void> _processSyncOp(SyncOperation op) async {\n    try {\n      final note = await isar.notes.get(op.noteId);\n      if (note == null) return;\n      \n      switch (op.type) {\n        case SyncOpType.create:\n        case SyncOpType.update:\n          final serverNote = await api.upsertNote(note.toJson());\n          await isar.writeTxn(() async {\n            note.serverId = serverNote['id'];\n            await isar.notes.put(note);\n          });\n          break;\n        case SyncOpType.delete:\n          if (note.serverId != null) {\n            await api.deleteNote(note.serverId!);\n          }\n          break;\n      }\n      \n      // Mark operation as complete\n      await isar.writeTxn(() async {\n        op.isPending = false;\n        await isar.syncOperations.put(op);\n      });\n    } catch (e) {\n      // Will retry on next sync\n      print('Sync error: $e');\n    }\n  }\n  \n  Future<void> _mergeRemoteNotes(List<Map<String, dynamic>> remoteNotes) async {\n    await isar.writeTxn(() async {\n      for (final json in remoteNotes) {\n        final remote = Note.fromJson(json);\n        \n        // Find local note by serverId\n        final local = await isar.notes\n            .where()\n            .serverIdEqualTo(remote.serverId)\n            .findFirst();\n        \n        if (local == null) {\n          // New note from server\n          await isar.notes.put(remote);\n        } else if (remote.updatedAt.isAfter(local.updatedAt)) {\n          // Server version is newer\n          remote.id = local.id; // Keep local ID\n          await isar.notes.put(remote);\n        }\n        // If local is newer, it will push on next sync\n      }\n    });\n  }\n}",
              "language": "dart"
            },
            {
              "type": "KEY_POINT",
              "title": "Running the Project",
              "content": "\n**Setup Steps:**\n\n1. Create new Flutter project:\n```bash\nflutter create notes_app\ncd notes_app\n```\n\n2. Add dependencies to pubspec.yaml\n\n3. Create models with Isar annotations\n\n4. Generate code:\n```bash\ndart run build_runner build\n```\n\n5. Implement repository, sync service, UI\n\n6. Run the app:\n```bash\nflutter run\n```\n\n**Testing Offline Mode:**\n1. Add some notes\n2. Turn on airplane mode\n3. Edit notes (should work instantly)\n4. Turn off airplane mode\n5. Watch sync indicator go green\n6. Changes sync automatically\n\n"
            }
          ],
          "challenges": [
            {
              "type": "PROJECT",
              "id": "15.8-project-0",
              "title": "Complete Notes App with Offline Sync",
              "description": "Build a fully functional notes app that works offline and syncs when online.",
              "instructions": "Create a notes app with: 1. Local storage using Isar. 2. CRUD operations that work offline. 3. Sync queue for tracking changes. 4. Automatic sync when coming online. 5. Visual indicator for online/offline status. 6. Pull-to-refresh for manual sync.",
              "starterCode": "// Project Structure:\n// lib/\n//   models/\n//     note.dart\n//     sync_operation.dart\n//   services/\n//     database_service.dart\n//     sync_service.dart\n//     connectivity_service.dart\n//   repositories/\n//     note_repository.dart\n//   screens/\n//     notes_screen.dart\n//     note_editor_screen.dart\n//   widgets/\n//     note_card.dart\n//     sync_indicator.dart\n//   main.dart\n\n// Start with the models, then services, then UI.\n// Use the examples from this lesson as templates.\n\n// Key requirements:\n// 1. Notes persist locally (Isar)\n// 2. All CRUD operations work offline\n// 3. Changes queue in SyncOperation collection\n// 4. SyncService pushes/pulls when online\n// 5. UI shows sync status\n// 6. Auto-sync on connectivity change",
              "solution": "// This is a large project - see lesson examples for complete implementation.\n//\n// Summary of key components:\n//\n// 1. Note model with serverId for sync tracking\n// 2. SyncOperation model to queue changes\n// 3. NoteRepository that wraps Isar operations\n// 4. SyncService that handles push/pull\n// 5. ConnectivityService for network status\n// 6. NotesScreen with StreamBuilder for reactive UI\n// 7. NoteEditorScreen for create/edit\n// 8. SyncIndicator widget showing online/offline\n//\n// The app should:\n// - Load instantly from local database\n// - Allow editing even when offline\n// - Queue changes automatically\n// - Sync in background when online\n// - Resolve conflicts with last-write-wins\n// - Show clear visual feedback for sync state",
              "language": "dart",
              "testCases": [],
              "hints": [
                {
                  "level": 1,
                  "text": "Start with the data layer (models, database) before UI"
                },
                {
                  "level": 2,
                  "text": "Use StreamBuilder with Isar's watch() for reactive updates"
                },
                {
                  "level": 3,
                  "text": "Create a mock API for testing sync without a real server"
                }
              ],
              "commonMistakes": [
                {
                  "mistake": "Waiting for sync before showing UI updates",
                  "consequence": "App feels slow and defeats offline-first purpose",
                  "correction": "Update local database immediately, sync in background"
                },
                {
                  "mistake": "Not handling sync failures gracefully",
                  "consequence": "Operations get stuck and never retry",
                  "correction": "Keep failed operations in queue, retry on next sync"
                }
              ],
              "difficulty": "advanced"
            }
          ]
        }
      ]
    }
  ]
}