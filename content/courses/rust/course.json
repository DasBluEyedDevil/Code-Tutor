{
  "id": "rust",
  "language": "rust",
  "title": "Rust Programming",
  "description": "Learn Rust from fundamentals to advanced concepts including ownership, borrowing, and systems programming.",
  "difficulty": "beginner",
  "estimatedHours": 19,
  "prerequisites": [],
  "modules": [
    {
      "id": "module-00",
      "title": "MODULE 00",
      "description": "Module 0",
      "difficulty": "beginner",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-00-01",
          "title": "Module 0, Lesson 1: Installing Rust (rustup and cargo)",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 0, Lesson 1: Installing Rust (rustup and cargo)\n\n## Why Do We Need This?\n\nImagine you want to build furniture. Before you can start, you need a workshop with the right tools. You wouldn't build a chair without a saw, a hammer, and some nails, right?\n\nProgramming is the same way. Before you can write programs in any language, you need the special tools that understand that language. These tools will:\n- Translate your human-readable instructions into something the computer can understand\n- Check your work for mistakes before running it\n- Help you organize your projects\n\nWe're going to install the complete set of tools you need to write programs in Rust. Think of it as setting up your coding workshop.\n\n## The Official Names\n\nThe \"workshop setup\" we just described has official names:\n\n- **Rustup**: This is the \"tool installer and manager.\" It downloads Rust and keeps it up to date. Think of it as the workshop manager who makes sure you always have the latest, best versions of your tools.\n\n- **Cargo**: This is Rust's \"project manager and build tool.\" It helps you create new projects, manage external code libraries (called \"crates\"), and compile your code into a running program. Cargo is like your workshop assistant who organizes everything.\n\n- **Rustc**: This is the actual \"compiler\" (the translator that turns your Rust code into a program the computer can run). You won't use this directly most of the timeâ€”Cargo will use it for you.\n\nWhen you install **rustup**, it automatically installs both **cargo** and **rustc**. It's a three-for-one deal!\n\n## How to Install\n\n### **For Windows Users:**\n\n1. Go to: https://rustup.rs/\n2. Download the `rustup-init.exe` file\n3. Run the downloaded file\n4. When asked, choose option `1` (default installation)\n5. Wait for installation to complete (this might take a few minutes)\n6. **Close and reopen** your terminal (this is important!)\n\n### **For macOS/Linux Users:**\n\n1. Open your terminal\n2. Copy and paste this command:\n   ```bash\n   curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n   ```\n3. Press Enter and follow the prompts\n4. When asked, choose option `1` (default installation)\n5. Wait for installation to complete\n6. **Close and reopen** your terminal\n\n## Verify Your Installation\n\nAfter installation, open a **new** terminal and run these commands one at a time:\n\n```bash\nrustup --version\ncargo --version\nrustc --version\n```\n\n**You should see something like this** (your numbers might be slightly different):\n```\nrustup 1.27.0 (...)\ncargo 1.75.0 (...)\nrustc 1.75.0 (...)\n```\n\nIf you see three version numbers, **congratulations!** Your Rust workshop is ready.\n\n## Troubleshooting\n\n**\"Command not found\" errors:**\n- Make sure you closed and reopened your terminal after installation\n- On Windows, try restarting your computer if the commands still don't work\n\n**Windows: \"Visual Studio C++ Build tools\" error:**\n- Follow the link in the error message to install the required Microsoft tools\n- This is normal for Windowsâ€”Rust needs these to compile programs\n\n---\n\n## âœ… Lesson Complete!\n\nYou now have Rust installed and ready to use. In the next lesson, we'll set up a code editor to make writing Rust code much easier.\n"
          }
        },
        {
          "id": "lesson-00-02",
          "title": "Module 0, Lesson 2: Setting up Visual Studio Code with rust-analyzer",
          "type": "reading",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 0, Lesson 2: Setting up Visual Studio Code with rust-analyzer\n\n## Why Do We Need This?\n\nImagine you're writing an essay by hand with pen and paper. It works, but it's slow. You have to manually check for spelling mistakes, you can't easily move paragraphs around, and if you want to know what a word means, you have to stop and look it up in a dictionary.\n\nNow imagine writing that same essay on a modern computer with a word processor. It automatically:\n- Underlines spelling mistakes as you type\n- Suggests better words\n- Shows you definitions when you hover over words\n- Lets you easily reorganize your text\n\nWriting code is exactly the same. You *could* write Rust programs in Notepad, but you'd be making your life much harder. Instead, we use a special \"code editor\" that watches what you're typing and helps you in real-time.\n\n## The Tools We're Installing\n\n**Visual Studio Code** (VS Code for short):\n- A free, professional code editor\n- Works on Windows, macOS, and Linux\n- The most popular code editor in the world\n- Think of it as \"Microsoft Word, but for code\"\n\n**rust-analyzer**:\n- An extension (plugin) that teaches VS Code to understand Rust\n- Shows you errors as you type (before you even run the code)\n- Suggests how to complete your code\n- Explains what your code does when you hover over it\n- Your \"Rust expert assistant\" that sits next to you while you code\n\n## Installation Steps\n\n### **Step 1: Install Visual Studio Code**\n\n1. Go to: https://code.visualstudio.com/\n2. Click the big download button for your operating system\n3. Run the installer and follow the default options\n4. Launch VS Code when installation completes\n\n### **Step 2: Install the rust-analyzer Extension**\n\n1. In VS Code, click the **Extensions** icon on the left sidebar (looks like four squares)\n   - Keyboard shortcut: `Ctrl+Shift+X` (Windows/Linux) or `Cmd+Shift+X` (macOS)\n2. In the search box, type: **rust-analyzer**\n3. Find the extension named **\"rust-analyzer\"** by matklad (should be the first result)\n4. Click the blue **\"Install\"** button\n5. Wait for it to finish installing\n\n### **Step 3: Test That It's Working**\n\nLet's verify rust-analyzer is active and helping you:\n\n1. In VS Code: **File â†’ Open Folder**\n2. Create a new empty folder anywhere on your computer called `rust-test`\n3. Open that folder in VS Code\n4. Create a new file named `test.rs` (click \"New File\" in VS Code)\n5. Type this code exactly:\n\n```rust\nfn main() {\n    let x = 5;\n    x = 10;\n}\n```\n\n6. **Look at line 3** (`x = 10;`) â€” you should see a **red squiggly underline**\n7. **Hover your mouse** over that underlined code\n8. **You should see an error message** appear in a tooltip!\n\nThe error message will say something like: *\"cannot assign twice to immutable variable\"*\n\nDon't worry about what that means yetâ€”we'll learn about it in Module 1. For now, if you see that error message pop up, **congratulations!** Your rust-analyzer is working perfectly.\n\n## What Just Happened?\n\nrust-analyzer analyzed your code in real-time and detected a problem before you even tried to run it. This is like having a spell-checker for code. Throughout this course, rust-analyzer will be your constant companion, catching mistakes and teaching you Rust's rules.\n\n## Troubleshooting\n\n**No red underline appears:**\n- Wait 10-20 secondsâ€”rust-analyzer needs a moment to start up the first time\n- Make sure your file is named with `.rs` extension (that's how VS Code knows it's Rust code)\n- Check the bottom-right corner of VS Code for any rust-analyzer status messages\n\n**Extension not found:**\n- Make sure you spelled it correctly: `rust-analyzer` (with a hyphen)\n- Ensure you have internet connection\n\n---\n\n## âœ… Lesson Complete!\n\nYour development environment is now fully set up. You have:\n- âœ… VS Code (your code editor)\n- âœ… rust-analyzer (your Rust assistant)\n\nYou're ready to write actual Rust code!\n"
          }
        },
        {
          "id": "lesson-00-03",
          "title": "Module 0, Lesson 3: Your First \"Hello, World!\" â€” Making the Computer Say Hello",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 0, Lesson 3: Your First \"Hello, World!\" â€” Making the Computer Say Hello\n\n## Why \"Hello, World\"?\n\nWhen learning any new programming language, the tradition is to write a simple program that displays \"Hello, World!\" on the screen. It's like learning to say \"Hello!\" when studying a new human language.\n\nThis simple program proves that:\n- Your tools are installed correctly\n- You can write code that the computer understands\n- You can run that code and see results\n- Everything is working!\n\n## How Programs Work: The Basic Cycle\n\nEvery program you write goes through three steps:\n\n1. **Write**: You type code in a file\n2. **Compile**: A tool translates your code into instructions the computer understands\n3. **Run**: The computer executes those instructions\n\nIn Rust, we use **Cargo** to do all three steps with one command: `cargo run`\n\n## The Anatomy of a Rust Program\n\nHere's a complete Rust program:\n\n```rust\nfn main() {\n    println!(\"Hello, World!\");\n}\n```\n\n**Breaking it down:**\n\n- `fn main()` â€” This is the \"main function,\" the entry point of your program. Every Rust program starts here.\n- `{ }` â€” Curly braces contain the code that runs\n- `println!(...)` â€” A command that prints text to the screen (the `!` makes it a \"macro\"â€”more on that later)\n- `\"Hello, World!\"` â€” The text to display (must be in double quotes)\n- `;` â€” Semicolon ends the statement (like a period ends a sentence)\n\n## Create Your First Program\n\n### **Step 1: Create a New Project**\n\nOpen your terminal and run:\n\n```bash\ncargo new hello\ncd hello\n```\n\nThis creates a new folder called `hello` with your project inside.\n\n### **Step 2: Open It in VS Code**\n\n```bash\ncode .\n```\n\n(The `.` means \"open the current folder\")\n\nIn VS Code, open the file `src/main.rs`. You'll see Cargo already created a \"Hello, World!\" program for you!\n\n### **Step 3: Run It**\n\nIn your terminal (inside the `hello` folder), run:\n\n```bash\ncargo run\n```\n\n**You should see:**\n\n```\n   Compiling hello v0.1.0 (/path/to/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.23s\n     Running `target/debug/hello`\nHello, world!\n```\n\nThe last line is your program's output. **You did it!**\n\n### **Step 4: Make It Personal**\n\nChange the text in `src/main.rs`:\n\n```rust\nfn main() {\n    println!(\"Hello, my name is Alex!\");\n    println!(\"I'm learning Rust!\");\n}\n```\n\nSave the file and run `cargo run` again. You'll see your custom messages!\n\n## Experiments: Learn by Breaking Things\n\nThe best way to learn is to experiment. Try these:\n\n**Experiment 1: Remove the semicolon**\n```rust\nfn main() {\n    println!(\"Hello!\")  // â† No semicolon\n}\n```\nRun `cargo run`. What error do you get? Read it carefully, then add the semicolon back.\n\n**Experiment 2: Remove the exclamation mark**\n```rust\nfn main() {\n    println(\"Hello!\");  // â† No exclamation mark\n}\n```\nRun `cargo run`. What does the error say? Add the `!` back.\n\n**Experiment 3: Print multiple lines**\n```rust\nfn main() {\n    println!(\"Line 1\");\n    println!(\"Line 2\");\n    println!(\"Line 3\");\n}\n```\n\n## What You've Learned\n\n- âœ… `cargo new` creates a new Rust project\n- âœ… `cargo run` compiles and runs your program\n- âœ… `fn main()` is where every program starts\n- âœ… `println!()` prints text to the screen\n- âœ… Semicolons are required at the end of statements\n- âœ… Compiler errors are helpfulâ€”they tell you exactly what's wrong!\n"
          }
        },
        {
          "id": "lesson-00-04",
          "title": "Module 0, Lesson 4: Understanding Cargo â€” Your Project Manager",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 0, Lesson 4: Understanding Cargo â€” Your Project Manager\n\n## Why Do We Need Cargo?\n\nImagine you're building a house. You could do everything yourselfâ€”mix concrete, cut wood, wire electricityâ€”or you could hire a general contractor who handles all the organizational work while you focus on the design.\n\nCargo is your \"general contractor\" for Rust projects. It handles:\n- Compiling your code\n- Organizing your project files\n- Downloading and managing external libraries\n- Running tests\n- Building optimized versions for release\n\nYou could do all of this manually, but Cargo makes it automatic and effortless.\n\n## What Is Cargo?\n\n**Cargo** is Rust's official:\n- **Build System**: Compiles your code from human-readable text to computer-executable programs\n- **Package Manager**: Downloads and manages external code libraries (called \"crates\")\n\nThink of it as the tool that sits between you and the Rust compiler, making your life easier.\n\n## The Project Structure Cargo Creates\n\nWhen you run `cargo new hello`, you get:\n\n```\nhello/                    â† Project folder\nâ”œâ”€â”€ Cargo.toml           â† Configuration file\nâ”œâ”€â”€ src/                 â† Your code goes here\nâ”‚   â””â”€â”€ main.rs         â† Main program file\nâ””â”€â”€ target/              â† Compiled output (appears after first build)\n    â””â”€â”€ debug/\n        â””â”€â”€ hello        â† The executable program\n```\n\n**Cargo.toml** (the configuration file):\n```toml\n[package]\nname = \"hello\"          # Your program's name\nversion = \"0.1.0\"       # Version number\nedition = \"2021\"        # Rust edition\n\n[dependencies]\n# External libraries go here\n```\n\nThis file tells Cargo everything about your project: its name, version, and which external libraries it needs.\n\n**src/main.rs** â€” This is where you write your actual code.\n\n**target/** â€” Where Cargo puts compiled files. You never edit anything here.\n\n## Essential Cargo Commands\n\nHere are the commands you'll use constantly:\n\n| Command | What It Does |\n|---------|-------------|\n| `cargo new [name]` | Creates a new project |\n| `cargo check` | Quickly checks if your code compiles (doesn't create an executable) |\n| `cargo build` | Compiles your code into an executable |\n| `cargo run` | Compiles (if needed) and runs your program |\n| `cargo clean` | Deletes compiled files to free up space |\n| `cargo test` | Runs automated tests (you'll learn this later) |\n\n**Pro tip:** `cargo run` is smartâ€”if you haven't changed your code since the last build, it just runs the program without recompiling.\n\n## Hands-On Practice\n\n### **Create a Test Project**\n\n```bash\ncargo new cargo_practice\ncd cargo_practice\n```\n\n### **Try Each Command**\n\n**1. Check if your code compiles (very fast):**\n```bash\ncargo check\n```\nThis verifies your code is valid without creating an executable. Use this for quick feedback while writing code.\n\n**2. Build your program:**\n```bash\ncargo build\n```\nThis creates an executable in `target/debug/cargo_practice`.\n\n**3. Run the compiled program directly:**\n```bash\n# macOS/Linux\n./target/debug/cargo_practice\n\n# Windows\n.\\target\\debug\\cargo_practice.exe\n```\n\n**4. Build and run in one command:**\n```bash\ncargo run\n```\nNotice it says \"Finished\" almost instantly the second timeâ€”Cargo detected nothing changed.\n\n**5. Modify the code:**\n- Open `src/main.rs` in VS Code\n- Change the message\n- Save the file\n- Run `cargo run` again\n\nCargo automatically detects the change and recompiles!\n\n**6. Clean up:**\n```bash\ncargo clean\n```\nThis deletes the `target/` folder to free up disk space. Useful when you have many projects.\n\n## Debug vs. Release Builds\n\nCargo can build your program in two modes:\n\n- **Debug mode** (default): Includes extra information for debugging, runs slower\n  - Command: `cargo build` or `cargo run`\n  - Output: `target/debug/`\n\n- **Release mode**: Optimized for speed, smaller file size\n  - Command: `cargo build --release` or `cargo run --release`\n  - Output: `target/release/`\n\nUse debug mode while developing. Use release mode when giving your program to others.\n\n## What You've Learned\n\n- âœ… Cargo is Rust's build system and package manager\n- âœ… `cargo new` creates a new project with the right structure\n- âœ… `Cargo.toml` is the configuration file\n- âœ… Your code goes in `src/main.rs`\n- âœ… `cargo check` quickly validates your code\n- âœ… `cargo build` compiles your program\n- âœ… `cargo run` compiles and runs in one command\n- âœ… `cargo clean` frees up disk space\n- âœ… Cargo automatically detects when code changes and rebuilds only what's necessary\n\n---\n\n## âœ… Module 0 Complete!\n\nYou've set up your entire Rust development environment:\n- âœ… Installed Rust (rustup, cargo, rustc)\n- âœ… Configured VS Code with rust-analyzer\n- âœ… Created and ran your first Rust program\n- âœ… Learned how to use Cargo to manage projects\n\n**You're now ready to start learning the Rust language itself!**\n"
          }
        }
      ]
    },
    {
      "id": "module-01",
      "title": "MODULE 01",
      "description": "Module 1",
      "difficulty": "beginner",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-01-01",
          "title": "Module 1, Lesson 1: The `main()` Function â€” Where Your Program Starts",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 1, Lesson 1: The `main()` Function â€” Where Your Program Starts\n\n## The Entry Point Concept\n\nImagine reading a book. You start at page 1, chapter 1â€”not at some random page in the middle. The same is true for computer programs. When you run a program, the computer needs to know where to start.\n\nIn Rust, that starting point is always the same: a special function called **main**.\n\nWhen you run a Rust program:\n1. The computer looks for a function named `main`\n2. It starts executing code from the first line inside `main()`\n3. It runs each line in order, from top to bottom\n4. When it reaches the end of `main()`, the program exits\n\nThink of `main()` as the front door to your program.\n\n## The main() Function Syntax\n\n```rust\nfn main() {\n    // Your code goes here\n}\n```\n\n**Breaking it down:**\n- `fn` â€” Keyword meaning \"function\"\n- `main` â€” The name (must be exactly \"main\" for the entry point)\n- `()` â€” Parentheses (parameters go here, empty for now)\n- `{ }` â€” Curly braces containing the code to execute\n\n## Code Examples\n\n**The simplest valid Rust program:**\n```rust\nfn main() {\n    // Does nothing, but it compiles and runs!\n}\n```\n\n**A program that produces output:**\n```rust\nfn main() {\n    println!(\"Line 1\");\n    println!(\"Line 2\");\n    println!(\"Line 3\");\n}\n```\n\nOutput:\n```\nLine 1\nLine 2\nLine 3\n```\n\nThe code executes from top to bottom, one line at a time.\n\n**What happens without main():**\n```rust\n// âŒ This will NOT compile\nprintln!(\"Hello!\");\n```\n\nError:\n```\nerror[E0601]: `main` function not found\n```\n\nRust requires a `main()` functionâ€”it's the only way the compiler knows where your program begins.\n\n## Hands-On Practice\n\n### **Create a Test Project**\n\n```bash\ncargo new main_practice\ncd main_practice\ncode .\n```\n\n### **Experiment 1: Add Multiple Lines**\n\nModify `src/main.rs`:\n\n```rust\nfn main() {\n    println!(\"Starting program\");\n    println!(\"Doing something\");\n    println!(\"Doing something else\");\n    println!(\"Ending program\");\n}\n```\n\nRun `cargo run` and observe the output order.\n\n### **Experiment 2: Remove main() and See the Error**\n\nDelete everything and write:\n\n```rust\nprintln!(\"Hello!\");\n```\n\nRun `cargo run`. You'll get: `error: main function not found`\n\nThis error teaches you that `main()` is mandatory.\n\nAdd it back:\n\n```rust\nfn main() {\n    println!(\"Hello!\");\n}\n```\n\nNow it works!\n\n### **Experiment 3: Capitalization Matters**\n\nTry this:\n\n```rust\nfn Main() {  // âŒ Wrong - capital M\n    println!(\"Hello!\");\n}\n```\n\nRun `cargo run`. Error: `main function not found`\n\nRust is case-sensitive. It must be lowercase: `main`\n\n### **Experiment 4: Prove Execution Order**\n\n```rust\nfn main() {\n    println!(\"First\");\n    println!(\"Second\");\n    println!(\"Third\");\n}\n```\n\nRun it. Now rearrange the lines:\n\n```rust\nfn main() {\n    println!(\"Third\");\n    println!(\"First\");\n    println!(\"Second\");\n}\n```\n\nRun it againâ€”the output changes. This proves code runs from top to bottom.\n\n## Key Takeaways\n\n- âœ… Every Rust program needs exactly one `main()` function\n- âœ… `main()` is the entry pointâ€”where execution begins\n- âœ… Code inside `main()` runs from top to bottom\n- âœ… The function must be named `main` (lowercase)\n- âœ… The syntax is: `fn main() { ... }`\n- âœ… If there's no `main()`, the program won't compile\n"
          }
        },
        {
          "id": "lesson-01-02",
          "title": "Module 1, Lesson 2: Running Your Code with `cargo run`",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 1, Lesson 2: Running Your Code with `cargo run`\n\n## The Translation Process\n\nImagine you write a recipe in English, but you're giving it to a robot chef that only understands a special robot language. You need a translator to convert your English recipe into robot instructions before the robot can make cookies.\n\nProgramming is the same:\n- **You write**: Rust code (human-readable)\n- **Computer needs**: Machine code (binaryâ€”ones and zeros)\n- **The solution**: A translator called a **compiler**\n\nThe Rust compiler (called `rustc`) translates your `.rs` files into executable programs.\n\n## What is Compilation?\n\n**Compilation** is the process of translating your code from human-readable Rust into machine code the computer can execute.\n\n```\nYour Code (main.rs)  â†’  [Compiler/rustc]  â†’  Executable Binary\n  Human-readable          Translation          Machine code\n```\n\nThe **executable** (also called a **binary**) is the actual program you run.\n\n## The `cargo run` Command\n\nInstead of manually compiling and running, you use **`cargo run`**, which:\n1. Checks if your code changed since the last compilation\n2. If yes: Compiles your code\n3. Runs the resulting executable\n4. Shows any output\n\nIf nothing changed, it skips compilation and just runs the existing executable.\n\n## What You See When Running cargo run\n\nGiven this code:\n\n```rust\nfn main() {\n    println!(\"Hello from Rust!\");\n}\n```\n\nWhen you run `cargo run`:\n\n```\n   Compiling hello v0.1.0 (/path/to/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.52s\n     Running `target/debug/hello`\nHello from Rust!\n```\n\n**Breaking it down:**\n\n1. **Compiling hello v0.1.0** â€” Cargo is translating your code\n2. **Finished dev** â€” Compilation successful (debug mode)\n3. **Running target/debug/hello** â€” Cargo is executing the program\n4. **Hello from Rust!** â€” Your program's output\n\n**Run again without changes:**\n\n```\n    Finished dev [unoptimized + debuginfo] target(s) in 0.01s\n     Running `target/debug/hello`\nHello from Rust!\n```\n\nNo \"Compiling\" lineâ€”Cargo is smart and skipped recompilation!\n\n## Hands-On Practice\n\n### **Create a Test Project**\n\n```bash\ncargo new run_practice\ncd run_practice\n```\n\n### **Experiment 1: Run Twice**\n\n```bash\ncargo run   # First run - will compile\ncargo run   # Second run - skips compilation\n```\n\nNotice the difference in output!\n\n### **Experiment 2: Modify and Rerun**\n\n1. Change the message in `src/main.rs`\n2. Save the file\n3. Run `cargo run`\n\nThe \"Compiling\" line appears againâ€”Cargo detected your change.\n\n### **Experiment 3: Find the Executable**\n\nAfter `cargo run`, check `target/debug/`:\n\n```bash\nls target/debug/        # macOS/Linux\ndir target\\debug\\       # Windows\n```\n\nYou'll see `run_practice` (or `run_practice.exe` on Windows). This is your compiled program!\n\nRun it directly:\n\n```bash\n./target/debug/run_practice        # macOS/Linux\n.\\target\\debug\\run_practice.exe    # Windows\n```\n\nSame output as `cargo run`!\n\n### **Experiment 4: cargo build vs. cargo run**\n\nTry this:\n\n```bash\ncargo build   # Only compiles, doesn't run\n```\n\nYou'll see \"Compiling\" and \"Finished,\" but no output from your program. To run it, you'd execute the binary manually.\n\n**When to use each:**\n- **`cargo run`** â€” Compile and run (use this 99% of the time)\n- **`cargo build`** â€” Only compile (when you want the executable but don't need to run it yet)\n\n### **Experiment 5: Compilation Errors**\n\nIntroduce an error in `main.rs`:\n\n```rust\nfn main() {\n    println!(\"Hello\")  // âŒ Missing semicolon\n}\n```\n\nRun `cargo run`:\n\n```\nerror: expected `;`, found `}`\n```\n\nThe compiler caught the mistake! Your program never ran because it failed to compile.\n\nFix it and run againâ€”now it works.\n\n## Key Takeaways\n\n- âœ… **Compilation** translates Rust code into machine code (executable)\n- âœ… **`cargo run`** compiles (if needed) and runs your program\n- âœ… Cargo is smartâ€”it only recompiles when code changes\n- âœ… The compiled executable lives in `target/debug/`\n- âœ… You can run the executable directly without Cargo\n- âœ… **`cargo build`** compiles without running\n- âœ… Compilation errors prevent your program from running\n"
          }
        },
        {
          "id": "lesson-01-03",
          "title": "Module 1, Lesson 3: Variables and Boxes â€” Storing Information (`let`, `mut`)",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 1, Lesson 3: Variables and Boxes â€” Storing Information (`let`, `mut`)\n\n## The Concept: Labeled Boxes\n\nImagine organizing your desk with sticky notes to remember important information:\n- Friend's phone number: \"555-1234\"\n- Book to read: \"The Hobbit\"\n- Apples you have: 5\n\nEach sticky note has:\n- A **label** (what it represents)\n- A **value** (the actual information)\n\nNow imagine two types of sticky notes:\n\n1. **Permanent marker** â€” Once written, can't be changed\n2. **Pencil** â€” Can be erased and rewritten\n\nIn Rust, you store information in \"labeled boxes\" called **variables**. By default, Rust gives you permanent marker boxesâ€”once you set a value, it can't change. If you want to change a value later, you explicitly ask for a pencil box.\n\nThis prevents bugs caused by accidentally changing values you didn't mean to change.\n\n## Creating Variables: The `let` Keyword\n\nTo create a variable, use **`let`**:\n\n```rust\nlet apple_count = 5;\n```\n\nThis means: \"Create a variable named `apple_count` and store the value `5` in it.\"\n\n**Important: Variables are immutable by default**\n\n**Immutable** means \"cannot be changed\":\n\n```rust\nlet score = 100;\nscore = 150;  // âŒ ERROR: cannot assign twice to immutable variable\n```\n\nOnce you create a variable with `let`, you can't modify its value.\n\n## Making Variables Changeable: The `mut` Keyword\n\nIf you want a variable that CAN be modified, use **`mut`** (short for \"mutable\"):\n\n```rust\nlet mut score = 100;  // Now it's mutable\nscore = 150;          // âœ… OK: we can change it\n```\n\nThink of it this way:\n- **`let`** = permanent marker (immutable)\n- **`let mut`** = pencil (mutable)\n\n## Why Immutable by Default?\n\nRust's philosophy: \"If something doesn't need to change, it shouldn't be allowed to change.\"\n\nThis prevents bugs. Imagine:\n\n```rust\nlet max_lives = 3;  // Game rule: 3 lives\n\n// ... 100 lines of code ...\n\nmax_lives = 5;  // âŒ Compiler error!\n```\n\nIf this were allowed, you might accidentally break your game logic. Immutability protects you.\n\n## Code Examples\n\n**Creating multiple variables:**\n\n```rust\nfn main() {\n    let name = \"Alice\";\n    let age = 30;\n    let is_student = true;\n\n    println!(\"Name: {}\", name);\n    println!(\"Age: {}\", age);\n    println!(\"Is student: {}\", is_student);\n}\n```\n\nOutput:\n```\nName: Alice\nAge: 30\nIs student: true\n```\n\n**Trying to change an immutable variable (ERROR):**\n\n```rust\nfn main() {\n    let score = 100;\n    score = 150;  // âŒ ERROR\n}\n```\n\nError:\n```\nerror[E0384]: cannot assign twice to immutable variable `score`\n```\n\n**Using mut to allow changes:**\n\n```rust\nfn main() {\n    let mut score = 100;\n    println!(\"Initial: {}\", score);\n\n    score = 150;\n    println!(\"Updated: {}\", score);\n\n    score = score + 50;\n    println!(\"Final: {}\", score);\n}\n```\n\nOutput:\n```\nInitial: 100\nUpdated: 150\nFinal: 200\n```\n\n## Hands-On Practice\n\n### **Create a Test Project**\n\n```bash\ncargo new variables_practice\ncd variables_practice\ncode .\n```\n\n### **Experiment 1: Immutable Variables**\n\n```rust\nfn main() {\n    let name = \"Bob\";\n    let favorite_number = 42;\n\n    println!(\"My name is {}\", name);\n    println!(\"My favorite number is {}\", favorite_number);\n}\n```\n\nRun `cargo run`.\n\n### **Experiment 2: Try to Change an Immutable Variable**\n\nAdd this line:\n\n```rust\nfavorite_number = 100;  // Try to change it\n```\n\nRun `cargo run`. You'll get an error. Read it carefully!\n\nRemove that line before continuing.\n\n### **Experiment 3: Mutable Variables**\n\n```rust\nfn main() {\n    let mut counter = 0;\n    println!(\"Counter: {}\", counter);\n\n    counter = counter + 1;\n    println!(\"Counter: {}\", counter);\n\n    counter = counter + 1;\n    println!(\"Counter: {}\", counter);\n}\n```\n\nOutput:\n```\nCounter: 0\nCounter: 1\nCounter: 2\n```\n\n### **Experiment 4: Temperature Tracker**\n\n```rust\nfn main() {\n    let mut temperature = 20;\n\n    println!(\"Morning: {}Â°C\", temperature);\n\n    temperature = temperature + 5;\n    println!(\"Afternoon: {}Â°C\", temperature);\n\n    temperature = temperature - 3;\n    println!(\"Evening: {}Â°C\", temperature);\n}\n```\n\n### **Challenge: Score Tracker**\n\nWrite a program that:\n1. Starts with `score = 0`\n2. Adds 10 points, prints it\n3. Adds 25 points, prints it\n4. Subtracts 5 points, prints it\n\nExpected output: `0 â†’ 10 â†’ 35 â†’ 30`\n\n## Key Takeaways\n\n- âœ… **Variables** store labeled values\n- âœ… **`let`** creates an immutable (unchangeable) variable\n- âœ… **`let mut`** creates a mutable (changeable) variable\n- âœ… Immutability by default prevents accidental bugs\n- âœ… Use `mut` only when you need to change a value\n- âœ… `println!(\"Value: {}\", var)` displays variable values\n"
          }
        },
        {
          "id": "lesson-01-04",
          "title": "Module 1, Lesson 4: Numbers and Text â€” The Basic Types of Data",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 1, Lesson 4: Numbers and Text â€” The Basic Types of Data\n\n## Understanding Data Types\n\nImagine organizing a filing cabinet with different types of information:\n- **Whole numbers**: 1, 2, 3, 100 (counting apples)\n- **Decimal numbers**: 3.14, 98.6, -5.5 (temperature, measurements)\n- **Yes/No answers**: true or false (Is it raining?)\n- **Text**: Words and sentences (names, messages)\n\nYou wouldn't mix these upâ€”you can't do math with words, or spell sentences with numbers. Each type of information has its own rules.\n\nComputers need to know what KIND of data they're working with. This is called the data's **type**.\n\n## Rust's Basic Types\n\n**Integers (whole numbers):**\n- `i32` â€” Signed integer (can be negative), default for whole numbers\n  - Range: about -2 billion to +2 billion\n- `i64` â€” Larger signed integer\n- `u32` â€” Unsigned (positive only)\n\n**Floating-point (decimal numbers):**\n- `f64` â€” 64-bit decimal number, default for decimals\n  - Examples: 3.14, -0.5, 100.0\n\n**Boolean (true/false):**\n- `bool` â€” Either `true` or `false`\n\n**Characters:**\n- `char` â€” Single character (use single quotes)\n  - Examples: `'a'`, `'Z'`, `'ðŸ˜€'`\n\n**Strings (text):**\n- `&str` â€” Text in double quotes: `\"Hello\"`\n- `String` â€” Owned, growable text (Module 5)\n\n## Type Inference\n\nRust can usually figure out types automatically:\n\n```rust\nlet age = 30;  // Rust knows this is i32\nlet pi = 3.14; // Rust knows this is f64\n```\n\nBut you can specify explicitly:\n\n```rust\nlet age: i32 = 30;\nlet pi: f64 = 3.14;\n```\n\n## Code Examples\n\n**Creating variables of different types:**\n\n```rust\nfn main() {\n    // Integers\n    let apples = 5;\n    let big_number: i64 = 1_000_000;  // Underscores for readability\n\n    // Floating-point\n    let pi = 3.14;\n    let temperature: f32 = 98.6;\n\n    // Boolean\n    let is_raining = false;\n    let is_sunny = true;\n\n    // Characters (single quotes!)\n    let letter = 'A';\n    let emoji = 'ðŸ˜€';\n\n    // Strings (double quotes!)\n    let name = \"Alice\";\n    let greeting = \"Hello!\";\n\n    println!(\"Apples: {}\", apples);\n    println!(\"Pi: {}\", pi);\n    println!(\"Is raining: {}\", is_raining);\n    println!(\"Letter: {}\", letter);\n    println!(\"Name: {}\", name);\n}\n```\n\n**Math operations:**\n\n```rust\nfn main() {\n    let x = 10;\n    let y = 3;\n\n    let sum = x + y;          // 13\n    let difference = x - y;   // 7\n    let product = x * y;      // 30\n    let quotient = x / y;     // 3 (integer division)\n    let remainder = x % y;    // 1 (modulo)\n\n    println!(\"Sum: {}\", sum);\n    println!(\"Product: {}\", product);\n    println!(\"Remainder: {}\", remainder);\n}\n```\n\n**Type mismatch (ERROR):**\n\n```rust\nfn main() {\n    let integer_num = 10;\n    let float_num = 3.5;\n\n    let result = integer_num + float_num;  // âŒ ERROR: mismatched types\n}\n```\n\nYou can't directly mix integers and floats. Rust enforces type safety!\n\n## Hands-On Practice\n\n### **Create a Test Project**\n\n```bash\ncargo new types_practice\ncd types_practice\ncode .\n```\n\n### **Experiment 1: Different Types**\n\n```rust\nfn main() {\n    let age = 25;\n    let price = 9.99;\n    let is_student = true;\n    let grade = 'A';\n    let name = \"Bob\";\n\n    println!(\"Age: {}\", age);\n    println!(\"Price: ${}\", price);\n    println!(\"Is student: {}\", is_student);\n    println!(\"Grade: {}\", grade);\n    println!(\"Name: {}\", name);\n}\n```\n\n### **Experiment 2: Math Operations**\n\n```rust\nfn main() {\n    let apples = 10;\n    let people = 3;\n\n    let apples_per_person = apples / people;\n    let leftover = apples % people;\n\n    println!(\"Each person gets {} apples\", apples_per_person);\n    println!(\"{} apples left over\", leftover);\n}\n```\n\n### **Experiment 3: Type Mismatch**\n\n```rust\nfn main() {\n    let whole = 10;\n    let decimal = 3.5;\n\n    let result = whole + decimal;  // âŒ Try this and see the error!\n}\n```\n\nRun `cargo run` to see the compiler error. Then comment it out.\n\n### **Challenge: Temperature Converter**\n\nConvert Celsius to Fahrenheit using: `F = C * 1.8 + 32.0`\n\n```rust\nfn main() {\n    let celsius = 25.0;\n    let fahrenheit = celsius * 1.8 + 32.0;\n\n    println!(\"{}Â°C is {}Â°F\", celsius, fahrenheit);\n}\n```\n\nExpected output: `25Â°C is 77Â°F`\n\n## Key Takeaways\n\n- âœ… **Type** defines what kind of data a variable holds\n- âœ… `i32` â€” Default integer type\n- âœ… `f64` â€” Default floating-point type\n- âœ… `bool` â€” True or false\n- âœ… `char` â€” Single character (single quotes)\n- âœ… `&str` â€” Text strings (double quotes)\n- âœ… Rust infers types but you can specify them explicitly\n- âœ… You can't mix types directly (type safety!)\n- âœ… Math operators: `+`, `-`, `*`, `/`, `%`\n"
          }
        },
        {
          "id": "lesson-01-05",
          "title": "Module 1, Lesson 5: Functions â€” Teaching Your Program New Tricks",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 1, Lesson 5: Functions â€” Teaching Your Program New Tricks\n\n## The Concept: Reusable Recipes\n\nImagine you teach a friend how to make coffee:\n1. Grind the beans\n2. Boil water\n3. Brew for 4 minutes\n4. Pour into cup\n\nNow, instead of repeating these steps every time, you just say **\"make coffee\"** and your friend knows exactly what to do.\n\nFunctions work the same way in programming. Instead of writing the same code over and over, you:\n1. **Define** a function once (teach the recipe)\n2. **Call** the function whenever you need it (say \"do the thing\")\n\n## Creating Functions\n\nA **function** is a named block of code that performs a specific task.\n\n**Syntax:**\n\n```rust\nfn function_name() {\n    // Code goes here\n}\n```\n\n- `fn` â€” Keyword for \"function\"\n- `function_name` â€” The name you give it (use snake_case: lowercase with underscores)\n- `()` â€” Parameters go here (empty for now)\n- `{ }` â€” The code to execute\n\n**Example:**\n\n```rust\nfn greet() {\n    println!(\"Hello!\");\n    println!(\"Welcome to Rust!\");\n}\n\nfn main() {\n    greet();  // Call the function\n    greet();  // Call it again\n}\n```\n\nOutput:\n```\nHello!\nWelcome to Rust!\nHello!\nWelcome to Rust!\n```\n\nThe `greet()` code runs twice, but we only wrote it once!\n\n## Functions with Parameters\n\n**Parameters** let you pass information into a function.\n\nThink of it like: \"Make coffee for 2 people\" vs. \"Make coffee for 5 people\"â€”the number of people is a parameter.\n\n**Syntax:**\n\n```rust\nfn function_name(parameter_name: Type) {\n    // Use parameter_name here\n}\n```\n\n**Example:**\n\n```rust\nfn greet_person(name: &str) {\n    println!(\"Hello, {}!\", name);\n    println!(\"Nice to meet you!\");\n}\n\nfn main() {\n    greet_person(\"Alice\");\n    greet_person(\"Bob\");\n    greet_person(\"Charlie\");\n}\n```\n\nOutput:\n```\nHello, Alice!\nNice to meet you!\nHello, Bob!\nNice to meet you!\nHello, Charlie!\nNice to meet you!\n```\n\n**Multiple parameters:**\n\n```rust\nfn introduce(name: &str, age: i32) {\n    println!(\"My name is {} and I'm {} years old\", name, age);\n}\n\nfn main() {\n    introduce(\"Alice\", 30);\n    introduce(\"Bob\", 25);\n}\n```\n\n## Functions that Return Values\n\nFunctions can **return** a result back to the caller.\n\nThink of it like asking: \"What's 5 + 3?\" and getting back \"8\".\n\n**Syntax:**\n\n```rust\nfn function_name() -> ReturnType {\n    // Code here\n    return_value  // No semicolon on the last expression!\n}\n```\n\n**Example:**\n\n```rust\nfn add(x: i32, y: i32) -> i32 {\n    x + y  // Return the sum (no semicolon!)\n}\n\nfn main() {\n    let result = add(5, 3);\n    println!(\"5 + 3 = {}\", result);\n\n    let another_result = add(10, 20);\n    println!(\"10 + 20 = {}\", another_result);\n}\n```\n\nOutput:\n```\n5 + 3 = 8\n10 + 20 = 30\n```\n\n**Important:** The last expression in a function (without a semicolon) is automatically returned.\n\nYou can also use `return` explicitly:\n\n```rust\nfn add(x: i32, y: i32) -> i32 {\n    return x + y;  // Explicit return with semicolon\n}\n```\n\nBoth styles work, but omitting `return` is more idiomatic in Rust.\n\n## Complete Example\n\n```rust\nfn main() {\n    greet();\n\n    let temp_f = celsius_to_fahrenheit(25.0);\n    println!(\"25Â°C is {}Â°F\", temp_f);\n\n    let area = rectangle_area(5, 10);\n    println!(\"Rectangle area: {}\", area);\n}\n\nfn greet() {\n    println!(\"Welcome to the program!\");\n}\n\nfn celsius_to_fahrenheit(celsius: f64) -> f64 {\n    celsius * 1.8 + 32.0\n}\n\nfn rectangle_area(width: i32, height: i32) -> i32 {\n    width * height\n}\n```\n\n## Hands-On Practice\n\n### **Create a Practice Project**\n\n```bash\ncargo new functions_practice\ncd functions_practice\ncode .\n```\n\n### **Experiment 1: Simple Function**\n\n```rust\nfn say_hello() {\n    println!(\"Hello, world!\");\n}\n\nfn main() {\n    say_hello();\n    say_hello();\n    say_hello();\n}\n```\n\n### **Experiment 2: Function with Parameters**\n\n```rust\nfn print_number(n: i32) {\n    println!(\"The number is: {}\", n);\n}\n\nfn main() {\n    print_number(5);\n    print_number(100);\n    print_number(-42);\n}\n```\n\n### **Experiment 3: Function that Returns a Value**\n\n```rust\nfn square(n: i32) -> i32 {\n    n * n\n}\n\nfn main() {\n    let result = square(5);\n    println!(\"5 squared is {}\", result);\n\n    println!(\"10 squared is {}\", square(10));\n}\n```\n\n### **Challenge: Create a Calculator**\n\nWrite four functions:\n- `add(a, b)` â€” Returns `a + b`\n- `subtract(a, b)` â€” Returns `a - b`\n- `multiply(a, b)` â€” Returns `a * b`\n- `divide(a, b)` â€” Returns `a / b`\n\nThen use them in `main()`:\n\n```rust\nfn main() {\n    println!(\"10 + 5 = {}\", add(10, 5));\n    println!(\"10 - 5 = {}\", subtract(10, 5));\n    println!(\"10 * 5 = {}\", multiply(10, 5));\n    println!(\"10 / 5 = {}\", divide(10, 5));\n}\n\nfn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n// Write subtract, multiply, and divide here!\n```\n\n## Key Takeaways\n\n- âœ… Functions are reusable blocks of code\n- âœ… `fn name() { }` defines a function\n- âœ… Call a function with `name()`\n- âœ… Parameters pass data into functions: `fn name(param: Type)`\n- âœ… Return values with `-> Type`\n- âœ… Last expression (without `;`) is automatically returned\n- âœ… Functions make code more organized and reusable\n"
          }
        },
        {
          "id": "lesson-01-06",
          "title": "Module 1, Lesson 6: Comments â€” Leaving Notes for Yourself",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 1, Lesson 6: Comments â€” Leaving Notes for Yourself\n\n## The Concept: Notes in Your Code\n\nImagine you're cooking with a recipe book. Some recipes have helpful notes like:\n- \"This step takes 30 minutes\"\n- \"You can substitute butter for oil\"\n- \"Be careful not to overheat!\"\n\nThese notes aren't ingredients or instructionsâ€”they're explanations to help you understand what's happening.\n\nIn programming, **comments** are notes you leave in your code to:\n- Explain what the code does\n- Remind yourself why you did something\n- Help others understand your code\n- Temporarily disable code without deleting it\n\nThe computer completely ignores commentsâ€”they're only for humans.\n\n## Types of Comments in Rust\n\n### **1. Single-Line Comments (`//`)**\n\nEverything after `//` on that line is a comment:\n\n```rust\nfn main() {\n    // This is a comment\n    println!(\"Hello!\");  // This is also a comment\n\n    // Comments can explain what the next line does\n    let age = 25;\n}\n```\n\n### **2. Multi-Line Comments (`/* */`)**\n\nFor longer explanations:\n\n```rust\nfn main() {\n    /*\n       This is a multi-line comment.\n       It can span multiple lines.\n       Useful for longer explanations.\n    */\n    println!(\"Hello!\");\n\n    /* You can also use it on one line */\n    let x = 5;\n}\n```\n\n### **3. Documentation Comments (`///`)**\n\nSpecial comments that generate documentation (we'll use these later):\n\n```rust\n/// This function greets a person by name.\n///\n/// # Examples\n/// ```\n/// greet_person(\"Alice\");\n/// ```\nfn greet_person(name: &str) {\n    println!(\"Hello, {}!\", name);\n}\n```\n\nFor now, stick with `//` commentsâ€”they're the most common.\n\n## When to Use Comments\n\n**Good uses:**\n\n```rust\nfn main() {\n    // Convert Celsius to Fahrenheit\n    let celsius = 25.0;\n    let fahrenheit = celsius * 1.8 + 32.0;\n\n    // Display the result\n    println!(\"{}Â°C is {}Â°F\", celsius, fahrenheit);\n}\n```\n\n**Explaining WHY, not WHAT:**\n\n```rust\n// Good: Explains WHY\n// We use i64 here because the number can exceed i32's limit\nlet world_population: i64 = 7_900_000_000;\n\n// Bad: Just repeats what the code says\n// Create a variable called x and set it to 5\nlet x = 5;\n```\n\n**Good comments explain the purpose, not the syntax.**\n\n## Commenting Out Code\n\nUse comments to temporarily disable code:\n\n```rust\nfn main() {\n    println!(\"This runs\");\n    // println!(\"This doesn't run\");\n    println!(\"This runs too\");\n}\n```\n\nOutput:\n```\nThis runs\nThis runs too\n```\n\nUseful while debugging or testing!\n\n## Complete Example\n\n```rust\nfn main() {\n    // Temperature conversion program\n    // Takes a Celsius temperature and converts it to Fahrenheit\n\n    let celsius = 25.0;  // Starting temperature\n\n    // Formula: F = C * 1.8 + 32\n    let fahrenheit = celsius * 1.8 + 32.0;\n\n    // Display the result\n    println!(\"{}Â°C equals {}Â°F\", celsius, fahrenheit);\n\n    // Uncomment the line below to test with a different temperature\n    // celsius_to_fahrenheit(100.0);\n}\n\n/// Converts Celsius to Fahrenheit and prints the result\nfn celsius_to_fahrenheit(c: f64) {\n    let f = c * 1.8 + 32.0;\n    println!(\"{}Â°C equals {}Â°F\", c, f);\n}\n```\n\n## Hands-On Practice\n\n### **Create a Practice Project**\n\n```bash\ncargo new comments_practice\ncd comments_practice\ncode .\n```\n\n### **Experiment 1: Add Comments**\n\n```rust\nfn main() {\n    // This program calculates the area of a rectangle\n\n    let width = 10;   // Width in meters\n    let height = 5;   // Height in meters\n\n    // Calculate area (width * height)\n    let area = width * height;\n\n    println!(\"The area is {} square meters\", area);\n}\n```\n\n### **Experiment 2: Comment Out Code**\n\n```rust\nfn main() {\n    println!(\"Line 1\");\n    // println!(\"Line 2 is commented out\");\n    println!(\"Line 3\");\n\n    /*\n    println!(\"Line 4 is in a multi-line comment\");\n    println!(\"Line 5 too\");\n    */\n\n    println!(\"Line 6\");\n}\n```\n\nRun it and see which lines print!\n\n### **Experiment 3: Multi-Line Comments**\n\n```rust\nfn main() {\n    /*\n       This is a calculator program.\n       It performs basic arithmetic operations.\n       Created for learning purposes.\n    */\n\n    let x = 10;\n    let y = 3;\n\n    println!(\"Sum: {}\", x + y);\n    println!(\"Difference: {}\", x - y);\n}\n```\n\n### **Challenge: Document Your Code**\n\nTake the temperature converter from Lesson 4 and add helpful comments:\n\n```rust\nfn main() {\n    // TODO: Add comments explaining what this program does\n\n    let celsius = 25.0;\n    let fahrenheit = celsius * 1.8 + 32.0;\n\n    println!(\"{}Â°C is {}Â°F\", celsius, fahrenheit);\n}\n```\n\nAdd comments that explain:\n1. What the program does\n2. What the conversion formula means\n3. What the variables represent\n\n## Key Takeaways\n\n- âœ… Comments are notes for humans, ignored by the compiler\n- âœ… `//` creates a single-line comment\n- âœ… `/* */` creates a multi-line comment\n- âœ… Use comments to explain WHY, not WHAT\n- âœ… Comments can temporarily disable code\n- âœ… Good comments make code easier to understand\n- âœ… Don't over-comment obvious things\n\n---\n\n## âœ… Module 1 Complete!\n\nYou've learned the fundamentals of Rust:\n- âœ… The `main()` function (entry point)\n- âœ… Running code with `cargo run`\n- âœ… Variables (`let`, `mut`)\n- âœ… Basic data types (i32, f64, bool, char, &str)\n- âœ… Functions (defining and calling)\n- âœ… Comments (documenting your code)\n\n**You're ready to start making decisions and controlling program flow!**\n"
          }
        }
      ]
    },
    {
      "id": "module-02",
      "title": "MODULE 02",
      "description": "Module 2",
      "difficulty": "beginner",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-02-01",
          "title": "Module 2, Lesson 1: Making Choices â€” The `if/else` Decision Maker",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 2, Lesson 1: Making Choices â€” The `if/else` Decision Maker\n\n## The Concept: Choosing Different Paths\n\nImagine you're leaving your house. You look outside and think:\n- \"IF it's raining, I'll bring an umbrella\"\n- \"OTHERWISE (ELSE), I'll leave the umbrella at home\"\n\nYou're making a decision based on a condition. Programs need to make decisions too!\n\n**In programming**: \"IF this condition is true, do this. ELSE, do that.\"\n\n## The `if` Statement\n\n**Basic syntax:**\n\n```rust\nif condition {\n    // Code runs if condition is true\n}\n```\n\n**Example:**\n\n```rust\nfn main() {\n    let temperature = 30;\n\n    if temperature > 25 {\n        println!(\"It's hot outside!\");\n    }\n}\n```\n\nIf `temperature` is greater than 25, it prints the message. Otherwise, nothing happens.\n\n## The `if/else` Statement\n\nTo do something when the condition is FALSE:\n\n```rust\nif condition {\n    // Code runs if true\n} else {\n    // Code runs if false\n}\n```\n\n**Example:**\n\n```rust\nfn main() {\n    let temperature = 20;\n\n    if temperature > 25 {\n        println!(\"It's hot outside!\");\n    } else {\n        println!(\"It's nice outside!\");\n    }\n}\n```\n\n## The `else if` Chain\n\nFor multiple conditions:\n\n```rust\nif condition1 {\n    // Runs if condition1 is true\n} else if condition2 {\n    // Runs if condition2 is true\n} else {\n    // Runs if all conditions are false\n}\n```\n\n**Example:**\n\n```rust\nfn main() {\n    let temperature = 15;\n\n    if temperature > 30 {\n        println!(\"It's very hot!\");\n    } else if temperature > 20 {\n        println!(\"It's warm!\");\n    } else if temperature > 10 {\n        println!(\"It's cool!\");\n    } else {\n        println!(\"It's cold!\");\n    }\n}\n```\n\n## Comparison Operators\n\nThese create boolean (true/false) conditions:\n\n| Operator | Meaning | Example |\n|----------|---------|---------|\n| `==` | Equal to | `x == 5` |\n| `!=` | Not equal to | `x != 5` |\n| `>` | Greater than | `x > 5` |\n| `<` | Less than | `x < 5` |\n| `>=` | Greater than or equal | `x >= 5` |\n| `<=` | Less than or equal | `x <= 5` |\n\n**Example:**\n\n```rust\nfn main() {\n    let age = 18;\n\n    if age >= 18 {\n        println!(\"You can vote!\");\n    } else {\n        println!(\"You're too young to vote.\");\n    }\n}\n```\n\n## Logical Operators\n\nCombine multiple conditions:\n\n- `&&` â€” AND (both must be true)\n- `||` â€” OR (at least one must be true)\n- `!` â€” NOT (inverts true/false)\n\n**Examples:**\n\n```rust\nfn main() {\n    let age = 20;\n    let has_license = true;\n\n    // AND: Both conditions must be true\n    if age >= 18 && has_license {\n        println!(\"You can drive!\");\n    }\n\n    // OR: At least one must be true\n    if age < 18 || !has_license {\n        println!(\"You cannot drive.\");\n    }\n}\n```\n\n## `if` as an Expression\n\nIn Rust, `if` can return a value:\n\n```rust\nfn main() {\n    let temperature = 30;\n\n    let weather = if temperature > 25 {\n        \"hot\"\n    } else {\n        \"cool\"\n    };\n\n    println!(\"The weather is {}\", weather);\n}\n```\n\nBoth branches must return the same type!\n\n## Hands-On Practice\n\n### **Create a Practice Project**\n\n```bash\ncargo new if_else_practice\ncd if_else_practice\ncode .\n```\n\n### **Experiment 1: Basic if/else**\n\n```rust\nfn main() {\n    let number = 10;\n\n    if number > 0 {\n        println!(\"The number is positive\");\n    } else {\n        println!(\"The number is zero or negative\");\n    }\n}\n```\n\n### **Experiment 2: else if Chain**\n\n```rust\nfn main() {\n    let score = 85;\n\n    if score >= 90 {\n        println!(\"Grade: A\");\n    } else if score >= 80 {\n        println!(\"Grade: B\");\n    } else if score >= 70 {\n        println!(\"Grade: C\");\n    } else if score >= 60 {\n        println!(\"Grade: D\");\n    } else {\n        println!(\"Grade: F\");\n    }\n}\n```\n\n### **Experiment 3: Logical Operators**\n\n```rust\nfn main() {\n    let age = 25;\n    let has_ticket = true;\n\n    if age >= 18 && has_ticket {\n        println!(\"You can enter the concert!\");\n    } else {\n        println!(\"Sorry, you cannot enter.\");\n    }\n}\n```\n\n### **Challenge: Number Classifier**\n\nWrite a program that:\n1. Takes a number\n2. Prints whether it's:\n   - Positive, negative, or zero\n   - Even or odd (hint: use `number % 2 == 0` for even)\n\n```rust\nfn main() {\n    let number = 7;\n\n    // Check positive/negative/zero\n    if number > 0 {\n        println!(\"Positive\");\n    } else if number < 0 {\n        println!(\"Negative\");\n    } else {\n        println!(\"Zero\");\n    }\n\n    // Check even/odd\n    if number % 2 == 0 {\n        println!(\"Even\");\n    } else {\n        println!(\"Odd\");\n    }\n}\n```\n\n## Key Takeaways\n\n- âœ… `if` makes decisions based on conditions\n- âœ… `if/else` provides an alternative path\n- âœ… `else if` chains multiple conditions\n- âœ… Comparison operators: `==`, `!=`, `>`, `<`, `>=`, `<=`\n- âœ… Logical operators: `&&` (AND), `||` (OR), `!` (NOT)\n- âœ… `if` can return a value in Rust\n- âœ… Conditions must be boolean (`true` or `false`)\n"
          }
        },
        {
          "id": "lesson-02-02",
          "title": "Module 2, Lesson 2: Repeating Forever â€” The `loop`",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 2, Lesson 2: Repeating Forever â€” The `loop`\n\n## The Concept: Doing Something Repeatedly\n\nImagine you're stirring soup. The recipe says: \"Keep stirring until the soup starts boiling, then stop.\"\n\nYou're repeating an action (stirring) until a specific condition is met (boiling).\n\nPrograms often need to repeat actions. Rust has several ways to create loops. The simplest is `loop`â€”it repeats forever until you explicitly tell it to stop.\n\n## The `loop` Keyword\n\n**Basic syntax:**\n\n```rust\nloop {\n    // This code repeats forever\n    // ...until you 'break' out of it\n}\n```\n\n**Example (infinite loop - DON'T RUN THIS!):**\n\n```rust\nfn main() {\n    loop {\n        println!(\"This prints forever!\");\n    }\n}\n```\n\nThis will print foreverâ€”you'd have to force-quit the program!\n\n## Breaking Out of a Loop\n\nUse `break` to exit a loop:\n\n```rust\nfn main() {\n    let mut count = 0;\n\n    loop {\n        count = count + 1;\n        println!(\"Count: {}\", count);\n\n        if count == 5 {\n            break;  // Exit the loop\n        }\n    }\n\n    println!(\"Loop finished!\");\n}\n```\n\nOutput:\n```\nCount: 1\nCount: 2\nCount: 3\nCount: 4\nCount: 5\nLoop finished!\n```\n\n## Skipping with `continue`\n\nUse `continue` to skip the rest of the current iteration:\n\n```rust\nfn main() {\n    let mut count = 0;\n\n    loop {\n        count = count + 1;\n\n        if count % 2 == 0 {\n            continue;  // Skip even numbers\n        }\n\n        println!(\"{}\", count);\n\n        if count >= 9 {\n            break;\n        }\n    }\n}\n```\n\nOutput:\n```\n1\n3\n5\n7\n9\n```\n\n(Only odd numbers print)\n\n## Returning Values from Loops\n\nLoops can return values with `break`:\n\n```rust\nfn main() {\n    let mut counter = 0;\n\n    let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2;  // Return a value when breaking\n        }\n    };\n\n    println!(\"Result: {}\", result);\n}\n```\n\nOutput:\n```\nResult: 20\n```\n\n## Nested Loops\n\nLoops inside loops:\n\n```rust\nfn main() {\n    let mut outer = 0;\n\n    loop {\n        outer += 1;\n        let mut inner = 0;\n\n        loop {\n            inner += 1;\n            println!(\"outer: {}, inner: {}\", outer, inner);\n\n            if inner >= 3 {\n                break;\n            }\n        }\n\n        if outer >= 2 {\n            break;\n        }\n    }\n}\n```\n\n## Hands-On Practice\n\n### **Create a Practice Project**\n\n```bash\ncargo new loop_practice\ncd loop_practice\ncode .\n```\n\n### **Experiment 1: Countdown**\n\n```rust\nfn main() {\n    let mut count = 5;\n\n    loop {\n        println!(\"{}\", count);\n        count -= 1;\n\n        if count == 0 {\n            println!(\"Liftoff!\");\n            break;\n        }\n    }\n}\n```\n\n### **Experiment 2: Find First Multiple of 13**\n\n```rust\nfn main() {\n    let mut num = 1;\n\n    loop {\n        if num % 13 == 0 {\n            println!(\"First multiple of 13: {}\", num);\n            break;\n        }\n        num += 1;\n    }\n}\n```\n\n### **Experiment 3: Loop with continue**\n\n```rust\nfn main() {\n    let mut count = 0;\n\n    loop {\n        count += 1;\n\n        if count % 3 == 0 {\n            continue;  // Skip multiples of 3\n        }\n\n        println!(\"{}\", count);\n\n        if count >= 10 {\n            break;\n        }\n    }\n}\n```\n\n### **Challenge: Sum Until Limit**\n\nWrite a program that:\n1. Starts with `sum = 0` and `num = 1`\n2. Keeps adding `num` to `sum`\n3. Increments `num` each time\n4. Stops when `sum` exceeds 100\n5. Prints the final sum\n\n```rust\nfn main() {\n    let mut sum = 0;\n    let mut num = 1;\n\n    loop {\n        sum += num;\n\n        if sum > 100 {\n            break;\n        }\n\n        num += 1;\n    }\n\n    println!(\"Final sum: {}\", sum);\n}\n```\n\n## When to Use `loop`\n\nUse `loop` when:\n- You don't know how many iterations you need\n- You want an infinite loop with `break` conditions\n- The exit condition is complex\n\nFor counting a specific number of times, `for` loops (Lesson 4) are better!\n\n## Key Takeaways\n\n- âœ… `loop` creates an infinite loop\n- âœ… `break` exits the loop\n- âœ… `continue` skips to the next iteration\n- âœ… Loops can return values with `break value`\n- âœ… Always ensure your loop has a `break` condition!\n- âœ… Use `loop` when iterations are unknown\n"
          }
        },
        {
          "id": "lesson-02-03",
          "title": "Module 2, Lesson 3: Repeating While True â€” The `while` Loop",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 2, Lesson 3: Repeating While True â€” The `while` Loop\n\n## The Concept: Loop with a Built-In Condition\n\nImagine washing dishes. You think: \"WHILE there are dirty dishes, keep washing.\"\n\nYou're repeating an action (washing) as long as a condition is true (dishes remain).\n\nThe `while` loop is like `loop`, but with a built-in condition check. It's cleaner than using `loop` with `if` and `break`.\n\n## The `while` Loop\n\n**Syntax:**\n\n```rust\nwhile condition {\n    // Code runs while condition is true\n}\n```\n\n**Example:**\n\n```rust\nfn main() {\n    let mut count = 1;\n\n    while count <= 5 {\n        println!(\"Count: {}\", count);\n        count += 1;\n    }\n\n    println!(\"Done!\");\n}\n```\n\nOutput:\n```\nCount: 1\nCount: 2\nCount: 3\nCount: 4\nCount: 5\nDone!\n```\n\nThe loop continues WHILE `count <= 5` is true.\n\n## Comparing `loop` vs. `while`\n\n**Using `loop`:**\n\n```rust\nfn main() {\n    let mut count = 1;\n\n    loop {\n        if count > 5 {\n            break;\n        }\n\n        println!(\"Count: {}\", count);\n        count += 1;\n    }\n}\n```\n\n**Using `while` (cleaner):**\n\n```rust\nfn main() {\n    let mut count = 1;\n\n    while count <= 5 {\n        println!(\"Count: {}\", count);\n        count += 1;\n    }\n}\n```\n\nSame result, but `while` is more readable!\n\n## Common `while` Loop Patterns\n\n**Countdown:**\n\n```rust\nfn main() {\n    let mut countdown = 10;\n\n    while countdown > 0 {\n        println!(\"{}...\", countdown);\n        countdown -= 1;\n    }\n\n    println!(\"Liftoff!\");\n}\n```\n\n**Waiting for a condition:**\n\n```rust\nfn main() {\n    let mut temperature = 20;\n\n    while temperature < 100 {\n        println!(\"Temperature: {}Â°C (heating...)\", temperature);\n        temperature += 10;  // Simulate heating\n    }\n\n    println!(\"Water is boiling!\");\n}\n```\n\n**Processing until empty:**\n\n```rust\nfn main() {\n    let mut remaining_tasks = 5;\n\n    while remaining_tasks > 0 {\n        println!(\"Completing task... {} left\", remaining_tasks);\n        remaining_tasks -= 1;\n    }\n\n    println!(\"All tasks done!\");\n}\n```\n\n## Using `break` and `continue` in `while`\n\nYou can still use `break` and `continue`:\n\n```rust\nfn main() {\n    let mut num = 0;\n\n    while num < 10 {\n        num += 1;\n\n        if num % 2 == 0 {\n            continue;  // Skip even numbers\n        }\n\n        if num == 7 {\n            break;  // Exit early\n        }\n\n        println!(\"{}\", num);\n    }\n}\n```\n\nOutput:\n```\n1\n3\n5\n```\n\n## Infinite `while` Loop (Avoid!)\n\nThis creates an infinite loop (like `loop`):\n\n```rust\nwhile true {\n    println!(\"Forever!\");\n}\n```\n\n**Better to use `loop`** if you want an infinite loop:\n\n```rust\nloop {\n    println!(\"Forever!\");\n}\n```\n\n## Hands-On Practice\n\n### **Create a Practice Project**\n\n```bash\ncargo new while_practice\ncd while_practice\ncode .\n```\n\n### **Experiment 1: Basic while Loop**\n\n```rust\nfn main() {\n    let mut count = 1;\n\n    while count <= 10 {\n        println!(\"{}\", count);\n        count += 1;\n    }\n}\n```\n\n### **Experiment 2: Countdown Timer**\n\n```rust\nfn main() {\n    let mut seconds = 5;\n\n    while seconds > 0 {\n        println!(\"{}...\", seconds);\n        seconds -= 1;\n    }\n\n    println!(\"Time's up!\");\n}\n```\n\n### **Experiment 3: Sum Until Limit**\n\n```rust\nfn main() {\n    let mut sum = 0;\n    let mut num = 1;\n\n    while sum < 100 {\n        sum += num;\n        num += 1;\n    }\n\n    println!(\"Final sum: {}\", sum);\n    println!(\"Took {} numbers\", num - 1);\n}\n```\n\n### **Challenge: Guessing Game (Simplified)**\n\nCreate a simple number-guessing simulation:\n\n```rust\nfn main() {\n    let secret_number = 7;\n    let mut guess = 1;\n\n    while guess != secret_number {\n        println!(\"Guessing {}... wrong!\", guess);\n        guess += 1;\n    }\n\n    println!(\"Found it! The number was {}\", secret_number);\n}\n```\n\n**Extension**: Try skipping certain numbers with `continue`:\n\n```rust\nfn main() {\n    let secret_number = 7;\n    let mut guess = 0;\n\n    while guess != secret_number {\n        guess += 1;\n\n        if guess % 2 == 0 {\n            continue;  // Skip even guesses\n        }\n\n        println!(\"Trying {}...\", guess);\n    }\n\n    println!(\"Success!\");\n}\n```\n\n## When to Use `while`\n\nUse `while` when:\n- You know the condition but not the exact number of iterations\n- The condition is simple and readable\n- You want cleaner code than `loop` with `break`\n\nUse `for` (next lesson) when you know exactly how many times to iterate!\n\n## Key Takeaways\n\n- âœ… `while condition { }` loops while condition is true\n- âœ… Cleaner than `loop` with `if/break` for simple conditions\n- âœ… Common pattern: `while count < limit`\n- âœ… Can use `break` and `continue`\n- âœ… Condition is checked BEFORE each iteration\n- âœ… If condition is initially false, loop never runs\n"
          }
        },
        {
          "id": "lesson-02-04",
          "title": "Module 2, Lesson 4: Counting Through a List â€” The `for` Loop",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 2, Lesson 4: Counting Through a List â€” The `for` Loop\n\n## The Concept: Iterating Over a Collection\n\nImagine you have 5 boxes numbered 1 through 5, and you need to check each one:\n- \"FOR each box, open it and check inside\"\n\nYou're going through a known collection of items, one by one.\n\nThe `for` loop is perfect when you know exactly what you're iterating over: a range of numbers, a list, or any collection.\n\n## The `for` Loop\n\n**Syntax:**\n\n```rust\nfor variable in collection {\n    // Code runs for each item in collection\n}\n```\n\n**Example with a range:**\n\n```rust\nfn main() {\n    for number in 1..6 {  // 1, 2, 3, 4, 5 (excludes 6)\n        println!(\"Number: {}\", number);\n    }\n}\n```\n\nOutput:\n```\nNumber: 1\nNumber: 2\nNumber: 3\nNumber: 4\nNumber: 5\n```\n\n## Ranges\n\nRust has two types of ranges:\n\n**Exclusive range (doesn't include the end):**\n\n```rust\nfor i in 1..5 {  // 1, 2, 3, 4\n    println!(\"{}\", i);\n}\n```\n\n**Inclusive range (includes the end):**\n\n```rust\nfor i in 1..=5 {  // 1, 2, 3, 4, 5\n    println!(\"{}\", i);\n}\n```\n\n## Comparing Loop Types\n\n**Using `while` (manual counting):**\n\n```rust\nfn main() {\n    let mut i = 1;\n\n    while i <= 5 {\n        println!(\"{}\", i);\n        i += 1;\n    }\n}\n```\n\n**Using `for` (cleaner and safer):**\n\n```rust\nfn main() {\n    for i in 1..=5 {\n        println!(\"{}\", i);\n    }\n}\n```\n\nThe `for` loop is more concise and prevents forgetting to increment the counter!\n\n## Common Patterns\n\n**Countdown:**\n\n```rust\nfn main() {\n    for num in (1..=10).rev() {  // .rev() reverses the range\n        println!(\"{}...\", num);\n    }\n    println!(\"Liftoff!\");\n}\n```\n\n**Iterating with steps:**\n\n```rust\nfn main() {\n    for num in (0..=20).step_by(2) {  // Every 2nd number\n        println!(\"{}\", num);\n    }\n}\n```\n\nOutput: `0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20`\n\n**Iterating over an array:**\n\n```rust\nfn main() {\n    let fruits = [\"apple\", \"banana\", \"cherry\"];\n\n    for fruit in fruits {\n        println!(\"I like {}s!\", fruit);\n    }\n}\n```\n\nOutput:\n```\nI like apples!\nI like bananas!\nI like cherrys!\n```\n\n## Using `break` and `continue`\n\nWorks the same as in other loops:\n\n```rust\nfn main() {\n    for num in 1..=10 {\n        if num == 5 {\n            continue;  // Skip 5\n        }\n\n        if num == 8 {\n            break;  // Stop at 8\n        }\n\n        println!(\"{}\", num);\n    }\n}\n```\n\nOutput:\n```\n1\n2\n3\n4\n6\n7\n```\n\n## Nested `for` Loops\n\nCreate multiplication tables:\n\n```rust\nfn main() {\n    for i in 1..=3 {\n        for j in 1..=3 {\n            println!(\"{} x {} = {}\", i, j, i * j);\n        }\n        println!(\"---\");\n    }\n}\n```\n\n## Hands-On Practice\n\n### **Create a Practice Project**\n\n```bash\ncargo new for_practice\ncd for_practice\ncode .\n```\n\n### **Experiment 1: Basic Range**\n\n```rust\nfn main() {\n    println!(\"Counting to 10:\");\n\n    for i in 1..=10 {\n        println!(\"{}\", i);\n    }\n}\n```\n\n### **Experiment 2: Countdown**\n\n```rust\nfn main() {\n    println!(\"Countdown:\");\n\n    for num in (1..=5).rev() {\n        println!(\"{}...\", num);\n    }\n\n    println!(\"Blastoff!\");\n}\n```\n\n### **Experiment 3: Even Numbers**\n\n```rust\nfn main() {\n    println!(\"Even numbers from 0 to 20:\");\n\n    for num in (0..=20).step_by(2) {\n        println!(\"{}\", num);\n    }\n}\n```\n\n### **Experiment 4: Multiplication Table**\n\n```rust\nfn main() {\n    let number = 7;\n\n    println!(\"Multiplication table for {}:\", number);\n\n    for i in 1..=10 {\n        println!(\"{} x {} = {}\", number, i, number * i);\n    }\n}\n```\n\n### **Challenge: FizzBuzz**\n\nClassic programming challenge:\n- Print numbers 1 to 30\n- If divisible by 3: print \"Fizz\"\n- If divisible by 5: print \"Buzz\"\n- If divisible by both: print \"FizzBuzz\"\n- Otherwise: print the number\n\n```rust\nfn main() {\n    for num in 1..=30 {\n        if num % 3 == 0 && num % 5 == 0 {\n            println!(\"FizzBuzz\");\n        } else if num % 3 == 0 {\n            println!(\"Fizz\");\n        } else if num % 5 == 0 {\n            println!(\"Buzz\");\n        } else {\n            println!(\"{}\", num);\n        }\n    }\n}\n```\n\n## When to Use `for`\n\nUse `for` when:\n- You know the collection or range you're iterating over\n- You want to go through each item once\n- You want clean, safe iteration\n\nUse `while` when the exit condition is more complex!\n\n## Key Takeaways\n\n- âœ… `for variable in collection { }` iterates over items\n- âœ… `1..5` is an exclusive range (1, 2, 3, 4)\n- âœ… `1..=5` is an inclusive range (1, 2, 3, 4, 5)\n- âœ… `.rev()` reverses a range\n- âœ… `.step_by(n)` skips n items\n- âœ… `for` is safer and cleaner than manual `while` counting\n- âœ… Can use `break` and `continue`\n- âœ… Great for arrays, ranges, and collections\n"
          }
        },
        {
          "id": "lesson-02-05",
          "title": "Module 2, Lesson 5: Practice Project â€” Building a Simple Calculator",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 2, Lesson 5: Practice Project â€” Building a Simple Calculator\n\n## Project Overview\n\nNow that you've learned `if/else`, `loop`, `while`, and `for`, let's combine everything into a real project: a simple command-line calculator!\n\n**What we're building:**\n- A program that performs basic math operations\n- User chooses the operation (add, subtract, multiply, divide)\n- Calculator runs in a loop until the user quits\n- Handles division by zero errors\n\n**Skills practiced:**\n- âœ… if/else for decision-making\n- âœ… loop for the main program loop\n- âœ… Functions to organize code\n- âœ… Variables and basic types\n- âœ… User input (bonus: we'll learn this now!)\n\n## Getting User Input\n\nBefore building the calculator, let's learn how to get input from the user:\n\n```rust\nuse std::io;  // Import input/output library\n\nfn main() {\n    println!(\"Enter your name:\");\n\n    let mut input = String::new();  // Create an empty string\n\n    io::stdin()\n        .read_line(&mut input)  // Read user input\n        .expect(\"Failed to read line\");  // Handle errors\n\n    println!(\"Hello, {}!\", input.trim());  // trim() removes whitespace\n}\n```\n\n**Breaking it down:**\n- `use std::io` â€” Import Rust's input/output library\n- `String::new()` â€” Create a new, empty String\n- `io::stdin().read_line(&mut input)` â€” Read a line from the terminal\n- `.trim()` â€” Remove newline characters\n\n## Parsing Numbers from Input\n\nTo convert user input to a number:\n\n```rust\nuse std::io;\n\nfn main() {\n    println!(\"Enter a number:\");\n\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read\");\n\n    let number: i32 = input.trim().parse().expect(\"Please enter a number!\");\n\n    println!(\"You entered: {}\", number);\n}\n```\n\n## The Calculator Project\n\n### **Step 1: Create the Project**\n\n```bash\ncargo new calculator\ncd calculator\ncode .\n```\n\n### **Step 2: Build the Calculator (Complete Code)**\n\nReplace `src/main.rs` with:\n\n```rust\nuse std::io;\n\nfn main() {\n    println!(\"=== Simple Calculator ===\");\n    println!(\"Type 'quit' to exit\\n\");\n\n    loop {\n        // Get first number\n        println!(\"Enter first number:\");\n        let num1 = get_number();\n\n        // Get operation\n        println!(\"Enter operation (+, -, *, /):\");\n        let operation = get_input();\n\n        // Check if user wants to quit\n        if operation.trim() == \"quit\" {\n            println!(\"Goodbye!\");\n            break;\n        }\n\n        // Get second number\n        println!(\"Enter second number:\");\n        let num2 = get_number();\n\n        // Perform calculation\n        let result = calculate(num1, num2, operation.trim());\n\n        // Display result\n        match result {\n            Some(value) => println!(\"\\nResult: {}\\n\", value),\n            None => println!(\"\\nError: Invalid operation or division by zero\\n\"),\n        }\n    }\n}\n\n// Function to get user input as a string\nfn get_input() -> String {\n    let mut input = String::new();\n    io::stdin()\n        .read_line(&mut input)\n        .expect(\"Failed to read input\");\n    input\n}\n\n// Function to get a number from the user\nfn get_number() -> f64 {\n    loop {\n        let input = get_input();\n\n        match input.trim().parse() {\n            Ok(num) => return num,\n            Err(_) => println!(\"Invalid number, try again:\"),\n        }\n    }\n}\n\n// Function to perform the calculation\nfn calculate(num1: f64, num2: f64, operation: &str) -> Option<f64> {\n    match operation {\n        \"+\" => Some(num1 + num2),\n        \"-\" => Some(num1 - num2),\n        \"*\" => Some(num1 * num2),\n        \"/\" => {\n            if num2 == 0.0 {\n                None  // Can't divide by zero\n            } else {\n                Some(num1 / num2)\n            }\n        }\n        _ => None,  // Invalid operation\n    }\n}\n```\n\n### **Step 3: Run the Calculator**\n\n```bash\ncargo run\n```\n\n**Try it out:**\n```\n=== Simple Calculator ===\nType 'quit' to exit\n\nEnter first number:\n10\nEnter operation (+, -, *, /):\n+\nEnter second number:\n5\n\nResult: 15\n\nEnter first number:\n20\nEnter operation (+, -, *, /):\n/\nEnter second number:\n4\n\nResult: 5\n\nEnter first number:\nquit\nGoodbye!\n```\n\n## Understanding the Code\n\n**Main loop:**\n```rust\nloop {\n    // Get inputs\n    // Perform calculation\n    // Display result\n    // Repeat until user quits\n}\n```\n\n**Getting input:**\n```rust\nfn get_number() -> f64 {\n    loop {\n        // Try to parse input\n        // If successful, return the number\n        // If failed, ask again\n    }\n}\n```\n\n**Calculation logic:**\n```rust\nmatch operation {\n    \"+\" => Some(num1 + num2),\n    // ... other operations\n    _ => None,  // Catch-all for invalid operations\n}\n```\n\nWe use `Option` (Some/None) to handle errors like division by zero (we'll learn more about `Option` in Module 3!).\n\n## Challenges and Extensions\n\n### **Challenge 1: Add More Operations**\n\nAdd these operations:\n- `%` â€” Modulo (remainder)\n- `^` â€” Power (hint: use `num1.powf(num2)`)\n\n### **Challenge 2: Keep Running Total**\n\nModify the calculator to keep a running total:\n```\nResult: 10\nDo you want to continue with 10? (yes/no):\nyes\nEnter operation:\n+\nEnter number:\n5\nResult: 15\n```\n\n### **Challenge 3: Better Error Messages**\n\nAdd specific error messages:\n- \"Cannot divide by zero!\"\n- \"Unknown operation!\"\n- \"Invalid number format!\"\n\n## Simplified Version\n\nIf the full version is too complex, try this simpler version first:\n\n```rust\nfn main() {\n    println!(\"Enter first number:\");\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let num1: f64 = input.trim().parse().unwrap();\n\n    println!(\"Enter second number:\");\n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let num2: f64 = input.trim().parse().unwrap();\n\n    println!(\"\\n{} + {} = {}\", num1, num2, num1 + num2);\n    println!(\"{} - {} = {}\", num1, num2, num1 - num2);\n    println!(\"{} * {} = {}\", num1, num2, num1 * num2);\n    println!(\"{} / {} = {}\", num1, num2, num1 / num2);\n}\n```\n\n## Key Takeaways\n\n- âœ… Combined `loop`, `if/else`, and functions\n- âœ… Learned basic user input with `std::io`\n- âœ… Converted strings to numbers with `.parse()`\n- âœ… Handled errors (division by zero, invalid input)\n- âœ… Created a real, usable program!\n- âœ… Organized code with multiple functions\n\n---\n\n## âœ… Module 2 Complete!\n\nYou've mastered program flow:\n- âœ… if/else (making decisions)\n- âœ… loop (infinite loops with break)\n- âœ… while (conditional loops)\n- âœ… for (iterating over collections)\n- âœ… Built a complete calculator project!\n\n**Next: Module 3 â€” Organizing your data with structs and enums!**\n"
          }
        }
      ]
    },
    {
      "id": "module-03",
      "title": "MODULE 03",
      "description": "Module 3",
      "difficulty": "beginner",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-03-01",
          "title": "Module 3, Lesson 1: Grouping Related Information â€” Introduction to Structs",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 3, Lesson 1: Grouping Related Information â€” Introduction to Structs\n\n## The Concept: Bundling Data Together\n\nImagine you're creating a contact list. For each person, you need to store:\n- Name\n- Age\n- Email\n- Phone number\n\nYou could create separate variables:\n\n```rust\nlet person1_name = \"Alice\";\nlet person1_age = 30;\nlet person1_email = \"alice@example.com\";\nlet person1_phone = \"555-1234\";\n```\n\nBut this gets messy fast! What if you have 100 people? You need a way to group related information together.\n\nThink of a **struct** as a custom container that holds multiple related pieces of data, like a form with labeled fields.\n\n## What is a Struct?\n\nA **struct** (short for \"structure\") is a custom data type that lets you package related values together.\n\n**Syntax:**\n\n```rust\nstruct StructName {\n    field1: Type1,\n    field2: Type2,\n    field3: Type3,\n}\n```\n\n**Example:**\n\n```rust\nstruct Person {\n    name: String,\n    age: i32,\n    email: String,\n}\n```\n\nThis defines a new type called `Person` with three fields.\n\n## Creating Struct Instances\n\nTo create an actual `Person`:\n\n```rust\nfn main() {\n    let alice = Person {\n        name: String::from(\"Alice\"),\n        age: 30,\n        email: String::from(\"alice@example.com\"),\n    };\n\n    println!(\"Name: {}\", alice.name);\n    println!(\"Age: {}\", alice.age);\n    println!(\"Email: {}\", alice.email);\n}\n\nstruct Person {\n    name: String,\n    age: i32,\n    email: String,\n}\n```\n\n**Accessing fields:** Use dot notation: `alice.name`\n\n## Mutable Structs\n\nTo modify fields, make the entire struct mutable:\n\n```rust\nfn main() {\n    let mut alice = Person {\n        name: String::from(\"Alice\"),\n        age: 30,\n        email: String::from(\"alice@example.com\"),\n    };\n\n    println!(\"Age: {}\", alice.age);\n\n    alice.age = 31;  // Birthday!\n\n    println!(\"New age: {}\", alice.age);\n}\n\nstruct Person {\n    name: String,\n    age: i32,\n    email: String,\n}\n```\n\n## Functions with Structs\n\nPass structs to functions:\n\n```rust\nfn main() {\n    let alice = Person {\n        name: String::from(\"Alice\"),\n        age: 30,\n        email: String::from(\"alice@example.com\"),\n    };\n\n    print_person(&alice);  // Borrow the struct\n}\n\nfn print_person(person: &Person) {\n    println!(\"Name: {}\", person.name);\n    println!(\"Age: {}\", person.age);\n    println!(\"Email: {}\", person.email);\n}\n\nstruct Person {\n    name: String,\n    age: i32,\n    email: String,\n}\n```\n\n## Methods on Structs\n\nYou can define functions that belong to a struct using `impl`:\n\n```rust\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    // Method that calculates area\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n\n    // Method to check if it's square\n    fn is_square(&self) -> bool {\n        self.width == self.height\n    }\n}\n\nfn main() {\n    let rect = Rectangle {\n        width: 10,\n        height: 20,\n    };\n\n    println!(\"Area: {}\", rect.area());\n    println!(\"Is square: {}\", rect.is_square());\n}\n```\n\n**Key points:**\n- `impl Rectangle` â€” \"implement methods for Rectangle\"\n- `&self` â€” Reference to the struct instance\n- Call methods with dot notation: `rect.area()`\n\n## Constructor Functions\n\nCreate helper functions to build structs:\n\n```rust\nimpl Person {\n    fn new(name: String, age: i32, email: String) -> Person {\n        Person { name, age, email }\n    }\n}\n\nfn main() {\n    let alice = Person::new(\n        String::from(\"Alice\"),\n        30,\n        String::from(\"alice@example.com\"),\n    );\n\n    println!(\"{}\", alice.name);\n}\n\nstruct Person {\n    name: String,\n    age: i32,\n    email: String,\n}\n```\n\n## Hands-On Practice\n\n### **Create a Practice Project**\n\n```bash\ncargo new structs_practice\ncd structs_practice\ncode .\n```\n\n### **Experiment 1: Basic Struct**\n\n```rust\nstruct Book {\n    title: String,\n    author: String,\n    pages: u32,\n}\n\nfn main() {\n    let my_book = Book {\n        title: String::from(\"The Rust Book\"),\n        author: String::from(\"Steve Klabnik\"),\n        pages: 500,\n    };\n\n    println!(\"Title: {}\", my_book.title);\n    println!(\"Author: {}\", my_book.author);\n    println!(\"Pages: {}\", my_book.pages);\n}\n```\n\n### **Experiment 2: Methods**\n\n```rust\nstruct Circle {\n    radius: f64,\n}\n\nimpl Circle {\n    fn area(&self) -> f64 {\n        3.14159 * self.radius * self.radius\n    }\n\n    fn circumference(&self) -> f64 {\n        2.0 * 3.14159 * self.radius\n    }\n}\n\nfn main() {\n    let circle = Circle { radius: 5.0 };\n\n    println!(\"Radius: {}\", circle.radius);\n    println!(\"Area: {:.2}\", circle.area());\n    println!(\"Circumference: {:.2}\", circle.circumference());\n}\n```\n\n### **Challenge: Create a Student Struct**\n\nCreate a `Student` struct with:\n- `name` (String)\n- `student_id` (u32)\n- `gpa` (f64)\n\nAdd methods:\n- `new()` â€” Constructor\n- `is_honor_roll()` â€” Returns true if GPA >= 3.5\n- `print_info()` â€” Prints all student information\n\n```rust\nstruct Student {\n    name: String,\n    student_id: u32,\n    gpa: f64,\n}\n\nimpl Student {\n    fn new(name: String, student_id: u32, gpa: f64) -> Student {\n        Student { name, student_id, gpa }\n    }\n\n    fn is_honor_roll(&self) -> bool {\n        self.gpa >= 3.5\n    }\n\n    fn print_info(&self) {\n        println!(\"Name: {}\", self.name);\n        println!(\"ID: {}\", self.student_id);\n        println!(\"GPA: {:.2}\", self.gpa);\n        println!(\"Honor Roll: {}\", self.is_honor_roll());\n    }\n}\n\nfn main() {\n    let student = Student::new(\n        String::from(\"Bob\"),\n        12345,\n        3.8,\n    );\n\n    student.print_info();\n}\n```\n\n## Key Takeaways\n\n- âœ… Structs group related data together\n- âœ… `struct Name { field: Type }` defines a struct\n- âœ… Create instances with `Name { field: value }`\n- âœ… Access fields with dot notation: `instance.field`\n- âœ… Entire struct must be `mut` to modify fields\n- âœ… `impl` adds methods to structs\n- âœ… `&self` is the first parameter in methods\n- âœ… Constructor patterns: `fn new()` is common\n"
          }
        },
        {
          "id": "lesson-03-02",
          "title": "Module 3, Lesson 2: Multiple Possibilities â€” Introduction to Enums",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 3, Lesson 2: Multiple Possibilities â€” Introduction to Enums\n\n## The Concept: One of Several Options\n\nImagine a traffic light. It can only be one of three colors at any given time:\n- Red\n- Yellow\n- Green\n\nIt can't be multiple colors simultaneously, and it can't be purple or blueâ€”only these three specific options.\n\nAn **enum** (enumeration) represents data that can be one of several distinct possibilities.\n\n## What is an Enum?\n\nAn **enum** defines a type by listing its possible variants.\n\n**Syntax:**\n\n```rust\nenum EnumName {\n    Variant1,\n    Variant2,\n    Variant3,\n}\n```\n\n**Example:**\n\n```rust\nenum TrafficLight {\n    Red,\n    Yellow,\n    Green,\n}\n```\n\nNow `TrafficLight` is a type that can only be one of these three values.\n\n## Using Enums\n\nCreate enum values:\n\n```rust\nfn main() {\n    let light = TrafficLight::Red;  // :: accesses enum variants\n\n    // We'll see how to use this value next!\n}\n\nenum TrafficLight {\n    Red,\n    Yellow,\n    Green,\n}\n```\n\n## Matching on Enums\n\nUse `match` to handle each possibility:\n\n```rust\nenum TrafficLight {\n    Red,\n    Yellow,\n    Green,\n}\n\nfn main() {\n    let light = TrafficLight::Red;\n\n    match light {\n        TrafficLight::Red => println!(\"Stop!\"),\n        TrafficLight::Yellow => println!(\"Slow down!\"),\n        TrafficLight::Green => println!(\"Go!\"),\n    }\n}\n```\n\n**Important:** `match` must handle ALL possible variants. The compiler checks!\n\n## Enums with Data\n\nEnums can store additional data with each variant:\n\n```rust\nenum Message {\n    Quit,                       // No data\n    Move { x: i32, y: i32 },   // Named fields (like a struct)\n    Write(String),              // Single value\n    ChangeColor(u8, u8, u8),   // Three values (RGB)\n}\n\nfn main() {\n    let msg1 = Message::Quit;\n    let msg2 = Message::Move { x: 10, y: 20 };\n    let msg3 = Message::Write(String::from(\"Hello!\"));\n    let msg4 = Message::ChangeColor(255, 0, 0);\n\n    process_message(msg2);\n}\n\nfn process_message(msg: Message) {\n    match msg {\n        Message::Quit => println!(\"Quitting...\"),\n        Message::Move { x, y } => println!(\"Move to ({}, {})\", x, y),\n        Message::Write(text) => println!(\"Message: {}\", text),\n        Message::ChangeColor(r, g, b) => println!(\"Color: rgb({}, {}, {})\", r, g, b),\n    }\n}\n```\n\n## Common Use Cases\n\n**Representing states:**\n\n```rust\nenum ConnectionState {\n    Connected,\n    Connecting,\n    Disconnected,\n}\n\nfn main() {\n    let state = ConnectionState::Connecting;\n\n    match state {\n        ConnectionState::Connected => println!(\"You're online!\"),\n        ConnectionState::Connecting => println!(\"Connecting...\"),\n        ConnectionState::Disconnected => println!(\"Offline\"),\n    }\n}\n```\n\n**Representing different types of data:**\n\n```rust\nenum WebEvent {\n    PageLoad,\n    PageUnload,\n    KeyPress(char),\n    Click { x: i32, y: i32 },\n}\n\nfn handle_event(event: WebEvent) {\n    match event {\n        WebEvent::PageLoad => println!(\"Page loaded\"),\n        WebEvent::PageUnload => println!(\"Page unloaded\"),\n        WebEvent::KeyPress(c) => println!(\"Key pressed: {}\", c),\n        WebEvent::Click { x, y } => println!(\"Clicked at ({}, {})\", x, y),\n    }\n}\n\nfn main() {\n    handle_event(WebEvent::PageLoad);\n    handle_event(WebEvent::KeyPress('a'));\n    handle_event(WebEvent::Click { x: 100, y: 200 });\n}\n```\n\n## Methods on Enums\n\nEnums can have methods too:\n\n```rust\nenum TrafficLight {\n    Red,\n    Yellow,\n    Green,\n}\n\nimpl TrafficLight {\n    fn can_go(&self) -> bool {\n        match self {\n            TrafficLight::Green => true,\n            TrafficLight::Red | TrafficLight::Yellow => false,\n        }\n    }\n\n    fn duration_seconds(&self) -> u32 {\n        match self {\n            TrafficLight::Red => 60,\n            TrafficLight::Yellow => 5,\n            TrafficLight::Green => 55,\n        }\n    }\n}\n\nfn main() {\n    let light = TrafficLight::Green;\n\n    println!(\"Can go: {}\", light.can_go());\n    println!(\"Duration: {} seconds\", light.duration_seconds());\n}\n```\n\n## Hands-On Practice\n\n### **Create a Practice Project**\n\n```bash\ncargo new enums_practice\ncd enums_practice\ncode .\n```\n\n### **Experiment 1: Basic Enum**\n\n```rust\nenum Direction {\n    North,\n    South,\n    East,\n    West,\n}\n\nfn main() {\n    let dir = Direction::North;\n\n    match dir {\n        Direction::North => println!(\"Going north!\"),\n        Direction::South => println!(\"Going south!\"),\n        Direction::East => println!(\"Going east!\"),\n        Direction::West => println!(\"Going west!\"),\n    }\n}\n```\n\n### **Experiment 2: Enum with Data**\n\n```rust\nenum Shape {\n    Circle(f64),                    // radius\n    Rectangle(f64, f64),            // width, height\n    Triangle(f64, f64, f64),        // three sides\n}\n\nimpl Shape {\n    fn area(&self) -> f64 {\n        match self {\n            Shape::Circle(r) => 3.14159 * r * r,\n            Shape::Rectangle(w, h) => w * h,\n            Shape::Triangle(a, b, c) => {\n                // Heron's formula\n                let s = (a + b + c) / 2.0;\n                (s * (s - a) * (s - b) * (s - c)).sqrt()\n            }\n        }\n    }\n}\n\nfn main() {\n    let circle = Shape::Circle(5.0);\n    let rectangle = Shape::Rectangle(10.0, 5.0);\n    let triangle = Shape::Triangle(3.0, 4.0, 5.0);\n\n    println!(\"Circle area: {:.2}\", circle.area());\n    println!(\"Rectangle area: {:.2}\", rectangle.area());\n    println!(\"Triangle area: {:.2}\", triangle.area());\n}\n```\n\n### **Challenge: Create a Coin Enum**\n\nCreate an enum representing US coins with their cent values:\n- Penny (1)\n- Nickel (5)\n- Dime (10)\n- Quarter (25)\n\nAdd a method `value_in_cents()` that returns the value.\n\n```rust\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nimpl Coin {\n    fn value_in_cents(&self) -> u32 {\n        match self {\n            Coin::Penny => 1,\n            Coin::Nickel => 5,\n            Coin::Dime => 10,\n            Coin::Quarter => 25,\n        }\n    }\n}\n\nfn main() {\n    let coins = vec![\n        Coin::Penny,\n        Coin::Nickel,\n        Coin::Dime,\n        Coin::Quarter,\n    ];\n\n    let mut total = 0;\n    for coin in coins {\n        total += coin.value_in_cents();\n    }\n\n    println!(\"Total value: {} cents\", total);\n}\n```\n\n## Key Takeaways\n\n- âœ… Enums represent data that can be one of several variants\n- âœ… `enum Name { Variant1, Variant2 }` defines an enum\n- âœ… Access variants with `Name::Variant`\n- âœ… `match` handles all possible variants\n- âœ… Enums can hold data: `Variant(Type)` or `Variant { field: Type }`\n- âœ… Compiler ensures you handle all cases\n- âœ… Enums can have methods with `impl`\n- âœ… More type-safe than using multiple booleans or magic numbers\n"
          }
        },
        {
          "id": "lesson-03-03",
          "title": "Module 3, Lesson 3: When Something Might Not Exist â€” The `Option` Enum",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 3, Lesson 3: When Something Might Not Exist â€” The `Option` Enum\n\n## The Concept: Maybe There, Maybe Not\n\nImagine looking in your refrigerator for milk. There are two possibilities:\n- **There IS milk** â€” You have Some milk\n- **There is NO milk** â€” You have None\n\nMany programming languages represent \"no value\" with `null`, but this causes billions of dollars in bugs every year. Rust takes a different approach: if a value might not exist, you must explicitly handle both cases using the `Option` enum.\n\n## The `Option` Enum\n\n`Option` is a built-in Rust enum with two variants:\n\n```rust\nenum Option<T> {\n    Some(T),    // There IS a value of type T\n    None,       // There is NO value\n}\n```\n\n**Don't worry about `<T>` yet**â€”just know it means Option can hold any type.\n\n**Examples:**\n\n```rust\nlet some_number: Option<i32> = Some(5);\nlet no_number: Option<i32> = None;\n\nlet some_string: Option<String> = Some(String::from(\"hello\"));\nlet no_string: Option<String> = None;\n```\n\n## Why Use Option?\n\n**The problem with null in other languages:**\n\n```java\n// Java example (dangerous!)\nString name = getName();  // Might return null\nint length = name.length();  // CRASH if name is null!\n```\n\n**The Rust way (safe):**\n\n```rust\nfn get_name() -> Option<String> {\n    // Might return Some(name) or None\n}\n\nlet name_option = get_name();\n\nmatch name_option {\n    Some(name) => println!(\"Length: {}\", name.len()),\n    None => println!(\"No name provided\"),\n}\n```\n\nThe compiler **forces** you to handle the `None` case!\n\n## Using Option with match\n\n```rust\nfn find_word_at_index(index: usize) -> Option<&'static str> {\n    let words = [\"apple\", \"banana\", \"cherry\"];\n\n    if index < words.len() {\n        Some(words[index])\n    } else {\n        None\n    }\n}\n\nfn main() {\n    let result = find_word_at_index(1);\n\n    match result {\n        Some(word) => println!(\"Found: {}\", word),\n        None => println!(\"Index out of bounds\"),\n    }\n}\n```\n\nOutput: `Found: banana`\n\n## Useful Option Methods\n\n**Check if there's a value:**\n\n```rust\nlet x: Option<i32> = Some(5);\n\nif x.is_some() {\n    println!(\"Has a value!\");\n}\n\nif x.is_none() {\n    println!(\"No value!\");\n}\n```\n\n**Get the value (or panic):**\n\n```rust\nlet x: Option<i32> = Some(5);\nlet value = x.unwrap();  // Gets 5, but panics if None!\nprintln!(\"{}\", value);\n\n// Safer: provide a default\nlet y: Option<i32> = None;\nlet value = y.unwrap_or(0);  // Returns 0 if None\nprintln!(\"{}\", value);\n```\n\n**Transform the value:**\n\n```rust\nlet x: Option<i32> = Some(5);\n\nlet doubled = x.map(|n| n * 2);  // Some(10)\nprintln!(\"{:?}\", doubled);\n\nlet nothing: Option<i32> = None;\nlet doubled_nothing = nothing.map(|n| n * 2);  // Still None\nprintln!(\"{:?}\", doubled_nothing);\n```\n\n## if let Syntax\n\nFor handling only the `Some` case:\n\n```rust\nfn main() {\n    let some_number = Some(7);\n\n    // Instead of match:\n    match some_number {\n        Some(n) => println!(\"Number: {}\", n),\n        None => {},\n    }\n\n    // Use if let (cleaner):\n    if let Some(n) = some_number {\n        println!(\"Number: {}\", n);\n    }\n}\n```\n\n## Practical Examples\n\n**Finding a value in a list:**\n\n```rust\nfn find_even(numbers: Vec<i32>) -> Option<i32> {\n    for num in numbers {\n        if num % 2 == 0 {\n            return Some(num);  // Found one!\n        }\n    }\n    None  // Didn't find any\n}\n\nfn main() {\n    let nums = vec![1, 3, 5, 8, 9];\n\n    match find_even(nums) {\n        Some(n) => println!(\"First even number: {}\", n),\n        None => println!(\"No even numbers found\"),\n    }\n}\n```\n\n**User input that might be empty:**\n\n```rust\nfn get_user_age() -> Option<i32> {\n    // Simulating user input\n    let input = \"\";  // Empty input\n\n    if input.is_empty() {\n        None\n    } else {\n        Some(input.parse().unwrap_or(0))\n    }\n}\n\nfn main() {\n    match get_user_age() {\n        Some(age) => println!(\"User is {} years old\", age),\n        None => println!(\"No age provided\"),\n    }\n}\n```\n\n## Hands-On Practice\n\n### **Create a Practice Project**\n\n```bash\ncargo new option_practice\ncd option_practice\ncode .\n```\n\n### **Experiment 1: Basic Option**\n\n```rust\nfn divide(a: f64, b: f64) -> Option<f64> {\n    if b == 0.0 {\n        None  // Can't divide by zero\n    } else {\n        Some(a / b)\n    }\n}\n\nfn main() {\n    let result1 = divide(10.0, 2.0);\n    let result2 = divide(10.0, 0.0);\n\n    match result1 {\n        Some(value) => println!(\"Result: {}\", value),\n        None => println!(\"Cannot divide by zero!\"),\n    }\n\n    match result2 {\n        Some(value) => println!(\"Result: {}\", value),\n        None => println!(\"Cannot divide by zero!\"),\n    }\n}\n```\n\n### **Experiment 2: Finding Values**\n\n```rust\nfn find_first_uppercase(text: &str) -> Option<char> {\n    for c in text.chars() {\n        if c.is_uppercase() {\n            return Some(c);\n        }\n    }\n    None\n}\n\nfn main() {\n    let text1 = \"hello World\";\n    let text2 = \"no uppercase here\";\n\n    if let Some(ch) = find_first_uppercase(text1) {\n        println!(\"First uppercase: {}\", ch);\n    } else {\n        println!(\"No uppercase letters\");\n    }\n\n    if let Some(ch) = find_first_uppercase(text2) {\n        println!(\"First uppercase: {}\", ch);\n    } else {\n        println!(\"No uppercase letters\");\n    }\n}\n```\n\n### **Challenge: Safe Array Access**\n\nCreate a function that safely gets an element from an array:\n\n```rust\nfn get_element(arr: &[i32], index: usize) -> Option<i32> {\n    if index < arr.len() {\n        Some(arr[index])\n    } else {\n        None\n    }\n}\n\nfn main() {\n    let numbers = [10, 20, 30, 40, 50];\n\n    // Try different indices\n    for i in 0..7 {\n        match get_element(&numbers, i) {\n            Some(value) => println!(\"Index {}: {}\", i, value),\n            None => println!(\"Index {} is out of bounds\", i),\n        }\n    }\n}\n```\n\n## Key Takeaways\n\n- âœ… `Option<T>` represents a value that might not exist\n- âœ… `Some(value)` means there IS a value\n- âœ… `None` means there is NO value\n- âœ… Replaces null from other languages\n- âœ… Compiler forces you to handle both cases\n- âœ… Use `match`, `if let`, or methods like `.unwrap_or()`\n- âœ… Makes code safer by preventing null pointer errors\n- âœ… `.is_some()`, `.is_none()`, `.map()` are useful methods\n"
          }
        },
        {
          "id": "lesson-03-04",
          "title": "Module 3, Lesson 4: When Things Can Go Wrong â€” The `Result` Enum",
          "type": "project",
          "estimatedMinutes": 6,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 3, Lesson 4: When Things Can Go Wrong â€” The `Result` Enum\n\n## The Concept: Success or Failure\n\nImagine trying to open a file on your computer. There are two possible outcomes:\n- **Success** â€” The file exists and you can read it\n- **Failure** â€” The file doesn't exist, or you don't have permission\n\nUnlike `Option` (which represents \"something or nothing\"), `Result` represents \"success or failure\" and can tell you WHY it failed.\n\n## The `Result` Enum\n\n`Result` is a built-in enum with two variants:\n\n```rust\nenum Result<T, E> {\n    Ok(T),      // Success with a value of type T\n    Err(E),     // Error with an error value of type E\n}\n```\n\n**Examples:**\n\n```rust\nlet success: Result<i32, String> = Ok(42);\nlet failure: Result<i32, String> = Err(String::from(\"Something went wrong\"));\n```\n\n## Why Use Result?\n\n**The problem in other languages:**\n\n```python\n# Python example\ntry:\n    file = open(\"data.txt\")\nexcept:\n    # What error occurred? File not found? Permission denied?\n    pass\n```\n\n**The Rust way:**\n\n```rust\nuse std::fs::File;\n\nfn open_file() -> Result<File, std::io::Error> {\n    File::open(\"data.txt\")  // Returns Ok(file) or Err(error)\n}\n\nfn main() {\n    match open_file() {\n        Ok(file) => println!(\"File opened successfully!\"),\n        Err(error) => println!(\"Error: {}\", error),\n    }\n}\n```\n\nThe error contains specific information about what went wrong!\n\n## Using Result with match\n\n```rust\nfn divide(a: f64, b: f64) -> Result<f64, String> {\n    if b == 0.0 {\n        Err(String::from(\"Cannot divide by zero\"))\n    } else {\n        Ok(a / b)\n    }\n}\n\nfn main() {\n    let result1 = divide(10.0, 2.0);\n    let result2 = divide(10.0, 0.0);\n\n    match result1 {\n        Ok(value) => println!(\"Result: {}\", value),\n        Err(error) => println!(\"Error: {}\", error),\n    }\n\n    match result2 {\n        Ok(value) => println!(\"Result: {}\", value),\n        Err(error) => println!(\"Error: {}\", error),\n    }\n}\n```\n\nOutput:\n```\nResult: 5\nError: Cannot divide by zero\n```\n\n## Unwrapping Results\n\n**`.unwrap()` â€” Get the value or panic:**\n\n```rust\nfn main() {\n    let result = divide(10.0, 2.0);\n    let value = result.unwrap();  // Gets 5.0\n    println!(\"{}\", value);\n\n    let bad_result = divide(10.0, 0.0);\n    let value = bad_result.unwrap();  // PANICS! Program crashes\n}\n```\n\nâš ï¸ **Only use `.unwrap()` when you're CERTAIN there's no error!**\n\n**`.expect()` â€” Like unwrap but with a custom message:**\n\n```rust\nfn main() {\n    let result = divide(10.0, 0.0);\n    let value = result.expect(\"Division should never fail here\");  // Panics with custom message\n}\n```\n\n**`.unwrap_or()` â€” Provide a default value:**\n\n```rust\nfn main() {\n    let result = divide(10.0, 0.0);\n    let value = result.unwrap_or(0.0);  // Returns 0.0 if error\n    println!(\"{}\", value);\n}\n```\n\n## The `?` Operator (Propagating Errors)\n\nWhen a function returns `Result`, you can propagate errors upward with `?`:\n\n```rust\nfn parse_number(s: &str) -> Result<i32, String> {\n    match s.parse::<i32>() {\n        Ok(num) => Ok(num),\n        Err(_) => Err(String::from(\"Not a valid number\")),\n    }\n}\n\nfn add_numbers(a: &str, b: &str) -> Result<i32, String> {\n    let num1 = parse_number(a)?;  // If error, return early\n    let num2 = parse_number(b)?;  // If error, return early\n    Ok(num1 + num2)\n}\n\nfn main() {\n    match add_numbers(\"10\", \"20\") {\n        Ok(sum) => println!(\"Sum: {}\", sum),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n\n    match add_numbers(\"10\", \"abc\") {\n        Ok(sum) => println!(\"Sum: {}\", sum),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\nThe `?` operator means: \"If this is an error, return it immediately. Otherwise, unwrap the Ok value.\"\n\nWe'll explore `?` more in Module 6!\n\n## if let with Result\n\nHandle only the success case:\n\n```rust\nfn main() {\n    let result = divide(10.0, 2.0);\n\n    if let Ok(value) = result {\n        println!(\"Result: {}\", value);\n    }\n    // Errors are silently ignored\n}\n```\n\nOr only the error case:\n\n```rust\nfn main() {\n    let result = divide(10.0, 0.0);\n\n    if let Err(error) = result {\n        println!(\"Error occurred: {}\", error);\n    }\n}\n```\n\n## Practical Examples\n\n**Parsing user input:**\n\n```rust\nfn parse_age(input: &str) -> Result<u32, String> {\n    match input.trim().parse::<u32>() {\n        Ok(age) if age > 0 && age < 150 => Ok(age),\n        Ok(_) => Err(String::from(\"Age out of valid range\")),\n        Err(_) => Err(String::from(\"Not a valid number\")),\n    }\n}\n\nfn main() {\n    let inputs = [\"25\", \"200\", \"abc\", \"0\"];\n\n    for input in inputs {\n        match parse_age(input) {\n            Ok(age) => println!(\"{} is a valid age\", age),\n            Err(e) => println!(\"'{}' - Error: {}\", input, e),\n        }\n    }\n}\n```\n\n**File operations:**\n\n```rust\nuse std::fs;\n\nfn read_username_from_file() -> Result<String, String> {\n    match fs::read_to_string(\"username.txt\") {\n        Ok(contents) => Ok(contents.trim().to_string()),\n        Err(error) => Err(format!(\"Could not read file: {}\", error)),\n    }\n}\n\nfn main() {\n    match read_username_from_file() {\n        Ok(username) => println!(\"Username: {}\", username),\n        Err(error) => println!(\"Error: {}\", error),\n    }\n}\n```\n\n## Hands-On Practice\n\n### **Create a Practice Project**\n\n```bash\ncargo new result_practice\ncd result_practice\ncode .\n```\n\n### **Experiment 1: Basic Result**\n\n```rust\nfn sqrt(n: f64) -> Result<f64, String> {\n    if n < 0.0 {\n        Err(String::from(\"Cannot take square root of negative number\"))\n    } else {\n        Ok(n.sqrt())\n    }\n}\n\nfn main() {\n    let numbers = [16.0, -4.0, 9.0];\n\n    for num in numbers {\n        match sqrt(num) {\n            Ok(result) => println!(\"sqrt({}) = {}\", num, result),\n            Err(e) => println!(\"sqrt({}) - Error: {}\", num, e),\n        }\n    }\n}\n```\n\n### **Experiment 2: Parsing Input**\n\n```rust\nfn parse_and_double(s: &str) -> Result<i32, String> {\n    match s.parse::<i32>() {\n        Ok(num) => Ok(num * 2),\n        Err(_) => Err(format!(\"'{}' is not a valid number\", s)),\n    }\n}\n\nfn main() {\n    let inputs = [\"42\", \"abc\", \"100\", \"xyz\"];\n\n    for input in inputs {\n        match parse_and_double(input) {\n            Ok(result) => println!(\"{} * 2 = {}\", input, result),\n            Err(e) => println!(\"Error: {}\", e),\n        }\n    }\n}\n```\n\n### **Challenge: Temperature Converter with Validation**\n\nCreate a function that converts Celsius to Fahrenheit, but returns an error if the temperature is below absolute zero (-273.15Â°C):\n\n```rust\nfn celsius_to_fahrenheit(celsius: f64) -> Result<f64, String> {\n    if celsius < -273.15 {\n        Err(String::from(\"Temperature below absolute zero!\"))\n    } else {\n        Ok(celsius * 1.8 + 32.0)\n    }\n}\n\nfn main() {\n    let temperatures = [25.0, -300.0, 0.0, -273.15];\n\n    for temp in temperatures {\n        match celsius_to_fahrenheit(temp) {\n            Ok(f) => println!(\"{}Â°C = {}Â°F\", temp, f),\n            Err(e) => println!(\"{}Â°C - Error: {}\", temp, e),\n        }\n    }\n}\n```\n\n## Key Takeaways\n\n- âœ… `Result<T, E>` represents success (`Ok`) or failure (`Err`)\n- âœ… `Ok(value)` contains the successful result\n- âœ… `Err(error)` contains information about the error\n- âœ… Use `match` to handle both cases\n- âœ… `.unwrap()` gets the value but panics on error\n- âœ… `.unwrap_or(default)` provides a fallback value\n- âœ… `.expect(msg)` like unwrap with custom panic message\n- âœ… `?` operator propagates errors (more in Module 6!)\n- âœ… More informative than `Option` when errors need context\n"
          }
        },
        {
          "id": "lesson-03-05",
          "title": "Module 3, Lesson 5: Practice Project â€” Creating a User Profile System",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "beginner",
          "content": {
            "format": "markdown",
            "body": "# Module 3, Lesson 5: Practice Project â€” Creating a User Profile System\n\n## Project Overview\n\nBuild a simple user profile management system that demonstrates structs, enums, Option, and Result!\n\n**What we're building:**\n- User profiles with personal information\n- Different account types (Regular, Premium, Admin)\n- Validation for user data\n- Methods to display and modify profiles\n\n**Skills practiced:**\n- âœ… Structs to organize data\n- âœ… Enums for account types\n- âœ… Option for optional fields\n- âœ… Result for error handling\n- âœ… Methods on structs\n\n## The Complete Project\n\n### **Step 1: Create the Project**\n\n```bash\ncargo new user_profiles\ncd user_profiles\ncode .\n```\n\n### **Step 2: Build the System (Complete Code)**\n\nReplace `src/main.rs` with:\n\n```rust\n// Define account types\n#[derive(Debug)]\nenum AccountType {\n    Regular,\n    Premium,\n    Admin,\n}\n\n// Define user profile struct\n#[derive(Debug)]\nstruct UserProfile {\n    username: String,\n    email: String,\n    age: Option<u32>,           // Age is optional\n    account_type: AccountType,\n    bio: Option<String>,        // Bio is optional\n}\n\nimpl UserProfile {\n    // Constructor with validation\n    fn new(\n        username: String,\n        email: String,\n        age: Option<u32>,\n        account_type: AccountType,\n    ) -> Result<UserProfile, String> {\n        // Validate username\n        if username.is_empty() {\n            return Err(String::from(\"Username cannot be empty\"));\n        }\n\n        // Validate email (basic check)\n        if !email.contains('@') {\n            return Err(String::from(\"Invalid email format\"));\n        }\n\n        // Validate age if provided\n        if let Some(a) = age {\n            if a > 120 {\n                return Err(String::from(\"Age must be 120 or less\"));\n            }\n        }\n\n        Ok(UserProfile {\n            username,\n            email,\n            age,\n            account_type,\n            bio: None,  // Start with no bio\n        })\n    }\n\n    // Display user info\n    fn display(&self) {\n        println!(\"\\n=== User Profile ===\");\n        println!(\"Username: {}\", self.username);\n        println!(\"Email: {}\", self.email);\n\n        match &self.age {\n            Some(a) => println!(\"Age: {}\", a),\n            None => println!(\"Age: Not specified\"),\n        }\n\n        println!(\"Account: {:?}\", self.account_type);\n\n        match &self.bio {\n            Some(b) => println!(\"Bio: {}\", b),\n            None => println!(\"Bio: Not set\"),\n        }\n        println!(\"===================\\n\");\n    }\n\n    // Set bio\n    fn set_bio(&mut self, bio: String) -> Result<(), String> {\n        if bio.len() > 200 {\n            Err(String::from(\"Bio too long (max 200 characters)\"))\n        } else {\n            self.bio = Some(bio);\n            Ok(())\n        }\n    }\n\n    // Check if user has premium features\n    fn has_premium_access(&self) -> bool {\n        matches!(self.account_type, AccountType::Premium | AccountType::Admin)\n    }\n\n    // Upgrade to premium\n    fn upgrade_to_premium(&mut self) -> Result<(), String> {\n        match self.account_type {\n            AccountType::Regular => {\n                self.account_type = AccountType::Premium;\n                Ok(())\n            }\n            AccountType::Premium => Err(String::from(\"Already premium\")),\n            AccountType::Admin => Err(String::from(\"Admins don't need upgrades\")),\n        }\n    }\n}\n\nfn main() {\n    println!(\"=== User Profile System ===\\n\");\n\n    // Create valid user\n    let user1 = UserProfile::new(\n        String::from(\"alice\"),\n        String::from(\"alice@example.com\"),\n        Some(25),\n        AccountType::Regular,\n    );\n\n    match user1 {\n        Ok(mut user) => {\n            user.display();\n\n            // Set bio\n            match user.set_bio(String::from(\"I love Rust programming!\")) {\n                Ok(()) => println!(\"Bio updated successfully\"),\n                Err(e) => println!(\"Error: {}\", e),\n            }\n\n            user.display();\n\n            // Check premium access\n            if user.has_premium_access() {\n                println!(\"User has premium features\");\n            } else {\n                println!(\"User has basic features\");\n            }\n\n            // Try to upgrade\n            match user.upgrade_to_premium() {\n                Ok(()) => println!(\"Upgraded to premium!\"),\n                Err(e) => println!(\"Upgrade error: {}\", e),\n            }\n\n            user.display();\n        }\n        Err(e) => println!(\"Error creating user: {}\", e),\n    }\n\n    // Try to create invalid users\n    println!(\"\\n=== Testing Validation ===\\n\");\n\n    let invalid_email = UserProfile::new(\n        String::from(\"bob\"),\n        String::from(\"not-an-email\"),\n        Some(30),\n        AccountType::Regular,\n    );\n\n    match invalid_email {\n        Ok(_) => println!(\"User created\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n\n    let invalid_age = UserProfile::new(\n        String::from(\"charlie\"),\n        String::from(\"charlie@example.com\"),\n        Some(150),\n        AccountType::Regular,\n    );\n\n    match invalid_age {\n        Ok(_) => println!(\"User created\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n\n    // Create admin user\n    let admin = UserProfile::new(\n        String::from(\"admin\"),\n        String::from(\"admin@example.com\"),\n        None,  // Age not specified\n        AccountType::Admin,\n    );\n\n    if let Ok(user) = admin {\n        user.display();\n        println!(\"Has premium access: {}\", user.has_premium_access());\n    }\n}\n```\n\n### **Step 3: Run the Project**\n\n```bash\ncargo run\n```\n\n**Expected output:**\n```\n=== User Profile System ===\n\n=== User Profile ===\nUsername: alice\nEmail: alice@example.com\nAge: 25\nAccount: Regular\nBio: Not set\n===================\n\nBio updated successfully\n\n=== User Profile ===\nUsername: alice\nEmail: alice@example.com\nAge: 25\nAccount: Regular\nBio: I love Rust programming!\n===================\n\nUser has basic features\nUpgraded to premium!\n\n=== User Profile ===\nUsername: alice\nEmail: alice@example.com\nAge: 25\nAccount: Premium\nBio: I love Rust programming!\n===================\n\n=== Testing Validation ===\n\nError: Invalid email format\nError: Age must be 120 or less\n\n=== User Profile ===\nUsername: admin\nEmail: admin@example.com\nAge: Not specified\nAccount: Admin\nBio: Not set\n===================\n\nHas premium access: true\n```\n\n## Understanding the Code\n\n**1. Using enums for account types:**\n```rust\nenum AccountType {\n    Regular,\n    Premium,\n    Admin,\n}\n```\n\n**2. Using Option for optional fields:**\n```rust\nage: Option<u32>,      // User might not provide age\nbio: Option<String>,   // Bio might not be set\n```\n\n**3. Using Result for validation:**\n```rust\nfn new(...) -> Result<UserProfile, String> {\n    if username.is_empty() {\n        return Err(String::from(\"Username cannot be empty\"));\n    }\n    Ok(UserProfile { ... })\n}\n```\n\n**4. Pattern matching on enums:**\n```rust\nmatch self.account_type {\n    AccountType::Regular => { /* upgrade */ },\n    AccountType::Premium => Err(...),\n    AccountType::Admin => Err(...),\n}\n```\n\n## Challenges and Extensions\n\n### **Challenge 1: Add More Validation**\n\nAdd validation for:\n- Username must be at least 3 characters\n- Username can only contain letters, numbers, underscore\n- Email must contain a dot after the @\n\n### **Challenge 2: Add Friend System**\n\nAdd a `friends` field (Vec<String>) and methods:\n- `add_friend(username: String) -> Result<(), String>`\n- `remove_friend(username: String) -> Result<(), String>`\n- `list_friends()`\n\n### **Challenge 3: Add User Statistics**\n\nAdd fields:\n- `post_count: u32`\n- `joined_date: String`\n\nAdd methods:\n- `increment_posts()`\n- `get_days_since_joined() -> u32`\n\n### **Challenge 4: Save/Load from File**\n\nUse `std::fs` to save profiles to a text file and load them back.\n\n## Key Takeaways\n\n- âœ… Structs organize related data\n- âœ… Enums represent distinct states\n- âœ… Option handles optional data\n- âœ… Result handles operations that can fail\n- âœ… Methods encapsulate behavior\n- âœ… Pattern matching handles all cases\n- âœ… Validation at construction prevents invalid states\n\n---\n\n## âœ… Module 3 Complete!\n\nYou've mastered data organization:\n- âœ… Structs (grouping data)\n- âœ… Enums (variants)\n- âœ… Option (maybe values)\n- âœ… Result (error handling)\n- âœ… Built a complete user profile system!\n\n**Next: Module 4 â€” The Ownership System (Rust's superpower)!**\n"
          }
        }
      ]
    },
    {
      "id": "module-04",
      "title": "MODULE 04",
      "description": "Module 4",
      "difficulty": "intermediate",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-04-01",
          "title": "Module 4, Lesson 1: Where Does Data Live? â€” The Stack and The Heap",
          "type": "project",
          "estimatedMinutes": 6,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 4, Lesson 1: Where Does Data Live? â€” The Stack and The Heap\n\n## âš ï¸ Important Introduction\n\nThis module teaches **Ownership** â€” Rust's most unique and important feature. It's what makes Rust both safe and fast. Take your time with these lessons!\n\nMany beginners find ownership confusing at first. That's normal! We'll break it down into small, digestible pieces with lots of analogies.\n\n## The Concept: Two Different Storage Areas\n\nImagine you're organizing your workspace:\n\n**Your Desk (Fast, Limited Space):**\n- Items are stacked in neat piles\n- Very quick to add or remove from the top\n- Limited spaceâ€”only for items you're using RIGHT NOW\n- Everything must be a known, fixed size\n\n**Your Warehouse (Slower, Unlimited Space):**\n- Items can be any size\n- Takes longer to store and retrieve\n- Can grow or shrink as needed\n- You get a receipt (address) to find items later\n\nComputers work the same way. They have two places to store data:\n- **The Stack** (like your desk)\n- **The Heap** (like your warehouse)\n\n## The Stack: Fast and Organized\n\n**The Stack:**\n- Stores data in a LIFO (Last In, First Out) orderâ€”like a stack of plates\n- Super fast (adding/removing from the top is instant)\n- Automatic cleanup (when a function ends, its stack data disappears)\n- **Only for fixed-size data** (known at compile time)\n\n**What goes on the stack:**\n- Numbers: `i32`, `f64`, `bool`\n- Characters: `char`\n- Fixed-size arrays: `[i32; 5]`\n- References (pointers to data)\n\n**Analogy:**\nThink of the stack like a stack of trays in a cafeteria. You can only take the top tray (fast!), and when you're done, you put it back on top. Everything is orderly and automatic.\n\n## The Heap: Flexible but Slower\n\n**The Heap:**\n- Stores data that can grow or shrink\n- Slower than the stack (must find available space first)\n- Manual management (something must clean it up)\n- For variable-size data\n\n**What goes on the heap:**\n- `String` (text that can grow)\n- `Vec<T>` (lists that can grow)\n- Large or dynamically-sized data\n\n**Analogy:**\nThink of the heap like a huge parking lot. When you park your car, you get a ticket with the parking spot number. Finding a spot takes time, and you need that ticket to find your car later.\n\n## Visual Comparison\n\n```\nSTACK (Fast, Fixed-Size)          HEAP (Flexible, Slower)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  number: 42  â”‚                  â”‚                         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                  â”‚  \"Hello, World!\"        â”‚\nâ”‚  is_active   â”‚                  â”‚  (can grow)             â”‚\nâ”‚  true        â”‚                  â”‚                         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                  â”‚  [1, 2, 3, 4, ...]      â”‚\nâ”‚  reference   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚  (can grow)             â”‚\nâ”‚  0x1234      â”‚  (points to      â”‚                         â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   heap data)     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Code Examples\n\n**Stack data (fixed size):**\n\n```rust\nfn main() {\n    let x = 5;           // Stored on stack (i32 is fixed size)\n    let y = true;        // Stored on stack (bool is fixed size)\n    let z = 3.14;        // Stored on stack (f64 is fixed size)\n\n    println!(\"{}, {}, {}\", x, y, z);\n}  // x, y, z automatically cleaned up when function ends\n```\n\n**Heap data (can grow):**\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");  // \"hello\" stored on heap\n                                     // s (a pointer) stored on stack\n\n    // s can grow:\n    let mut s = String::from(\"hello\");\n    s.push_str(\", world!\");  // Now \"hello, world!\" on heap\n    println!(\"{}\", s);\n}  // Rust automatically cleans up heap memory here\n```\n\n## Why This Matters for Ownership\n\nHere's the key insight:\n\n**Stack data is simple:**\n- Cheap to copy\n- Automatic cleanup\n- No complexity\n\n**Heap data is complex:**\n- Expensive to copy (the whole data must be duplicated)\n- Needs explicit cleanup (or memory leaks!)\n- This is where **Ownership** comes in\n\nRust's ownership rules exist primarily to manage heap data safely and efficiently!\n\n## Copying vs. Moving\n\n**Stack data (cheap to copy):**\n\n```rust\nfn main() {\n    let x = 5;\n    let y = x;  // Copies the value (cheap!)\n\n    println!(\"x: {}, y: {}\", x, y);  // Both x and y are usable\n}\n```\n\n**Heap data (expensive to copy, so it MOVES instead):**\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1;  // s1 is MOVED to s2 (not copied!)\n\n    // println!(\"{}\", s1);  // âŒ ERROR: s1 is no longer valid!\n    println!(\"{}\", s2);     // âœ… OK: s2 owns the data now\n}\n```\n\nWe'll explore this more in the next lesson!\n\n## Hands-On Practice\n\n### **Create a Practice Project**\n\n```bash\ncargo new stack_heap_practice\ncd stack_heap_practice\ncode .\n```\n\n### **Experiment 1: Stack Data (Numbers)**\n\n```rust\nfn main() {\n    let a = 10;\n    let b = a;  // Copy (cheap!)\n\n    println!(\"a: {}, b: {}\", a, b);  // Both work!\n}\n```\n\nRun thisâ€”both `a` and `b` are usable.\n\n### **Experiment 2: Heap Data (String)**\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1;  // Move (not copy!)\n\n    // Uncomment the next line to see the error:\n    // println!(\"{}\", s1);  // âŒ ERROR!\n\n    println!(\"{}\", s2);  // âœ… OK\n}\n```\n\nRun thisâ€”notice `s1` is no longer usable after the move!\n\n### **Experiment 3: Cloning Heap Data**\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1.clone();  // Explicitly copy heap data\n\n    println!(\"s1: {}, s2: {}\", s1, s2);  // Both work!\n}\n```\n\n`.clone()` makes a deep copy of heap data (expensive but sometimes necessary).\n\n### **Experiment 4: Function Calls**\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n    take_ownership(s);  // s is moved into the function\n\n    // println!(\"{}\", s);  // âŒ ERROR: s was moved!\n}\n\nfn take_ownership(some_string: String) {\n    println!(\"{}\", some_string);\n}  // some_string is dropped here\n```\n\n## Key Takeaways\n\n- âœ… **Stack**: Fast, fixed-size, automatic cleanup\n- âœ… **Heap**: Flexible, variable-size, needs management\n- âœ… Stack data (i32, bool, etc.) is **copied**\n- âœ… Heap data (String, Vec, etc.) is **moved** by default\n- âœ… Moving prevents accidental double-freeing of memory\n- âœ… Use `.clone()` to explicitly copy heap data\n- âœ… Ownership rules manage heap memory safely\n- âœ… This is the foundation for understanding the next lessons!\n\n**Next**: We'll learn the three ownership rules that govern how data moves around your program.\n"
          }
        },
        {
          "id": "lesson-04-02",
          "title": "Module 4, Lesson 2: Who Owns This Data? â€” Understanding Ownership Rules",
          "type": "project",
          "estimatedMinutes": 7,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 4, Lesson 2: Who Owns This Data? â€” Understanding Ownership Rules\n\n## The Concept: One Owner at a Time\n\nImagine you have a physical book. At any given moment:\n- **Exactly ONE person** has the book in their hands (the owner)\n- The owner can read it, write in it, or lend it to someone else\n- When the owner is done, they can give it away (transfer ownership)\n- When no one owns it anymore, it gets thrown away\n\nRust enforces this same rule for data in your program. Every piece of data has **exactly one owner** at any time. This prevents multiple parts of your code from accidentally corrupting the same data.\n\n## The Three Ownership Rules\n\nThese are THE most important rules in Rust. Memorize them:\n\n1. **Each value in Rust has an owner**\n   - Every piece of data is owned by exactly one variable\n\n2. **There can only be one owner at a time**\n   - You can't have two variables owning the same data simultaneously\n\n3. **When the owner goes out of scope, the value is dropped**\n   - When the owner variable disappears, Rust automatically cleans up the data\n\n## Rule 1: Each Value Has an Owner\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");  // s is the owner of \"hello\"\n\n    println!(\"{}\", s);\n}  // s goes out of scope here, \"hello\" is automatically freed\n```\n\n**Visual representation:**\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Variable s  â”‚ â”€â”€â”€> \"hello\" (on heap)\nâ”‚  (owner)    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n`s` owns the String \"hello\". When `s` goes away, \"hello\" is cleaned up.\n\n## Rule 2: Only One Owner at a Time\n\n**What happens when you assign one variable to another?**\n\n### With Stack Data (Cheap Copy)\n\n```rust\nfn main() {\n    let x = 5;       // x owns the value 5\n    let y = x;       // y gets a COPY of 5\n\n    println!(\"x: {}, y: {}\", x, y);  // Both work! (5 is copied)\n}\n```\n\nStack data (integers, bools, etc.) is so cheap to copy that Rust just copies it.\n\n### With Heap Data (Move)\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");  // s1 owns \"hello\"\n    let s2 = s1;                     // Ownership MOVES to s2\n\n    // println!(\"{}\", s1);  // âŒ ERROR! s1 no longer owns the data\n    println!(\"{}\", s2);     // âœ… OK! s2 now owns it\n}\n```\n\n**What happened:**\n\n```\nBEFORE:\nâ”Œâ”€â”€â”€â”€â”\nâ”‚ s1 â”‚ â”€â”€â”€> \"hello\"\nâ””â”€â”€â”€â”€â”˜\n\nAFTER let s2 = s1:\nâ”Œâ”€â”€â”€â”€â”\nâ”‚ s1 â”‚ (invalid!)\nâ””â”€â”€â”€â”€â”˜\nâ”Œâ”€â”€â”€â”€â”\nâ”‚ s2 â”‚ â”€â”€â”€> \"hello\"  (ownership transferred)\nâ””â”€â”€â”€â”€â”˜\n```\n\nOwnership **moved** from `s1` to `s2`. Now only `s2` can use the data.\n\n**Why?** To prevent \"double-free\" errors. If both `s1` and `s2` tried to clean up \"hello\", it would cause a crash.\n\n## Rule 3: When Owner Goes Out of Scope, Value is Dropped\n\n```rust\nfn main() {\n    {\n        let s = String::from(\"hello\");  // s is valid from here\n\n        println!(\"{}\", s);  // use s\n\n    }  // s goes out of scope HERE - \"hello\" is automatically freed\n\n    // println!(\"{}\", s);  // âŒ ERROR! s doesn't exist anymore\n}\n```\n\nRust automatically calls `drop()` to clean up the memory when the owner goes out of scope. You never have to manually free memory!\n\n## Functions and Ownership\n\nPassing a value to a function **moves ownership**:\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n\n    takes_ownership(s);  // s's value moves into the function\n\n    // println!(\"{}\", s);  // âŒ ERROR! s no longer owns the data\n}\n\nfn takes_ownership(some_string: String) {\n    println!(\"{}\", some_string);\n}  // some_string goes out of scope and is dropped here\n```\n\n**Visual representation:**\n\n```\nmain():\n  s â”€â”€â”€> \"hello\"\n         â†“ (moved)\ntakes_ownership():\n  some_string â”€â”€â”€> \"hello\"\n  â†“ (dropped when function ends)\n  ðŸ—‘ï¸\n```\n\n## Returning Ownership from Functions\n\nFunctions can **return ownership** back:\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let s2 = takes_and_gives_back(s1);  // s1 moved in, ownership returned as s2\n\n    // println!(\"{}\", s1);  // âŒ ERROR! s1 was moved\n    println!(\"{}\", s2);     // âœ… OK! s2 owns it now\n}\n\nfn takes_and_gives_back(a_string: String) -> String {\n    a_string  // Return ownership to the caller\n}\n```\n\n## Cloning: Making an Explicit Copy\n\nIf you want TWO variables to have the SAME data, use `.clone()`:\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1.clone();  // Make a deep copy\n\n    println!(\"s1: {}, s2: {}\", s1, s2);  // Both work!\n}\n```\n\n**Visual:**\n\n```\nâ”Œâ”€â”€â”€â”€â”\nâ”‚ s1 â”‚ â”€â”€â”€> \"hello\" (original)\nâ””â”€â”€â”€â”€â”˜\nâ”Œâ”€â”€â”€â”€â”\nâ”‚ s2 â”‚ â”€â”€â”€> \"hello\" (copy)\nâ””â”€â”€â”€â”€â”˜\n```\n\nNow there are TWO separate copies in memory. Cloning is **expensive** - use it sparingly!\n\n## Stack-Only Data: The Copy Trait\n\nSome types are so simple that Rust automatically copies them:\n\n```rust\nfn main() {\n    let x = 5;\n    let y = x;  // Copy, not move!\n\n    println!(\"x: {}, y: {}\", x, y);  // Both work\n}\n```\n\n**Types that implement `Copy` (automatic copying):**\n- All integers: `i32`, `u32`, `i64`, etc.\n- Booleans: `bool`\n- Floating-point: `f32`, `f64`\n- Characters: `char`\n- Tuples of Copy types: `(i32, i32)`, `(i32, bool)`\n\n**Types that do NOT implement `Copy` (ownership moves):**\n- `String`\n- `Vec<T>`\n- Any type with heap-allocated data\n\n## Hands-On Practice\n\n### **Create a Practice Project**\n\n```bash\ncargo new ownership_rules\ncd ownership_rules\ncode .\n```\n\n### **Experiment 1: Move Semantics**\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1;  // Move\n\n    // Uncomment to see the error:\n    // println!(\"{}\", s1);  // âŒ ERROR!\n\n    println!(\"{}\", s2);  // âœ… OK\n}\n```\n\n### **Experiment 2: Function Ownership**\n\n```rust\nfn main() {\n    let s = String::from(\"world\");\n\n    print_string(s);  // s is moved into function\n\n    // Uncomment to see the error:\n    // println!(\"{}\", s);  // âŒ ERROR! s was moved\n}\n\nfn print_string(text: String) {\n    println!(\"{}\", text);\n}  // text is dropped here\n```\n\n### **Experiment 3: Returning Ownership**\n\n```rust\nfn main() {\n    let s1 = gives_ownership();  // Function returns ownership\n    println!(\"{}\", s1);\n\n    let s2 = String::from(\"hello\");\n    let s3 = takes_and_gives_back(s2);  // s2 moved, ownership returned as s3\n\n    println!(\"{}\", s3);\n    // println!(\"{}\", s2);  // âŒ ERROR! s2 was moved\n}\n\nfn gives_ownership() -> String {\n    String::from(\"yours\")  // Ownership given to caller\n}\n\nfn takes_and_gives_back(text: String) -> String {\n    text  // Ownership returned\n}\n```\n\n### **Experiment 4: Cloning vs. Moving**\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    // Clone (expensive but preserves original)\n    let s2 = s1.clone();\n    println!(\"s1: {}, s2: {}\", s1, s2);  // Both work\n\n    // Move (efficient but original becomes invalid)\n    let s3 = String::from(\"world\");\n    let s4 = s3;\n    // println!(\"{}\", s3);  // âŒ ERROR!\n    println!(\"{}\", s4);\n}\n```\n\n### **Experiment 5: Copy Types**\n\n```rust\nfn main() {\n    // Integers are Copy\n    let x = 5;\n    let y = x;\n    println!(\"x: {}, y: {}\", x, y);  // Both work!\n\n    // Strings are NOT Copy (they move)\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n    // println!(\"{}\", s1);  // âŒ ERROR!\n    println!(\"{}\", s2);\n}\n```\n\n### **Challenge: Fix the Ownership Errors**\n\nThis code has ownership errors. Fix it by either:\n- Using `.clone()`\n- Returning ownership from functions\n- Using different variables\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n\n    calculate_length(s);\n    println!(\"{}\", s);  // âŒ ERROR! Fix this\n}\n\nfn calculate_length(text: String) {\n    println!(\"Length: {}\", text.len());\n}\n```\n\n**Solution 1: Clone**\n```rust\ncalculate_length(s.clone());\n```\n\n**Solution 2: Return ownership**\n```rust\nfn calculate_length(text: String) -> String {\n    println!(\"Length: {}\", text.len());\n    text  // Return ownership\n}\n\nlet s = calculate_length(s);\n```\n\n**Solution 3: Use references (next lesson!)**\n```rust\n// We'll learn this in Lesson 4!\n```\n\n## Key Takeaways\n\n- âœ… **Rule 1**: Each value has exactly one owner\n- âœ… **Rule 2**: Only one owner at a time (moves, not copies for heap data)\n- âœ… **Rule 3**: When owner goes out of scope, value is dropped (automatic cleanup)\n- âœ… Passing to functions **moves** ownership\n- âœ… Returning from functions **gives** ownership back\n- âœ… `.clone()` makes an explicit deep copy\n- âœ… Stack data (i32, bool, etc.) implements `Copy` - automatically copied\n- âœ… Heap data (String, Vec) is **moved** by default\n\n## Why This Matters\n\nOwnership prevents:\n- **Memory leaks** (forgetting to free memory)\n- **Double-free errors** (freeing the same memory twice)\n- **Use-after-free errors** (using memory after it's freed)\n- **Data races** (multiple parts of code modifying the same data)\n\nAll of this happens **at compile time** with zero runtime cost!\n\n**Next lesson**: We'll learn about **borrowing** - a way to let functions use data WITHOUT taking ownership!\n"
          }
        },
        {
          "id": "lesson-04-03",
          "title": "Module 4, Lesson 3: Fighting the Compiler (On Purpose) â€” Common Ownership Errors",
          "type": "project",
          "estimatedMinutes": 8,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 4, Lesson 3: Fighting the Compiler (On Purpose) â€” Common Ownership Errors\n\n## The Concept: Learning from Mistakes\n\nImagine learning to ride a bike. You WILL fall a few times. But each fall teaches you:\n- \"Leaning too far left causes a fall\"\n- \"Going too fast without braking is dangerous\"\n- \"Looking down instead of ahead makes you unstable\"\n\nLearning Rust is similar. The compiler will stop you from making mistakes, but **each error message teaches you something important**. In this lesson, we'll intentionally make mistakes and learn from them.\n\nThink of the compiler as a patient teacher who catches your mistakes BEFORE they become bugs.\n\n## Error 1: Using a Value After Move\n\n### **The Mistake**\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n    let t = s;  // s moves to t\n\n    println!(\"{}\", s);  // âŒ Trying to use s after it moved\n}\n```\n\n### **The Error Message**\n\n```\nerror[E0382]: borrow of moved value: `s`\n --> src/main.rs:5:20\n  |\n2 |     let s = String::from(\"hello\");\n  |         - move occurs because `s` has type `String`, which does not implement the `Copy` trait\n3 |     let t = s;\n  |             - value moved here\n4 |\n5 |     println!(\"{}\", s);\n  |                    ^ value borrowed here after move\n```\n\n### **What It Means**\n\nThe compiler is telling you:\n1. Line 3: \"`s` moved to `t`\"\n2. Line 5: \"You tried to use `s` after it moved\"\n3. Suggestion: \"String doesn't implement Copy, so it moves\"\n\n### **How to Fix**\n\n**Option 1: Use the new owner**\n```rust\nlet s = String::from(\"hello\");\nlet t = s;\nprintln!(\"{}\", t);  // âœ… Use t instead\n```\n\n**Option 2: Clone if you need both**\n```rust\nlet s = String::from(\"hello\");\nlet t = s.clone();\nprintln!(\"{}, {}\", s, t);  // âœ… Both work\n```\n\n**Option 3: Don't move (we'll learn borrowing next lesson!)**\n```rust\n// Coming soon: borrowing with &\n```\n\n## Error 2: Moving in a Function and Using After\n\n### **The Mistake**\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n\n    print_length(s);  // s moves into function\n\n    println!(\"String was: {}\", s);  // âŒ s is gone!\n}\n\nfn print_length(text: String) {\n    println!(\"Length: {}\", text.len());\n}\n```\n\n### **The Error Message**\n\n```\nerror[E0382]: borrow of moved value: `s`\n --> src/main.rs:6:32\n  |\n2 |     let s = String::from(\"hello\");\n  |         - move occurs because `s` has type `String`\n3 |\n4 |     print_length(s);\n  |                  - value moved here\n5 |\n6 |     println!(\"String was: {}\", s);\n  |                                ^ value borrowed here after move\n```\n\n### **How to Fix**\n\n**Option 1: Return ownership**\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n    let s = print_length(s);  // Get ownership back\n    println!(\"String was: {}\", s);\n}\n\nfn print_length(text: String) -> String {\n    println!(\"Length: {}\", text.len());\n    text  // Return ownership\n}\n```\n\n**Option 2: Clone (wasteful)**\n```rust\nprint_length(s.clone());  // Function gets a copy\nprintln!(\"String was: {}\", s);  // Original still valid\n```\n\n**Option 3: Use references (best - next lesson!)**\n\n## Error 3: Moving in a Loop\n\n### **The Mistake**\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n\n    for i in 0..3 {\n        print_string(s);  // âŒ Tries to move s three times!\n    }\n}\n\nfn print_string(text: String) {\n    println!(\"{}\", text);\n}\n```\n\n### **The Error Message**\n\n```\nerror[E0382]: use of moved value: `s`\n --> src/main.rs:5:22\n  |\n2 |     let s = String::from(\"hello\");\n  |         - move occurs because `s` has type `String`\n3 |\n4 |     for i in 0..3 {\n5 |         print_string(s);\n  |                      ^ value moved here, in previous iteration of loop\n```\n\n### **What It Means**\n\n- First loop iteration: `s` moves into `print_string()` and is dropped\n- Second iteration: Trying to move `s` again, but it's already gone!\n\n### **How to Fix**\n\n**Option 1: Clone in the loop (expensive)**\n```rust\nfor i in 0..3 {\n    print_string(s.clone());\n}\n```\n\n**Option 2: Use references (efficient - next lesson!)**\n\n## Error 4: Multiple Mutable Bindings\n\n### **The Mistake**\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    let r1 = &mut s;\n    let r2 = &mut s;  // âŒ Two mutable references!\n\n    println!(\"{}, {}\", r1, r2);\n}\n```\n\n### **The Error Message**\n\n```\nerror[E0499]: cannot borrow `s` as mutable more than once at a time\n --> src/main.rs:5:14\n  |\n4 |     let r1 = &mut s;\n  |              ------ first mutable borrow occurs here\n5 |     let r2 = &mut s;\n  |              ^^^^^^ second mutable borrow occurs here\n6 |\n7 |     println!(\"{}, {}\", r1, r2);\n  |                        -- first borrow later used here\n```\n\n### **What It Means**\n\nRust prevents you from having multiple mutable references to the same data at the same time. This prevents data races!\n\n### **How to Fix**\n\n**Option 1: Don't use r1 after creating r2**\n```rust\nlet mut s = String::from(\"hello\");\n\nlet r1 = &mut s;\nprintln!(\"{}\", r1);  // Use r1\n\nlet r2 = &mut s;  // âœ… OK: r1 is no longer used\nprintln!(\"{}\", r2);\n```\n\n**Option 2: Use scopes**\n```rust\nlet mut s = String::from(\"hello\");\n\n{\n    let r1 = &mut s;\n    println!(\"{}\", r1);\n}  // r1 goes out of scope\n\nlet r2 = &mut s;  // âœ… OK: r1 is gone\nprintln!(\"{}\", r2);\n```\n\n## Error 5: Mixing Immutable and Mutable References\n\n### **The Mistake**\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    let r1 = &s;      // Immutable borrow\n    let r2 = &s;      // Another immutable borrow (OK)\n    let r3 = &mut s;  // âŒ Mutable borrow while immutable exist!\n\n    println!(\"{}, {}, {}\", r1, r2, r3);\n}\n```\n\n### **The Error Message**\n\n```\nerror[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable\n --> src/main.rs:6:14\n  |\n4 |     let r1 = &s;\n  |              -- immutable borrow occurs here\n5 |     let r2 = &s;\n6 |     let r3 = &mut s;\n  |              ^^^^^^ mutable borrow occurs here\n7 |\n8 |     println!(\"{}, {}, {}\", r1, r2, r3);\n  |                            -- immutable borrow later used here\n```\n\n### **What It Means**\n\nYou can't modify data while others are reading it! This prevents data from changing unexpectedly.\n\n### **How to Fix**\n\n```rust\nlet mut s = String::from(\"hello\");\n\nlet r1 = &s;\nlet r2 = &s;\nprintln!(\"{}, {}\", r1, r2);  // Use immutable references\n\nlet r3 = &mut s;  // âœ… OK: r1 and r2 no longer used\nprintln!(\"{}\", r3);\n```\n\n## Hands-On Practice: Error Scavenger Hunt\n\n### **Create a Practice Project**\n\n```bash\ncargo new ownership_errors\ncd ownership_errors\ncode .\n```\n\n### **Exercise 1: Identify the Error**\n\nWhat's wrong with this code?\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n    let s3 = s1;  // âŒ What's the problem?\n}\n```\n\n<details>\n<summary>Answer</summary>\n\n`s1` moved to `s2`, so it can't move to `s3` again.\n\n**Fix:**\n```rust\nlet s2 = s1.clone();\nlet s3 = s1.clone();\n```\n</details>\n\n### **Exercise 2: Identify the Error**\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n    takes_ownership(s);\n    takes_ownership(s);  // âŒ What's the problem?\n}\n\nfn takes_ownership(text: String) {\n    println!(\"{}\", text);\n}\n```\n\n<details>\n<summary>Answer</summary>\n\nFirst call moves `s`, second call tries to move it again.\n\n**Fix:**\n```rust\ntakes_ownership(s.clone());\ntakes_ownership(s);\n```\n\nOr return ownership from the function.\n</details>\n\n### **Exercise 3: Identify the Error**\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    let r1 = &mut s;\n    let r2 = &mut s;  // âŒ What's the problem?\n\n    r1.push_str(\" world\");\n    r2.push_str(\"!\");\n}\n```\n\n<details>\n<summary>Answer</summary>\n\nCan't have two mutable references at the same time.\n\n**Fix:**\n```rust\nlet r1 = &mut s;\nr1.push_str(\" world\");\n\nlet r2 = &mut s;  // r1 no longer used\nr2.push_str(\"!\");\n```\n</details>\n\n### **Challenge: Fix All the Errors**\n\nThis program has multiple ownership errors. Fix them WITHOUT using `.clone()`:\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n\n    let len = calculate_length(s);\n    println!(\"The length of '{}' is {}\", s, len);  // âŒ\n}\n\nfn calculate_length(text: String) -> usize {\n    text.len()\n}  // text is dropped here\n```\n\n**Hint**: You'll need to return the String along with the length.\n\n<details>\n<summary>Solution</summary>\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n\n    let (s, len) = calculate_length(s);  // Return both!\n    println!(\"The length of '{}' is {}\", s, len);\n}\n\nfn calculate_length(text: String) -> (String, usize) {\n    let length = text.len();\n    (text, length)  // Return tuple\n}\n```\n\n**But this is awkward!** In the next lesson, we'll learn **borrowing** - a much better solution!\n</details>\n\n## Compiler Error Patterns to Remember\n\n1. **\"borrow of moved value\"** â†’ You moved data and tried to use it again\n2. **\"use of moved value\"** â†’ Same as above\n3. **\"cannot borrow as mutable more than once\"** â†’ Multiple mutable references\n4. **\"cannot borrow as mutable because it is also borrowed as immutable\"** â†’ Mixed borrows\n\n## Key Takeaways\n\n- âœ… Compiler errors are **teaching tools**, not obstacles\n- âœ… \"Use after move\" is the most common beginner error\n- âœ… Each error message tells you EXACTLY what's wrong and where\n- âœ… You can't have multiple mutable references simultaneously\n- âœ… You can't mix mutable and immutable references\n- âœ… Ownership errors are caught at **compile time** (no runtime crashes!)\n- âœ… These restrictions prevent entire classes of bugs\n\n## The Good News\n\nAll of these errors seem restrictive now, but they prevent:\n- Segmentation faults\n- Use-after-free bugs\n- Data races\n- Memory corruption\n\nAnd in the next lesson, we'll learn **borrowing** - which makes ownership much more ergonomic!\n\n**Next**: Learn how to **lend** data to functions without transferring ownership!\n"
          }
        },
        {
          "id": "lesson-04-04",
          "title": "Module 4, Lesson 4: Lending Data Temporarily â€” Immutable Borrowing (References)",
          "type": "project",
          "estimatedMinutes": 8,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 4, Lesson 4: Lending Data Temporarily â€” Immutable Borrowing (References)\n\n## The Concept: Borrowing a Book\n\nImagine you own a book. Your friend wants to read it. You have two options:\n\n**Option 1: Give them the book (transfer ownership)**\n- They take the book home\n- You can't read it until they give it back\n- When they're done, they might forget to return it!\n\n**Option 2: Let them borrow it (reference)**\n- They can read it at your house\n- You still own it\n- They can't write in it or damage it\n- When they're done, you automatically have it back\n\n**Borrowing** in Rust works like Option 2. You let a function \"look at\" your data without giving away ownership.\n\n## The Problem We're Solving\n\nRemember this awkward code from the last lesson?\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n    let (s, len) = calculate_length(s);  // Have to return s back!\n    println!(\"Length of '{}' is {}\", s, len);\n}\n\nfn calculate_length(text: String) -> (String, usize) {\n    let length = text.len();\n    (text, length)  // Return both!\n}\n```\n\nThis is clunky! We just want to **read** the length, not take ownership.\n\n## The Solution: References\n\nA **reference** lets you refer to a value without owning it:\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n\n    let len = calculate_length(&s);  // Borrow s with &\n\n    println!(\"Length of '{}' is {}\", s, len);  // s is still valid!\n}\n\nfn calculate_length(text: &String) -> usize {\n    text.len()\n}  // text goes out of scope, but it doesn't own the String, so nothing is dropped\n```\n\n**Much better!** Now we can use `s` after calling the function.\n\n## Reference Syntax\n\n**Creating a reference: `&`**\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // r is a reference to s\n```\n\n**Accepting a reference in a function: `&Type`**\n```rust\nfn print_string(text: &String) {\n    println!(\"{}\", text);\n}\n```\n\n**Visual representation:**\n\n```\nStack:                    Heap:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ s        â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> \"hello\"\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â†‘\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚\nâ”‚ r        â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (points to the same data)\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n`r` doesn't own \"hello\"â€”it just points to it!\n\n## Borrowing Rules for Immutable References\n\n1. **You can read the data**\n   ```rust\n   let s = String::from(\"hello\");\n   let r = &s;\n   println!(\"{}\", r);  // âœ… Reading is OK\n   ```\n\n2. **You CANNOT modify the data**\n   ```rust\n   let s = String::from(\"hello\");\n   let r = &s;\n   r.push_str(\" world\");  // âŒ ERROR! Can't modify through immutable reference\n   ```\n\n3. **You can have MULTIPLE immutable references**\n   ```rust\n   let s = String::from(\"hello\");\n   let r1 = &s;\n   let r2 = &s;\n   let r3 = &s;\n   println!(\"{}, {}, {}\", r1, r2, r3);  // âœ… All OK!\n   ```\n\n4. **Original owner can't modify while borrowed**\n   ```rust\n   let mut s = String::from(\"hello\");\n   let r = &s;\n   s.push_str(\" world\");  // âŒ ERROR! s is borrowed\n   println!(\"{}\", r);\n   ```\n\n## Multiple Immutable References (Allowed!)\n\nYou can have as many \"readers\" as you want:\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n\n    let r1 = &s;\n    let r2 = &s;\n    let r3 = &s;\n\n    println!(\"{}, {}, {}\", r1, r2, r3);  // âœ… All fine!\n}\n```\n\n**Why is this safe?** Everyone is just **reading**. No one can modify the data, so there's no risk of conflict.\n\n## Dereferencing (Usually Automatic)\n\nTo access the actual value, you can use `*` (dereference):\n\n```rust\nlet x = 5;\nlet r = &x;\n\nprintln!(\"{}\", *r);  // Dereference to get 5\n```\n\nBut Rust usually does this automatically for you:\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;\n\nprintln!(\"{}\", r.len());  // âœ… Rust auto-dereferences for method calls\n```\n\n## Functions with References\n\n**Passing a reference:**\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n\n    print_length(&s);  // Pass a reference\n\n    println!(\"{}\", s);  // âœ… s still valid!\n}\n\nfn print_length(text: &String) {\n    println!(\"Length: {}\", text.len());\n}  // text (the reference) goes out of scope, but the String is not dropped\n```\n\n**Multiple parameters:**\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = String::from(\"world\");\n\n    let result = concatenate(&s1, &s2);\n\n    println!(\"{}\", result);\n    println!(\"Still have: {} and {}\", s1, s2);  // âœ… Both still valid\n}\n\nfn concatenate(a: &String, b: &String) -> String {\n    format!(\"{} {}\", a, b)  // Creates a NEW String\n}\n```\n\n## References to References\n\nYou can have references to references:\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n    let r1 = &s;\n    let r2 = &r1;  // Reference to a reference\n    let r3 = &r2;\n\n    println!(\"{}\", r3);  // Rust auto-dereferences all the way down\n}\n```\n\nBut this is rarely needed in practice.\n\n## Common Patterns\n\n### **Pattern 1: Reading without taking ownership**\n\n```rust\nfn get_first_word(text: &String) -> &str {\n    let bytes = text.as_bytes();\n\n    for (i, &byte) in bytes.iter().enumerate() {\n        if byte == b' ' {\n            return &text[0..i];\n        }\n    }\n\n    &text[..]\n}\n\nfn main() {\n    let sentence = String::from(\"hello world\");\n    let word = get_first_word(&sentence);\n\n    println!(\"First word: {}\", word);\n    println!(\"Full sentence: {}\", sentence);  // âœ… Still valid\n}\n```\n\n### **Pattern 2: Multiple reads from different functions**\n\n```rust\nfn main() {\n    let data = String::from(\"important data\");\n\n    validate(&data);\n    process(&data);\n    display(&data);\n\n    println!(\"Original data: {}\", data);  // âœ… Still valid\n}\n\nfn validate(text: &String) {\n    println!(\"Validating: {}\", text);\n}\n\nfn process(text: &String) {\n    println!(\"Processing: {}\", text);\n}\n\nfn display(text: &String) {\n    println!(\"Displaying: {}\", text);\n}\n```\n\n### **Pattern 3: Iterating without consuming**\n\n```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n\n    print_sum(&numbers);\n    print_average(&numbers);\n\n    println!(\"Numbers: {:?}\", numbers);  // âœ… Still valid\n}\n\nfn print_sum(nums: &Vec<i32>) {\n    let sum: i32 = nums.iter().sum();\n    println!(\"Sum: {}\", sum);\n}\n\nfn print_average(nums: &Vec<i32>) {\n    let sum: i32 = nums.iter().sum();\n    let avg = sum as f64 / nums.len() as f64;\n    println!(\"Average: {}\", avg);\n}\n```\n\n## Hands-On Practice\n\n### **Create a Practice Project**\n\n```bash\ncargo new immutable_borrowing\ncd immutable_borrowing\ncode .\n```\n\n### **Experiment 1: Basic References**\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n\n    let len = calculate_length(&s);\n\n    println!(\"The length of '{}' is {}\", s, len);\n}\n\nfn calculate_length(text: &String) -> usize {\n    text.len()\n}\n```\n\n### **Experiment 2: Multiple References**\n\n```rust\nfn main() {\n    let s = String::from(\"Rust\");\n\n    let r1 = &s;\n    let r2 = &s;\n    let r3 = &s;\n\n    println!(\"{}, {}, {}\", r1, r2, r3);  // All work!\n}\n```\n\n### **Experiment 3: References in Loops**\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n\n    for i in 0..5 {\n        print_string(&s);  // Borrow each time\n    }\n\n    println!(\"Original: {}\", s);  // âœ… Still valid\n}\n\nfn print_string(text: &String) {\n    println!(\"{}\", text);\n}\n```\n\n### **Experiment 4: Cannot Modify Through Immutable Reference**\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n    let r = &s;\n\n    // Uncomment to see the error:\n    // r.push_str(\" world\");  // âŒ ERROR!\n\n    println!(\"{}\", r);\n}\n```\n\n### **Challenge: String Analyzer**\n\nCreate functions that analyze a string without taking ownership:\n\n```rust\nfn main() {\n    let text = String::from(\"Hello, Rust programming!\");\n\n    println!(\"Length: {}\", get_length(&text));\n    println!(\"Word count: {}\", count_words(&text));\n    println!(\"Contains 'Rust': {}\", contains_word(&text, \"Rust\"));\n\n    println!(\"Original text: {}\", text);  // âœ… Still valid!\n}\n\nfn get_length(s: &String) -> usize {\n    s.len()\n}\n\nfn count_words(s: &String) -> usize {\n    s.split_whitespace().count()\n}\n\nfn contains_word(s: &String, word: &str) -> bool {\n    s.contains(word)\n}\n```\n\n## When to Use References\n\nâœ… **Use references when:**\n- You need to read data without taking ownership\n- Multiple parts of code need to read the same data\n- You want to avoid expensive clones\n- You're implementing a function that just observes data\n\nâŒ **Don't use references when:**\n- The function needs to take ownership (e.g., to return it or store it)\n- You need to modify the data (use mutable references - next lesson!)\n\n## Key Takeaways\n\n- âœ… **References** let you borrow data without taking ownership\n- âœ… **Syntax**: `&` creates a reference, `&Type` accepts one\n- âœ… **Immutable references** allow reading but NOT writing\n- âœ… **Multiple immutable references** are allowed simultaneously\n- âœ… Original data cannot be modified while borrowed immutably\n- âœ… References are automatically dereferenced for method calls\n- âœ… When the reference goes out of scope, the borrow ends\n- âœ… Much more ergonomic than transferring ownership back and forth!\n\n## The Analogy Recap\n\n| Concept | Book Analogy |\n|---------|--------------|\n| Ownership | You own the book |\n| Move | Give the book away |\n| Immutable reference | Let someone read it (but not write in it) |\n| Multiple immutable refs | Multiple people can read it |\n| Reference goes out of scope | Person done reading, book back to you |\n\n**Next**: Learn about **mutable references** - borrowing with permission to modify!\n"
          }
        },
        {
          "id": "lesson-04-05",
          "title": "Module 4, Lesson 5: Lending with Permission to Change â€” Mutable Borrowing",
          "type": "project",
          "estimatedMinutes": 8,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 4, Lesson 5: Lending with Permission to Change â€” Mutable Borrowing\n\n## The Concept: Borrowing with Edit Rights\n\nImagine you lend your notebook to a friend. You have two options:\n\n**Option 1: Read-only (immutable reference)**\n- \"You can look at my notes, but don't write in it\"\n- Multiple friends can look at it at once\n- No risk of changes\n\n**Option 2: With editing permission (mutable reference)**\n- \"You can look at AND edit my notes\"\n- Only ONE person can have it at a time (to prevent conflicts)\n- You can't look at it while they're editing (to avoid seeing half-finished edits)\n\n**Mutable references** in Rust work like Option 2. They allow modification, but with strict rules to prevent data races.\n\n## The Problem We're Solving\n\nWhat if we want a function to **modify** data without taking ownership?\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    // How do we let add_world modify s without taking ownership?\n    add_world(s);  // âŒ This moves s\n\n    println!(\"{}\", s);  // âŒ s is gone!\n}\n\nfn add_world(text: String) {\n    text.push_str(\" world\");  // âŒ Can't modify; text is immutable\n}\n```\n\nWe need a way to **borrow mutably**.\n\n## The Solution: Mutable References\n\nUse `&mut` to create a mutable reference:\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    add_world(&mut s);  // Borrow mutably\n\n    println!(\"{}\", s);  // âœ… Prints \"hello world\"\n}\n\nfn add_world(text: &mut String) {\n    text.push_str(\" world\");  // âœ… Can modify!\n}\n```\n\n**Perfect!** The function can modify the String, and we still own it afterward.\n\n## Mutable Reference Syntax\n\n**Creating a mutable reference: `&mut`**\n```rust\nlet mut s = String::from(\"hello\");\nlet r = &mut s;  // r is a mutable reference to s\n```\n\n**Accepting a mutable reference in a function: `&mut Type`**\n```rust\nfn modify_string(text: &mut String) {\n    text.push_str(\" more\");\n}\n```\n\n**Important**: The original variable MUST be `mut`!\n\n```rust\nlet s = String::from(\"hello\");  // âŒ Not mutable\nlet r = &mut s;  // ERROR: can't borrow immutable variable as mutable\n```\n\n```rust\nlet mut s = String::from(\"hello\");  // âœ… Mutable\nlet r = &mut s;  // OK\n```\n\n## The Mutable Reference Rules\n\nThese are STRICT rules enforced by the compiler:\n\n### **Rule 1: Only ONE mutable reference at a time**\n\n```rust\nlet mut s = String::from(\"hello\");\n\nlet r1 = &mut s;\nlet r2 = &mut s;  // âŒ ERROR! Second mutable reference\n\nprintln!(\"{}, {}\", r1, r2);\n```\n\n**Why?** If two parts of code could modify the same data simultaneously, it would cause a **data race**.\n\n**Fix**: Use them in separate scopes\n\n```rust\nlet mut s = String::from(\"hello\");\n\n{\n    let r1 = &mut s;\n    r1.push_str(\" world\");\n}  // r1 goes out of scope\n\nlet r2 = &mut s;  // âœ… OK: r1 is gone\nr2.push_str(\"!\");\n```\n\n### **Rule 2: No mutable reference while immutable references exist**\n\n```rust\nlet mut s = String::from(\"hello\");\n\nlet r1 = &s;      // Immutable borrow\nlet r2 = &s;      // Another immutable borrow (OK)\nlet r3 = &mut s;  // âŒ ERROR! Can't have mutable while immutable exist\n\nprintln!(\"{}, {}, {}\", r1, r2, r3);\n```\n\n**Why?** Imagine reading a document while someone is editing itâ€”you might see inconsistent data!\n\n**Fix**: Stop using immutable references before creating a mutable one\n\n```rust\nlet mut s = String::from(\"hello\");\n\nlet r1 = &s;\nlet r2 = &s;\nprintln!(\"{}, {}\", r1, r2);  // Last use of r1 and r2\n\nlet r3 = &mut s;  // âœ… OK: r1 and r2 no longer used\nr3.push_str(\" world\");\nprintln!(\"{}\", r3);\n```\n\n### **Rule 3: Original variable can't be used while mutably borrowed**\n\n```rust\nlet mut s = String::from(\"hello\");\n\nlet r = &mut s;\ns.push_str(\" world\");  // âŒ ERROR! s is borrowed\nprintln!(\"{}\", r);\n```\n\n**Why?** The borrow `r` would become invalid if `s` changed!\n\n## Non-Lexical Lifetimes (NLL)\n\nModern Rust is smart about when borrows end:\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    let r1 = &s;\n    let r2 = &s;\n    println!(\"{}, {}\", r1, r2);  // r1 and r2 last used here\n\n    let r3 = &mut s;  // âœ… OK! r1 and r2 are no longer active\n    r3.push_str(\" world\");\n}\n```\n\nThe borrow ends at the **last use**, not at the end of the scope!\n\n## Modifying Through Mutable References\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    modify(&mut s);\n\n    println!(\"{}\", s);  // Prints \"hello world!\"\n}\n\nfn modify(text: &mut String) {\n    text.push_str(\" world\");\n    text.push('!');\n}\n```\n\n## Returning Mutable References\n\nYou can return mutable references, but be careful:\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    let r = get_mut_ref(&mut s);\n    r.push_str(\" world\");\n\n    println!(\"{}\", s);\n}\n\nfn get_mut_ref(text: &mut String) -> &mut String {\n    text  // Return the mutable reference\n}\n```\n\n##Mutable References to Vectors\n\nA common pattern:\n\n```rust\nfn main() {\n    let mut numbers = vec![1, 2, 3];\n\n    add_numbers(&mut numbers);\n\n    println!(\"{:?}\", numbers);  // [1, 2, 3, 4, 5]\n}\n\nfn add_numbers(nums: &mut Vec<i32>) {\n    nums.push(4);\n    nums.push(5);\n}\n```\n\n## Dereferencing Mutable References\n\nSometimes you need to use `*` to modify the actual value:\n\n```rust\nfn main() {\n    let mut x = 5;\n\n    add_one(&mut x);\n\n    println!(\"{}\", x);  // 6\n}\n\nfn add_one(num: &mut i32) {\n    *num += 1;  // Dereference to modify the value\n}\n```\n\nFor types like `String` and `Vec`, you don't need `*` for method calls:\n\n```rust\nfn modify(text: &mut String) {\n    text.push_str(\" world\");  // No * needed\n}\n```\n\n## Common Patterns\n\n### **Pattern 1: Modify-in-place**\n\n```rust\nfn main() {\n    let mut name = String::from(\"alice\");\n\n    capitalize(&mut name);\n\n    println!(\"{}\", name);  // \"Alice\"\n}\n\nfn capitalize(s: &mut String) {\n    if let Some(first) = s.get_mut(0..1) {\n        first.make_ascii_uppercase();\n    }\n}\n```\n\n### **Pattern 2: Swap values**\n\n```rust\nfn main() {\n    let mut a = 5;\n    let mut b = 10;\n\n    swap(&mut a, &mut b);\n\n    println!(\"a: {}, b: {}\", a, b);  // a: 10, b: 5\n}\n\nfn swap(x: &mut i32, y: &mut i32) {\n    let temp = *x;\n    *x = *y;\n    *y = temp;\n}\n```\n\n### **Pattern 3: Modify collection elements**\n\n```rust\nfn main() {\n    let mut numbers = vec![1, 2, 3, 4, 5];\n\n    double_values(&mut numbers);\n\n    println!(\"{:?}\", numbers);  // [2, 4, 6, 8, 10]\n}\n\nfn double_values(nums: &mut Vec<i32>) {\n    for num in nums.iter_mut() {\n        *num *= 2;\n    }\n}\n```\n\n## Hands-On Practice\n\n### **Create a Practice Project**\n\n```bash\ncargo new mutable_borrowing\ncd mutable_borrowing\ncode .\n```\n\n### **Experiment 1: Basic Mutable Reference**\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    append_exclamation(&mut s);\n\n    println!(\"{}\", s);  // \"hello!\"\n}\n\nfn append_exclamation(text: &mut String) {\n    text.push('!');\n}\n```\n\n### **Experiment 2: Multiple Modifications**\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    append_word(&mut s, \"world\");\n    append_word(&mut s, \"Rust\");\n\n    println!(\"{}\", s);  // \"hello world Rust\"\n}\n\nfn append_word(text: &mut String, word: &str) {\n    text.push(' ');\n    text.push_str(word);\n}\n```\n\n### **Experiment 3: Cannot Have Two Mutable References**\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    let r1 = &mut s;\n    // let r2 = &mut s;  // âŒ Uncomment to see error\n\n    r1.push_str(\" world\");\n    println!(\"{}\", r1);\n}\n```\n\n### **Experiment 4: Mutable Reference Ends**\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    let r1 = &mut s;\n    r1.push_str(\" world\");\n    println!(\"{}\", r1);  // Last use of r1\n\n    let r2 = &mut s;  // âœ… OK: r1 no longer used\n    r2.push('!');\n    println!(\"{}\", r2);\n}\n```\n\n### **Challenge: String Manipulator**\n\nCreate functions that modify strings in place:\n\n```rust\nfn main() {\n    let mut text = String::from(\"hello rust\");\n\n    to_uppercase(&mut text);\n    println!(\"{}\", text);  // \"HELLO RUST\"\n\n    add_prefix(&mut text, \"Language: \");\n    println!(\"{}\", text);  // \"Language: HELLO RUST\"\n\n    reverse_words(&mut text);\n    println!(\"{}\", text);  // \"RUST HELLO :egaugnaL\"\n}\n\nfn to_uppercase(s: &mut String) {\n    *s = s.to_uppercase();\n}\n\nfn add_prefix(s: &mut String, prefix: &str) {\n    s.insert_str(0, prefix);\n}\n\nfn reverse_words(s: &mut String) {\n    let words: Vec<&str> = s.split_whitespace().collect();\n    let reversed: Vec<&str> = words.into_iter().rev().collect();\n    *s = reversed.join(\" \");\n}\n```\n\n## Comparison: Immutable vs. Mutable References\n\n| Feature | Immutable (`&T`) | Mutable (`&mut T`) |\n|---------|------------------|---------------------|\n| **Can read?** | âœ… Yes | âœ… Yes |\n| **Can modify?** | âŒ No | âœ… Yes |\n| **How many at once?** | âœ… Multiple | âš ï¸ Only ONE |\n| **Can coexist with immutable refs?** | âœ… Yes | âŒ No |\n| **Syntax** | `&` | `&mut` |\n\n## Key Takeaways\n\n- âœ… **Mutable references** allow modification without taking ownership\n- âœ… **Syntax**: `&mut` creates one, `&mut Type` accepts one\n- âœ… **Only ONE mutable reference** to data at a time\n- âœ… **No mutable reference** while immutable references exist\n- âœ… Original variable must be declared `mut`\n- âœ… Borrows end at **last use** (non-lexical lifetimes)\n- âœ… Use `*` to dereference when modifying primitive types\n- âœ… Prevents data races at compile time!\n\n## The Rules Summary\n\n```rust\nlet mut s = String::from(\"hello\");\n\n// âœ… Multiple immutable references OK\nlet r1 = &s;\nlet r2 = &s;\n\n// âœ… One mutable reference OK (when no immutable exist)\nlet r3 = &mut s;\n\n// âŒ Two mutable references NOT OK\nlet r4 = &mut s;  // ERROR if r3 still in use\n\n// âŒ Mixing immutable and mutable NOT OK\nlet r5 = &s;      // ERROR if r3 still in use\n```\n\n**Next**: Learn common **borrow checker errors** and how to fix them!\n"
          }
        },
        {
          "id": "lesson-04-06",
          "title": "Module 4, Lesson 6: Fighting the Borrow Checker â€” Common Borrowing Errors",
          "type": "exercise",
          "estimatedMinutes": 5,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 4, Lesson 6: Fighting the Borrow Checker â€” Common Borrowing Errors\n\n## The Concept: Learning from the Borrow Checker\n\nThe **borrow checker** is Rust's compile-time guardian that enforces ownership and borrowing rules. New Rustaceans often \"fight\" with it, but it's actually preventing bugs!\n\nThink of it like a strict but helpful grammar checker that catches mistakes before anyone sees your writing.\n\n## Error 1: Multiple Mutable References\n\n### **The Mistake**\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    let r1 = &mut s;\n    let r2 = &mut s;  // âŒ Second mutable reference\n\n    r1.push_str(\" world\");\n    r2.push('!');\n}\n```\n\n### **The Error**\n\n```\nerror[E0499]: cannot borrow `s` as mutable more than once at a time\n```\n\n### **The Fix**\n\nUse them in separate scopes:\n\n```rust\nlet mut s = String::from(\"hello\");\n\n{\n    let r1 = &mut s;\n    r1.push_str(\" world\");\n}  // r1 ends here\n\nlet r2 = &mut s;\nr2.push('!');\n```\n\n## Error 2: Mixing Immutable and Mutable References\n\n### **The Mistake**\n\n```rust\nlet mut s = String::from(\"hello\");\n\nlet r1 = &s;\nlet r2 = &mut s;  // âŒ Mutable while immutable exists\n\nprintln!(\"{}, {}\", r1, r2);\n```\n\n### **The Fix**\n\n```rust\nlet mut s = String::from(\"hello\");\n\nlet r1 = &s;\nprintln!(\"{}\", r1);  // Last use of r1\n\nlet r2 = &mut s;  // âœ… OK now\nr2.push_str(\" world\");\n```\n\n## Error 3: Dangling References\n\n### **The Mistake**\n\n```rust\nfn main() {\n    let r = dangle();\n}\n\nfn dangle() -> &String {  // âŒ Returns reference to local variable\n    let s = String::from(\"hello\");\n    &s  // s is dropped at end of function!\n}\n```\n\n### **The Fix**\n\nReturn ownership instead:\n\n```rust\nfn no_dangle() -> String {\n    let s = String::from(\"hello\");\n    s  // âœ… Return ownership\n}\n```\n\n## Error 4: Modifying While Borrowed\n\n### **The Mistake**\n\n```rust\nlet mut v = vec![1, 2, 3];\n\nlet first = &v[0];\nv.push(4);  // âŒ Modifying while borrowed\n\nprintln!(\"{}\", first);\n```\n\n### **The Fix**\n\n```rust\nlet mut v = vec![1, 2, 3];\n\nlet first = v[0];  // Copy the value\nv.push(4);  // âœ… OK\n\nprintln!(\"{}\", first);\n```\n\n## Hands-On Practice\n\n### **Exercise 1: Fix the Borrowing Error**\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    let r1 = &s;\n    let r2 = &s;\n    let r3 = &mut s;  // âŒ Fix this\n\n    println!(\"{}, {}, {}\", r1, r2, r3);\n}\n```\n\n<details>\n<summary>Solution</summary>\n\n```rust\nlet r1 = &s;\nlet r2 = &s;\nprintln!(\"{}, {}\", r1, r2);  // Use immutable refs\n\nlet r3 = &mut s;  // âœ… OK now\nprintln!(\"{}\", r3);\n```\n</details>\n\n### **Exercise 2: Fix the Double Mutable Borrow**\n\n```rust\nfn main() {\n    let mut numbers = vec![1, 2, 3];\n\n    let r1 = &mut numbers;\n    let r2 = &mut numbers;  // âŒ Fix this\n\n    r1.push(4);\n    r2.push(5);\n}\n```\n\n<details>\n<summary>Solution</summary>\n\n```rust\nlet mut numbers = vec![1, 2, 3];\n\n{\n    let r1 = &mut numbers;\n    r1.push(4);\n}  // r1 ends\n\nlet r2 = &mut numbers;\nr2.push(5);\n```\n</details>\n\n## Key Takeaways\n\n- âœ… Borrow checker errors are **preventing bugs**, not being difficult\n- âœ… Most errors solved by understanding reference lifetimes\n- âœ… Use scopes to limit borrow duration\n- âœ… End immutable borrows before creating mutable ones\n- âœ… Copy values if you need them after modification\n- âœ… Never return references to local variables\n- âœ… Trust the compilerâ€”it's usually right!\n\n**Next**: Understanding **lifetimes** - how long references are valid!\n"
          }
        },
        {
          "id": "lesson-04-07",
          "title": "Module 4, Lesson 7: How Long Can I Use This? â€” Understanding Lifetimes",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 4, Lesson 7: How Long Can I Use This? â€” Understanding Lifetimes\n\n## The Concept: Expiration Dates\n\nImagine borrowing a library book. The library gives you a due date:\n- You can use the book until that date\n- After the due date, your borrowing privilege expires\n- The library ensures the book doesn't disappear while you have it\n\n**Lifetimes** in Rust work the same way. They track how long a reference is valid.\n\n## What Are Lifetimes?\n\nA **lifetime** is the scope for which a reference is valid.\n\n**Good news**: Most of the time, Rust infers lifetimes automatically! You rarely need to write them explicitly.\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");  // s's lifetime starts\n\n    let r = &s;  // r's lifetime starts (borrows from s)\n\n    println!(\"{}\", r);  // Use r\n\n}  // r's lifetime ends, then s's lifetime ends\n```\n\nRust ensures `r` doesn't outlive `s`.\n\n## The Lifetime Problem\n\nWhat if a function returns a reference? Which input does it come from?\n\n```rust\nfn longest(x: &str, y: &str) -> &str {  // âŒ Which lifetime?\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n\nRust doesn't know if the returned reference is from `x` or `y`, so it doesn't know how long it's valid!\n\n## Lifetime Annotation Syntax\n\nWe use **lifetime parameters** to tell Rust about relationships:\n\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n\n**What this means:**\n- `'a` is a lifetime parameter (pronounced \"tick A\")\n- Both `x` and `y` live for at least lifetime `'a`\n- The returned reference will also live for `'a`\n- Rust enforces: returned reference won't outlive either input\n\n## Lifetime Annotations Don't Change Lifetimes\n\n**Important**: Lifetime annotations are **descriptive**, not prescriptive. They describe relationships but don't change how long things live.\n\nThink of them like type annotationsâ€”they document relationships for the compiler.\n\n## When Do You Need Lifetime Annotations?\n\n### **Case 1: Multiple References Returned**\n\n```rust\nfn first_word<'a>(s: &'a str) -> &'a str {\n    let bytes = s.as_bytes();\n\n    for (i, &byte) in bytes.iter().enumerate() {\n        if byte == b' ' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n```\n\n### **Case 2: Structs Holding References**\n\n```rust\nstruct Book<'a> {\n    title: &'a str,  // Book can't outlive this reference\n    author: &'a str,\n}\n\nfn main() {\n    let title = String::from(\"The Rust Book\");\n    let author = String::from(\"Steve Klabnik\");\n\n    let book = Book {\n        title: &title,\n        author: &author,\n    };\n\n    println!(\"{} by {}\", book.title, book.author);\n}  // book, author, and title all end together\n```\n\n## Lifetime Elision Rules\n\nRust has three rules for inferring lifetimes automatically:\n\n1. Each input reference gets its own lifetime\n2. If there's exactly one input lifetime, it's assigned to all outputs\n3. If there's a `&self` or `&mut self`, its lifetime is assigned to outputs\n\n**Most of the time, you don't need to write lifetimes!**\n\n## The Static Lifetime\n\n`'static` means \"lives for the entire program\":\n\n```rust\nlet s: &'static str = \"Hello, world!\";  // String literals are 'static\n```\n\n## Hands-On Practice\n\n### **Experiment 1: Lifetime Annotations**\n\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let string1 = String::from(\"long string\");\n    let string2 = String::from(\"short\");\n\n    let result = longest(string1.as_str(), string2.as_str());\n    println!(\"Longest: {}\", result);\n}\n```\n\n### **Experiment 2: Struct with Lifetimes**\n\n```rust\nstruct Article<'a> {\n    title: &'a str,\n    content: &'a str,\n}\n\nfn main() {\n    let title = String::from(\"Rust Lifetimes\");\n    let content = String::from(\"Lifetimes ensure references are valid.\");\n\n    let article = Article {\n        title: &title,\n        content: &content,\n    };\n\n    println!(\"{}: {}\", article.title, article.content);\n}\n```\n\n### **Challenge: Safe Reference Return**\n\nThis won't compile. Fix it with lifetime annotations:\n\n```rust\nfn get_first<'a>(items: &'a [&str]) -> &'a str {\n    items[0]\n}\n\nfn main() {\n    let words = vec![\"hello\", \"world\"];\n    let first = get_first(&words);\n    println!(\"{}\", first);\n}\n```\n\n## Key Takeaways\n\n- âœ… **Lifetimes** describe how long references are valid\n- âœ… Rust infers lifetimes most of the time (lifetime elision)\n- âœ… Syntax: `'a` (tick A), `'b`, `'static`\n- âœ… Used when compiler can't infer reference relationships\n- âœ… Lifetimes in structs ensure references don't outlive data\n- âœ… `'static` means \"lives for entire program\"\n- âœ… Lifetime annotations are **descriptive**, not prescriptive\n- âœ… Most Rust code doesn't need explicit lifetime annotations!\n\n## When You'll Use Lifetimes\n\n- Returning references from functions with multiple inputs\n- Structs that hold references\n- More advanced patterns\n\n**For now, understand the concept. You'll naturally learn when you need them through practice!**\n\n**Next**: Practice project synthesizing all ownership concepts!\n"
          }
        },
        {
          "id": "lesson-04-08",
          "title": "Module 4, Lesson 8: Practice Project â€” Building a Text Processor",
          "type": "project",
          "estimatedMinutes": 6,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 4, Lesson 8: Practice Project â€” Building a Text Processor\n\n## Project Overview\n\nBuild a text processor that demonstrates ownership, borrowing, and memory efficiency!\n\n**What we're building:**\n- Analyze text without unnecessary copying\n- Modify text in-place using mutable references\n- Return processed data efficiently\n- No memory leaks, no data races\n\n**Skills practiced:**\n- âœ… Ownership and moves\n- âœ… Immutable borrowing (reading without copying)\n- âœ… Mutable borrowing (modifying in-place)\n- âœ… Lifetimes (returning references)\n- âœ… Efficient memory usage\n\n## The Complete Project\n\n### **Step 1: Create the Project**\n\n```bash\ncargo new text_processor\ncd text_processor\ncode .\n```\n\n### **Step 2: Build the Processor (Complete Code)**\n\n```rust\n// Text statistics struct\nstruct TextStats {\n    char_count: usize,\n    word_count: usize,\n    line_count: usize,\n    unique_words: usize,\n}\n\n// Analyze text without taking ownership\nfn analyze_text(text: &str) -> TextStats {\n    let char_count = text.len();\n    let line_count = text.lines().count();\n    let word_count = text.split_whitespace().count();\n\n    // Count unique words (case-insensitive)\n    let mut unique_words = std::collections::HashSet::new();\n    for word in text.split_whitespace() {\n        unique_words.insert(word.to_lowercase());\n    }\n\n    TextStats {\n        char_count,\n        word_count,\n        line_count,\n        unique_words: unique_words.len(),\n    }\n}\n\n// Modify text in-place (mutable borrowing)\nfn remove_extra_spaces(text: &mut String) {\n    let words: Vec<&str> = text.split_whitespace().collect();\n    *text = words.join(\" \");\n}\n\n// Convert to title case in-place\nfn to_title_case(text: &mut String) {\n    let words: Vec<String> = text\n        .split_whitespace()\n        .map(|word| {\n            let mut chars = word.chars();\n            match chars.next() {\n                None => String::new(),\n                Some(first) => first.to_uppercase().chain(chars).collect(),\n            }\n        })\n        .collect();\n\n    *text = words.join(\" \");\n}\n\n// Find longest word (returns reference - lifetime!)\nfn find_longest_word(text: &str) -> Option<&str> {\n    text.split_whitespace()\n        .max_by_key(|word| word.len())\n}\n\n// Count occurrences of a word (case-insensitive)\nfn count_word(text: &str, target: &str) -> usize {\n    let target_lower = target.to_lowercase();\n\n    text.split_whitespace()\n        .filter(|word| word.to_lowercase() == target_lower)\n        .count()\n}\n\n// Replace all occurrences (mutable borrowing)\nfn replace_word(text: &mut String, from: &str, to: &str) {\n    *text = text.replace(from, to);\n}\n\nfn main() {\n    // Original text (we own this)\n    let mut text = String::from(\n        \"the quick brown fox jumps over the lazy dog. \\\n         The  dog  was  really  lazy.\"\n    );\n\n    println!(\"=== Original Text ===\");\n    println!(\"{}\\n\", text);\n\n    // Analyze (immutable borrow - no copying!)\n    println!(\"=== Analysis ===\");\n    let stats = analyze_text(&text);\n    println!(\"Characters: {}\", stats.char_count);\n    println!(\"Words: {}\", stats.word_count);\n    println!(\"Lines: {}\", stats.line_count);\n    println!(\"Unique words: {}\", stats.unique_words);\n\n    // Find longest word (returns reference - efficient!)\n    if let Some(longest) = find_longest_word(&text) {\n        println!(\"Longest word: {}\", longest);\n    }\n\n    // Count specific word\n    let dog_count = count_word(&text, \"dog\");\n    println!(\"'dog' appears {} times\\n\", dog_count);\n\n    // Modify in-place (mutable borrow)\n    println!(\"=== Cleaning Text ===\");\n    remove_extra_spaces(&mut text);\n    println!(\"{}\\n\", text);\n\n    println!(\"=== Title Case ===\");\n    to_title_case(&mut text);\n    println!(\"{}\\n\", text);\n\n    println!(\"=== Replace 'Dog' with 'Cat' ===\");\n    replace_word(&mut text, \"Dog\", \"Cat\");\n    println!(\"{}\\n\", text);\n\n    // Final analysis\n    println!(\"=== Final Analysis ===\");\n    let final_stats = analyze_text(&text);\n    println!(\"Characters: {}\", final_stats.char_count);\n    println!(\"Words: {}\", final_stats.word_count);\n    println!(\"Unique words: {}\", final_stats.unique_words);\n}\n```\n\n### **Step 3: Run the Project**\n\n```bash\ncargo run\n```\n\n**Expected output:**\n\n```\n=== Original Text ===\nthe quick brown fox jumps over the lazy dog. The  dog  was  really  lazy.\n\n=== Analysis ===\nCharacters: 75\nWords: 13\nLines: 1\nUnique words: 11\nLongest word: really\n'dog' appears 2 times\n\n=== Cleaning Text ===\nthe quick brown fox jumps over the lazy dog. The dog was really lazy.\n\n=== Title Case ===\nThe Quick Brown Fox Jumps Over The Lazy Dog. The Dog Was Really Lazy.\n\n=== Replace 'Dog' with 'Cat' ===\nThe Quick Brown Fox Jumps Over The Lazy Cat. The Cat Was Really Lazy.\n\n=== Final Analysis ===\nCharacters: 75\nWords: 13\nUnique words: 11\n```\n\n## Understanding the Code\n\n### **Immutable Borrowing (Analysis)**\n\n```rust\nfn analyze_text(text: &str) -> TextStats {\n    // Reads text without copying it\n    let char_count = text.len();\n    // ...\n}\n```\n\n**Why it matters**: No expensive string copying!\n\n### **Returning References (Lifetimes)**\n\n```rust\nfn find_longest_word(text: &str) -> Option<&str> {\n    // Returns reference to a word in the original text\n    text.split_whitespace().max_by_key(|word| word.len())\n}\n```\n\n**Why it matters**: No allocation - returns a \"slice\" into existing data!\n\n### **Mutable Borrowing (Modification)**\n\n```rust\nfn remove_extra_spaces(text: &mut String) {\n    // Modifies in-place\n    *text = words.join(\" \");\n}\n```\n\n**Why it matters**: Efficient modification without creating temporary copies!\n\n## Challenges and Extensions\n\n### **Challenge 1: Add More Analysis**\n\nAdd functions to calculate:\n- Average word length\n- Sentence count (count `.` characters)\n- Alphabetical first/last words\n\n### **Challenge 2: Word Frequency**\n\nCreate a function that returns the top 5 most frequent words:\n\n```rust\nuse std::collections::HashMap;\n\nfn top_words(text: &str, n: usize) -> Vec<(&str, usize)> {\n    let mut freq: HashMap<&str, usize> = HashMap::new();\n\n    for word in text.split_whitespace() {\n        *freq.entry(word).or_insert(0) += 1;\n    }\n\n    let mut pairs: Vec<_> = freq.iter().collect();\n    pairs.sort_by(|a, b| b.1.cmp(a.1));\n    pairs.into_iter().take(n).map(|(k, v)| (*k, *v)).collect()\n}\n```\n\n### **Challenge 3: Palindrome Detector**\n\n```rust\nfn is_palindrome(text: &str) -> bool {\n    let clean: String = text\n        .chars()\n        .filter(|c| c.is_alphanumeric())\n        .map(|c| c.to_ascii_lowercase())\n        .collect();\n\n    clean == clean.chars().rev().collect::<String>()\n}\n```\n\n### **Challenge 4: Add Sentence Manipulation**\n\n```rust\nfn reverse_sentences(text: &mut String) {\n    let sentences: Vec<&str> = text.split('.').collect();\n    let reversed: Vec<&str> = sentences.into_iter().rev().collect();\n    *text = reversed.join(\".\");\n}\n```\n\n## Memory Efficiency Comparison\n\n**BAD (copies everywhere):**\n\n```rust\nfn bad_analyze(text: String) -> String {  // Takes ownership\n    let modified = text.clone();  // Unnecessary clone\n    let result = modified.clone();  // Another clone\n    result  // Returns owned String\n}\n```\n\n**GOOD (borrows efficiently):**\n\n```rust\nfn good_analyze(text: &str) -> &str {  // Borrows\n    // Return reference into original string\n    &text[0..10]\n}\n```\n\n## Key Takeaways\n\n- âœ… Use `&str` for reading (no copies)\n- âœ… Use `&mut String` for in-place modification\n- âœ… Return references when possible (lifetimes)\n- âœ… Avoid `.clone()` unless necessary\n- âœ… Mutable borrows enable efficient updates\n- âœ… Immutable borrows enable safe concurrent reads\n- âœ… Ownership prevents memory leaks automatically\n\n---\n\n## âœ… Module 4 Complete!\n\nYou've mastered Rust's ownership system:\n- âœ… Stack vs. Heap\n- âœ… The three ownership rules\n- âœ… Common ownership errors\n- âœ… Immutable borrowing (`&T`)\n- âœ… Mutable borrowing (`&mut T`)\n- âœ… Borrow checker errors\n- âœ… Lifetimes (basics)\n- âœ… Built an efficient text processor!\n\n**This is THE hardest part of Rust. You did it!**\n\n**Next: Module 5 â€” Collections (String, Vec, HashMap)**\n"
          }
        }
      ]
    },
    {
      "id": "module-05",
      "title": "MODULE 05",
      "description": "Module 5",
      "difficulty": "intermediate",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-05-01",
          "title": "Module 5, Lesson 1: Text You Own vs. Text You Borrow â€” `String` vs `&str`",
          "type": "exercise",
          "estimatedMinutes": 5,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 5, Lesson 1: Text You Own vs. Text You Borrow â€” `String` vs `&str`\n\n## The Concept: Owned Book vs. Page Reference\n\nImagine two ways to have text:\n- **Owning a book**: You can add pages, remove pages, modify it (like `String`)\n- **Pointing to a page**: You can read it but not modify the book (like `&str`)\n\n## What is String?\n\n`String` is an **owned**, **growable**, **UTF-8** text stored on the heap.\n\n```rust\nlet mut s = String::from(\"hello\");\ns.push_str(\" world\");  // Can grow!\nprintln!(\"{}\", s);  // \"hello world\"\n```\n\n**Characteristics:**\n- Owned (you can modify it)\n- Stored on heap\n- Can grow and shrink\n- Automatically freed when owner goes out of scope\n\n## What is &str?\n\n`&str` (string slice) is a **view** into string data.\n\n```rust\nlet s = \"hello\";  // &str (string literal)\nlet s2 = &String::from(\"world\")[..];  // &str (slice of String)\n```\n\n**Characteristics:**\n- Borrowed (read-only)\n- Fixed size\n- Can point to String, string literal, or part of a string\n- Lightweight (just a pointer + length)\n\n## Creating Strings\n\n```rust\n// String literals are &str\nlet s1 = \"hello\";  // Type: &str\n\n// Create owned String\nlet s2 = String::from(\"hello\");  // Type: String\nlet s3 = \"hello\".to_string();    // Type: String\n\n// From format! macro\nlet s4 = format!(\"Number: {}\", 42);  // Type: String\n```\n\n## String Methods\n\n```rust\nlet mut s = String::from(\"hello\");\n\n// Append\ns.push_str(\" world\");  // Add &str\ns.push('!');           // Add char\n\n// Modify\ns = s.replace(\"world\", \"Rust\");\n\n// Capacity management\ns.reserve(10);  // Reserve space\ns.shrink_to_fit();  // Free unused space\n\nprintln!(\"{}\", s);  // \"hello Rust!\"\n```\n\n## String Slices (&str)\n\n```rust\nlet s = String::from(\"hello world\");\n\nlet hello = &s[0..5];    // \"hello\"\nlet world = &s[6..11];   // \"world\"\nlet all = &s[..];        // \"hello world\"\n\nprintln!(\"{}, {}\", hello, world);\n```\n\n## When to Use Each\n\n**Use `String` when:**\n- You need to own the text\n- Text will grow or shrink\n- Building strings dynamically\n- Storing in structs\n\n**Use `&str` when:**\n- Reading/viewing text\n- Function parameters (most flexible)\n- String literals\n- Efficiency (no allocation)\n\n## Function Parameters: Prefer &str\n\n```rust\n// âœ… Good: Accepts both String and &str\nfn print_text(s: &str) {\n    println!(\"{}\", s);\n}\n\nfn main() {\n    let owned = String::from(\"hello\");\n    let borrowed = \"world\";\n\n    print_text(&owned);     // Works\n    print_text(borrowed);   // Works\n}\n```\n\n```rust\n// âŒ Less flexible: Only accepts String\nfn print_text_owned(s: String) {\n    println!(\"{}\", s);\n}\n\nfn main() {\n    let s = \"hello\";\n    print_text_owned(s.to_string());  // Must convert\n}\n```\n\n## Concatenation\n\n```rust\n// Method 1: + operator (takes ownership)\nlet s1 = String::from(\"Hello\");\nlet s2 = String::from(\" world\");\nlet s3 = s1 + &s2;  // s1 is moved\n// println!(\"{}\", s1);  // âŒ Error\n\n// Method 2: format! macro (doesn't take ownership)\nlet s1 = String::from(\"Hello\");\nlet s2 = String::from(\" world\");\nlet s3 = format!(\"{}{}\", s1, s2);\nprintln!(\"{}, {}, {}\", s1, s2, s3);  // âœ… All still valid\n\n// Method 3: push_str (mutable)\nlet mut s = String::from(\"Hello\");\ns.push_str(\" world\");\n```\n\n## Hands-On Practice\n\n```bash\ncargo new string_practice\ncd string_practice\ncode .\n```\n\n### **Experiment 1: Creating Strings**\n\n```rust\nfn main() {\n    let literal = \"Hello\";  // &str\n    let owned = String::from(\"World\");  // String\n\n    println!(\"{}, {}\", literal, owned);\n}\n```\n\n### **Experiment 2: Growing Strings**\n\n```rust\nfn main() {\n    let mut s = String::new();\n\n    s.push_str(\"Hello\");\n    s.push(' ');\n    s.push_str(\"Rust\");\n\n    println!(\"{}\", s);  // \"Hello Rust\"\n}\n```\n\n### **Experiment 3: String Slices**\n\n```rust\nfn main() {\n    let s = String::from(\"Hello, world!\");\n\n    let hello = &s[0..5];\n    let world = &s[7..12];\n\n    println!(\"{}, {}\", hello, world);\n}\n```\n\n### **Challenge: String Builder**\n\n```rust\nfn build_sentence(words: Vec<&str>) -> String {\n    words.join(\" \")\n}\n\nfn main() {\n    let words = vec![\"Rust\", \"is\", \"awesome\"];\n    let sentence = build_sentence(words);\n\n    println!(\"{}\", sentence);\n}\n```\n\n## Key Takeaways\n\n- âœ… `String` = owned, growable, heap-allocated\n- âœ… `&str` = borrowed view, fixed size, efficient\n- âœ… String literals are `&str`\n- âœ… Prefer `&str` for function parameters\n- âœ… Use `.to_string()` or `String::from()` to convert\n- âœ… Slicing creates `&str` from `String`\n- âœ… `format!` doesn't take ownership\n- âœ… `+` operator takes ownership of left operand\n"
          }
        },
        {
          "id": "lesson-05-02",
          "title": "Module 5, Lesson 2: Growing Lists â€” Vectors (`Vec<T>`)",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 5, Lesson 2: Growing Lists â€” Vectors (`Vec<T>`)\n\n## The Concept: Expandable Array\n\nImagine a bookshelf:\n- Fixed array: Shelf with exactly 5 slots (can't add more)\n- Vector: Shelf that can add more slots as needed\n\n**Vectors** are growable, heap-allocated lists.\n\n## Creating Vectors\n\n```rust\n// Empty vector\nlet v: Vec<i32> = Vec::new();\n\n// With initial values (using vec! macro)\nlet v = vec![1, 2, 3, 4, 5];\n\n// With capacity (pre-allocate space)\nlet v: Vec<i32> = Vec::with_capacity(10);\n```\n\n## Adding Elements\n\n```rust\nlet mut v = Vec::new();\n\nv.push(1);  // Add to end\nv.push(2);\nv.push(3);\n\nprintln!(\"{:?}\", v);  // [1, 2, 3]\n```\n\n## Accessing Elements\n\n```rust\nlet v = vec![1, 2, 3, 4, 5];\n\n// Method 1: Indexing (panics if out of bounds)\nlet third = v[2];\nprintln!(\"Third element: {}\", third);\n\n// Method 2: get() - returns Option (safe)\nmatch v.get(2) {\n    Some(third) => println!(\"Third: {}\", third),\n    None => println!(\"No third element\"),\n}\n\nmatch v.get(10) {\n    Some(val) => println!(\"Value: {}\", val),\n    None => println!(\"Index out of bounds\"),  // This prints\n}\n```\n\n## Modifying Elements\n\n```rust\nlet mut v = vec![1, 2, 3];\n\nv[0] = 10;  // Change first element\n\nprintln!(\"{:?}\", v);  // [10, 2, 3]\n```\n\n## Removing Elements\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nlet last = v.pop();  // Remove and return last\nprintln!(\"Popped: {:?}\", last);  // Some(5)\n\nv.remove(1);  // Remove at index 1 (shifts elements)\nprintln!(\"{:?}\", v);  // [1, 3, 4]\n```\n\n## Iterating Over Vectors\n\n```rust\nlet v = vec![1, 2, 3, 4, 5];\n\n// Immutable iteration\nfor num in &v {\n    println!(\"{}\", num);\n}\n\n// Mutable iteration\nlet mut v = vec![1, 2, 3];\nfor num in &mut v {\n    *num *= 2;\n}\nprintln!(\"{:?}\", v);  // [2, 4, 6]\n\n// Taking ownership\nfor num in v {\n    println!(\"{}\", num);\n}\n// v is no longer valid here\n```\n\n## Vector Methods\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\n// Length\nprintln!(\"Length: {}\", v.len());\n\n// Is empty?\nprintln!(\"Empty: {}\", v.is_empty());\n\n// Contains?\nprintln!(\"Contains 3: {}\", v.contains(&3));\n\n// Clear all elements\nv.clear();\n\n// Capacity (allocated space)\nlet mut v = Vec::with_capacity(10);\nv.push(1);\nprintln!(\"Len: {}, Capacity: {}\", v.len(), v.capacity());\n```\n\n## Vectors of Different Types\n\n```rust\n// Vector of Strings\nlet mut names = vec![\n    String::from(\"Alice\"),\n    String::from(\"Bob\"),\n];\nnames.push(String::from(\"Charlie\"));\n\n// Vector of structs\nstruct Person {\n    name: String,\n    age: u32,\n}\n\nlet people = vec![\n    Person { name: String::from(\"Alice\"), age: 30 },\n    Person { name: String::from(\"Bob\"), age: 25 },\n];\n\n// Vector of enums (store multiple types)\nenum Value {\n    Integer(i32),\n    Float(f64),\n    Text(String),\n}\n\nlet values = vec![\n    Value::Integer(42),\n    Value::Float(3.14),\n    Value::Text(String::from(\"hello\")),\n];\n```\n\n## Hands-On Practice\n\n```bash\ncargo new vector_practice\ncd vector_practice\ncode .\n```\n\n### **Experiment 1: Basic Operations**\n\n```rust\nfn main() {\n    let mut numbers = vec![1, 2, 3];\n\n    numbers.push(4);\n    numbers.push(5);\n\n    println!(\"{:?}\", numbers);\n\n    if let Some(last) = numbers.pop() {\n        println!(\"Popped: {}\", last);\n    }\n\n    println!(\"{:?}\", numbers);\n}\n```\n\n### **Experiment 2: Safe Access**\n\n```rust\nfn main() {\n    let v = vec![10, 20, 30];\n\n    // Safe access\n    match v.get(5) {\n        Some(val) => println!(\"Value: {}\", val),\n        None => println!(\"Index out of bounds\"),\n    }\n\n    // This would panic:\n    // let val = v[5];\n}\n```\n\n### **Experiment 3: Filtering**\n\n```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n    let evens: Vec<i32> = numbers\n        .iter()\n        .filter(|&&n| n % 2 == 0)\n        .copied()\n        .collect();\n\n    println!(\"Evens: {:?}\", evens);\n}\n```\n\n### **Challenge: Todo List**\n\n```rust\nfn main() {\n    let mut todos: Vec<String> = Vec::new();\n\n    // Add tasks\n    todos.push(String::from(\"Learn Rust\"));\n    todos.push(String::from(\"Build a project\"));\n    todos.push(String::from(\"Contribute to open source\"));\n\n    // Display tasks\n    println!(\"=== Todo List ===\");\n    for (i, task) in todos.iter().enumerate() {\n        println!(\"{}. {}\", i + 1, task);\n    }\n\n    // Complete first task\n    if !todos.is_empty() {\n        let completed = todos.remove(0);\n        println!(\"\\nâœ… Completed: {}\", completed);\n    }\n\n    // Display remaining\n    println!(\"\\n=== Remaining Tasks ===\");\n    for (i, task) in todos.iter().enumerate() {\n        println!(\"{}. {}\", i + 1, task);\n    }\n}\n```\n\n## Key Takeaways\n\n- âœ… `Vec<T>` is a growable, heap-allocated list\n- âœ… Create with `Vec::new()` or `vec![]` macro\n- âœ… `.push()` adds to end, `.pop()` removes from end\n- âœ… Index with `[]` (panics) or `.get()` (safe)\n- âœ… Iterate with `for x in &v` (immutable) or `&mut v` (mutable)\n- âœ… `.len()` for length, `.is_empty()` to check empty\n- âœ… Vectors can store any type (including structs and enums)\n- âœ… Use enums to store multiple types in one vector\n"
          }
        },
        {
          "id": "lesson-05-03",
          "title": "Module 5, Lesson 3: Looking Things Up by Name â€” Hash Maps (`HashMap<K, V>`)",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 5, Lesson 3: Looking Things Up by Name â€” Hash Maps (`HashMap<K, V>`)\n\n## The Concept: Dictionary or Phone Book\n\nImagine a phone book:\n- **Key**: Person's name\n- **Value**: Phone number\n- Look up phone number by name (fast!)\n\n**Hash Maps** store key-value pairs for fast lookups.\n\n## Creating Hash Maps\n\n```rust\nuse std::collections::HashMap;\n\n// Empty HashMap\nlet mut scores = HashMap::new();\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Red\"), 50);\n\n// From vectors\nlet teams = vec![String::from(\"Blue\"), String::from(\"Red\")];\nlet initial_scores = vec![10, 50];\n\nlet scores: HashMap<_, _> = teams\n    .iter()\n    .zip(initial_scores.iter())\n    .collect();\n```\n\n## Basic Operations\n\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\n// Insert\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Red\"), 50);\n\n// Get value (returns Option)\nmatch scores.get(\"Blue\") {\n    Some(score) => println!(\"Blue: {}\", score),\n    None => println!(\"No score for Blue\"),\n}\n\n// Check if key exists\nif scores.contains_key(\"Blue\") {\n    println!(\"Blue team exists\");\n}\n\n// Remove\nscores.remove(\"Red\");\n```\n\n## Updating Values\n\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\n// Overwrite\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Blue\"), 25);  // Overwrites 10\n\n// Only insert if key doesn't exist\nscores.entry(String::from(\"Red\")).or_insert(50);\nscores.entry(String::from(\"Red\")).or_insert(100);  // Doesn't change (still 50)\n\n// Update based on old value\nlet text = \"hello world wonderful world\";\nlet mut word_count = HashMap::new();\n\nfor word in text.split_whitespace() {\n    let count = word_count.entry(word).or_insert(0);\n    *count += 1;  // Increment count\n}\n\nprintln!(\"{:?}\", word_count);\n// {\"hello\": 1, \"world\": 2, \"wonderful\": 1}\n```\n\n## Iterating\n\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Red\"), 50);\n\n// Iterate over key-value pairs\nfor (key, value) in &scores {\n    println!(\"{}: {}\", key, value);\n}\n\n// Iterate over keys\nfor key in scores.keys() {\n    println!(\"Key: {}\", key);\n}\n\n// Iterate over values\nfor value in scores.values() {\n    println!(\"Value: {}\", value);\n}\n```\n\n## Ownership\n\n```rust\nuse std::collections::HashMap;\n\nlet field_name = String::from(\"Favorite color\");\nlet field_value = String::from(\"Blue\");\n\nlet mut map = HashMap::new();\nmap.insert(field_name, field_value);\n\n// field_name and field_value are moved!\n// println!(\"{}\", field_name);  // âŒ Error\n\n// For types that implement Copy (like i32), values are copied\nlet mut map = HashMap::new();\nlet x = 5;\nmap.insert(\"number\", x);\nprintln!(\"{}\", x);  // âœ… OK (i32 implements Copy)\n```\n\n## Common Patterns\n\n### **Counting Occurrences**\n\n```rust\nuse std::collections::HashMap;\n\nfn count_words(text: &str) -> HashMap<&str, usize> {\n    let mut counts = HashMap::new();\n\n    for word in text.split_whitespace() {\n        *counts.entry(word).or_insert(0) += 1;\n    }\n\n    counts\n}\n\nfn main() {\n    let text = \"the quick brown fox jumps over the lazy dog the fox\";\n    let counts = count_words(text);\n\n    for (word, count) in counts {\n        println!(\"{}: {}\", word, count);\n    }\n}\n```\n\n### **Grouping by Category**\n\n```rust\nuse std::collections::HashMap;\n\nstruct Person {\n    name: String,\n    age: u32,\n}\n\nfn group_by_age(people: Vec<Person>) -> HashMap<u32, Vec<String>> {\n    let mut groups = HashMap::new();\n\n    for person in people {\n        groups\n            .entry(person.age)\n            .or_insert(Vec::new())\n            .push(person.name);\n    }\n\n    groups\n}\n```\n\n### **Caching/Memoization**\n\n```rust\nuse std::collections::HashMap;\n\nfn expensive_calculation(n: i32) -> i32 {\n    println!(\"Calculating for {}...\", n);\n    n * 2  // Simulate expensive operation\n}\n\nfn main() {\n    let mut cache: HashMap<i32, i32> = HashMap::new();\n\n    for &num in &[1, 2, 1, 3, 2, 1] {\n        let result = cache\n            .entry(num)\n            .or_insert_with(|| expensive_calculation(num));\n\n        println!(\"Result for {}: {}\", num, result);\n    }\n}\n```\n\n## Hands-On Practice\n\n```bash\ncargo new hashmap_practice\ncd hashmap_practice\ncode .\n```\n\n### **Experiment 1: Basic HashMap**\n\n```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut ages = HashMap::new();\n\n    ages.insert(\"Alice\", 30);\n    ages.insert(\"Bob\", 25);\n    ages.insert(\"Charlie\", 35);\n\n    if let Some(age) = ages.get(\"Alice\") {\n        println!(\"Alice is {} years old\", age);\n    }\n}\n```\n\n### **Experiment 2: Word Frequency**\n\n```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let text = \"hello world hello rust world hello\";\n    let mut freq = HashMap::new();\n\n    for word in text.split_whitespace() {\n        *freq.entry(word).or_insert(0) += 1;\n    }\n\n    for (word, count) in freq {\n        println!(\"{}: {}\", word, count);\n    }\n}\n```\n\n### **Challenge: Grade Book**\n\n```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut grades: HashMap<String, Vec<i32>> = HashMap::new();\n\n    // Add grades\n    grades\n        .entry(String::from(\"Alice\"))\n        .or_insert(Vec::new())\n        .push(95);\n\n    grades\n        .entry(String::from(\"Alice\"))\n        .or_insert(Vec::new())\n        .push(88);\n\n    grades\n        .entry(String::from(\"Bob\"))\n        .or_insert(Vec::new())\n        .extend(vec![78, 85, 92]);\n\n    // Calculate averages\n    for (name, scores) in &grades {\n        let sum: i32 = scores.iter().sum();\n        let avg = sum as f64 / scores.len() as f64;\n\n        println!(\"{}: {:?} (avg: {:.2})\", name, scores, avg);\n    }\n}\n```\n\n## Key Takeaways\n\n- âœ… `HashMap<K, V>` stores key-value pairs\n- âœ… Import with `use std::collections::HashMap;`\n- âœ… `.insert(key, value)` adds/updates\n- âœ… `.get(key)` returns `Option<&V>`\n- âœ… `.entry(key).or_insert(default)` for conditional insert\n- âœ… Keys must implement `Eq` and `Hash`\n- âœ… Owned types are moved into HashMap\n- âœ… Fast lookups (O(1) average)\n- âœ… Great for counting, caching, grouping\n\n**Next**: Practice project bringing together all collections!\n"
          }
        },
        {
          "id": "lesson-05-04",
          "title": "Module 5, Lesson 4: Practice Project â€” Building a Word Counter",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 5, Lesson 4: Practice Project â€” Building a Word Counter\n\n## Project Overview\n\nBuild a word frequency analyzer that demonstrates all three collection types!\n\n**What we're building:**\n- Analyze text from multiple sources\n- Count word frequencies\n- Find most/least common words\n- Display statistics\n\n**Skills practiced:**\n- âœ… String manipulation\n- âœ… Vector operations\n- âœ… HashMap for counting\n- âœ… All collection types working together\n\n## The Complete Project\n\n### **Step 1: Create the Project**\n\n```bash\ncargo new word_counter\ncd word_counter\ncode .\n```\n\n### **Step 2: Build the Counter (Complete Code)**\n\n```rust\nuse std::collections::HashMap;\n\n// Analyze text and return word frequencies\nfn count_words(text: &str) -> HashMap<String, usize> {\n    let mut counts = HashMap::new();\n\n    for word in text.split_whitespace() {\n        let word = word\n            .chars()\n            .filter(|c| c.is_alphanumeric())\n            .collect::<String>()\n            .to_lowercase();\n\n        if !word.is_empty() {\n            *counts.entry(word).or_insert(0) += 1;\n        }\n    }\n\n    counts\n}\n\n// Find most common words\nfn top_words(counts: &HashMap<String, usize>, n: usize) -> Vec<(&String, &usize)> {\n    let mut pairs: Vec<_> = counts.iter().collect();\n    pairs.sort_by(|a, b| b.1.cmp(a.1));  // Sort by count (descending)\n    pairs.into_iter().take(n).collect()\n}\n\n// Find least common words\nfn least_common_words(counts: &HashMap<String, usize>, n: usize) -> Vec<(&String, &usize)> {\n    let mut pairs: Vec<_> = counts.iter().collect();\n    pairs.sort_by(|a, b| a.1.cmp(b.1));  // Sort by count (ascending)\n    pairs.into_iter().take(n).collect()\n}\n\n// Calculate statistics\nfn calculate_stats(counts: &HashMap<String, usize>) -> Stats {\n    let total_words: usize = counts.values().sum();\n    let unique_words = counts.len();\n\n    let average_frequency = if unique_words > 0 {\n        total_words as f64 / unique_words as f64\n    } else {\n        0.0\n    };\n\n    Stats {\n        total_words,\n        unique_words,\n        average_frequency,\n    }\n}\n\nstruct Stats {\n    total_words: usize,\n    unique_words: usize,\n    average_frequency: f64,\n}\n\n// Find words that appear exactly n times\nfn words_with_count(counts: &HashMap<String, usize>, target: usize) -> Vec<String> {\n    counts\n        .iter()\n        .filter(|(_, &count)| count == target)\n        .map(|(word, _)| word.clone())\n        .collect()\n}\n\nfn main() {\n    let text = \"The quick brown fox jumps over the lazy dog. \\\n                The dog was really lazy, and the fox was quick. \\\n                The lazy dog slept while the quick fox ran.\";\n\n    println!(\"=== Text Analysis ===\\n\");\n    println!(\"Text: {}\\n\", text);\n\n    // Count words\n    let counts = count_words(text);\n\n    // Display statistics\n    let stats = calculate_stats(&counts);\n    println!(\"=== Statistics ===\");\n    println!(\"Total words: {}\", stats.total_words);\n    println!(\"Unique words: {}\", stats.unique_words);\n    println!(\"Average frequency: {:.2}\\n\", stats.average_frequency);\n\n    // Top 5 most common words\n    println!(\"=== Top 5 Most Common Words ===\");\n    for (word, count) in top_words(&counts, 5) {\n        println!(\"{}: {} times\", word, count);\n    }\n\n    // Least common words\n    println!(\"\\n=== Least Common Words ===\");\n    for (word, count) in least_common_words(&counts, 5) {\n        println!(\"{}: {} times\", word, count);\n    }\n\n    // Words that appear exactly once\n    println!(\"\\n=== Words Appearing Once ===\");\n    let once = words_with_count(&counts, 1);\n    println!(\"{:?}\", once);\n\n    // All words alphabetically\n    println!(\"\\n=== All Words (Alphabetical) ===\");\n    let mut words: Vec<_> = counts.keys().collect();\n    words.sort();\n    for word in words {\n        println!(\"{}: {}\", word, counts.get(word).unwrap());\n    }\n}\n```\n\n### **Step 3: Run the Project**\n\n```bash\ncargo run\n```\n\n**Expected output:**\n\n```\n=== Text Analysis ===\n\nText: The quick brown fox jumps over the lazy dog. The dog was really lazy...\n\n=== Statistics ===\nTotal words: 25\nUnique words: 11\nAverage frequency: 2.27\n\n=== Top 5 Most Common Words ===\nthe: 5 times\nlazy: 3 times\nquick: 3 times\nfox: 3 times\ndog: 3 times\n\n=== Least Common Words ===\nover: 1 times\njumps: 1 times\nbrown: 1 times\nslept: 1 times\nwhile: 1 times\n\n=== Words Appearing Once ===\n[\"over\", \"jumps\", \"brown\", \"slept\", \"while\", \"really\", \"ran\", \"was\"]\n\n=== All Words (Alphabetical) ===\nbrown: 1\ndog: 3\nfox: 3\n...\n```\n\n## Understanding the Code\n\n### **String Processing**\n\n```rust\nlet word = word\n    .chars()\n    .filter(|c| c.is_alphanumeric())  // Remove punctuation\n    .collect::<String>()\n    .to_lowercase();  // Normalize case\n```\n\n### **HashMap for Counting**\n\n```rust\n*counts.entry(word).or_insert(0) += 1;\n```\n\n### **Vector for Sorting**\n\n```rust\nlet mut pairs: Vec<_> = counts.iter().collect();\npairs.sort_by(|a, b| b.1.cmp(a.1));  // Sort by count\n```\n\n## Challenges and Extensions\n\n### **Challenge 1: Read from File**\n\n```rust\nuse std::fs;\n\nfn main() {\n    let text = fs::read_to_string(\"input.txt\")\n        .expect(\"Failed to read file\");\n\n    let counts = count_words(&text);\n    // ... rest of code\n}\n```\n\n### **Challenge 2: Filter Common Words**\n\n```rust\nfn filter_common_words(\n    counts: &HashMap<String, usize>,\n    stop_words: &[&str],\n) -> HashMap<String, usize> {\n    counts\n        .iter()\n        .filter(|(word, _)| !stop_words.contains(&word.as_str()))\n        .map(|(k, v)| (k.clone(), *v))\n        .collect()\n}\n\nfn main() {\n    let stop_words = vec![\"the\", \"a\", \"an\", \"and\", \"or\", \"but\"];\n    let filtered = filter_common_words(&counts, &stop_words);\n}\n```\n\n### **Challenge 3: Word Length Analysis**\n\n```rust\nfn average_word_length(counts: &HashMap<String, usize>) -> f64 {\n    let total_length: usize = counts\n        .keys()\n        .map(|word| word.len())\n        .sum();\n\n    total_length as f64 / counts.len() as f64\n}\n\nfn words_longer_than(counts: &HashMap<String, usize>, min_len: usize) -> Vec<String> {\n    counts\n        .keys()\n        .filter(|word| word.len() > min_len)\n        .cloned()\n        .collect()\n}\n```\n\n### **Challenge 4: Save Results to File**\n\n```rust\nuse std::fs::File;\nuse std::io::Write;\n\nfn save_results(counts: &HashMap<String, usize>, filename: &str) -> std::io::Result<()> {\n    let mut file = File::create(filename)?;\n\n    let mut pairs: Vec<_> = counts.iter().collect();\n    pairs.sort_by(|a, b| b.1.cmp(a.1));\n\n    for (word, count) in pairs {\n        writeln!(file, \"{},{}\", word, count)?;\n    }\n\n    Ok(())\n}\n```\n\n## Key Takeaways\n\n- âœ… Strings for text processing\n- âœ… HashMaps for counting frequencies\n- âœ… Vectors for sorting results\n- âœ… All three collections working together\n- âœ… Iterator methods for filtering and mapping\n- âœ… Real-world text analysis application\n- âœ… Efficient data processing without unnecessary copying\n\n---\n\n## âœ… Module 5 Complete!\n\nYou've mastered Rust collections:\n- âœ… String vs &str (owned vs borrowed text)\n- âœ… Vec<T> (growable lists)\n- âœ… HashMap<K, V> (key-value storage)\n- âœ… Built a complete word frequency analyzer!\n\n**Next: Module 6 â€” Advanced Error Handling**\n\nTotal Progress: 33 lessons complete (~55%)\n"
          }
        }
      ]
    },
    {
      "id": "module-06",
      "title": "MODULE 06",
      "description": "Module 6",
      "difficulty": "intermediate",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-06-01",
          "title": "Module 6, Lesson 1: When Things Might Not Be There â€” Deep Dive into `Option<T>`",
          "type": "exercise",
          "estimatedMinutes": 7,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 6, Lesson 1: When Things Might Not Be There â€” Deep Dive into `Option<T>`\n\n## The Concept: The Vending Machine\n\nImagine a vending machine:\n- **Press button for Snickers**: Machine dispenses `Some(Snickers)` âœ…\n- **Press button for sold-out item**: Machine dispenses `None` âŒ\n- **You always get a response**: Either something or nothing\n\n**Option<T>** represents a value that might or might not exist.\n\n## Why Option<T> Exists\n\nIn many languages, \"nothing\" is represented by `null` or `nil`:\n\n```javascript\n// JavaScript - The Billion Dollar Mistake\nlet user = findUser(\"alice\");\nconsole.log(user.name);  // ðŸ’¥ Runtime error if user is null!\n```\n\n**Rust's Solution**: Make \"might not exist\" explicit in the type system.\n\n```rust\nfn find_user(name: &str) -> Option<User> {\n    // Returns Some(user) or None\n}\n```\n\nThe compiler **forces** you to handle the None case!\n\n## Creating Options\n\n```rust\n// Some with a value\nlet some_number = Some(5);\nlet some_string = Some(String::from(\"hello\"));\n\n// None (no value)\nlet no_number: Option<i32> = None;\n\n// Function returning Option\nfn get_first_element(list: Vec<i32>) -> Option<i32> {\n    if list.is_empty() {\n        None\n    } else {\n        Some(list[0])\n    }\n}\n```\n\n## Checking What's Inside\n\n### **Method 1: Pattern Matching** (Most Powerful)\n\n```rust\nfn main() {\n    let maybe_number = Some(42);\n\n    match maybe_number {\n        Some(num) => println!(\"Got number: {}\", num),\n        None => println!(\"Got nothing\"),\n    }\n}\n```\n\n### **Method 2: if let** (More Concise)\n\n```rust\nfn main() {\n    let maybe_name = Some(\"Alice\");\n\n    if let Some(name) = maybe_name {\n        println!(\"Hello, {}!\", name);\n    } else {\n        println!(\"No name provided\");\n    }\n}\n```\n\n### **Method 3: Checking Without Extracting**\n\n```rust\nfn main() {\n    let x = Some(10);\n\n    if x.is_some() {\n        println!(\"x has a value\");\n    }\n\n    if x.is_none() {\n        println!(\"x is empty\");\n    }\n}\n```\n\n## Powerful Option Methods\n\n### **unwrap_or() - Provide a Default**\n\n```rust\nfn main() {\n    let some_value = Some(100);\n    let no_value: Option<i32> = None;\n\n    println!(\"{}\", some_value.unwrap_or(0));  // 100\n    println!(\"{}\", no_value.unwrap_or(0));    // 0 (default)\n}\n```\n\n### **map() - Transform the Value Inside**\n\n```rust\nfn main() {\n    let maybe_number = Some(5);\n\n    // Multiply the number inside by 2\n    let doubled = maybe_number.map(|n| n * 2);\n\n    println!(\"{:?}\", doubled);  // Some(10)\n\n    // If None, stays None\n    let nothing: Option<i32> = None;\n    let still_nothing = nothing.map(|n| n * 2);\n    println!(\"{:?}\", still_nothing);  // None\n}\n```\n\n### **and_then() - Chain Operations That Return Options**\n\n```rust\nfn divide(numerator: i32, denominator: i32) -> Option<i32> {\n    if denominator == 0 {\n        None\n    } else {\n        Some(numerator / denominator)\n    }\n}\n\nfn main() {\n    let result = Some(10)\n        .and_then(|n| divide(n, 2))  // 10 / 2 = Some(5)\n        .and_then(|n| divide(n, 0)); // 5 / 0 = None\n\n    match result {\n        Some(val) => println!(\"Result: {}\", val),\n        None => println!(\"Division by zero!\"),\n    }\n}\n```\n\n### **filter() - Keep Only If Condition Met**\n\n```rust\nfn main() {\n    let number = Some(42);\n\n    // Keep only if even\n    let even = number.filter(|n| n % 2 == 0);\n    println!(\"{:?}\", even);  // Some(42)\n\n    // Filter out odd numbers\n    let odd_number = Some(43);\n    let filtered = odd_number.filter(|n| n % 2 == 0);\n    println!(\"{:?}\", filtered);  // None\n}\n```\n\n### **or() and or_else() - Provide Alternatives**\n\n```rust\nfn main() {\n    let primary = None;\n    let backup = Some(100);\n\n    let result = primary.or(backup);\n    println!(\"{:?}\", result);  // Some(100)\n\n    // or_else with computation\n    let result = primary.or_else(|| Some(42));\n    println!(\"{:?}\", result);  // Some(42)\n}\n```\n\n## Dangerous Methods (Use With Care!)\n\n### **unwrap() - Panics if None**\n\n```rust\nfn main() {\n    let some_value = Some(10);\n    println!(\"{}\", some_value.unwrap());  // âœ… Works: 10\n\n    let no_value: Option<i32> = None;\n    // println!(\"{}\", no_value.unwrap());  // ðŸ’¥ PANIC! \"called unwrap on None\"\n}\n```\n\n**Rule**: Only use `unwrap()` when you're **absolutely certain** there's a value.\n\n### **expect() - Panic with Custom Message**\n\n```rust\nfn main() {\n    let config = Some(\"settings.toml\");\n    let filename = config.expect(\"Config file must be provided!\");\n    println!(\"{}\", filename);\n\n    let missing: Option<&str> = None;\n    // let file = missing.expect(\"Config file must be provided!\");\n    // ðŸ’¥ PANIC: \"Config file must be provided!\"\n}\n```\n\n## Real-World Example: User Lookup\n\n```rust\nuse std::collections::HashMap;\n\nstruct User {\n    name: String,\n    email: String,\n    age: u32,\n}\n\nfn find_user(users: &HashMap<u32, User>, id: u32) -> Option<&User> {\n    users.get(&id)\n}\n\nfn main() {\n    let mut users = HashMap::new();\n\n    users.insert(\n        1,\n        User {\n            name: String::from(\"Alice\"),\n            email: String::from(\"alice@example.com\"),\n            age: 30,\n        },\n    );\n\n    // Found user\n    match find_user(&users, 1) {\n        Some(user) => println!(\"Found: {} ({})\", user.name, user.email),\n        None => println!(\"User not found\"),\n    }\n\n    // Missing user\n    match find_user(&users, 999) {\n        Some(user) => println!(\"Found: {}\", user.name),\n        None => println!(\"User not found\"),  // This prints\n    }\n}\n```\n\n## Hands-On Practice\n\n```bash\ncargo new option_practice\ncd option_practice\ncode .\n```\n\n### **Experiment 1: Safe Division**\n\n```rust\nfn safe_divide(a: f64, b: f64) -> Option<f64> {\n    if b == 0.0 {\n        None\n    } else {\n        Some(a / b)\n    }\n}\n\nfn main() {\n    let result1 = safe_divide(10.0, 2.0);\n    println!(\"{:?}\", result1);  // Some(5.0)\n\n    let result2 = safe_divide(10.0, 0.0);\n    println!(\"{:?}\", result2);  // None\n\n    // With unwrap_or\n    let safe_result = safe_divide(10.0, 0.0).unwrap_or(0.0);\n    println!(\"Safe result: {}\", safe_result);  // 0.0\n}\n```\n\n### **Experiment 2: Parsing Numbers**\n\n```rust\nfn main() {\n    let valid = \"42\";\n    let invalid = \"hello\";\n\n    // parse returns Option<i32>\n    let num1: Option<i32> = valid.parse().ok();\n    let num2: Option<i32> = invalid.parse().ok();\n\n    println!(\"{:?}\", num1);  // Some(42)\n    println!(\"{:?}\", num2);  // None\n\n    // With default\n    let parsed = num2.unwrap_or(0);\n    println!(\"Parsed: {}\", parsed);  // 0\n}\n```\n\n### **Experiment 3: Chaining with map()**\n\n```rust\nfn main() {\n    let user_input = Some(\"  hello world  \");\n\n    let processed = user_input\n        .map(|s| s.trim())           // Remove whitespace\n        .map(|s| s.to_uppercase())   // Convert to uppercase\n        .filter(|s| s.len() > 5);    // Keep only if > 5 chars\n\n    println!(\"{:?}\", processed);  // Some(\"HELLO WORLD\")\n}\n```\n\n### **Challenge: Configuration Parser**\n\nBuild a config system that safely handles missing values:\n\n```rust\nuse std::collections::HashMap;\n\nstruct Config {\n    settings: HashMap<String, String>,\n}\n\nimpl Config {\n    fn new() -> Self {\n        Config {\n            settings: HashMap::new(),\n        }\n    }\n\n    fn set(&mut self, key: &str, value: &str) {\n        self.settings.insert(key.to_string(), value.to_string());\n    }\n\n    fn get(&self, key: &str) -> Option<&String> {\n        self.settings.get(key)\n    }\n\n    fn get_or(&self, key: &str, default: &str) -> String {\n        self.get(key)\n            .map(|s| s.clone())\n            .unwrap_or_else(|| default.to_string())\n    }\n\n    fn get_as_int(&self, key: &str) -> Option<i32> {\n        self.get(key)\n            .and_then(|s| s.parse::<i32>().ok())\n    }\n}\n\nfn main() {\n    let mut config = Config::new();\n\n    config.set(\"port\", \"8080\");\n    config.set(\"host\", \"localhost\");\n    config.set(\"debug\", \"true\");\n\n    // Get existing value\n    if let Some(port) = config.get(\"port\") {\n        println!(\"Port: {}\", port);\n    }\n\n    // Get missing value with default\n    let timeout = config.get_or(\"timeout\", \"30\");\n    println!(\"Timeout: {}\", timeout);\n\n    // Parse as integer\n    match config.get_as_int(\"port\") {\n        Some(num) => println!(\"Port as number: {}\", num),\n        None => println!(\"Port is not a valid number\"),\n    }\n\n    // Missing value\n    match config.get_as_int(\"missing\") {\n        Some(num) => println!(\"Value: {}\", num),\n        None => println!(\"Key not found\"),  // This prints\n    }\n}\n```\n\n**Output:**\n```\nPort: 8080\nTimeout: 30\nPort as number: 8080\nKey not found\n```\n\n## Common Patterns\n\n### **Pattern 1: Early Return with ?**\n\n```rust\nfn get_first_char(text: Option<String>) -> Option<char> {\n    let t = text?;  // Return None if text is None\n    t.chars().next()  // Return first char or None\n}\n\nfn main() {\n    let result1 = get_first_char(Some(String::from(\"hello\")));\n    println!(\"{:?}\", result1);  // Some('h')\n\n    let result2 = get_first_char(None);\n    println!(\"{:?}\", result2);  // None\n}\n```\n\n### **Pattern 2: Combining Multiple Options**\n\n```rust\nfn add_optional_numbers(a: Option<i32>, b: Option<i32>) -> Option<i32> {\n    match (a, b) {\n        (Some(x), Some(y)) => Some(x + y),\n        _ => None,\n    }\n}\n\nfn main() {\n    println!(\"{:?}\", add_optional_numbers(Some(5), Some(3)));  // Some(8)\n    println!(\"{:?}\", add_optional_numbers(Some(5), None));     // None\n}\n```\n\n### **Pattern 3: Optional References**\n\n```rust\nfn find_longest<'a>(words: &'a [String]) -> Option<&'a String> {\n    if words.is_empty() {\n        None\n    } else {\n        Some(&words[0])  // Simplified - just return first\n    }\n}\n\nfn main() {\n    let words = vec![\n        String::from(\"hello\"),\n        String::from(\"world\"),\n    ];\n\n    match find_longest(&words) {\n        Some(word) => println!(\"Found: {}\", word),\n        None => println!(\"Empty list\"),\n    }\n}\n```\n\n## Key Takeaways\n\n- âœ… `Option<T>` represents a value that might not exist\n- âœ… Two variants: `Some(value)` and `None`\n- âœ… Forces you to handle the \"missing\" case at compile time\n- âœ… Use pattern matching or `if let` to extract values\n- âœ… `.unwrap_or(default)` provides safe defaults\n- âœ… `.map()` transforms the value inside\n- âœ… `.and_then()` chains operations that return Options\n- âœ… `.filter()` conditionally keeps values\n- âœ… Avoid `.unwrap()` unless you're **certain** there's a value\n- âœ… Use `.expect()` with helpful messages for debugging\n- âœ… The `?` operator allows early returns from functions\n\n**Next**: Deep dive into `Result<T, E>` for operations that can fail with error information!\n\n---\n\n**Progress**: Module 6, Lesson 1 complete (34/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-06-02",
          "title": "Module 6, Lesson 2: When Things Can Fail with Details â€” Deep Dive into `Result<T, E>`",
          "type": "exercise",
          "estimatedMinutes": 9,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 6, Lesson 2: When Things Can Fail with Details â€” Deep Dive into `Result<T, E>`\n\n## The Concept: The Package Delivery\n\nImagine ordering a package:\n- **Successful delivery**: `Ok(Package)` âœ… - You get your item\n- **Failed delivery**: `Err(\"Address not found\")` âŒ - You get an explanation\n\n**Result<T, E>** represents an operation that can succeed with a value or fail with an error.\n\n## Option vs Result: What's the Difference?\n\n```rust\n// Option: Something might not exist\nfn find_user(id: u32) -> Option<User> {\n    // Returns Some(user) or None (no reason given)\n}\n\n// Result: Operation might fail (with reason)\nfn load_file(path: &str) -> Result<String, std::io::Error> {\n    // Returns Ok(contents) or Err(error details)\n}\n```\n\n**When to use which:**\n- **Option**: Value might not exist (no error, just absence)\n- **Result**: Operation can fail and you need to know why\n\n## Creating Results\n\n```rust\n// Success case\nlet success: Result<i32, String> = Ok(42);\n\n// Error case\nlet failure: Result<i32, String> = Err(String::from(\"Something went wrong\"));\n\n// Function returning Result\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        Err(String::from(\"Division by zero\"))\n    } else {\n        Ok(a / b)\n    }\n}\n```\n\n## Handling Results: Pattern Matching\n\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        Err(String::from(\"Cannot divide by zero\"))\n    } else {\n        Ok(a / b)\n    }\n}\n\nfn main() {\n    let result = divide(10, 2);\n\n    match result {\n        Ok(value) => println!(\"Result: {}\", value),\n        Err(error) => println!(\"Error: {}\", error),\n    }\n\n    let result2 = divide(10, 0);\n\n    match result2 {\n        Ok(value) => println!(\"Result: {}\", value),\n        Err(error) => println!(\"Error: {}\", error),  // This prints\n    }\n}\n```\n\n**Output:**\n```\nResult: 5\nError: Cannot divide by zero\n```\n\n## Result Methods\n\n### **is_ok() and is_err() - Quick Checks**\n\n```rust\nfn main() {\n    let success: Result<i32, String> = Ok(10);\n    let failure: Result<i32, String> = Err(String::from(\"failed\"));\n\n    println!(\"Success is ok: {}\", success.is_ok());    // true\n    println!(\"Success is err: {}\", success.is_err());  // false\n\n    println!(\"Failure is ok: {}\", failure.is_ok());    // false\n    println!(\"Failure is err: {}\", failure.is_err());  // true\n}\n```\n\n### **unwrap_or() - Provide Default Value**\n\n```rust\nfn main() {\n    let success: Result<i32, String> = Ok(100);\n    let failure: Result<i32, String> = Err(String::from(\"error\"));\n\n    println!(\"{}\", success.unwrap_or(0));  // 100\n    println!(\"{}\", failure.unwrap_or(0));  // 0 (default)\n}\n```\n\n### **unwrap_or_else() - Compute Default from Error**\n\n```rust\nfn main() {\n    let result: Result<i32, String> = Err(String::from(\"calculation failed\"));\n\n    let value = result.unwrap_or_else(|err| {\n        println!(\"Error occurred: {}\", err);\n        0  // Return default\n    });\n\n    println!(\"Value: {}\", value);\n}\n```\n\n**Output:**\n```\nError occurred: calculation failed\nValue: 0\n```\n\n### **map() - Transform Success Value**\n\n```rust\nfn main() {\n    let result: Result<i32, String> = Ok(5);\n\n    let doubled = result.map(|n| n * 2);\n    println!(\"{:?}\", doubled);  // Ok(10)\n\n    let failed: Result<i32, String> = Err(String::from(\"error\"));\n    let still_failed = failed.map(|n| n * 2);\n    println!(\"{:?}\", still_failed);  // Err(\"error\")\n}\n```\n\n### **map_err() - Transform Error Value**\n\n```rust\nfn main() {\n    let result: Result<i32, String> = Err(String::from(\"failed\"));\n\n    let new_error = result.map_err(|e| format!(\"ERROR: {}\", e));\n    println!(\"{:?}\", new_error);  // Err(\"ERROR: failed\")\n}\n```\n\n### **and_then() - Chain Operations That Return Results**\n\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        Err(String::from(\"Division by zero\"))\n    } else {\n        Ok(a / b)\n    }\n}\n\nfn main() {\n    let result = divide(10, 2)\n        .and_then(|n| divide(n, 0));  // First succeeds, second fails\n\n    match result {\n        Ok(val) => println!(\"Result: {}\", val),\n        Err(e) => println!(\"Error: {}\", e),  // \"Division by zero\"\n    }\n}\n```\n\n## Dangerous Methods (Use With Extreme Care!)\n\n### **unwrap() - Panics on Error**\n\n```rust\nfn main() {\n    let success: Result<i32, String> = Ok(42);\n    println!(\"{}\", success.unwrap());  // âœ… Works: 42\n\n    let failure: Result<i32, String> = Err(String::from(\"failed\"));\n    // println!(\"{}\", failure.unwrap());  // ðŸ’¥ PANIC: \"called unwrap on Err\"\n}\n```\n\n### **expect() - Panic with Custom Message**\n\n```rust\nfn main() {\n    let config: Result<String, String> = Err(String::from(\"file not found\"));\n\n    // let content = config.expect(\"Configuration must be loaded!\");\n    // ðŸ’¥ PANIC: \"Configuration must be loaded!: file not found\"\n}\n```\n\n### **When to Use unwrap()/expect()**\n\nOnly in these situations:\n1. **Prototyping**: Quick testing before proper error handling\n2. **Tests**: Where panics are acceptable\n3. **When impossible to fail**: But add comment explaining why\n\n```rust\nfn main() {\n    // Safe: parsing a string literal we control\n    let number = \"42\".parse::<i32>().expect(\"hardcoded string is valid\");\n    println!(\"{}\", number);\n}\n```\n\n## The ? Operator - Early Return on Error\n\nThe `?` operator is **game-changing** for clean error handling:\n\n```rust\nuse std::fs;\nuse std::io;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut username = fs::read_to_string(\"username.txt\")?;\n    // If error, immediately return Err(error)\n    // If success, unwrap and continue\n\n    username = username.trim().to_string();\n    Ok(username)\n}\n\nfn main() {\n    match read_username_from_file() {\n        Ok(name) => println!(\"Username: {}\", name),\n        Err(e) => println!(\"Error reading file: {}\", e),\n    }\n}\n```\n\n**How ? works:**\n- If `Ok(value)`: Extract value and continue\n- If `Err(error)`: Return error immediately from function\n\n**Without ? operator** (verbose):\n```rust\nfn read_username_from_file() -> Result<String, io::Error> {\n    let result = fs::read_to_string(\"username.txt\");\n\n    let mut username = match result {\n        Ok(content) => content,\n        Err(e) => return Err(e),\n    };\n\n    username = username.trim().to_string();\n    Ok(username)\n}\n```\n\n**With ? operator** (clean):\n```rust\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut username = fs::read_to_string(\"username.txt\")?;\n    username = username.trim().to_string();\n    Ok(username)\n}\n```\n\n## Chaining with ?\n\n```rust\nuse std::fs;\nuse std::io;\n\nfn process_file(path: &str) -> Result<usize, io::Error> {\n    let content = fs::read_to_string(path)?;  // Return error if fails\n    let trimmed = content.trim();\n    let length = trimmed.len();\n    Ok(length)\n}\n\nfn main() {\n    match process_file(\"data.txt\") {\n        Ok(len) => println!(\"File length: {}\", len),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\n## Real-World Example: User Input Validation\n\n```rust\nuse std::io;\n\n#[derive(Debug)]\nenum ValidationError {\n    TooShort,\n    TooLong,\n    InvalidCharacters,\n}\n\nfn validate_username(name: &str) -> Result<String, ValidationError> {\n    if name.len() < 3 {\n        return Err(ValidationError::TooShort);\n    }\n\n    if name.len() > 20 {\n        return Err(ValidationError::TooLong);\n    }\n\n    if !name.chars().all(|c| c.is_alphanumeric() || c == '_') {\n        return Err(ValidationError::InvalidCharacters);\n    }\n\n    Ok(name.to_string())\n}\n\nfn main() {\n    println!(\"Enter username:\");\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n\n    let username = input.trim();\n\n    match validate_username(username) {\n        Ok(valid_name) => println!(\"âœ… Valid username: {}\", valid_name),\n        Err(ValidationError::TooShort) => {\n            println!(\"âŒ Username must be at least 3 characters\");\n        }\n        Err(ValidationError::TooLong) => {\n            println!(\"âŒ Username must be at most 20 characters\");\n        }\n        Err(ValidationError::InvalidCharacters) => {\n            println!(\"âŒ Username can only contain letters, numbers, and underscores\");\n        }\n    }\n}\n```\n\n## Hands-On Practice\n\n```bash\ncargo new result_practice\ncd result_practice\ncode .\n```\n\n### **Experiment 1: Safe Parsing**\n\n```rust\nfn parse_age(input: &str) -> Result<u32, String> {\n    match input.parse::<u32>() {\n        Ok(age) => {\n            if age > 0 && age < 150 {\n                Ok(age)\n            } else {\n                Err(String::from(\"Age must be between 1 and 149\"))\n            }\n        }\n        Err(_) => Err(String::from(\"Invalid number format\")),\n    }\n}\n\nfn main() {\n    let test_cases = vec![\"25\", \"200\", \"abc\", \"0\"];\n\n    for input in test_cases {\n        match parse_age(input) {\n            Ok(age) => println!(\"âœ… Valid age: {}\", age),\n            Err(e) => println!(\"âŒ Error for '{}': {}\", input, e),\n        }\n    }\n}\n```\n\n### **Experiment 2: Multiple Validations**\n\n```rust\nfn validate_email(email: &str) -> Result<String, String> {\n    if !email.contains('@') {\n        return Err(String::from(\"Must contain @\"));\n    }\n\n    if !email.contains('.') {\n        return Err(String::from(\"Must contain domain\"));\n    }\n\n    if email.len() < 5 {\n        return Err(String::from(\"Too short\"));\n    }\n\n    Ok(email.to_string())\n}\n\nfn main() {\n    let emails = vec![\n        \"user@example.com\",\n        \"invalid\",\n        \"no-at-sign.com\",\n        \"x@y\",\n    ];\n\n    for email in emails {\n        match validate_email(email) {\n            Ok(valid) => println!(\"âœ… {}\", valid),\n            Err(e) => println!(\"âŒ {}: {}\", email, e),\n        }\n    }\n}\n```\n\n### **Experiment 3: Using ? Operator**\n\n```rust\nfn calculate_average(numbers: Vec<&str>) -> Result<f64, String> {\n    if numbers.is_empty() {\n        return Err(String::from(\"Cannot calculate average of empty list\"));\n    }\n\n    let mut sum = 0.0;\n    let mut count = 0;\n\n    for num_str in numbers {\n        let num = num_str\n            .parse::<f64>()\n            .map_err(|_| format!(\"Invalid number: {}\", num_str))?;\n\n        sum += num;\n        count += 1;\n    }\n\n    Ok(sum / count as f64)\n}\n\nfn main() {\n    let valid = vec![\"10\", \"20\", \"30\"];\n    match calculate_average(valid) {\n        Ok(avg) => println!(\"Average: {:.2}\", avg),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n\n    let invalid = vec![\"10\", \"abc\", \"30\"];\n    match calculate_average(invalid) {\n        Ok(avg) => println!(\"Average: {:.2}\", avg),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\n### **Challenge: Password Validator**\n\nBuild a comprehensive password validation system:\n\n```rust\n#[derive(Debug)]\nenum PasswordError {\n    TooShort,\n    NoUppercase,\n    NoLowercase,\n    NoDigit,\n    NoSpecialChar,\n}\n\nfn validate_password(password: &str) -> Result<String, Vec<PasswordError>> {\n    let mut errors = Vec::new();\n\n    if password.len() < 8 {\n        errors.push(PasswordError::TooShort);\n    }\n\n    if !password.chars().any(|c| c.is_uppercase()) {\n        errors.push(PasswordError::NoUppercase);\n    }\n\n    if !password.chars().any(|c| c.is_lowercase()) {\n        errors.push(PasswordError::NoLowercase);\n    }\n\n    if !password.chars().any(|c| c.is_numeric()) {\n        errors.push(PasswordError::NoDigit);\n    }\n\n    if !password.chars().any(|c| \"!@#$%^&*\".contains(c)) {\n        errors.push(PasswordError::NoSpecialChar);\n    }\n\n    if errors.is_empty() {\n        Ok(password.to_string())\n    } else {\n        Err(errors)\n    }\n}\n\nfn main() {\n    let test_passwords = vec![\n        \"Abc123!@\",\n        \"password\",\n        \"PASSWORD\",\n        \"Pass123\",\n        \"short\",\n        \"MyP@ssw0rd\",\n    ];\n\n    for pwd in test_passwords {\n        print!(\"Password '{}': \", pwd);\n\n        match validate_password(pwd) {\n            Ok(_) => println!(\"âœ… Valid!\"),\n            Err(errors) => {\n                println!(\"âŒ Invalid:\");\n                for error in errors {\n                    let msg = match error {\n                        PasswordError::TooShort => \"  - Must be at least 8 characters\",\n                        PasswordError::NoUppercase => \"  - Must contain uppercase letter\",\n                        PasswordError::NoLowercase => \"  - Must contain lowercase letter\",\n                        PasswordError::NoDigit => \"  - Must contain a digit\",\n                        PasswordError::NoSpecialChar => \"  - Must contain special character (!@#$%^&*)\",\n                    };\n                    println!(\"{}\", msg);\n                }\n            }\n        }\n        println!();\n    }\n}\n```\n\n**Output:**\n```\nPassword 'Abc123!@': âœ… Valid!\n\nPassword 'password': âŒ Invalid:\n  - Must contain uppercase letter\n  - Must contain a digit\n  - Must contain special character (!@#$%^&*)\n\nPassword 'MyP@ssw0rd': âœ… Valid!\n```\n\n## Converting Between Option and Result\n\n```rust\nfn main() {\n    // Option to Result\n    let maybe_number: Option<i32> = Some(42);\n    let result = maybe_number.ok_or(String::from(\"No value\"));\n    println!(\"{:?}\", result);  // Ok(42)\n\n    // Result to Option\n    let result: Result<i32, String> = Ok(100);\n    let option = result.ok();\n    println!(\"{:?}\", option);  // Some(100)\n\n    // Error to Option (discards error info)\n    let result: Result<i32, String> = Err(String::from(\"failed\"));\n    let option = result.ok();\n    println!(\"{:?}\", option);  // None\n}\n```\n\n## Key Takeaways\n\n- âœ… `Result<T, E>` represents operations that can fail with error details\n- âœ… Two variants: `Ok(value)` for success, `Err(error)` for failure\n- âœ… Use `match` or `if let` to handle both cases\n- âœ… `.unwrap_or(default)` provides safe fallbacks\n- âœ… `.map()` transforms success values\n- âœ… `.map_err()` transforms error values\n- âœ… `.and_then()` chains Result-returning operations\n- âœ… The `?` operator enables clean error propagation\n- âœ… Avoid `.unwrap()` in production code\n- âœ… Use `.expect()` with descriptive messages\n- âœ… Custom enums make excellent error types\n- âœ… Use `Result` when you need error details, `Option` when you just need presence/absence\n\n**Next**: The ? operator in depth and error propagation patterns!\n\n---\n\n**Progress**: Module 6, Lesson 2 complete (35/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-06-03",
          "title": "Module 6, Lesson 3: Clean Error Handling â€” The `?` Operator Mastery",
          "type": "exercise",
          "estimatedMinutes": 8,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 6, Lesson 3: Clean Error Handling â€” The `?` Operator Mastery\n\n## The Concept: The Assembly Line\n\nImagine an assembly line building a product:\n- **Each station** checks quality and passes to next station\n- **If any station fails**: Stop the line, report which station failed\n- **If all succeed**: Final product ready\n\n**The ? operator** lets each function pass along errors automatically.\n\n## The Problem: Error Handling is Verbose\n\nWithout the `?` operator, error handling gets messy fast:\n\n```rust\nuse std::fs;\nuse std::io;\n\nfn read_and_process_file() -> Result<String, io::Error> {\n    let content_result = fs::read_to_string(\"data.txt\");\n\n    let content = match content_result {\n        Ok(c) => c,\n        Err(e) => return Err(e),\n    };\n\n    let trimmed = content.trim();\n\n    let uppercase = trimmed.to_uppercase();\n\n    Ok(uppercase)\n}\n```\n\n**Problem**: Boilerplate match statements everywhere!\n\n## The Solution: The ? Operator\n\n```rust\nuse std::fs;\nuse std::io;\n\nfn read_and_process_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"data.txt\")?;  // Auto-return error\n    let trimmed = content.trim();\n    let uppercase = trimmed.to_uppercase();\n    Ok(uppercase)\n}\n```\n\n**What ? does:**\n1. If `Ok(value)`: Unwrap the value, continue\n2. If `Err(error)`: Return the error immediately from the function\n\n## How ? Works Behind the Scenes\n\n```rust\n// This code:\nlet value = some_result?;\n\n// Is equivalent to:\nlet value = match some_result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n};\n```\n\n## Chaining Multiple Operations\n\n```rust\nuse std::fs;\nuse std::io;\n\nfn count_lines(filename: &str) -> Result<usize, io::Error> {\n    let content = fs::read_to_string(filename)?;  // Might fail\n    let lines = content.lines().count();\n    Ok(lines)\n}\n\nfn main() {\n    match count_lines(\"data.txt\") {\n        Ok(count) => println!(\"File has {} lines\", count),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\n## Chaining Many ? Operators\n\n```rust\nuse std::fs;\nuse std::io;\n\nfn read_username_from_file(path: &str) -> Result<String, io::Error> {\n    let content = fs::read_to_string(path)?;  // Error 1: File not found\n    let first_line = content\n        .lines()\n        .next()\n        .ok_or(io::Error::new(io::ErrorKind::InvalidData, \"Empty file\"))?;  // Error 2: Empty file\n\n    Ok(first_line.trim().to_string())\n}\n\nfn main() {\n    match read_username_from_file(\"username.txt\") {\n        Ok(name) => println!(\"Username: {}\", name),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\n## Using ? with Option\n\nThe `?` operator also works with `Option<T>`:\n\n```rust\nfn get_first_word(text: &str) -> Option<&str> {\n    let first = text.split_whitespace().next()?;  // Return None if no words\n    Some(first)\n}\n\nfn main() {\n    let result = get_first_word(\"Hello world\");\n    println!(\"{:?}\", result);  // Some(\"Hello\")\n\n    let empty = get_first_word(\"\");\n    println!(\"{:?}\", empty);  // None\n}\n```\n\n## Mixing ? with Different Error Types\n\n**Problem**: Can't use `?` if error types don't match:\n\n```rust\nuse std::fs;\nuse std::io;\nuse std::num::ParseIntError;\n\n// âŒ This won't compile:\n// fn read_number_from_file() -> Result<i32, io::Error> {\n//     let content = fs::read_to_string(\"number.txt\")?;  // io::Error\n//     let number = content.trim().parse::<i32>()?;  // ParseIntError - doesn't match!\n//     Ok(number)\n// }\n```\n\n**Solution 1**: Use a common error type (Box<dyn Error>)\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\nfn read_number_from_file() -> Result<i32, Box<dyn Error>> {\n    let content = fs::read_to_string(\"number.txt\")?;  // âœ… Works\n    let number = content.trim().parse::<i32>()?;       // âœ… Works\n    Ok(number)\n}\n\nfn main() {\n    match read_number_from_file() {\n        Ok(num) => println!(\"Number: {}\", num),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\n**Solution 2**: Custom error type (more advanced, see next lesson)\n\n## The ? Operator Rules\n\n### **Rule 1: Function Must Return Result or Option**\n\n```rust\n// âŒ Won't compile - main returns ()\n// fn main() {\n//     let content = std::fs::read_to_string(\"file.txt\")?;  // Error!\n// }\n\n// âœ… Works - returns Result\nfn read_file() -> Result<String, std::io::Error> {\n    let content = std::fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```\n\n### **Rule 2: Error Types Must Match**\n\n```rust\nuse std::io;\n\nfn process() -> Result<i32, io::Error> {\n    // let num = \"42\".parse::<i32>()?;  // âŒ ParseIntError doesn't match io::Error\n    // Ok(num)\n\n    // Fix: Convert error types\n    let num = \"42\"\n        .parse::<i32>()\n        .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;\n    Ok(num)\n}\n```\n\n### **Rule 3: Can't Mix Option and Result**\n\n```rust\n// âŒ Can't use Option? in Result function\n// fn example() -> Result<i32, String> {\n//     let value = Some(42)?;  // Error: returns Option, not Result\n//     Ok(value)\n// }\n\n// âœ… Convert Option to Result\nfn example() -> Result<i32, String> {\n    let value = Some(42).ok_or(String::from(\"No value\"))?;\n    Ok(value)\n}\n```\n\n## Making main() Return Result\n\nYou can make `main()` return `Result` to use `?`:\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let content = fs::read_to_string(\"config.toml\")?;  // âœ… Works!\n    println!(\"Config: {}\", content);\n    Ok(())\n}\n```\n\n**If error occurs**: Program exits with error message\n\n## Real-World Example: Configuration Loader\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\nstruct Config {\n    port: u16,\n    host: String,\n}\n\nimpl Config {\n    fn load(path: &str) -> Result<Self, Box<dyn Error>> {\n        let content = fs::read_to_string(path)?;  // Read file\n\n        let lines: Vec<&str> = content.lines().collect();\n\n        // Parse port (line 1)\n        let port = lines\n            .get(0)\n            .ok_or(\"Missing port\")?\n            .trim()\n            .parse::<u16>()?;\n\n        // Parse host (line 2)\n        let host = lines\n            .get(1)\n            .ok_or(\"Missing host\")?\n            .trim()\n            .to_string();\n\n        Ok(Config { port, host })\n    }\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let config = Config::load(\"config.txt\")?;\n    println!(\"Server: {}:{}\", config.host, config.port);\n    Ok(())\n}\n```\n\n**config.txt:**\n```\n8080\nlocalhost\n```\n\n## Hands-On Practice\n\n```bash\ncargo new question_mark_practice\ncd question_mark_practice\ncode .\n```\n\n### **Experiment 1: File Reading with ?**\n\n```rust\nuse std::fs;\nuse std::io;\n\nfn read_and_uppercase(filename: &str) -> Result<String, io::Error> {\n    let content = fs::read_to_string(filename)?;\n    Ok(content.to_uppercase())\n}\n\nfn main() {\n    match read_and_uppercase(\"test.txt\") {\n        Ok(content) => println!(\"{}\", content),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\n**Create test.txt first:**\n```bash\necho \"hello world\" > test.txt\n```\n\n### **Experiment 2: Parsing Chain**\n\n```rust\nuse std::error::Error;\n\nfn sum_from_file(filename: &str) -> Result<i32, Box<dyn Error>> {\n    let content = std::fs::read_to_string(filename)?;\n\n    let sum = content\n        .lines()\n        .map(|line| line.trim().parse::<i32>())\n        .collect::<Result<Vec<i32>, _>>()?  // Propagate parse errors\n        .iter()\n        .sum();\n\n    Ok(sum)\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let total = sum_from_file(\"numbers.txt\")?;\n    println!(\"Total: {}\", total);\n    Ok(())\n}\n```\n\n**Create numbers.txt:**\n```bash\necho -e \"10\\n20\\n30\\n40\" > numbers.txt\n```\n\n### **Experiment 3: Option to Result Conversion**\n\n```rust\nfn get_first_number(numbers: Vec<i32>) -> Result<i32, String> {\n    numbers\n        .first()\n        .copied()\n        .ok_or(String::from(\"Empty list\"))  // Convert Option to Result\n}\n\nfn main() {\n    let nums = vec![1, 2, 3];\n    match get_first_number(nums) {\n        Ok(n) => println!(\"First: {}\", n),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n\n    let empty: Vec<i32> = vec![];\n    match get_first_number(empty) {\n        Ok(n) => println!(\"First: {}\", n),\n        Err(e) => println!(\"Error: {}\", e),  // \"Empty list\"\n    }\n}\n```\n\n### **Challenge: CSV Parser**\n\nBuild a simple CSV parser using multiple `?` operators:\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\n#[derive(Debug)]\nstruct Person {\n    name: String,\n    age: u32,\n    city: String,\n}\n\nimpl Person {\n    fn from_csv_line(line: &str) -> Result<Self, Box<dyn Error>> {\n        let parts: Vec<&str> = line.split(',').collect();\n\n        let name = parts\n            .get(0)\n            .ok_or(\"Missing name\")?\n            .trim()\n            .to_string();\n\n        let age = parts\n            .get(1)\n            .ok_or(\"Missing age\")?\n            .trim()\n            .parse::<u32>()?;\n\n        let city = parts\n            .get(2)\n            .ok_or(\"Missing city\")?\n            .trim()\n            .to_string();\n\n        Ok(Person { name, age, city })\n    }\n}\n\nfn load_people(filename: &str) -> Result<Vec<Person>, Box<dyn Error>> {\n    let content = fs::read_to_string(filename)?;\n\n    let mut people = Vec::new();\n\n    for (i, line) in content.lines().enumerate() {\n        if i == 0 {\n            continue;  // Skip header\n        }\n\n        let person = Person::from_csv_line(line)\n            .map_err(|e| format!(\"Line {}: {}\", i + 1, e))?;\n\n        people.push(person);\n    }\n\n    Ok(people)\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let people = load_people(\"people.csv\")?;\n\n    println!(\"Loaded {} people:\", people.len());\n    for person in people {\n        println!(\"{} ({}) from {}\", person.name, person.age, person.city);\n    }\n\n    Ok(())\n}\n```\n\n**Create people.csv:**\n```csv\nname,age,city\nAlice,30,New York\nBob,25,San Francisco\nCharlie,35,Chicago\n```\n\n**Run:**\n```bash\ncargo run\n```\n\n**Output:**\n```\nLoaded 3 people:\nAlice (30) from New York\nBob (25) from San Francisco\nCharlie (35) from Chicago\n```\n\n## Advanced: Early Return in Loops\n\n```rust\nfn find_valid_number(numbers: Vec<&str>) -> Result<i32, String> {\n    for (i, num_str) in numbers.iter().enumerate() {\n        match num_str.parse::<i32>() {\n            Ok(num) => {\n                if num > 0 {\n                    return Ok(num);  // Found valid number\n                }\n            }\n            Err(_) => {\n                return Err(format!(\"Invalid number at position {}: {}\", i, num_str));\n            }\n        }\n    }\n\n    Err(String::from(\"No positive numbers found\"))\n}\n\nfn main() {\n    let numbers = vec![\"0\", \"-5\", \"42\", \"100\"];\n\n    match find_valid_number(numbers) {\n        Ok(num) => println!(\"Found: {}\", num),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\n## Best Practices\n\n### âœ… DO: Use ? for Clean Code\n\n```rust\nfn process() -> Result<String, std::io::Error> {\n    let data = std::fs::read_to_string(\"file.txt\")?;\n    let trimmed = data.trim();\n    Ok(trimmed.to_string())\n}\n```\n\n### âœ… DO: Make main() Return Result When Needed\n\n```rust\nuse std::error::Error;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let config = load_config()?;\n    start_server(config)?;\n    Ok(())\n}\n```\n\n### âŒ DON'T: Mix ? with panic!\n\n```rust\n// âŒ Bad: Using both error handling strategies\nfn bad_example() -> Result<i32, String> {\n    let file = std::fs::read_to_string(\"file.txt\")\n        .expect(\"Failed\");  // Panics instead of returning Result\n    Ok(file.len() as i32)\n}\n\n// âœ… Good: Consistent error handling\nfn good_example() -> Result<i32, std::io::Error> {\n    let file = std::fs::read_to_string(\"file.txt\")?;\n    Ok(file.len() as i32)\n}\n```\n\n### âœ… DO: Add Context to Errors\n\n```rust\nuse std::fs;\n\nfn load_config() -> Result<String, String> {\n    fs::read_to_string(\"config.toml\")\n        .map_err(|e| format!(\"Failed to load config: {}\", e))\n}\n```\n\n## Key Takeaways\n\n- âœ… The `?` operator simplifies error handling dramatically\n- âœ… Works with both `Result<T, E>` and `Option<T>`\n- âœ… Automatically returns errors early from functions\n- âœ… Can only be used in functions returning `Result` or `Option`\n- âœ… Error types must match (or use `Box<dyn Error>`)\n- âœ… Can chain many `?` operators cleanly\n- âœ… `main()` can return `Result<(), Box<dyn Error>>`\n- âœ… Use `.ok_or()` to convert `Option` to `Result`\n- âœ… Use `.map_err()` to convert between error types\n- âœ… Reduces boilerplate while maintaining safety\n- âœ… Makes error propagation explicit and compile-time checked\n\n**Next**: Creating custom error types for better error handling!\n\n---\n\n**Progress**: Module 6, Lesson 3 complete (36/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-06-04",
          "title": "Module 6, Lesson 4: Making Errors Meaningful â€” Custom Error Types",
          "type": "project",
          "estimatedMinutes": 9,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 6, Lesson 4: Making Errors Meaningful â€” Custom Error Types\n\n## The Concept: Specific Doctor Diagnoses\n\nImagine visiting a doctor:\n- **Generic**: \"You're sick\" âŒ (not helpful)\n- **Specific**: \"You have strep throat, here's the treatment\" âœ… (actionable)\n\n**Custom error types** provide specific, actionable error information.\n\n## The Problem with String Errors\n\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        Err(String::from(\"Cannot divide by zero\"))\n    } else {\n        Ok(a / b)\n    }\n}\n```\n\n**Problems:**\n- Can't match on specific error types\n- Hard to handle different errors differently\n- No structured error data\n- Strings aren't very Rust-idiomatic\n\n## Solution: Custom Error Enums\n\n```rust\n#[derive(Debug)]\nenum MathError {\n    DivisionByZero,\n    Overflow,\n    NegativeResult,\n}\n\nfn divide(a: i32, b: i32) -> Result<i32, MathError> {\n    if b == 0 {\n        return Err(MathError::DivisionByZero);\n    }\n\n    if a == i32::MAX && b == -1 {\n        return Err(MathError::Overflow);\n    }\n\n    let result = a / b;\n\n    if result < 0 {\n        return Err(MathError::NegativeResult);\n    }\n\n    Ok(result)\n}\n\nfn main() {\n    match divide(10, 0) {\n        Ok(result) => println!(\"Result: {}\", result),\n        Err(MathError::DivisionByZero) => println!(\"âŒ Cannot divide by zero!\"),\n        Err(MathError::Overflow) => println!(\"âŒ Result too large!\"),\n        Err(MathError::NegativeResult) => println!(\"âŒ Negative results not allowed!\"),\n    }\n}\n```\n\n**Benefits:**\n- âœ… Pattern match on specific errors\n- âœ… Type-safe error handling\n- âœ… Self-documenting code\n- âœ… Compiler ensures all errors handled\n\n## Adding Data to Errors\n\n```rust\n#[derive(Debug)]\nenum ValidationError {\n    TooShort { min_length: usize, actual: usize },\n    TooLong { max_length: usize, actual: usize },\n    InvalidCharacter(char),\n    Empty,\n}\n\nfn validate_username(name: &str) -> Result<String, ValidationError> {\n    if name.is_empty() {\n        return Err(ValidationError::Empty);\n    }\n\n    if name.len() < 3 {\n        return Err(ValidationError::TooShort {\n            min_length: 3,\n            actual: name.len(),\n        });\n    }\n\n    if name.len() > 20 {\n        return Err(ValidationError::TooLong {\n            max_length: 20,\n            actual: name.len(),\n        });\n    }\n\n    for ch in name.chars() {\n        if !ch.is_alphanumeric() && ch != '_' {\n            return Err(ValidationError::InvalidCharacter(ch));\n        }\n    }\n\n    Ok(name.to_string())\n}\n\nfn main() {\n    let usernames = vec![\"alice\", \"ab\", \"user@name\", \"this_is_way_too_long_username\"];\n\n    for name in usernames {\n        match validate_username(name) {\n            Ok(valid) => println!(\"âœ… '{}' is valid\", valid),\n            Err(ValidationError::Empty) => {\n                println!(\"âŒ '{}': Username cannot be empty\", name);\n            }\n            Err(ValidationError::TooShort { min_length, actual }) => {\n                println!(\n                    \"âŒ '{}': Too short (min: {}, got: {})\",\n                    name, min_length, actual\n                );\n            }\n            Err(ValidationError::TooLong { max_length, actual }) => {\n                println!(\n                    \"âŒ '{}': Too long (max: {}, got: {})\",\n                    name, max_length, actual\n                );\n            }\n            Err(ValidationError::InvalidCharacter(ch)) => {\n                println!(\"âŒ '{}': Invalid character '{}'\", name, ch);\n            }\n        }\n    }\n}\n```\n\n**Output:**\n```\nâœ… 'alice' is valid\nâŒ 'ab': Too short (min: 3, got: 2)\nâŒ 'user@name': Invalid character '@'\nâŒ 'this_is_way_too_long_username': Too long (max: 20, got: 29)\n```\n\n## Implementing Display for Better Messages\n\n```rust\nuse std::fmt;\n\n#[derive(Debug)]\nenum FileError {\n    NotFound(String),\n    PermissionDenied(String),\n    AlreadyExists(String),\n}\n\nimpl fmt::Display for FileError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            FileError::NotFound(path) => {\n                write!(f, \"File not found: {}\", path)\n            }\n            FileError::PermissionDenied(path) => {\n                write!(f, \"Permission denied: {}\", path)\n            }\n            FileError::AlreadyExists(path) => {\n                write!(f, \"File already exists: {}\", path)\n            }\n        }\n    }\n}\n\nfn open_file(path: &str) -> Result<String, FileError> {\n    // Simulate different errors\n    if path.is_empty() {\n        return Err(FileError::NotFound(String::from(\"(empty path)\")));\n    }\n\n    if path.starts_with(\"/system\") {\n        return Err(FileError::PermissionDenied(path.to_string()));\n    }\n\n    Ok(format!(\"Contents of {}\", path))\n}\n\nfn main() {\n    match open_file(\"\") {\n        Ok(content) => println!(\"{}\", content),\n        Err(e) => println!(\"Error: {}\", e),  // Uses Display trait\n    }\n\n    match open_file(\"/system/secret.txt\") {\n        Ok(content) => println!(\"{}\", content),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\n**Output:**\n```\nError: File not found: (empty path)\nError: Permission denied: /system/secret.txt\n```\n\n## Implementing the Error Trait\n\nTo make custom errors work with `Box<dyn Error>`:\n\n```rust\nuse std::error::Error;\nuse std::fmt;\n\n#[derive(Debug)]\nenum DatabaseError {\n    ConnectionFailed,\n    QueryError(String),\n    NotFound,\n}\n\nimpl fmt::Display for DatabaseError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            DatabaseError::ConnectionFailed => write!(f, \"Failed to connect to database\"),\n            DatabaseError::QueryError(msg) => write!(f, \"Query error: {}\", msg),\n            DatabaseError::NotFound => write!(f, \"Record not found\"),\n        }\n    }\n}\n\nimpl Error for DatabaseError {}\n\nfn fetch_user(id: u32) -> Result<String, DatabaseError> {\n    if id == 0 {\n        return Err(DatabaseError::NotFound);\n    }\n\n    Ok(format!(\"User {}\", id))\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let user = fetch_user(0)?;  // Works with ? operator now!\n    println!(\"{}\", user);\n    Ok(())\n}\n```\n\n## Wrapping Other Errors\n\n```rust\nuse std::error::Error;\nuse std::fmt;\nuse std::fs;\nuse std::io;\nuse std::num::ParseIntError;\n\n#[derive(Debug)]\nenum AppError {\n    IoError(io::Error),\n    ParseError(ParseIntError),\n    InvalidData(String),\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            AppError::IoError(e) => write!(f, \"IO error: {}\", e),\n            AppError::ParseError(e) => write!(f, \"Parse error: {}\", e),\n            AppError::InvalidData(msg) => write!(f, \"Invalid data: {}\", msg),\n        }\n    }\n}\n\nimpl Error for AppError {}\n\nimpl From<io::Error> for AppError {\n    fn from(error: io::Error) -> Self {\n        AppError::IoError(error)\n    }\n}\n\nimpl From<ParseIntError> for AppError {\n    fn from(error: ParseIntError) -> Self {\n        AppError::ParseError(error)\n    }\n}\n\nfn read_number(filename: &str) -> Result<i32, AppError> {\n    let content = fs::read_to_string(filename)?;  // io::Error auto-converted\n    let number = content.trim().parse::<i32>()?;  // ParseIntError auto-converted\n\n    if number < 0 {\n        return Err(AppError::InvalidData(String::from(\"Number must be positive\")));\n    }\n\n    Ok(number)\n}\n\nfn main() {\n    match read_number(\"number.txt\") {\n        Ok(num) => println!(\"Number: {}\", num),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\n**The `From` trait enables automatic error conversion with `?`!**\n\n## Real-World Example: User Registration System\n\n```rust\nuse std::error::Error;\nuse std::fmt;\n\n#[derive(Debug)]\nenum RegistrationError {\n    UsernameTooShort,\n    UsernameTooLong,\n    UsernameInvalidChars,\n    PasswordTooWeak,\n    EmailInvalid,\n    UsernameExists(String),\n}\n\nimpl fmt::Display for RegistrationError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            RegistrationError::UsernameTooShort => {\n                write!(f, \"Username must be at least 3 characters\")\n            }\n            RegistrationError::UsernameTooLong => {\n                write!(f, \"Username must be at most 20 characters\")\n            }\n            RegistrationError::UsernameInvalidChars => {\n                write!(f, \"Username can only contain letters, numbers, and underscores\")\n            }\n            RegistrationError::PasswordTooWeak => {\n                write!(f, \"Password must be at least 8 characters and contain letters and numbers\")\n            }\n            RegistrationError::EmailInvalid => {\n                write!(f, \"Email address is invalid\")\n            }\n            RegistrationError::UsernameExists(name) => {\n                write!(f, \"Username '{}' already exists\", name)\n            }\n        }\n    }\n}\n\nimpl Error for RegistrationError {}\n\nstruct User {\n    username: String,\n    email: String,\n}\n\nfn validate_username(username: &str, existing: &[String]) -> Result<(), RegistrationError> {\n    if username.len() < 3 {\n        return Err(RegistrationError::UsernameTooShort);\n    }\n\n    if username.len() > 20 {\n        return Err(RegistrationError::UsernameTooLong);\n    }\n\n    if !username.chars().all(|c| c.is_alphanumeric() || c == '_') {\n        return Err(RegistrationError::UsernameInvalidChars);\n    }\n\n    if existing.contains(&username.to_string()) {\n        return Err(RegistrationError::UsernameExists(username.to_string()));\n    }\n\n    Ok(())\n}\n\nfn validate_password(password: &str) -> Result<(), RegistrationError> {\n    let has_letter = password.chars().any(|c| c.is_alphabetic());\n    let has_number = password.chars().any(|c| c.is_numeric());\n\n    if password.len() < 8 || !has_letter || !has_number {\n        return Err(RegistrationError::PasswordTooWeak);\n    }\n\n    Ok(())\n}\n\nfn validate_email(email: &str) -> Result<(), RegistrationError> {\n    if !email.contains('@') || !email.contains('.') {\n        return Err(RegistrationError::EmailInvalid);\n    }\n\n    Ok(())\n}\n\nfn register_user(\n    username: &str,\n    password: &str,\n    email: &str,\n    existing_users: &[String],\n) -> Result<User, RegistrationError> {\n    validate_username(username, existing_users)?;\n    validate_password(password)?;\n    validate_email(email)?;\n\n    Ok(User {\n        username: username.to_string(),\n        email: email.to_string(),\n    })\n}\n\nfn main() {\n    let existing = vec![String::from(\"alice\"), String::from(\"bob\")];\n\n    let test_cases = vec![\n        (\"alice\", \"Password123\", \"alice@example.com\"),\n        (\"ab\", \"Password123\", \"user@example.com\"),\n        (\"newuser\", \"weak\", \"user@example.com\"),\n        (\"new_user\", \"Password123\", \"invalid-email\"),\n        (\"charlie\", \"Password123\", \"charlie@example.com\"),\n    ];\n\n    for (username, password, email) in test_cases {\n        println!(\"\\nTrying to register '{}'...\", username);\n\n        match register_user(username, password, email, &existing) {\n            Ok(user) => {\n                println!(\"âœ… Success! Registered {} with email {}\", user.username, user.email);\n            }\n            Err(e) => {\n                println!(\"âŒ Registration failed: {}\", e);\n            }\n        }\n    }\n}\n```\n\n**Output:**\n```\nTrying to register 'alice'...\nâŒ Registration failed: Username 'alice' already exists\n\nTrying to register 'ab'...\nâŒ Registration failed: Username must be at least 3 characters\n\nTrying to register 'newuser'...\nâŒ Registration failed: Password must be at least 8 characters and contain letters and numbers\n\nTrying to register 'new_user'...\nâŒ Registration failed: Email address is invalid\n\nTrying to register 'charlie'...\nâœ… Success! Registered charlie with email charlie@example.com\n```\n\n## Hands-On Practice\n\n```bash\ncargo new custom_errors\ncd custom_errors\ncode .\n```\n\n### **Experiment 1: Basic Custom Error**\n\n```rust\n#[derive(Debug)]\nenum CalculatorError {\n    DivideByZero,\n    Overflow,\n}\n\nfn safe_divide(a: i32, b: i32) -> Result<i32, CalculatorError> {\n    if b == 0 {\n        return Err(CalculatorError::DivideByZero);\n    }\n\n    Ok(a / b)\n}\n\nfn main() {\n    match safe_divide(10, 0) {\n        Ok(result) => println!(\"Result: {}\", result),\n        Err(CalculatorError::DivideByZero) => println!(\"Cannot divide by zero\"),\n        Err(CalculatorError::Overflow) => println!(\"Overflow occurred\"),\n    }\n}\n```\n\n### **Experiment 2: Error with Data**\n\n```rust\nuse std::fmt;\n\n#[derive(Debug)]\nstruct RangeError {\n    value: i32,\n    min: i32,\n    max: i32,\n}\n\nimpl fmt::Display for RangeError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"Value {} out of range ({} to {})\",\n            self.value, self.min, self.max\n        )\n    }\n}\n\nfn check_range(value: i32, min: i32, max: i32) -> Result<i32, RangeError> {\n    if value < min || value > max {\n        Err(RangeError { value, min, max })\n    } else {\n        Ok(value)\n    }\n}\n\nfn main() {\n    match check_range(150, 0, 100) {\n        Ok(v) => println!(\"Value {} is valid\", v),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\n### **Challenge: File Operations with Custom Errors**\n\n```rust\nuse std::error::Error;\nuse std::fmt;\nuse std::fs;\nuse std::io;\n\n#[derive(Debug)]\nenum FileOpError {\n    NotFound(String),\n    PermissionDenied(String),\n    TooLarge { path: String, size: u64, max: u64 },\n    IoError(io::Error),\n}\n\nimpl fmt::Display for FileOpError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            FileOpError::NotFound(path) => write!(f, \"File not found: {}\", path),\n            FileOpError::PermissionDenied(path) => {\n                write!(f, \"Permission denied: {}\", path)\n            }\n            FileOpError::TooLarge { path, size, max } => {\n                write!(\n                    f,\n                    \"File {} too large ({} bytes, max {} bytes)\",\n                    path, size, max\n                )\n            }\n            FileOpError::IoError(e) => write!(f, \"IO error: {}\", e),\n        }\n    }\n}\n\nimpl Error for FileOpError {}\n\nimpl From<io::Error> for FileOpError {\n    fn from(error: io::Error) -> Self {\n        FileOpError::IoError(error)\n    }\n}\n\nfn read_small_file(path: &str, max_size: u64) -> Result<String, FileOpError> {\n    let metadata = fs::metadata(path)?;\n    let size = metadata.len();\n\n    if size > max_size {\n        return Err(FileOpError::TooLarge {\n            path: path.to_string(),\n            size,\n            max: max_size,\n        });\n    }\n\n    let content = fs::read_to_string(path)?;\n    Ok(content)\n}\n\nfn main() {\n    // Create a test file\n    fs::write(\"test.txt\", \"Hello, Rust!\").expect(\"Failed to create test file\");\n\n    match read_small_file(\"test.txt\", 100) {\n        Ok(content) => println!(\"File content: {}\", content),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n\n    match read_small_file(\"test.txt\", 5) {\n        Ok(content) => println!(\"File content: {}\", content),\n        Err(e) => println!(\"Error: {}\", e),  // File too large\n    }\n\n    match read_small_file(\"nonexistent.txt\", 100) {\n        Ok(content) => println!(\"File content: {}\", content),\n        Err(e) => println!(\"Error: {}\", e),  // File not found\n    }\n}\n```\n\n## Key Takeaways\n\n- âœ… Custom error enums provide specific, type-safe error handling\n- âœ… Error variants can hold data for detailed error information\n- âœ… Implement `Display` trait for user-friendly error messages\n- âœ… Implement `Error` trait to work with `Box<dyn Error>`\n- âœ… Implement `From` trait to enable automatic error conversion with `?`\n- âœ… Custom errors make code self-documenting\n- âœ… Pattern matching on errors allows specific error handling\n- âœ… Error enums are more idiomatic than Strings\n- âœ… Wrapping other error types creates application-specific errors\n- âœ… Error types should be meaningful and actionable\n\n**Next**: Practice project bringing all error handling techniques together!\n\n---\n\n**Progress**: Module 6, Lesson 4 complete (37/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-06-05",
          "title": "Module 6, Lesson 5: Practice Project â€” Building a File Validator",
          "type": "project",
          "estimatedMinutes": 10,
          "difficulty": "intermediate",
          "content": {
            "format": "markdown",
            "body": "# Module 6, Lesson 5: Practice Project â€” Building a File Validator\n\n## Project Overview\n\nBuild a professional file validation system that demonstrates all error handling techniques!\n\n**What we're building:**\n- Validate file existence, size, format\n- Parse and validate file contents\n- Comprehensive error reporting\n- Clean error propagation with `?`\n\n**Skills practiced:**\n- âœ… `Option<T>` for optional values\n- âœ… `Result<T, E>` for operations that can fail\n- âœ… The `?` operator for clean error propagation\n- âœ… Custom error types with detailed information\n- âœ… Error conversion with `From` trait\n- âœ… All error handling patterns working together\n\n## The Complete Project\n\n### **Step 1: Create the Project**\n\n```bash\ncargo new file_validator\ncd file_validator\ncode .\n```\n\n### **Step 2: Build the Validator (Complete Code)**\n\n```rust\nuse std::error::Error;\nuse std::fmt;\nuse std::fs;\nuse std::io;\nuse std::path::Path;\n\n// ===== Custom Error Types =====\n\n#[derive(Debug)]\nenum ValidationError {\n    FileNotFound(String),\n    FileTooLarge { path: String, size: u64, max: u64 },\n    FileTooSmall { path: String, size: u64, min: u64 },\n    InvalidExtension { path: String, expected: Vec<String> },\n    EmptyFile(String),\n    InvalidFormat(String),\n    ParseError { line: usize, reason: String },\n    IoError(io::Error),\n}\n\nimpl fmt::Display for ValidationError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            ValidationError::FileNotFound(path) => {\n                write!(f, \"File not found: {}\", path)\n            }\n            ValidationError::FileTooLarge { path, size, max } => {\n                write!(f, \"File '{}' is too large: {} bytes (max: {})\", path, size, max)\n            }\n            ValidationError::FileTooSmall { path, size, min } => {\n                write!(f, \"File '{}' is too small: {} bytes (min: {})\", path, size, min)\n            }\n            ValidationError::InvalidExtension { path, expected } => {\n                write!(\n                    f,\n                    \"File '{}' has wrong extension. Expected: {:?}\",\n                    path, expected\n                )\n            }\n            ValidationError::EmptyFile(path) => {\n                write!(f, \"File '{}' is empty\", path)\n            }\n            ValidationError::InvalidFormat(msg) => {\n                write!(f, \"Invalid format: {}\", msg)\n            }\n            ValidationError::ParseError { line, reason } => {\n                write!(f, \"Parse error at line {}: {}\", line, reason)\n            }\n            ValidationError::IoError(e) => {\n                write!(f, \"IO error: {}\", e)\n            }\n        }\n    }\n}\n\nimpl Error for ValidationError {}\n\nimpl From<io::Error> for ValidationError {\n    fn from(error: io::Error) -> Self {\n        ValidationError::IoError(error)\n    }\n}\n\n// ===== Validation Rules =====\n\nstruct ValidationRules {\n    allowed_extensions: Vec<String>,\n    min_size: u64,\n    max_size: u64,\n    require_header: Option<String>,\n}\n\nimpl ValidationRules {\n    fn for_csv() -> Self {\n        ValidationRules {\n            allowed_extensions: vec![String::from(\"csv\")],\n            min_size: 1,\n            max_size: 10_000_000,  // 10 MB\n            require_header: Some(String::from(\"name,age,email\")),\n        }\n    }\n\n    fn for_text() -> Self {\n        ValidationRules {\n            allowed_extensions: vec![String::from(\"txt\"), String::from(\"md\")],\n            min_size: 1,\n            max_size: 1_000_000,  // 1 MB\n            require_header: None,\n        }\n    }\n}\n\n// ===== File Validator =====\n\nstruct FileValidator {\n    path: String,\n    rules: ValidationRules,\n}\n\nimpl FileValidator {\n    fn new(path: &str, rules: ValidationRules) -> Self {\n        FileValidator {\n            path: path.to_string(),\n            rules,\n        }\n    }\n\n    fn validate(&self) -> Result<ValidationReport, ValidationError> {\n        // Check existence\n        self.check_exists()?;\n\n        // Check size\n        let size = self.check_size()?;\n\n        // Check extension\n        self.check_extension()?;\n\n        // Read and validate content\n        let content = self.read_content()?;\n        let line_count = self.validate_content(&content)?;\n\n        Ok(ValidationReport {\n            path: self.path.clone(),\n            size,\n            line_count,\n            status: String::from(\"Valid\"),\n        })\n    }\n\n    fn check_exists(&self) -> Result<(), ValidationError> {\n        if !Path::new(&self.path).exists() {\n            return Err(ValidationError::FileNotFound(self.path.clone()));\n        }\n        Ok(())\n    }\n\n    fn check_size(&self) -> Result<u64, ValidationError> {\n        let metadata = fs::metadata(&self.path)?;\n        let size = metadata.len();\n\n        if size == 0 {\n            return Err(ValidationError::EmptyFile(self.path.clone()));\n        }\n\n        if size < self.rules.min_size {\n            return Err(ValidationError::FileTooSmall {\n                path: self.path.clone(),\n                size,\n                min: self.rules.min_size,\n            });\n        }\n\n        if size > self.rules.max_size {\n            return Err(ValidationError::FileTooLarge {\n                path: self.path.clone(),\n                size,\n                max: self.rules.max_size,\n            });\n        }\n\n        Ok(size)\n    }\n\n    fn check_extension(&self) -> Result<(), ValidationError> {\n        let path = Path::new(&self.path);\n\n        let extension = path\n            .extension()\n            .and_then(|ext| ext.to_str())\n            .map(|s| s.to_lowercase());\n\n        match extension {\n            Some(ext) => {\n                if !self.rules.allowed_extensions.contains(&ext) {\n                    return Err(ValidationError::InvalidExtension {\n                        path: self.path.clone(),\n                        expected: self.rules.allowed_extensions.clone(),\n                    });\n                }\n                Ok(())\n            }\n            None => Err(ValidationError::InvalidExtension {\n                path: self.path.clone(),\n                expected: self.rules.allowed_extensions.clone(),\n            }),\n        }\n    }\n\n    fn read_content(&self) -> Result<String, ValidationError> {\n        let content = fs::read_to_string(&self.path)?;\n        Ok(content)\n    }\n\n    fn validate_content(&self, content: &str) -> Result<usize, ValidationError> {\n        let lines: Vec<&str> = content.lines().collect();\n\n        if lines.is_empty() {\n            return Err(ValidationError::EmptyFile(self.path.clone()));\n        }\n\n        // Check header if required\n        if let Some(expected_header) = &self.rules.require_header {\n            let actual_header = lines[0].trim();\n            if actual_header != expected_header {\n                return Err(ValidationError::InvalidFormat(format!(\n                    \"Expected header: {}, got: {}\",\n                    expected_header, actual_header\n                )));\n            }\n        }\n\n        Ok(lines.len())\n    }\n}\n\n// ===== Validation Report =====\n\n#[derive(Debug)]\nstruct ValidationReport {\n    path: String,\n    size: u64,\n    line_count: usize,\n    status: String,\n}\n\nimpl ValidationReport {\n    fn print(&self) {\n        println!(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\");\n        println!(\"â•‘       File Validation Report          â•‘\");\n        println!(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\");\n        println!(\"â•‘ File: {:30} â•‘\", self.path);\n        println!(\"â•‘ Size: {:30} bytes â•‘\", self.size);\n        println!(\"â•‘ Lines: {:29} â•‘\", self.line_count);\n        println!(\"â•‘ Status: {:28} â•‘\", self.status);\n        println!(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n    }\n}\n\n// ===== CSV Parser =====\n\n#[derive(Debug)]\nstruct Person {\n    name: String,\n    age: u32,\n    email: String,\n}\n\nimpl Person {\n    fn from_csv_line(line: &str, line_num: usize) -> Result<Self, ValidationError> {\n        let parts: Vec<&str> = line.split(',').collect();\n\n        if parts.len() != 3 {\n            return Err(ValidationError::ParseError {\n                line: line_num,\n                reason: format!(\"Expected 3 fields, got {}\", parts.len()),\n            });\n        }\n\n        let name = parts[0].trim().to_string();\n        if name.is_empty() {\n            return Err(ValidationError::ParseError {\n                line: line_num,\n                reason: String::from(\"Name cannot be empty\"),\n            });\n        }\n\n        let age = parts[1]\n            .trim()\n            .parse::<u32>()\n            .map_err(|_| ValidationError::ParseError {\n                line: line_num,\n                reason: format!(\"Invalid age: {}\", parts[1]),\n            })?;\n\n        let email = parts[2].trim().to_string();\n        if !email.contains('@') {\n            return Err(ValidationError::ParseError {\n                line: line_num,\n                reason: format!(\"Invalid email: {}\", email),\n            });\n        }\n\n        Ok(Person { name, age, email })\n    }\n}\n\nfn parse_csv_file(path: &str) -> Result<Vec<Person>, ValidationError> {\n    let content = fs::read_to_string(path)?;\n    let mut people = Vec::new();\n\n    for (i, line) in content.lines().enumerate() {\n        if i == 0 {\n            continue;  // Skip header\n        }\n\n        if line.trim().is_empty() {\n            continue;  // Skip empty lines\n        }\n\n        let person = Person::from_csv_line(line, i + 1)?;\n        people.push(person);\n    }\n\n    Ok(people)\n}\n\n// ===== Main Program =====\n\nfn main() -> Result<(), Box<dyn Error>> {\n    println!(\"=== File Validator Demo ===\\n\");\n\n    // Create test files\n    create_test_files()?;\n\n    // Test 1: Valid CSV file\n    println!(\"Test 1: Validating valid CSV file\");\n    validate_and_report(\"data.csv\", ValidationRules::for_csv());\n\n    // Test 2: Invalid CSV (wrong header)\n    println!(\"\\nTest 2: Validating CSV with wrong header\");\n    validate_and_report(\"bad_header.csv\", ValidationRules::for_csv());\n\n    // Test 3: File too large\n    println!(\"\\nTest 3: Validating file that's too large\");\n    let mut rules = ValidationRules::for_text();\n    rules.max_size = 10;  // Set very low limit\n    validate_and_report(\"large.txt\", rules);\n\n    // Test 4: Non-existent file\n    println!(\"\\nTest 4: Validating non-existent file\");\n    validate_and_report(\"missing.csv\", ValidationRules::for_csv());\n\n    // Test 5: Parse CSV and display\n    println!(\"\\nTest 5: Parsing and displaying CSV data\");\n    match parse_csv_file(\"data.csv\") {\n        Ok(people) => {\n            println!(\"âœ… Successfully parsed {} people:\", people.len());\n            for person in people {\n                println!(\"  - {} ({} years old) - {}\", person.name, person.age, person.email);\n            }\n        }\n        Err(e) => println!(\"âŒ Error: {}\", e),\n    }\n\n    Ok(())\n}\n\nfn validate_and_report(path: &str, rules: ValidationRules) {\n    let validator = FileValidator::new(path, rules);\n\n    match validator.validate() {\n        Ok(report) => {\n            println!(\"âœ… Validation successful!\");\n            report.print();\n        }\n        Err(e) => {\n            println!(\"âŒ Validation failed: {}\", e);\n        }\n    }\n}\n\nfn create_test_files() -> Result<(), Box<dyn Error>> {\n    // Valid CSV\n    fs::write(\n        \"data.csv\",\n        \"name,age,email\\nAlice,30,alice@example.com\\nBob,25,bob@example.com\\nCharlie,35,charlie@example.com\",\n    )?;\n\n    // CSV with wrong header\n    fs::write(\n        \"bad_header.csv\",\n        \"username,years,contact\\nAlice,30,alice@example.com\",\n    )?;\n\n    // Large text file\n    fs::write(\"large.txt\", \"This is a test file with some content.\")?;\n\n    Ok(())\n}\n```\n\n### **Step 3: Run the Project**\n\n```bash\ncargo run\n```\n\n**Expected output:**\n\n```\n=== File Validator Demo ===\n\nTest 1: Validating valid CSV file\nâœ… Validation successful!\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘       File Validation Report          â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘ File: data.csv                         â•‘\nâ•‘ Size: 104                        bytes â•‘\nâ•‘ Lines: 4                               â•‘\nâ•‘ Status: Valid                          â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nTest 2: Validating CSV with wrong header\nâŒ Validation failed: Invalid format: Expected header: name,age,email, got: username,years,contact\n\nTest 3: Validating file that's too large\nâŒ Validation failed: File 'large.txt' is too large: 39 bytes (max: 10)\n\nTest 4: Validating non-existent file\nâŒ Validation failed: File not found: missing.csv\n\nTest 5: Parsing and displaying CSV data\nâœ… Successfully parsed 3 people:\n  - Alice (30 years old) - alice@example.com\n  - Bob (25 years old) - bob@example.com\n  - Charlie (35 years old) - charlie@example.com\n```\n\n## Understanding the Code\n\n### **Custom Error Enum**\n\n```rust\n#[derive(Debug)]\nenum ValidationError {\n    FileNotFound(String),\n    FileTooLarge { path: String, size: u64, max: u64 },\n    // ... more variants with contextual data\n}\n```\n\n**Why**: Provides specific, actionable error information.\n\n### **Error Conversion**\n\n```rust\nimpl From<io::Error> for ValidationError {\n    fn from(error: io::Error) -> Self {\n        ValidationError::IoError(error)\n    }\n}\n```\n\n**Why**: Enables `?` operator to work with different error types.\n\n### **Clean Error Propagation**\n\n```rust\nfn validate(&self) -> Result<ValidationReport, ValidationError> {\n    self.check_exists()?;         // Return error if fails\n    let size = self.check_size()?; // Unwrap if succeeds\n    self.check_extension()?;\n    // ... continue\n}\n```\n\n**Why**: Clean, readable code without nested match statements.\n\n### **Option to Result Conversion**\n\n```rust\nlet extension = path\n    .extension()\n    .and_then(|ext| ext.to_str())\n    .map(|s| s.to_lowercase());\n\nmatch extension {\n    Some(ext) => { /* validate */ },\n    None => Err(ValidationError::InvalidExtension { /* ... */ }),\n}\n```\n\n**Why**: Safely handle potentially missing values.\n\n## Challenges and Extensions\n\n### **Challenge 1: Add JSON Validation**\n\n```rust\n// Add to Cargo.toml:\n// [dependencies]\n// serde_json = \"1.0\"\n\nuse serde_json::Value;\n\nimpl ValidationRules {\n    fn for_json() -> Self {\n        ValidationRules {\n            allowed_extensions: vec![String::from(\"json\")],\n            min_size: 2,  // At least \"{}\"\n            max_size: 5_000_000,\n            require_header: None,\n        }\n    }\n}\n\nfn validate_json(path: &str) -> Result<(), ValidationError> {\n    let content = fs::read_to_string(path)?;\n\n    serde_json::from_str::<Value>(&content)\n        .map_err(|e| ValidationError::InvalidFormat(format!(\"Invalid JSON: {}\", e)))?;\n\n    Ok(())\n}\n```\n\n### **Challenge 2: Batch Validation**\n\n```rust\nfn validate_multiple(paths: Vec<&str>, rules: ValidationRules) -> Vec<Result<ValidationReport, ValidationError>> {\n    paths\n        .into_iter()\n        .map(|path| FileValidator::new(path, &rules).validate())\n        .collect()\n}\n\nfn main() {\n    let files = vec![\"file1.csv\", \"file2.csv\", \"file3.csv\"];\n    let results = validate_multiple(files, ValidationRules::for_csv());\n\n    for (i, result) in results.iter().enumerate() {\n        match result {\n            Ok(report) => println!(\"âœ… File {}: Valid\", i + 1),\n            Err(e) => println!(\"âŒ File {}: {}\", i + 1, e),\n        }\n    }\n}\n```\n\n### **Challenge 3: Warning System**\n\n```rust\n#[derive(Debug)]\nenum Warning {\n    LargeFile(u64),\n    ManyLines(usize),\n    OldFormat,\n}\n\nstruct ValidationReport {\n    path: String,\n    size: u64,\n    line_count: usize,\n    status: String,\n    warnings: Vec<Warning>,  // Add warnings\n}\n\nimpl FileValidator {\n    fn generate_warnings(&self, size: u64, line_count: usize) -> Vec<Warning> {\n        let mut warnings = Vec::new();\n\n        if size > 5_000_000 {\n            warnings.push(Warning::LargeFile(size));\n        }\n\n        if line_count > 10_000 {\n            warnings.push(Warning::ManyLines(line_count));\n        }\n\n        warnings\n    }\n}\n```\n\n### **Challenge 4: Progress Reporting**\n\n```rust\nuse std::sync::mpsc;\nuse std::thread;\n\nfn validate_with_progress(paths: Vec<String>) {\n    let (tx, rx) = mpsc::channel();\n    let total = paths.len();\n\n    thread::spawn(move || {\n        for (i, path) in paths.iter().enumerate() {\n            let validator = FileValidator::new(path, ValidationRules::for_csv());\n            let result = validator.validate();\n\n            tx.send((i + 1, total, result)).unwrap();\n        }\n    });\n\n    for (current, total, result) in rx {\n        println!(\"Progress: {}/{}\", current, total);\n        match result {\n            Ok(_) => println!(\"  âœ… Valid\"),\n            Err(e) => println!(\"  âŒ Error: {}\", e),\n        }\n    }\n}\n```\n\n## Key Takeaways\n\n- âœ… Custom error enums provide detailed, specific error information\n- âœ… `From` trait enables seamless error conversion with `?`\n- âœ… The `?` operator creates clean, readable error handling code\n- âœ… Pattern matching on custom errors allows specific handling\n- âœ… `Display` trait implementation provides user-friendly messages\n- âœ… Combining `Option` and `Result` handles optional and fallible operations\n- âœ… Error context (line numbers, file names) makes debugging easier\n- âœ… Validation rules encapsulate reusable logic\n- âœ… Comprehensive error handling is the foundation of robust applications\n- âœ… All error handling techniques work together seamlessly\n\n---\n\n## âœ… Module 6 Complete!\n\nYou've mastered Rust error handling:\n- âœ… `Option<T>` for values that might not exist\n- âœ… `Result<T, E>` for operations that can fail\n- âœ… The `?` operator for clean error propagation\n- âœ… Custom error types for specific, actionable errors\n- âœ… Built a professional file validation system!\n\n**Next: Module 7 â€” File I/O and Command-Line Arguments**\n\nTotal Progress: 38 lessons complete (~63%)\n\n---\n\n[â† Back to Module 6](README.md) | [Continue to Module 7 â†’](../module_07_file_io/)\n"
          }
        }
      ]
    },
    {
      "id": "module-07",
      "title": "MODULE 07",
      "description": "Module 7",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-07-01",
          "title": "Module 7, Lesson 1: Receiving Instructions from Users â€” Command-Line Arguments",
          "type": "project",
          "estimatedMinutes": 8,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 7, Lesson 1: Receiving Instructions from Users â€” Command-Line Arguments\n\n## The Concept: Restaurant Order\n\nImagine a restaurant:\n- **No input**: Kitchen makes default meal\n- **With order**: Kitchen makes what you requested: \"burger\", \"fries\", \"large\"\n\n**Command-line arguments** let users specify what they want your program to do.\n\n## What Are Command-Line Arguments?\n\nWhen you run a program from the terminal, you can pass values:\n\n```bash\ncargo run hello world 123\n```\n\n- `hello`, `world`, `123` are **arguments**\n- Your program can read and use them\n\n## Reading Arguments with std::env\n\n```rust\nuse std::env;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    println!(\"Arguments:\");\n    for (i, arg) in args.iter().enumerate() {\n        println!(\"{}: {}\", i, arg);\n    }\n}\n```\n\n**Run it:**\n```bash\ncargo run hello world\n```\n\n**Output:**\n```\nArguments:\n0: target/debug/your_program\n1: hello\n2: world\n```\n\n**Important**: Argument 0 is always the program name/path!\n\n## Accessing Specific Arguments\n\n```rust\nuse std::env;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    if args.len() < 2 {\n        println!(\"Please provide a name\");\n        return;\n    }\n\n    let name = &args[1];\n    println!(\"Hello, {}!\", name);\n}\n```\n\n**Run:**\n```bash\ncargo run Alice\n```\n\n**Output:**\n```\nHello, Alice!\n```\n\n## Handling Multiple Arguments\n\n```rust\nuse std::env;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    if args.len() < 3 {\n        println!(\"Usage: {} <command> <value>\", args[0]);\n        return;\n    }\n\n    let command = &args[1];\n    let value = &args[2];\n\n    match command.as_str() {\n        \"greet\" => println!(\"Hello, {}!\", value),\n        \"repeat\" => {\n            if let Ok(count) = value.parse::<usize>() {\n                for i in 1..=count {\n                    println!(\"{}. Message\", i);\n                }\n            } else {\n                println!(\"Error: '{}' is not a valid number\", value);\n            }\n        }\n        _ => println!(\"Unknown command: {}\", command),\n    }\n}\n```\n\n**Run:**\n```bash\ncargo run greet World\ncargo run repeat 3\ncargo run unknown test\n```\n\n**Output:**\n```\nHello, World!\n1. Message\n2. Message\n3. Message\nUnknown command: unknown\n```\n\n## Better Argument Parsing with clap\n\nFor real applications, use the `clap` crate (most popular CLI parser):\n\n### **Step 1: Add clap to Cargo.toml**\n\n```toml\n[dependencies]\nclap = { version = \"4.5\", features = [\"derive\"] }\n```\n\n### **Step 2: Use clap**\n\n```rust\nuse clap::Parser;\n\n/// Simple greeting program\n#[derive(Parser)]\n#[command(name = \"greeter\")]\n#[command(about = \"Greets people\", long_about = None)]\nstruct Args {\n    /// Name of the person to greet\n    #[arg(short, long)]\n    name: String,\n\n    /// Number of times to greet\n    #[arg(short, long, default_value_t = 1)]\n    count: usize,\n}\n\nfn main() {\n    let args = Args::parse();\n\n    for _ in 0..args.count {\n        println!(\"Hello, {}!\", args.name);\n    }\n}\n```\n\n**Run with different options:**\n```bash\ncargo run -- --name Alice\ncargo run -- --name Bob --count 3\ncargo run -- -n Charlie -c 2\ncargo run -- --help\n```\n\n**Output:**\n```\nHello, Alice!\n\nHello, Bob!\nHello, Bob!\nHello, Bob!\n\nHello, Charlie!\nHello, Charlie!\n\nSimple greeting program\n\nUsage: greeter --name <NAME> [--count <COUNT>]\n\nOptions:\n  -n, --name <NAME>     Name of the person to greet\n  -c, --count <COUNT>   Number of times to greet [default: 1]\n  -h, --help            Print help\n```\n\n## Hands-On Practice\n\n```bash\ncargo new cli_args\ncd cli_args\ncode .\n```\n\n### **Experiment 1: Basic Arguments**\n\n```rust\nuse std::env;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    println!(\"Program: {}\", args[0]);\n    println!(\"Total arguments: {}\", args.len() - 1);\n\n    for (i, arg) in args.iter().skip(1).enumerate() {\n        println!(\"Arg {}: {}\", i + 1, arg);\n    }\n}\n```\n\n### **Experiment 2: Calculator**\n\n```rust\nuse std::env;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    if args.len() != 4 {\n        println!(\"Usage: {} <num1> <operator> <num2>\", args[0]);\n        println!(\"Example: {} 10 + 5\", args[0]);\n        return;\n    }\n\n    let num1: f64 = match args[1].parse() {\n        Ok(n) => n,\n        Err(_) => {\n            println!(\"Error: '{}' is not a valid number\", args[1]);\n            return;\n        }\n    };\n\n    let operator = &args[2];\n\n    let num2: f64 = match args[3].parse() {\n        Ok(n) => n,\n        Err(_) => {\n            println!(\"Error: '{}' is not a valid number\", args[3]);\n            return;\n        }\n    };\n\n    let result = match operator.as_str() {\n        \"+\" => num1 + num2,\n        \"-\" => num1 - num2,\n        \"*\" => num1 * num2,\n        \"/\" => {\n            if num2 == 0.0 {\n                println!(\"Error: Division by zero\");\n                return;\n            }\n            num1 / num2\n        }\n        _ => {\n            println!(\"Error: Unknown operator '{}'\", operator);\n            return;\n        }\n    };\n\n    println!(\"{} {} {} = {}\", num1, operator, num2, result);\n}\n```\n\n**Run:**\n```bash\ncargo run 10 + 5\ncargo run 20 - 8\ncargo run 6 \"*\" 7  # Quote * to prevent shell expansion\ncargo run 15 / 3\n```\n\n### **Experiment 3: File Operation CLI**\n\n```rust\nuse std::env;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    if args.len() < 2 {\n        print_usage(&args[0]);\n        return;\n    }\n\n    let command = &args[1];\n\n    match command.as_str() {\n        \"count\" => {\n            if args.len() != 3 {\n                println!(\"Usage: {} count <text>\", args[0]);\n                return;\n            }\n            let text = &args[2];\n            println!(\"Characters: {}\", text.len());\n            println!(\"Words: {}\", text.split_whitespace().count());\n        }\n        \"reverse\" => {\n            if args.len() != 3 {\n                println!(\"Usage: {} reverse <text>\", args[0]);\n                return;\n            }\n            let text = &args[2];\n            let reversed: String = text.chars().rev().collect();\n            println!(\"{}\", reversed);\n        }\n        \"upper\" => {\n            if args.len() != 3 {\n                println!(\"Usage: {} upper <text>\", args[0]);\n                return;\n            }\n            let text = &args[2];\n            println!(\"{}\", text.to_uppercase());\n        }\n        _ => {\n            println!(\"Unknown command: {}\", command);\n            print_usage(&args[0]);\n        }\n    }\n}\n\nfn print_usage(program: &str) {\n    println!(\"Usage: {} <command> [arguments]\", program);\n    println!(\"\\nCommands:\");\n    println!(\"  count <text>    Count characters and words\");\n    println!(\"  reverse <text>  Reverse text\");\n    println!(\"  upper <text>    Convert to uppercase\");\n}\n```\n\n**Run:**\n```bash\ncargo run count \"hello world\"\ncargo run reverse \"Rust\"\ncargo run upper \"hello\"\ncargo run help\n```\n\n### **Challenge: Task Manager CLI**\n\nBuild a simple task manager with commands:\n\n```rust\nuse std::env;\nuse std::fs;\n\nconst TASKS_FILE: &str = \"tasks.txt\";\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    if args.len() < 2 {\n        print_usage(&args[0]);\n        return;\n    }\n\n    let command = &args[1];\n\n    match command.as_str() {\n        \"add\" => {\n            if args.len() < 3 {\n                println!(\"Usage: {} add <task>\", args[0]);\n                return;\n            }\n            let task = args[2..].join(\" \");\n            add_task(&task);\n        }\n        \"list\" => {\n            list_tasks();\n        }\n        \"clear\" => {\n            clear_tasks();\n        }\n        _ => {\n            println!(\"Unknown command: {}\", command);\n            print_usage(&args[0]);\n        }\n    }\n}\n\nfn add_task(task: &str) {\n    let mut tasks = load_tasks();\n    tasks.push(task.to_string());\n    save_tasks(&tasks);\n    println!(\"âœ… Added: {}\", task);\n}\n\nfn list_tasks() {\n    let tasks = load_tasks();\n\n    if tasks.is_empty() {\n        println!(\"No tasks!\");\n        return;\n    }\n\n    println!(\"ðŸ“‹ Tasks:\");\n    for (i, task) in tasks.iter().enumerate() {\n        println!(\"{}. {}\", i + 1, task);\n    }\n}\n\nfn clear_tasks() {\n    fs::write(TASKS_FILE, \"\").expect(\"Failed to clear tasks\");\n    println!(\"âœ… All tasks cleared\");\n}\n\nfn load_tasks() -> Vec<String> {\n    match fs::read_to_string(TASKS_FILE) {\n        Ok(content) => content\n            .lines()\n            .filter(|line| !line.is_empty())\n            .map(|line| line.to_string())\n            .collect(),\n        Err(_) => Vec::new(),\n    }\n}\n\nfn save_tasks(tasks: &[String]) {\n    let content = tasks.join(\"\\n\");\n    fs::write(TASKS_FILE, content).expect(\"Failed to save tasks\");\n}\n\nfn print_usage(program: &str) {\n    println!(\"Usage: {} <command> [arguments]\", program);\n    println!(\"\\nCommands:\");\n    println!(\"  add <task>   Add a new task\");\n    println!(\"  list         List all tasks\");\n    println!(\"  clear        Clear all tasks\");\n}\n```\n\n**Run:**\n```bash\ncargo run add \"Learn Rust\"\ncargo run add \"Build a project\"\ncargo run list\ncargo run add \"Master error handling\"\ncargo run list\ncargo run clear\ncargo run list\n```\n\n**Output:**\n```\nâœ… Added: Learn Rust\nâœ… Added: Build a project\nðŸ“‹ Tasks:\n1. Learn Rust\n2. Build a project\nâœ… Added: Master error handling\nðŸ“‹ Tasks:\n1. Learn Rust\n2. Build a project\n3. Master error handling\nâœ… All tasks cleared\nNo tasks!\n```\n\n## Common Patterns\n\n### **Pattern 1: Argument Validation**\n\n```rust\nfn validate_args(args: &[String]) -> Result<(), String> {\n    if args.len() < 2 {\n        return Err(String::from(\"Missing required argument\"));\n    }\n\n    if args[1].is_empty() {\n        return Err(String::from(\"Argument cannot be empty\"));\n    }\n\n    Ok(())\n}\n```\n\n### **Pattern 2: Optional Arguments**\n\n```rust\nfn get_arg(args: &[String], index: usize, default: &str) -> String {\n    args.get(index)\n        .map(|s| s.clone())\n        .unwrap_or_else(|| default.to_string())\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let name = get_arg(&args, 1, \"World\");\n    println!(\"Hello, {}!\", name);\n}\n```\n\n### **Pattern 3: Flag Arguments**\n\n```rust\nfn has_flag(args: &[String], flag: &str) -> bool {\n    args.iter().any(|arg| arg == flag)\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let verbose = has_flag(&args, \"--verbose\");\n\n    if verbose {\n        println!(\"Verbose mode enabled\");\n    }\n\n    println!(\"Running program...\");\n}\n```\n\n## Key Takeaways\n\n- âœ… `std::env::args()` provides access to command-line arguments\n- âœ… First argument (index 0) is always the program name\n- âœ… Arguments are strings that may need parsing\n- âœ… Always validate argument count and values\n- âœ… Use `.parse()` to convert string arguments to numbers\n- âœ… Provide helpful error messages and usage instructions\n- âœ… Consider using `clap` crate for complex CLI tools\n- âœ… Command-line args make programs flexible and scriptable\n- âœ… Test with various argument combinations\n- âœ… Handle edge cases (missing args, invalid values, etc.)\n\n**Next**: Reading files from disk!\n\n---\n\n**Progress**: Module 7, Lesson 1 complete (39/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-07-02",
          "title": "Module 7, Lesson 2: Loading Data from Disk â€” Reading Files",
          "type": "exercise",
          "estimatedMinutes": 7,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 7, Lesson 2: Loading Data from Disk â€” Reading Files\n\n## The Concept: Opening a Book\n\nImagine reading a book:\n- **Open it**: Access the contents\n- **Read pages**: Get the text\n- **Close it**: Done automatically in Rust!\n\n**File reading** lets your program load and process data stored on disk.\n\n## The Simplest Way: read_to_string()\n\n```rust\nuse std::fs;\n\nfn main() {\n    let content = fs::read_to_string(\"hello.txt\")\n        .expect(\"Failed to read file\");\n\n    println!(\"File contents:\\n{}\", content);\n}\n```\n\n**Create hello.txt first:**\n```bash\necho \"Hello from a file!\" > hello.txt\n```\n\n**Run:**\n```bash\ncargo run\n```\n\n**Output:**\n```\nFile contents:\nHello from a file!\n```\n\n## Proper Error Handling\n\n```rust\nuse std::fs;\n\nfn main() {\n    match fs::read_to_string(\"hello.txt\") {\n        Ok(content) => {\n            println!(\"âœ… File read successfully!\");\n            println!(\"Contents:\\n{}\", content);\n        }\n        Err(error) => {\n            println!(\"âŒ Error reading file: {}\", error);\n        }\n    }\n}\n```\n\n## With the ? Operator\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\nfn read_file(path: &str) -> Result<String, Box<dyn Error>> {\n    let content = fs::read_to_string(path)?;\n    Ok(content)\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let content = read_file(\"hello.txt\")?;\n    println!(\"File contents:\\n{}\", content);\n    Ok(())\n}\n```\n\n## Reading Line by Line\n\nFor large files, read line by line:\n\n```rust\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn main() -> std::io::Result<()> {\n    let file = File::open(\"hello.txt\")?;\n    let reader = BufReader::new(file);\n\n    for (i, line) in reader.lines().enumerate() {\n        let line = line?;\n        println!(\"Line {}: {}\", i + 1, line);\n    }\n\n    Ok(())\n}\n```\n\n## Reading Binary Data\n\n```rust\nuse std::fs;\n\nfn main() -> std::io::Result<()> {\n    let bytes = fs::read(\"data.bin\")?;\n    println!(\"Read {} bytes\", bytes.len());\n\n    // Print first 10 bytes\n    for (i, byte) in bytes.iter().take(10).enumerate() {\n        println!(\"Byte {}: {:02x}\", i, byte);\n    }\n\n    Ok(())\n}\n```\n\n## Common File Operations\n\n### **Check if File Exists**\n\n```rust\nuse std::path::Path;\n\nfn main() {\n    let path = \"hello.txt\";\n\n    if Path::new(path).exists() {\n        println!(\"âœ… File exists\");\n    } else {\n        println!(\"âŒ File not found\");\n    }\n}\n```\n\n### **Get File Metadata**\n\n```rust\nuse std::fs;\n\nfn main() -> std::io::Result<()> {\n    let metadata = fs::metadata(\"hello.txt\")?;\n\n    println!(\"File size: {} bytes\", metadata.len());\n    println!(\"Is file: {}\", metadata.is_file());\n    println!(\"Is directory: {}\", metadata.is_dir());\n    println!(\"Read only: {}\", metadata.permissions().readonly());\n\n    Ok(())\n}\n```\n\n### **Read with Size Limit**\n\n```rust\nuse std::fs;\n\nfn read_small_file(path: &str, max_size: u64) -> Result<String, String> {\n    let metadata = fs::metadata(path)\n        .map_err(|e| format!(\"Cannot read metadata: {}\", e))?;\n\n    if metadata.len() > max_size {\n        return Err(format!(\n            \"File too large: {} bytes (max: {})\",\n            metadata.len(),\n            max_size\n        ));\n    }\n\n    fs::read_to_string(path).map_err(|e| format!(\"Cannot read file: {}\", e))\n}\n\nfn main() {\n    match read_small_file(\"hello.txt\", 1000) {\n        Ok(content) => println!(\"Content: {}\", content),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\n## Hands-On Practice\n\n```bash\ncargo new file_reader\ncd file_reader\ncode .\n```\n\n### **Experiment 1: Basic File Reading**\n\n```rust\nuse std::fs;\n\nfn main() {\n    // Create a test file\n    fs::write(\"test.txt\", \"Hello, Rust!\\nWelcome to file I/O.\")\n        .expect(\"Failed to create test file\");\n\n    // Read it back\n    let content = fs::read_to_string(\"test.txt\")\n        .expect(\"Failed to read test file\");\n\n    println!(\"File contents:\\n{}\", content);\n}\n```\n\n### **Experiment 2: Line Counter**\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\nfn count_lines(path: &str) -> Result<usize, Box<dyn Error>> {\n    let content = fs::read_to_string(path)?;\n    let count = content.lines().count();\n    Ok(count)\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    // Create test file with multiple lines\n    fs::write(\"lines.txt\", \"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\")?;\n\n    let count = count_lines(\"lines.txt\")?;\n    println!(\"File has {} lines\", count);\n\n    Ok(())\n}\n```\n\n### **Experiment 3: Word Counter**\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\nfn count_words(path: &str) -> Result<usize, Box<dyn Error>> {\n    let content = fs::read_to_string(path)?;\n    let count = content.split_whitespace().count();\n    Ok(count)\n}\n\nfn count_chars(path: &str) -> Result<usize, Box<dyn Error>> {\n    let content = fs::read_to_string(path)?;\n    Ok(content.len())\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let path = \"sample.txt\";\n\n    // Create test file\n    fs::write(\n        path,\n        \"The quick brown fox jumps over the lazy dog.\\nRust is awesome!\",\n    )?;\n\n    let words = count_words(path)?;\n    let chars = count_chars(path)?;\n    let lines = fs::read_to_string(path)?.lines().count();\n\n    println!(\"File statistics:\");\n    println!(\"  Lines: {}\", lines);\n    println!(\"  Words: {}\", words);\n    println!(\"  Characters: {}\", chars);\n\n    Ok(())\n}\n```\n\n### **Experiment 4: Search in File**\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\nfn search_in_file(path: &str, query: &str) -> Result<Vec<String>, Box<dyn Error>> {\n    let content = fs::read_to_string(path)?;\n    let matches: Vec<String> = content\n        .lines()\n        .filter(|line| line.contains(query))\n        .map(|line| line.to_string())\n        .collect();\n\n    Ok(matches)\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    // Create test file\n    fs::write(\n        \"data.txt\",\n        \"Rust is great\\nPython is popular\\nRust is fast\\nJava is old\\nRust is safe\",\n    )?;\n\n    let query = \"Rust\";\n    let matches = search_in_file(\"data.txt\", query)?;\n\n    println!(\"Lines containing '{}':\", query);\n    for (i, line) in matches.iter().enumerate() {\n        println!(\"{}. {}\", i + 1, line);\n    }\n\n    println!(\"\\nFound {} matching lines\", matches.len());\n\n    Ok(())\n}\n```\n\n**Output:**\n```\nLines containing 'Rust':\n1. Rust is great\n2. Rust is fast\n3. Rust is safe\n\nFound 3 matching lines\n```\n\n### **Challenge: Log File Analyzer**\n\nBuild a log file analyzer:\n\n```rust\nuse std::error::Error;\nuse std::fs;\n\n#[derive(Debug)]\nstruct LogStats {\n    total_lines: usize,\n    error_count: usize,\n    warning_count: usize,\n    info_count: usize,\n}\n\nfn analyze_log(path: &str) -> Result<LogStats, Box<dyn Error>> {\n    let content = fs::read_to_string(path)?;\n    let lines: Vec<&str> = content.lines().collect();\n\n    let total_lines = lines.len();\n    let error_count = lines.iter().filter(|line| line.contains(\"ERROR\")).count();\n    let warning_count = lines.iter().filter(|line| line.contains(\"WARN\")).count();\n    let info_count = lines.iter().filter(|line| line.contains(\"INFO\")).count();\n\n    Ok(LogStats {\n        total_lines,\n        error_count,\n        warning_count,\n        info_count,\n    })\n}\n\nfn find_errors(path: &str) -> Result<Vec<String>, Box<dyn Error>> {\n    let content = fs::read_to_string(path)?;\n    let errors: Vec<String> = content\n        .lines()\n        .filter(|line| line.contains(\"ERROR\"))\n        .map(|line| line.to_string())\n        .collect();\n\n    Ok(errors)\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    // Create sample log file\n    let log_content = \"\\\n[2024-01-01 10:00:00] INFO: Application started\n[2024-01-01 10:01:00] INFO: User logged in\n[2024-01-01 10:02:00] WARN: High memory usage\n[2024-01-01 10:03:00] ERROR: Database connection failed\n[2024-01-01 10:04:00] INFO: Retrying connection\n[2024-01-01 10:05:00] ERROR: Authentication failed for user john\n[2024-01-01 10:06:00] WARN: Disk space low\n[2024-01-01 10:07:00] INFO: Task completed successfully\n[2024-01-01 10:08:00] ERROR: File not found: data.csv\n[2024-01-01 10:09:00] INFO: Application shutdown\n\";\n\n    fs::write(\"app.log\", log_content)?;\n\n    // Analyze log\n    let stats = analyze_log(\"app.log\")?;\n\n    println!(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\");\n    println!(\"â•‘        Log File Analysis          â•‘\");\n    println!(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\");\n    println!(\"â•‘ Total lines:    {:17} â•‘\", stats.total_lines);\n    println!(\"â•‘ INFO messages:  {:17} â•‘\", stats.info_count);\n    println!(\"â•‘ WARN messages:  {:17} â•‘\", stats.warning_count);\n    println!(\"â•‘ ERROR messages: {:17} â•‘\", stats.error_count);\n    println!(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n\n    // Show errors\n    if stats.error_count > 0 {\n        println!(\"\\nðŸš¨ Errors found:\");\n        let errors = find_errors(\"app.log\")?;\n        for (i, error) in errors.iter().enumerate() {\n            println!(\"{}. {}\", i + 1, error);\n        }\n    }\n\n    Ok(())\n}\n```\n\n**Output:**\n```\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘        Log File Analysis          â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘ Total lines:                   10 â•‘\nâ•‘ INFO messages:                  4 â•‘\nâ•‘ WARN messages:                  2 â•‘\nâ•‘ ERROR messages:                 3 â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸš¨ Errors found:\n1. [2024-01-01 10:03:00] ERROR: Database connection failed\n2. [2024-01-01 10:05:00] ERROR: Authentication failed for user john\n3. [2024-01-01 10:08:00] ERROR: File not found: data.csv\n```\n\n## Performance Considerations\n\n### **When to Use read_to_string()**\n\n```rust\n// âœ… Good for small to medium files (< 100 MB)\nlet content = fs::read_to_string(\"config.json\")?;\n```\n\n### **When to Use BufReader**\n\n```rust\n// âœ… Good for large files or when you need line-by-line processing\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nlet file = File::open(\"huge_log.txt\")?;\nlet reader = BufReader::new(file);\n\nfor line in reader.lines() {\n    let line = line?;\n    // Process each line without loading entire file\n}\n```\n\n## Error Handling Best Practices\n\n### **Specific Error Messages**\n\n```rust\nuse std::fs;\n\nfn read_config(path: &str) -> Result<String, String> {\n    fs::read_to_string(path).map_err(|e| {\n        format!(\"Failed to read config file '{}': {}\", path, e)\n    })\n}\n\nfn main() {\n    match read_config(\"config.toml\") {\n        Ok(content) => println!(\"Config loaded\"),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n```\n\n### **Fallback to Defaults**\n\n```rust\nuse std::fs;\n\nfn load_or_default(path: &str, default: &str) -> String {\n    fs::read_to_string(path).unwrap_or_else(|_| default.to_string())\n}\n\nfn main() {\n    let config = load_or_default(\"config.txt\", \"default config\");\n    println!(\"Using config: {}\", config);\n}\n```\n\n## Key Takeaways\n\n- âœ… `fs::read_to_string(path)` reads entire file as String\n- âœ… `fs::read(path)` reads file as bytes (`Vec<u8>`)\n- âœ… Use `BufReader` for large files or line-by-line reading\n- âœ… Always handle errors when reading files\n- âœ… Use `Path::new(path).exists()` to check file existence\n- âœ… Use `fs::metadata()` to get file information\n- âœ… The `?` operator makes error propagation clean\n- âœ… Consider file size and memory when choosing read method\n- âœ… Provide specific error messages for better debugging\n- âœ… Test with missing files and invalid paths\n\n**Next**: Writing data to files!\n\n---\n\n**Progress**: Module 7, Lesson 2 complete (40/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-07-03",
          "title": "Module 7, Lesson 3: Saving Data to Disk â€” Writing Files",
          "type": "project",
          "estimatedMinutes": 8,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 7, Lesson 3: Saving Data to Disk â€” Writing Files\n\n## The Concept: Writing in a Notebook\n\nImagine a notebook:\n- **Write on blank page**: Create new content\n- **Add to existing page**: Append more content\n- **Erase and rewrite**: Overwrite existing content\n\n**File writing** lets your program save data persistently to disk.\n\n## The Simplest Way: write()\n\n```rust\nuse std::fs;\n\nfn main() -> std::io::Result<()> {\n    fs::write(\"output.txt\", \"Hello, file system!\")?;\n    println!(\"âœ… File written successfully!\");\n    Ok(())\n}\n```\n\n**This creates or overwrites the file!**\n\n## Writing Multiple Times\n\n```rust\nuse std::fs;\n\nfn main() -> std::io::Result<()> {\n    // First write (creates file)\n    fs::write(\"log.txt\", \"Application started\\n\")?;\n\n    // Second write (OVERWRITES file)\n    fs::write(\"log.txt\", \"Application running\\n\")?;\n\n    // Third write (OVERWRITES again)\n    fs::write(\"log.txt\", \"Application stopped\\n\")?;\n\n    // Only last message remains!\n    let content = fs::read_to_string(\"log.txt\")?;\n    println!(\"File contains:\\n{}\", content);\n\n    Ok(())\n}\n```\n\n**Output:**\n```\nFile contains:\nApplication stopped\n```\n\n## Appending to Files\n\nTo add content without erasing, use `OpenOptions`:\n\n```rust\nuse std::fs::OpenOptions;\nuse std::io::Write;\n\nfn main() -> std::io::Result<()> {\n    // Create initial file\n    std::fs::write(\"log.txt\", \"Application started\\n\")?;\n\n    // Append more lines\n    let mut file = OpenOptions::new()\n        .append(true)\n        .open(\"log.txt\")?;\n\n    writeln!(file, \"User logged in\")?;\n    writeln!(file, \"Task completed\")?;\n    writeln!(file, \"Application stopped\")?;\n\n    println!(\"âœ… Log entries appended!\");\n\n    // Read back\n    let content = std::fs::read_to_string(\"log.txt\")?;\n    println!(\"\\nLog file:\\n{}\", content);\n\n    Ok(())\n}\n```\n\n**Output:**\n```\nâœ… Log entries appended!\n\nLog file:\nApplication started\nUser logged in\nTask completed\nApplication stopped\n```\n\n## Creating Directories\n\n```rust\nuse std::fs;\n\nfn main() -> std::io::Result<()> {\n    // Create directory\n    fs::create_dir(\"data\")?;\n    println!(\"âœ… Directory created\");\n\n    // Create nested directories\n    fs::create_dir_all(\"data/logs/2024\")?;\n    println!(\"âœ… Nested directories created\");\n\n    // Write file in directory\n    fs::write(\"data/logs/2024/app.log\", \"Log entry 1\\n\")?;\n    println!(\"âœ… File written to directory\");\n\n    Ok(())\n}\n```\n\n## Safe File Writing\n\nCheck before overwriting:\n\n```rust\nuse std::fs;\nuse std::path::Path;\n\nfn safe_write(path: &str, content: &str) -> Result<(), String> {\n    if Path::new(path).exists() {\n        return Err(format!(\"File '{}' already exists!\", path));\n    }\n\n    fs::write(path, content).map_err(|e| format!(\"Write error: {}\", e))?;\n\n    Ok(())\n}\n\nfn main() {\n    match safe_write(\"important.txt\", \"Important data\") {\n        Ok(_) => println!(\"âœ… File created\"),\n        Err(e) => println!(\"âŒ Error: {}\", e),\n    }\n\n    // Try again\n    match safe_write(\"important.txt\", \"More data\") {\n        Ok(_) => println!(\"âœ… File created\"),\n        Err(e) => println!(\"âŒ Error: {}\", e),  // Will error\n    }\n}\n```\n\n## Writing Different Data Types\n\n### **Writing Numbers**\n\n```rust\nuse std::fs;\n\nfn main() -> std::io::Result<()> {\n    let numbers = vec![1, 2, 3, 4, 5];\n\n    // Convert to string\n    let content: String = numbers\n        .iter()\n        .map(|n| n.to_string())\n        .collect::<Vec<String>>()\n        .join(\"\\n\");\n\n    fs::write(\"numbers.txt\", content)?;\n    println!(\"âœ… Numbers written\");\n\n    Ok(())\n}\n```\n\n### **Writing CSV Data**\n\n```rust\nuse std::fs;\n\nstruct Person {\n    name: String,\n    age: u32,\n    city: String,\n}\n\nfn main() -> std::io::Result<()> {\n    let people = vec![\n        Person {\n            name: String::from(\"Alice\"),\n            age: 30,\n            city: String::from(\"New York\"),\n        },\n        Person {\n            name: String::from(\"Bob\"),\n            age: 25,\n            city: String::from(\"San Francisco\"),\n        },\n        Person {\n            name: String::from(\"Charlie\"),\n            age: 35,\n            city: String::from(\"Chicago\"),\n        },\n    ];\n\n    // Create CSV content\n    let mut csv = String::from(\"name,age,city\\n\");\n\n    for person in people {\n        csv.push_str(&format!(\"{},{},{}\\n\", person.name, person.age, person.city));\n    }\n\n    fs::write(\"people.csv\", csv)?;\n    println!(\"âœ… CSV file created\");\n\n    Ok(())\n}\n```\n\n### **Writing Binary Data**\n\n```rust\nuse std::fs;\n\nfn main() -> std::io::Result<()> {\n    let data: Vec<u8> = vec![0x48, 0x65, 0x6C, 0x6C, 0x6F];  // \"Hello\" in bytes\n\n    fs::write(\"data.bin\", data)?;\n    println!(\"âœ… Binary file written\");\n\n    // Read back\n    let bytes = fs::read(\"data.bin\")?;\n    let text = String::from_utf8_lossy(&bytes);\n    println!(\"Binary content as text: {}\", text);\n\n    Ok(())\n}\n```\n\n## Hands-On Practice\n\n```bash\ncargo new file_writer\ncd file_writer\ncode .\n```\n\n### **Experiment 1: Basic Writing**\n\n```rust\nuse std::fs;\n\nfn main() -> std::io::Result<()> {\n    // Write\n    fs::write(\"greeting.txt\", \"Hello, World!\\n\")?;\n    fs::write(\"greeting.txt\", \"Welcome to Rust!\\n\")?;  // Overwrites\n\n    // Read back\n    let content = fs::read_to_string(\"greeting.txt\")?;\n    println!(\"File contains: {}\", content);\n\n    Ok(())\n}\n```\n\n### **Experiment 2: Append Logger**\n\n```rust\nuse std::fs::OpenOptions;\nuse std::io::Write;\n\nfn log_message(message: &str) -> std::io::Result<()> {\n    let mut file = OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(\"app.log\")?;\n\n    let timestamp = chrono::Local::now().format(\"%Y-%m-%d %H:%M:%S\");\n    writeln!(file, \"[{}] {}\", timestamp, message)?;\n\n    Ok(())\n}\n\nfn main() -> std::io::Result<()> {\n    log_message(\"Application started\")?;\n    log_message(\"Processing data\")?;\n    log_message(\"Task completed\")?;\n    log_message(\"Application stopped\")?;\n\n    println!(\"âœ… Log entries written\");\n\n    // Display log\n    let log = std::fs::read_to_string(\"app.log\")?;\n    println!(\"\\nðŸ“‹ Log file:\\n{}\", log);\n\n    Ok(())\n}\n```\n\n**Note**: Add chrono to Cargo.toml or use simple strings:\n```rust\nfn log_message(message: &str) -> std::io::Result<()> {\n    let mut file = OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(\"app.log\")?;\n\n    writeln!(file, \"{}\", message)?;\n    Ok(())\n}\n```\n\n### **Experiment 3: Configuration Manager**\n\n```rust\nuse std::fs;\nuse std::path::Path;\n\nfn save_config(key: &str, value: &str) -> std::io::Result<()> {\n    let config_path = \"config.txt\";\n    let mut content = String::new();\n\n    // Read existing config if it exists\n    if Path::new(config_path).exists() {\n        content = fs::read_to_string(config_path)?;\n    }\n\n    // Check if key exists\n    let lines: Vec<&str> = content.lines().collect();\n    let mut found = false;\n    let mut new_content = String::new();\n\n    for line in lines {\n        if line.starts_with(&format!(\"{}=\", key)) {\n            new_content.push_str(&format!(\"{}={}\\n\", key, value));\n            found = true;\n        } else {\n            new_content.push_str(line);\n            new_content.push('\\n');\n        }\n    }\n\n    // Add new key if not found\n    if !found {\n        new_content.push_str(&format!(\"{}={}\\n\", key, value));\n    }\n\n    fs::write(config_path, new_content)?;\n    Ok(())\n}\n\nfn load_config(key: &str) -> std::io::Result<Option<String>> {\n    let content = fs::read_to_string(\"config.txt\")?;\n\n    for line in content.lines() {\n        if line.starts_with(&format!(\"{}=\", key)) {\n            let value = line.split('=').nth(1).unwrap_or(\"\").to_string();\n            return Ok(Some(value));\n        }\n    }\n\n    Ok(None)\n}\n\nfn main() -> std::io::Result<()> {\n    // Save settings\n    save_config(\"theme\", \"dark\")?;\n    save_config(\"language\", \"en\")?;\n    save_config(\"font_size\", \"14\")?;\n\n    println!(\"âœ… Configuration saved\");\n\n    // Load settings\n    if let Some(theme) = load_config(\"theme\")? {\n        println!(\"Theme: {}\", theme);\n    }\n\n    if let Some(lang) = load_config(\"language\")? {\n        println!(\"Language: {}\", lang);\n    }\n\n    // Update setting\n    save_config(\"theme\", \"light\")?;\n    println!(\"âœ… Theme updated\");\n\n    // Display config file\n    let config = fs::read_to_string(\"config.txt\")?;\n    println!(\"\\nâš™ï¸  Config file:\\n{}\", config);\n\n    Ok(())\n}\n```\n\n### **Challenge: Note-Taking App**\n\n```rust\nuse std::fs::{self, OpenOptions};\nuse std::io::Write;\nuse std::path::Path;\n\nstruct Note {\n    title: String,\n    content: String,\n}\n\nimpl Note {\n    fn new(title: &str, content: &str) -> Self {\n        Note {\n            title: title.to_string(),\n            content: content.to_string(),\n        }\n    }\n\n    fn save(&self) -> std::io::Result<()> {\n        // Create notes directory if it doesn't exist\n        fs::create_dir_all(\"notes\")?;\n\n        // Create filename from title\n        let filename = format!(\"notes/{}.txt\", self.title.replace(' ', \"_\"));\n\n        // Write note\n        let content = format!(\"Title: {}\\n\\n{}\", self.title, self.content);\n        fs::write(&filename, content)?;\n\n        println!(\"âœ… Note '{}' saved\", self.title);\n        Ok(())\n    }\n\n    fn load(title: &str) -> std::io::Result<Option<Note>> {\n        let filename = format!(\"notes/{}.txt\", title.replace(' ', \"_\"));\n\n        if !Path::new(&filename).exists() {\n            return Ok(None);\n        }\n\n        let content = fs::read_to_string(&filename)?;\n        let lines: Vec<&str> = content.lines().collect();\n\n        if lines.is_empty() {\n            return Ok(None);\n        }\n\n        // Skip \"Title: \" line and get rest\n        let note_content = lines[2..].join(\"\\n\");\n\n        Ok(Some(Note {\n            title: title.to_string(),\n            content: note_content,\n        }))\n    }\n}\n\nfn list_notes() -> std::io::Result<()> {\n    if !Path::new(\"notes\").exists() {\n        println!(\"No notes yet!\");\n        return Ok(());\n    }\n\n    println!(\"ðŸ“ Notes:\");\n    for entry in fs::read_dir(\"notes\")? {\n        let entry = entry?;\n        let filename = entry.file_name();\n        let title = filename\n            .to_str()\n            .unwrap()\n            .replace(\".txt\", \"\")\n            .replace('_', \" \");\n\n        println!(\"  - {}\", title);\n    }\n\n    Ok(())\n}\n\nfn main() -> std::io::Result<()> {\n    // Create notes\n    let note1 = Note::new(\"Rust Tips\", \"Always handle errors with Result!\\nUse ? operator for cleaner code.\");\n    note1.save()?;\n\n    let note2 = Note::new(\"Todo\", \"1. Learn Rust\\n2. Build projects\\n3. Contribute to open source\");\n    note2.save()?;\n\n    let note3 = Note::new(\"Ideas\", \"Build a file organizer\\nCreate a CLI tool\\nWrite a web server\");\n    note3.save()?;\n\n    // List all notes\n    println!();\n    list_notes()?;\n\n    // Load and display a note\n    println!(\"\\nðŸ“„ Loading note: 'Rust Tips'\");\n    if let Some(note) = Note::load(\"Rust Tips\")? {\n        println!(\"\\nTitle: {}\", note.title);\n        println!(\"Content:\\n{}\", note.content);\n    }\n\n    Ok(())\n}\n```\n\n**Output:**\n```\nâœ… Note 'Rust Tips' saved\nâœ… Note 'Todo' saved\nâœ… Note 'Ideas' saved\n\nðŸ“ Notes:\n  - Rust Tips\n  - Todo\n  - Ideas\n\nðŸ“„ Loading note: 'Rust Tips'\n\nTitle: Rust Tips\nContent:\nAlways handle errors with Result!\nUse ? operator for cleaner code.\n```\n\n## Best Practices\n\n### **1. Always Handle Errors**\n\n```rust\n// âŒ Bad: Panics if fails\nfs::write(\"file.txt\", \"data\").unwrap();\n\n// âœ… Good: Handles errors\nmatch fs::write(\"file.txt\", \"data\") {\n    Ok(_) => println!(\"Success\"),\n    Err(e) => eprintln!(\"Error: {}\", e),\n}\n```\n\n### **2. Create Parent Directories**\n\n```rust\nuse std::fs;\nuse std::path::Path;\n\nfn write_with_dirs(path: &str, content: &str) -> std::io::Result<()> {\n    if let Some(parent) = Path::new(path).parent() {\n        fs::create_dir_all(parent)?;\n    }\n\n    fs::write(path, content)?;\n    Ok(())\n}\n```\n\n### **3. Use Temporary Files for Safety**\n\n```rust\nuse std::fs;\n\nfn safe_update(path: &str, content: &str) -> std::io::Result<()> {\n    let temp_path = format!(\"{}.tmp\", path);\n\n    // Write to temporary file\n    fs::write(&temp_path, content)?;\n\n    // Rename (atomic operation on most systems)\n    fs::rename(&temp_path, path)?;\n\n    Ok(())\n}\n```\n\n### **4. Buffer Large Writes**\n\n```rust\nuse std::fs::File;\nuse std::io::{BufWriter, Write};\n\nfn write_many_lines() -> std::io::Result<()> {\n    let file = File::create(\"output.txt\")?;\n    let mut writer = BufWriter::new(file);\n\n    for i in 1..=10000 {\n        writeln!(writer, \"Line {}\", i)?;\n    }\n\n    writer.flush()?;  // Ensure all data written\n    Ok(())\n}\n```\n\n## Key Takeaways\n\n- âœ… `fs::write(path, content)` creates or overwrites file\n- âœ… Use `OpenOptions` with `.append(true)` to add content\n- âœ… `fs::create_dir_all()` creates nested directories\n- âœ… Check `Path::exists()` before overwriting important files\n- âœ… Use `.create(true)` to create file if it doesn't exist\n- âœ… `writeln!` macro adds newline automatically\n- âœ… Use `BufWriter` for better performance with many writes\n- âœ… Handle all I/O errors properly\n- âœ… Consider using temporary files for important updates\n- âœ… Create parent directories before writing files\n\n**Next**: Working with paths and file systems!\n\n---\n\n**Progress**: Module 7, Lesson 3 complete (41/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-07-04",
          "title": "Module 7, Lesson 4: Navigating the File System â€” Working with Paths",
          "type": "project",
          "estimatedMinutes": 8,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 7, Lesson 4: Navigating the File System â€” Working with Paths\n\n## The Concept: Street Addresses\n\nImagine addresses:\n- **Absolute**: \"123 Main St, New York, NY\" (complete address)\n- **Relative**: \"2 blocks north\" (from current location)\n- **Normalized**: Handle \"going up\" (../) and shortcuts\n\n**Path** operations let you manipulate file locations safely and portably.\n\n## The Path and PathBuf Types\n\n```rust\nuse std::path::{Path, PathBuf};\n\nfn main() {\n    // &Path: borrowed path (like &str)\n    let path = Path::new(\"data/files/document.txt\");\n    println!(\"Path: {:?}\", path);\n\n    // PathBuf: owned path (like String)\n    let mut pathbuf = PathBuf::from(\"data\");\n    pathbuf.push(\"files\");\n    pathbuf.push(\"document.txt\");\n    println!(\"PathBuf: {:?}\", pathbuf);\n}\n```\n\n**Output:**\n```\nPath: \"data/files/document.txt\"\nPathBuf: \"data/files/document.txt\"\n```\n\n## Path Components\n\n```rust\nuse std::path::Path;\n\nfn main() {\n    let path = Path::new(\"data/logs/2024/app.log\");\n\n    // File name\n    if let Some(name) = path.file_name() {\n        println!(\"File name: {:?}\", name);  // \"app.log\"\n    }\n\n    // Extension\n    if let Some(ext) = path.extension() {\n        println!(\"Extension: {:?}\", ext);  // \"log\"\n    }\n\n    // File stem (name without extension)\n    if let Some(stem) = path.file_stem() {\n        println!(\"File stem: {:?}\", stem);  // \"app\"\n    }\n\n    // Parent directory\n    if let Some(parent) = path.parent() {\n        println!(\"Parent: {:?}\", parent);  // \"data/logs/2024\"\n    }\n\n    // Components\n    println!(\"\\nComponents:\");\n    for component in path.components() {\n        println!(\"  {:?}\", component);\n    }\n}\n```\n\n**Output:**\n```\nFile name: \"app.log\"\nExtension: \"log\"\nFile stem: \"app\"\nParent: \"data/logs/2024\"\n\nComponents:\n  Normal(\"data\")\n  Normal(\"logs\")\n  Normal(\"2024\")\n  Normal(\"app.log\")\n```\n\n## Building Paths\n\n```rust\nuse std::path::PathBuf;\n\nfn main() {\n    let mut path = PathBuf::from(\"data\");\n\n    // Add components\n    path.push(\"logs\");\n    path.push(\"2024\");\n    path.push(\"app.log\");\n\n    println!(\"Built path: {:?}\", path);  // \"data/logs/2024/app.log\"\n\n    // Remove last component\n    path.pop();\n    println!(\"After pop: {:?}\", path);   // \"data/logs/2024\"\n\n    // Replace filename\n    path.push(\"system.log\");\n    println!(\"New file: {:?}\", path);    // \"data/logs/2024/system.log\"\n}\n```\n\n## Joining Paths\n\n```rust\nuse std::path::Path;\n\nfn main() {\n    let base = Path::new(\"data/documents\");\n    let file = \"report.pdf\";\n\n    let full_path = base.join(file);\n    println!(\"Full path: {:?}\", full_path);  // \"data/documents/report.pdf\"\n\n    // Chaining joins\n    let nested = Path::new(\"data\")\n        .join(\"projects\")\n        .join(\"rust\")\n        .join(\"main.rs\");\n\n    println!(\"Nested: {:?}\", nested);  // \"data/projects/rust/main.rs\"\n}\n```\n\n## Absolute vs Relative Paths\n\n```rust\nuse std::env;\nuse std::path::Path;\n\nfn main() -> std::io::Result<()> {\n    let relative = Path::new(\"data/file.txt\");\n    let absolute = relative.canonicalize()?;  // Converts to absolute\n\n    println!(\"Relative: {:?}\", relative);\n    println!(\"Absolute: {:?}\", absolute);\n\n    // Check if path is absolute\n    println!(\"Is absolute: {}\", absolute.is_absolute());\n    println!(\"Is relative: {}\", relative.is_relative());\n\n    Ok(())\n}\n```\n\n## Checking Path Properties\n\n```rust\nuse std::path::Path;\n\nfn main() {\n    let path = Path::new(\"src/main.rs\");\n\n    println!(\"Exists: {}\", path.exists());\n    println!(\"Is file: {}\", path.is_file());\n    println!(\"Is directory: {}\", path.is_dir());\n    println!(\"Is absolute: {}\", path.is_absolute());\n    println!(\"Is relative: {}\", path.is_relative());\n}\n```\n\n## Cross-Platform Path Handling\n\n```rust\nuse std::path::{Path, MAIN_SEPARATOR};\n\nfn main() {\n    println!(\"Path separator: {}\", MAIN_SEPARATOR);\n    // Windows: \\\n    // Unix: /\n\n    // PathBuf handles platform differences automatically\n    let path = Path::new(\"data\").join(\"files\").join(\"doc.txt\");\n\n    println!(\"Path: {:?}\", path);\n    // Windows: \"data\\\\files\\\\doc.txt\"\n    // Unix: \"data/files/doc.txt\"\n}\n```\n\n## Hands-On Practice\n\n```bash\ncargo new path_practice\ncd path_practice\ncode .\n```\n\n### **Experiment 1: Path Dissection**\n\n```rust\nuse std::path::Path;\n\nfn analyze_path(path_str: &str) {\n    let path = Path::new(path_str);\n\n    println!(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\");\n    println!(\"â•‘      Path Analysis                â•‘\");\n    println!(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\");\n    println!(\"â•‘ Full path: {:19} â•‘\", path_str);\n\n    if let Some(name) = path.file_name().and_then(|n| n.to_str()) {\n        println!(\"â•‘ File name: {:19} â•‘\", name);\n    }\n\n    if let Some(ext) = path.extension().and_then(|e| e.to_str()) {\n        println!(\"â•‘ Extension: {:19} â•‘\", ext);\n    }\n\n    if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {\n        println!(\"â•‘ File stem: {:19} â•‘\", stem);\n    }\n\n    if let Some(parent) = path.parent() {\n        println!(\"â•‘ Parent:    {:19} â•‘\", parent.to_str().unwrap_or(\"\"));\n    }\n\n    println!(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n}\n\nfn main() {\n    analyze_path(\"data/logs/2024/app.log\");\n    println!();\n    analyze_path(\"documents/report.pdf\");\n    println!();\n    analyze_path(\"src/main.rs\");\n}\n```\n\n### **Experiment 2: Path Builder**\n\n```rust\nuse std::path::PathBuf;\n\nfn build_log_path(date: &str, level: &str) -> PathBuf {\n    PathBuf::from(\"logs\")\n        .join(date)\n        .join(format!(\"{}.log\", level))\n}\n\nfn main() {\n    let error_log = build_log_path(\"2024-01-15\", \"error\");\n    let info_log = build_log_path(\"2024-01-15\", \"info\");\n    let debug_log = build_log_path(\"2024-01-16\", \"debug\");\n\n    println!(\"Error log: {:?}\", error_log);\n    println!(\"Info log: {:?}\", info_log);\n    println!(\"Debug log: {:?}\", debug_log);\n}\n```\n\n**Output:**\n```\nError log: \"logs/2024-01-15/error.log\"\nInfo log: \"logs/2024-01-15/info.log\"\nDebug log: \"logs/2024-01-16/debug.log\"\n```\n\n### **Experiment 3: File Organizer**\n\n```rust\nuse std::fs;\nuse std::path::Path;\n\nfn organize_file(file_path: &str) -> Result<String, String> {\n    let path = Path::new(file_path);\n\n    let extension = path\n        .extension()\n        .and_then(|ext| ext.to_str())\n        .ok_or(\"No extension found\")?;\n\n    let category = match extension {\n        \"txt\" | \"md\" | \"doc\" => \"documents\",\n        \"jpg\" | \"png\" | \"gif\" => \"images\",\n        \"mp3\" | \"wav\" | \"flac\" => \"audio\",\n        \"mp4\" | \"avi\" | \"mkv\" => \"video\",\n        \"rs\" | \"py\" | \"js\" => \"code\",\n        _ => \"other\",\n    };\n\n    let filename = path\n        .file_name()\n        .and_then(|name| name.to_str())\n        .ok_or(\"Invalid filename\")?;\n\n    let target = Path::new(\"organized\")\n        .join(category)\n        .join(filename);\n\n    Ok(format!(\"{} -> {:?}\", file_path, target))\n}\n\nfn main() {\n    let files = vec![\n        \"report.txt\",\n        \"photo.jpg\",\n        \"song.mp3\",\n        \"main.rs\",\n        \"movie.mp4\",\n        \"data.csv\",\n    ];\n\n    println!(\"File Organization Plan:\\n\");\n\n    for file in files {\n        match organize_file(file) {\n            Ok(plan) => println!(\"âœ… {}\", plan),\n            Err(e) => println!(\"âŒ {}: {}\", file, e),\n        }\n    }\n}\n```\n\n**Output:**\n```\nFile Organization Plan:\n\nâœ… report.txt -> \"organized/documents/report.txt\"\nâœ… photo.jpg -> \"organized/images/photo.jpg\"\nâœ… song.mp3 -> \"organized/audio/song.mp3\"\nâœ… main.rs -> \"organized/code/main.rs\"\nâœ… movie.mp4 -> \"organized/video/movie.mp4\"\nâœ… data.csv -> \"organized/other/data.csv\"\n```\n\n### **Challenge: Recursive Directory Walker**\n\n```rust\nuse std::fs;\nuse std::path::Path;\n\nfn walk_directory(dir: &Path, indent: usize) -> std::io::Result<()> {\n    if !dir.is_dir() {\n        return Ok(());\n    }\n\n    let entries = fs::read_dir(dir)?;\n\n    for entry in entries {\n        let entry = entry?;\n        let path = entry.path();\n        let name = path\n            .file_name()\n            .and_then(|n| n.to_str())\n            .unwrap_or(\"?\");\n\n        // Print with indentation\n        let prefix = \"  \".repeat(indent);\n\n        if path.is_dir() {\n            println!(\"{}ðŸ“ {}/\", prefix, name);\n            walk_directory(&path, indent + 1)?;\n        } else {\n            let size = entry.metadata()?.len();\n            println!(\"{}ðŸ“„ {} ({} bytes)\", prefix, name, size);\n        }\n    }\n\n    Ok(())\n}\n\nfn main() -> std::io::Result<()> {\n    // Create test directory structure\n    fs::create_dir_all(\"test_dir/subdir1\")?;\n    fs::create_dir_all(\"test_dir/subdir2\")?;\n    fs::write(\"test_dir/file1.txt\", \"Hello\")?;\n    fs::write(\"test_dir/subdir1/file2.txt\", \"World\")?;\n    fs::write(\"test_dir/subdir2/file3.txt\", \"Rust\")?;\n\n    println!(\"Directory structure:\\n\");\n    walk_directory(Path::new(\"test_dir\"), 0)?;\n\n    Ok(())\n}\n```\n\n**Output:**\n```\nDirectory structure:\n\nðŸ“ subdir1/\n  ðŸ“„ file2.txt (5 bytes)\nðŸ“ subdir2/\n  ðŸ“„ file3.txt (4 bytes)\nðŸ“„ file1.txt (5 bytes)\n```\n\n## Working with Current Directory\n\n```rust\nuse std::env;\n\nfn main() -> std::io::Result<()> {\n    // Get current directory\n    let current = env::current_dir()?;\n    println!(\"Current directory: {:?}\", current);\n\n    // Change current directory\n    env::set_current_dir(\"src\")?;\n    let new_current = env::current_dir()?;\n    println!(\"New directory: {:?}\", new_current);\n\n    // Change back\n    env::set_current_dir(\"..\")?;\n    let restored = env::current_dir()?;\n    println!(\"Restored directory: {:?}\", restored);\n\n    Ok(())\n}\n```\n\n## Path Normalization\n\n```rust\nuse std::path::{Path, PathBuf};\n\nfn normalize_path(path: &str) -> PathBuf {\n    let mut components = Vec::new();\n\n    for component in Path::new(path).components() {\n        match component {\n            std::path::Component::ParentDir => {\n                components.pop();  // Go up one level\n            }\n            std::path::Component::CurDir => {\n                // Skip \".\" (current directory)\n            }\n            _ => {\n                components.push(component);\n            }\n        }\n    }\n\n    components.iter().collect()\n}\n\nfn main() {\n    let paths = vec![\n        \"data/./files/document.txt\",\n        \"data/../data/files/document.txt\",\n        \"./data/files/../docs/report.pdf\",\n    ];\n\n    for path in paths {\n        let normalized = normalize_path(path);\n        println!(\"{:35} => {:?}\", path, normalized);\n    }\n}\n```\n\n**Output:**\n```\ndata/./files/document.txt           => \"data/files/document.txt\"\ndata/../data/files/document.txt     => \"data/files/document.txt\"\n./data/files/../docs/report.pdf     => \"data/docs/report.pdf\"\n```\n\n## Common Patterns\n\n### **Pattern 1: Safe Filename**\n\n```rust\nfn sanitize_filename(name: &str) -> String {\n    name.chars()\n        .map(|c| match c {\n            '/' | '\\\\' | ':' | '*' | '?' | '\"' | '<' | '>' | '|' => '_',\n            c => c,\n        })\n        .collect()\n}\n\nfn main() {\n    let unsafe_name = \"Report: Q1/2024 (Final).pdf\";\n    let safe_name = sanitize_filename(unsafe_name);\n    println!(\"Safe filename: {}\", safe_name);\n    // \"Report_ Q1_2024 (Final).pdf\"\n}\n```\n\n### **Pattern 2: Backup Path Generator**\n\n```rust\nuse std::path::{Path, PathBuf};\n\nfn create_backup_path(original: &Path) -> PathBuf {\n    let mut backup = original.to_path_buf();\n\n    if let Some(stem) = original.file_stem() {\n        if let Some(ext) = original.extension() {\n            let backup_name = format!(\n                \"{}.backup.{}\",\n                stem.to_str().unwrap(),\n                ext.to_str().unwrap()\n            );\n            backup.set_file_name(backup_name);\n        }\n    }\n\n    backup\n}\n\nfn main() {\n    let original = Path::new(\"data/important.txt\");\n    let backup = create_backup_path(original);\n    println!(\"Original: {:?}\", original);\n    println!(\"Backup:   {:?}\", backup);\n}\n```\n\n### **Pattern 3: Find Files by Extension**\n\n```rust\nuse std::fs;\nuse std::path::Path;\n\nfn find_files_by_extension(dir: &Path, ext: &str) -> std::io::Result<Vec<String>> {\n    let mut results = Vec::new();\n\n    if !dir.is_dir() {\n        return Ok(results);\n    }\n\n    for entry in fs::read_dir(dir)? {\n        let entry = entry?;\n        let path = entry.path();\n\n        if path.is_file() {\n            if let Some(file_ext) = path.extension() {\n                if file_ext == ext {\n                    if let Some(name) = path.to_str() {\n                        results.push(name.to_string());\n                    }\n                }\n            }\n        }\n    }\n\n    Ok(results)\n}\n\nfn main() -> std::io::Result<()> {\n    // Create test files\n    fs::write(\"test1.rs\", \"// Rust file 1\")?;\n    fs::write(\"test2.rs\", \"// Rust file 2\")?;\n    fs::write(\"readme.md\", \"# Readme\")?;\n\n    let rust_files = find_files_by_extension(Path::new(\".\"), \"rs\")?;\n\n    println!(\"Rust files:\");\n    for file in rust_files {\n        println!(\"  - {}\", file);\n    }\n\n    Ok(())\n}\n```\n\n## Key Takeaways\n\n- âœ… `Path` is for borrowed paths (like &str), `PathBuf` for owned paths (like String)\n- âœ… Use `.join()` to combine path components safely\n- âœ… `.file_name()`, `.extension()`, `.parent()` extract path parts\n- âœ… `.exists()`, `.is_file()`, `.is_dir()` check path properties\n- âœ… Paths are cross-platform - Rust handles separators automatically\n- âœ… Use `.canonicalize()` to get absolute paths\n- âœ… `.push()` adds components to PathBuf, `.pop()` removes last\n- âœ… Always handle path operations that return `Option` safely\n- âœ… Sanitize user-provided filenames to prevent security issues\n- âœ… Use `Path::new()` to create paths from strings\n\n**Next**: Practice project bringing all file I/O concepts together!\n\n---\n\n**Progress**: Module 7, Lesson 4 complete (42/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-07-05",
          "title": "Module 7, Lesson 5: Practice Project â€” Building a File Management Tool",
          "type": "project",
          "estimatedMinutes": 10,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 7, Lesson 5: Practice Project â€” Building a File Management Tool\n\n## Project Overview\n\nBuild a comprehensive command-line file management tool that demonstrates all file I/O techniques!\n\n**What we're building:**\n- File and directory operations\n- Search and filter capabilities\n- File content analysis\n- Batch operations\n- Complete CLI interface\n\n**Skills practiced:**\n- âœ… Command-line argument parsing\n- âœ… Reading and writing files\n- âœ… Path manipulation\n- âœ… Directory traversal\n- âœ… Error handling\n- âœ… All file I/O concepts working together\n\n## The Complete Project\n\n### **Step 1: Create the Project**\n\n```bash\ncargo new filetool\ncd filetool\ncode .\n```\n\n### **Step 2: Add Dependencies to Cargo.toml**\n\n```toml\n[package]\nname = \"filetool\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nclap = { version = \"4.5\", features = [\"derive\"] }\n```\n\n### **Step 3: Build the Tool (Complete Code)**\n\n```rust\nuse clap::{Parser, Subcommand};\nuse std::error::Error;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\n// ===== CLI Definition =====\n\n#[derive(Parser)]\n#[command(name = \"filetool\")]\n#[command(about = \"A comprehensive file management tool\", long_about = None)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// List files in a directory\n    List {\n        /// Directory to list (default: current directory)\n        #[arg(default_value = \".\")]\n        path: String,\n\n        /// Show file sizes\n        #[arg(short, long)]\n        size: bool,\n    },\n\n    /// Search for files by name\n    Search {\n        /// Directory to search in\n        path: String,\n\n        /// Search pattern\n        pattern: String,\n    },\n\n    /// Count words in a text file\n    Count {\n        /// File to analyze\n        file: String,\n    },\n\n    /// Copy a file\n    Copy {\n        /// Source file\n        source: String,\n\n        /// Destination file\n        dest: String,\n    },\n\n    /// Find and replace text in a file\n    Replace {\n        /// File to modify\n        file: String,\n\n        /// Text to find\n        find: String,\n\n        /// Replacement text\n        replace: String,\n    },\n\n    /// Create a backup of a file\n    Backup {\n        /// File to backup\n        file: String,\n    },\n\n    /// Get file information\n    Info {\n        /// File to analyze\n        file: String,\n    },\n}\n\n// ===== Implementation =====\n\nfn list_files(path: &str, show_size: bool) -> Result<(), Box<dyn Error>> {\n    let dir_path = Path::new(path);\n\n    if !dir_path.exists() {\n        return Err(format!(\"Directory '{}' not found\", path).into());\n    }\n\n    if !dir_path.is_dir() {\n        return Err(format!(\"'{}' is not a directory\", path).into());\n    }\n\n    println!(\"ðŸ“‚ Contents of {}:\\n\", path);\n\n    let mut entries: Vec<_> = fs::read_dir(dir_path)?.collect();\n    entries.sort_by_key(|e| e.as_ref().ok().map(|e| e.path()));\n\n    for entry in entries {\n        let entry = entry?;\n        let path = entry.path();\n        let metadata = entry.metadata()?;\n\n        let name = path\n            .file_name()\n            .and_then(|n| n.to_str())\n            .unwrap_or(\"?\");\n\n        if path.is_dir() {\n            if show_size {\n                println!(\"ðŸ“ {}/\", name);\n            } else {\n                println!(\"ðŸ“ {}/\", name);\n            }\n        } else {\n            if show_size {\n                let size = metadata.len();\n                println!(\"ðŸ“„ {} ({} bytes)\", name, size);\n            } else {\n                println!(\"ðŸ“„ {}\", name);\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn search_files(dir: &str, pattern: &str) -> Result<(), Box<dyn Error>> {\n    let search_path = Path::new(dir);\n\n    if !search_path.exists() {\n        return Err(format!(\"Directory '{}' not found\", dir).into());\n    }\n\n    println!(\"ðŸ” Searching for '{}' in {}...\\n\", pattern, dir);\n\n    let mut matches = Vec::new();\n    search_recursive(search_path, pattern, &mut matches)?;\n\n    if matches.is_empty() {\n        println!(\"No files found matching '{}'\", pattern);\n    } else {\n        println!(\"Found {} matching file(s):\\n\", matches.len());\n        for (i, file) in matches.iter().enumerate() {\n            println!(\"{}. {}\", i + 1, file);\n        }\n    }\n\n    Ok(())\n}\n\nfn search_recursive(\n    dir: &Path,\n    pattern: &str,\n    matches: &mut Vec<String>,\n) -> Result<(), Box<dyn Error>> {\n    for entry in fs::read_dir(dir)? {\n        let entry = entry?;\n        let path = entry.path();\n\n        if path.is_dir() {\n            search_recursive(&path, pattern, matches)?;\n        } else if path.is_file() {\n            if let Some(name) = path.file_name().and_then(|n| n.to_str()) {\n                if name.contains(pattern) {\n                    if let Some(path_str) = path.to_str() {\n                        matches.push(path_str.to_string());\n                    }\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn count_file(file: &str) -> Result<(), Box<dyn Error>> {\n    let path = Path::new(file);\n\n    if !path.exists() {\n        return Err(format!(\"File '{}' not found\", file).into());\n    }\n\n    let content = fs::read_to_string(path)?;\n\n    let lines = content.lines().count();\n    let words = content.split_whitespace().count();\n    let chars = content.len();\n    let bytes = path.metadata()?.len();\n\n    println!(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\");\n    println!(\"â•‘      File Statistics              â•‘\");\n    println!(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\");\n    println!(\"â•‘ File:       {:19} â•‘\", file);\n    println!(\"â•‘ Lines:      {:19} â•‘\", lines);\n    println!(\"â•‘ Words:      {:19} â•‘\", words);\n    println!(\"â•‘ Characters: {:19} â•‘\", chars);\n    println!(\"â•‘ Bytes:      {:19} â•‘\", bytes);\n    println!(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n\n    Ok(())\n}\n\nfn copy_file(source: &str, dest: &str) -> Result<(), Box<dyn Error>> {\n    let src_path = Path::new(source);\n    let dst_path = Path::new(dest);\n\n    if !src_path.exists() {\n        return Err(format!(\"Source file '{}' not found\", source).into());\n    }\n\n    if dst_path.exists() {\n        return Err(format!(\"Destination file '{}' already exists\", dest).into());\n    }\n\n    // Create parent directories if needed\n    if let Some(parent) = dst_path.parent() {\n        fs::create_dir_all(parent)?;\n    }\n\n    fs::copy(src_path, dst_path)?;\n\n    println!(\"âœ… Copied '{}' to '{}'\", source, dest);\n\n    Ok(())\n}\n\nfn replace_in_file(file: &str, find: &str, replace: &str) -> Result<(), Box<dyn Error>> {\n    let path = Path::new(file);\n\n    if !path.exists() {\n        return Err(format!(\"File '{}' not found\", file).into());\n    }\n\n    let content = fs::read_to_string(path)?;\n    let occurrences = content.matches(find).count();\n\n    if occurrences == 0 {\n        println!(\"âš ï¸  No occurrences of '{}' found in '{}'\", find, file);\n        return Ok(());\n    }\n\n    let new_content = content.replace(find, replace);\n    fs::write(path, new_content)?;\n\n    println!(\n        \"âœ… Replaced {} occurrence(s) of '{}' with '{}' in '{}'\",\n        occurrences, find, replace, file\n    );\n\n    Ok(())\n}\n\nfn backup_file(file: &str) -> Result<(), Box<dyn Error>> {\n    let path = Path::new(file);\n\n    if !path.exists() {\n        return Err(format!(\"File '{}' not found\", file).into());\n    }\n\n    let backup_path = create_backup_path(path);\n    fs::copy(path, &backup_path)?;\n\n    println!(\n        \"âœ… Created backup: {}\",\n        backup_path.to_str().unwrap_or(\"?\")\n    );\n\n    Ok(())\n}\n\nfn create_backup_path(original: &Path) -> PathBuf {\n    let mut backup = original.to_path_buf();\n\n    if let Some(stem) = original.file_stem() {\n        let timestamp = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap()\n            .as_secs();\n\n        let backup_name = if let Some(ext) = original.extension() {\n            format!(\n                \"{}.backup_{}.{}\",\n                stem.to_str().unwrap(),\n                timestamp,\n                ext.to_str().unwrap()\n            )\n        } else {\n            format!(\"{}.backup_{}\", stem.to_str().unwrap(), timestamp)\n        };\n\n        backup.set_file_name(backup_name);\n    }\n\n    backup\n}\n\nfn file_info(file: &str) -> Result<(), Box<dyn Error>> {\n    let path = Path::new(file);\n\n    if !path.exists() {\n        return Err(format!(\"File '{}' not found\", file).into());\n    }\n\n    let metadata = path.metadata()?;\n    let file_type = if metadata.is_file() {\n        \"File\"\n    } else if metadata.is_dir() {\n        \"Directory\"\n    } else {\n        \"Other\"\n    };\n\n    let size = metadata.len();\n    let readonly = metadata.permissions().readonly();\n\n    let extension = path\n        .extension()\n        .and_then(|e| e.to_str())\n        .unwrap_or(\"(none)\");\n\n    let parent = path\n        .parent()\n        .and_then(|p| p.to_str())\n        .unwrap_or(\"(none)\");\n\n    println!(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\");\n    println!(\"â•‘      File Information             â•‘\");\n    println!(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\");\n    println!(\"â•‘ Path:      {:20} â•‘\", file);\n    println!(\"â•‘ Type:      {:20} â•‘\", file_type);\n    println!(\"â•‘ Size:      {:17} bytes â•‘\", size);\n    println!(\"â•‘ Extension: {:20} â•‘\", extension);\n    println!(\"â•‘ Parent:    {:20} â•‘\", parent);\n    println!(\"â•‘ Read-only: {:20} â•‘\", readonly);\n    println!(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n\n    Ok(())\n}\n\n// ===== Main Function =====\n\nfn main() {\n    let cli = Cli::parse();\n\n    let result = match cli.command {\n        Commands::List { path, size } => list_files(&path, size),\n        Commands::Search { path, pattern } => search_files(&path, &pattern),\n        Commands::Count { file } => count_file(&file),\n        Commands::Copy { source, dest } => copy_file(&source, &dest),\n        Commands::Replace {\n            file,\n            find,\n            replace,\n        } => replace_in_file(&file, &find, &replace),\n        Commands::Backup { file } => backup_file(&file),\n        Commands::Info { file } => file_info(&file),\n    };\n\n    if let Err(e) = result {\n        eprintln!(\"âŒ Error: {}\", e);\n        std::process::exit(1);\n    }\n}\n```\n\n### **Step 4: Build and Test**\n\n```bash\ncargo build --release\n```\n\n## Usage Examples\n\n### **List Files**\n\n```bash\ncargo run -- list .\ncargo run -- list src --size\n```\n\n**Output:**\n```\nðŸ“‚ Contents of src:\n\nðŸ“„ main.rs (5234 bytes)\n```\n\n### **Search for Files**\n\n```bash\n# Create test files first\nmkdir -p test_data\necho \"Hello\" > test_data/hello.txt\necho \"World\" > test_data/world.txt\necho \"Test\" > test_data/test.md\n\ncargo run -- search test_data txt\n```\n\n**Output:**\n```\nðŸ” Searching for 'txt' in test_data...\n\nFound 2 matching file(s):\n\n1. test_data/hello.txt\n2. test_data/world.txt\n```\n\n### **Count Words**\n\n```bash\necho \"The quick brown fox jumps over the lazy dog\" > sample.txt\ncargo run -- count sample.txt\n```\n\n**Output:**\n```\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘      File Statistics              â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘ File:       sample.txt            â•‘\nâ•‘ Lines:      1                     â•‘\nâ•‘ Words:      9                     â•‘\nâ•‘ Characters: 43                    â•‘\nâ•‘ Bytes:      43                    â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```\n\n### **Copy File**\n\n```bash\ncargo run -- copy sample.txt copy_of_sample.txt\n```\n\n**Output:**\n```\nâœ… Copied 'sample.txt' to 'copy_of_sample.txt'\n```\n\n### **Find and Replace**\n\n```bash\ncargo run -- replace sample.txt \"fox\" \"cat\"\n```\n\n**Output:**\n```\nâœ… Replaced 1 occurrence(s) of 'fox' with 'cat' in 'sample.txt'\n```\n\n### **Create Backup**\n\n```bash\ncargo run -- backup sample.txt\n```\n\n**Output:**\n```\nâœ… Created backup: sample.backup_1704153600.txt\n```\n\n### **Get File Info**\n\n```bash\ncargo run -- info sample.txt\n```\n\n**Output:**\n```\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘      File Information             â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘ Path:      sample.txt             â•‘\nâ•‘ Type:      File                   â•‘\nâ•‘ Size:      43 bytes               â•‘\nâ•‘ Extension: txt                    â•‘\nâ•‘ Parent:    .                      â•‘\nâ•‘ Read-only: false                  â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```\n\n## Understanding the Code\n\n### **Command-Line Interface with clap**\n\n```rust\n#[derive(Parser)]\n#[command(name = \"filetool\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n```\n\n**Why**: Professional CLI with automatic help generation and parsing.\n\n### **Recursive Directory Search**\n\n```rust\nfn search_recursive(dir: &Path, pattern: &str, matches: &mut Vec<String>) -> Result<(), Box<dyn Error>> {\n    for entry in fs::read_dir(dir)? {\n        let path = entry.path();\n        if path.is_dir() {\n            search_recursive(&path, pattern, matches)?;  // Recurse\n        }\n        // ...\n    }\n    Ok(())\n}\n```\n\n**Why**: Searches all subdirectories systematically.\n\n### **Safe File Operations**\n\n```rust\nif !src_path.exists() {\n    return Err(format!(\"Source file '{}' not found\", source).into());\n}\n\nif dst_path.exists() {\n    return Err(format!(\"Destination file '{}' already exists\", dest).into());\n}\n```\n\n**Why**: Prevents accidental data loss and provides clear error messages.\n\n### **Timestamp-Based Backups**\n\n```rust\nlet timestamp = std::time::SystemTime::now()\n    .duration_since(std::time::UNIX_EPOCH)\n    .unwrap()\n    .as_secs();\n\nlet backup_name = format!(\"{}.backup_{}.{}\", stem, timestamp, ext);\n```\n\n**Why**: Unique backup filenames prevent overwriting previous backups.\n\n## Challenges and Extensions\n\n### **Challenge 1: Add Delete Command**\n\n```rust\nCommands::Delete {\n    /// File to delete\n    file: String,\n\n    /// Skip confirmation\n    #[arg(short, long)]\n    force: bool,\n},\n\nfn delete_file(file: &str, force: bool) -> Result<(), Box<dyn Error>> {\n    let path = Path::new(file);\n\n    if !path.exists() {\n        return Err(format!(\"File '{}' not found\", file).into());\n    }\n\n    if !force {\n        use std::io::{self, Write};\n        print!(\"Delete '{}'? (y/N): \", file);\n        io::stdout().flush()?;\n\n        let mut input = String::new();\n        io::stdin().read_line(&mut input)?;\n\n        if input.trim().to_lowercase() != \"y\" {\n            println!(\"Cancelled\");\n            return Ok(());\n        }\n    }\n\n    fs::remove_file(path)?;\n    println!(\"âœ… Deleted '{}'\", file);\n\n    Ok(())\n}\n```\n\n### **Challenge 2: Add Move Command**\n\n```rust\nCommands::Move {\n    /// Source file\n    source: String,\n\n    /// Destination\n    dest: String,\n},\n\nfn move_file(source: &str, dest: &str) -> Result<(), Box<dyn Error>> {\n    let src_path = Path::new(source);\n    let dst_path = Path::new(dest);\n\n    if !src_path.exists() {\n        return Err(format!(\"Source '{}' not found\", source).into());\n    }\n\n    fs::rename(src_path, dst_path)?;\n    println!(\"âœ… Moved '{}' to '{}'\", source, dest);\n\n    Ok(())\n}\n```\n\n### **Challenge 3: Add File Comparison**\n\n```rust\nCommands::Compare {\n    /// First file\n    file1: String,\n\n    /// Second file\n    file2: String,\n},\n\nfn compare_files(file1: &str, file2: &str) -> Result<(), Box<dyn Error>> {\n    let content1 = fs::read_to_string(file1)?;\n    let content2 = fs::read_to_string(file2)?;\n\n    if content1 == content2 {\n        println!(\"âœ… Files are identical\");\n    } else {\n        println!(\"âŒ Files are different\");\n\n        let lines1: Vec<&str> = content1.lines().collect();\n        let lines2: Vec<&str> = content2.lines().collect();\n\n        for (i, (line1, line2)) in lines1.iter().zip(lines2.iter()).enumerate() {\n            if line1 != line2 {\n                println!(\"Difference at line {}:\", i + 1);\n                println!(\"  File 1: {}\", line1);\n                println!(\"  File 2: {}\", line2);\n            }\n        }\n    }\n\n    Ok(())\n}\n```\n\n### **Challenge 4: Add File Statistics Summary**\n\n```rust\nCommands::Stats {\n    /// Directory to analyze\n    #[arg(default_value = \".\")]\n    path: String,\n},\n\nfn directory_stats(path: &str) -> Result<(), Box<dyn Error>> {\n    let mut total_files = 0;\n    let mut total_dirs = 0;\n    let mut total_size = 0u64;\n\n    for entry in fs::read_dir(path)? {\n        let entry = entry?;\n        let metadata = entry.metadata()?;\n\n        if metadata.is_file() {\n            total_files += 1;\n            total_size += metadata.len();\n        } else if metadata.is_dir() {\n            total_dirs += 1;\n        }\n    }\n\n    println!(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\");\n    println!(\"â•‘    Directory Statistics           â•‘\");\n    println!(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\");\n    println!(\"â•‘ Files:       {:17} â•‘\", total_files);\n    println!(\"â•‘ Directories: {:17} â•‘\", total_dirs);\n    println!(\"â•‘ Total size:  {:14} bytes â•‘\", total_size);\n    println!(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n\n    Ok(())\n}\n```\n\n## Key Takeaways\n\n- âœ… Command-line tools combine multiple file I/O operations\n- âœ… The `clap` crate makes building professional CLIs easy\n- âœ… Always validate inputs and handle errors gracefully\n- âœ… Recursive functions enable directory tree traversal\n- âœ… Path manipulation ensures cross-platform compatibility\n- âœ… Safety checks prevent accidental data loss\n- âœ… Timestamps create unique backup filenames\n- âœ… Comprehensive error messages improve user experience\n- âœ… Modular functions make code maintainable and testable\n- âœ… All file I/O concepts work together in real applications\n\n---\n\n## âœ… Module 7 Complete!\n\nYou've mastered Rust file I/O:\n- âœ… Command-line argument parsing\n- âœ… Reading files (whole and line-by-line)\n- âœ… Writing files (create and append)\n- âœ… Path manipulation and navigation\n- âœ… Built a complete file management tool!\n\n**Next: Module 8 â€” Traits & Generics**\n\nTotal Progress: 43 lessons complete (~72%)\n\n---\n\n[â† Back to Module 7](README.md) | [Continue to Module 8 â†’](../module_08_traits_generics/)\n"
          }
        }
      ]
    },
    {
      "id": "module-08",
      "title": "MODULE 08",
      "description": "Module 8",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-08-01",
          "title": "Module 8, Lesson 1: Shared Behavior â€” Introduction to Traits",
          "type": "exercise",
          "estimatedMinutes": 7,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 8, Lesson 1: Shared Behavior â€” Introduction to Traits\n\n## The Concept: Contracts and Interfaces\n\nImagine different devices with a \"chargeable\" interface:\n- **Phone**: Can charge (via USB-C)\n- **Laptop**: Can charge (via USB-C)\n- **Earbuds**: Can charge (via USB-C)\n\nAll share the same behavior: `charge()` method, but implement it differently.\n\n**Traits** define shared behavior that types can implement.\n\n## What Are Traits?\n\nTraits are like interfaces in other languages - they define a set of methods that a type must implement.\n\n```rust\n// Define a trait\ntrait Speak {\n    fn speak(&self) -> String;\n}\n\n// Implement the trait for Dog\nstruct Dog {\n    name: String,\n}\n\nimpl Speak for Dog {\n    fn speak(&self) -> String {\n        format!(\"{} says: Woof!\", self.name)\n    }\n}\n\n// Implement the trait for Cat\nstruct Cat {\n    name: String,\n}\n\nimpl Speak for Cat {\n    fn speak(&self) -> String {\n        format!(\"{} says: Meow!\", self.name)\n    }\n}\n\nfn main() {\n    let dog = Dog {\n        name: String::from(\"Buddy\"),\n    };\n\n    let cat = Cat {\n        name: String::from(\"Whiskers\"),\n    };\n\n    println!(\"{}\", dog.speak());  // Buddy says: Woof!\n    println!(\"{}\", cat.speak());  // Whiskers says: Meow!\n}\n```\n\n## Why Traits Matter\n\n### **1. Polymorphism**\n\nDifferent types can be used interchangeably if they implement the same trait:\n\n```rust\ntrait Drawable {\n    fn draw(&self);\n}\n\nstruct Circle {\n    radius: f64,\n}\n\nstruct Rectangle {\n    width: f64,\n    height: f64,\n}\n\nimpl Drawable for Circle {\n    fn draw(&self) {\n        println!(\"Drawing circle with radius {}\", self.radius);\n    }\n}\n\nimpl Drawable for Rectangle {\n    fn draw(&self) {\n        println!(\"Drawing rectangle {}x{}\", self.width, self.height);\n    }\n}\n\nfn render(shape: &impl Drawable) {\n    shape.draw();\n}\n\nfn main() {\n    let circle = Circle { radius: 5.0 };\n    let rectangle = Rectangle {\n        width: 10.0,\n        height: 20.0,\n    };\n\n    render(&circle);     // Drawing circle with radius 5\n    render(&rectangle);  // Drawing rectangle 10x20\n}\n```\n\n### **2. Code Reuse**\n\nWrite functions that work with any type implementing a trait:\n\n```rust\ntrait Summarizable {\n    fn summary(&self) -> String;\n}\n\nstruct Article {\n    title: String,\n    author: String,\n}\n\nstruct Tweet {\n    username: String,\n    content: String,\n}\n\nimpl Summarizable for Article {\n    fn summary(&self) -> String {\n        format!(\"'{}' by {}\", self.title, self.author)\n    }\n}\n\nimpl Summarizable for Tweet {\n    fn summary(&self) -> String {\n        format!(\"@{}: {}\", self.username, self.content)\n    }\n}\n\nfn print_summary(item: &impl Summarizable) {\n    println!(\"Summary: {}\", item.summary());\n}\n\nfn main() {\n    let article = Article {\n        title: String::from(\"Rust Traits Explained\"),\n        author: String::from(\"Alice\"),\n    };\n\n    let tweet = Tweet {\n        username: String::from(\"rustlang\"),\n        content: String::from(\"Rust 1.88 released!\"),\n    };\n\n    print_summary(&article);  // Summary: 'Rust Traits Explained' by Alice\n    print_summary(&tweet);    // Summary: @rustlang: Rust 1.88 released!\n}\n```\n\n## Default Implementations\n\nTraits can provide default method implementations:\n\n```rust\ntrait Greet {\n    fn greet(&self) -> String {\n        String::from(\"Hello!\")  // Default implementation\n    }\n\n    fn farewell(&self) -> String {\n        String::from(\"Goodbye!\")\n    }\n}\n\nstruct Person {\n    name: String,\n}\n\nstruct Robot;\n\nimpl Greet for Person {\n    // Override the default\n    fn greet(&self) -> String {\n        format!(\"Hello, I'm {}!\", self.name)\n    }\n    // Use default for farewell\n}\n\nimpl Greet for Robot {\n    // Use both defaults (empty impl block)\n}\n\nfn main() {\n    let person = Person {\n        name: String::from(\"Alice\"),\n    };\n    let robot = Robot;\n\n    println!(\"{}\", person.greet());     // Hello, I'm Alice!\n    println!(\"{}\", person.farewell());  // Goodbye!\n\n    println!(\"{}\", robot.greet());      // Hello!\n    println!(\"{}\", robot.farewell());   // Goodbye!\n}\n```\n\n## Traits Can Have Multiple Methods\n\n```rust\ntrait Shape {\n    fn area(&self) -> f64;\n    fn perimeter(&self) -> f64;\n\n    fn description(&self) -> String {\n        format!(\n            \"Shape with area {} and perimeter {}\",\n            self.area(),\n            self.perimeter()\n        )\n    }\n}\n\nstruct Square {\n    side: f64,\n}\n\nimpl Shape for Square {\n    fn area(&self) -> f64 {\n        self.side * self.side\n    }\n\n    fn perimeter(&self) -> f64 {\n        4.0 * self.side\n    }\n}\n\nfn main() {\n    let square = Square { side: 5.0 };\n\n    println!(\"Area: {}\", square.area());\n    println!(\"Perimeter: {}\", square.perimeter());\n    println!(\"{}\", square.description());\n}\n```\n\n**Output:**\n```\nArea: 25\nPerimeter: 20\nShape with area 25 and perimeter 20\n```\n\n## Hands-On Practice\n\n```bash\ncargo new trait_practice\ncd trait_practice\ncode .\n```\n\n### **Experiment 1: Basic Trait**\n\n```rust\ntrait Identifiable {\n    fn get_id(&self) -> u32;\n    fn get_name(&self) -> String;\n}\n\nstruct User {\n    id: u32,\n    username: String,\n}\n\nstruct Product {\n    id: u32,\n    name: String,\n}\n\nimpl Identifiable for User {\n    fn get_id(&self) -> u32 {\n        self.id\n    }\n\n    fn get_name(&self) -> String {\n        self.username.clone()\n    }\n}\n\nimpl Identifiable for Product {\n    fn get_id(&self) -> u32 {\n        self.id\n    }\n\n    fn get_name(&self) -> String {\n        self.name.clone()\n    }\n}\n\nfn display_item(item: &impl Identifiable) {\n    println!(\"ID: {}, Name: {}\", item.get_id(), item.get_name());\n}\n\nfn main() {\n    let user = User {\n        id: 1,\n        username: String::from(\"alice\"),\n    };\n\n    let product = Product {\n        id: 101,\n        name: String::from(\"Laptop\"),\n    };\n\n    display_item(&user);\n    display_item(&product);\n}\n```\n\n### **Experiment 2: Trait with Default Method**\n\n```rust\ntrait Logger {\n    fn log(&self, message: &str) {\n        println!(\"[LOG] {}\", message);\n    }\n\n    fn error(&self, message: &str) {\n        println!(\"[ERROR] {}\", message);\n    }\n}\n\nstruct Application;\n\nstruct Database;\n\nimpl Logger for Application {\n    fn log(&self, message: &str) {\n        println!(\"[APP] {}\", message);  // Custom implementation\n    }\n}\n\nimpl Logger for Database {\n    // Uses default implementations\n}\n\nfn main() {\n    let app = Application;\n    let db = Database;\n\n    app.log(\"Application started\");\n    app.error(\"Connection failed\");\n\n    db.log(\"Query executed\");\n    db.error(\"Deadlock detected\");\n}\n```\n\n### **Experiment 3: Multiple Traits**\n\n```rust\ntrait Playable {\n    fn play(&self);\n}\n\ntrait Pausable {\n    fn pause(&self);\n}\n\nstruct MusicPlayer {\n    song: String,\n}\n\nimpl Playable for MusicPlayer {\n    fn play(&self) {\n        println!(\"â™ª Playing: {}\", self.song);\n    }\n}\n\nimpl Pausable for MusicPlayer {\n    fn pause(&self) {\n        println!(\"â¸ Paused: {}\", self.song);\n    }\n}\n\nfn main() {\n    let player = MusicPlayer {\n        song: String::from(\"Rust Theme Song\"),\n    };\n\n    player.play();\n    player.pause();\n}\n```\n\n### **Challenge: Notification System**\n\n```rust\ntrait Notifiable {\n    fn send(&self, message: &str);\n\n    fn format_message(&self, message: &str) -> String {\n        format!(\"[Notification] {}\", message)\n    }\n}\n\nstruct EmailNotifier {\n    address: String,\n}\n\nstruct SMSNotifier {\n    phone: String,\n}\n\nstruct PushNotifier {\n    device_id: String,\n}\n\nimpl Notifiable for EmailNotifier {\n    fn send(&self, message: &str) {\n        println!(\"ðŸ“§ Sending email to {}\", self.address);\n        println!(\"   {}\", self.format_message(message));\n    }\n\n    fn format_message(&self, message: &str) -> String {\n        format!(\"Email: {}\", message)  // Custom format\n    }\n}\n\nimpl Notifiable for SMSNotifier {\n    fn send(&self, message: &str) {\n        println!(\"ðŸ“± Sending SMS to {}\", self.phone);\n        println!(\"   {}\", self.format_message(message));\n    }\n}\n\nimpl Notifiable for PushNotifier {\n    fn send(&self, message: &str) {\n        println!(\"ðŸ”” Sending push to device {}\", self.device_id);\n        println!(\"   {}\", self.format_message(message));\n    }\n}\n\nfn notify_all(notifiers: Vec<&dyn Notifiable>, message: &str) {\n    for notifier in notifiers {\n        notifier.send(message);\n        println!();\n    }\n}\n\nfn main() {\n    let email = EmailNotifier {\n        address: String::from(\"user@example.com\"),\n    };\n\n    let sms = SMSNotifier {\n        phone: String::from(\"+1234567890\"),\n    };\n\n    let push = PushNotifier {\n        device_id: String::from(\"device-abc-123\"),\n    };\n\n    let notifiers: Vec<&dyn Notifiable> = vec![&email, &sms, &push];\n\n    notify_all(notifiers, \"Your order has been shipped!\");\n}\n```\n\n**Output:**\n```\nðŸ“§ Sending email to user@example.com\n   Email: Your order has been shipped!\n\nðŸ“± Sending SMS to +1234567890\n   [Notification] Your order has been shipped!\n\nðŸ”” Sending push to device device-abc-123\n   [Notification] Your order has been shipped!\n```\n\n## Trait Syntax Variants\n\n### **impl Trait (Simple)**\n\n```rust\nfn summarize(item: &impl Summarizable) -> String {\n    item.summary()\n}\n```\n\n### **Trait Bound (More Flexible)**\n\n```rust\nfn summarize<T: Summarizable>(item: &T) -> String {\n    item.summary()\n}\n```\n\n### **Multiple Traits**\n\n```rust\nfn process(item: &(impl Readable + Writable)) {\n    // item implements both traits\n}\n```\n\n### **Trait Objects (Dynamic Dispatch)**\n\n```rust\nfn notify(item: &dyn Notifiable) {\n    item.send(\"Message\");\n}\n```\n\n## Common Built-In Traits (Preview)\n\nWe'll explore these in detail in Lesson 3:\n\n- **Debug**: `println!(\"{:?}\", value)`\n- **Display**: `println!(\"{}\", value)`\n- **Clone**: `value.clone()`\n- **Copy**: Automatic copying\n- **PartialEq**: `a == b`\n- **Ord**: `a < b`, sorting\n\n## Key Takeaways\n\n- âœ… Traits define shared behavior across types\n- âœ… Use `trait` keyword to define a trait\n- âœ… Use `impl TraitName for Type` to implement traits\n- âœ… Traits enable polymorphism in Rust\n- âœ… Default implementations provide common behavior\n- âœ… Types can implement multiple traits\n- âœ… Use `&impl Trait` for function parameters\n- âœ… Traits make code reusable and extensible\n- âœ… `&dyn Trait` enables runtime polymorphism\n- âœ… Traits are checked at compile time for safety\n\n**Next**: Generic types for writing flexible, reusable code!\n\n---\n\n**Progress**: Module 8, Lesson 1 complete (44/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-08-02",
          "title": "Module 8, Lesson 2: Writing Flexible Code â€” Introduction to Generics",
          "type": "exercise",
          "estimatedMinutes": 8,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 8, Lesson 2: Writing Flexible Code â€” Introduction to Generics\n\n## The Concept: Universal Remote\n\nImagine a universal remote:\n- **Works with**: TV, stereo, DVD player, gaming console\n- **Same buttons**: Power, volume, channel\n- **One design**: Adapts to many devices\n\n**Generics** let you write code that works with many types without duplication.\n\n## The Problem: Code Duplication\n\nWithout generics, you'd need separate functions for each type:\n\n```rust\nfn largest_i32(list: &[i32]) -> i32 {\n    let mut largest = list[0];\n    for &item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n    largest\n}\n\nfn largest_f64(list: &[f64]) -> f64 {\n    let mut largest = list[0];\n    for &item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n    largest\n}\n\n// Same logic, different types! ðŸ¤¦\n```\n\n## The Solution: Generic Functions\n\n```rust\nfn largest<T: PartialOrd + Copy>(list: &[T]) -> T {\n    let mut largest = list[0];\n    for &item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n    largest\n}\n\nfn main() {\n    let numbers = vec![34, 50, 25, 100, 65];\n    let result = largest(&numbers);\n    println!(\"Largest number: {}\", result);\n\n    let floats = vec![1.5, 3.2, 2.8, 4.1];\n    let result = largest(&floats);\n    println!(\"Largest float: {}\", result);\n}\n```\n\n**Output:**\n```\nLargest number: 100\nLargest float: 4.1\n```\n\n## Generic Syntax Explained\n\n```rust\nfn function_name<T>(parameter: T) -> T {\n    // T is a type parameter\n    // It's a placeholder for any type\n}\n```\n\n- **`<T>`**: Type parameter declaration\n- **`T`**: Convention (can be any name, but T is standard)\n- **Trait bounds**: `T: PartialOrd + Copy` - T must implement these traits\n\n## Generic Structs\n\n```rust\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let integer_point = Point { x: 5, y: 10 };\n    let float_point = Point { x: 1.5, y: 4.7 };\n\n    println!(\"Integer point: ({}, {})\", integer_point.x, integer_point.y);\n    println!(\"Float point: ({}, {})\", float_point.x, float_point.y);\n}\n```\n\n### **Multiple Type Parameters**\n\n```rust\nstruct Point<T, U> {\n    x: T,\n    y: U,\n}\n\nfn main() {\n    let mixed = Point { x: 5, y: 4.5 };  // i32 and f64\n    let both_int = Point { x: 1, y: 2 };  // both i32\n    let both_float = Point { x: 1.0, y: 2.0 };  // both f64\n\n    println!(\"Mixed: ({}, {})\", mixed.x, mixed.y);\n}\n```\n\n## Generic Enums\n\nRust's `Option` and `Result` are generic enums!\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n### **Custom Generic Enum**\n\n```rust\nenum Container<T> {\n    Single(T),\n    Multiple(Vec<T>),\n    Empty,\n}\n\nfn main() {\n    let one = Container::Single(42);\n    let many = Container::Multiple(vec![1, 2, 3, 4, 5]);\n    let none: Container<i32> = Container::Empty;\n\n    match one {\n        Container::Single(value) => println!(\"Single value: {}\", value),\n        Container::Multiple(values) => println!(\"Multiple: {:?}\", values),\n        Container::Empty => println!(\"Empty\"),\n    }\n}\n```\n\n## Generic Methods\n\n```rust\nstruct Pair<T> {\n    first: T,\n    second: T,\n}\n\nimpl<T> Pair<T> {\n    fn new(first: T, second: T) -> Self {\n        Pair { first, second }\n    }\n\n    fn swap(self) -> Self {\n        Pair {\n            first: self.second,\n            second: self.first,\n        }\n    }\n}\n\n// Methods only for types that implement Display + PartialOrd\nimpl<T: std::fmt::Display + PartialOrd> Pair<T> {\n    fn cmp_display(&self) {\n        if self.first >= self.second {\n            println!(\"First is larger or equal: {}\", self.first);\n        } else {\n            println!(\"Second is larger: {}\", self.second);\n        }\n    }\n}\n\nfn main() {\n    let pair = Pair::new(10, 20);\n    pair.cmp_display();  // Second is larger: 20\n\n    let swapped = pair.swap();\n    swapped.cmp_display();  // First is larger or equal: 20\n}\n```\n\n## Trait Bounds in Detail\n\n### **Single Trait Bound**\n\n```rust\nfn print_value<T: std::fmt::Display>(value: T) {\n    println!(\"Value: {}\", value);\n}\n```\n\n### **Multiple Trait Bounds**\n\n```rust\nfn process<T: std::fmt::Display + Clone>(value: T) {\n    println!(\"Value: {}\", value);\n    let copy = value.clone();\n    println!(\"Copy: {}\", copy);\n}\n```\n\n### **Where Clauses (More Readable)**\n\n```rust\nfn complex_function<T, U>(t: T, u: U) -> String\nwhere\n    T: std::fmt::Display + Clone,\n    U: std::fmt::Debug + Clone,\n{\n    format!(\"T: {}, U: {:?}\", t, u)\n}\n```\n\n## Hands-On Practice\n\n```bash\ncargo new generics_practice\ncd generics_practice\ncode .\n```\n\n### **Experiment 1: Generic Container**\n\n```rust\nstruct Box<T> {\n    value: T,\n}\n\nimpl<T> Box<T> {\n    fn new(value: T) -> Self {\n        Box { value }\n    }\n\n    fn get(&self) -> &T {\n        &self.value\n    }\n\n    fn set(&mut self, value: T) {\n        self.value = value;\n    }\n}\n\nfn main() {\n    let mut int_box = Box::new(42);\n    println!(\"Integer box: {}\", int_box.get());\n\n    int_box.set(100);\n    println!(\"Updated: {}\", int_box.get());\n\n    let string_box = Box::new(String::from(\"Hello\"));\n    println!(\"String box: {}\", string_box.get());\n}\n```\n\n### **Experiment 2: Generic Pair Operations**\n\n```rust\nstruct Pair<T> {\n    first: T,\n    second: T,\n}\n\nimpl<T: PartialOrd> Pair<T> {\n    fn new(first: T, second: T) -> Self {\n        Pair { first, second }\n    }\n\n    fn larger(&self) -> &T {\n        if self.first > self.second {\n            &self.first\n        } else {\n            &self.second\n        }\n    }\n}\n\nimpl<T: std::ops::Add<Output = T> + Copy> Pair<T> {\n    fn sum(&self) -> T {\n        self.first + self.second\n    }\n}\n\nfn main() {\n    let number_pair = Pair::new(10, 25);\n    println!(\"Larger: {}\", number_pair.larger());\n    println!(\"Sum: {}\", number_pair.sum());\n\n    let float_pair = Pair::new(3.5, 2.1);\n    println!(\"Larger: {}\", float_pair.larger());\n    println!(\"Sum: {}\", float_pair.sum());\n}\n```\n\n### **Experiment 3: Generic Stack**\n\n```rust\nstruct Stack<T> {\n    items: Vec<T>,\n}\n\nimpl<T> Stack<T> {\n    fn new() -> Self {\n        Stack { items: Vec::new() }\n    }\n\n    fn push(&mut self, item: T) {\n        self.items.push(item);\n    }\n\n    fn pop(&mut self) -> Option<T> {\n        self.items.pop()\n    }\n\n    fn peek(&self) -> Option<&T> {\n        self.items.last()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.items.is_empty()\n    }\n\n    fn size(&self) -> usize {\n        self.items.len()\n    }\n}\n\nfn main() {\n    let mut stack = Stack::new();\n\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n\n    println!(\"Stack size: {}\", stack.size());\n    println!(\"Top item: {:?}\", stack.peek());\n\n    while let Some(item) = stack.pop() {\n        println!(\"Popped: {}\", item);\n    }\n\n    println!(\"Is empty: {}\", stack.is_empty());\n\n    // Works with strings too!\n    let mut string_stack = Stack::new();\n    string_stack.push(String::from(\"Hello\"));\n    string_stack.push(String::from(\"World\"));\n\n    while let Some(word) = string_stack.pop() {\n        println!(\"{}\", word);\n    }\n}\n```\n\n**Output:**\n```\nStack size: 3\nTop item: Some(3)\nPopped: 3\nPopped: 2\nPopped: 1\nIs empty: true\nWorld\nHello\n```\n\n### **Challenge: Generic Queue**\n\n```rust\nstruct Queue<T> {\n    items: Vec<T>,\n}\n\nimpl<T> Queue<T> {\n    fn new() -> Self {\n        Queue { items: Vec::new() }\n    }\n\n    fn enqueue(&mut self, item: T) {\n        self.items.push(item);\n    }\n\n    fn dequeue(&mut self) -> Option<T> {\n        if self.items.is_empty() {\n            None\n        } else {\n            Some(self.items.remove(0))\n        }\n    }\n\n    fn peek(&self) -> Option<&T> {\n        self.items.first()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.items.is_empty()\n    }\n\n    fn size(&self) -> usize {\n        self.items.len()\n    }\n\n    fn clear(&mut self) {\n        self.items.clear();\n    }\n}\n\nimpl<T: std::fmt::Display> Queue<T> {\n    fn display(&self) {\n        print!(\"Queue [front -> back]: \");\n        for item in &self.items {\n            print!(\"{} \", item);\n        }\n        println!();\n    }\n}\n\nfn main() {\n    let mut queue = Queue::new();\n\n    println!(\"=== Integer Queue ===\");\n    queue.enqueue(10);\n    queue.enqueue(20);\n    queue.enqueue(30);\n    queue.enqueue(40);\n\n    queue.display();\n    println!(\"Size: {}\", queue.size());\n\n    if let Some(front) = queue.peek() {\n        println!(\"Front: {}\", front);\n    }\n\n    println!(\"\\nDequeuing:\");\n    while let Some(item) = queue.dequeue() {\n        println!(\"  Removed: {}\", item);\n    }\n\n    println!(\"Is empty: {}\", queue.is_empty());\n\n    println!(\"\\n=== String Queue ===\");\n    let mut task_queue = Queue::new();\n    task_queue.enqueue(\"Process payment\");\n    task_queue.enqueue(\"Send email\");\n    task_queue.enqueue(\"Update database\");\n\n    task_queue.display();\n\n    if let Some(next_task) = task_queue.dequeue() {\n        println!(\"Processing: {}\", next_task);\n    }\n\n    task_queue.display();\n}\n```\n\n**Output:**\n```\n=== Integer Queue ===\nQueue [front -> back]: 10 20 30 40\nSize: 4\nFront: 10\n\nDequeuing:\n  Removed: 10\n  Removed: 20\n  Removed: 30\n  Removed: 40\nIs empty: true\n\n=== String Queue ===\nQueue [front -> back]: Process payment Send email Update database\nProcessing: Process payment\nQueue [front -> back]: Send email Update database\n```\n\n## Generic Type Aliases\n\n```rust\ntype Result<T> = std::result::Result<T, String>;\n\nfn divide(a: i32, b: i32) -> Result<i32> {\n    if b == 0 {\n        Err(String::from(\"Division by zero\"))\n    } else {\n        Ok(a / b)\n    }\n}\n```\n\n## Performance: Zero-Cost Abstraction\n\nGenerics have **no runtime cost**! Rust uses **monomorphization**:\n\n```rust\nfn process<T>(value: T) {\n    // Generic code\n}\n\nfn main() {\n    process(42);        // Compiler generates process_i32()\n    process(3.14);      // Compiler generates process_f64()\n    process(\"hello\");   // Compiler generates process_str()\n}\n```\n\nThe compiler creates specialized versions for each type used, resulting in the same performance as writing separate functions!\n\n## Common Patterns\n\n### **Pattern 1: Builder with Generics**\n\n```rust\nstruct Builder<T> {\n    value: T,\n}\n\nimpl<T> Builder<T> {\n    fn new(value: T) -> Self {\n        Builder { value }\n    }\n\n    fn transform<U, F>(self, f: F) -> Builder<U>\n    where\n        F: Fn(T) -> U,\n    {\n        Builder { value: f(self.value) }\n    }\n\n    fn build(self) -> T {\n        self.value\n    }\n}\n\nfn main() {\n    let result = Builder::new(5)\n        .transform(|x| x * 2)\n        .transform(|x| x + 10)\n        .build();\n\n    println!(\"Result: {}\", result);  // 20\n}\n```\n\n### **Pattern 2: Generic Wrapper**\n\n```rust\nstruct Wrapper<T> {\n    value: T,\n}\n\nimpl<T: std::fmt::Display> Wrapper<T> {\n    fn print(&self) {\n        println!(\"Wrapped: {}\", self.value);\n    }\n}\n```\n\n## Key Takeaways\n\n- âœ… Generics eliminate code duplication\n- âœ… Use `<T>` to declare type parameters\n- âœ… Generics work with functions, structs, enums, and methods\n- âœ… Trait bounds constrain what types can be used\n- âœ… Multiple type parameters: `<T, U>`\n- âœ… `where` clauses improve readability\n- âœ… Generics have zero runtime cost (monomorphization)\n- âœ… `Option<T>` and `Result<T, E>` are generic enums\n- âœ… Generic code is type-safe and checked at compile time\n- âœ… Combine generics with traits for powerful abstractions\n\n**Next**: Common traits that make Rust types work seamlessly!\n\n---\n\n**Progress**: Module 8, Lesson 2 complete (45/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-08-03",
          "title": "Module 8, Lesson 3: Essential Behaviors â€” Common Traits in the Standard Library",
          "type": "exercise",
          "estimatedMinutes": 9,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 8, Lesson 3: Essential Behaviors â€” Common Traits in the Standard Library\n\n## The Concept: Standard Interfaces\n\nImagine electronic devices with standard ports:\n- **USB-C**: Charging, data transfer, video\n- **3.5mm jack**: Audio\n- **HDMI**: Video and audio\n\n**Common traits** provide standard interfaces that make Rust types work with built-in language features.\n\n## Why Common Traits Matter\n\nThey unlock built-in functionality:\n- **Debug**: `println!(\"{:?}\", value)`\n- **Display**: `println!(\"{}\", value)`\n- **Clone**: `value.clone()`\n- **Copy**: Automatic copying\n- **PartialEq**: `a == b`\n- **Ord**: Sorting and comparison\n\n## Debug - For Developer Output\n\n```rust\n#[derive(Debug)]\nstruct User {\n    name: String,\n    age: u32,\n}\n\nfn main() {\n    let user = User {\n        name: String::from(\"Alice\"),\n        age: 30,\n    };\n\n    println!(\"{:?}\", user);      // User { name: \"Alice\", age: 30 }\n    println!(\"{:#?}\", user);     // Pretty-printed\n}\n```\n\n**Output:**\n```\nUser { name: \"Alice\", age: 30 }\nUser {\n    name: \"Alice\",\n    age: 30,\n}\n```\n\n### **Custom Debug Implementation**\n\n```rust\nuse std::fmt;\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl fmt::Debug for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Point({}, {})\", self.x, self.y)\n    }\n}\n\nfn main() {\n    let p = Point { x: 10, y: 20 };\n    println!(\"{:?}\", p);  // Point(10, 20)\n}\n```\n\n## Display - For User-Facing Output\n\n```rust\nuse std::fmt;\n\nstruct User {\n    name: String,\n    age: u32,\n}\n\nimpl fmt::Display for User {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{} (age {})\", self.name, self.age)\n    }\n}\n\nfn main() {\n    let user = User {\n        name: String::from(\"Alice\"),\n        age: 30,\n    };\n\n    println!(\"{}\", user);  // Alice (age 30)\n}\n```\n\n## Clone - Explicit Copying\n\n```rust\n#[derive(Debug, Clone)]\nstruct Book {\n    title: String,\n    pages: u32,\n}\n\nfn main() {\n    let book1 = Book {\n        title: String::from(\"Rust Book\"),\n        pages: 500,\n    };\n\n    let book2 = book1.clone();  // Explicit copy\n\n    println!(\"Book 1: {:?}\", book1);\n    println!(\"Book 2: {:?}\", book2);\n    // Both are valid!\n}\n```\n\n### **Custom Clone Implementation**\n\n```rust\n#[derive(Debug)]\nstruct Counter {\n    count: u32,\n}\n\nimpl Clone for Counter {\n    fn clone(&self) -> Self {\n        println!(\"Cloning counter with count {}\", self.count);\n        Counter { count: self.count }\n    }\n}\n\nfn main() {\n    let c1 = Counter { count: 10 };\n    let c2 = c1.clone();\n    println!(\"{:?}\", c2);\n}\n```\n\n## Copy - Automatic Copying\n\n```rust\n#[derive(Debug, Copy, Clone)]  // Copy requires Clone\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p1 = Point { x: 5, y: 10 };\n    let p2 = p1;  // Automatic copy, both valid\n\n    println!(\"p1: {:?}\", p1);\n    println!(\"p2: {:?}\", p2);\n}\n```\n\n**Rules for Copy:**\n- Type must be fully stored on the stack\n- No heap allocations (no `String`, `Vec`, etc.)\n- All fields must implement `Copy`\n\n```rust\n// âŒ This won't compile: String doesn't implement Copy\n// #[derive(Copy, Clone)]\n// struct User {\n//     name: String,\n// }\n\n// âœ… This works: i32 implements Copy\n#[derive(Debug, Copy, Clone)]\nstruct Coordinates {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n```\n\n## PartialEq and Eq - Equality Comparison\n\n```rust\n#[derive(Debug, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p1 = Point { x: 5, y: 10 };\n    let p2 = Point { x: 5, y: 10 };\n    let p3 = Point { x: 3, y: 7 };\n\n    println!(\"p1 == p2: {}\", p1 == p2);  // true\n    println!(\"p1 == p3: {}\", p1 == p3);  // false\n    println!(\"p1 != p3: {}\", p1 != p3);  // true\n}\n```\n\n### **Custom PartialEq**\n\n```rust\nstruct CaseInsensitiveString {\n    value: String,\n}\n\nimpl PartialEq for CaseInsensitiveString {\n    fn eq(&self, other: &Self) -> bool {\n        self.value.to_lowercase() == other.value.to_lowercase()\n    }\n}\n\nfn main() {\n    let s1 = CaseInsensitiveString {\n        value: String::from(\"Hello\"),\n    };\n    let s2 = CaseInsensitiveString {\n        value: String::from(\"HELLO\"),\n    };\n\n    println!(\"Equal: {}\", s1 == s2);  // true\n}\n```\n\n## PartialOrd and Ord - Ordering\n\n```rust\n#[derive(Debug, PartialEq, PartialOrd)]\nstruct Person {\n    name: String,\n    age: u32,\n}\n\nfn main() {\n    let alice = Person {\n        name: String::from(\"Alice\"),\n        age: 30,\n    };\n    let bob = Person {\n        name: String::from(\"Bob\"),\n        age: 25,\n    };\n\n    if alice > bob {\n        println!(\"Alice is greater\");\n    } else {\n        println!(\"Bob is greater\");\n    }\n}\n```\n\n### **Custom Ordering**\n\n```rust\nuse std::cmp::Ordering;\n\n#[derive(Debug, Eq, PartialEq)]\nstruct Student {\n    name: String,\n    grade: u32,\n}\n\nimpl PartialOrd for Student {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Student {\n    fn cmp(&self, other: &Self) -> Ordering {\n        // Sort by grade descending\n        other.grade.cmp(&self.grade)\n    }\n}\n\nfn main() {\n    let mut students = vec![\n        Student {\n            name: String::from(\"Alice\"),\n            grade: 85,\n        },\n        Student {\n            name: String::from(\"Bob\"),\n            grade: 92,\n        },\n        Student {\n            name: String::from(\"Charlie\"),\n            grade: 78,\n        },\n    ];\n\n    students.sort();\n\n    for student in students {\n        println!(\"{}: {}\", student.name, student.grade);\n    }\n}\n```\n\n**Output:**\n```\nBob: 92\nAlice: 85\nCharlie: 78\n```\n\n## Default - Default Values\n\n```rust\n#[derive(Debug, Default)]\nstruct Config {\n    debug: bool,\n    max_connections: u32,\n    timeout: u32,\n}\n\nfn main() {\n    let config = Config::default();\n    println!(\"{:?}\", config);\n    // Config { debug: false, max_connections: 0, timeout: 0 }\n\n    let custom = Config {\n        debug: true,\n        ..Default::default()  // Use defaults for other fields\n    };\n    println!(\"{:?}\", custom);\n}\n```\n\n### **Custom Default**\n\n```rust\nstruct Server {\n    host: String,\n    port: u16,\n}\n\nimpl Default for Server {\n    fn default() -> Self {\n        Server {\n            host: String::from(\"localhost\"),\n            port: 8080,\n        }\n    }\n}\n\nfn main() {\n    let server = Server::default();\n    println!(\"Server: {}:{}\", server.host, server.port);\n}\n```\n\n## From and Into - Type Conversion\n\n```rust\nstruct Celsius(f64);\nstruct Fahrenheit(f64);\n\nimpl From<Celsius> for Fahrenheit {\n    fn from(c: Celsius) -> Self {\n        Fahrenheit(c.0 * 9.0 / 5.0 + 32.0)\n    }\n}\n\nfn main() {\n    let celsius = Celsius(25.0);\n    let fahrenheit: Fahrenheit = celsius.into();  // into() is automatic!\n\n    println!(\"Temperature: {}Â°F\", fahrenheit.0);\n}\n```\n\n## Hands-On Practice\n\n```bash\ncargo new common_traits\ncd common_traits\ncode .\n```\n\n### **Experiment 1: Complete Type**\n\n```rust\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq)]\nstruct Product {\n    id: u32,\n    name: String,\n    price: f64,\n}\n\nimpl fmt::Display for Product {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{} (ID: {}) - ${:.2}\", self.name, self.id, self.price)\n    }\n}\n\nimpl Default for Product {\n    fn default() -> Self {\n        Product {\n            id: 0,\n            name: String::from(\"Unknown\"),\n            price: 0.0,\n        }\n    }\n}\n\nfn main() {\n    let product1 = Product {\n        id: 1,\n        name: String::from(\"Laptop\"),\n        price: 999.99,\n    };\n\n    let product2 = product1.clone();\n\n    println!(\"Debug: {:?}\", product1);\n    println!(\"Display: {}\", product1);\n    println!(\"Equal: {}\", product1 == product2);\n\n    let default_product = Product::default();\n    println!(\"Default: {}\", default_product);\n}\n```\n\n### **Experiment 2: Sortable Items**\n\n```rust\n#[derive(Debug, Eq, PartialEq)]\nstruct Task {\n    name: String,\n    priority: u32,\n}\n\nimpl PartialOrd for Task {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Task {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        // High priority first\n        other.priority.cmp(&self.priority)\n    }\n}\n\nfn main() {\n    let mut tasks = vec![\n        Task {\n            name: String::from(\"Email client\"),\n            priority: 2,\n        },\n        Task {\n            name: String::from(\"Fix bug\"),\n            priority: 5,\n        },\n        Task {\n            name: String::from(\"Write docs\"),\n            priority: 1,\n        },\n    ];\n\n    tasks.sort();\n\n    println!(\"Tasks by priority:\");\n    for task in tasks {\n        println!(\"  [P{}] {}\", task.priority, task.name);\n    }\n}\n```\n\n### **Challenge: Complete Contact System**\n\n```rust\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nstruct Contact {\n    name: String,\n    email: String,\n    phone: String,\n}\n\nimpl fmt::Display for Contact {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{} <{}> | {}\", self.name, self.email, self.phone)\n    }\n}\n\nimpl PartialOrd for Contact {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Contact {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        // Sort alphabetically by name\n        self.name.cmp(&other.name)\n    }\n}\n\nimpl Default for Contact {\n    fn default() -> Self {\n        Contact {\n            name: String::from(\"Unknown\"),\n            email: String::from(\"no-email\"),\n            phone: String::from(\"000-000-0000\"),\n        }\n    }\n}\n\nfn main() {\n    let mut contacts = vec![\n        Contact {\n            name: String::from(\"Charlie\"),\n            email: String::from(\"charlie@example.com\"),\n            phone: String::from(\"555-3333\"),\n        },\n        Contact {\n            name: String::from(\"Alice\"),\n            email: String::from(\"alice@example.com\"),\n            phone: String::from(\"555-1111\"),\n        },\n        Contact {\n            name: String::from(\"Bob\"),\n            email: String::from(\"bob@example.com\"),\n            phone: String::from(\"555-2222\"),\n        },\n    ];\n\n    println!(\"=== Unsorted Contacts ===\");\n    for contact in &contacts {\n        println!(\"{}\", contact);\n    }\n\n    contacts.sort();\n\n    println!(\"\\n=== Sorted Contacts ===\");\n    for contact in &contacts {\n        println!(\"{}\", contact);\n    }\n\n    let contact2 = contacts[0].clone();\n    println!(\"\\n=== Cloned Contact ===\");\n    println!(\"{}\", contact2);\n\n    println!(\"\\n=== Comparison ===\");\n    println!(\"First == Cloned: {}\", contacts[0] == contact2);\n\n    println!(\"\\n=== Default Contact ===\");\n    let default = Contact::default();\n    println!(\"{:?}\", default);\n}\n```\n\n**Output:**\n```\n=== Unsorted Contacts ===\nCharlie <charlie@example.com> | 555-3333\nAlice <alice@example.com> | 555-1111\nBob <bob@example.com> | 555-2222\n\n=== Sorted Contacts ===\nAlice <alice@example.com> | 555-1111\nBob <bob@example.com> | 555-2222\nCharlie <charlie@example.com> | 555-3333\n\n=== Cloned Contact ===\nAlice <alice@example.com> | 555-1111\n\n=== Comparison ===\nFirst == Cloned: true\n\n=== Default Contact ===\nContact { name: \"Unknown\", email: \"no-email\", phone: \"000-000-0000\" }\n```\n\n## Derivable vs Manual Implementation\n\n### **Derivable (Use `#[derive(...)]`)**\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Default)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n```\n\n### **Manual (Custom Behavior)**\n\n```rust\nimpl PartialEq for Point {\n    fn eq(&self, other: &Self) -> bool {\n        // Custom equality logic\n        self.x == other.x && self.y == other.y\n    }\n}\n```\n\n## Trait Summary Table\n\n| Trait | Purpose | Enables | Derivable? |\n|-------|---------|---------|------------|\n| `Debug` | Developer output | `{:?}` formatting | âœ… Yes |\n| `Display` | User output | `{}` formatting | âŒ No |\n| `Clone` | Explicit copying | `.clone()` | âœ… Yes |\n| `Copy` | Implicit copying | Automatic copy | âœ… Yes |\n| `PartialEq` | Equality | `==`, `!=` | âœ… Yes |\n| `Eq` | Total equality | Required for HashMap keys | âœ… Yes |\n| `PartialOrd` | Partial ordering | `<`, `>`, `<=`, `>=` | âœ… Yes |\n| `Ord` | Total ordering | `.sort()` | âœ… Yes |\n| `Default` | Default values | `T::default()` | âœ… Yes |\n| `From/Into` | Type conversion | `.into()` | âŒ No |\n\n## Best Practices\n\n### **1. Derive When Possible**\n\n```rust\n// âœ… Good\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n}\n\n// âŒ Don't manually implement unless needed\n```\n\n### **2. Implement Display for User-Facing Types**\n\n```rust\nimpl fmt::Display for User {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"User: {}\", self.name)\n    }\n}\n```\n\n### **3. Copy Only for Small, Stack-Only Types**\n\n```rust\n// âœ… Good for Copy\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\n// âŒ Bad for Copy (has heap data)\n// struct User { name: String }\n```\n\n## Key Takeaways\n\n- âœ… Common traits provide standard interfaces\n- âœ… Use `#[derive(...)]` for automatic implementations\n- âœ… `Debug` is for developers, `Display` for users\n- âœ… `Clone` is explicit, `Copy` is implicit (automatic)\n- âœ… `Copy` types must be stack-only (no heap)\n- âœ… `PartialEq` enables `==`, `Ord` enables sorting\n- âœ… `Default` provides sensible initial values\n- âœ… `From`/`Into` enable type conversions\n- âœ… Manual implementation for custom behavior\n- âœ… Traits unlock built-in Rust functionality\n\n**Next**: Iterators for powerful data processing!\n\n---\n\n**Progress**: Module 8, Lesson 3 complete (46/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-08-04",
          "title": "Module 8, Lesson 4: Processing Collections Elegantly â€” Iterators",
          "type": "project",
          "estimatedMinutes": 9,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 8, Lesson 4: Processing Collections Elegantly â€” Iterators\n\n## The Concept: Assembly Line\n\nImagine an assembly line:\n- **Items flow** through stations\n- **Each station** transforms or inspects items\n- **No manual looping** - the line handles movement\n\n**Iterators** let you process sequences without manual index management.\n\n## What Are Iterators?\n\nIterators provide a way to process elements in a sequence one at a time:\n\n```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n\n    // Old way: manual loop\n    for i in 0..numbers.len() {\n        println!(\"{}\", numbers[i]);\n    }\n\n    // Iterator way: cleaner\n    for num in numbers.iter() {\n        println!(\"{}\", num);\n    }\n\n    // Even simpler\n    for num in &numbers {\n        println!(\"{}\", num);\n    }\n}\n```\n\n## Creating Iterators\n\n### **From Collections**\n\n```rust\nfn main() {\n    let vec = vec![1, 2, 3];\n\n    let iter1 = vec.iter();          // Immutable references\n    let iter2 = vec.iter_mut();      // Mutable references (requires mut vec)\n    let iter3 = vec.into_iter();     // Takes ownership\n}\n```\n\n### **From Ranges**\n\n```rust\nfn main() {\n    for i in 0..5 {\n        println!(\"{}\", i);  // 0, 1, 2, 3, 4\n    }\n\n    for i in 0..=5 {\n        println!(\"{}\", i);  // 0, 1, 2, 3, 4, 5 (inclusive)\n    }\n}\n```\n\n## Iterator Methods (Adapters)\n\n### **map() - Transform Each Element**\n\n```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n\n    let doubled: Vec<i32> = numbers\n        .iter()\n        .map(|x| x * 2)\n        .collect();\n\n    println!(\"{:?}\", doubled);  // [2, 4, 6, 8, 10]\n}\n```\n\n### **filter() - Keep Matching Elements**\n\n```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n    let evens: Vec<&i32> = numbers\n        .iter()\n        .filter(|x| *x % 2 == 0)\n        .collect();\n\n    println!(\"{:?}\", evens);  // [2, 4, 6, 8, 10]\n}\n```\n\n### **Chaining Methods**\n\n```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n    let result: Vec<i32> = numbers\n        .iter()\n        .filter(|x| *x % 2 == 0)  // Keep evens\n        .map(|x| x * x)            // Square them\n        .collect();\n\n    println!(\"{:?}\", result);  // [4, 16, 36, 64, 100]\n}\n```\n\n## Consumer Methods\n\n### **collect() - Build a Collection**\n\n```rust\nfn main() {\n    let numbers = vec![1, 2, 3];\n\n    // Collect into Vec\n    let vec: Vec<i32> = numbers.iter().map(|x| x * 2).collect();\n\n    // Collect into different types\n    use std::collections::HashSet;\n    let set: HashSet<i32> = numbers.iter().copied().collect();\n\n    println!(\"Vec: {:?}\", vec);\n    println!(\"Set: {:?}\", set);\n}\n```\n\n### **sum() and product()**\n\n```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n\n    let total: i32 = numbers.iter().sum();\n    let product: i32 = numbers.iter().product();\n\n    println!(\"Sum: {}\", total);        // 15\n    println!(\"Product: {}\", product);  // 120\n}\n```\n\n### **count()**\n\n```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n    let even_count = numbers\n        .iter()\n        .filter(|x| *x % 2 == 0)\n        .count();\n\n    println!(\"Even numbers: {}\", even_count);  // 5\n}\n```\n\n### **any() and all()**\n\n```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n\n    let has_even = numbers.iter().any(|x| x % 2 == 0);\n    let all_positive = numbers.iter().all(|x| *x > 0);\n\n    println!(\"Has even: {}\", has_even);           // true\n    println!(\"All positive: {}\", all_positive);   // true\n}\n```\n\n### **find() and position()**\n\n```rust\nfn main() {\n    let numbers = vec![1, 3, 5, 7, 8, 9];\n\n    let first_even = numbers.iter().find(|x| *x % 2 == 0);\n    let position = numbers.iter().position(|x| *x % 2 == 0);\n\n    println!(\"First even: {:?}\", first_even);  // Some(8)\n    println!(\"Position: {:?}\", position);      // Some(4)\n}\n```\n\n### **min() and max()**\n\n```rust\nfn main() {\n    let numbers = vec![5, 2, 8, 1, 9, 3];\n\n    let min = numbers.iter().min();\n    let max = numbers.iter().max();\n\n    println!(\"Min: {:?}\", min);  // Some(1)\n    println!(\"Max: {:?}\", max);  // Some(9)\n}\n```\n\n## Advanced Iterator Methods\n\n### **take() and skip()**\n\n```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n    let first_three: Vec<&i32> = numbers.iter().take(3).collect();\n    let skip_two: Vec<&i32> = numbers.iter().skip(2).collect();\n\n    println!(\"First 3: {:?}\", first_three);  // [1, 2, 3]\n    println!(\"Skip 2: {:?}\", skip_two);      // [3, 4, 5, 6, 7, 8, 9, 10]\n}\n```\n\n### **enumerate() - With Indices**\n\n```rust\nfn main() {\n    let words = vec![\"hello\", \"world\", \"rust\"];\n\n    for (i, word) in words.iter().enumerate() {\n        println!(\"{}: {}\", i, word);\n    }\n}\n```\n\n**Output:**\n```\n0: hello\n1: world\n2: rust\n```\n\n### **zip() - Combine Two Iterators**\n\n```rust\nfn main() {\n    let names = vec![\"Alice\", \"Bob\", \"Charlie\"];\n    let ages = vec![30, 25, 35];\n\n    for (name, age) in names.iter().zip(ages.iter()) {\n        println!(\"{} is {} years old\", name, age);\n    }\n}\n```\n\n**Output:**\n```\nAlice is 30 years old\nBob is 25 years old\nCharlie is 35 years old\n```\n\n### **fold() - Accumulate a Value**\n\n```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n    let product = numbers.iter().fold(1, |acc, x| acc * x);\n\n    println!(\"Sum: {}\", sum);        // 15\n    println!(\"Product: {}\", product); // 120\n}\n```\n\n### **flat_map() - Flatten Nested Structures**\n\n```rust\nfn main() {\n    let nested = vec![vec![1, 2], vec![3, 4], vec![5, 6]];\n\n    let flattened: Vec<i32> = nested\n        .iter()\n        .flat_map(|inner| inner.iter())\n        .copied()\n        .collect();\n\n    println!(\"{:?}\", flattened);  // [1, 2, 3, 4, 5, 6]\n}\n```\n\n## Hands-On Practice\n\n```bash\ncargo new iterator_practice\ncd iterator_practice\ncode .\n```\n\n### **Experiment 1: Data Processing Pipeline**\n\n```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n    // Complex transformation pipeline\n    let result: Vec<i32> = numbers\n        .iter()\n        .filter(|x| *x > 3)           // Keep > 3\n        .map(|x| x * x)                // Square\n        .filter(|x| *x < 50)           // Keep < 50\n        .collect();\n\n    println!(\"Result: {:?}\", result);  // [16, 25, 36, 49]\n}\n```\n\n### **Experiment 2: Text Processing**\n\n```rust\nfn main() {\n    let text = \"The quick brown fox jumps over the lazy dog\";\n\n    let word_lengths: Vec<usize> = text\n        .split_whitespace()\n        .map(|word| word.len())\n        .collect();\n\n    println!(\"Word lengths: {:?}\", word_lengths);\n\n    let long_words: Vec<&str> = text\n        .split_whitespace()\n        .filter(|word| word.len() > 3)\n        .collect();\n\n    println!(\"Long words: {:?}\", long_words);\n\n    let total_chars: usize = text\n        .split_whitespace()\n        .map(|word| word.len())\n        .sum();\n\n    println!(\"Total characters: {}\", total_chars);\n}\n```\n\n### **Experiment 3: Statistics Calculator**\n\n```rust\nfn main() {\n    let scores = vec![85.5, 90.0, 78.5, 92.0, 88.5, 95.0, 82.0];\n\n    let count = scores.len();\n    let sum: f64 = scores.iter().sum();\n    let average = sum / count as f64;\n\n    let min = scores.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max = scores.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\n    let above_90 = scores.iter().filter(|x| **x >= 90.0).count();\n\n    println!(\"=== Score Statistics ===\");\n    println!(\"Count: {}\", count);\n    println!(\"Sum: {:.2}\", sum);\n    println!(\"Average: {:.2}\", average);\n    println!(\"Min: {:.2}\", min);\n    println!(\"Max: {:.2}\", max);\n    println!(\"Scores >= 90: {}\", above_90);\n}\n```\n\n**Output:**\n```\n=== Score Statistics ===\nCount: 7\nSum: 611.50\nAverage: 87.36\nMin: 78.50\nMax: 95.00\nScores >= 90: 3\n```\n\n### **Challenge: Log File Analyzer**\n\n```rust\nfn main() {\n    let log_lines = vec![\n        \"[INFO] Application started\",\n        \"[ERROR] Database connection failed\",\n        \"[INFO] Retrying connection\",\n        \"[WARN] High memory usage\",\n        \"[ERROR] Authentication failed\",\n        \"[INFO] User logged in\",\n        \"[ERROR] File not found\",\n        \"[INFO] Task completed\",\n    ];\n\n    // Count by level\n    let error_count = log_lines\n        .iter()\n        .filter(|line| line.contains(\"[ERROR]\"))\n        .count();\n\n    let warn_count = log_lines\n        .iter()\n        .filter(|line| line.contains(\"[WARN]\"))\n        .count();\n\n    let info_count = log_lines\n        .iter()\n        .filter(|line| line.contains(\"[INFO]\"))\n        .count();\n\n    // Extract error messages\n    let errors: Vec<String> = log_lines\n        .iter()\n        .filter(|line| line.contains(\"[ERROR]\"))\n        .map(|line| line.replace(\"[ERROR] \", \"\"))\n        .collect();\n\n    // Find first warning\n    let first_warning = log_lines\n        .iter()\n        .find(|line| line.contains(\"[WARN]\"));\n\n    println!(\"=== Log Analysis ===\");\n    println!(\"Total lines: {}\", log_lines.len());\n    println!(\"ERROR: {}\", error_count);\n    println!(\"WARN: {}\", warn_count);\n    println!(\"INFO: {}\", info_count);\n\n    println!(\"\\n=== Errors ===\");\n    for (i, error) in errors.iter().enumerate() {\n        println!(\"{}. {}\", i + 1, error);\n    }\n\n    if let Some(warning) = first_warning {\n        println!(\"\\n=== First Warning ===\");\n        println!(\"{}\", warning);\n    }\n}\n```\n\n**Output:**\n```\n=== Log Analysis ===\nTotal lines: 8\nERROR: 3\nWARN: 1\nINFO: 4\n\n=== Errors ===\n1. Database connection failed\n2. Authentication failed\n3. File not found\n\n=== First Warning ===\n[WARN] High memory usage\n```\n\n## Creating Custom Iterators\n\n```rust\nstruct Counter {\n    count: u32,\n    max: u32,\n}\n\nimpl Counter {\n    fn new(max: u32) -> Counter {\n        Counter { count: 0, max }\n    }\n}\n\nimpl Iterator for Counter {\n    type Item = u32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.count < self.max {\n            self.count += 1;\n            Some(self.count)\n        } else {\n            None\n        }\n    }\n}\n\nfn main() {\n    let counter = Counter::new(5);\n\n    for num in counter {\n        println!(\"{}\", num);  // 1, 2, 3, 4, 5\n    }\n\n    // Can use all iterator methods!\n    let sum: u32 = Counter::new(10).sum();\n    println!(\"Sum of 1-10: {}\", sum);  // 55\n}\n```\n\n## Performance: Iterators are Fast!\n\nIterators are **zero-cost abstractions** - they're as fast as hand-written loops!\n\n```rust\n// Iterator way (clean and fast)\nlet sum: i32 = numbers.iter().sum();\n\n// Manual way (same performance)\nlet mut sum = 0;\nfor num in &numbers {\n    sum += num;\n}\n```\n\nThe compiler optimizes iterator chains into efficient machine code!\n\n## Common Patterns\n\n### **Pattern 1: Processing Options**\n\n```rust\nfn main() {\n    let numbers = vec![Some(1), None, Some(3), None, Some(5)];\n\n    let values: Vec<i32> = numbers\n        .into_iter()\n        .filter_map(|x| x)  // Keep only Some values\n        .collect();\n\n    println!(\"{:?}\", values);  // [1, 3, 5]\n}\n```\n\n### **Pattern 2: Group Processing**\n\n```rust\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n    let (evens, odds): (Vec<_>, Vec<_>) = numbers\n        .into_iter()\n        .partition(|x| x % 2 == 0);\n\n    println!(\"Evens: {:?}\", evens);  // [2, 4, 6, 8, 10]\n    println!(\"Odds: {:?}\", odds);    // [1, 3, 5, 7, 9]\n}\n```\n\n### **Pattern 3: String Building**\n\n```rust\nfn main() {\n    let words = vec![\"Rust\", \"is\", \"awesome\"];\n\n    let sentence: String = words\n        .iter()\n        .map(|s| *s)\n        .collect::<Vec<&str>>()\n        .join(\" \");\n\n    println!(\"{}\", sentence);  // Rust is awesome\n}\n```\n\n## Key Takeaways\n\n- âœ… Iterators process sequences without manual indexing\n- âœ… `.iter()` for immutable, `.iter_mut()` for mutable, `.into_iter()` for ownership\n- âœ… **Adapters** transform iterators: `map()`, `filter()`, `take()`, `skip()`\n- âœ… **Consumers** produce final values: `collect()`, `sum()`, `count()`, `find()`\n- âœ… Chain methods for powerful data pipelines\n- âœ… Iterators are **zero-cost abstractions** (no performance penalty)\n- âœ… Use `enumerate()` for indices, `zip()` to combine iterators\n- âœ… `fold()` accumulates values, `flat_map()` flattens nested structures\n- âœ… Custom iterators implement the `Iterator` trait\n- âœ… Iterators make code more expressive and functional\n\n**Next**: Practice project combining traits, generics, and iterators!\n\n---\n\n**Progress**: Module 8, Lesson 4 complete (47/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-08-05",
          "title": "Module 8, Lesson 5: Practice Project â€” Building a Generic Data Filter",
          "type": "project",
          "estimatedMinutes": 9,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 8, Lesson 5: Practice Project â€” Building a Generic Data Filter\n\n## Project Overview\n\nBuild a powerful, generic data filtering and transformation system that demonstrates traits, generics, and iterators!\n\n**What we're building:**\n- Generic filter system for any data type\n- Chainable transformations\n- Statistical analysis\n- Custom iterators\n- Complete type safety\n\n**Skills practiced:**\n- âœ… Defining and implementing traits\n- âœ… Generic types and functions\n- âœ… Trait bounds\n- âœ… Iterator methods and chains\n- âœ… All advanced concepts working together\n\n## The Complete Project\n\n### **Step 1: Create the Project**\n\n```bash\ncargo new data_filter\ncd data_filter\ncode .\n```\n\n### **Step 2: Build the Filter System**\n\n```rust\nuse std::fmt::Display;\n\n// ===== Filterable Trait =====\n\ntrait Filterable {\n    fn matches(&self, criteria: &str) -> bool;\n}\n\n// ===== Analyzable Trait =====\n\ntrait Analyzable: Display {\n    fn score(&self) -> f64;\n    fn category(&self) -> String;\n}\n\n// ===== Generic Filter =====\n\nstruct DataFilter<T> {\n    items: Vec<T>,\n}\n\nimpl<T> DataFilter<T> {\n    fn new() -> Self {\n        DataFilter { items: Vec::new() }\n    }\n\n    fn add(&mut self, item: T) {\n        self.items.push(item);\n    }\n\n    fn count(&self) -> usize {\n        self.items.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.items.is_empty()\n    }\n}\n\nimpl<T: Filterable> DataFilter<T> {\n    fn filter_by(&self, criteria: &str) -> Vec<&T> {\n        self.items\n            .iter()\n            .filter(|item| item.matches(criteria))\n            .collect()\n    }\n\n    fn count_matching(&self, criteria: &str) -> usize {\n        self.items\n            .iter()\n            .filter(|item| item.matches(criteria))\n            .count()\n    }\n}\n\nimpl<T: Analyzable> DataFilter<T> {\n    fn average_score(&self) -> f64 {\n        if self.items.is_empty() {\n            return 0.0;\n        }\n\n        let sum: f64 = self.items.iter().map(|item| item.score()).sum();\n        sum / self.items.len() as f64\n    }\n\n    fn top_scores(&self, n: usize) -> Vec<&T> {\n        let mut sorted: Vec<&T> = self.items.iter().collect();\n        sorted.sort_by(|a, b| {\n            b.score()\n                .partial_cmp(&a.score())\n                .unwrap_or(std::cmp::Ordering::Equal)\n        });\n\n        sorted.into_iter().take(n).collect()\n    }\n\n    fn group_by_category(&self) -> std::collections::HashMap<String, Vec<&T>> {\n        let mut groups = std::collections::HashMap::new();\n\n        for item in &self.items {\n            let category = item.category();\n            groups.entry(category).or_insert_with(Vec::new).push(item);\n        }\n\n        groups\n    }\n\n    fn display_all(&self) {\n        for (i, item) in self.items.iter().enumerate() {\n            println!(\"{}. {}\", i + 1, item);\n        }\n    }\n}\n\n// ===== Student Example =====\n\n#[derive(Debug, Clone)]\nstruct Student {\n    name: String,\n    grade: f64,\n    major: String,\n}\n\nimpl Display for Student {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{} ({}) - {:.1}\", self.name, self.major, self.grade)\n    }\n}\n\nimpl Filterable for Student {\n    fn matches(&self, criteria: &str) -> bool {\n        self.name.to_lowercase().contains(&criteria.to_lowercase())\n            || self.major.to_lowercase().contains(&criteria.to_lowercase())\n    }\n}\n\nimpl Analyzable for Student {\n    fn score(&self) -> f64 {\n        self.grade\n    }\n\n    fn category(&self) -> String {\n        self.major.clone()\n    }\n}\n\n// ===== Product Example =====\n\n#[derive(Debug, Clone)]\nstruct Product {\n    name: String,\n    price: f64,\n    category: String,\n    rating: f64,\n}\n\nimpl Display for Product {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(\n            f,\n            \"{} (${:.2}) - {} stars\",\n            self.name, self.price, self.rating\n        )\n    }\n}\n\nimpl Filterable for Product {\n    fn matches(&self, criteria: &str) -> bool {\n        self.name.to_lowercase().contains(&criteria.to_lowercase())\n            || self.category.to_lowercase().contains(&criteria.to_lowercase())\n    }\n}\n\nimpl Analyzable for Product {\n    fn score(&self) -> f64 {\n        self.rating\n    }\n\n    fn category(&self) -> String {\n        self.category.clone()\n    }\n}\n\n// ===== Generic Statistics =====\n\nstruct Statistics<T> {\n    data: Vec<T>,\n}\n\nimpl<T: Analyzable + Clone> Statistics<T> {\n    fn new(data: Vec<T>) -> Self {\n        Statistics { data }\n    }\n\n    fn summary(&self) {\n        if self.data.is_empty() {\n            println!(\"No data\");\n            return;\n        }\n\n        let scores: Vec<f64> = self.data.iter().map(|item| item.score()).collect();\n\n        let sum: f64 = scores.iter().sum();\n        let avg = sum / scores.len() as f64;\n        let min = scores\n            .iter()\n            .cloned()\n            .fold(f64::INFINITY, f64::min);\n        let max = scores\n            .iter()\n            .cloned()\n            .fold(f64::NEG_INFINITY, f64::max);\n\n        println!(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\");\n        println!(\"â•‘      Statistical Summary          â•‘\");\n        println!(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\");\n        println!(\"â•‘ Count:   {:22} â•‘\", self.data.len());\n        println!(\"â•‘ Average: {:22.2} â•‘\", avg);\n        println!(\"â•‘ Min:     {:22.2} â•‘\", min);\n        println!(\"â•‘ Max:     {:22.2} â•‘\", max);\n        println!(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n    }\n\n    fn percentile(&self, p: f64) -> Option<f64> {\n        if self.data.is_empty() || p < 0.0 || p > 100.0 {\n            return None;\n        }\n\n        let mut scores: Vec<f64> = self.data.iter().map(|item| item.score()).collect();\n        scores.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\n        let index = ((p / 100.0) * (scores.len() - 1) as f64).round() as usize;\n        Some(scores[index])\n    }\n}\n\n// ===== Main Program =====\n\nfn main() {\n    println!(\"=== Student Data Filter Demo ===\\n\");\n\n    let mut students = DataFilter::new();\n\n    students.add(Student {\n        name: String::from(\"Alice Johnson\"),\n        grade: 92.5,\n        major: String::from(\"Computer Science\"),\n    });\n\n    students.add(Student {\n        name: String::from(\"Bob Smith\"),\n        grade: 85.0,\n        major: String::from(\"Mathematics\"),\n    });\n\n    students.add(Student {\n        name: String::from(\"Charlie Davis\"),\n        grade: 88.5,\n        major: String::from(\"Computer Science\"),\n    });\n\n    students.add(Student {\n        name: String::from(\"Diana Wilson\"),\n        grade: 95.0,\n        major: String::from(\"Physics\"),\n    });\n\n    students.add(Student {\n        name: String::from(\"Eve Brown\"),\n        grade: 90.5,\n        major: String::from(\"Mathematics\"),\n    });\n\n    println!(\"All students:\");\n    students.display_all();\n\n    println!(\"\\n--- Filtering by 'Computer' ---\");\n    let cs_students = students.filter_by(\"Computer\");\n    for student in cs_students {\n        println!(\"  - {}\", student);\n    }\n\n    println!(\"\\n--- Top 3 Students ---\");\n    let top_3 = students.top_scores(3);\n    for student in top_3 {\n        println!(\"  - {}\", student);\n    }\n\n    println!(\"\\n--- Students by Major ---\");\n    let grouped = students.group_by_category();\n    for (major, students_in_major) in grouped {\n        println!(\"{}:\", major);\n        for student in students_in_major {\n            println!(\"  - {}\", student);\n        }\n    }\n\n    println!(\"\\n--- Statistics ---\");\n    println!(\"Average grade: {:.2}\", students.average_score());\n    println!(\"CS students: {}\", students.count_matching(\"Computer\"));\n\n    let stats = Statistics::new(\n        students\n            .items\n            .iter()\n            .cloned()\n            .collect(),\n    );\n    stats.summary();\n\n    if let Some(p90) = stats.percentile(90.0) {\n        println!(\"90th percentile: {:.2}\", p90);\n    }\n\n    println!(\"\\n\\n=== Product Data Filter Demo ===\\n\");\n\n    let mut products = DataFilter::new();\n\n    products.add(Product {\n        name: String::from(\"Laptop\"),\n        price: 999.99,\n        category: String::from(\"Electronics\"),\n        rating: 4.5,\n    });\n\n    products.add(Product {\n        name: String::from(\"Mouse\"),\n        price: 29.99,\n        category: String::from(\"Electronics\"),\n        rating: 4.2,\n    });\n\n    products.add(Product {\n        name: String::from(\"Desk\"),\n        price: 299.99,\n        category: String::from(\"Furniture\"),\n        rating: 4.7,\n    });\n\n    products.add(Product {\n        name: String::from(\"Chair\"),\n        price: 199.99,\n        category: String::from(\"Furniture\"),\n        rating: 4.8,\n    });\n\n    println!(\"All products:\");\n    products.display_all();\n\n    println!(\"\\n--- Electronics ---\");\n    let electronics = products.filter_by(\"Electronics\");\n    for product in electronics {\n        println!(\"  - {}\", product);\n    }\n\n    println!(\"\\n--- Top 2 Rated Products ---\");\n    let top_rated = products.top_scores(2);\n    for product in top_rated {\n        println!(\"  - {}\", product);\n    }\n\n    println!(\"\\n--- Average Rating ---\");\n    println!(\"{:.2} stars\", products.average_score());\n}\n```\n\n### **Step 3: Run the Project**\n\n```bash\ncargo run\n```\n\n**Expected Output:**\n\n```\n=== Student Data Filter Demo ===\n\nAll students:\n1. Alice Johnson (Computer Science) - 92.5\n2. Bob Smith (Mathematics) - 85.0\n3. Charlie Davis (Computer Science) - 88.5\n4. Diana Wilson (Physics) - 95.0\n5. Eve Brown (Mathematics) - 90.5\n\n--- Filtering by 'Computer' ---\n  - Alice Johnson (Computer Science) - 92.5\n  - Charlie Davis (Computer Science) - 88.5\n\n--- Top 3 Students ---\n  - Diana Wilson (Physics) - 95.0\n  - Alice Johnson (Computer Science) - 92.5\n  - Eve Brown (Mathematics) - 90.5\n\n--- Students by Major ---\nMathematics:\n  - Bob Smith (Mathematics) - 85.0\n  - Eve Brown (Mathematics) - 90.5\nPhysics:\n  - Diana Wilson (Physics) - 95.0\nComputer Science:\n  - Alice Johnson (Computer Science) - 92.5\n  - Charlie Davis (Computer Science) - 88.5\n\n--- Statistics ---\nAverage grade: 90.30\nCS students: 2\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘      Statistical Summary          â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘ Count:                        5   â•‘\nâ•‘ Average:                  90.30   â•‘\nâ•‘ Min:                      85.00   â•‘\nâ•‘ Max:                      95.00   â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n90th percentile: 92.50\n\n\n=== Product Data Filter Demo ===\n\nAll products:\n1. Laptop ($999.99) - 4.5 stars\n2. Mouse ($29.99) - 4.2 stars\n3. Desk ($299.99) - 4.7 stars\n4. Chair ($199.99) - 4.8 stars\n\n--- Electronics ---\n  - Laptop ($999.99) - 4.5 stars\n  - Mouse ($29.99) - 4.2 stars\n\n--- Top 2 Rated Products ---\n  - Chair ($199.99) - 4.8 stars\n  - Desk ($299.99) - 4.7 stars\n\n--- Average Rating ---\n4.55 stars\n```\n\n## Understanding the Code\n\n### **Generic with Trait Bounds**\n\n```rust\nimpl<T: Filterable> DataFilter<T> {\n    fn filter_by(&self, criteria: &str) -> Vec<&T> {\n        // Only available when T implements Filterable\n    }\n}\n```\n\n**Why**: Different functionality based on what traits T implements.\n\n### **Multiple Trait Bounds**\n\n```rust\ntrait Analyzable: Display {\n    // Analyzable requires Display\n}\n```\n\n**Why**: Ensures types can be both analyzed and displayed.\n\n### **Iterator Chains**\n\n```rust\nself.items\n    .iter()\n    .filter(|item| item.matches(criteria))\n    .collect()\n```\n\n**Why**: Clean, functional data processing.\n\n### **Generic Statistics**\n\n```rust\nstruct Statistics<T> {\n    data: Vec<T>,\n}\n\nimpl<T: Analyzable + Clone> Statistics<T> {\n    // Works with any Analyzable type\n}\n```\n\n**Why**: Single implementation works for Students, Products, and any future types!\n\n## Challenges and Extensions\n\n### **Challenge 1: Add Sorting Options**\n\n```rust\nimpl<T: Analyzable + Clone> DataFilter<T> {\n    fn sorted_by_score(&self, ascending: bool) -> Vec<T> {\n        let mut sorted = self.items.clone();\n        sorted.sort_by(|a, b| {\n            let cmp = a.score().partial_cmp(&b.score()).unwrap();\n            if ascending {\n                cmp\n            } else {\n                cmp.reverse()\n            }\n        });\n        sorted\n    }\n}\n```\n\n### **Challenge 2: Add Filtering by Range**\n\n```rust\nimpl<T: Analyzable> DataFilter<T> {\n    fn filter_by_score_range(&self, min: f64, max: f64) -> Vec<&T> {\n        self.items\n            .iter()\n            .filter(|item| {\n                let score = item.score();\n                score >= min && score <= max\n            })\n            .collect()\n    }\n}\n```\n\n### **Challenge 3: Add Export Functionality**\n\n```rust\nimpl<T: Analyzable> DataFilter<T> {\n    fn export_csv(&self, filename: &str) -> std::io::Result<()> {\n        use std::fs::File;\n        use std::io::Write;\n\n        let mut file = File::create(filename)?;\n\n        writeln!(file, \"Item,Score,Category\")?;\n\n        for item in &self.items {\n            writeln!(\n                file,\n                \"\\\"{}\\\",{},\\\"{}\\\"\",\n                item,\n                item.score(),\n                item.category()\n            )?;\n        }\n\n        Ok(())\n    }\n}\n```\n\n### **Challenge 4: Custom Iterator**\n\n```rust\nstruct FilterIterator<'a, T> {\n    items: &'a [T],\n    criteria: String,\n    index: usize,\n}\n\nimpl<'a, T: Filterable> Iterator for FilterIterator<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while self.index < self.items.len() {\n            let item = &self.items[self.index];\n            self.index += 1;\n\n            if item.matches(&self.criteria) {\n                return Some(item);\n            }\n        }\n        None\n    }\n}\n\nimpl<T: Filterable> DataFilter<T> {\n    fn iter_matching(&self, criteria: &str) -> FilterIterator<T> {\n        FilterIterator {\n            items: &self.items,\n            criteria: criteria.to_string(),\n            index: 0,\n        }\n    }\n}\n```\n\n## Key Concepts Demonstrated\n\n### **1. Trait-Based Polymorphism**\nDifferent types (Student, Product) work with the same generic code through shared traits.\n\n### **2. Generic Type Parameters**\n`DataFilter<T>` works with any type, providing type-safe collections.\n\n### **3. Trait Bounds**\n`impl<T: Analyzable>` ensures T has required methods at compile time.\n\n### **4. Iterator Methods**\nPowerful data processing with `filter()`, `map()`, `collect()`, `fold()`.\n\n### **5. Zero-Cost Abstractions**\nAll generics compiled to efficient specialized code - no runtime overhead!\n\n## Key Takeaways\n\n- âœ… Traits define shared behavior across different types\n- âœ… Generics enable code reuse without duplication\n- âœ… Trait bounds constrain generic types at compile time\n- âœ… Iterators provide expressive data processing\n- âœ… Multiple trait implementations unlock different functionality\n- âœ… Generic code is type-safe and performant\n- âœ… Combining traits + generics + iterators creates powerful abstractions\n- âœ… Real-world applications benefit from these patterns\n- âœ… Single implementation works for unlimited types\n- âœ… Rust's type system ensures correctness\n\n---\n\n## âœ… Module 8 Complete!\n\nYou've mastered advanced Rust concepts:\n- âœ… Traits for shared behavior\n- âœ… Generics for flexible, reusable code\n- âœ… Common traits (Debug, Display, Clone, etc.)\n- âœ… Iterators for elegant data processing\n- âœ… Built a complete generic data filtering system!\n\n**Next: Module 9 â€” Capstone Project (Task Manager Application)**\n\nTotal Progress: 48 lessons complete (80%)\n\n---\n\n[â† Back to Module 8](README.md) | [Continue to Module 9 â†’](../module_09_capstone/)\n"
          }
        }
      ]
    },
    {
      "id": "module-09",
      "title": "MODULE 09",
      "description": "Module 9",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-09-01",
          "title": "Module 9 - Capstone Project",
          "type": "project",
          "estimatedMinutes": 7,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 9 - Capstone Project\n\n# Lesson 1: Project Setup & Core Data Structures\n\n## Project Overview: Task Manager CLI\n\nWelcome to the capstone project! You'll build a complete, professional task management application that brings together everything you've learned:\n\n- âœ… **Structs & Enums** (Module 3)\n- âœ… **Ownership & Borrowing** (Module 4)\n- âœ… **Collections** (Module 5)\n- âœ… **Error Handling** (Module 6)\n- âœ… **File I/O** (Module 7)\n- âœ… **Traits & Generics** (Module 8)\n\n**What we're building:**\nA command-line task manager with:\n- Create, read, update, delete tasks\n- Priority levels and due dates\n- Tags and categories\n- Search and filtering\n- File persistence\n- Statistics and reports\n\n## Step 1: Create the Project\n\n```bash\ncargo new taskmaster\ncd taskmaster\n```\n\n### **Add Dependencies to Cargo.toml**\n\n```toml\n[package]\nname = \"taskmaster\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nclap = { version = \"4.5\", features = [\"derive\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nchrono = \"0.4\"\n```\n\n**Dependencies explained:**\n- **clap**: Command-line argument parsing\n- **serde**: Serialization/deserialization\n- **serde_json**: JSON file format\n- **chrono**: Date and time handling\n\n## Step 2: Define Core Data Structures\n\nCreate `src/task.rs`:\n\n```rust\nuse chrono::{DateTime, Local};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum Priority {\n    Low,\n    Medium,\n    High,\n    Urgent,\n}\n\nimpl Priority {\n    pub fn from_str(s: &str) -> Option<Self> {\n        match s.to_lowercase().as_str() {\n            \"low\" => Some(Priority::Low),\n            \"medium\" => Some(Priority::Medium),\n            \"high\" => Some(Priority::High),\n            \"urgent\" => Some(Priority::Urgent),\n            _ => None,\n        }\n    }\n\n    pub fn as_str(&self) -> &str {\n        match self {\n            Priority::Low => \"Low\",\n            Priority::Medium => \"Medium\",\n            Priority::High => \"High\",\n            Priority::Urgent => \"Urgent\",\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum Status {\n    Todo,\n    InProgress,\n    Done,\n}\n\nimpl Status {\n    pub fn from_str(s: &str) -> Option<Self> {\n        match s.to_lowercase().as_str() {\n            \"todo\" => Some(Status::Todo),\n            \"inprogress\" | \"in-progress\" => Some(Status::InProgress),\n            \"done\" => Some(Status::Done),\n            _ => None,\n        }\n    }\n\n    pub fn as_str(&self) -> &str {\n        match self {\n            Status::Todo => \"Todo\",\n            Status::InProgress => \"In Progress\",\n            Status::Done => \"Done\",\n        }\n    }\n\n    pub fn icon(&self) -> &str {\n        match self {\n            Status::Todo => \"â¬œ\",\n            Status::InProgress => \"ðŸ”„\",\n            Status::Done => \"âœ…\",\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Task {\n    pub id: u32,\n    pub title: String,\n    pub description: Option<String>,\n    pub priority: Priority,\n    pub status: Status,\n    pub tags: Vec<String>,\n    pub created_at: DateTime<Local>,\n    pub updated_at: DateTime<Local>,\n    pub due_date: Option<DateTime<Local>>,\n}\n\nimpl Task {\n    pub fn new(id: u32, title: String) -> Self {\n        let now = Local::now();\n        Task {\n            id,\n            title,\n            description: None,\n            priority: Priority::Medium,\n            status: Status::Todo,\n            tags: Vec::new(),\n            created_at: now,\n            updated_at: now,\n            due_date: None,\n        }\n    }\n\n    pub fn with_description(mut self, description: String) -> Self {\n        self.description = Some(description);\n        self.updated_at = Local::now();\n        self\n    }\n\n    pub fn with_priority(mut self, priority: Priority) -> Self {\n        self.priority = priority;\n        self.updated_at = Local::now();\n        self\n    }\n\n    pub fn with_tags(mut self, tags: Vec<String>) -> Self {\n        self.tags = tags;\n        self.updated_at = Local::now();\n        self\n    }\n\n    pub fn set_status(&mut self, status: Status) {\n        self.status = status;\n        self.updated_at = Local::now();\n    }\n\n    pub fn add_tag(&mut self, tag: String) {\n        if !self.tags.contains(&tag) {\n            self.tags.push(tag);\n            self.updated_at = Local::now();\n        }\n    }\n\n    pub fn remove_tag(&mut self, tag: &str) {\n        if let Some(pos) = self.tags.iter().position(|t| t == tag) {\n            self.tags.remove(pos);\n            self.updated_at = Local::now();\n        }\n    }\n}\n\nimpl std::fmt::Display for Task {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(\n            f,\n            \"[{}] #{} - {} | {} | {}\",\n            self.status.icon(),\n            self.id,\n            self.title,\n            self.priority.as_str(),\n            self.status.as_str()\n        )\n    }\n}\n```\n\n## Step 3: Create Error Types\n\nCreate `src/error.rs`:\n\n```rust\nuse std::error::Error;\nuse std::fmt;\n\n#[derive(Debug)]\npub enum TaskError {\n    NotFound(u32),\n    InvalidId(String),\n    InvalidPriority(String),\n    InvalidStatus(String),\n    IoError(std::io::Error),\n    JsonError(serde_json::Error),\n    EmptyTitle,\n}\n\nimpl fmt::Display for TaskError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            TaskError::NotFound(id) => write!(f, \"Task #{} not found\", id),\n            TaskError::InvalidId(s) => write!(f, \"Invalid task ID: {}\", s),\n            TaskError::InvalidPriority(s) => write!(f, \"Invalid priority: {}\", s),\n            TaskError::InvalidStatus(s) => write!(f, \"Invalid status: {}\", s),\n            TaskError::IoError(e) => write!(f, \"IO error: {}\", e),\n            TaskError::JsonError(e) => write!(f, \"JSON error: {}\", e),\n            TaskError::EmptyTitle => write!(f, \"Task title cannot be empty\"),\n        }\n    }\n}\n\nimpl Error for TaskError {}\n\nimpl From<std::io::Error> for TaskError {\n    fn from(error: std::io::Error) -> Self {\n        TaskError::IoError(error)\n    }\n}\n\nimpl From<serde_json::Error> for TaskError {\n    fn from(error: serde_json::Error) -> Self {\n        TaskError::JsonError(error)\n    }\n}\n\npub type Result<T> = std::result::Result<T, TaskError>;\n```\n\n## Step 4: Basic Task Manager\n\nCreate `src/manager.rs`:\n\n```rust\nuse crate::error::{Result, TaskError};\nuse crate::task::{Priority, Status, Task};\n\npub struct TaskManager {\n    tasks: Vec<Task>,\n    next_id: u32,\n}\n\nimpl TaskManager {\n    pub fn new() -> Self {\n        TaskManager {\n            tasks: Vec::new(),\n            next_id: 1,\n        }\n    }\n\n    pub fn add_task(&mut self, title: String) -> Result<u32> {\n        if title.trim().is_empty() {\n            return Err(TaskError::EmptyTitle);\n        }\n\n        let id = self.next_id;\n        let task = Task::new(id, title);\n        self.tasks.push(task);\n        self.next_id += 1;\n\n        Ok(id)\n    }\n\n    pub fn get_task(&self, id: u32) -> Result<&Task> {\n        self.tasks\n            .iter()\n            .find(|t| t.id == id)\n            .ok_or(TaskError::NotFound(id))\n    }\n\n    pub fn get_task_mut(&mut self, id: u32) -> Result<&mut Task> {\n        self.tasks\n            .iter_mut()\n            .find(|t| t.id == id)\n            .ok_or(TaskError::NotFound(id))\n    }\n\n    pub fn list_tasks(&self) -> &[Task] {\n        &self.tasks\n    }\n\n    pub fn update_task<F>(&mut self, id: u32, update_fn: F) -> Result<()>\n    where\n        F: FnOnce(&mut Task),\n    {\n        let task = self.get_task_mut(id)?;\n        update_fn(task);\n        Ok(())\n    }\n\n    pub fn delete_task(&mut self, id: u32) -> Result<()> {\n        let pos = self\n            .tasks\n            .iter()\n            .position(|t| t.id == id)\n            .ok_or(TaskError::NotFound(id))?;\n\n        self.tasks.remove(pos);\n        Ok(())\n    }\n\n    pub fn count(&self) -> usize {\n        self.tasks.len()\n    }\n}\n\nimpl Default for TaskManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n```\n\n## Step 5: Main Program (Basic Version)\n\nUpdate `src/main.rs`:\n\n```rust\nmod error;\nmod manager;\nmod task;\n\nuse manager::TaskManager;\nuse task::{Priority, Status};\n\nfn main() {\n    println!(\"=== TaskMaster Demo ===\\n\");\n\n    let mut manager = TaskManager::new();\n\n    // Add tasks\n    let id1 = manager.add_task(\"Learn Rust\".to_string()).unwrap();\n    let id2 = manager.add_task(\"Build a project\".to_string()).unwrap();\n    let id3 = manager.add_task(\"Master error handling\".to_string()).unwrap();\n\n    println!(\"âœ… Created {} tasks\\n\", manager.count());\n\n    // Update tasks\n    manager\n        .update_task(id1, |task| {\n            task.with_priority(Priority::High);\n            task.set_status(Status::InProgress);\n            task.add_tag(\"learning\".to_string());\n        })\n        .unwrap();\n\n    manager\n        .update_task(id2, |task| {\n            task.with_priority(Priority::Medium);\n            task.add_tag(\"project\".to_string());\n        })\n        .unwrap();\n\n    // List all tasks\n    println!(\"All tasks:\");\n    for task in manager.list_tasks() {\n        println!(\"  {}\", task);\n    }\n\n    // Get specific task\n    println!(\"\\n=== Task Details ===\");\n    if let Ok(task) = manager.get_task(id1) {\n        println!(\"Task #{}:\", task.id);\n        println!(\"  Title: {}\", task.title);\n        println!(\"  Priority: {}\", task.priority.as_str());\n        println!(\"  Status: {}\", task.status.as_str());\n        println!(\"  Tags: {:?}\", task.tags);\n        println!(\"  Created: {}\", task.created_at.format(\"%Y-%m-%d %H:%M\"));\n    }\n\n    // Delete task\n    manager.delete_task(id3).unwrap();\n    println!(\"\\nâœ… Deleted task #{}\", id3);\n    println!(\"Remaining tasks: {}\", manager.count());\n}\n```\n\n## Step 6: Build and Test\n\n```bash\ncargo build\ncargo run\n```\n\n**Expected Output:**\n\n```\n=== TaskMaster Demo ===\n\nâœ… Created 3 tasks\n\nAll tasks:\n  [ðŸ”„] #1 - Learn Rust | High | In Progress\n  [â¬œ] #2 - Build a project | Medium | Todo\n  [â¬œ] #3 - Master error handling | Medium | Todo\n\n=== Task Details ===\nTask #1:\n  Title: Learn Rust\n  Priority: High\n  Status: In Progress\n  Tags: [\"learning\"]\n  Created: 2024-01-15 10:30\n\nâœ… Deleted task #3\nRemaining tasks: 2\n```\n\n## Understanding the Code\n\n### **Builder Pattern**\n\n```rust\nlet task = Task::new(id, title)\n    .with_description(\"Details\".to_string())\n    .with_priority(Priority::High);\n```\n\n**Why**: Chainable, readable task construction.\n\n### **Generic Update Function**\n\n```rust\nfn update_task<F>(&mut self, id: u32, update_fn: F) -> Result<()>\nwhere\n    F: FnOnce(&mut Task),\n```\n\n**Why**: Flexible task updates without exposing mutable references.\n\n### **Custom Error Types**\n\n```rust\nenum TaskError {\n    NotFound(u32),\n    InvalidId(String),\n    // ...\n}\n```\n\n**Why**: Specific, actionable error information with context.\n\n### **Trait Implementations**\n\n```rust\nimpl Display for Task { }\nimpl From<std::io::Error> for TaskError { }\n```\n\n**Why**: Integrates with Rust ecosystem (println!, ? operator).\n\n## Checkpoint\n\nYou now have:\n- âœ… Core data structures (Task, Priority, Status)\n- âœ… Custom error types with From trait\n- âœ… Task manager with CRUD operations\n- âœ… Builder pattern for task creation\n- âœ… Display trait for pretty printing\n\n**Next lesson**: Add file persistence to save and load tasks!\n\n---\n\n**Progress**: Module 9, Lesson 1 complete (49/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-09-02",
          "title": "Module 9, Lesson 2: Saving Data â€” File Persistence",
          "type": "reading",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 9, Lesson 2: Saving Data â€” File Persistence\n\n## Adding File Storage\n\nNow we'll make tasks persist between program runs by saving them to a JSON file.\n\n## Step 1: Add Storage Module\n\nCreate `src/storage.rs`:\n\n```rust\nuse crate::error::Result;\nuse crate::manager::TaskManager;\nuse crate::task::Task;\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::Path;\n\nconst DATA_FILE: &str = \"tasks.json\";\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct StorageData {\n    tasks: Vec<Task>,\n    next_id: u32,\n}\n\npub fn save(manager: &TaskManager) -> Result<()> {\n    let data = StorageData {\n        tasks: manager.tasks.clone(),\n        next_id: manager.next_id,\n    };\n\n    let json = serde_json::to_string_pretty(&data)?;\n    fs::write(DATA_FILE, json)?;\n\n    Ok(())\n}\n\npub fn load() -> Result<TaskManager> {\n    if !Path::new(DATA_FILE).exists() {\n        return Ok(TaskManager::new());\n    }\n\n    let json = fs::read_to_string(DATA_FILE)?;\n    let data: StorageData = serde_json::from_str(&json)?;\n\n    Ok(TaskManager {\n        tasks: data.tasks,\n        next_id: data.next_id,\n    })\n}\n\npub fn clear() -> Result<()> {\n    if Path::new(DATA_FILE).exists() {\n        fs::remove_file(DATA_FILE)?;\n    }\n    Ok(())\n}\n```\n\n## Step 2: Update TaskManager\n\nModify `src/manager.rs` to expose fields needed for storage:\n\n```rust\nuse crate::error::{Result, TaskError};\nuse crate::task::{Priority, Status, Task};\n\npub struct TaskManager {\n    pub(crate) tasks: Vec<Task>,\n    pub(crate) next_id: u32,\n}\n\n// ... rest of implementation stays the same\n```\n\n## Step 3: Update Main\n\nUpdate `src/main.rs` to use persistence:\n\n```rust\nmod error;\nmod manager;\nmod storage;\nmod task;\n\nuse manager::TaskManager;\nuse task::Priority;\n\nfn main() {\n    println!(\"=== TaskMaster with Persistence ===\\n\");\n\n    // Load existing tasks\n    let mut manager = match storage::load() {\n        Ok(mgr) => {\n            println!(\"âœ… Loaded {} tasks from file\\n\", mgr.count());\n            mgr\n        }\n        Err(e) => {\n            eprintln!(\"âš ï¸  Failed to load tasks: {}\", e);\n            eprintln!(\"Starting with empty task list\\n\");\n            TaskManager::new()\n        }\n    };\n\n    // Add a new task\n    if let Ok(id) = manager.add_task(\"Complete Rust course\".to_string()) {\n        manager\n            .update_task(id, |task| {\n                task.with_priority(Priority::High);\n                task.add_tag(\"learning\".to_string());\n            })\n            .ok();\n        println!(\"âœ… Added new task\\n\");\n    }\n\n    // Display all tasks\n    println!(\"Current tasks:\");\n    for task in manager.list_tasks() {\n        println!(\"  {}\", task);\n    }\n\n    // Save to file\n    match storage::save(&manager) {\n        Ok(_) => println!(\"\\nâœ… Saved {} tasks to file\", manager.count()),\n        Err(e) => eprintln!(\"\\nâŒ Failed to save tasks: {}\", e),\n    }\n}\n```\n\n## Step 4: Test Persistence\n\n```bash\n# First run - creates file\ncargo run\n\n# Check the file was created\ncat tasks.json\n\n# Second run - loads existing data\ncargo run\n\n# Third run - should show accumulated tasks\ncargo run\n```\n\n**tasks.json example:**\n\n```json\n{\n  \"tasks\": [\n    {\n      \"id\": 1,\n      \"title\": \"Complete Rust course\",\n      \"description\": null,\n      \"priority\": \"High\",\n      \"status\": \"Todo\",\n      \"tags\": [\"learning\"],\n      \"created_at\": \"2024-01-15T10:30:00.000Z\",\n      \"updated_at\": \"2024-01-15T10:30:00.000Z\",\n      \"due_date\": null\n    }\n  ],\n  \"next_id\": 2\n}\n```\n\n## Step 5: Add Auto-Save\n\nUpdate `TaskManager` to auto-save on modifications:\n\n```rust\n// In manager.rs\n\nimpl TaskManager {\n    pub fn add_task(&mut self, title: String) -> Result<u32> {\n        if title.trim().is_empty() {\n            return Err(TaskError::EmptyTitle);\n        }\n\n        let id = self.next_id;\n        let task = Task::new(id, title);\n        self.tasks.push(task);\n        self.next_id += 1;\n\n        // Auto-save\n        if let Err(e) = crate::storage::save(self) {\n            eprintln!(\"Warning: Failed to save: {}\", e);\n        }\n\n        Ok(id)\n    }\n\n    pub fn delete_task(&mut self, id: u32) -> Result<()> {\n        let pos = self\n            .tasks\n            .iter()\n            .position(|t| t.id == id)\n            .ok_or(TaskError::NotFound(id))?;\n\n        self.tasks.remove(pos);\n\n        // Auto-save\n        if let Err(e) = crate::storage::save(self) {\n            eprintln!(\"Warning: Failed to save: {}\", e);\n        }\n\n        Ok(())\n    }\n\n    pub fn update_task<F>(&mut self, id: u32, update_fn: F) -> Result<()>\n    where\n        F: FnOnce(&mut Task),\n    {\n        let task = self.get_task_mut(id)?;\n        update_fn(task);\n\n        // Auto-save\n        if let Err(e) = crate::storage::save(self) {\n            eprintln!(\"Warning: Failed to save: {}\", e);\n        }\n\n        Ok(())\n    }\n}\n```\n\n## Key Concepts\n\n### **Serialization with Serde**\n\n```rust\n#[derive(Serialize, Deserialize)]\nstruct Task {\n    // Fields automatically serialized/deserialized\n}\n```\n\n**Why**: Convert Rust structs to/from JSON automatically.\n\n### **Graceful Degradation**\n\n```rust\nlet manager = match storage::load() {\n    Ok(mgr) => mgr,\n    Err(e) => {\n        eprintln!(\"Warning: {}\", e);\n        TaskManager::new()  // Fallback\n    }\n};\n```\n\n**Why**: Program works even if file doesn't exist.\n\n### **Module Privacy**\n\n```rust\npub struct TaskManager {\n    pub(crate) tasks: Vec<Task>,  // Visible within crate only\n}\n```\n\n**Why**: Expose fields to storage module without making them public.\n\n## Checkpoint\n\nYou now have:\n- âœ… JSON file persistence\n- âœ… Automatic save on modifications\n- âœ… Graceful fallback if file missing\n- âœ… Pretty-printed JSON format\n- âœ… Preserves task IDs across runs\n\n**Next lesson**: Build the command-line interface with clap!\n\n---\n\n**Progress**: Module 9, Lesson 2 complete (50/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-09-03",
          "title": "Module 9, Lesson 3: User Interaction â€” Building the CLI Interface",
          "type": "project",
          "estimatedMinutes": 8,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 9, Lesson 3: User Interaction â€” Building the CLI Interface\n\n## Creating a Professional CLI\n\nNow we'll build a complete command-line interface using clap for professional argument parsing.\n\n## Step 1: Define CLI Structure\n\nCreate `src/cli.rs`:\n\n```rust\nuse clap::{Parser, Subcommand};\n\n#[derive(Parser)]\n#[command(name = \"taskmaster\")]\n#[command(about = \"A powerful task management CLI\", long_about = None)]\n#[command(version)]\npub struct Cli {\n    #[command(subcommand)]\n    pub command: Commands,\n}\n\n#[derive(Subcommand)]\npub enum Commands {\n    /// Add a new task\n    Add {\n        /// Task title\n        title: String,\n\n        /// Task description\n        #[arg(short, long)]\n        description: Option<String>,\n\n        /// Priority: low, medium, high, urgent\n        #[arg(short, long, default_value = \"medium\")]\n        priority: String,\n\n        /// Tags (comma-separated)\n        #[arg(short, long)]\n        tags: Option<String>,\n    },\n\n    /// List all tasks\n    List {\n        /// Filter by status: todo, inprogress, done\n        #[arg(short, long)]\n        status: Option<String>,\n\n        /// Filter by priority\n        #[arg(short, long)]\n        priority: Option<String>,\n\n        /// Filter by tag\n        #[arg(short, long)]\n        tag: Option<String>,\n    },\n\n    /// Show task details\n    Show {\n        /// Task ID\n        id: u32,\n    },\n\n    /// Update a task\n    Update {\n        /// Task ID\n        id: u32,\n\n        /// New title\n        #[arg(short = 'T', long)]\n        title: Option<String>,\n\n        /// New description\n        #[arg(short, long)]\n        description: Option<String>,\n\n        /// New priority\n        #[arg(short, long)]\n        priority: Option<String>,\n\n        /// New status\n        #[arg(short, long)]\n        status: Option<String>,\n    },\n\n    /// Delete a task\n    Delete {\n        /// Task ID\n        id: u32,\n\n        /// Skip confirmation\n        #[arg(short, long)]\n        force: bool,\n    },\n\n    /// Add tag to task\n    Tag {\n        /// Task ID\n        id: u32,\n\n        /// Tag to add\n        tag: String,\n    },\n\n    /// Remove tag from task\n    Untag {\n        /// Task ID\n        id: u32,\n\n        /// Tag to remove\n        tag: String,\n    },\n\n    /// Mark task as done\n    Done {\n        /// Task ID\n        id: u32,\n    },\n\n    /// Show statistics\n    Stats,\n\n    /// Clear all tasks\n    Clear {\n        /// Skip confirmation\n        #[arg(short, long)]\n        force: bool,\n    },\n}\n```\n\n## Step 2: Implement CLI Handlers\n\nCreate `src/commands.rs`:\n\n```rust\nuse crate::cli::Commands;\nuse crate::error::{Result, TaskError};\nuse crate::manager::TaskManager;\nuse crate::task::{Priority, Status};\nuse std::io::{self, Write};\n\npub fn execute(command: Commands, manager: &mut TaskManager) -> Result<()> {\n    match command {\n        Commands::Add {\n            title,\n            description,\n            priority,\n            tags,\n        } => add_task(manager, title, description, priority, tags),\n\n        Commands::List {\n            status,\n            priority,\n            tag,\n        } => list_tasks(manager, status, priority, tag),\n\n        Commands::Show { id } => show_task(manager, id),\n\n        Commands::Update {\n            id,\n            title,\n            description,\n            priority,\n            status,\n        } => update_task(manager, id, title, description, priority, status),\n\n        Commands::Delete { id, force } => delete_task(manager, id, force),\n\n        Commands::Tag { id, tag } => add_tag(manager, id, tag),\n\n        Commands::Untag { id, tag } => remove_tag(manager, id, tag),\n\n        Commands::Done { id } => mark_done(manager, id),\n\n        Commands::Stats => show_stats(manager),\n\n        Commands::Clear { force } => clear_all(manager, force),\n    }\n}\n\nfn add_task(\n    manager: &mut TaskManager,\n    title: String,\n    description: Option<String>,\n    priority_str: String,\n    tags: Option<String>,\n) -> Result<()> {\n    let priority = Priority::from_str(&priority_str)\n        .ok_or_else(|| TaskError::InvalidPriority(priority_str.clone()))?;\n\n    let id = manager.add_task(title)?;\n\n    manager.update_task(id, |task| {\n        task.with_priority(priority);\n        if let Some(desc) = description {\n            task.with_description(desc);\n        }\n        if let Some(tags_str) = tags {\n            for tag in tags_str.split(',') {\n                task.add_tag(tag.trim().to_string());\n            }\n        }\n    })?;\n\n    println!(\"âœ… Created task #{}\", id);\n    Ok(())\n}\n\nfn list_tasks(\n    manager: &TaskManager,\n    status_filter: Option<String>,\n    priority_filter: Option<String>,\n    tag_filter: Option<String>,\n) -> Result<()> {\n    let mut tasks: Vec<_> = manager.list_tasks().iter().collect();\n\n    // Apply filters\n    if let Some(status_str) = status_filter {\n        let status = Status::from_str(&status_str)\n            .ok_or_else(|| TaskError::InvalidStatus(status_str))?;\n        tasks.retain(|t| t.status == status);\n    }\n\n    if let Some(priority_str) = priority_filter {\n        let priority = Priority::from_str(&priority_str)\n            .ok_or_else(|| TaskError::InvalidPriority(priority_str))?;\n        tasks.retain(|t| t.priority == priority);\n    }\n\n    if let Some(tag) = tag_filter {\n        tasks.retain(|t| t.tags.iter().any(|t_tag| t_tag.contains(&tag)));\n    }\n\n    if tasks.is_empty() {\n        println!(\"No tasks found\");\n        return Ok(());\n    }\n\n    println!(\"Tasks ({}):\", tasks.len());\n    for task in tasks {\n        println!(\"  {}\", task);\n        if !task.tags.is_empty() {\n            println!(\"    Tags: {}\", task.tags.join(\", \"));\n        }\n    }\n\n    Ok(())\n}\n\nfn show_task(manager: &TaskManager, id: u32) -> Result<()> {\n    let task = manager.get_task(id)?;\n\n    println!(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\");\n    println!(\"â•‘              Task Details                     â•‘\");\n    println!(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\");\n    println!(\"â•‘ ID:          {:30} â•‘\", task.id);\n    println!(\"â•‘ Title:       {:30} â•‘\", task.title);\n    println!(\"â•‘ Status:      {:30} â•‘\", task.status.as_str());\n    println!(\"â•‘ Priority:    {:30} â•‘\", task.priority.as_str());\n\n    if let Some(desc) = &task.description {\n        println!(\"â•‘ Description: {:30} â•‘\", desc);\n    }\n\n    if !task.tags.is_empty() {\n        println!(\"â•‘ Tags:        {:30} â•‘\", task.tags.join(\", \"));\n    }\n\n    println!(\n        \"â•‘ Created:     {:30} â•‘\",\n        task.created_at.format(\"%Y-%m-%d %H:%M\").to_string()\n    );\n    println!(\n        \"â•‘ Updated:     {:30} â•‘\",\n        task.updated_at.format(\"%Y-%m-%d %H:%M\").to_string()\n    );\n    println!(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n\n    Ok(())\n}\n\nfn update_task(\n    manager: &mut TaskManager,\n    id: u32,\n    title: Option<String>,\n    description: Option<String>,\n    priority_str: Option<String>,\n    status_str: Option<String>,\n) -> Result<()> {\n    let priority = if let Some(p) = priority_str {\n        Some(\n            Priority::from_str(&p)\n                .ok_or_else(|| TaskError::InvalidPriority(p.clone()))?,\n        )\n    } else {\n        None\n    };\n\n    let status = if let Some(s) = status_str {\n        Some(\n            Status::from_str(&s)\n                .ok_or_else(|| TaskError::InvalidStatus(s.clone()))?,\n        )\n    } else {\n        None\n    };\n\n    manager.update_task(id, |task| {\n        if let Some(t) = title {\n            task.title = t;\n        }\n        if let Some(d) = description {\n            task.description = Some(d);\n        }\n        if let Some(p) = priority {\n            task.priority = p;\n        }\n        if let Some(s) = status {\n            task.set_status(s);\n        }\n    })?;\n\n    println!(\"âœ… Updated task #{}\", id);\n    Ok(())\n}\n\nfn delete_task(manager: &mut TaskManager, id: u32, force: bool) -> Result<()> {\n    if !force {\n        let task = manager.get_task(id)?;\n        print!(\"Delete task '{}' (y/N)? \", task.title);\n        io::stdout().flush()?;\n\n        let mut input = String::new();\n        io::stdin().read_line(&mut input)?;\n\n        if input.trim().to_lowercase() != \"y\" {\n            println!(\"Cancelled\");\n            return Ok(());\n        }\n    }\n\n    manager.delete_task(id)?;\n    println!(\"âœ… Deleted task #{}\", id);\n    Ok(())\n}\n\nfn add_tag(manager: &mut TaskManager, id: u32, tag: String) -> Result<()> {\n    manager.update_task(id, |task| {\n        task.add_tag(tag.clone());\n    })?;\n\n    println!(\"âœ… Added tag '{}' to task #{}\", tag, id);\n    Ok(())\n}\n\nfn remove_tag(manager: &mut TaskManager, id: u32, tag: String) -> Result<()> {\n    manager.update_task(id, |task| {\n        task.remove_tag(&tag);\n    })?;\n\n    println!(\"âœ… Removed tag '{}' from task #{}\", tag, id);\n    Ok(())\n}\n\nfn mark_done(manager: &mut TaskManager, id: u32) -> Result<()> {\n    manager.update_task(id, |task| {\n        task.set_status(Status::Done);\n    })?;\n\n    println!(\"âœ… Marked task #{} as done\", id);\n    Ok(())\n}\n\nfn show_stats(manager: &TaskManager) -> Result<()> {\n    let total = manager.count();\n    let todo = manager\n        .list_tasks()\n        .iter()\n        .filter(|t| t.status == Status::Todo)\n        .count();\n    let in_progress = manager\n        .list_tasks()\n        .iter()\n        .filter(|t| t.status == Status::InProgress)\n        .count();\n    let done = manager\n        .list_tasks()\n        .iter()\n        .filter(|t| t.status == Status::Done)\n        .count();\n\n    println!(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\");\n    println!(\"â•‘        Task Statistics            â•‘\");\n    println!(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\");\n    println!(\"â•‘ Total:       {:17} â•‘\", total);\n    println!(\"â•‘ Todo:        {:17} â•‘\", todo);\n    println!(\"â•‘ In Progress: {:17} â•‘\", in_progress);\n    println!(\"â•‘ Done:        {:17} â•‘\", done);\n    println!(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n\n    if total > 0 {\n        let completion = (done as f64 / total as f64) * 100.0;\n        println!(\"\\nCompletion: {:.1}%\", completion);\n    }\n\n    Ok(())\n}\n\nfn clear_all(manager: &mut TaskManager, force: bool) -> Result<()> {\n    if manager.count() == 0 {\n        println!(\"No tasks to clear\");\n        return Ok(());\n    }\n\n    if !force {\n        print!(\"Clear all {} tasks (y/N)? \", manager.count());\n        io::stdout().flush()?;\n\n        let mut input = String::new();\n        io::stdin().read_line(&mut input)?;\n\n        if input.trim().to_lowercase() != \"y\" {\n            println!(\"Cancelled\");\n            return Ok(());\n        }\n    }\n\n    let count = manager.count();\n    *manager = TaskManager::new();\n    crate::storage::save(manager)?;\n\n    println!(\"âœ… Cleared {} tasks\", count);\n    Ok(())\n}\n```\n\n## Step 3: Update Main\n\nUpdate `src/main.rs`:\n\n```rust\nmod cli;\nmod commands;\nmod error;\nmod manager;\nmod storage;\nmod task;\n\nuse clap::Parser;\nuse cli::Cli;\n\nfn main() {\n    let cli = Cli::parse();\n\n    let mut manager = match storage::load() {\n        Ok(mgr) => mgr,\n        Err(e) => {\n            eprintln!(\"Failed to load tasks: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    if let Err(e) = commands::execute(cli.command, &mut manager) {\n        eprintln!(\"Error: {}\", e);\n        std::process::exit(1);\n    }\n}\n```\n\n## Step 4: Test the CLI\n\n```bash\n# Build the project\ncargo build --release\n\n# Add tasks\ncargo run -- add \"Learn Rust\" -p high -t \"learning,rust\"\ncargo run -- add \"Build project\" -d \"Create a CLI app\" -p medium\n\n# List tasks\ncargo run -- list\ncargo run -- list --status todo\ncargo run -- list --priority high\n\n# Show details\ncargo run -- show 1\n\n# Update task\ncargo run -- update 1 --status inprogress\ncargo run -- update 2 --priority high\n\n# Tag management\ncargo run -- tag 1 important\ncargo run -- untag 1 learning\n\n# Mark complete\ncargo run -- done 1\n\n# Statistics\ncargo run -- stats\n\n# Delete task\ncargo run -- delete 2\ncargo run -- delete 2 --force  # Skip confirmation\n\n# Clear all\ncargo run -- clear\n```\n\n## Usage Examples\n\n### **Adding Tasks**\n\n```bash\ntaskmaster add \"Implement feature X\"\ntaskmaster add \"Fix bug Y\" -p urgent -t \"bug,critical\"\ntaskmaster add \"Write docs\" -d \"Document all functions\" -p low\n```\n\n### **Listing with Filters**\n\n```bash\ntaskmaster list\ntaskmaster list --status todo\ntaskmaster list --priority high\ntaskmaster list --tag bug\n```\n\n### **Task Management**\n\n```bash\ntaskmaster show 5\ntaskmaster update 5 --status inprogress --priority high\ntaskmaster tag 5 review-needed\ntaskmaster done 5\n```\n\n### **Help Command**\n\n```bash\ntaskmaster --help\ntaskmaster add --help\ntaskmaster list --help\n```\n\n## Key Concepts\n\n### **Clap Derive API**\n\n```rust\n#[derive(Parser)]\n#[command(name = \"taskmaster\")]\npub struct Cli {\n    #[command(subcommand)]\n    pub command: Commands,\n}\n```\n\n**Why**: Declarative, type-safe CLI definition with automatic help generation.\n\n### **Error Propagation**\n\n```rust\nif let Err(e) = commands::execute(cli.command, &mut manager) {\n    eprintln!(\"Error: {}\", e);\n    std::process::exit(1);\n}\n```\n\n**Why**: Clean error handling with informative messages.\n\n### **User Confirmation**\n\n```rust\nprint!(\"Delete task (y/N)? \");\nio::stdout().flush()?;  // Ensure prompt displays\n\nlet mut input = String::new();\nio::stdin().read_line(&mut input)?;\n```\n\n**Why**: Prevent accidental destructive operations.\n\n## Checkpoint\n\nYou now have:\n- âœ… Complete CLI with subcommands\n- âœ… Argument parsing with clap\n- âœ… Filtering and searching\n- âœ… Interactive confirmations\n- âœ… Professional help messages\n- âœ… Error handling throughout\n\n**Next lesson**: Advanced filtering and search capabilities!\n\n---\n\n**Progress**: Module 9, Lesson 3 complete (51/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-09-04",
          "title": "Module 9, Lesson 4: Power Features â€” Advanced Filtering & Search",
          "type": "reading",
          "estimatedMinutes": 6,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 9, Lesson 4: Power Features â€” Advanced Filtering & Search\n\n## Adding Search and Advanced Filtering\n\nLet's add powerful search and filtering capabilities using iterators and traits.\n\n## Step 1: Add Filterable Trait\n\nUpdate `src/task.rs` to add searching:\n\n```rust\nimpl Task {\n    pub fn matches_search(&self, query: &str) -> bool {\n        let query_lower = query.to_lowercase();\n\n        self.title.to_lowercase().contains(&query_lower)\n            || self\n                .description\n                .as_ref()\n                .map(|d| d.to_lowercase().contains(&query_lower))\n                .unwrap_or(false)\n            || self.tags.iter().any(|t| t.to_lowercase().contains(&query_lower))\n    }\n\n    pub fn is_overdue(&self) -> bool {\n        if let Some(due) = self.due_date {\n            due < chrono::Local::now()\n        } else {\n            false\n        }\n    }\n\n    pub fn days_until_due(&self) -> Option<i64> {\n        self.due_date.map(|due| {\n            let duration = due.signed_duration_since(chrono::Local::now());\n            duration.num_days()\n        })\n    }\n}\n```\n\n## Step 2: Add Filter Builder\n\nCreate `src/filter.rs`:\n\n```rust\nuse crate::task::{Priority, Status, Task};\n\npub struct TaskFilter<'a> {\n    tasks: &'a [Task],\n}\n\nimpl<'a> TaskFilter<'a> {\n    pub fn new(tasks: &'a [Task]) -> Self {\n        TaskFilter { tasks }\n    }\n\n    pub fn by_status(self, status: Status) -> Vec<&'a Task> {\n        self.tasks\n            .iter()\n            .filter(|t| t.status == status)\n            .collect()\n    }\n\n    pub fn by_priority(self, priority: Priority) -> Vec<&'a Task> {\n        self.tasks\n            .iter()\n            .filter(|t| t.priority == priority)\n            .collect()\n    }\n\n    pub fn by_tag(self, tag: &str) -> Vec<&'a Task> {\n        self.tasks\n            .iter()\n            .filter(|t| t.tags.iter().any(|t_tag| t_tag.contains(tag)))\n            .collect()\n    }\n\n    pub fn search(self, query: &str) -> Vec<&'a Task> {\n        self.tasks\n            .iter()\n            .filter(|t| t.matches_search(query))\n            .collect()\n    }\n\n    pub fn overdue(self) -> Vec<&'a Task> {\n        self.tasks.iter().filter(|t| t.is_overdue()).collect()\n    }\n\n    pub fn due_soon(self, days: i64) -> Vec<&'a Task> {\n        self.tasks\n            .iter()\n            .filter(|t| {\n                if let Some(days_until) = t.days_until_due() {\n                    days_until >= 0 && days_until <= days\n                } else {\n                    false\n                }\n            })\n            .collect()\n    }\n\n    pub fn sort_by_priority(mut self) -> Vec<&'a Task> {\n        let mut tasks: Vec<&Task> = self.tasks.iter().collect();\n        tasks.sort_by(|a, b| {\n            let priority_order = |p: &Priority| match p {\n                Priority::Urgent => 0,\n                Priority::High => 1,\n                Priority::Medium => 2,\n                Priority::Low => 3,\n            };\n            priority_order(&a.priority).cmp(&priority_order(&b.priority))\n        });\n        tasks\n    }\n\n    pub fn sort_by_due_date(mut self) -> Vec<&'a Task> {\n        let mut tasks: Vec<&Task> = self.tasks.iter().collect();\n        tasks.sort_by(|a, b| {\n            match (a.due_date, b.due_date) {\n                (Some(a_due), Some(b_due)) => a_due.cmp(&b_due),\n                (Some(_), None) => std::cmp::Ordering::Less,\n                (None, Some(_)) => std::cmp::Ordering::Greater,\n                (None, None) => std::cmp::Ordering::Equal,\n            }\n        });\n        tasks\n    }\n}\n```\n\n## Step 3: Add Search Command\n\nUpdate `src/cli.rs`:\n\n```rust\n#[derive(Subcommand)]\npub enum Commands {\n    // ... existing commands ...\n\n    /// Search tasks\n    Search {\n        /// Search query\n        query: String,\n    },\n\n    /// Show overdue tasks\n    Overdue,\n\n    /// Show tasks due soon\n    DueSoon {\n        /// Number of days\n        #[arg(default_value = \"7\")]\n        days: i64,\n    },\n}\n```\n\n## Step 4: Implement Search Commands\n\nUpdate `src/commands.rs`:\n\n```rust\nuse crate::filter::TaskFilter;\n\npub fn execute(command: Commands, manager: &mut TaskManager) -> Result<()> {\n    match command {\n        // ... existing commands ...\n\n        Commands::Search { query } => search_tasks(manager, query),\n        Commands::Overdue => show_overdue(manager),\n        Commands::DueSoon { days } => show_due_soon(manager, days),\n    }\n}\n\nfn search_tasks(manager: &TaskManager, query: String) -> Result<()> {\n    let filter = TaskFilter::new(manager.list_tasks());\n    let results = filter.search(&query);\n\n    if results.is_empty() {\n        println!(\"No tasks found matching '{}'\", query);\n        return Ok(());\n    }\n\n    println!(\"Found {} task(s) matching '{}':\", results.len(), query);\n    for task in results {\n        println!(\"  {}\", task);\n    }\n\n    Ok(())\n}\n\nfn show_overdue(manager: &TaskManager) -> Result<()> {\n    let filter = TaskFilter::new(manager.list_tasks());\n    let overdue = filter.overdue();\n\n    if overdue.is_empty() {\n        println!(\"âœ… No overdue tasks\");\n        return Ok(());\n    }\n\n    println!(\"âš ï¸  {} overdue task(s):\", overdue.len());\n    for task in overdue {\n        if let Some(days) = task.days_until_due() {\n            println!(\"  {} (overdue by {} days)\", task, days.abs());\n        } else {\n            println!(\"  {}\", task);\n        }\n    }\n\n    Ok(())\n}\n\nfn show_due_soon(manager: &TaskManager, days: i64) -> Result<()> {\n    let filter = TaskFilter::new(manager.list_tasks());\n    let due_soon = filter.due_soon(days);\n\n    if due_soon.is_empty() {\n        println!(\"No tasks due in the next {} days\", days);\n        return Ok(());\n    }\n\n    println!(\"{} task(s) due in the next {} days:\", due_soon.len(), days);\n    for task in due_soon {\n        if let Some(days_until) = task.days_until_due() {\n            println!(\"  {} (due in {} days)\", task, days_until);\n        }\n    }\n\n    Ok(())\n}\n```\n\n## Step 5: Add Due Date Support\n\nUpdate `src/cli.rs` to add due date to Add command:\n\n```rust\nCommands::Add {\n    // ... existing fields ...\n\n    /// Due date (YYYY-MM-DD)\n    #[arg(short = 'D', long)]\n    due: Option<String>,\n},\n```\n\nUpdate `src/commands.rs` add_task function:\n\n```rust\nfn add_task(\n    manager: &mut TaskManager,\n    title: String,\n    description: Option<String>,\n    priority_str: String,\n    tags: Option<String>,\n    due_str: Option<String>,\n) -> Result<()> {\n    let priority = Priority::from_str(&priority_str)\n        .ok_or_else(|| TaskError::InvalidPriority(priority_str.clone()))?;\n\n    let due_date = if let Some(date_str) = due_str {\n        Some(\n            chrono::NaiveDate::parse_from_str(&date_str, \"%Y-%m-%d\")\n                .map_err(|_| TaskError::InvalidDate(date_str.clone()))?\n                .and_hms_opt(23, 59, 59)\n                .ok_or_else(|| TaskError::InvalidDate(date_str.clone()))?\n                .and_local_timezone(chrono::Local)\n                .single()\n                .ok_or_else(|| TaskError::InvalidDate(date_str))?,\n        )\n    } else {\n        None\n    };\n\n    let id = manager.add_task(title)?;\n\n    manager.update_task(id, |task| {\n        task.with_priority(priority);\n        if let Some(desc) = description {\n            task.with_description(desc);\n        }\n        if let Some(tags_str) = tags {\n            for tag in tags_str.split(',') {\n                task.add_tag(tag.trim().to_string());\n            }\n        }\n        if let Some(due) = due_date {\n            task.due_date = Some(due);\n        }\n    })?;\n\n    println!(\"âœ… Created task #{}\", id);\n    Ok(())\n}\n```\n\nAdd InvalidDate to `src/error.rs`:\n\n```rust\n#[derive(Debug)]\npub enum TaskError {\n    // ... existing variants ...\n    InvalidDate(String),\n}\n\nimpl fmt::Display for TaskError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            // ... existing cases ...\n            TaskError::InvalidDate(s) => write!(f, \"Invalid date format: {} (use YYYY-MM-DD)\", s),\n        }\n    }\n}\n```\n\n## Usage Examples\n\n### **Advanced Search**\n\n```bash\n# Search across title, description, and tags\ntaskmaster search rust\ntaskmaster search \"bug fix\"\ntaskmaster search urgent\n```\n\n### **Due Date Management**\n\n```bash\n# Add task with due date\ntaskmaster add \"Submit report\" -D 2024-12-31 -p high\n\n# Show overdue tasks\ntaskmaster overdue\n\n# Show tasks due in next 7 days\ntaskmaster due-soon\n\n# Show tasks due in next 30 days\ntaskmaster due-soon 30\n```\n\n### **Combined Filtering**\n\n```bash\n# High priority todos\ntaskmaster list --status todo --priority high\n\n# Tasks with specific tag\ntaskmaster list --tag urgent\n\n# Search within filtered results\ntaskmaster search \"bug\" | grep -i \"high\"\n```\n\n## Key Concepts\n\n### **Fluent Filter API**\n\n```rust\nTaskFilter::new(tasks)\n    .by_status(Status::Todo)\n    .sort_by_priority()\n```\n\n**Why**: Composable, readable filtering with method chaining.\n\n### **Iterator Chains**\n\n```rust\ntasks\n    .iter()\n    .filter(|t| t.matches_search(query))\n    .collect()\n```\n\n**Why**: Efficient, lazy evaluation with functional style.\n\n### **Option Handling**\n\n```rust\ntask.days_until_due().map(|days| {\n    // Process days value\n})\n```\n\n**Why**: Safe handling of optional due dates.\n\n## Checkpoint\n\nYou now have:\n- âœ… Full-text search across all task fields\n- âœ… Advanced filtering by multiple criteria\n- âœ… Due date support with parsing\n- âœ… Overdue task detection\n- âœ… Sortable task lists\n- âœ… Composable filter API\n\n**Next lesson**: Statistics, reports, and data visualization!\n\n---\n\n**Progress**: Module 9, Lesson 4 complete (52/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-09-05",
          "title": "Module 9, Lesson 5: Insights â€” Statistics and Reports",
          "type": "reading",
          "estimatedMinutes": 6,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 9, Lesson 5: Insights â€” Statistics and Reports\n\n## Generating Insights from Task Data\n\nLet's add comprehensive statistics and reporting capabilities.\n\n## Step 1: Create Stats Module\n\nCreate `src/stats.rs`:\n\n```rust\nuse crate::task::{Priority, Status, Task};\nuse std::collections::HashMap;\n\npub struct TaskStats {\n    pub total: usize,\n    pub by_status: HashMap<Status, usize>,\n    pub by_priority: HashMap<Priority, usize>,\n    pub completed_percentage: f64,\n    pub overdue_count: usize,\n    pub average_age_days: f64,\n}\n\nimpl TaskStats {\n    pub fn from_tasks(tasks: &[Task]) -> Self {\n        let total = tasks.len();\n\n        let mut by_status = HashMap::new();\n        for status in [Status::Todo, Status::InProgress, Status::Done] {\n            let count = tasks.iter().filter(|t| t.status == status).count();\n            by_status.insert(status, count);\n        }\n\n        let mut by_priority = HashMap::new();\n        for priority in [\n            Priority::Low,\n            Priority::Medium,\n            Priority::High,\n            Priority::Urgent,\n        ] {\n            let count = tasks.iter().filter(|t| t.priority == priority).count();\n            by_priority.insert(priority, count);\n        }\n\n        let done_count = *by_status.get(&Status::Done).unwrap_or(&0);\n        let completed_percentage = if total > 0 {\n            (done_count as f64 / total as f64) * 100.0\n        } else {\n            0.0\n        };\n\n        let overdue_count = tasks.iter().filter(|t| t.is_overdue()).count();\n\n        let total_age_days: i64 = tasks\n            .iter()\n            .map(|t| {\n                let duration = chrono::Local::now().signed_duration_since(t.created_at);\n                duration.num_days()\n            })\n            .sum();\n\n        let average_age_days = if total > 0 {\n            total_age_days as f64 / total as f64\n        } else {\n            0.0\n        };\n\n        TaskStats {\n            total,\n            by_status,\n            by_priority,\n            completed_percentage,\n            overdue_count,\n            average_age_days,\n        }\n    }\n\n    pub fn display(&self) {\n        println!(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\");\n        println!(\"â•‘         Task Statistics Report            â•‘\");\n        println!(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\");\n        println!(\"â•‘                                           â•‘\");\n        println!(\"â•‘ Overview                                  â•‘\");\n        println!(\"â•‘   Total tasks:        {:17} â•‘\", self.total);\n        println!(\n            \"â•‘   Completion rate:    {:15.1}% â•‘\",\n            self.completed_percentage\n        );\n        println!(\"â•‘   Overdue tasks:      {:17} â•‘\", self.overdue_count);\n        println!(\n            \"â•‘   Average age:        {:13.1} days â•‘\",\n            self.average_age_days\n        );\n        println!(\"â•‘                                           â•‘\");\n        println!(\"â•‘ By Status                                 â•‘\");\n        println!(\n            \"â•‘   Todo:               {:17} â•‘\",\n            self.by_status.get(&Status::Todo).unwrap_or(&0)\n        );\n        println!(\n            \"â•‘   In Progress:        {:17} â•‘\",\n            self.by_status.get(&Status::InProgress).unwrap_or(&0)\n        );\n        println!(\n            \"â•‘   Done:               {:17} â•‘\",\n            self.by_status.get(&Status::Done).unwrap_or(&0)\n        );\n        println!(\"â•‘                                           â•‘\");\n        println!(\"â•‘ By Priority                               â•‘\");\n        println!(\n            \"â•‘   Urgent:             {:17} â•‘\",\n            self.by_priority.get(&Priority::Urgent).unwrap_or(&0)\n        );\n        println!(\n            \"â•‘   High:               {:17} â•‘\",\n            self.by_priority.get(&Priority::High).unwrap_or(&0)\n        );\n        println!(\n            \"â•‘   Medium:             {:17} â•‘\",\n            self.by_priority.get(&Priority::Medium).unwrap_or(&0)\n        );\n        println!(\n            \"â•‘   Low:                {:17} â•‘\",\n            self.by_priority.get(&Priority::Low).unwrap_or(&0)\n        );\n        println!(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n    }\n\n    pub fn progress_bar(&self, width: usize) -> String {\n        let filled = ((self.completed_percentage / 100.0) * width as f64) as usize;\n        let empty = width - filled;\n\n        format!(\n            \"[{}{}] {:.1}%\",\n            \"â–ˆ\".repeat(filled),\n            \"â–‘\".repeat(empty),\n            self.completed_percentage\n        )\n    }\n}\n\npub fn tag_distribution(tasks: &[Task]) -> HashMap<String, usize> {\n    let mut distribution = HashMap::new();\n\n    for task in tasks {\n        for tag in &task.tags {\n            *distribution.entry(tag.clone()).or_insert(0) += 1;\n        }\n    }\n\n    distribution\n}\n\npub fn productivity_summary(tasks: &[Task], days: i64) -> ProductivitySummary {\n    let cutoff = chrono::Local::now() - chrono::Duration::days(days);\n\n    let recent_completed = tasks\n        .iter()\n        .filter(|t| t.status == Status::Done && t.updated_at >= cutoff)\n        .count();\n\n    let recent_created = tasks\n        .iter()\n        .filter(|t| t.created_at >= cutoff)\n        .count();\n\n    let tasks_per_day = recent_completed as f64 / days as f64;\n\n    ProductivitySummary {\n        days,\n        tasks_completed: recent_completed,\n        tasks_created: recent_created,\n        completion_rate: tasks_per_day,\n    }\n}\n\npub struct ProductivitySummary {\n    pub days: i64,\n    pub tasks_completed: usize,\n    pub tasks_created: usize,\n    pub completion_rate: f64,\n}\n\nimpl ProductivitySummary {\n    pub fn display(&self) {\n        println!(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\");\n        println!(\"â•‘      Productivity Report (Last {} days)  â•‘\", self.days);\n        println!(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\");\n        println!(\n            \"â•‘ Tasks completed:      {:17} â•‘\",\n            self.tasks_completed\n        );\n        println!(\"â•‘ Tasks created:        {:17} â•‘\", self.tasks_created);\n        println!(\n            \"â•‘ Completion rate:      {:13.2}/day â•‘\",\n            self.completion_rate\n        );\n        println!(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n    }\n}\n```\n\n## Step 2: Update Commands\n\nUpdate `src/cli.rs`:\n\n```rust\nCommands::Stats {\n    /// Show detailed statistics\n    #[arg(short, long)]\n    detailed: bool,\n},\n\n/// Show productivity report\nProductivity {\n    /// Number of days to analyze\n    #[arg(default_value = \"7\")]\n    days: i64,\n},\n\n/// Show tag distribution\nTags,\n\n/// Export tasks to file\nExport {\n    /// Output file\n    #[arg(default_value = \"tasks_export.json\")]\n    file: String,\n},\n```\n\nUpdate `src/commands.rs`:\n\n```rust\nuse crate::stats::{productivity_summary, tag_distribution, TaskStats};\n\nCommands::Stats { detailed } => {\n    show_stats(manager, detailed)\n}\n\nCommands::Productivity { days } => {\n    show_productivity(manager, days)\n}\n\nCommands::Tags => show_tags(manager),\n\nCommands::Export { file } => export_tasks(manager, &file),\n\nfn show_stats(manager: &TaskManager, detailed: bool) -> Result<()> {\n    let stats = TaskStats::from_tasks(manager.list_tasks());\n\n    if detailed {\n        stats.display();\n    } else {\n        println!(\"Tasks: {} total\", stats.total);\n        println!(\n            \"Progress: {}\",\n            stats.progress_bar(30)\n        );\n\n        if stats.overdue_count > 0 {\n            println!(\"âš ï¸  {} overdue\", stats.overdue_count);\n        }\n    }\n\n    Ok(())\n}\n\nfn show_productivity(manager: &TaskManager, days: i64) -> Result<()> {\n    let summary = productivity_summary(manager.list_tasks(), days);\n    summary.display();\n    Ok(())\n}\n\nfn show_tags(manager: &TaskManager) -> Result<()> {\n    let distribution = tag_distribution(manager.list_tasks());\n\n    if distribution.is_empty() {\n        println!(\"No tags found\");\n        return Ok(());\n    }\n\n    let mut tags: Vec<_> = distribution.into_iter().collect();\n    tags.sort_by(|a, b| b.1.cmp(&a.1)); // Sort by count descending\n\n    println!(\"Tag Distribution:\");\n    for (tag, count) in tags {\n        println!(\"  {:20} {}\", tag, count);\n    }\n\n    Ok(())\n}\n\nfn export_tasks(manager: &TaskManager, filename: &str) -> Result<()> {\n    let json = serde_json::to_string_pretty(manager.list_tasks())?;\n    std::fs::write(filename, json)?;\n\n    println!(\"âœ… Exported {} tasks to {}\", manager.count(), filename);\n    Ok(())\n}\n```\n\n## Step 3: Add Report Command\n\nCreate a comprehensive report combining all stats:\n\n```rust\nCommands::Report => generate_report(manager),\n\nfn generate_report(manager: &TaskManager) -> Result<()> {\n    let stats = TaskStats::from_tasks(manager.list_tasks());\n\n    println!(\"\\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n    println!(\"            TASKMASTER REPORT\");\n    println!(\"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n\");\n\n    // Overview\n    stats.display();\n\n    // Productivity\n    println!();\n    let productivity = productivity_summary(manager.list_tasks(), 7);\n    productivity.display();\n\n    // Tag distribution\n    println!();\n    let distribution = tag_distribution(manager.list_tasks());\n    if !distribution.is_empty() {\n        println!(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\");\n        println!(\"â•‘           Tag Distribution                â•‘\");\n        println!(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\");\n\n        let mut tags: Vec<_> = distribution.into_iter().collect();\n        tags.sort_by(|a, b| b.1.cmp(&a.1));\n        tags.truncate(5); // Top 5\n\n        for (tag, count) in tags {\n            println!(\"â•‘ {:30} {:8} â•‘\", tag, count);\n        }\n        println!(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n    }\n\n    // Urgent items\n    println!();\n    let urgent = manager\n        .list_tasks()\n        .iter()\n        .filter(|t| t.priority == Priority::Urgent && t.status != Status::Done)\n        .collect::<Vec<_>>();\n\n    if !urgent.is_empty() {\n        println!(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\");\n        println!(\"â•‘           Urgent Items                    â•‘\");\n        println!(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\");\n        for task in urgent {\n            println!(\"â•‘ {:<42} â•‘\", format!(\"#{} - {}\", task.id, task.title));\n        }\n        println!(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n    }\n\n    Ok(())\n}\n```\n\n## Usage Examples\n\n### **Quick Stats**\n\n```bash\ntaskmaster stats\n# Output:\n# Tasks: 25 total\n# Progress: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 40.0%\n```\n\n### **Detailed Statistics**\n\n```bash\ntaskmaster stats --detailed\n```\n\n### **Productivity Analysis**\n\n```bash\ntaskmaster productivity       # Last 7 days\ntaskmaster productivity 30    # Last 30 days\n```\n\n### **Tag Analysis**\n\n```bash\ntaskmaster tags\n# Output:\n# Tag Distribution:\n#   bug                  5\n#   feature              3\n#   documentation        2\n```\n\n### **Complete Report**\n\n```bash\ntaskmaster report\n```\n\n### **Export Data**\n\n```bash\ntaskmaster export\ntaskmaster export tasks_backup.json\n```\n\n## Key Concepts\n\n### **Aggregate Statistics**\n\n```rust\nlet total_age: i64 = tasks\n    .iter()\n    .map(|t| calculate_age(t))\n    .sum();\n```\n\n**Why**: Iterator methods for efficient data aggregation.\n\n### **HashMap for Grouping**\n\n```rust\nlet mut by_status = HashMap::new();\nfor task in tasks {\n    *by_status.entry(task.status).or_insert(0) += 1;\n}\n```\n\n**Why**: Count occurrences by category efficiently.\n\n### **Visual Progress Indicators**\n\n```rust\nfn progress_bar(&self, width: usize) -> String {\n    let filled = ((self.percentage / 100.0) * width as f64) as usize;\n    format!(\"[{}{}]\", \"â–ˆ\".repeat(filled), \"â–‘\".repeat(width - filled))\n}\n```\n\n**Why**: User-friendly visual feedback in CLI.\n\n## Checkpoint\n\nYou now have:\n- âœ… Comprehensive statistics reports\n- âœ… Progress visualization\n- âœ… Productivity tracking\n- âœ… Tag distribution analysis\n- âœ… Data export functionality\n- âœ… Multi-faceted reporting\n\n**Next lesson**: Final polish and deployment!\n\n---\n\n**Progress**: Module 9, Lesson 5 complete (53/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-09-06",
          "title": "Module 9, Lesson 6: Finishing Touches â€” Testing & Deployment",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 9, Lesson 6: Finishing Touches â€” Testing & Deployment\n\n## Final Polish and Production Readiness\n\nLet's add the finishing touches to make TaskMaster production-ready.\n\n## Step 1: Add Unit Tests\n\nCreate `src/task_tests.rs`:\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::task::{Priority, Status, Task};\n\n    #[test]\n    fn test_task_creation() {\n        let task = Task::new(1, \"Test task\".to_string());\n        assert_eq!(task.id, 1);\n        assert_eq!(task.title, \"Test task\");\n        assert_eq!(task.status, Status::Todo);\n        assert_eq!(task.priority, Priority::Medium);\n    }\n\n    #[test]\n    fn test_task_builder() {\n        let task = Task::new(1, \"Test\".to_string())\n            .with_priority(Priority::High)\n            .with_description(\"Description\".to_string());\n\n        assert_eq!(task.priority, Priority::High);\n        assert_eq!(task.description, Some(\"Description\".to_string()));\n    }\n\n    #[test]\n    fn test_task_search() {\n        let task = Task::new(1, \"Learn Rust\".to_string())\n            .with_description(\"Study ownership\".to_string());\n\n        assert!(task.matches_search(\"rust\"));\n        assert!(task.matches_search(\"ownership\"));\n        assert!(!task.matches_search(\"python\"));\n    }\n\n    #[test]\n    fn test_tag_management() {\n        let mut task = Task::new(1, \"Test\".to_string());\n\n        task.add_tag(\"important\".to_string());\n        assert_eq!(task.tags.len(), 1);\n\n        task.add_tag(\"urgent\".to_string());\n        assert_eq!(task.tags.len(), 2);\n\n        task.remove_tag(\"important\");\n        assert_eq!(task.tags.len(), 1);\n        assert!(task.tags.contains(&\"urgent\".to_string()));\n    }\n}\n```\n\nRun tests:\n\n```bash\ncargo test\n```\n\n## Step 2: Add Configuration\n\nCreate `src/config.rs`:\n\n```rust\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::PathBuf;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Config {\n    pub data_file: String,\n    pub auto_save: bool,\n    pub default_priority: String,\n}\n\nimpl Default for Config {\n    fn default() -> Self {\n        Config {\n            data_file: \"tasks.json\".to_string(),\n            auto_save: true,\n            default_priority: \"medium\".to_string(),\n        }\n    }\n}\n\nimpl Config {\n    pub fn load() -> Self {\n        let config_path = Self::config_path();\n\n        if config_path.exists() {\n            if let Ok(content) = fs::read_to_string(&config_path) {\n                if let Ok(config) = serde_json::from_str(&content) {\n                    return config;\n                }\n            }\n        }\n\n        Config::default()\n    }\n\n    pub fn save(&self) -> std::io::Result<()> {\n        let config_path = Self::config_path();\n\n        if let Some(parent) = config_path.parent() {\n            fs::create_dir_all(parent)?;\n        }\n\n        let json = serde_json::to_string_pretty(self)?;\n        fs::write(&config_path, json)?;\n\n        Ok(())\n    }\n\n    fn config_path() -> PathBuf {\n        dirs::config_dir()\n            .unwrap_or_else(|| PathBuf::from(\".\"))\n            .join(\"taskmaster\")\n            .join(\"config.json\")\n    }\n}\n```\n\nAdd `dirs` dependency to `Cargo.toml`:\n\n```toml\n[dependencies]\ndirs = \"5.0\"\n```\n\n## Step 3: Add README\n\nCreate a comprehensive `README.md`:\n\n```markdown\n# TaskMaster\n\nA powerful command-line task manager built with Rust.\n\n## Features\n\n- âœ… Create, update, and delete tasks\n- âœ… Priority levels (Low, Medium, High, Urgent)\n- âœ… Status tracking (Todo, In Progress, Done)\n- âœ… Tags for organization\n- âœ… Due dates with overdue detection\n- âœ… Full-text search\n- âœ… Statistics and productivity reports\n- âœ… JSON file persistence\n- âœ… Export/import functionality\n\n## Installation\n\n### From Source\n\n```bash\ngit clone https://github.com/yourusername/taskmaster.git\ncd taskmaster\ncargo build --release\ncargo install --path .\n```\n\n## Usage\n\n### Basic Commands\n\n```bash\n# Add a task\ntaskmaster add \"Learn Rust\" -p high -t learning\n\n# List tasks\ntaskmaster list\ntaskmaster list --status todo\ntaskmaster list --priority high\n\n# Show task details\ntaskmaster show 1\n\n# Update task\ntaskmaster update 1 --status inprogress\ntaskmaster update 1 --priority urgent\n\n# Mark as done\ntaskmaster done 1\n\n# Delete task\ntaskmaster delete 1\n```\n\n### Advanced Features\n\n```bash\n# Search tasks\ntaskmaster search \"rust\"\n\n# Show overdue tasks\ntaskmaster overdue\n\n# Show tasks due soon\ntaskmaster due-soon 7\n\n# Statistics\ntaskmaster stats\ntaskmaster stats --detailed\n\n# Productivity report\ntaskmaster productivity 30\n\n# Complete report\ntaskmaster report\n\n# Export data\ntaskmaster export tasks_backup.json\n```\n\n## Configuration\n\nTaskMaster stores configuration in `~/.config/taskmaster/config.json`:\n\n```json\n{\n  \"data_file\": \"tasks.json\",\n  \"auto_save\": true,\n  \"default_priority\": \"medium\"\n}\n```\n\n## License\n\nMIT\n\n## Contributing\n\nContributions welcome! Please open an issue or PR.\n```\n\n## Step 4: Build Release Binary\n\n```bash\n# Build optimized release binary\ncargo build --release\n\n# Binary located at: target/release/taskmaster\n\n# Install globally (Unix-like systems)\ncargo install --path .\n\n# Create distributable package\ncargo build --release\nstrip target/release/taskmaster  # Reduce binary size\n```\n\n## Step 5: Add Shell Completions\n\nAdd to `src/main.rs`:\n\n```rust\nuse clap::CommandFactory;\nuse clap_complete::{generate_to, shells::*};\n\n// Generate shell completions\nfn generate_completions() {\n    let mut cmd = Cli::command();\n    let bin_name = \"taskmaster\";\n\n    let outdir = std::env::var_os(\"OUT_DIR\").unwrap();\n\n    generate_to(Bash, &mut cmd, bin_name, &outdir).ok();\n    generate_to(Zsh, &mut cmd, bin_name, &outdir).ok();\n    generate_to(Fish, &mut cmd, bin_name, &outdir).ok();\n}\n```\n\nAdd dependency:\n\n```toml\n[dependencies]\nclap_complete = \"4.5\"\n```\n\n## Usage as Library\n\nTaskMaster can also be used as a library:\n\n```rust\nuse taskmaster::{TaskManager, Task, Priority};\n\nfn main() {\n    let mut manager = TaskManager::new();\n\n    let id = manager.add_task(\"My task\".to_string()).unwrap();\n\n    manager.update_task(id, |task| {\n        task.with_priority(Priority::High);\n    }).unwrap();\n\n    for task in manager.list_tasks() {\n        println!(\"{}\", task);\n    }\n}\n```\n\n## Complete Example: Daily Workflow\n\n```bash\n#!/bin/bash\n# daily_tasks.sh\n\n# Morning routine\ntaskmaster list --status todo --priority urgent\ntaskmaster overdue\ntaskmaster due-soon 1\n\n# During work\ntaskmaster add \"Review PR #123\" -p high -t review\ntaskmaster update 15 --status inprogress\ntaskmaster done 12\n\n# End of day\ntaskmaster stats --detailed\ntaskmaster productivity 1\ntaskmaster export daily_backup.json\n```\n\n## Troubleshooting\n\n### Tasks not persisting\n\nCheck file permissions for `tasks.json`:\n\n```bash\nls -l tasks.json\nchmod 644 tasks.json\n```\n\n### Performance with many tasks\n\nTaskMaster efficiently handles thousands of tasks. If experiencing slowness:\n\n```bash\n# Export and archive old completed tasks\ntaskmaster export archive.json\ntaskmaster list --status done | # filter and delete old ones\n```\n\n## Capstone Project Complete! ðŸŽ‰\n\nYou've built a professional-grade CLI application demonstrating:\n\n- âœ… **Structs & Enums**: Task, Priority, Status\n- âœ… **Error Handling**: Custom errors with From trait\n- âœ… **File I/O**: JSON persistence\n- âœ… **Traits**: Display, Serialize, Deserialize\n- âœ… **Generics**: Flexible functions\n- âœ… **Iterators**: Filtering, mapping, collecting\n- âœ… **CLI Parsing**: clap with subcommands\n- âœ… **Testing**: Unit tests\n- âœ… **Documentation**: Comprehensive README\n\n## Next Steps\n\n**Optional enhancements:**\n\n1. **Database backend**: SQLite instead of JSON\n2. **Sync**: Cloud synchronization\n3. **Web interface**: REST API with web UI\n4. **Mobile app**: Share data with mobile client\n5. **AI features**: Smart task suggestions\n6. **Team features**: Shared task lists\n7. **Notifications**: Desktop/email reminders\n8. **Time tracking**: Log time spent on tasks\n9. **Recurring tasks**: Scheduled repetition\n10. **Subtasks**: Task hierarchies\n\n## Deployment Options\n\n### **As CLI Tool**\n\n```bash\ncargo install --path .\n```\n\n### **Distribute Binary**\n\n```bash\n# Create releases for multiple platforms\ncargo build --release --target x86_64-unknown-linux-gnu\ncargo build --release --target x86_64-apple-darwin\ncargo build --release --target x86_64-pc-windows-msvc\n```\n\n### **Publish to crates.io**\n\n```bash\ncargo publish\n```\n\n---\n\n**Progress**: Module 9, Lesson 6 complete (54/60 lessons total)\n\n**Next**: Quiz to test your understanding of building complete applications!\n"
          }
        }
      ]
    },
    {
      "id": "module-10",
      "title": "MODULE 10",
      "description": "Module 10",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-10-01",
          "title": "Module 10: The Rust Ecosystem",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 10: The Rust Ecosystem\n\n# Lesson 1: Mastering Cargo â€” Features, Workspaces & More\n\n## Understanding Cargo.toml\n\nCargo.toml is the heart of every Rust project. Let's explore its full capabilities.\n\n## Basic Structure\n\n```toml\n[package]\nname = \"my_project\"\nversion = \"0.1.0\"\nedition = \"2021\"\nauthors = [\"Your Name <you@example.com>\"]\ndescription = \"A brief description\"\nlicense = \"MIT\"\nrepository = \"https://github.com/username/project\"\nkeywords = [\"cli\", \"tool\"]\ncategories = [\"command-line-utilities\"]\n\n[dependencies]\n# Regular dependencies\n\n[dev-dependencies]\n# Test-only dependencies\n\n[build-dependencies]\n# Build script dependencies\n```\n\n## Dependency Specifications\n\n### **Version Requirements**\n\n```toml\n[dependencies]\n# Exact version\nserde = \"=1.0.0\"\n\n# Caret (compatible updates)\nserde = \"^1.0\"    # >= 1.0.0, < 2.0.0\nserde = \"1.0\"     # Same as ^1.0\n\n# Tilde (minor updates only)\nserde = \"~1.2\"    # >= 1.2.0, < 1.3.0\n\n# Wildcard\nserde = \"1.*\"     # >= 1.0.0, < 2.0.0\n\n# Greater/less than\nserde = \">= 1.0, < 2.0\"\n\n# Latest\nserde = \"*\"       # Not recommended!\n```\n\n### **Git Dependencies**\n\n```toml\n[dependencies]\nmy_crate = { git = \"https://github.com/user/repo\" }\n\n# Specific branch\nmy_crate = { git = \"https://github.com/user/repo\", branch = \"develop\" }\n\n# Specific tag\nmy_crate = { git = \"https://github.com/user/repo\", tag = \"v1.0.0\" }\n\n# Specific commit\nmy_crate = { git = \"https://github.com/user/repo\", rev = \"abc123\" }\n```\n\n### **Path Dependencies**\n\n```toml\n[dependencies]\nmy_local_crate = { path = \"../my_local_crate\" }\n```\n\n## Features\n\nFeatures enable conditional compilation:\n\n```toml\n[features]\ndefault = [\"std\"]  # Enabled by default\nstd = []\nserde = [\"dep:serde\", \"dep:serde_json\"]\nexperimental = []\n\n[dependencies]\nserde = { version = \"1.0\", optional = true }\nserde_json = { version = \"1.0\", optional = true }\n```\n\n**Usage:**\n\n```bash\n# Build with specific features\ncargo build --features serde\ncargo build --features \"serde experimental\"\n\n# Build without default features\ncargo build --no-default-features\n\n# Build with all features\ncargo build --all-features\n```\n\n**In code:**\n\n```rust\n#[cfg(feature = \"serde\")]\nuse serde::{Serialize, Deserialize};\n\n#[cfg(feature = \"serde\")]\n#[derive(Serialize, Deserialize)]\npub struct Data {\n    value: i32,\n}\n\n#[cfg(not(feature = \"serde\"))]\npub struct Data {\n    value: i32,\n}\n```\n\n## Workspaces\n\nManage multiple related packages:\n\n### **Workspace Cargo.toml (root)**\n\n```toml\n[workspace]\nmembers = [\n    \"crates/core\",\n    \"crates/cli\",\n    \"crates/server\",\n]\n\n[workspace.dependencies]\n# Shared dependency versions\nserde = \"1.0\"\ntokio = \"1.0\"\n```\n\n### **Member Cargo.toml**\n\n```toml\n[package]\nname = \"my-cli\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n# Reference workspace package\nmy-core = { path = \"../core\" }\n\n# Use workspace dependency version\nserde = { workspace = true }\n```\n\n**Benefits:**\n- Shared `target/` directory\n- Unified dependency versions\n- Build all packages: `cargo build --workspace`\n- Test all packages: `cargo test --workspace`\n\n## Profiles\n\nOptimize builds for different scenarios:\n\n```toml\n[profile.dev]\nopt-level = 0      # No optimization\ndebug = true       # Include debug info\n\n[profile.release]\nopt-level = 3      # Maximum optimization\ndebug = false      # No debug info\nlto = true         # Link-time optimization\ncodegen-units = 1  # Better optimization, slower compile\n\n[profile.release-with-debug]\ninherits = \"release\"\ndebug = true       # Release optimizations + debug symbols\n```\n\n**Usage:**\n\n```bash\ncargo build --release\ncargo build --profile release-with-debug\n```\n\n## Build Scripts\n\n`build.rs` runs before compilation:\n\n```rust\n// build.rs\nfn main() {\n    println!(\"cargo:rerun-if-changed=build.rs\");\n\n    // Set environment variable\n    println!(\"cargo:rustc-env=BUILD_TIME={}\",\n        chrono::Local::now().format(\"%Y-%m-%d\"));\n\n    // Link library\n    println!(\"cargo:rustc-link-lib=mylib\");\n\n    // Add compiler flag\n    println!(\"cargo:rustc-cfg=has_feature\");\n}\n```\n\n**In Cargo.toml:**\n\n```toml\n[build-dependencies]\nchrono = \"0.4\"\n```\n\n## Useful Cargo Commands\n\n```bash\n# Check project (fast, no binary)\ncargo check\n\n# Build documentation\ncargo doc --open\n\n# Run specific binary\ncargo run --bin my_app\n\n# Run specific example\ncargo run --example my_example\n\n# Show dependency tree\ncargo tree\n\n# Update dependencies\ncargo update\n\n# Clean build artifacts\ncargo clean\n\n# Format code\ncargo fmt\n\n# Lint code\ncargo clippy\n\n# Benchmark\ncargo bench\n\n# Show outdated dependencies\ncargo outdated  # Requires cargo-outdated plugin\n```\n\n## Cargo Plugins\n\nInstall useful plugins:\n\n```bash\n# Audit dependencies for security vulnerabilities\ncargo install cargo-audit\ncargo audit\n\n# Check for outdated dependencies\ncargo install cargo-outdated\ncargo outdated\n\n# Generate license file\ncargo install cargo-license\ncargo license\n\n# Expand macros\ncargo install cargo-expand\ncargo expand\n\n# Watch for changes and rebuild\ncargo install cargo-watch\ncargo watch -x run\n\n# Binary size optimization\ncargo install cargo-bloat\ncargo bloat --release\n```\n\n## Example: Complete Cargo.toml\n\n```toml\n[package]\nname = \"taskmaster\"\nversion = \"1.0.0\"\nedition = \"2021\"\nauthors = [\"Your Name <you@example.com>\"]\ndescription = \"A powerful task management CLI\"\nlicense = \"MIT OR Apache-2.0\"\nrepository = \"https://github.com/username/taskmaster\"\nreadme = \"README.md\"\nkeywords = [\"cli\", \"task\", \"productivity\"]\ncategories = [\"command-line-utilities\"]\n\n[features]\ndefault = [\"cli\"]\ncli = [\"clap\"]\nweb = [\"actix-web\"]\nall = [\"cli\", \"web\"]\n\n[dependencies]\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nchrono = { version = \"0.4\", features = [\"serde\"] }\nclap = { version = \"4.5\", features = [\"derive\"], optional = true }\nactix-web = { version = \"4\", optional = true }\n\n[dev-dependencies]\ntempfile = \"3\"\n\n[profile.release]\nlto = true\ncodegen-units = 1\nstrip = true        # Remove debug symbols\n\n[profile.dev]\nopt-level = 1       # Some optimization for faster dev builds\n\n[[bin]]\nname = \"taskmaster\"\npath = \"src/main.rs\"\n\n[[example]]\nname = \"api_demo\"\nrequired-features = [\"web\"]\n```\n\n## Key Takeaways\n\n- âœ… Cargo.toml controls dependencies, features, and build settings\n- âœ… Version specifications: exact (=), caret (^), tilde (~)\n- âœ… Features enable conditional compilation\n- âœ… Workspaces manage multiple related packages\n- âœ… Profiles optimize builds for different scenarios\n- âœ… Build scripts enable custom build steps\n- âœ… Cargo plugins extend functionality\n\n**Next**: Exploring crates.io and discovering popular crates!\n\n---\n\n**Progress**: Module 10, Lesson 1 complete (55/60 lessons total)\n"
          }
        },
        {
          "id": "lesson-10-02",
          "title": "Module 10, Lesson 2: The Crate Ecosystem â€” Popular Libraries & Best Practices",
          "type": "exercise",
          "estimatedMinutes": 6,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 10, Lesson 2: The Crate Ecosystem â€” Popular Libraries & Best Practices\n\n## Discovering Crates\n\n**crates.io** is Rust's official package registry with over 100,000 crates.\n\n## Essential Crates by Category\n\n### **Serialization & Data Formats**\n\n#### serde (1.0)\nThe de-facto serialization framework:\n\n```toml\n[dependencies]\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"          # JSON\nserde_yaml = \"0.9\"          # YAML\ntoml = \"0.8\"                # TOML\nbincode = \"1.3\"             # Binary\n```\n\n```rust\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize)]\nstruct Config {\n    name: String,\n    value: i32,\n}\n\nfn main() {\n    let config = Config { name: \"test\".into(), value: 42 };\n\n    // To JSON\n    let json = serde_json::to_string(&config).unwrap();\n\n    // From JSON\n    let parsed: Config = serde_json::from_str(&json).unwrap();\n}\n```\n\n### **Error Handling**\n\n#### anyhow (1.0)\nFor applications (not libraries):\n\n```toml\n[dependencies]\nanyhow = \"1.0\"\n```\n\n```rust\nuse anyhow::{Context, Result};\n\nfn main() -> Result<()> {\n    let config = std::fs::read_to_string(\"config.toml\")\n        .context(\"Failed to read config file\")?;\n\n    let parsed: Config = toml::from_str(&config)\n        .context(\"Failed to parse config\")?;\n\n    Ok(())\n}\n```\n\n#### thiserror (1.0)\nFor libraries (custom error types):\n\n```toml\n[dependencies]\nthiserror = \"1.0\"\n```\n\n```rust\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum MyError {\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"Parse error at line {line}: {msg}\")]\n    Parse { line: usize, msg: String },\n\n    #[error(\"Not found: {0}\")]\n    NotFound(String),\n}\n```\n\n### **CLI Development**\n\n#### clap (4.5)\nCommand-line argument parsing:\n\n```toml\n[dependencies]\nclap = { version = \"4.5\", features = [\"derive\"] }\n```\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Args {\n    #[arg(short, long)]\n    name: String,\n\n    #[arg(short, long, default_value_t = 1)]\n    count: u32,\n}\n```\n\n#### colored (2.1)\nTerminal colors:\n\n```rust\nuse colored::*;\n\nprintln!(\"{}\", \"Success!\".green().bold());\nprintln!(\"{}\", \"Error!\".red());\nprintln!(\"{}\", \"Warning\".yellow());\n```\n\n#### indicatif (0.17)\nProgress bars:\n\n```rust\nuse indicatif::ProgressBar;\n\nlet pb = ProgressBar::new(100);\nfor _ in 0..100 {\n    pb.inc(1);\n    std::thread::sleep(Duration::from_millis(50));\n}\npb.finish_with_message(\"Done!\");\n```\n\n### **Async Runtime**\n\n#### tokio (1.0)\nAsync runtime for I/O-heavy applications:\n\n```toml\n[dependencies]\ntokio = { version = \"1.x\", features = [\"full\"] }\n```\n\n```rust\n#[tokio::main]\nasync fn main() {\n    let result = fetch_data().await;\n    println!(\"{:?}\", result);\n}\n\nasync fn fetch_data() -> Result<String, Box<dyn std::error::Error>> {\n    let resp = reqwest::get(\"https://api.example.com/data\")\n        .await?\n        .text()\n        .await?;\n\n    Ok(resp)\n}\n```\n\n### **Web Development**\n\n#### axum (0.8.x)\nModern web framework:\n\n```toml\n[dependencies]\naxum = \"0.8.x\"\ntokio = { version = \"1.x\", features = [\"full\"] }\n```\n\n```rust\nuse axum::{routing::get, Router};\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/\", get(|| async { \"Hello, World!\" }));\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    axum::serve(listener, app)\n        .await\n        .unwrap();\n}\n```\n\n#### actix-web (4.0)\nHigh-performance web framework:\n\n```toml\n[dependencies]\nactix-web = \"4\"\n```\n\n### **HTTP Clients**\n\n#### reqwest (0.11)\nEasy HTTP client:\n\n```toml\n[dependencies]\nreqwest = { version = \"0.11\", features = [\"json\"] }\n```\n\n```rust\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let response = reqwest::get(\"https://api.github.com/repos/rust-lang/rust\")\n        .await?\n        .json::<serde_json::Value>()\n        .await?;\n\n    println!(\"{:#?}\", response);\n    Ok(())\n}\n```\n\n### **Database Access**\n\n#### sqlx (0.8.x)\nAsync SQL toolkit:\n\n```toml\n[dependencies]\nsqlx = { version = \"0.8.x\", features = [\"runtime-tokio-native-tls\", \"sqlite\"] }\n```\n\n```rust\nuse sqlx::sqlite::SqlitePool;\n\n#[tokio::main]\nasync fn main() -> Result<(), sqlx::Error> {\n    let pool = SqlitePool::connect(\"sqlite:db.sqlite3\").await?;\n\n    let row: (i64,) = sqlx::query_as(\"SELECT COUNT(*) FROM users\")\n        .fetch_one(&pool)\n        .await?;\n\n    println!(\"Users: {}\", row.0);\n    Ok(())\n}\n```\n\n### **Date & Time**\n\n#### chrono (0.4)\nDate and time handling:\n\n```rust\nuse chrono::{DateTime, Local, Utc};\n\nfn main() {\n    let now = Local::now();\n    println!(\"{}\", now.format(\"%Y-%m-%d %H:%M:%S\"));\n\n    let utc: DateTime<Utc> = Utc::now();\n    println!(\"{}\", utc.to_rfc3339());\n}\n```\n\n### **Logging**\n\n#### tracing (0.1)\nStructured logging:\n\n```toml\n[dependencies]\ntracing = \"0.1\"\ntracing-subscriber = \"0.3\"\n```\n\n```rust\nuse tracing::{info, warn, error, debug};\n\nfn main() {\n    tracing_subscriber::fmt::init();\n\n    info!(\"Application started\");\n    warn!(\"This is a warning\");\n    error!(\"An error occurred\");\n    debug!(user_id = 123, \"Processing request\");\n}\n```\n\n### **Testing**\n\n#### proptest (1.4)\nProperty-based testing:\n\n```toml\n[dev-dependencies]\nproptest = \"1.4\"\n```\n\n```rust\nuse proptest::prelude::*;\n\nproptest! {\n    #[test]\n    fn test_reverse_reverse(s in \".*\") {\n        let reversed: String = s.chars().rev().collect();\n        let double_reversed: String = reversed.chars().rev().collect();\n        assert_eq!(s, double_reversed);\n    }\n}\n```\n\n## Evaluating Crates\n\n### **Quality Indicators**\n\n1. **Download count**: High downloads indicate popularity\n2. **Recent updates**: Active maintenance\n3. **Documentation**: Well-documented API\n4. **Tests**: Comprehensive test coverage\n5. **Dependencies**: Minimal, well-chosen dependencies\n6. **Community**: GitHub stars, issues, PRs\n\n### **Check Before Using**\n\n```bash\n# View crate information\ncargo info serde\n\n# Check for security vulnerabilities\ncargo audit\n\n# View dependency tree\ncargo tree\n\n# Check license compatibility\ncargo license\n```\n\n## Publishing Your Own Crate\n\n### **Step 1: Prepare**\n\n```toml\n[package]\nname = \"my_awesome_crate\"\nversion = \"0.1.0\"\nedition = \"2021\"\nauthors = [\"Your Name <you@example.com>\"]\ndescription = \"A brief description\"\nlicense = \"MIT OR Apache-2.0\"\nreadme = \"README.md\"\nrepository = \"https://github.com/username/repo\"\ndocumentation = \"https://docs.rs/my_awesome_crate\"\nkeywords = [\"keyword1\", \"keyword2\"]\ncategories = [\"category\"]\n```\n\n### **Step 2: Test & Document**\n\n```bash\n# Run all tests\ncargo test\n\n# Check documentation\ncargo doc --open\n\n# Check for issues\ncargo clippy\n```\n\n### **Step 3: Publish**\n\n```bash\n# Login to crates.io\ncargo login YOUR_API_TOKEN\n\n# Dry run\ncargo publish --dry-run\n\n# Publish!\ncargo publish\n```\n\n## Best Practices\n\n### **Dependency Management**\n\nâœ… **DO:**\n- Use specific version ranges\n- Minimize dependencies\n- Use `cargo update` carefully\n- Lock versions with `Cargo.lock` (commit for binaries)\n\nâŒ **DON'T:**\n- Use `*` for versions\n- Include unnecessary dependencies\n- Ignore security advisories\n\n### **Feature Flags**\n\n```toml\n[features]\ndefault = [\"std\"]\nstd = []\nfull = [\"serde\", \"chrono\"]\n\n[dependencies]\nserde = { version = \"1.0\", optional = true }\nchrono = { version = \"0.4\", optional = true }\n```\n\n### **Semantic Versioning**\n\n- `0.1.0` â†’ `0.1.1`: Bug fixes\n- `0.1.0` â†’ `0.2.0`: New features\n- `0.1.0` â†’ `1.0.0`: Breaking changes\n\n## Quick Reference: Must-Know Crates\n\n| Category | Crate | Purpose |\n|----------|-------|---------|\n| Serialization | serde | Data serialization |\n| JSON | serde_json | JSON support |\n| Error handling | anyhow | Application errors |\n| Error handling | thiserror | Library errors |\n| CLI | clap | Argument parsing |\n| Async runtime | tokio | Async I/O |\n| HTTP client | reqwest | HTTP requests |\n| Web framework | axum | Web applications |\n| Database | sqlx | SQL databases |\n| Logging | tracing | Structured logging |\n| Testing | proptest | Property testing |\n| Date/Time | chrono | Date handling |\n\n## Key Takeaways\n\n- âœ… crates.io is Rust's package registry\n- âœ… Evaluate crates by downloads, maintenance, docs, tests\n- âœ… Use serde for serialization, anyhow/thiserror for errors\n- âœ… clap for CLI, tokio for async, axum/actix for web\n- âœ… Check security with `cargo audit`\n- âœ… Follow semantic versioning\n- âœ… Document and test before publishing\n\n**Next**: Module 11 - Next Steps & Advanced Topics!\n\n---\n\n**Progress**: Module 10, Lesson 2 complete (56/60 lessons total)\n"
          }
        }
      ]
    },
    {
      "id": "module-11",
      "title": "MODULE 11",
      "description": "Module 11",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-11-01",
          "title": "Module 11: Next Steps & Async Introduction",
          "type": "exercise",
          "estimatedMinutes": 8,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 11: Next Steps & Async Introduction\n\n# Lesson 1: Hands-On Async/Await Practice\n\n## Why Async Programming?\n\nYou've built command-line applications that run **synchronously** - each operation waits for the previous one to finish.\n\n**Synchronous (blocking):**\n```rust\nfn main() {\n    let file1 = read_file(\"data1.txt\");  // Wait for this...\n    let file2 = read_file(\"data2.txt\");  // Then this...\n    let file3 = read_file(\"data3.txt\");  // Then this...\n    // Total time: ~3 seconds if each takes 1 second\n}\n```\n\n**Asynchronous (non-blocking):**\n```rust\n#[tokio::main]\nasync fn main() {\n    // Start all three at once!\n    let (file1, file2, file3) = tokio::join!(\n        read_file_async(\"data1.txt\"),\n        read_file_async(\"data2.txt\"),\n        read_file_async(\"data3.txt\"),\n    );\n    // Total time: ~1 second (all run concurrently)\n}\n```\n\n**Async is essential for:**\n- Web servers (handle many requests simultaneously)\n- Network I/O (don't wait for slow network calls)\n- Database queries (run multiple queries in parallel)\n- File I/O in high-performance applications\n\n## Setup\n\n```toml\n# Cargo.toml\n[package]\nname = \"async_practice\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ntokio = { version = \"1.x\", features = [\"full\"] }\nreqwest = \"0.12\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n```\n\n## Understanding async/await\n\n### The Basics\n\n**async fn** - Returns a **Future** instead of executing immediately:\n\n```rust\n// This doesn't execute yet!\nasync fn fetch_data() -> String {\n    \"Hello from async\".to_string()\n}\n\n// To actually run it:\n#[tokio::main]\nasync fn main() {\n    let result = fetch_data().await;  // .await executes the future\n    println!(\"{}\", result);\n}\n```\n\n**Key concepts:**\n1. `async fn` creates a **Future** (a value that will be ready later)\n2. `.await` **executes** the future and waits for the result\n3. `#[tokio::main]` sets up the **async runtime** that manages all futures\n\n### Example: Download a File\n\n**Synchronous (blocking):**\n```rust\nuse std::fs;\n\nfn download_blocking() -> Result<String, Box<dyn std::error::Error>> {\n    // This blocks the entire program until download completes!\n    let response = reqwest::blocking::get(\"https://api.github.com/users/rust-lang\")?\n        .text()?;\n\n    fs::write(\"rust-lang.json\", &response)?;\n    Ok(response)\n}\n```\n\n**Asynchronous (non-blocking):**\n```rust\nuse tokio::fs;\n\nasync fn download_async() -> Result<String, Box<dyn std::error::Error>> {\n    // Other async tasks can run while waiting for network!\n    let response = reqwest::get(\"https://api.github.com/users/rust-lang\")\n        .await?      // Wait for request\n        .text()\n        .await?;     // Wait for body\n\n    fs::write(\"rust-lang.json\", &response).await?;  // Wait for file write\n    Ok(response)\n}\n```\n\n## Practice 1: Your First Async Program\n\nCreate `src/main.rs`:\n\n```rust\nuse tokio::time::{sleep, Duration};\n\nasync fn task_one() {\n    println!(\"Task 1: Started\");\n    sleep(Duration::from_secs(2)).await;  // Simulate work\n    println!(\"Task 1: Finished\");\n}\n\nasync fn task_two() {\n    println!(\"Task 2: Started\");\n    sleep(Duration::from_secs(1)).await;\n    println!(\"Task 2: Finished\");\n}\n\n#[tokio::main]\nasync fn main() {\n    println!(\"=== Running Sequentially ===\");\n    task_one().await;\n    task_two().await;\n    // Total time: 3 seconds\n\n    println!(\"\\n=== Running Concurrently ===\");\n    // Start both at the same time!\n    tokio::join!(task_one(), task_two());\n    // Total time: 2 seconds (limited by slower task)\n}\n```\n\n**Run it:**\n```bash\ncargo run\n```\n\n**Output:**\n```\n=== Running Sequentially ===\nTask 1: Started\nTask 1: Finished\nTask 2: Started\nTask 2: Finished\n\n=== Running Concurrently ===\nTask 1: Started\nTask 2: Started\nTask 2: Finished\nTask 1: Finished\n```\n\nNotice Task 2 finishes before Task 1 when run concurrently!\n\n## Practice 2: Fetching Multiple URLs\n\n```rust\nuse serde::Deserialize;\n\n#[derive(Debug, Deserialize)]\nstruct GitHubUser {\n    login: String,\n    name: Option<String>,\n    public_repos: u32,\n}\n\nasync fn fetch_user(username: &str) -> Result<GitHubUser, reqwest::Error> {\n    let url = format!(\"https://api.github.com/users/{}\", username);\n\n    reqwest::get(&url)\n        .await?\n        .json::<GitHubUser>()\n        .await\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let usernames = vec![\"torvalds\", \"graydon\", \"BurntSushi\"];\n\n    println!(\"Fetching users sequentially...\");\n    let start = std::time::Instant::now();\n\n    for username in &usernames {\n        match fetch_user(username).await {\n            Ok(user) => println!(\"{}: {} repos\", user.login, user.public_repos),\n            Err(e) => eprintln!(\"Error fetching {}: {}\", username, e),\n        }\n    }\n\n    println!(\"Sequential time: {:?}\\n\", start.elapsed());\n\n    // Now concurrently!\n    println!(\"Fetching users concurrently...\");\n    let start = std::time::Instant::now();\n\n    let tasks = usernames.iter().map(|username| fetch_user(username));\n    let results = futures::future::join_all(tasks).await;\n\n    for result in results {\n        match result {\n            Ok(user) => println!(\"{}: {} repos\", user.login, user.public_repos),\n            Err(e) => eprintln!(\"Error: {}\", e),\n        }\n    }\n\n    println!(\"Concurrent time: {:?}\", start.elapsed());\n\n    Ok(())\n}\n```\n\nAdd to `Cargo.toml`:\n```toml\n[dependencies]\nfutures = \"0.3\"\n```\n\n## Practice 3: tokio::spawn for Background Tasks\n\n`tokio::spawn` runs a task in the background:\n\n```rust\nuse tokio::time::{sleep, Duration};\n\nasync fn background_worker(id: u32) {\n    for i in 1..=3 {\n        println!(\"Worker {}: Step {}\", id, i);\n        sleep(Duration::from_millis(500)).await;\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    println!(\"Starting workers...\\n\");\n\n    // Spawn 3 background tasks\n    let worker1 = tokio::spawn(background_worker(1));\n    let worker2 = tokio::spawn(background_worker(2));\n    let worker3 = tokio::spawn(background_worker(3));\n\n    // Do other work while they run\n    println!(\"Main: Doing other work...\");\n    sleep(Duration::from_secs(1)).await;\n    println!(\"Main: Done with work\\n\");\n\n    // Wait for all workers to finish\n    let _ = tokio::join!(worker1, worker2, worker3);\n\n    println!(\"\\nAll workers finished!\");\n}\n```\n\n## Practice 4: Returning Values from Spawned Tasks\n\n```rust\nasync fn calculate(x: i32) -> i32 {\n    tokio::time::sleep(Duration::from_secs(1)).await;\n    x * 2\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let handle1 = tokio::spawn(calculate(5));\n    let handle2 = tokio::spawn(calculate(10));\n    let handle3 = tokio::spawn(calculate(15));\n\n    // Join handles return Result<T, JoinError>\n    let result1 = handle1.await?;\n    let result2 = handle2.await?;\n    let result3 = handle3.await?;\n\n    println!(\"Results: {}, {}, {}\", result1, result2, result3);\n    // Results: 10, 20, 30\n\n    Ok(())\n}\n```\n\n## Practice 5: Error Handling with async\n\n```rust\nuse reqwest::Error;\n\nasync fn fetch_url(url: &str) -> Result<String, Error> {\n    reqwest::get(url)\n        .await?\n        .text()\n        .await\n}\n\n#[tokio::main]\nasync fn main() {\n    let urls = vec![\n        \"https://api.github.com/users/rust-lang\",\n        \"https://invalid-url-that-will-fail.com/api\",\n        \"https://api.github.com/users/tokio-rs\",\n    ];\n\n    for url in urls {\n        match fetch_url(url).await {\n            Ok(body) => println!(\"âœ… Fetched {} bytes from {}\", body.len(), url),\n            Err(e) => println!(\"âŒ Error fetching {}: {}\", url, e),\n        }\n    }\n}\n```\n\n## Practice 6: Real-World Example - Parallel File Downloads\n\n```rust\nuse tokio::fs::File;\nuse tokio::io::AsyncWriteExt;\n\nasync fn download_file(url: &str, filename: &str) -> Result<(), Box<dyn std::error::Error>> {\n    println!(\"â¬‡ï¸  Downloading {} ...\", url);\n\n    let response = reqwest::get(url).await?;\n    let bytes = response.bytes().await?;\n\n    let mut file = File::create(filename).await?;\n    file.write_all(&bytes).await?;\n\n    println!(\"âœ… Saved to {}\", filename);\n\n    Ok(())\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let downloads = vec![\n        (\"https://www.rust-lang.org/\", \"rust-homepage.html\"),\n        (\"https://doc.rust-lang.org/book/\", \"rust-book.html\"),\n        (\"https://crates.io/\", \"crates-io.html\"),\n    ];\n\n    let tasks = downloads.into_iter().map(|(url, filename)| {\n        tokio::spawn(async move {\n            if let Err(e) = download_file(url, filename).await {\n                eprintln!(\"âŒ Error: {}\", e);\n            }\n        })\n    });\n\n    // Wait for all downloads to complete\n    for task in tasks {\n        task.await?;\n    }\n\n    println!(\"\\nðŸŽ‰ All downloads complete!\");\n\n    Ok(())\n}\n```\n\n## Understanding #[tokio::main]\n\nThis macro:\n\n```rust\n#[tokio::main]\nasync fn main() {\n    // Your async code\n}\n```\n\nExpands to:\n\n```rust\nfn main() {\n    tokio::runtime::Runtime::new()\n        .unwrap()\n        .block_on(async {\n            // Your async code\n        })\n}\n```\n\nThe **runtime** manages all async tasks:\n- Schedules tasks\n- Manages threads\n- Handles I/O\n- Wakes tasks when ready\n\n## Key Differences: sync vs async\n\n| **Synchronous** | **Asynchronous** |\n|----------------|------------------|\n| `fn` | `async fn` |\n| Returns `T` | Returns `Future<Output = T>` |\n| Executes immediately | Executes when `.await`ed |\n| Blocks thread | Yields to other tasks |\n| `std::fs::read` | `tokio::fs::read` |\n| `std::thread::sleep` | `tokio::time::sleep` |\n| `reqwest::blocking::get` | `reqwest::get` |\n\n## Practice Exercise: Build a URL Checker\n\nCreate a program that checks if multiple URLs are online:\n\n**Requirements:**\n1. Accept a list of URLs\n2. Check each URL concurrently using `reqwest`\n3. Report which are online (status 200) and which are down\n4. Print total time taken\n\n**Starter code:**\n\n```rust\nuse reqwest;\nuse tokio::time::Instant;\n\nasync fn check_url(url: &str) -> Result<bool, reqwest::Error> {\n    // TODO: Make GET request and check if status is 200\n    // Return Ok(true) if online, Ok(false) if not\n    todo!()\n}\n\n#[tokio::main]\nasync fn main() {\n    let urls = vec![\n        \"https://www.rust-lang.org\",\n        \"https://github.com\",\n        \"https://this-site-does-not-exist-12345.com\",\n        \"https://crates.io\",\n    ];\n\n    let start = Instant::now();\n\n    // TODO: Check all URLs concurrently\n    // Print status for each\n\n    println!(\"\\nTotal time: {:?}\", start.elapsed());\n}\n```\n\n**Solution:**\n\n```rust\nuse reqwest;\nuse tokio::time::Instant;\n\nasync fn check_url(url: &str) -> Result<bool, reqwest::Error> {\n    match reqwest::get(url).await {\n        Ok(response) => Ok(response.status().is_success()),\n        Err(_) => Ok(false),\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let urls = vec![\n        \"https://www.rust-lang.org\",\n        \"https://github.com\",\n        \"https://this-site-does-not-exist-12345.com\",\n        \"https://crates.io\",\n    ];\n\n    let start = Instant::now();\n\n    let tasks = urls.iter().map(|url| {\n        let url = url.to_string();\n        tokio::spawn(async move {\n            match check_url(&url).await {\n                Ok(true) => println!(\"âœ… {} is online\", url),\n                Ok(false) => println!(\"âŒ {} is down\", url),\n                Err(e) => println!(\"âš ï¸  {} error: {}\", url, e),\n            }\n        })\n    });\n\n    for task in tasks {\n        let _ = task.await;\n    }\n\n    println!(\"\\nTotal time: {:?}\", start.elapsed());\n}\n```\n\n## Common Patterns\n\n### Pattern 1: Join All\n\n```rust\n// Wait for all to complete\nlet results = tokio::join!(task1(), task2(), task3());\n```\n\n### Pattern 2: Select First\n\n```rust\n// Return as soon as ONE completes\nlet result = tokio::select! {\n    res1 = task1() => res1,\n    res2 = task2() => res2,\n};\n```\n\n### Pattern 3: Timeout\n\n```rust\nuse tokio::time::{timeout, Duration};\n\nmatch timeout(Duration::from_secs(5), slow_operation()).await {\n    Ok(result) => println!(\"Completed: {:?}\", result),\n    Err(_) => println!(\"Timed out!\"),\n}\n```\n\n## When to Use Async\n\nâœ… **Use async when:**\n- Building web servers\n- Making network requests\n- Reading/writing files in high-performance apps\n- Database queries\n- WebSockets or real-time communication\n\nâŒ **Don't use async for:**\n- CPU-intensive work (use `std::thread` instead)\n- Simple CLI tools with no I/O\n- When you don't need concurrency\n\n## Key Takeaways\n\n- âœ… `async fn` creates a **Future** that must be `.await`ed to execute\n- âœ… `#[tokio::main]` sets up the async **runtime**\n- âœ… Use `tokio::spawn` to run tasks in the **background**\n- âœ… `tokio::join!` runs multiple tasks **concurrently** and waits for all\n- âœ… Async is for **I/O-bound** tasks, not CPU-bound\n- âœ… Use async versions of libraries (`tokio::fs`, `reqwest`, etc.)\n- âœ… Error handling works the same with `Result` and `?`\n\n## What's Next?\n\nNow you understand async/await! In the next modules, you'll use these concepts to:\n- Build web servers with Axum (Module 12)\n- Query databases with SQLx (Module 13)\n- Handle WebSockets for real-time features (Module 15)\n\n**Next**: Advanced topics overview and career paths!\n\n---\n\n**Progress**: Module 11, Lesson 1 complete (68/85 lessons total)\n"
          }
        },
        {
          "id": "lesson-11-02",
          "title": "Module 11: Next Steps in Your Rust Journey",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 11: Next Steps in Your Rust Journey\n\n# Lesson 1: Advanced Topics â€” Where to Go Next\n\n## You've Completed the Fundamentals!\n\nCongratulations! You now have a solid foundation in Rust. Here's what to explore next.\n\n## Advanced Topics Overview\n\n### **1. Async Programming**\n\nModern Rust applications often use async/await for concurrent I/O:\n\n```rust\nuse tokio;\n\n#[tokio::main]\nasync fn main() {\n    let result = fetch_data().await;\n    println!(\"{:?}\", result);\n}\n\nasync fn fetch_data() -> Result<String, Box<dyn std::error::Error>> {\n    let response = reqwest::get(\"https://api.example.com\")\n        .await?\n        .text()\n        .await?;\n\n    Ok(response)\n}\n```\n\n**Learning Resources:**\n- [Async Book](https://rust-lang.github.io/async-book/)\n- [Tokio Tutorial](https://tokio.rs/tokio/tutorial)\n- Build: async web server, chat application, web scraper\n\n### **2. Macros**\n\nWrite code that writes code:\n\n**Declarative Macros:**\n```rust\nmacro_rules! vec_of_strings {\n    ($($x:expr),*) => {\n        vec![$($x.to_string()),*]\n    };\n}\n\nfn main() {\n    let strings = vec_of_strings![\"hello\", \"world\"];\n}\n```\n\n**Procedural Macros:**\n```rust\n#[derive(MyCustomDerive)]\nstruct MyStruct {\n    field: String,\n}\n```\n\n**Learning Resources:**\n- [The Rust Reference - Macros](https://doc.rust-lang.org/reference/macros.html)\n- [Macros Book](https://danielkeep.github.io/tlborm/book/)\n\n### **3. Unsafe Rust**\n\nLow-level operations when needed:\n\n```rust\nunsafe {\n    let ptr = 0x1234 as *const i32;\n    // Dereference raw pointer\n    let value = *ptr;\n}\n```\n\n**When to use:**\n- FFI (calling C libraries)\n- Extremely performance-critical code\n- Implementing low-level data structures\n\n**Learning Resources:**\n- [The Rustonomicon](https://doc.rust-lang.org/nomicon/)\n- [Unsafe Code Guidelines](https://rust-lang.github.io/unsafe-code-guidelines/)\n\n### **4. Embedded Systems**\n\nRust on microcontrollers:\n\n```rust\n#![no_std]\n#![no_main]\n\nuse cortex_m_rt::entry;\n\n#[entry]\nfn main() -> ! {\n    loop {\n        // Blink LED\n    }\n}\n```\n\n**Learning Resources:**\n- [Embedded Rust Book](https://rust-embedded.github.io/book/)\n- [Discovery Book](https://rust-embedded.github.io/discovery/)\n\n### **5. WebAssembly**\n\nRust compiles to WebAssembly for browser:\n\n```rust\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn greet(name: &str) -> String {\n    format!(\"Hello, {}!\", name)\n}\n```\n\n**Learning Resources:**\n- [Rust and WebAssembly Book](https://rustwasm.github.io/docs/book/)\n- Build: browser-based games, web apps\n\n### **6. Operating Systems**\n\nBuild your own OS in Rust:\n\n**Learning Resources:**\n- [Writing an OS in Rust](https://os.phil-opp.com/)\n- [Redox OS](https://www.redox-os.org/)\n\n## Practical Project Ideas\n\n### **Beginner to Intermediate**\n\n1. **Command-Line Tools**\n   - File organizer\n   - Git helper\n   - System monitor\n   - Code formatter\n\n2. **Web Applications**\n   - REST API with axum/actix-web\n   - Blog engine\n   - URL shortener\n   - File sharing service\n\n3. **Desktop Applications**\n   - Todo app with GUI (egui/iced)\n   - Image editor\n   - Music player\n   - Text editor\n\n### **Intermediate to Advanced**\n\n4. **System Tools**\n   - Package manager\n   - Container runtime\n   - Process manager\n   - Network proxy\n\n5. **Data Processing**\n   - Log analyzer\n   - Data pipeline\n   - ETL tool\n   - Search engine\n\n6. **Game Development**\n   - 2D game with Bevy\n   - Roguelike\n   - Puzzle game\n   - Game engine\n\n### **Advanced Projects**\n\n7. **Distributed Systems**\n   - Distributed cache (like Redis)\n   - Message queue\n   - Consensus algorithm\n   - Blockchain node\n\n8. **Compilers & Interpreters**\n   - Programming language\n   - Query language\n   - Template engine\n   - Linter/formatter\n\n## Domain-Specific Learning Paths\n\n### **Web Development**\n\n**Stack:**\n- axum or actix-web (backend)\n- sqlx or diesel (database)\n- serde (serialization)\n- tracing (logging)\n\n**Project:** Build a full REST API\n\n### **Systems Programming**\n\n**Stack:**\n- libc bindings\n- mio or tokio (async I/O)\n- crossbeam (concurrency)\n\n**Project:** Build a network proxy\n\n### **Game Development**\n\n**Stack:**\n- bevy (game engine)\n- winit (windowing)\n- wgpu (graphics)\n\n**Project:** 2D platformer\n\n### **CLI Tools**\n\n**Stack:**\n- clap (arguments)\n- indicatif (progress)\n- colored (terminal colors)\n\n**Project:** Advanced file manager\n\n### **Data Science**\n\n**Stack:**\n- polars (dataframes)\n- ndarray (arrays)\n- plotters (visualization)\n\n**Project:** Data analysis pipeline\n\n## Contributing to Open Source\n\n### **How to Start:**\n\n1. **Find a project:**\n   - Search \"good first issue\" on GitHub\n   - Check Rust official projects\n   - Look for crates you use\n\n2. **Make your first contribution:**\n   - Fix typos in documentation\n   - Add tests\n   - Improve error messages\n   - Fix small bugs\n\n3. **Level up:**\n   - Add features\n   - Improve performance\n   - Refactor code\n   - Review PRs\n\n### **Popular Rust Projects:**\n\n- **Rust itself**: [github.com/rust-lang/rust](https://github.com/rust-lang/rust)\n- **ripgrep**: Fast text search\n- **bat**: Better `cat`\n- **exa**: Better `ls`\n- **fd**: Better `find`\n- **tokio**: Async runtime\n- **serde**: Serialization\n\n## Learning Resources\n\n### **Books**\n\n- *The Rust Programming Language* (Free online)\n- *Rust for Rustaceans* by Jon Gjengset\n- *Zero To Production In Rust* by Luca Palmieri\n- *Programming Rust* by Jim Blandy & Jason Orendorff\n\n### **Online Courses**\n\n- [Rust by Example](https://doc.rust-lang.org/rust-by-example/)\n- [Rustlings](https://github.com/rust-lang/rustlings) - Interactive exercises\n- [Exercism Rust Track](https://exercism.org/tracks/rust)\n\n### **Videos**\n\n- Jon Gjengset's YouTube channel\n- [Rust for the Impatient](https://www.youtube.com/playlist?list=PLqbS7AVVErFirH9armw8yXlE6dacF-F-M)\n- Rust official conference talks\n\n### **Communities**\n\n- [Rust Users Forum](https://users.rust-lang.org/)\n- [r/rust subreddit](https://reddit.com/r/rust)\n- [Rust Discord](https://discord.gg/rust-lang)\n- [This Week in Rust](https://this-week-in-rust.org/) - Newsletter\n\n## Continuous Learning\n\n### **Stay Updated:**\n\n- Follow [Rust Blog](https://blog.rust-lang.org/)\n- Read release notes for new Rust versions\n- Try new crates as they emerge\n- Attend Rust conferences (RustConf, Rust Belt Rust)\n\n### **Practice Regularly:**\n\n- [Advent of Code](https://adventofcode.com/) in Rust\n- [LeetCode](https://leetcode.com/) Rust solutions\n- Build something every week\n- Refactor old code with new knowledge\n\n## Your Learning Path\n\n**Weeks 1-4:** Solidify fundamentals\n- Rebuild capstone project from memory\n- Solve 20+ coding problems in Rust\n- Read \"The Rust Programming Language\" cover to cover\n\n**Months 2-3:** Build real projects\n- Create 3 CLI tools\n- Build a web API\n- Contribute to open source\n\n**Months 4-6:** Specialize\n- Choose a domain (web, systems, games, etc.)\n- Deep-dive into relevant crates\n- Build a portfolio project\n\n**Months 7-12:** Master advanced topics\n- Async programming\n- Unsafe Rust (if needed)\n- Macro development\n- Performance optimization\n\n## Key Takeaways\n\n- âœ… You have the fundamentals - now build!\n- âœ… Choose projects that interest you\n- âœ… Contribute to open source\n- âœ… Stay connected with the community\n- âœ… Keep learning advanced topics\n- âœ… Practice regularly\n- âœ… Share your knowledge\n\n**Next**: Final lesson - Building your Rust portfolio!\n\n---\n\n**Progress**: Module 11, Lesson 2 complete (69/85 lessons total)\n"
          }
        },
        {
          "id": "lesson-11-03",
          "title": "Module 11, Lesson 2: Course Completion â€” Your Rust Journey Begins!",
          "type": "project",
          "estimatedMinutes": 7,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 11, Lesson 2: Course Completion â€” Your Rust Journey Begins!\n\n## ðŸŽ‰ Congratulations!\n\nYou've completed the comprehensive Rust Training Course! Let's review what you've learned and chart your path forward.\n\n## What You've Mastered\n\n### **Module 0: Setup**\n- âœ… Installed Rust toolchain\n- âœ… Configured VS Code\n- âœ… Created your first Rust program\n- âœ… Understood Cargo basics\n\n### **Module 1: Basics**\n- âœ… Main function and program entry\n- âœ… Variables and mutability\n- âœ… Data types\n- âœ… Functions\n- âœ… Comments and documentation\n\n### **Module 2: Control Flow**\n- âœ… if/else statements\n- âœ… Loop constructs (loop, while, for)\n- âœ… Built a calculator\n\n### **Module 3: Data Organization**\n- âœ… Structs for data grouping\n- âœ… Enums for variants\n- âœ… Option and Result types\n- âœ… Created a user profile system\n\n### **Module 4: Ownership**\n- âœ… Stack vs heap memory\n- âœ… Ownership rules\n- âœ… Borrowing (& and &mut)\n- âœ… Lifetimes\n- âœ… Built a text processor\n\n### **Module 5: Collections**\n- âœ… String vs &str\n- âœ… Vectors (Vec<T>)\n- âœ… HashMaps\n- âœ… Created a word counter\n\n### **Module 6: Error Handling**\n- âœ… Option<T> for optional values\n- âœ… Result<T, E> for fallible operations\n- âœ… The ? operator\n- âœ… Custom error types\n- âœ… Built a file validator\n\n### **Module 7: File I/O**\n- âœ… Command-line arguments\n- âœ… Reading files\n- âœ… Writing files\n- âœ… Path manipulation\n- âœ… Created a file management tool\n\n### **Module 8: Traits & Generics**\n- âœ… Trait definitions and implementations\n- âœ… Generic types and functions\n- âœ… Common traits (Debug, Display, Clone, etc.)\n- âœ… Iterators and functional programming\n- âœ… Built a generic data filter\n\n### **Module 9: Capstone Project**\n- âœ… Professional CLI application\n- âœ… JSON persistence\n- âœ… Advanced filtering and search\n- âœ… Statistics and reports\n- âœ… Complete TaskMaster application\n\n### **Module 10: Ecosystem**\n- âœ… Advanced Cargo features\n- âœ… Popular crates and libraries\n- âœ… Publishing crates\n- âœ… Best practices\n\n### **Module 11: Next Steps**\n- âœ… Advanced topics overview\n- âœ… Learning paths\n- âœ… Project ideas\n- âœ… This lesson!\n\n## Your Skills Summary\n\nYou can now:\n\n**Build Complete Applications:**\n- Design and implement multi-module projects\n- Handle errors gracefully\n- Persist data to files\n- Create professional CLIs\n- Test and document code\n\n**Write Idiomatic Rust:**\n- Use ownership and borrowing effectively\n- Leverage traits and generics\n- Apply functional programming with iterators\n- Implement custom error types\n- Follow Rust best practices\n\n**Navigate the Ecosystem:**\n- Find and evaluate crates\n- Manage dependencies\n- Use popular libraries\n- Contribute to open source\n\n## Building Your Portfolio\n\n### **Portfolio Project Ideas**\n\nChoose 3-5 projects that showcase different skills:\n\n1. **CLI Tool** (demonstrates practical skills)\n   - File organizer with advanced filtering\n   - Git workflow automation\n   - Development environment setup tool\n\n2. **Web Application** (shows modern stack knowledge)\n   - REST API with database\n   - Real-time chat application\n   - Content management system\n\n3. **Systems Tool** (proves low-level understanding)\n   - Custom shell\n   - Process monitor\n   - Network protocol implementation\n\n4. **Library/Crate** (demonstrates API design)\n   - Data processing library\n   - Utility crate\n   - Published on crates.io\n\n5. **Game or GUI App** (shows creativity)\n   - 2D game with Bevy\n   - Desktop productivity app\n   - Visualization tool\n\n### **Portfolio Best Practices**\n\n**Code Quality:**\n- Comprehensive tests\n- Clear documentation\n- Consistent style (use `cargo fmt`)\n- No clippy warnings\n\n**Documentation:**\n- Detailed README with examples\n- API documentation\n- Architecture explanation\n- Usage guide\n\n**GitHub Presentation:**\n- Clean commit history\n- Descriptive commit messages\n- Issues and PR templates\n- CI/CD setup\n\n## Showcase Projects Template\n\n### **README Structure**\n\n```markdown\n# Project Name\n\nBrief, compelling description.\n\n## Features\n\n- Feature 1\n- Feature 2\n- Feature 3\n\n## Installation\n\n```bash\ncargo install project_name\n```\n\n## Usage\n\n```bash\nproject_name --help\n```\n\n## Examples\n\n[Include screenshots or example output]\n\n## Architecture\n\n[Explain design decisions]\n\n## Testing\n\n```bash\ncargo test\n```\n\n## Contributing\n\n[Guidelines for contributors]\n\n## License\n\nMIT\n```\n\n## Career Paths in Rust\n\n### **Roles:**\n\n- **Backend Developer**: Web services, APIs, microservices\n- **Systems Programmer**: Operating systems, drivers, tools\n- **Embedded Developer**: IoT, robotics, hardware\n- **Blockchain Developer**: Cryptocurrency, smart contracts\n- **Game Developer**: Game engines, game logic\n- **DevOps Engineer**: Build tools, deployment systems\n- **Data Engineer**: Processing pipelines, analytics\n\n### **Industries Using Rust:**\n\n- Cloud infrastructure (AWS, Azure)\n- Web browsers (Firefox, Chrome)\n- Operating systems (Linux kernel, Windows)\n- Cryptocurrency (Solana, Polkadot)\n- Game development (Amazon Lumberyard)\n- Databases (TiKV, CockroachDB)\n- Web services (Discord, Cloudflare)\n\n## Your Action Plan\n\n### **This Week:**\n- âœ… Complete any unfinished lessons\n- âœ… Review quiz questions you missed\n- âœ… Choose your first portfolio project\n- âœ… Join Rust community (Discord, forum)\n\n### **This Month:**\n- âœ… Build your first portfolio project\n- âœ… Contribute to an open-source project\n- âœ… Read \"Rust for Rustaceans\"\n- âœ… Solve 20 coding problems in Rust\n\n### **Next 3 Months:**\n- âœ… Complete 3 portfolio projects\n- âœ… Publish a crate to crates.io\n- âœ… Write a technical blog post about Rust\n- âœ… Attend a Rust meetup or conference\n\n### **Next 6 Months:**\n- âœ… Apply for Rust positions\n- âœ… Build a production-ready application\n- âœ… Become active in Rust community\n- âœ… Mentor other Rust learners\n\n## Staying Connected\n\n### **Follow These Resources:**\n\n- [This Week in Rust](https://this-week-in-rust.org/) - Weekly newsletter\n- [Rust Blog](https://blog.rust-lang.org/) - Official announcements\n- [r/rust](https://reddit.com/r/rust) - Community discussions\n- [Rust Users Forum](https://users.rust-lang.org/) - Help and discussions\n\n### **Join Communities:**\n\n- Rust Discord Server\n- Local Rust meetups\n- Online study groups\n- Twitter #rustlang\n\n### **Give Back:**\n\n- Answer questions on forums\n- Write blog posts\n- Create tutorials\n- Contribute to documentation\n- Mentor beginners\n\n## Final Wisdom\n\n**Remember:**\n\n1. **Everyone starts somewhere** - Don't compare your beginning to someone else's middle\n2. **Build, build, build** - Theory is important, but practice makes perfect\n3. **Learn in public** - Share your progress, mistakes, and victories\n4. **Community matters** - Help others and ask for help\n5. **Be patient** - Mastery takes time and consistent effort\n\n**The compiler is your friend:**\n- Error messages teach you\n- Warnings guide you\n- Clippy improves your code\n\n**Embrace the Rust way:**\n- Fight the borrow checker now, thank it later\n- Explicit is better than implicit\n- Compile-time safety prevents runtime headaches\n\n## You're Ready!\n\nYou now have everything you need to:\n- Build professional Rust applications\n- Contribute to the Rust ecosystem\n- Launch a Rust career\n- Continue learning advanced topics\n- Become part of the Rust community\n\n## What's Next?\n\n1. **Review** any challenging topics\n2. **Build** your first portfolio project\n3. **Share** your progress\n4. **Connect** with the community\n5. **Keep learning** - Rust is always evolving!\n\n---\n\n## ðŸš€ Your Rust Journey Has Just Begun!\n\nThank you for completing this course. The Rust community welcomes you!\n\n**Remember the Rust mantra:**\n> *Fearless concurrency. Memory safety without garbage collection. Zero-cost abstractions.*\n\nNow go build amazing things! ðŸ¦€\n\n---\n\n## âœ… Course Complete!\n\n**Total Lessons Completed**: 60/60\n**Quizzes Completed**: 5 (Modules 4, 6, 7, 8, 9)\n**Projects Built**: 8+ (Calculator, User Profile, Text Processor, Word Counter, File Validator, File Tool, Data Filter, TaskMaster)\n\n**Achievement Unlocked**: ðŸ† **Rust Developer**\n\n---\n\n*Course created to take you from absolute beginner to confident Rust developer*\n\n*Happy coding, and welcome to the Rust community!* ðŸ¦€\n\n---\n\n**Progress**: Course 100% Complete! ðŸŽ‰\n\n[View Course Map](../../00_curriculum.md) | [Join Rust Community](https://www.rust-lang.org/community)\n"
          }
        }
      ]
    },
    {
      "id": "module-12",
      "title": "MODULE 12",
      "description": "Module 12",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-12-01",
          "title": "Module 12: Web Development with Rust",
          "type": "project",
          "estimatedMinutes": 8,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 12: Web Development with Rust\n\n# Lesson 1: HTTP & REST Fundamentals\n\n## Welcome to Full-Stack Development!\n\nYou've mastered Rust fundamentals and built CLI applications. Now let's build **web applications** that serve users over HTTP!\n\n## What is HTTP?\n\n**HTTP (HyperText Transfer Protocol)** is how computers communicate on the web.\n\n### Simple Analogy\n\nThink of HTTP like **mailing letters**:\n\n- **Request**: You send a letter (request) asking for information\n- **Response**: The recipient sends back a letter (response) with the information\n- **Method**: The type of request (GET = \"please send\", POST = \"please save this\")\n- **Headers**: Envelope information (sender, content type, etc.)\n- **Body**: The actual message content\n\n### HTTP Request Structure\n\n```\nGET /api/users/123 HTTP/1.1\nHost: example.com\nAccept: application/json\nAuthorization: Bearer token123\n\n[optional body data]\n```\n\n**Parts:**\n- **Method**: GET (what action to perform)\n- **Path**: `/api/users/123` (what resource)\n- **Headers**: Metadata about the request\n- **Body**: Data being sent (for POST, PUT, PATCH)\n\n### HTTP Response Structure\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 45\n\n{\"id\": 123, \"name\": \"Alice\", \"email\": \"alice@example.com\"}\n```\n\n**Parts:**\n- **Status Code**: 200 (result of the request)\n- **Headers**: Metadata about the response\n- **Body**: The actual data\n\n## HTTP Methods\n\n### **GET** - Retrieve Data\n\n```\nGET /api/products\n```\n\n**Purpose**: Fetch data without changing anything\n\n**Analogy**: Looking at items in a store window\n\n**Example uses**:\n- Get list of users\n- Fetch a single blog post\n- Retrieve search results\n\n### **POST** - Create New Data\n\n```\nPOST /api/products\nContent-Type: application/json\n\n{\"name\": \"Laptop\", \"price\": 999}\n```\n\n**Purpose**: Create a new resource\n\n**Analogy**: Submitting a form to create a new account\n\n**Example uses**:\n- Create a new user\n- Submit a comment\n- Upload a file\n\n### **PUT** - Update/Replace Data\n\n```\nPUT /api/products/123\nContent-Type: application/json\n\n{\"name\": \"Gaming Laptop\", \"price\": 1299}\n```\n\n**Purpose**: Replace entire resource\n\n**Analogy**: Replacing an old file with a completely new version\n\n### **PATCH** - Partial Update\n\n```\nPATCH /api/products/123\nContent-Type: application/json\n\n{\"price\": 1199}\n```\n\n**Purpose**: Update only specific fields\n\n**Analogy**: Editing just one paragraph in a document\n\n### **DELETE** - Remove Data\n\n```\nDELETE /api/products/123\n```\n\n**Purpose**: Delete a resource\n\n**Analogy**: Throwing away an item\n\n## HTTP Status Codes\n\nStatus codes tell you what happened:\n\n### **2xx - Success**\n\n- **200 OK**: Request succeeded\n- **201 Created**: New resource created\n- **204 No Content**: Success, but no data to return\n\n### **3xx - Redirection**\n\n- **301 Moved Permanently**: Resource moved to new URL\n- **302 Found**: Temporary redirect\n\n### **4xx - Client Errors**\n\n- **400 Bad Request**: Invalid request data\n- **401 Unauthorized**: Authentication required\n- **403 Forbidden**: Authenticated but not allowed\n- **404 Not Found**: Resource doesn't exist\n- **422 Unprocessable Entity**: Valid format, but can't process\n\n### **5xx - Server Errors**\n\n- **500 Internal Server Error**: Server crashed\n- **503 Service Unavailable**: Server temporarily down\n\n### Quick Reference\n\n```rust\n// In Rust with axum, you'll use:\nStatusCode::OK                    // 200\nStatusCode::CREATED               // 201\nStatusCode::BAD_REQUEST           // 400\nStatusCode::NOT_FOUND             // 404\nStatusCode::INTERNAL_SERVER_ERROR // 500\n```\n\n## What is REST?\n\n**REST (Representational State Transfer)** is a set of conventions for building web APIs.\n\n### REST Principles\n\n**1. Resource-Based URLs**\n\nResources are nouns, not verbs:\n\nâœ… **Good:**\n```\nGET    /api/users           # Get all users\nGET    /api/users/123       # Get user 123\nPOST   /api/users           # Create user\nPUT    /api/users/123       # Update user 123\nDELETE /api/users/123       # Delete user 123\n```\n\nâŒ **Bad:**\n```\nGET  /api/getUsers\nPOST /api/createUser\nPOST /api/deleteUser/123\n```\n\n**2. Use HTTP Methods Correctly**\n\n- GET for reading\n- POST for creating\n- PUT/PATCH for updating\n- DELETE for deleting\n\n**3. Stateless**\n\nEach request contains everything needed (no relying on server memory of previous requests).\n\n**4. Standard Status Codes**\n\nUse HTTP status codes to indicate results.\n\n**5. JSON Format**\n\nModern APIs use JSON for data:\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\",\n  \"created_at\": \"2025-01-15T10:30:00Z\"\n}\n```\n\n## RESTful API Example\n\n**E-commerce API:**\n\n```\n# Products\nGET    /api/products           # List all products\nGET    /api/products/42        # Get product 42\nPOST   /api/products           # Create new product\nPUT    /api/products/42        # Update product 42\nDELETE /api/products/42        # Delete product 42\n\n# Orders\nGET    /api/orders             # List all orders\nPOST   /api/orders             # Create new order\nGET    /api/orders/99          # Get order 99\n\n# Nested resources\nGET    /api/orders/99/items    # Get items in order 99\nPOST   /api/orders/99/items    # Add item to order 99\n```\n\n## URL Structure\n\n```\nhttps://api.example.com/v1/products?category=electronics&sort=price\n\nProtocol: https://\nDomain: api.example.com\nVersion: /v1\nResource: /products\nQuery params: ?category=electronics&sort=price\n```\n\n**Query Parameters** (after `?`):\n- Filtering: `?status=active`\n- Sorting: `?sort=name&order=asc`\n- Pagination: `?page=2&limit=20`\n- Search: `?q=laptop`\n\n## Headers\n\n### Common Request Headers\n\n```\nContent-Type: application/json        # Format of body\nAccept: application/json              # Format you want back\nAuthorization: Bearer token123        # Authentication\nUser-Agent: MyApp/1.0                 # Client info\n```\n\n### Common Response Headers\n\n```\nContent-Type: application/json        # Format of body\nContent-Length: 1234                  # Size in bytes\nCache-Control: max-age=3600           # Caching rules\nLocation: /api/users/123              # New resource URL (for 201)\n```\n\n## JSON - The Language of APIs\n\n**JSON (JavaScript Object Notation)** is the standard data format for web APIs.\n\n### JSON Syntax\n\n```json\n{\n  \"string\": \"text value\",\n  \"number\": 42,\n  \"float\": 3.14,\n  \"boolean\": true,\n  \"null_value\": null,\n  \"array\": [1, 2, 3],\n  \"object\": {\n    \"nested\": \"value\"\n  }\n}\n```\n\n### Rust Structs â†” JSON\n\n```rust\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize)]\nstruct User {\n    id: u32,\n    name: String,\n    email: String,\n    active: bool,\n}\n\n// Becomes:\n{\n  \"id\": 1,\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\",\n  \"active\": true\n}\n```\n\n## Complete Request/Response Flow\n\n### Example: Creating a User\n\n**1. Client sends request:**\n\n```http\nPOST /api/users HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAccept: application/json\n\n{\n  \"name\": \"Bob\",\n  \"email\": \"bob@example.com\"\n}\n```\n\n**2. Server processes:**\n\n- Validates the data\n- Creates user in database\n- Generates ID and timestamp\n\n**3. Server sends response:**\n\n```http\nHTTP/1.1 201 Created\nContent-Type: application/json\nLocation: /api/users/456\n\n{\n  \"id\": 456,\n  \"name\": \"Bob\",\n  \"email\": \"bob@example.com\",\n  \"created_at\": \"2025-11-13T14:30:00Z\"\n}\n```\n\n## API Design Best Practices\n\n### âœ… DO:\n\n- Use plural nouns for collections: `/users`, `/products`\n- Use standard HTTP methods\n- Return appropriate status codes\n- Include timestamps\n- Version your API: `/v1/users`\n- Provide clear error messages\n\n### âŒ DON'T:\n\n- Use verbs in URLs: `/getUser`\n- Return 200 for errors\n- Nest too deeply: `/api/users/1/orders/2/items/3/reviews`\n- Change response formats without versioning\n\n## Error Response Format\n\n**Standard error response:**\n\n```json\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Email is required\",\n    \"details\": {\n      \"field\": \"email\",\n      \"reason\": \"missing\"\n    }\n  }\n}\n```\n\n## Practice Exercise\n\n### Exercise 1: Design a Blog API\n\nDesign RESTful endpoints for a blog with:\n- Posts (title, content, author, published_at)\n- Comments (post_id, author, content)\n- Tags\n\n**Your turn:** Write the URL endpoints and HTTP methods.\n\n<details>\n<summary>Solution</summary>\n\n```\n# Posts\nGET    /api/posts              # List posts\nGET    /api/posts/123          # Get post 123\nPOST   /api/posts              # Create post\nPUT    /api/posts/123          # Update post 123\nDELETE /api/posts/123          # Delete post 123\n\n# Comments\nGET    /api/posts/123/comments # List comments for post 123\nPOST   /api/posts/123/comments # Add comment to post 123\nDELETE /api/comments/456       # Delete comment 456\n\n# Tags\nGET    /api/tags               # List all tags\nGET    /api/posts?tag=rust     # Filter posts by tag\n```\n</details>\n\n### Exercise 2: HTTP Status Codes\n\nWhat status code should be returned for each scenario?\n\n1. User successfully created âžœ ?\n2. Resource not found âžœ ?\n3. Invalid email format âžœ ?\n4. Authentication token missing âžœ ?\n5. Server database crashed âžœ ?\n\n<details>\n<summary>Solution</summary>\n\n1. **201 Created** - New resource created successfully\n2. **404 Not Found** - Resource doesn't exist\n3. **400 Bad Request** - Client sent invalid data\n4. **401 Unauthorized** - Authentication required\n5. **500 Internal Server Error** - Server problem\n</details>\n\n### Exercise 3: Request/Response\n\nDesign the request and response for:\n\n**Create a book in a library API**\n\nBook has: title, author, isbn, published_year\n\n<details>\n<summary>Solution</summary>\n\n**Request:**\n```http\nPOST /api/books HTTP/1.1\nContent-Type: application/json\n\n{\n  \"title\": \"The Rust Book\",\n  \"author\": \"Steve Klabnik\",\n  \"isbn\": \"978-1718503106\",\n  \"published_year\": 2023\n}\n```\n\n**Response:**\n```http\nHTTP/1.1 201 Created\nContent-Type: application/json\nLocation: /api/books/789\n\n{\n  \"id\": 789,\n  \"title\": \"The Rust Book\",\n  \"author\": \"Steve Klabnik\",\n  \"isbn\": \"978-1718503106\",\n  \"published_year\": 2023,\n  \"created_at\": \"2025-11-13T15:00:00Z\"\n}\n```\n</details>\n\n## Tools for Testing APIs\n\n### cURL (Command line)\n\n```bash\n# GET request\ncurl https://api.example.com/users\n\n# POST request\ncurl -X POST https://api.example.com/users \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\":\"Alice\",\"email\":\"alice@example.com\"}'\n\n# With auth\ncurl https://api.example.com/users \\\n  -H \"Authorization: Bearer token123\"\n```\n\n### httpie (Friendlier than curl)\n\n```bash\n# GET\nhttp GET https://api.example.com/users\n\n# POST\nhttp POST https://api.example.com/users name=Alice email=alice@example.com\n```\n\n### Postman / Insomnia\n\nGUI tools for testing APIs (download from their websites)\n\n## What's Next?\n\nNow that you understand HTTP and REST fundamentals, you're ready to build your first Rust web server with **axum**!\n\nIn the next lesson, we'll:\n- Set up an axum project\n- Create a simple web server\n- Handle HTTP requests\n- Return JSON responses\n\n## Key Takeaways\n\n- âœ… HTTP is request/response protocol\n- âœ… GET retrieves, POST creates, PUT/PATCH updates, DELETE removes\n- âœ… Status codes indicate results (2xx success, 4xx client error, 5xx server error)\n- âœ… REST uses resource-based URLs and standard HTTP methods\n- âœ… JSON is the standard data format for APIs\n- âœ… Good API design makes endpoints predictable and easy to use\n\n**Next**: Building your first web server with axum!\n\n---\n\n**Progress**: Module 12, Lesson 1 complete (58/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-12-02",
          "title": "Module 12: Web Development with Rust",
          "type": "project",
          "estimatedMinutes": 8,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 12: Web Development with Rust\n\n# Lesson 2: Your First Axum Web Server\n\n## What is Axum?\n\n**Axum** is a modern, ergonomic web framework for Rust built on:\n- **tokio** - async runtime\n- **hyper** - HTTP library\n- **tower** - middleware and services\n\n**Why Axum?**\n- Fast and efficient\n- Type-safe extractors\n- Excellent error messages\n- Built by the Tokio team\n- Latest version: **0.8.0** (January 2025)\n\n## Project Setup\n\n### Create a New Project\n\n```bash\ncargo new web_server\ncd web_server\n```\n\n### Add Dependencies\n\nEdit `Cargo.toml`:\n\n```toml\n[package]\nname = \"web_server\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\naxum = \"0.8.x\"\ntokio = { version = \"1.x\", features = [\"full\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n```\n\n**Dependencies explained:**\n- `axum` - Web framework\n- `tokio` - Async runtime (enables `async`/`await`)\n- `serde` - Serialization/deserialization\n- `serde_json` - JSON support\n\nInstall dependencies:\n\n```bash\ncargo build\n```\n\n## Your First \"Hello World\" Server\n\n### Step 1: Basic Server\n\nReplace `src/main.rs`:\n\n```rust\nuse axum::{\n    routing::get,\n    Router,\n};\n\n#[tokio::main]\nasync fn main() {\n    // Create a router with a single route\n    let app = Router::new()\n        .route(\"/\", get(hello_world));\n\n    // Create listener\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    println!(\"ðŸš€ Server running on http://localhost:3000\");\n\n    // Run the server\n    axum::serve(listener, app)\n        .await\n        .unwrap();\n}\n\n// Handler function\nasync fn hello_world() -> &'static str {\n    \"Hello, World!\"\n}\n```\n\n### Run Your Server\n\n```bash\ncargo run\n```\n\nYou should see:\n```\nðŸš€ Server running on http://localhost:3000\n```\n\n### Test It\n\nOpen your browser to `http://localhost:3000` or use curl:\n\n```bash\ncurl http://localhost:3000\n# Output: Hello, World!\n```\n\n**Congratulations!** You've built your first web server! ðŸŽ‰\n\n## Understanding the Code\n\n### The `#[tokio::main]` Attribute\n\n```rust\n#[tokio::main]\nasync fn main() {\n    // async code here\n}\n```\n\n**What it does:**\n- Transforms `async fn main` into a regular `fn main`\n- Sets up the tokio async runtime\n- Allows you to use `await` in main\n\n**Without the macro:**\n```rust\n// You'd have to write this manually:\nfn main() {\n    tokio::runtime::Runtime::new()\n        .unwrap()\n        .block_on(async {\n            // async code here\n        });\n}\n```\n\n### The Router\n\n```rust\nlet app = Router::new()\n    .route(\"/\", get(hello_world));\n```\n\n**Router** is the core of axum. It:\n- Maps URLs (paths) to handler functions\n- Supports different HTTP methods (GET, POST, PUT, DELETE)\n- Can be nested and composed\n\n### Handler Functions\n\n```rust\nasync fn hello_world() -> &'static str {\n    \"Hello, World!\"\n}\n```\n\n**Handler functions:**\n- Are `async` (run concurrently)\n- Take extractors as parameters (more on this later)\n- Return something that implements `IntoResponse`\n\n### The Listener & Server\n\n```rust\nlet listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n    .await\n    .unwrap();\n\naxum::serve(listener, app)\n    .await\n    .unwrap();\n```\n\n**What this does:**\n- Binds to port 3000 on all interfaces (`0.0.0.0`)\n- Starts the server\n- Waits for incoming HTTP requests\n\n**Address explained:**\n- `0.0.0.0` = accept connections from anywhere\n- `127.0.0.1` or `localhost` = only local connections\n- `3000` = port number (common for development)\n\n## Multiple Routes\n\nLet's add more routes:\n\n```rust\nuse axum::{\n    routing::get,\n    Router,\n};\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/\", get(home))\n        .route(\"/hello\", get(hello))\n        .route(\"/about\", get(about));\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    println!(\"ðŸš€ Server running on http://localhost:3000\");\n\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn home() -> &'static str {\n    \"Welcome to the home page!\"\n}\n\nasync fn hello() -> &'static str {\n    \"Hello from /hello!\"\n}\n\nasync fn about() -> &'static str {\n    \"This is a Rust web server built with axum\"\n}\n```\n\n**Test the routes:**\n\n```bash\ncurl http://localhost:3000/\ncurl http://localhost:3000/hello\ncurl http://localhost:3000/about\n```\n\n## Returning Different Types\n\nHandlers can return various types:\n\n### String\n\n```rust\nasync fn greeting() -> String {\n    format!(\"Hello at {}\", chrono::Local::now())\n}\n```\n\n### HTML\n\n```rust\nuse axum::response::Html;\n\nasync fn html_page() -> Html<&'static str> {\n    Html(\"<h1>Hello from HTML!</h1>\")\n}\n```\n\nTest: Visit `http://localhost:3000/html` in your browser!\n\n### Status Codes\n\n```rust\nuse axum::http::StatusCode;\n\nasync fn not_found() -> StatusCode {\n    StatusCode::NOT_FOUND\n}\n\n// Or with a message:\nasync fn not_found_with_message() -> (StatusCode, &'static str) {\n    (StatusCode::NOT_FOUND, \"Page not found\")\n}\n```\n\n## Complete Example with Multiple Response Types\n\n```rust\nuse axum::{\n    routing::get,\n    Router,\n    response::{Html, IntoResponse},\n    http::StatusCode,\n};\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/\", get(home))\n        .route(\"/html\", get(html_page))\n        .route(\"/greet\", get(greeting))\n        .route(\"/status\", get(status_example))\n        .route(\"/error\", get(error_example));\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    println!(\"ðŸš€ Server running on http://localhost:3000\");\n    println!(\"   Try:\");\n    println!(\"   - http://localhost:3000/\");\n    println!(\"   - http://localhost:3000/html\");\n    println!(\"   - http://localhost:3000/greet\");\n    println!(\"   - http://localhost:3000/status\");\n    println!(\"   - http://localhost:3000/error\");\n\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn home() -> &'static str {\n    \"Welcome! Try the different routes.\"\n}\n\nasync fn html_page() -> Html<&'static str> {\n    Html(r#\"\n        <!DOCTYPE html>\n        <html>\n            <head><title>Axum Server</title></head>\n            <body>\n                <h1>Hello from Axum!</h1>\n                <p>This is an HTML response.</p>\n            </body>\n        </html>\n    \"#)\n}\n\nasync fn greeting() -> String {\n    let now = std::time::SystemTime::now()\n        .duration_since(std::time::UNIX_EPOCH)\n        .unwrap()\n        .as_secs();\n\n    format!(\"Hello! Current timestamp: {}\", now)\n}\n\nasync fn status_example() -> impl IntoResponse {\n    (StatusCode::CREATED, \"Resource created!\")\n}\n\nasync fn error_example() -> impl IntoResponse {\n    (StatusCode::INTERNAL_SERVER_ERROR, \"Oops! Something went wrong\")\n}\n```\n\n## Understanding `impl IntoResponse`\n\n```rust\nasync fn handler() -> impl IntoResponse {\n    \"Can return various types\"\n}\n```\n\n**`IntoResponse` trait** is implemented by:\n- `&str`, `String`\n- `Html<T>`\n- `StatusCode`\n- `(StatusCode, T)` where T implements IntoResponse\n- `Json<T>` (next lesson!)\n- And many more...\n\n**Why use it?**\n- Flexibility - return different types from the same function\n- Type safety - compiler checks compatibility\n\n## Different HTTP Methods\n\n```rust\nuse axum::routing::{get, post, put, delete};\n\nlet app = Router::new()\n    .route(\"/users\", get(list_users).post(create_user))\n    .route(\"/users/:id\", get(get_user).put(update_user).delete(delete_user));\n```\n\n**Each method can have its own handler:**\n\n```rust\nasync fn list_users() -> &'static str {\n    \"GET /users - List all users\"\n}\n\nasync fn create_user() -> &'static str {\n    \"POST /users - Create a user\"\n}\n\nasync fn get_user() -> &'static str {\n    \"GET /users/:id - Get one user\"\n}\n\nasync fn update_user() -> &'static str {\n    \"PUT /users/:id - Update user\"\n}\n\nasync fn delete_user() -> &'static str {\n    \"DELETE /users/:id - Delete user\"\n}\n```\n\n## Practice Exercises\n\n### Exercise 1: Personal Portfolio API\n\nCreate a web server with these routes:\n\n- `GET /` â†’ Welcome message\n- `GET /bio` â†’ Your bio (as text)\n- `GET /skills` â†’ List of your skills\n- `GET /projects` â†’ Your projects\n- `GET /contact` â†’ Contact info\n\n**Starter code:**\n\n```rust\nuse axum::{routing::get, Router};\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/\", get(home))\n        // Add more routes here\n        ;\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    println!(\"ðŸš€ Portfolio server running!\");\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn home() -> &'static str {\n    \"Welcome to my portfolio!\"\n}\n\n// Add handler functions here\n```\n\n<details>\n<summary>Solution</summary>\n\n```rust\nuse axum::{routing::get, Router, response::Html};\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/\", get(home))\n        .route(\"/bio\", get(bio))\n        .route(\"/skills\", get(skills))\n        .route(\"/projects\", get(projects))\n        .route(\"/contact\", get(contact));\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    println!(\"ðŸš€ Portfolio server running on http://localhost:3000\");\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn home() -> Html<&'static str> {\n    Html(\"<h1>Welcome to my portfolio!</h1>\")\n}\n\nasync fn bio() -> &'static str {\n    \"I'm a Rust developer passionate about systems programming and web development.\"\n}\n\nasync fn skills() -> &'static str {\n    \"Skills: Rust, Axum, Tokio, System Programming, Web Development\"\n}\n\nasync fn projects() -> &'static str {\n    \"Projects:\\n1. TaskMaster CLI\\n2. File Validator\\n3. Web Server\"\n}\n\nasync fn contact() -> &'static str {\n    \"Contact: email@example.com | GitHub: github.com/username\"\n}\n```\n</details>\n\n### Exercise 2: Status Code Practice\n\nCreate endpoints that return different status codes:\n\n- `GET /health` â†’ 200 OK with \"Healthy\"\n- `GET /teapot` â†’ 418 I'm a teapot (yes, it's real!)\n- `GET /forbidden` â†’ 403 Forbidden\n- `GET /unavailable` â†’ 503 Service Unavailable\n\n<details>\n<summary>Solution</summary>\n\n```rust\nuse axum::{routing::get, Router, http::StatusCode};\n\nasync fn health() -> (StatusCode, &'static str) {\n    (StatusCode::OK, \"Healthy\")\n}\n\nasync fn teapot() -> (StatusCode, &'static str) {\n    (StatusCode::IM_A_TEAPOT, \"I'm a teapot â˜•\")\n}\n\nasync fn forbidden() -> (StatusCode, &'static str) {\n    (StatusCode::FORBIDDEN, \"Access forbidden\")\n}\n\nasync fn unavailable() -> (StatusCode, &'static str) {\n    (StatusCode::SERVICE_UNAVAILABLE, \"Service temporarily unavailable\")\n}\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/health\", get(health))\n        .route(\"/teapot\", get(teapot))\n        .route(\"/forbidden\", get(forbidden))\n        .route(\"/unavailable\", get(unavailable));\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    axum::serve(listener, app).await.unwrap();\n}\n```\n</details>\n\n## Common Errors & Solutions\n\n### Error: \"error[E0277]: the trait bound `fn() -> impl Future<Output = ...>: Handler<_, _>` is not satisfied\"\n\n**Cause**: Forgot `async` on handler function\n\nâŒ **Wrong:**\n```rust\nfn handler() -> &'static str {  // Missing async!\n    \"Hello\"\n}\n```\n\nâœ… **Correct:**\n```rust\nasync fn handler() -> &'static str {\n    \"Hello\"\n}\n```\n\n### Error: \"Address already in use\"\n\n**Cause**: Port 3000 is already being used\n\n**Solution:**\n- Stop the old server (Ctrl+C)\n- Or use a different port: `\"0.0.0.0:8080\"`\n\n### Error: `await` can only be used in async functions\n\n**Cause**: Forgot `#[tokio::main]`\n\nâœ… **Correct:**\n```rust\n#[tokio::main]\nasync fn main() {\n    // can use .await here\n}\n```\n\n## Key Takeaways\n\n- âœ… Axum is a modern, type-safe web framework\n- âœ… `#[tokio::main]` enables async in main function\n- âœ… Router maps paths to handler functions\n- âœ… Handlers are async functions that return `IntoResponse`\n- âœ… Different routes can use different HTTP methods\n- âœ… Can return text, HTML, status codes, and more\n\n**Next**: Routing, path parameters, and extractors!\n\n---\n\n**Progress**: Module 12, Lesson 2 complete (59/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-12-03",
          "title": "Module 12: Web Development with Rust",
          "type": "exercise",
          "estimatedMinutes": 8,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 12: Web Development with Rust\n\n# Lesson 3: Routing & Extractors\n\n## Path Parameters\n\nOften, you need dynamic URLs like `/users/123` or `/posts/my-first-post`.\n\n### Basic Path Parameters\n\n```rust\nuse axum::{\n    routing::get,\n    Router,\n    extract::Path,\n};\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/users/{id}\", get(get_user))\n        .route(\"/posts/{slug}\", get(get_post));\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    axum::serve(listener, app).await.unwrap();\n}\n\n// Extract a single parameter\nasync fn get_user(Path(id): Path<u32>) -> String {\n    format!(\"Getting user with ID: {}\", id)\n}\n\nasync fn get_post(Path(slug): Path<String>) -> String {\n    format!(\"Getting post with slug: {}\", slug)\n}\n```\n\n**Test it:**\n\n```bash\ncurl http://localhost:3000/users/42\n# Output: Getting user with ID: 42\n\ncurl http://localhost:3000/posts/hello-world\n# Output: Getting post with slug: hello-world\n```\n\n### Important: Path Syntax Change\n\nAxum 0.8 changed path parameter syntax:\n\nâœ… **Axum 0.8+ (new syntax):**\n```rust\n.route(\"/users/{id}\", get(handler))        // Single parameter\n.route(\"/files/{*path}\", get(handler))     // Catch-all\n```\n\nâŒ **Axum 0.7 and earlier (old syntax):**\n```rust\n.route(\"/users/:id\", get(handler))         // Old style\n.route(\"/files/*path\", get(handler))       // Old style\n```\n\n**Use the new `{param}` syntax!**\n\n## Multiple Path Parameters\n\n```rust\nuse axum::{\n    routing::get,\n    Router,\n    extract::Path,\n};\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/users/{user_id}/posts/{post_id}\", get(get_user_post));\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    axum::serve(listener, app).await.unwrap();\n}\n\n// Method 1: Tuple extraction\nasync fn get_user_post(Path((user_id, post_id)): Path<(u32, u32)>) -> String {\n    format!(\"User {} - Post {}\", user_id, post_id)\n}\n```\n\n**Test:**\n```bash\ncurl http://localhost:3000/users/5/posts/42\n# Output: User 5 - Post 42\n```\n\n### Using a Struct for Parameters\n\nFor better readability with many parameters:\n\n```rust\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct PostPath {\n    user_id: u32,\n    post_id: u32,\n}\n\nasync fn get_user_post(Path(params): Path<PostPath>) -> String {\n    format!(\"User {} - Post {}\", params.user_id, params.post_id)\n}\n```\n\n## Query Parameters\n\nQuery parameters come after `?` in the URL: `/search?q=rust&limit=10`\n\n```rust\nuse axum::extract::Query;\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct SearchParams {\n    q: String,\n    #[serde(default = \"default_limit\")]\n    limit: u32,\n}\n\nfn default_limit() -> u32 {\n    10\n}\n\nasync fn search(Query(params): Query<SearchParams>) -> String {\n    format!(\"Searching for '{}' with limit {}\", params.q, params.limit)\n}\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/search\", get(search));\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    axum::serve(listener, app).await.unwrap();\n}\n```\n\n**Test:**\n\n```bash\ncurl \"http://localhost:3000/search?q=rust\"\n# Output: Searching for 'rust' with limit 10\n\ncurl \"http://localhost:3000/search?q=rust&limit=20\"\n# Output: Searching for 'rust' with limit 20\n```\n\n### Optional Query Parameters\n\n```rust\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct Pagination {\n    page: Option<u32>,\n    per_page: Option<u32>,\n}\n\nasync fn list_items(Query(pagination): Query<Pagination>) -> String {\n    let page = pagination.page.unwrap_or(1);\n    let per_page = pagination.per_page.unwrap_or(20);\n\n    format!(\"Page {} with {} items per page\", page, per_page)\n}\n```\n\n## What are Extractors?\n\n**Extractors** pull data out of HTTP requests in a type-safe way.\n\n### Common Extractors\n\n| Extractor | What it extracts |\n|-----------|------------------|\n| `Path<T>` | URL path parameters |\n| `Query<T>` | Query string parameters |\n| `Json<T>` | JSON request body |\n| `Form<T>` | Form data |\n| `Extension<T>` | Shared state |\n| `headers::HeaderMap` | HTTP headers |\n\n## Combining Multiple Extractors\n\nYou can use multiple extractors in the same handler:\n\n```rust\nuse axum::{\n    extract::{Path, Query},\n    Json,\n};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize)]\nstruct UserQuery {\n    include_posts: bool,\n}\n\n#[derive(Serialize)]\nstruct User {\n    id: u32,\n    name: String,\n    posts: Option<Vec<String>>,\n}\n\nasync fn get_user_detailed(\n    Path(id): Path<u32>,\n    Query(query): Query<UserQuery>,\n) -> Json<User> {\n    let posts = if query.include_posts {\n        Some(vec![\"Post 1\".to_string(), \"Post 2\".to_string()])\n    } else {\n        None\n    };\n\n    Json(User {\n        id,\n        name: format!(\"User {}\", id),\n        posts,\n    })\n}\n```\n\n**Test:**\n```bash\ncurl \"http://localhost:3000/users/5?include_posts=true\"\n# Output: {\"id\":5,\"name\":\"User 5\",\"posts\":[\"Post 1\",\"Post 2\"]}\n```\n\n## Catch-All Routes\n\nCapture the rest of the path:\n\n```rust\nasync fn serve_file(Path(path): Path<String>) -> String {\n    format!(\"Serving file: {}\", path)\n}\n\nlet app = Router::new()\n    .route(\"/files/{*path}\", get(serve_file));\n```\n\n**Test:**\n```bash\ncurl http://localhost:3000/files/docs/readme.md\n# Output: Serving file: docs/readme.md\n\ncurl http://localhost:3000/files/a/b/c/d.txt\n# Output: Serving file: a/b/c/d.txt\n```\n\n## Nested Routers\n\nOrganize large applications by nesting routers:\n\n```rust\nuse axum::Router;\nuse axum::routing::get;\n\n#[tokio::main]\nasync fn main() {\n    // User routes\n    let user_routes = Router::new()\n        .route(\"/\", get(list_users))\n        .route(\"/{id}\", get(get_user));\n\n    // Post routes\n    let post_routes = Router::new()\n        .route(\"/\", get(list_posts))\n        .route(\"/{id}\", get(get_post));\n\n    // Main app\n    let app = Router::new()\n        .route(\"/\", get(home))\n        .nest(\"/users\", user_routes)\n        .nest(\"/posts\", post_routes);\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    println!(\"ðŸš€ Server running!\");\n    println!(\"   GET /\");\n    println!(\"   GET /users\");\n    println!(\"   GET /users/{{id}}\");\n    println!(\"   GET /posts\");\n    println!(\"   GET /posts/{{id}}\");\n\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn home() -> &'static str {\n    \"API Home\"\n}\n\nasync fn list_users() -> &'static str {\n    \"List of all users\"\n}\n\nasync fn get_user(Path(id): Path<u32>) -> String {\n    format!(\"User {}\", id)\n}\n\nasync fn list_posts() -> &'static str {\n    \"List of all posts\"\n}\n\nasync fn get_post(Path(id): Path<u32>) -> String {\n    format!(\"Post {}\", id)\n}\n```\n\n## Router Fallback (404 Handler)\n\nHandle routes that don't match:\n\n```rust\nuse axum::http::StatusCode;\n\nasync fn not_found() -> (StatusCode, &'static str) {\n    (StatusCode::NOT_FOUND, \"404 - Page not found\")\n}\n\nlet app = Router::new()\n    .route(\"/\", get(home))\n    .route(\"/about\", get(about))\n    .fallback(not_found);\n```\n\n**Test:**\n```bash\ncurl http://localhost:3000/nonexistent\n# Output: 404 - Page not found\n```\n\n## Complete Example: Blog API Routing\n\n```rust\nuse axum::{\n    routing::{get, post, put, delete},\n    Router,\n    extract::{Path, Query},\n    Json,\n    http::StatusCode,\n};\nuse serde::{Deserialize, Serialize};\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/\", get(api_info))\n        .route(\"/posts\", get(list_posts).post(create_post))\n        .route(\"/posts/{id}\", get(get_post).put(update_post).delete(delete_post))\n        .route(\"/posts/{id}/comments\", get(list_comments))\n        .fallback(not_found);\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    println!(\"ðŸš€ Blog API running on http://localhost:3000\");\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn api_info() -> &'static str {\n    \"Blog API v1.0\"\n}\n\n#[derive(Deserialize)]\nstruct ListQuery {\n    #[serde(default)]\n    page: u32,\n    #[serde(default = \"default_per_page\")]\n    per_page: u32,\n}\n\nfn default_per_page() -> u32 {\n    10\n}\n\nasync fn list_posts(Query(query): Query<ListQuery>) -> String {\n    format!(\"Listing posts - page {}, {} per page\", query.page, query.per_page)\n}\n\n#[derive(Deserialize)]\nstruct CreatePost {\n    title: String,\n    content: String,\n}\n\nasync fn create_post(Json(post): Json<CreatePost>) -> (StatusCode, String) {\n    (\n        StatusCode::CREATED,\n        format!(\"Created post: {}\", post.title)\n    )\n}\n\nasync fn get_post(Path(id): Path<u32>) -> String {\n    format!(\"Getting post {}\", id)\n}\n\n#[derive(Deserialize)]\nstruct UpdatePost {\n    title: Option<String>,\n    content: Option<String>,\n}\n\nasync fn update_post(\n    Path(id): Path<u32>,\n    Json(update): Json<UpdatePost>,\n) -> String {\n    format!(\"Updating post {}\", id)\n}\n\nasync fn delete_post(Path(id): Path<u32>) -> (StatusCode, String) {\n    (StatusCode::NO_CONTENT, format!(\"Deleted post {}\", id))\n}\n\nasync fn list_comments(Path(post_id): Path<u32>) -> String {\n    format!(\"Listing comments for post {}\", post_id)\n}\n\nasync fn not_found() -> (StatusCode, &'static str) {\n    (StatusCode::NOT_FOUND, \"Endpoint not found\")\n}\n```\n\n## Practice Exercises\n\n### Exercise 1: E-commerce Routes\n\nBuild routing for an e-commerce API:\n\n**Requirements:**\n- `/products` - GET (list products), POST (create product)\n- `/products/{id}` - GET (get product), PUT (update), DELETE (delete)\n- `/categories` - GET (list categories)\n- `/products?category=electronics&sort=price` - Filter and sort\n- `/orders/{order_id}/items` - GET items in an order\n\n<details>\n<summary>Solution</summary>\n\n```rust\nuse axum::{\n    routing::{get, post, put, delete},\n    Router,\n    extract::{Path, Query},\n};\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct ProductQuery {\n    category: Option<String>,\n    sort: Option<String>,\n}\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/products\", get(list_products).post(create_product))\n        .route(\"/products/{id}\", get(get_product).put(update_product).delete(delete_product))\n        .route(\"/categories\", get(list_categories))\n        .route(\"/orders/{order_id}/items\", get(list_order_items));\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    println!(\"ðŸš€ E-commerce API running!\");\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn list_products(Query(query): Query<ProductQuery>) -> String {\n    format!(\n        \"Products - category: {:?}, sort: {:?}\",\n        query.category, query.sort\n    )\n}\n\nasync fn create_product() -> &'static str {\n    \"Create product\"\n}\n\nasync fn get_product(Path(id): Path<u32>) -> String {\n    format!(\"Get product {}\", id)\n}\n\nasync fn update_product(Path(id): Path<u32>) -> String {\n    format!(\"Update product {}\", id)\n}\n\nasync fn delete_product(Path(id): Path<u32>) -> String {\n    format!(\"Delete product {}\", id)\n}\n\nasync fn list_categories() -> &'static str {\n    \"List categories\"\n}\n\nasync fn list_order_items(Path(order_id): Path<u32>) -> String {\n    format!(\"List items for order {}\", order_id)\n}\n```\n</details>\n\n### Exercise 2: File Server with Catch-All\n\nCreate a file server that:\n- `/files/{*path}` - serves any file path\n- Extracts the full path\n- Returns \"Serving: [path]\"\n\n<details>\n<summary>Solution</summary>\n\n```rust\nuse axum::{\n    routing::get,\n    Router,\n    extract::Path,\n};\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/\", get(home))\n        .route(\"/files/{*path}\", get(serve_file));\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    println!(\"ðŸš€ File server running!\");\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn home() -> &'static str {\n    \"File Server - use /files/path/to/file\"\n}\n\nasync fn serve_file(Path(path): Path<String>) -> String {\n    format!(\"Serving: {}\", path)\n}\n```\n\n**Test:**\n```bash\ncurl http://localhost:3000/files/documents/report.pdf\n# Output: Serving: documents/report.pdf\n```\n</details>\n\n### Exercise 3: Search API with Multiple Parameters\n\nCreate `/search` endpoint that accepts:\n- `q` - search query (required)\n- `category` - filter by category (optional)\n- `page` - page number (optional, default 1)\n- `limit` - results per page (optional, default 20)\n\n<details>\n<summary>Solution</summary>\n\n```rust\nuse axum::{routing::get, Router, extract::Query};\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct SearchParams {\n    q: String,\n    category: Option<String>,\n    #[serde(default = \"default_page\")]\n    page: u32,\n    #[serde(default = \"default_limit\")]\n    limit: u32,\n}\n\nfn default_page() -> u32 {\n    1\n}\n\nfn default_limit() -> u32 {\n    20\n}\n\nasync fn search(Query(params): Query<SearchParams>) -> String {\n    format!(\n        \"Search: '{}' in category: {:?}, page: {}, limit: {}\",\n        params.q, params.category, params.page, params.limit\n    )\n}\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new().route(\"/search\", get(search));\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    axum::serve(listener, app).await.unwrap();\n}\n```\n\n**Test:**\n```bash\ncurl \"http://localhost:3000/search?q=rust\"\ncurl \"http://localhost:3000/search?q=rust&category=books&page=2&limit=10\"\n```\n</details>\n\n## Common Patterns\n\n### Versioned APIs\n\n```rust\nlet v1_routes = Router::new()\n    .route(\"/users\", get(v1_users));\n\nlet v2_routes = Router::new()\n    .route(\"/users\", get(v2_users));\n\nlet app = Router::new()\n    .nest(\"/api/v1\", v1_routes)\n    .nest(\"/api/v2\", v2_routes);\n```\n\n### RESTful Resource Routes\n\n```rust\nfn resource_routes<T>() -> Router {\n    Router::new()\n        .route(\"/\", get(list::<T>).post(create::<T>))\n        .route(\"/{id}\", get(get::<T>).put(update::<T>).delete(delete::<T>))\n}\n```\n\n## Key Takeaways\n\n- âœ… Path parameters: `/users/{id}` extracts dynamic segments\n- âœ… Query parameters: `/search?q=rust` extracts URL parameters\n- âœ… Extractors pull typed data from requests\n- âœ… Can combine multiple extractors in one handler\n- âœ… Catch-all routes: `{*path}` captures remaining path\n- âœ… Nested routers organize code into modules\n- âœ… Fallback handler catches 404s\n\n**Next**: JSON APIs and working with request/response bodies!\n\n---\n\n**Progress**: Module 12, Lesson 3 complete (60/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-12-04",
          "title": "Module 12: Web Development with Rust",
          "type": "project",
          "estimatedMinutes": 10,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 12: Web Development with Rust\n\n# Lesson 4: JSON APIs & Request Bodies\n\n## Working with JSON\n\nMost modern APIs use **JSON** (JavaScript Object Notation) to send and receive data.\n\n### The `Json` Extractor\n\nAxum provides `Json<T>` for easy JSON handling:\n\n```rust\nuse axum::{\n    routing::{get, post},\n    Router,\n    Json,\n};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize)]\nstruct User {\n    name: String,\n    email: String,\n    age: u32,\n}\n\nasync fn create_user(Json(user): Json<User>) -> Json<User> {\n    // Automatically deserializes JSON from request body\n    // Automatically serializes response to JSON\n    Json(user)\n}\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/users\", post(create_user));\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    axum::serve(listener, app).await.unwrap();\n}\n```\n\n**Test with curl:**\n\n```bash\ncurl -X POST http://localhost:3000/users \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\":\"Alice\",\"email\":\"alice@example.com\",\"age\":30}'\n\n# Response:\n# {\"name\":\"Alice\",\"email\":\"alice@example.com\",\"age\":30}\n```\n\n## Complete CRUD API Example\n\nLet's build a complete REST API for managing tasks:\n\n```rust\nuse axum::{\n    routing::{get, post, put, delete},\n    Router,\n    Json,\n    extract::Path,\n    http::StatusCode,\n};\nuse serde::{Deserialize, Serialize};\nuse std::sync::{Arc, Mutex};\n\n// Data model\n#[derive(Serialize, Deserialize, Clone)]\nstruct Task {\n    id: u32,\n    title: String,\n    completed: bool,\n}\n\n// Request types\n#[derive(Deserialize)]\nstruct CreateTask {\n    title: String,\n}\n\n#[derive(Deserialize)]\nstruct UpdateTask {\n    title: Option<String>,\n    completed: Option<bool>,\n}\n\n// Response types\n#[derive(Serialize)]\nstruct TaskResponse {\n    task: Task,\n}\n\n#[derive(Serialize)]\nstruct TasksResponse {\n    tasks: Vec<Task>,\n}\n\n// Shared state (we'll improve this with a database later)\ntype AppState = Arc<Mutex<Vec<Task>>>;\n\n> **âš ï¸ IMPORTANT NOTE: Temporary Learning Pattern**\n>\n> The `Arc<Mutex<Vec<Task>>>` pattern you see here is a **temporary tool for in-memory learning**. It is:\n> - âŒ **Difficult to understand** (complex ownership and locking concepts)\n> - âŒ **Performance bottleneck** (locks block other requests)\n> - âŒ **Not production-ready** (data lost on restart, no persistence)\n> - âŒ **Limited scalability** (single-server only, doesn't work with multiple instances)\n>\n> **Don't worry if this feels confusing!** In Module 13, you'll learn the **production-ready solution** using a database (PostgreSQL + SQLx), which is:\n> - âœ… **Much simpler** (no Arc, no Mutex, no manual locking)\n> - âœ… **Much more powerful** (complex queries, transactions, relationships)\n> - âœ… **Production-ready** (persistent data, works with multiple servers)\n>\n> This `Arc<Mutex<T>>` pattern is just a stepping stone to help you understand state management in web servers before introducing databases. Focus on understanding the API patterns (routes, handlers, JSON) rather than mastering Arc/Mutex!\n\n#[tokio::main]\nasync fn main() {\n    // Initialize state\n    let state: AppState = Arc::new(Mutex::new(vec![\n        Task { id: 1, title: \"Learn Rust\".to_string(), completed: false },\n        Task { id: 2, title: \"Build API\".to_string(), completed: false },\n    ]));\n\n    let app = Router::new()\n        .route(\"/tasks\", get(list_tasks).post(create_task))\n        .route(\"/tasks/{id}\", get(get_task).put(update_task).delete(delete_task))\n        .with_state(state);\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    println!(\"ðŸš€ Task API running on http://localhost:3000\");\n    axum::serve(listener, app).await.unwrap();\n}\n\n// GET /tasks - List all tasks\nasync fn list_tasks(\n    axum::extract::State(state): axum::extract::State<AppState>,\n) -> Json<TasksResponse> {\n    let tasks = state.lock().unwrap().clone();\n    Json(TasksResponse { tasks })\n}\n\n// GET /tasks/:id - Get single task\nasync fn get_task(\n    Path(id): Path<u32>,\n    axum::extract::State(state): axum::extract::State<AppState>,\n) -> Result<Json<TaskResponse>, StatusCode> {\n    let tasks = state.lock().unwrap();\n    let task = tasks.iter()\n        .find(|t| t.id == id)\n        .cloned();\n\n    match task {\n        Some(task) => Ok(Json(TaskResponse { task })),\n        None => Err(StatusCode::NOT_FOUND),\n    }\n}\n\n// POST /tasks - Create task\nasync fn create_task(\n    axum::extract::State(state): axum::extract::State<AppState>,\n    Json(create): Json<CreateTask>,\n) -> (StatusCode, Json<TaskResponse>) {\n    let mut tasks = state.lock().unwrap();\n\n    let id = tasks.iter().map(|t| t.id).max().unwrap_or(0) + 1;\n\n    let task = Task {\n        id,\n        title: create.title,\n        completed: false,\n    };\n\n    tasks.push(task.clone());\n\n    (StatusCode::CREATED, Json(TaskResponse { task }))\n}\n\n// PUT /tasks/:id - Update task\nasync fn update_task(\n    Path(id): Path<u32>,\n    axum::extract::State(state): axum::extract::State<AppState>,\n    Json(update): Json<UpdateTask>,\n) -> Result<Json<TaskResponse>, StatusCode> {\n    let mut tasks = state.lock().unwrap();\n\n    let task = tasks.iter_mut()\n        .find(|t| t.id == id);\n\n    match task {\n        Some(task) => {\n            if let Some(title) = update.title {\n                task.title = title;\n            }\n            if let Some(completed) = update.completed {\n                task.completed = completed;\n            }\n            Ok(Json(TaskResponse { task: task.clone() }))\n        }\n        None => Err(StatusCode::NOT_FOUND),\n    }\n}\n\n// DELETE /tasks/:id - Delete task\nasync fn delete_task(\n    Path(id): Path<u32>,\n    axum::extract::State(state): axum::extract::State<AppState>,\n) -> StatusCode {\n    let mut tasks = state.lock().unwrap();\n\n    let before_len = tasks.len();\n    tasks.retain(|t| t.id != id);\n    let after_len = tasks.len();\n\n    if before_len > after_len {\n        StatusCode::NO_CONTENT\n    } else {\n        StatusCode::NOT_FOUND\n    }\n}\n```\n\n### Test the API\n\n```bash\n# List all tasks\ncurl http://localhost:3000/tasks\n\n# Get single task\ncurl http://localhost:3000/tasks/1\n\n# Create task\ncurl -X POST http://localhost:3000/tasks \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\":\"Write documentation\"}'\n\n# Update task\ncurl -X PUT http://localhost:3000/tasks/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"completed\":true}'\n\n# Delete task\ncurl -X DELETE http://localhost:3000/tasks/1\n```\n\n## Understanding Shared State\n\n### The `Arc<Mutex<T>>` Pattern\n\n```rust\ntype AppState = Arc<Mutex<Vec<Task>>>;\n```\n\n**Breaking it down:**\n\n- **`Vec<Task>`** - The actual data (list of tasks)\n- **`Mutex<T>`** - Ensures only one thread can access at a time\n- **`Arc<T>`** - Allows sharing across threads (Atomic Reference Counted)\n\n**Why needed?**\n- Web servers handle multiple requests concurrently\n- Each request runs in its own task/thread\n- Shared data must be protected from race conditions\n\n### Accessing State in Handlers\n\n```rust\nasync fn handler(\n    axum::extract::State(state): axum::extract::State<AppState>,\n) -> String {\n    let data = state.lock().unwrap();\n    // use data\n    format!(\"Data: {:?}\", data)\n}\n```\n\n**Important**: Always drop the lock quickly to avoid blocking other requests!\n\nâœ… **Good:**\n```rust\nasync fn handler(State(state): State<AppState>) -> String {\n    let result = {\n        let data = state.lock().unwrap();\n        data.clone() // or extract what you need\n    }; // lock is dropped here\n\n    // do other work\n    format!(\"{:?}\", result)\n}\n```\n\nâŒ **Bad:**\n```rust\nasync fn handler(State(state): State<AppState>) -> String {\n    let data = state.lock().unwrap();\n    // long computation while holding lock - blocks other requests!\n    tokio::time::sleep(Duration::from_secs(10)).await;\n    format!(\"{:?}\", data)\n}\n```\n\n## Error Handling in APIs\n\n### Custom Error Responses\n\n```rust\nuse axum::{\n    response::{IntoResponse, Response},\n    http::StatusCode,\n    Json,\n};\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct ErrorResponse {\n    error: String,\n    message: String,\n}\n\nenum ApiError {\n    NotFound,\n    BadRequest(String),\n    InternalError,\n}\n\nimpl IntoResponse for ApiError {\n    fn into_response(self) -> Response {\n        let (status, error, message) = match self {\n            ApiError::NotFound => (\n                StatusCode::NOT_FOUND,\n                \"NOT_FOUND\",\n                \"Resource not found\",\n            ),\n            ApiError::BadRequest(msg) => (\n                StatusCode::BAD_REQUEST,\n                \"BAD_REQUEST\",\n                &msg,\n            ),\n            ApiError::InternalError => (\n                StatusCode::INTERNAL_SERVER_ERROR,\n                \"INTERNAL_ERROR\",\n                \"Something went wrong\",\n            ),\n        };\n\n        let body = Json(ErrorResponse {\n            error: error.to_string(),\n            message: message.to_string(),\n        });\n\n        (status, body).into_response()\n    }\n}\n\n// Use in handlers\nasync fn get_task(Path(id): Path<u32>) -> Result<Json<Task>, ApiError> {\n    if id > 100 {\n        return Err(ApiError::NotFound);\n    }\n\n    // ... fetch task\n\n    Ok(Json(task))\n}\n```\n\n### Validation\n\n```rust\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct CreateUser {\n    #[serde(deserialize_with = \"validate_email\")]\n    email: String,\n    #[serde(deserialize_with = \"validate_age\")]\n    age: u32,\n}\n\nfn validate_email<'de, D>(deserializer: D) -> Result<String, D::Error>\nwhere\n    D: serde::Deserializer<'de>,\n{\n    let email = String::deserialize(deserializer)?;\n    if email.contains('@') {\n        Ok(email)\n    } else {\n        Err(serde::de::Error::custom(\"Invalid email\"))\n    }\n}\n\nfn validate_age<'de, D>(deserializer: D) -> Result<u32, D::Error>\nwhere\n    D: serde::Deserializer<'de>,\n{\n    let age = u32::deserialize(deserializer)?;\n    if age >= 18 && age <= 120 {\n        Ok(age)\n    } else {\n        Err(serde::de::Error::custom(\"Age must be 18-120\"))\n    }\n}\n\nasync fn create_user(Json(user): Json<CreateUser>) -> StatusCode {\n    // If we get here, validation passed\n    StatusCode::CREATED\n}\n```\n\n## Response Types\n\n### Different Response Formats\n\n```rust\nuse axum::response::{Html, IntoResponse};\nuse axum::http::header;\n\n// JSON\nasync fn json_response() -> Json<User> {\n    Json(User { name: \"Alice\".into(), email: \"alice@example.com\".into(), age: 30 })\n}\n\n// HTML\nasync fn html_response() -> Html<String> {\n    Html(\"<h1>Hello</h1>\".to_string())\n}\n\n// Plain text with custom headers\nasync fn custom_response() -> impl IntoResponse {\n    (\n        StatusCode::OK,\n        [(header::CONTENT_TYPE, \"text/plain\")],\n        \"Custom response\"\n    )\n}\n\n// Redirect\nasync fn redirect() -> impl IntoResponse {\n    axum::response::Redirect::to(\"/new-url\")\n}\n```\n\n### Conditional Responses\n\n```rust\nasync fn get_user(Path(id): Path<u32>) -> impl IntoResponse {\n    if id == 0 {\n        return (StatusCode::BAD_REQUEST, \"Invalid ID\").into_response();\n    }\n\n    if id > 1000 {\n        return (StatusCode::NOT_FOUND, \"User not found\").into_response();\n    }\n\n    Json(User {\n        id,\n        name: format!(\"User {}\", id),\n        email: format!(\"user{}@example.com\", id),\n    }).into_response()\n}\n```\n\n## Practice Exercises\n\n### Exercise 1: Book Library API\n\nCreate a REST API for managing books:\n\n**Requirements:**\n- Book model: `id`, `title`, `author`, `isbn`, `available`\n- `GET /books` - list all books\n- `GET /books/:id` - get single book\n- `POST /books` - create book (returns 201)\n- `PUT /books/:id` - update book\n- `DELETE /books/:id` - delete book (returns 204)\n- Use shared state with Arc<Mutex<Vec<Book>>>\n\n<details>\n<summary>Solution</summary>\n\n```rust\nuse axum::{\n    routing::{get, post, put, delete},\n    Router,\n    Json,\n    extract::{Path, State},\n    http::StatusCode,\n};\nuse serde::{Deserialize, Serialize};\nuse std::sync::{Arc, Mutex};\n\n#[derive(Serialize, Deserialize, Clone)]\nstruct Book {\n    id: u32,\n    title: String,\n    author: String,\n    isbn: String,\n    available: bool,\n}\n\n#[derive(Deserialize)]\nstruct CreateBook {\n    title: String,\n    author: String,\n    isbn: String,\n}\n\n#[derive(Deserialize)]\nstruct UpdateBook {\n    title: Option<String>,\n    author: Option<String>,\n    available: Option<bool>,\n}\n\ntype AppState = Arc<Mutex<Vec<Book>>>;\n\n#[tokio::main]\nasync fn main() {\n    let state: AppState = Arc::new(Mutex::new(vec![]));\n\n    let app = Router::new()\n        .route(\"/books\", get(list_books).post(create_book))\n        .route(\"/books/{id}\", get(get_book).put(update_book).delete(delete_book))\n        .with_state(state);\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    println!(\"ðŸ“š Book Library API running!\");\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn list_books(State(state): State<AppState>) -> Json<Vec<Book>> {\n    let books = state.lock().unwrap().clone();\n    Json(books)\n}\n\nasync fn get_book(\n    Path(id): Path<u32>,\n    State(state): State<AppState>,\n) -> Result<Json<Book>, StatusCode> {\n    let books = state.lock().unwrap();\n    books.iter()\n        .find(|b| b.id == id)\n        .cloned()\n        .map(Json)\n        .ok_or(StatusCode::NOT_FOUND)\n}\n\nasync fn create_book(\n    State(state): State<AppState>,\n    Json(create): Json<CreateBook>,\n) -> (StatusCode, Json<Book>) {\n    let mut books = state.lock().unwrap();\n    let id = books.iter().map(|b| b.id).max().unwrap_or(0) + 1;\n\n    let book = Book {\n        id,\n        title: create.title,\n        author: create.author,\n        isbn: create.isbn,\n        available: true,\n    };\n\n    books.push(book.clone());\n    (StatusCode::CREATED, Json(book))\n}\n\nasync fn update_book(\n    Path(id): Path<u32>,\n    State(state): State<AppState>,\n    Json(update): Json<UpdateBook>,\n) -> Result<Json<Book>, StatusCode> {\n    let mut books = state.lock().unwrap();\n\n    books.iter_mut()\n        .find(|b| b.id == id)\n        .map(|book| {\n            if let Some(title) = update.title {\n                book.title = title;\n            }\n            if let Some(author) = update.author {\n                book.author = author;\n            }\n            if let Some(available) = update.available {\n                book.available = available;\n            }\n            Json(book.clone())\n        })\n        .ok_or(StatusCode::NOT_FOUND)\n}\n\nasync fn delete_book(\n    Path(id): Path<u32>,\n    State(state): State<AppState>,\n) -> StatusCode {\n    let mut books = state.lock().unwrap();\n    let len_before = books.len();\n    books.retain(|b| b.id != id);\n\n    if books.len() < len_before {\n        StatusCode::NO_CONTENT\n    } else {\n        StatusCode::NOT_FOUND\n    }\n}\n```\n</details>\n\n### Exercise 2: Input Validation\n\nAdd validation to the book creation:\n- Title must not be empty\n- ISBN must be exactly 13 characters\n- Author must not be empty\n\nReturn 400 Bad Request with error message if validation fails.\n\n<details>\n<summary>Hint</summary>\n\nCreate a validation function that returns `Result<(), String>`:\n\n```rust\nfn validate_create_book(book: &CreateBook) -> Result<(), String> {\n    if book.title.trim().is_empty() {\n        return Err(\"Title cannot be empty\".to_string());\n    }\n    if book.isbn.len() != 13 {\n        return Err(\"ISBN must be 13 characters\".to_string());\n    }\n    if book.author.trim().is_empty() {\n        return Err(\"Author cannot be empty\".to_string());\n    }\n    Ok(())\n}\n```\n\nUse it in the handler before creating the book.\n</details>\n\n### Exercise 3: Custom Error Type\n\nCreate a custom error type for the Book API that handles:\n- NotFound\n- ValidationError(String)\n- InternalError\n\nImplement `IntoResponse` to return proper JSON error responses.\n\n<details>\n<summary>Solution</summary>\n\n```rust\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct ErrorResponse {\n    error: String,\n    message: String,\n}\n\nenum BookApiError {\n    NotFound,\n    ValidationError(String),\n    InternalError,\n}\n\nimpl IntoResponse for BookApiError {\n    fn into_response(self) -> Response {\n        let (status, error, message) = match self {\n            BookApiError::NotFound => (\n                StatusCode::NOT_FOUND,\n                \"NOT_FOUND\",\n                \"Book not found\".to_string(),\n            ),\n            BookApiError::ValidationError(msg) => (\n                StatusCode::BAD_REQUEST,\n                \"VALIDATION_ERROR\",\n                msg,\n            ),\n            BookApiError::InternalError => (\n                StatusCode::INTERNAL_SERVER_ERROR,\n                \"INTERNAL_ERROR\",\n                \"Something went wrong\".to_string(),\n            ),\n        };\n\n        (\n            status,\n            Json(ErrorResponse {\n                error: error.to_string(),\n                message,\n            }),\n        ).into_response()\n    }\n}\n\nasync fn create_book(\n    State(state): State<AppState>,\n    Json(create): Json<CreateBook>,\n) -> Result<(StatusCode, Json<Book>), BookApiError> {\n    // Validate\n    if create.title.trim().is_empty() {\n        return Err(BookApiError::ValidationError(\"Title is required\".into()));\n    }\n\n    // Create book\n    let mut books = state.lock().unwrap();\n    let id = books.iter().map(|b| b.id).max().unwrap_or(0) + 1;\n\n    let book = Book {\n        id,\n        title: create.title,\n        author: create.author,\n        isbn: create.isbn,\n        available: true,\n    };\n\n    books.push(book.clone());\n    Ok((StatusCode::CREATED, Json(book)))\n}\n```\n</details>\n\n## Key Takeaways\n\n- âœ… `Json<T>` automatically serializes/deserializes JSON\n- âœ… Use `Arc<Mutex<T>>` for shared state across handlers\n- âœ… Return appropriate status codes (200, 201, 204, 400, 404, 500)\n- âœ… Create custom error types implementing `IntoResponse`\n- âœ… Validate input data before processing\n- âœ… Keep Mutex locks held for minimal time\n- âœ… Use `with_state()` to share data across handlers\n\n**Next**: Building a complete RESTful API practice project!\n\n---\n\n**Progress**: Module 12, Lesson 4 complete (61/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-12-05",
          "title": "Module 12: Web Development with Rust",
          "type": "project",
          "estimatedMinutes": 9,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 12: Web Development with Rust\n\n# Lesson 5: Practice Project â€” Blog REST API\n\n## Project Overview\n\nBuild a complete **Blog REST API** with:\n- Posts (create, read, update, delete, list)\n- Comments on posts\n- Tags for categorization\n- Filtering and pagination\n- Proper error handling\n- Input validation\n\nThis project integrates everything you've learned in Module 12!\n\n## Project Setup\n\n```bash\ncargo new blog_api\ncd blog_api\n```\n\n### Dependencies\n\n```toml\n[package]\nname = \"blog_api\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\naxum = \"0.8.x\"\ntokio = { version = \"1.x\", features = [\"full\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nchrono = { version = \"0.4\", features = [\"serde\"] }\n```\n\n## Step 1: Data Models\n\nCreate `src/models.rs`:\n\n```rust\nuse serde::{Deserialize, Serialize};\nuse chrono::{DateTime, Utc};\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct Post {\n    pub id: u32,\n    pub title: String,\n    pub content: String,\n    pub author: String,\n    pub tags: Vec<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct Comment {\n    pub id: u32,\n    pub post_id: u32,\n    pub author: String,\n    pub content: String,\n    pub created_at: DateTime<Utc>,\n}\n\n#[derive(Deserialize, Debug)]\npub struct CreatePost {\n    pub title: String,\n    pub content: String,\n    pub author: String,\n    pub tags: Vec<String>,\n}\n\n#[derive(Deserialize, Debug)]\npub struct UpdatePost {\n    pub title: Option<String>,\n    pub content: Option<String>,\n    pub tags: Option<Vec<String>>,\n}\n\n#[derive(Deserialize, Debug)]\npub struct CreateComment {\n    pub author: String,\n    pub content: String,\n}\n\n#[derive(Deserialize, Debug)]\npub struct ListPostsQuery {\n    pub tag: Option<String>,\n    #[serde(default)]\n    pub page: u32,\n    #[serde(default = \"default_limit\")]\n    pub limit: u32,\n}\n\nfn default_limit() -> u32 {\n    10\n}\n```\n\n## Step 2: Application State\n\nCreate `src/state.rs`:\n\n```rust\nuse crate::models::{Post, Comment};\nuse std::sync::{Arc, Mutex};\n\n#[derive(Clone)]\npub struct AppState {\n    pub posts: Arc<Mutex<Vec<Post>>>,\n    pub comments: Arc<Mutex<Vec<Comment>>>,\n}\n\nimpl AppState {\n    pub fn new() -> Self {\n        Self {\n            posts: Arc::new(Mutex::new(Vec::new())),\n            comments: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n\n    pub fn with_sample_data() -> Self {\n        use chrono::Utc;\n\n        let posts = vec![\n            Post {\n                id: 1,\n                title: \"Getting Started with Rust\".to_string(),\n                content: \"Rust is a systems programming language...\".to_string(),\n                author: \"Alice\".to_string(),\n                tags: vec![\"rust\".to_string(), \"programming\".to_string()],\n                created_at: Utc::now(),\n                updated_at: Utc::now(),\n            },\n            Post {\n                id: 2,\n                title: \"Building Web APIs with Axum\".to_string(),\n                content: \"Axum is a modern web framework...\".to_string(),\n                author: \"Bob\".to_string(),\n                tags: vec![\"rust\".to_string(), \"web\".to_string(), \"axum\".to_string()],\n                created_at: Utc::now(),\n                updated_at: Utc::now(),\n            },\n        ];\n\n        let comments = vec![\n            Comment {\n                id: 1,\n                post_id: 1,\n                author: \"Charlie\".to_string(),\n                content: \"Great article!\".to_string(),\n                created_at: Utc::now(),\n            },\n        ];\n\n        Self {\n            posts: Arc::new(Mutex::new(posts)),\n            comments: Arc::new(Mutex::new(comments)),\n        }\n    }\n}\n```\n\n## Step 3: Error Handling\n\nCreate `src/errors.rs`:\n\n```rust\nuse axum::{\n    response::{IntoResponse, Response},\n    http::StatusCode,\n    Json,\n};\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct ErrorResponse {\n    error: String,\n    message: String,\n}\n\npub enum ApiError {\n    NotFound,\n    BadRequest(String),\n    InternalError,\n}\n\nimpl IntoResponse for ApiError {\n    fn into_response(self) -> Response {\n        let (status, error_code, message) = match self {\n            ApiError::NotFound => (\n                StatusCode::NOT_FOUND,\n                \"NOT_FOUND\",\n                \"Resource not found\".to_string(),\n            ),\n            ApiError::BadRequest(msg) => (\n                StatusCode::BAD_REQUEST,\n                \"BAD_REQUEST\",\n                msg,\n            ),\n            ApiError::InternalError => (\n                StatusCode::INTERNAL_SERVER_ERROR,\n                \"INTERNAL_ERROR\",\n                \"An internal error occurred\".to_string(),\n            ),\n        };\n\n        (\n            status,\n            Json(ErrorResponse {\n                error: error_code.to_string(),\n                message,\n            }),\n        )\n            .into_response()\n    }\n}\n\npub fn validate_create_post(post: &crate::models::CreatePost) -> Result<(), ApiError> {\n    if post.title.trim().is_empty() {\n        return Err(ApiError::BadRequest(\"Title cannot be empty\".to_string()));\n    }\n\n    if post.content.trim().is_empty() {\n        return Err(ApiError::BadRequest(\"Content cannot be empty\".to_string()));\n    }\n\n    if post.author.trim().is_empty() {\n        return Err(ApiError::BadRequest(\"Author cannot be empty\".to_string()));\n    }\n\n    Ok(())\n}\n\npub fn validate_create_comment(comment: &crate::models::CreateComment) -> Result<(), ApiError> {\n    if comment.author.trim().is_empty() {\n        return Err(ApiError::BadRequest(\"Author cannot be empty\".to_string()));\n    }\n\n    if comment.content.trim().is_empty() {\n        return Err(ApiError::BadRequest(\"Comment cannot be empty\".to_string()));\n    }\n\n    Ok(())\n}\n```\n\n## Step 4: Post Handlers\n\nCreate `src/handlers/posts.rs`:\n\n```rust\nuse axum::{\n    extract::{Path, Query, State},\n    http::StatusCode,\n    Json,\n};\nuse chrono::Utc;\n\nuse crate::{\n    models::{Post, CreatePost, UpdatePost, ListPostsQuery},\n    state::AppState,\n    errors::{ApiError, validate_create_post},\n};\n\npub async fn list_posts(\n    State(state): State<AppState>,\n    Query(query): Query<ListPostsQuery>,\n) -> Json<Vec<Post>> {\n    let posts = state.posts.lock().unwrap();\n\n    let mut filtered: Vec<Post> = posts\n        .iter()\n        .filter(|post| {\n            if let Some(ref tag) = query.tag {\n                post.tags.contains(tag)\n            } else {\n                true\n            }\n        })\n        .cloned()\n        .collect();\n\n    // Sort by created_at descending\n    filtered.sort_by(|a, b| b.created_at.cmp(&a.created_at));\n\n    // Pagination\n    let start = (query.page * query.limit) as usize;\n    let end = start + query.limit as usize;\n\n    let paginated = filtered.into_iter().skip(start).take(query.limit as usize).collect();\n\n    Json(paginated)\n}\n\npub async fn get_post(\n    Path(id): Path<u32>,\n    State(state): State<AppState>,\n) -> Result<Json<Post>, ApiError> {\n    let posts = state.posts.lock().unwrap();\n\n    posts\n        .iter()\n        .find(|p| p.id == id)\n        .cloned()\n        .map(Json)\n        .ok_or(ApiError::NotFound)\n}\n\npub async fn create_post(\n    State(state): State<AppState>,\n    Json(create): Json<CreatePost>,\n) -> Result<(StatusCode, Json<Post>), ApiError> {\n    validate_create_post(&create)?;\n\n    let mut posts = state.posts.lock().unwrap();\n\n    let id = posts.iter().map(|p| p.id).max().unwrap_or(0) + 1;\n\n    let now = Utc::now();\n    let post = Post {\n        id,\n        title: create.title,\n        content: create.content,\n        author: create.author,\n        tags: create.tags,\n        created_at: now,\n        updated_at: now,\n    };\n\n    posts.push(post.clone());\n\n    Ok((StatusCode::CREATED, Json(post)))\n}\n\npub async fn update_post(\n    Path(id): Path<u32>,\n    State(state): State<AppState>,\n    Json(update): Json<UpdatePost>,\n) -> Result<Json<Post>, ApiError> {\n    let mut posts = state.posts.lock().unwrap();\n\n    let post = posts\n        .iter_mut()\n        .find(|p| p.id == id)\n        .ok_or(ApiError::NotFound)?;\n\n    if let Some(title) = update.title {\n        if title.trim().is_empty() {\n            return Err(ApiError::BadRequest(\"Title cannot be empty\".to_string()));\n        }\n        post.title = title;\n    }\n\n    if let Some(content) = update.content {\n        if content.trim().is_empty() {\n            return Err(ApiError::BadRequest(\"Content cannot be empty\".to_string()));\n        }\n        post.content = content;\n    }\n\n    if let Some(tags) = update.tags {\n        post.tags = tags;\n    }\n\n    post.updated_at = Utc::now();\n\n    Ok(Json(post.clone()))\n}\n\npub async fn delete_post(\n    Path(id): Path<u32>,\n    State(state): State<AppState>,\n) -> Result<StatusCode, ApiError> {\n    let mut posts = state.posts.lock().unwrap();\n\n    let index = posts\n        .iter()\n        .position(|p| p.id == id)\n        .ok_or(ApiError::NotFound)?;\n\n    posts.remove(index);\n\n    // Also delete associated comments\n    let mut comments = state.comments.lock().unwrap();\n    comments.retain(|c| c.post_id != id);\n\n    Ok(StatusCode::NO_CONTENT)\n}\n```\n\n## Step 5: Comment Handlers\n\nCreate `src/handlers/comments.rs`:\n\n```rust\nuse axum::{\n    extract::{Path, State},\n    http::StatusCode,\n    Json,\n};\nuse chrono::Utc;\n\nuse crate::{\n    models::{Comment, CreateComment},\n    state::AppState,\n    errors::{ApiError, validate_create_comment},\n};\n\npub async fn list_comments(\n    Path(post_id): Path<u32>,\n    State(state): State<AppState>,\n) -> Result<Json<Vec<Comment>>, ApiError> {\n    // Verify post exists\n    {\n        let posts = state.posts.lock().unwrap();\n        if !posts.iter().any(|p| p.id == post_id) {\n            return Err(ApiError::NotFound);\n        }\n    }\n\n    let comments = state.comments.lock().unwrap();\n\n    let post_comments: Vec<Comment> = comments\n        .iter()\n        .filter(|c| c.post_id == post_id)\n        .cloned()\n        .collect();\n\n    Ok(Json(post_comments))\n}\n\npub async fn create_comment(\n    Path(post_id): Path<u32>,\n    State(state): State<AppState>,\n    Json(create): Json<CreateComment>,\n) -> Result<(StatusCode, Json<Comment>), ApiError> {\n    validate_create_comment(&create)?;\n\n    // Verify post exists\n    {\n        let posts = state.posts.lock().unwrap();\n        if !posts.iter().any(|p| p.id == post_id) {\n            return Err(ApiError::NotFound);\n        }\n    }\n\n    let mut comments = state.comments.lock().unwrap();\n\n    let id = comments.iter().map(|c| c.id).max().unwrap_or(0) + 1;\n\n    let comment = Comment {\n        id,\n        post_id,\n        author: create.author,\n        content: create.content,\n        created_at: Utc::now(),\n    };\n\n    comments.push(comment.clone());\n\n    Ok((StatusCode::CREATED, Json(comment)))\n}\n\npub async fn delete_comment(\n    Path((post_id, comment_id)): Path<(u32, u32)>,\n    State(state): State<AppState>,\n) -> Result<StatusCode, ApiError> {\n    let mut comments = state.comments.lock().unwrap();\n\n    let index = comments\n        .iter()\n        .position(|c| c.id == comment_id && c.post_id == post_id)\n        .ok_or(ApiError::NotFound)?;\n\n    comments.remove(index);\n\n    Ok(StatusCode::NO_CONTENT)\n}\n```\n\n## Step 6: Module Organization\n\nCreate `src/handlers/mod.rs`:\n\n```rust\npub mod posts;\npub mod comments;\n```\n\nUpdate `src/main.rs` to declare modules:\n\n```rust\nmod models;\nmod state;\nmod errors;\nmod handlers;\n\n// (rest of main.rs below)\n```\n\n## Step 7: Main Application\n\nUpdate `src/main.rs`:\n\n```rust\nmod models;\nmod state;\nmod errors;\nmod handlers;\n\nuse axum::{\n    routing::{get, post, put, delete},\n    Router,\n};\n\nuse state::AppState;\nuse handlers::{posts, comments};\n\n#[tokio::main]\nasync fn main() {\n    // Initialize state with sample data\n    let state = AppState::with_sample_data();\n\n    // Build router\n    let app = Router::new()\n        // API info\n        .route(\"/\", get(api_info))\n        // Posts\n        .route(\"/posts\", get(posts::list_posts).post(posts::create_post))\n        .route(\"/posts/{id}\", get(posts::get_post).put(posts::update_post).delete(posts::delete_post))\n        // Comments\n        .route(\"/posts/{post_id}/comments\", get(comments::list_comments).post(comments::create_comment))\n        .route(\"/posts/{post_id}/comments/{comment_id}\", delete(comments::delete_comment))\n        .with_state(state);\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\")\n        .await\n        .unwrap();\n\n    println!(\"ðŸš€ Blog API running on http://localhost:3000\");\n    println!(\"\\nðŸ“– Available endpoints:\");\n    println!(\"   GET    /posts\");\n    println!(\"   GET    /posts?tag=rust&page=0&limit=10\");\n    println!(\"   GET    /posts/{{id}}\");\n    println!(\"   POST   /posts\");\n    println!(\"   PUT    /posts/{{id}}\");\n    println!(\"   DELETE /posts/{{id}}\");\n    println!(\"   GET    /posts/{{post_id}}/comments\");\n    println!(\"   POST   /posts/{{post_id}}/comments\");\n    println!(\"   DELETE /posts/{{post_id}}/comments/{{comment_id}}\");\n\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn api_info() -> &'static str {\n    \"Blog REST API v1.0 - Built with Rust & Axum\"\n}\n```\n\n## Step 8: Testing the API\n\n### List All Posts\n\n```bash\ncurl http://localhost:3000/posts\n```\n\n### List Posts by Tag\n\n```bash\ncurl \"http://localhost:3000/posts?tag=rust\"\n```\n\n### Get Single Post\n\n```bash\ncurl http://localhost:3000/posts/1\n```\n\n### Create Post\n\n```bash\ncurl -X POST http://localhost:3000/posts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"My New Post\",\n    \"content\": \"This is the content of my new post\",\n    \"author\": \"Dave\",\n    \"tags\": [\"rust\", \"tutorial\"]\n  }'\n```\n\n### Update Post\n\n```bash\ncurl -X PUT http://localhost:3000/posts/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"Updated Title\"\n  }'\n```\n\n### Delete Post\n\n```bash\ncurl -X DELETE http://localhost:3000/posts/1\n```\n\n### List Comments\n\n```bash\ncurl http://localhost:3000/posts/1/comments\n```\n\n### Create Comment\n\n```bash\ncurl -X POST http://localhost:3000/posts/1/comments \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"author\": \"Eve\",\n    \"content\": \"Interesting post!\"\n  }'\n```\n\n### Delete Comment\n\n```bash\ncurl -X DELETE http://localhost:3000/posts/1/comments/1\n```\n\n## Challenge Extensions\n\n### 1. Add Search Functionality\n\nAdd `/posts/search?q=rust` endpoint that searches in title and content.\n\n<details>\n<summary>Hint</summary>\n\n```rust\n#[derive(Deserialize)]\nstruct SearchQuery {\n    q: String,\n}\n\nasync fn search_posts(\n    State(state): State<AppState>,\n    Query(query): Query<SearchQuery>,\n) -> Json<Vec<Post>> {\n    let posts = state.posts.lock().unwrap();\n    let query_lower = query.q.to_lowercase();\n\n    let results: Vec<Post> = posts\n        .iter()\n        .filter(|p| {\n            p.title.to_lowercase().contains(&query_lower)\n                || p.content.to_lowercase().contains(&query_lower)\n        })\n        .cloned()\n        .collect();\n\n    Json(results)\n}\n```\n</details>\n\n### 2. Add Statistics Endpoint\n\nCreate `GET /stats` that returns:\n- Total posts\n- Total comments\n- Posts by tag\n\n<details>\n<summary>Hint</summary>\n\n```rust\nuse std::collections::HashMap;\n\n#[derive(Serialize)]\nstruct Stats {\n    total_posts: usize,\n    total_comments: usize,\n    posts_by_tag: HashMap<String, usize>,\n}\n\nasync fn get_stats(State(state): State<AppState>) -> Json<Stats> {\n    let posts = state.posts.lock().unwrap();\n    let comments = state.comments.lock().unwrap();\n\n    let mut posts_by_tag = HashMap::new();\n    for post in posts.iter() {\n        for tag in &post.tags {\n            *posts_by_tag.entry(tag.clone()).or_insert(0) += 1;\n        }\n    }\n\n    Json(Stats {\n        total_posts: posts.len(),\n        total_comments: comments.len(),\n        posts_by_tag,\n    })\n}\n```\n</details>\n\n### 3. Add Sorting\n\nSupport `?sort=created_at&order=desc` query parameters.\n\n### 4. Add Post Likes\n\n- Add `likes: u32` field to Post\n- Create `POST /posts/{id}/like` endpoint\n- Return updated post with incremented likes\n\n## Key Takeaways\n\n- âœ… Organized code into modules (models, state, errors, handlers)\n- âœ… Implemented complete CRUD operations\n- âœ… Added input validation\n- âœ… Proper error handling with custom types\n- âœ… Filtering and pagination\n- âœ… Nested resources (posts and comments)\n- âœ… Type-safe request/response handling\n\n## What You've Built\n\nA production-ready REST API structure with:\n- Clean code organization\n- Proper error handling\n- Input validation\n- Filtering and pagination\n- Nested resources\n- Comprehensive documentation\n\n**Next Module**: Database Integration with SQLx!\n\n---\n\n**Progress**: Module 12 complete! (62/90+ lessons total)\n"
          }
        }
      ]
    },
    {
      "id": "module-13",
      "title": "MODULE 13",
      "description": "Module 13",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-13-01",
          "title": "Module 13: Database Integration",
          "type": "exercise",
          "estimatedMinutes": 9,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 13: Database Integration\n\n# Lesson 1: Database & SQL Fundamentals\n\n## Why Databases?\n\nIn Module 12, we stored data in memory using `Arc<Mutex<Vec<T>>>`. This works for learning, but has problems:\n\nâŒ **Problems with in-memory storage:**\n- Data disappears when server restarts\n- Can't scale beyond one server\n- No querying capabilities\n- Limited by available RAM\n\nâœ… **Benefits of databases:**\n- Persistent storage (data survives restarts)\n- Powerful querying and indexing\n- Concurrent access from multiple servers\n- Transactions and data integrity\n- Can handle massive datasets\n\n## Types of Databases\n\n### Relational Databases (SQL)\n\nStore data in **tables** with **relationships** between them.\n\n**Popular SQL databases:**\n- **PostgreSQL** â­ (What we'll use - powerful, open source)\n- MySQL / MariaDB\n- SQLite (embedded, no server needed)\n\n**When to use:**\n- Structured data with clear relationships\n- Need transactions and data integrity\n- Complex queries and joins\n- Traditional business applications\n\n### NoSQL Databases\n\nStore data in flexible formats (documents, key-value, etc.)\n\n**Popular NoSQL databases:**\n- MongoDB (documents)\n- Redis (key-value, caching)\n- Cassandra (wide-column)\n\n**When to use:**\n- Flexible or changing schema\n- Massive scale horizontal scaling\n- High-speed caching\n- Real-time analytics\n\n## We'll Use PostgreSQL\n\n**Why PostgreSQL?**\n- Most powerful open-source SQL database\n- Excellent Rust support (sqlx)\n- ACID compliant (reliable transactions)\n- JSON support (best of both worlds)\n- Free and widely used\n\n## SQL Basics\n\n**SQL (Structured Query Language)** is how you talk to relational databases.\n\n### Creating Tables\n\n```sql\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    age INTEGER,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n```\n\n**Breaking it down:**\n- `CREATE TABLE users` - Make a new table called \"users\"\n- `id SERIAL PRIMARY KEY` - Auto-incrementing unique identifier\n- `VARCHAR(255)` - String with max length 255\n- `NOT NULL` - Field is required\n- `UNIQUE` - No duplicates allowed\n- `DEFAULT NOW()` - Automatically set current timestamp\n\n### Data Types\n\n| SQL Type | Rust Equivalent | Description |\n|----------|-----------------|-------------|\n| `SERIAL` | `i32` | Auto-incrementing integer |\n| `INTEGER` | `i32` | Whole number |\n| `BIGINT` | `i64` | Large whole number |\n| `VARCHAR(n)` | `String` | Variable-length string |\n| `TEXT` | `String` | Unlimited-length string |\n| `BOOLEAN` | `bool` | True/false |\n| `TIMESTAMP` | `DateTime<Utc>` | Date and time |\n| `JSON` | `serde_json::Value` | JSON data |\n\n### Inserting Data\n\n```sql\nINSERT INTO users (name, email, age)\nVALUES ('Alice', 'alice@example.com', 30);\n\n-- Insert multiple rows\nINSERT INTO users (name, email, age)\nVALUES\n    ('Bob', 'bob@example.com', 25),\n    ('Charlie', 'charlie@example.com', 35);\n```\n\n### Querying Data\n\n```sql\n-- Get all users\nSELECT * FROM users;\n\n-- Get specific columns\nSELECT name, email FROM users;\n\n-- Filter with WHERE\nSELECT * FROM users WHERE age > 25;\n\n-- Order results\nSELECT * FROM users ORDER BY created_at DESC;\n\n-- Limit results\nSELECT * FROM users LIMIT 10;\n\n-- Combine conditions\nSELECT * FROM users\nWHERE age > 20 AND name LIKE 'A%'\nORDER BY name\nLIMIT 5;\n```\n\n### Updating Data\n\n```sql\nUPDATE users\nSET age = 31, email = 'alice.new@example.com'\nWHERE id = 1;\n\n-- Update multiple rows\nUPDATE users\nSET age = age + 1\nWHERE age < 30;\n```\n\n### Deleting Data\n\n```sql\nDELETE FROM users WHERE id = 1;\n\n-- Delete all rows (careful!)\nDELETE FROM users WHERE age > 100;\n```\n\n## Relationships\n\nTables can relate to each other.\n\n### One-to-Many\n\nOne user can have many posts:\n\n```sql\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id),\n    title VARCHAR(255) NOT NULL,\n    content TEXT NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n```\n\n**`REFERENCES users(id)`** creates a **foreign key** - links to users table.\n\n### Querying Related Data (JOIN)\n\n```sql\n-- Get posts with user information\nSELECT posts.*, users.name as author_name\nFROM posts\nJOIN users ON posts.user_id = users.id\nWHERE users.name = 'Alice';\n```\n\n### Many-to-Many\n\nPosts can have many tags, tags can be on many posts:\n\n```sql\nCREATE TABLE tags (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL\n);\n\nCREATE TABLE post_tags (\n    post_id INTEGER REFERENCES posts(id),\n    tag_id INTEGER REFERENCES tags(id),\n    PRIMARY KEY (post_id, tag_id)\n);\n```\n\n## Primary Keys & Indexes\n\n### Primary Key\n\n**Uniquely identifies each row**, usually an auto-incrementing `id`.\n\n```sql\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,  -- Auto-incrementing primary key\n    name VARCHAR(255) NOT NULL\n);\n```\n\n### Indexes\n\nMake queries faster by creating an index:\n\n```sql\n-- Speed up lookups by email\nCREATE INDEX idx_users_email ON users(email);\n\n-- Speed up filtering by age\nCREATE INDEX idx_users_age ON users(age);\n```\n\n**When to use indexes:**\n- Columns used in WHERE clauses\n- Columns used in JOIN conditions\n- Columns used for sorting (ORDER BY)\n\n**Trade-off:** Indexes speed up reads but slow down writes.\n\n## Constraints\n\nEnforce data rules at the database level:\n\n```sql\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,  -- Cannot be NULL\n    price DECIMAL(10, 2) CHECK (price > 0),  -- Must be positive\n    sku VARCHAR(50) UNIQUE,  -- No duplicates\n    category_id INTEGER REFERENCES categories(id)  -- Must exist in categories\n);\n```\n\n### Types of Constraints\n\n- `NOT NULL` - Value required\n- `UNIQUE` - No duplicates\n- `CHECK` - Custom validation\n- `FOREIGN KEY` - Must reference existing row\n- `DEFAULT` - Set default value\n\n## Transactions\n\n**Transactions** ensure multiple operations succeed or fail together:\n\n```sql\nBEGIN;\n\nINSERT INTO accounts (name, balance) VALUES ('Alice', 1000);\nINSERT INTO accounts (name, balance) VALUES ('Bob', 500);\n\nUPDATE accounts SET balance = balance - 100 WHERE name = 'Alice';\nUPDATE accounts SET balance = balance + 100 WHERE name = 'Bob';\n\nCOMMIT;  -- or ROLLBACK to undo\n```\n\n**ACID Properties:**\n- **Atomic**: All or nothing\n- **Consistent**: Database stays valid\n- **Isolated**: Transactions don't interfere\n- **Durable**: Changes are permanent\n\n## Practice Exercises\n\n### Exercise 1: Design a Blog Schema\n\nCreate tables for a blog with:\n- Users (id, username, email, password_hash, created_at)\n- Posts (id, user_id, title, content, published, created_at, updated_at)\n- Comments (id, post_id, user_id, content, created_at)\n\n<details>\n<summary>Solution</summary>\n\n```sql\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT NOT NULL,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT NOW(),\n    updated_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    post_id INTEGER NOT NULL REFERENCES posts(id) ON DELETE CASCADE,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    content TEXT NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Indexes for common queries\nCREATE INDEX idx_posts_user_id ON posts(user_id);\nCREATE INDEX idx_posts_published ON posts(published);\nCREATE INDEX idx_comments_post_id ON comments(post_id);\n```\n</details>\n\n### Exercise 2: Write Queries\n\nGiven the blog schema above, write SQL for:\n\n1. Get all published posts with author name\n2. Get all comments for post ID 5 with commenter names\n3. Count posts per user\n4. Get the 10 most recent published posts\n\n<details>\n<summary>Solutions</summary>\n\n```sql\n-- 1. Published posts with author name\nSELECT posts.*, users.username as author\nFROM posts\nJOIN users ON posts.user_id = users.id\nWHERE posts.published = TRUE\nORDER BY posts.created_at DESC;\n\n-- 2. Comments for post 5 with commenter names\nSELECT comments.*, users.username as commenter\nFROM comments\nJOIN users ON comments.user_id = users.id\nWHERE comments.post_id = 5\nORDER BY comments.created_at ASC;\n\n-- 3. Count posts per user\nSELECT users.username, COUNT(posts.id) as post_count\nFROM users\nLEFT JOIN posts ON users.id = posts.user_id\nGROUP BY users.id, users.username\nORDER BY post_count DESC;\n\n-- 4. 10 most recent published posts\nSELECT * FROM posts\nWHERE published = TRUE\nORDER BY created_at DESC\nLIMIT 10;\n```\n</details>\n\n### Exercise 3: E-commerce Schema\n\nDesign tables for an e-commerce site with:\n- Products (id, name, description, price, stock)\n- Orders (id, user_id, status, total, created_at)\n- Order Items (order_id, product_id, quantity, price_at_purchase)\n\nInclude appropriate constraints and foreign keys.\n\n<details>\n<summary>Solution</summary>\n\n```sql\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    description TEXT,\n    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),\n    stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id),\n    status VARCHAR(20) NOT NULL DEFAULT 'pending',\n    total DECIMAL(10, 2) NOT NULL CHECK (total >= 0),\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE TABLE order_items (\n    id SERIAL PRIMARY KEY,\n    order_id INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,\n    product_id INTEGER NOT NULL REFERENCES products(id),\n    quantity INTEGER NOT NULL CHECK (quantity > 0),\n    price_at_purchase DECIMAL(10, 2) NOT NULL,\n    UNIQUE(order_id, product_id)\n);\n\n-- Indexes\nCREATE INDEX idx_orders_user_id ON orders(user_id);\nCREATE INDEX idx_orders_status ON orders(status);\nCREATE INDEX idx_order_items_order_id ON order_items(order_id);\n```\n</details>\n\n## Installing PostgreSQL\n\n### macOS\n\n```bash\nbrew install postgresql@15\nbrew services start postgresql@15\n```\n\n### Linux (Ubuntu/Debian)\n\n```bash\nsudo apt update\nsudo apt install postgresql postgresql-contrib\nsudo systemctl start postgresql\n```\n\n### Windows\n\nDownload installer from [postgresql.org](https://www.postgresql.org/download/windows/)\n\n### Docker (All platforms)\n\n```bash\ndocker run --name postgres \\\n  -e POSTGRES_PASSWORD=mysecretpassword \\\n  -p 5432:5432 \\\n  -d postgres:15\n```\n\n### Verify Installation\n\n```bash\npsql --version\n# Should show: psql (PostgreSQL) 15.x\n```\n\n## Connecting to PostgreSQL\n\n### Using psql (command-line client)\n\n```bash\n# Connect to default database\npsql -U postgres\n\n# Create a database\nCREATE DATABASE blog_dev;\n\n# Connect to your database\n\\c blog_dev\n\n# List tables\n\\dt\n\n# Describe table\n\\d users\n\n# Quit\n\\q\n```\n\n### GUI Tools\n\n- **pgAdmin** - Official GUI tool\n- **DBeaver** - Universal database tool\n- **TablePlus** - Modern, clean interface (Mac/Windows)\n- **Postico** - Mac only\n\n## Database URL Format\n\nRust applications connect using a **connection string**:\n\n```\npostgresql://username:password@host:port/database\n```\n\n**Example:**\n```\npostgresql://postgres:mypassword@localhost:5432/blog_dev\n```\n\n**Parts:**\n- `postgresql://` - Database type\n- `postgres` - Username\n- `mypassword` - Password\n- `localhost` - Server address\n- `5432` - Port (PostgreSQL default)\n- `blog_dev` - Database name\n\n## Key Takeaways\n\n- âœ… Databases provide persistent, queryable storage\n- âœ… PostgreSQL is a powerful, open-source SQL database\n- âœ… Tables store structured data with defined schemas\n- âœ… SQL is used to query and manipulate data\n- âœ… Foreign keys create relationships between tables\n- âœ… Indexes speed up queries\n- âœ… Transactions ensure data consistency\n- âœ… Constraints enforce data integrity\n\n**Next**: Setting up SQLx and connecting to PostgreSQL from Rust!\n\n---\n\n**Progress**: Module 13, Lesson 1 complete (63/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-13-02",
          "title": "Module 13: Database Integration",
          "type": "project",
          "estimatedMinutes": 9,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 13: Database Integration\n\n# Lesson 2: Setting Up SQLx\n\n## What is SQLx?\n\n**SQLx** is a Rust SQL toolkit that provides:\n- Async database access (works with tokio)\n- Compile-time checked queries\n- Connection pooling\n- Support for PostgreSQL, MySQL, SQLite\n- Type-safe query results\n\n**Latest version: 0.8.6** (as of November 2025)\n\n## Project Setup\n\n### Create New Project\n\n```bash\ncargo new blog_db\ncd blog_db\n```\n\n### Add Dependencies\n\nEdit `Cargo.toml`:\n\n```toml\n[package]\nname = \"blog_db\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ntokio = { version = \"1.x\", features = [\"full\"] }\nsqlx = { version = \"0.8.x\", features = [\"runtime-tokio\", \"postgres\", \"chrono\", \"uuid\"] }\nchrono = { version = \"0.4\", features = [\"serde\"] }\nuuid = { version = \"1.0\", features = [\"v4\", \"serde\"] }\ndotenvy = \"0.15\"\n```\n\n**Dependency features explained:**\n- `runtime-tokio` - Use tokio async runtime\n- `postgres` - PostgreSQL support\n- `chrono` - Date/time types\n- `uuid` - UUID support for primary keys\n- `dotenvy` - Load environment variables from .env file\n\n### Install sqlx-cli\n\nThe sqlx command-line tool manages migrations:\n\n```bash\ncargo install sqlx-cli --no-default-features --features postgres\n```\n\nVerify installation:\n\n```bash\nsqlx --version\n```\n\n## Database Setup\n\n### Create Database\n\n```bash\n# Using psql\ncreatedb blog_dev\n\n# Or using sqlx-cli\nsqlx database create --database-url postgresql://postgres:password@localhost/blog_dev\n```\n\n### Create .env File\n\nCreate `.env` in your project root:\n\n```env\nDATABASE_URL=postgresql://postgres:your_password@localhost:5432/blog_dev\n```\n\n**Important:** Add `.env` to `.gitignore` to avoid committing passwords!\n\n```.gitignore\n/target\n.env\n```\n\n## Your First Connection\n\nCreate `src/main.rs`:\n\n```rust\nuse sqlx::postgres::PgPoolOptions;\nuse std::env;\n\n#[tokio::main]\nasync fn main() -> Result<(), sqlx::Error> {\n    // Load .env file\n    dotenvy::dotenv().ok();\n\n    // Get database URL from environment\n    let database_url = env::var(\"DATABASE_URL\")\n        .expect(\"DATABASE_URL must be set in .env file\");\n\n    // Create connection pool\n    let pool = PgPoolOptions::new()\n        .max_connections(5)\n        .connect(&database_url)\n        .await?;\n\n    println!(\"âœ… Connected to database!\");\n\n    // Test query\n    let result: (i64,) = sqlx::query_as(\"SELECT $1 as value\")\n        .bind(42_i64)\n        .fetch_one(&pool)\n        .await?;\n\n    println!(\"Test query result: {}\", result.0);\n\n    Ok(())\n}\n```\n\n**Run it:**\n\n```bash\ncargo run\n# Output:\n# âœ… Connected to database!\n# Test query result: 42\n```\n\n## Understanding Connection Pools\n\n```rust\nlet pool = PgPoolOptions::new()\n    .max_connections(5)\n    .connect(&database_url)\n    .await?;\n```\n\n**What is a connection pool?**\n- Maintains a pool of reusable database connections\n- Connections are expensive to create\n- Pool reuses connections instead of creating new ones\n\n**Configuration options:**\n```rust\nlet pool = PgPoolOptions::new()\n    .max_connections(10)           // Max concurrent connections\n    .min_connections(2)            // Keep at least 2 connections open\n    .acquire_timeout(Duration::from_secs(30))  // Wait max 30s for connection\n    .connect(&database_url)\n    .await?;\n```\n\n## Database Migrations\n\nMigrations are version-controlled schema changes.\n\n### Initialize Migrations\n\n```bash\nsqlx migrate add create_users_table\n```\n\nThis creates: `migrations/TIMESTAMP_create_users_table.sql`\n\n### Write Migration\n\nEdit the generated file:\n\n```sql\n-- migrations/20251113_create_users_table.sql\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Add index for email lookups\nCREATE INDEX idx_users_email ON users(email);\n```\n\n### Run Migration\n\n```bash\nsqlx migrate run\n```\n\nYou should see:\n```\nApplied 20251113/create_users_table (...)\n```\n\n### Check Migration Status\n\n```bash\nsqlx migrate info\n```\n\n### Revert Migration (if needed)\n\n```bash\nsqlx migrate revert\n```\n\n## Basic Queries\n\n### Insert Data\n\n```rust\nuse sqlx::PgPool;\n\nasync fn create_user(\n    pool: &PgPool,\n    username: &str,\n    email: &str,\n    password_hash: &str,\n) -> Result<i32, sqlx::Error> {\n    let result = sqlx::query!(\n        \"INSERT INTO users (username, email, password_hash) VALUES ($1, $2, $3) RETURNING id\",\n        username,\n        email,\n        password_hash\n    )\n    .fetch_one(pool)\n    .await?;\n\n    Ok(result.id)\n}\n```\n\n**The `query!` macro:**\n- Validates SQL at compile time!\n- Checks types match database schema\n- Auto-generates type-safe result structs\n\n### Select Data\n\n```rust\n#[derive(Debug)]\nstruct User {\n    id: i32,\n    username: String,\n    email: String,\n    password_hash: String,\n    created_at: chrono::NaiveDateTime,\n}\n\nasync fn get_user_by_email(\n    pool: &PgPool,\n    email: &str,\n) -> Result<Option<User>, sqlx::Error> {\n    let user = sqlx::query_as!(\n        User,\n        \"SELECT id, username, email, password_hash, created_at FROM users WHERE email = $1\",\n        email\n    )\n    .fetch_optional(pool)\n    .await?;\n\n    Ok(user)\n}\n```\n\n### Update Data\n\n```rust\nasync fn update_username(\n    pool: &PgPool,\n    user_id: i32,\n    new_username: &str,\n) -> Result<(), sqlx::Error> {\n    sqlx::query!(\n        \"UPDATE users SET username = $1 WHERE id = $2\",\n        new_username,\n        user_id\n    )\n    .execute(pool)\n    .await?;\n\n    Ok(())\n}\n```\n\n### Delete Data\n\n```rust\nasync fn delete_user(\n    pool: &PgPool,\n    user_id: i32,\n) -> Result<u64, sqlx::Error> {\n    let result = sqlx::query!(\n        \"DELETE FROM users WHERE id = $1\",\n        user_id\n    )\n    .execute(pool)\n    .await?;\n\n    Ok(result.rows_affected())\n}\n```\n\n## Complete Example\n\n```rust\nuse sqlx::postgres::PgPoolOptions;\nuse sqlx::PgPool;\nuse std::env;\n\n#[derive(Debug)]\nstruct User {\n    id: i32,\n    username: String,\n    email: String,\n    created_at: chrono::NaiveDateTime,\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), sqlx::Error> {\n    dotenvy::dotenv().ok();\n\n    let database_url = env::var(\"DATABASE_URL\")\n        .expect(\"DATABASE_URL must be set\");\n\n    let pool = PgPoolOptions::new()\n        .max_connections(5)\n        .connect(&database_url)\n        .await?;\n\n    println!(\"âœ… Connected to database!\");\n\n    // Create a user\n    let user_id = create_user(&pool, \"alice\", \"alice@example.com\", \"hashed_password\").await?;\n    println!(\"Created user with ID: {}\", user_id);\n\n    // Find user by email\n    if let Some(user) = get_user_by_email(&pool, \"alice@example.com\").await? {\n        println!(\"Found user: {:?}\", user);\n    }\n\n    // Update username\n    update_username(&pool, user_id, \"alice_updated\").await?;\n    println!(\"Updated username\");\n\n    // List all users\n    let users = list_users(&pool).await?;\n    println!(\"All users: {:?}\", users);\n\n    Ok(())\n}\n\nasync fn create_user(\n    pool: &PgPool,\n    username: &str,\n    email: &str,\n    password_hash: &str,\n) -> Result<i32, sqlx::Error> {\n    let result = sqlx::query!(\n        \"INSERT INTO users (username, email, password_hash) VALUES ($1, $2, $3) RETURNING id\",\n        username,\n        email,\n        password_hash\n    )\n    .fetch_one(pool)\n    .await?;\n\n    Ok(result.id)\n}\n\nasync fn get_user_by_email(\n    pool: &PgPool,\n    email: &str,\n) -> Result<Option<User>, sqlx::Error> {\n    let user = sqlx::query_as!(\n        User,\n        r#\"\n        SELECT id, username, email, created_at\n        FROM users\n        WHERE email = $1\n        \"#,\n        email\n    )\n    .fetch_optional(pool)\n    .await?;\n\n    Ok(user)\n}\n\nasync fn update_username(\n    pool: &PgPool,\n    user_id: i32,\n    new_username: &str,\n) -> Result<(), sqlx::Error> {\n    sqlx::query!(\n        \"UPDATE users SET username = $1 WHERE id = $2\",\n        new_username,\n        user_id\n    )\n    .execute(pool)\n    .await?;\n\n    Ok(())\n}\n\nasync fn list_users(pool: &PgPool) -> Result<Vec<User>, sqlx::Error> {\n    let users = sqlx::query_as!(\n        User,\n        \"SELECT id, username, email, created_at FROM users ORDER BY created_at DESC\"\n    )\n    .fetch_all(pool)\n    .await?;\n\n    Ok(users)\n}\n```\n\n## Query Types\n\n### fetch_one - Expect exactly one row\n\n```rust\nlet user = sqlx::query_as!(User, \"SELECT * FROM users WHERE id = $1\", id)\n    .fetch_one(&pool)  // Returns Error if not found or multiple rows\n    .await?;\n```\n\n### fetch_optional - Zero or one row\n\n```rust\nlet maybe_user = sqlx::query_as!(User, \"SELECT * FROM users WHERE email = $1\", email)\n    .fetch_optional(&pool)  // Returns Option<User>\n    .await?;\n```\n\n### fetch_all - All matching rows\n\n```rust\nlet users = sqlx::query_as!(User, \"SELECT * FROM users\")\n    .fetch_all(&pool)  // Returns Vec<User>\n    .await?;\n```\n\n### execute - Don't return rows\n\n```rust\nlet result = sqlx::query!(\"DELETE FROM users WHERE id = $1\", id)\n    .execute(&pool)  // Returns PgQueryResult with rows_affected()\n    .await?;\n\nprintln!(\"Deleted {} rows\", result.rows_affected());\n```\n\n## Handling NULL Values\n\n```sql\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    content TEXT NOT NULL,\n    published_at TIMESTAMP  -- Can be NULL\n);\n```\n\n```rust\n#[derive(Debug)]\nstruct Post {\n    id: i32,\n    title: String,\n    content: String,\n    published_at: Option<chrono::NaiveDateTime>,  // NULL becomes None\n}\n```\n\n## Practice Exercises\n\n### Exercise 1: Posts Table\n\nCreate a migration for a posts table with:\n- id (serial primary key)\n- user_id (foreign key to users)\n- title (varchar 255, not null)\n- content (text, not null)\n- published (boolean, default false)\n- created_at (timestamp, default now)\n\n<details>\n<summary>Solution</summary>\n\n```bash\nsqlx migrate add create_posts_table\n```\n\n```sql\n-- migrations/TIMESTAMP_create_posts_table.sql\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT NOT NULL,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE INDEX idx_posts_user_id ON posts(user_id);\nCREATE INDEX idx_posts_published ON posts(published);\n```\n\n```bash\nsqlx migrate run\n```\n</details>\n\n### Exercise 2: CRUD Functions for Posts\n\nImplement these functions:\n\n```rust\nasync fn create_post(pool: &PgPool, user_id: i32, title: &str, content: &str) -> Result<i32, sqlx::Error>;\nasync fn get_post(pool: &PgPool, post_id: i32) -> Result<Option<Post>, sqlx::Error>;\nasync fn list_user_posts(pool: &PgPool, user_id: i32) -> Result<Vec<Post>, sqlx::Error>;\nasync fn publish_post(pool: &PgPool, post_id: i32) -> Result<(), sqlx::Error>;\nasync fn delete_post(pool: &PgPool, post_id: i32) -> Result<u64, sqlx::Error>;\n```\n\n<details>\n<summary>Solution</summary>\n\n```rust\n#[derive(Debug)]\nstruct Post {\n    id: i32,\n    user_id: i32,\n    title: String,\n    content: String,\n    published: bool,\n    created_at: chrono::NaiveDateTime,\n}\n\nasync fn create_post(\n    pool: &PgPool,\n    user_id: i32,\n    title: &str,\n    content: &str,\n) -> Result<i32, sqlx::Error> {\n    let result = sqlx::query!(\n        \"INSERT INTO posts (user_id, title, content) VALUES ($1, $2, $3) RETURNING id\",\n        user_id,\n        title,\n        content\n    )\n    .fetch_one(pool)\n    .await?;\n\n    Ok(result.id)\n}\n\nasync fn get_post(\n    pool: &PgPool,\n    post_id: i32,\n) -> Result<Option<Post>, sqlx::Error> {\n    let post = sqlx::query_as!(\n        Post,\n        \"SELECT id, user_id, title, content, published, created_at FROM posts WHERE id = $1\",\n        post_id\n    )\n    .fetch_optional(pool)\n    .await?;\n\n    Ok(post)\n}\n\nasync fn list_user_posts(\n    pool: &PgPool,\n    user_id: i32,\n) -> Result<Vec<Post>, sqlx::Error> {\n    let posts = sqlx::query_as!(\n        Post,\n        \"SELECT id, user_id, title, content, published, created_at FROM posts WHERE user_id = $1 ORDER BY created_at DESC\",\n        user_id\n    )\n    .fetch_all(pool)\n    .await?;\n\n    Ok(posts)\n}\n\nasync fn publish_post(\n    pool: &PgPool,\n    post_id: i32,\n) -> Result<(), sqlx::Error> {\n    sqlx::query!(\n        \"UPDATE posts SET published = TRUE WHERE id = $1\",\n        post_id\n    )\n    .execute(pool)\n    .await?;\n\n    Ok(())\n}\n\nasync fn delete_post(\n    pool: &PgPool,\n    post_id: i32,\n) -> Result<u64, sqlx::Error> {\n    let result = sqlx::query!(\n        \"DELETE FROM posts WHERE id = $1\",\n        post_id\n    )\n    .execute(pool)\n    .await?;\n\n    Ok(result.rows_affected())\n}\n```\n</details>\n\n## Common Issues & Solutions\n\n### Issue: \"no DATABASE_URL environment variable\"\n\n**Solution:** Create `.env` file with your database URL\n\n### Issue: \"error returned from database: relation \\\"users\\\" does not exist\"\n\n**Solution:** Run migrations: `sqlx migrate run`\n\n### Issue: Compile-time verification fails\n\n**Solution:** Make sure database is running and `DATABASE_URL` is set during build\n\nOr use offline mode:\n```bash\ncargo sqlx prepare  # Generate sqlx-data.json\ncargo build --offline\n```\n\n### Issue: \"password authentication failed\"\n\n**Solution:** Check your DATABASE_URL username/password\n\n## Key Takeaways\n\n- âœ… SQLx provides async, type-safe database access\n- âœ… Connection pools manage database connections efficiently\n- âœ… Migrations version-control schema changes\n- âœ… `query!` macro validates SQL at compile time\n- âœ… Use `fetch_one`, `fetch_optional`, `fetch_all` based on expected rows\n- âœ… SQLx supports PostgreSQL, MySQL, and SQLite\n- âœ… Always use `.env` for sensitive configuration\n\n**Next**: Integrating SQLx with Axum for database-backed APIs!\n\n---\n\n**Progress**: Module 13, Lesson 2 complete (64/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-13-03",
          "title": "Module 13: Database Integration",
          "type": "project",
          "estimatedMinutes": 9,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 13: Database Integration\n\n# Lesson 3: Axum + SQLx Integration\n\n## Combining Web API + Database\n\nNow let's build a real API backed by PostgreSQL instead of in-memory storage!\n\n## Project Setup\n\n```bash\ncargo new blog_api_db\ncd blog_api_db\n```\n\n### Dependencies\n\n```toml\n[package]\nname = \"blog_api_db\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\naxum = \"0.8.x\"\ntokio = { version = \"1.x\", features = [\"full\"] }\nsqlx = { version = \"0.8.x\", features = [\"runtime-tokio\", \"postgres\", \"chrono\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nchrono = { version = \"0.4\", features = [\"serde\"] }\ndotenvy = \"0.15\"\n```\n\n### Database Setup\n\nCreate `.env`:\n\n```env\nDATABASE_URL=postgresql://postgres:password@localhost:5432/blog_dev\n```\n\n## Database Schema\n\nCreate migrations:\n\n```bash\nsqlx migrate add create_schema\n```\n\nEdit `migrations/TIMESTAMP_create_schema.sql`:\n\n```sql\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    content TEXT NOT NULL,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT NOW(),\n    updated_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE INDEX idx_posts_user_id ON posts(user_id);\nCREATE INDEX idx_posts_published ON posts(published);\n\n-- Insert sample data\nINSERT INTO users (username, email) VALUES\n    ('alice', 'alice@example.com'),\n    ('bob', 'bob@example.com');\n\nINSERT INTO posts (user_id, title, content, published) VALUES\n    (1, 'Getting Started with Rust', 'Rust is amazing...', TRUE),\n    (1, 'Building Web APIs', 'Let me show you how...', TRUE),\n    (2, 'My First Post', 'Hello world!', FALSE);\n```\n\nRun migration:\n\n```bash\nsqlx migrate run\n```\n\n## Sharing Database Pool in Axum\n\nThe key is passing the `PgPool` to handlers using Axum's `State`:\n\n```rust\nuse axum::{\n    Router,\n    extract::State,\n};\nuse sqlx::PgPool;\n\n#[tokio::main]\nasync fn main() {\n    let pool = /* create pool */;\n\n    let app = Router::new()\n        .route(\"/users\", get(list_users))\n        .with_state(pool);  // Share pool with all handlers\n\n    // ...\n}\n\nasync fn list_users(\n    State(pool): State<PgPool>,  // Extract pool in handler\n) -> Json<Vec<User>> {\n    // Use pool to query database\n}\n```\n\n## Complete Example\n\n### Project Structure\n\n```\nsrc/\nâ”œâ”€â”€ main.rs\nâ”œâ”€â”€ models.rs\nâ”œâ”€â”€ handlers/\nâ”‚   â”œâ”€â”€ mod.rs\nâ”‚   â”œâ”€â”€ users.rs\nâ”‚   â””â”€â”€ posts.rs\n```\n\n### src/models.rs\n\n```rust\nuse serde::{Deserialize, Serialize};\nuse chrono::NaiveDateTime;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct User {\n    pub id: i32,\n    pub username: String,\n    pub email: String,\n    pub created_at: NaiveDateTime,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Post {\n    pub id: i32,\n    pub user_id: i32,\n    pub title: String,\n    pub content: String,\n    pub published: bool,\n    pub created_at: NaiveDateTime,\n    pub updated_at: NaiveDateTime,\n}\n\n#[derive(Debug, Deserialize)]\npub struct CreatePost {\n    pub user_id: i32,\n    pub title: String,\n    pub content: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct UpdatePost {\n    pub title: Option<String>,\n    pub content: Option<String>,\n    pub published: Option<bool>,\n}\n```\n\n### src/handlers/users.rs\n\n```rust\nuse axum::{\n    extract::State,\n    Json,\n};\nuse sqlx::PgPool;\n\nuse crate::models::User;\n\npub async fn list_users(\n    State(pool): State<PgPool>,\n) -> Result<Json<Vec<User>>, (axum::http::StatusCode, String)> {\n    let users = sqlx::query_as!(\n        User,\n        \"SELECT id, username, email, created_at FROM users ORDER BY created_at DESC\"\n    )\n    .fetch_all(&pool)\n    .await\n    .map_err(internal_error)?;\n\n    Ok(Json(users))\n}\n\npub async fn get_user(\n    State(pool): State<PgPool>,\n    axum::extract::Path(id): axum::extract::Path<i32>,\n) -> Result<Json<User>, (axum::http::StatusCode, String)> {\n    let user = sqlx::query_as!(\n        User,\n        \"SELECT id, username, email, created_at FROM users WHERE id = $1\",\n        id\n    )\n    .fetch_optional(&pool)\n    .await\n    .map_err(internal_error)?\n    .ok_or_else(|| {\n        (\n            axum::http::StatusCode::NOT_FOUND,\n            \"User not found\".to_string(),\n        )\n    })?;\n\n    Ok(Json(user))\n}\n\nfn internal_error<E>(err: E) -> (axum::http::StatusCode, String)\nwhere\n    E: std::error::Error,\n{\n    (axum::http::StatusCode::INTERNAL_SERVER_ERROR, err.to_string())\n}\n```\n\n### src/handlers/posts.rs\n\n```rust\nuse axum::{\n    extract::{Path, Query, State},\n    http::StatusCode,\n    Json,\n};\nuse serde::Deserialize;\nuse sqlx::PgPool;\n\nuse crate::models::{Post, CreatePost, UpdatePost};\n\n#[derive(Deserialize)]\npub struct ListQuery {\n    #[serde(default)]\n    pub published: Option<bool>,\n}\n\npub async fn list_posts(\n    State(pool): State<PgPool>,\n    Query(query): Query<ListQuery>,\n) -> Result<Json<Vec<Post>>, (StatusCode, String)> {\n    let posts = if let Some(published) = query.published {\n        sqlx::query_as!(\n            Post,\n            \"SELECT * FROM posts WHERE published = $1 ORDER BY created_at DESC\",\n            published\n        )\n        .fetch_all(&pool)\n        .await\n    } else {\n        sqlx::query_as!(\n            Post,\n            \"SELECT * FROM posts ORDER BY created_at DESC\"\n        )\n        .fetch_all(&pool)\n        .await\n    }\n    .map_err(internal_error)?;\n\n    Ok(Json(posts))\n}\n\npub async fn get_post(\n    State(pool): State<PgPool>,\n    Path(id): Path<i32>,\n) -> Result<Json<Post>, (StatusCode, String)> {\n    let post = sqlx::query_as!(\n        Post,\n        \"SELECT * FROM posts WHERE id = $1\",\n        id\n    )\n    .fetch_optional(&pool)\n    .await\n    .map_err(internal_error)?\n    .ok_or_else(|| (StatusCode::NOT_FOUND, \"Post not found\".to_string()))?;\n\n    Ok(Json(post))\n}\n\npub async fn create_post(\n    State(pool): State<PgPool>,\n    Json(create): Json<CreatePost>,\n) -> Result<(StatusCode, Json<Post>), (StatusCode, String)> {\n    // Verify user exists\n    let user_exists = sqlx::query!(\"SELECT id FROM users WHERE id = $1\", create.user_id)\n        .fetch_optional(&pool)\n        .await\n        .map_err(internal_error)?\n        .is_some();\n\n    if !user_exists {\n        return Err((StatusCode::BAD_REQUEST, \"User does not exist\".to_string()));\n    }\n\n    let post = sqlx::query_as!(\n        Post,\n        r#\"\n        INSERT INTO posts (user_id, title, content)\n        VALUES ($1, $2, $3)\n        RETURNING id, user_id, title, content, published, created_at, updated_at\n        \"#,\n        create.user_id,\n        create.title,\n        create.content\n    )\n    .fetch_one(&pool)\n    .await\n    .map_err(internal_error)?;\n\n    Ok((StatusCode::CREATED, Json(post)))\n}\n\npub async fn update_post(\n    State(pool): State<PgPool>,\n    Path(id): Path<i32>,\n    Json(update): Json<UpdatePost>,\n) -> Result<Json<Post>, (StatusCode, String)> {\n    // Get existing post\n    let mut post = sqlx::query_as!(\n        Post,\n        \"SELECT * FROM posts WHERE id = $1\",\n        id\n    )\n    .fetch_optional(&pool)\n    .await\n    .map_err(internal_error)?\n    .ok_or_else(|| (StatusCode::NOT_FOUND, \"Post not found\".to_string()))?;\n\n    // Apply updates\n    if let Some(title) = update.title {\n        post.title = title;\n    }\n    if let Some(content) = update.content {\n        post.content = content;\n    }\n    if let Some(published) = update.published {\n        post.published = published;\n    }\n\n    // Save to database\n    let updated_post = sqlx::query_as!(\n        Post,\n        r#\"\n        UPDATE posts\n        SET title = $1, content = $2, published = $3, updated_at = NOW()\n        WHERE id = $4\n        RETURNING id, user_id, title, content, published, created_at, updated_at\n        \"#,\n        post.title,\n        post.content,\n        post.published,\n        id\n    )\n    .fetch_one(&pool)\n    .await\n    .map_err(internal_error)?;\n\n    Ok(Json(updated_post))\n}\n\npub async fn delete_post(\n    State(pool): State<PgPool>,\n    Path(id): Path<i32>,\n) -> Result<StatusCode, (StatusCode, String)> {\n    let result = sqlx::query!(\"DELETE FROM posts WHERE id = $1\", id)\n        .execute(&pool)\n        .await\n        .map_err(internal_error)?;\n\n    if result.rows_affected() == 0 {\n        return Err((StatusCode::NOT_FOUND, \"Post not found\".to_string()));\n    }\n\n    Ok(StatusCode::NO_CONTENT)\n}\n\npub async fn list_user_posts(\n    State(pool): State<PgPool>,\n    Path(user_id): Path<i32>,\n) -> Result<Json<Vec<Post>>, (StatusCode, String)> {\n    let posts = sqlx::query_as!(\n        Post,\n        \"SELECT * FROM posts WHERE user_id = $1 ORDER BY created_at DESC\",\n        user_id\n    )\n    .fetch_all(&pool)\n    .await\n    .map_err(internal_error)?;\n\n    Ok(Json(posts))\n}\n\nfn internal_error<E>(err: E) -> (StatusCode, String)\nwhere\n    E: std::error::Error,\n{\n    (StatusCode::INTERNAL_SERVER_ERROR, err.to_string())\n}\n```\n\n### src/handlers/mod.rs\n\n```rust\npub mod users;\npub mod posts;\n```\n\n### src/main.rs\n\n```rust\nmod models;\nmod handlers;\n\nuse axum::{\n    routing::{get, post, put, delete},\n    Router,\n};\nuse sqlx::postgres::PgPoolOptions;\nuse std::env;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Load environment variables\n    dotenvy::dotenv().ok();\n\n    // Get database URL\n    let database_url = env::var(\"DATABASE_URL\")?;\n\n    // Create connection pool\n    let pool = PgPoolOptions::new()\n        .max_connections(5)\n        .connect(&database_url)\n        .await?;\n\n    println!(\"âœ… Connected to database\");\n\n    // Build router\n    let app = Router::new()\n        .route(\"/\", get(|| async { \"Blog API with Database\" }))\n        // User routes\n        .route(\"/users\", get(handlers::users::list_users))\n        .route(\"/users/{id}\", get(handlers::users::get_user))\n        // Post routes\n        .route(\"/posts\", get(handlers::posts::list_posts).post(handlers::posts::create_post))\n        .route(\"/posts/{id}\",\n            get(handlers::posts::get_post)\n            .put(handlers::posts::update_post)\n            .delete(handlers::posts::delete_post)\n        )\n        .route(\"/users/{user_id}/posts\", get(handlers::posts::list_user_posts))\n        .with_state(pool);\n\n    // Start server\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await?;\n\n    println!(\"ðŸš€ Server running on http://localhost:3000\");\n    println!(\"\\nðŸ“š Endpoints:\");\n    println!(\"  GET    /users\");\n    println!(\"  GET    /users/{{id}}\");\n    println!(\"  GET    /posts\");\n    println!(\"  GET    /posts?published=true\");\n    println!(\"  GET    /posts/{{id}}\");\n    println!(\"  POST   /posts\");\n    println!(\"  PUT    /posts/{{id}}\");\n    println!(\"  DELETE /posts/{{id}}\");\n    println!(\"  GET    /users/{{user_id}}/posts\");\n\n    axum::serve(listener, app).await?;\n\n    Ok(())\n}\n```\n\n## Testing the API\n\n### List all users\n\n```bash\ncurl http://localhost:3000/users\n```\n\n### Get specific user\n\n```bash\ncurl http://localhost:3000/users/1\n```\n\n### List all posts\n\n```bash\ncurl http://localhost:3000/posts\n```\n\n### List only published posts\n\n```bash\ncurl \"http://localhost:3000/posts?published=true\"\n```\n\n### Get user's posts\n\n```bash\ncurl http://localhost:3000/users/1/posts\n```\n\n### Create a post\n\n```bash\ncurl -X POST http://localhost:3000/posts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"user_id\": 1,\n    \"title\": \"New Database Post\",\n    \"content\": \"This is stored in PostgreSQL!\"\n  }'\n```\n\n### Update a post\n\n```bash\ncurl -X PUT http://localhost:3000/posts/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"Updated Title\",\n    \"published\": true\n  }'\n```\n\n### Delete a post\n\n```bash\ncurl -X DELETE http://localhost:3000/posts/3\n```\n\n## Error Handling Best Practices\n\n### Custom Error Type\n\nCreate `src/error.rs`:\n\n```rust\nuse axum::{\n    response::{IntoResponse, Response},\n    http::StatusCode,\n    Json,\n};\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct ErrorResponse {\n    error: String,\n}\n\npub enum ApiError {\n    NotFound(String),\n    BadRequest(String),\n    InternalError,\n    DatabaseError(String),\n}\n\nimpl IntoResponse for ApiError {\n    fn into_response(self) -> Response {\n        let (status, message) = match self {\n            ApiError::NotFound(msg) => (StatusCode::NOT_FOUND, msg),\n            ApiError::BadRequest(msg) => (StatusCode::BAD_REQUEST, msg),\n            ApiError::DatabaseError(msg) => (StatusCode::INTERNAL_SERVER_ERROR, format!(\"Database error: {}\", msg)),\n            ApiError::InternalError => (StatusCode::INTERNAL_SERVER_ERROR, \"Internal error\".to_string()),\n        };\n\n        (status, Json(ErrorResponse { error: message })).into_response()\n    }\n}\n\nimpl From<sqlx::Error> for ApiError {\n    fn from(err: sqlx::Error) -> Self {\n        match err {\n            sqlx::Error::RowNotFound => ApiError::NotFound(\"Resource not found\".to_string()),\n            _ => ApiError::DatabaseError(err.to_string()),\n        }\n    }\n}\n```\n\nUpdate handlers to use `ApiError`:\n\n```rust\nuse crate::error::ApiError;\n\npub async fn get_post(\n    State(pool): State<PgPool>,\n    Path(id): Path<i32>,\n) -> Result<Json<Post>, ApiError> {\n    let post = sqlx::query_as!(Post, \"SELECT * FROM posts WHERE id = $1\", id)\n        .fetch_one(&pool)\n        .await?;  // sqlx::Error automatically converts to ApiError\n\n    Ok(Json(post))\n}\n```\n\n## Transactions\n\nFor operations that need to succeed or fail together:\n\n```rust\nuse sqlx::Acquire;\n\npub async fn transfer_post_ownership(\n    State(pool): State<PgPool>,\n    Path((post_id, new_user_id)): Path<(i32, i32)>,\n) -> Result<StatusCode, ApiError> {\n    let mut tx = pool.begin().await?;\n\n    // Check new user exists\n    sqlx::query!(\"SELECT id FROM users WHERE id = $1\", new_user_id)\n        .fetch_one(&mut *tx)\n        .await?;\n\n    // Update post\n    sqlx::query!(\"UPDATE posts SET user_id = $1 WHERE id = $2\", new_user_id, post_id)\n        .execute(&mut *tx)\n        .await?;\n\n    // Commit transaction\n    tx.commit().await?;\n\n    Ok(StatusCode::OK)\n}\n```\n\n## Practice Exercises\n\n### Exercise 1: Add Comments\n\nCreate a comments table and API:\n- Migration for comments table\n- Models for Comment\n- Handlers for creating and listing comments on posts\n\n<details>\n<summary>Hint</summary>\n\nMigration:\n```sql\nCREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    post_id INTEGER NOT NULL REFERENCES posts(id) ON DELETE CASCADE,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    content TEXT NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n```\n\nRoutes:\n- `GET /posts/{post_id}/comments`\n- `POST /posts/{post_id}/comments`\n</details>\n\n### Exercise 2: Add Pagination\n\nImplement pagination for the posts list:\n- Accept `page` and `limit` query parameters\n- Use SQL `LIMIT` and `OFFSET`\n- Return total count in response\n\n<details>\n<summary>Solution Hint</summary>\n\n```rust\n#[derive(Deserialize)]\nstruct Pagination {\n    #[serde(default = \"default_page\")]\n    page: i64,\n    #[serde(default = \"default_limit\")]\n    limit: i64,\n}\n\nfn default_page() -> i64 { 0 }\nfn default_limit() -> i64 { 10 }\n\nlet offset = query.page * query.limit;\n\nlet posts = sqlx::query_as!(\n    Post,\n    \"SELECT * FROM posts ORDER BY created_at DESC LIMIT $1 OFFSET $2\",\n    query.limit,\n    offset\n)\n.fetch_all(&pool)\n.await?;\n```\n</details>\n\n### Exercise 3: Search Posts\n\nAdd `/posts/search?q=rust` endpoint that searches titles and content.\n\n<details>\n<summary>Solution</summary>\n\n```rust\npub async fn search_posts(\n    State(pool): State<PgPool>,\n    Query(query): Query<SearchQuery>,\n) -> Result<Json<Vec<Post>>, ApiError> {\n    let search_term = format!(\"%{}%\", query.q);\n\n    let posts = sqlx::query_as!(\n        Post,\n        r#\"\n        SELECT * FROM posts\n        WHERE title ILIKE $1 OR content ILIKE $1\n        ORDER BY created_at DESC\n        \"#,\n        search_term\n    )\n    .fetch_all(&pool)\n    .await?;\n\n    Ok(Json(posts))\n}\n```\n</details>\n\n## Key Takeaways\n\n- âœ… Share `PgPool` across handlers with Axum's `State`\n- âœ… Use `sqlx::query_as!` for type-safe database queries\n- âœ… Convert `sqlx::Error` to custom API errors\n- âœ… Use transactions for multi-step operations\n- âœ… Validate foreign keys before inserting\n- âœ… Return appropriate status codes (200, 201, 404, etc.)\n- âœ… Database persistence survives server restarts!\n\n**Next**: Advanced database patterns and optimization!\n\n---\n\n**Progress**: Module 13, Lesson 3 complete (65/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-13-04",
          "title": "Module 13: Database Integration",
          "type": "project",
          "estimatedMinutes": 9,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 13: Database Integration\n\n# Lesson 4: Advanced Database Patterns\n\n## Joins - Combining Related Data\n\n### Inner Join\n\nGet posts with their author information:\n\n```rust\n#[derive(Debug, Serialize)]\nstruct PostWithAuthor {\n    id: i32,\n    title: String,\n    content: String,\n    published: bool,\n    author_id: i32,\n    author_name: String,\n    author_email: String,\n}\n\nasync fn get_posts_with_authors(\n    pool: &PgPool,\n) -> Result<Vec<PostWithAuthor>, sqlx::Error> {\n    let posts = sqlx::query_as!(\n        PostWithAuthor,\n        r#\"\n        SELECT\n            p.id,\n            p.title,\n            p.content,\n            p.published,\n            u.id as author_id,\n            u.username as author_name,\n            u.email as author_email\n        FROM posts p\n        INNER JOIN users u ON p.user_id = u.id\n        ORDER BY p.created_at DESC\n        \"#\n    )\n    .fetch_all(pool)\n    .await?;\n\n    Ok(posts)\n}\n```\n\n### Left Join\n\nGet all users with their post counts (including users with zero posts):\n\n```rust\n#[derive(Debug, Serialize)]\nstruct UserWithPostCount {\n    id: i32,\n    username: String,\n    email: String,\n    post_count: Option<i64>,\n}\n\nasync fn get_users_with_post_counts(\n    pool: &PgPool,\n) -> Result<Vec<UserWithPostCount>, sqlx::Error> {\n    let users = sqlx::query_as!(\n        UserWithPostCount,\n        r#\"\n        SELECT\n            u.id,\n            u.username,\n            u.email,\n            COUNT(p.id) as \"post_count: i64\"\n        FROM users u\n        LEFT JOIN posts p ON u.id = p.user_id\n        GROUP BY u.id, u.username, u.email\n        ORDER BY post_count DESC\n        \"#\n    )\n    .fetch_all(pool)\n    .await?;\n\n    Ok(users)\n}\n```\n\n## Aggregations\n\n### COUNT, SUM, AVG, MIN, MAX\n\n```rust\n#[derive(Debug, Serialize)]\nstruct PostStats {\n    total_posts: i64,\n    published_posts: i64,\n    draft_posts: i64,\n    total_users: i64,\n}\n\nasync fn get_stats(pool: &PgPool) -> Result<PostStats, sqlx::Error> {\n    let stats = sqlx::query!(\n        r#\"\n        SELECT\n            COUNT(p.id) as \"total_posts!\",\n            COUNT(p.id) FILTER (WHERE p.published = true) as \"published_posts!\",\n            COUNT(p.id) FILTER (WHERE p.published = false) as \"draft_posts!\",\n            COUNT(DISTINCT p.user_id) as \"total_users!\"\n        FROM posts p\n        \"#\n    )\n    .fetch_one(pool)\n    .await?;\n\n    Ok(PostStats {\n        total_posts: stats.total_posts,\n        published_posts: stats.published_posts,\n        draft_posts: stats.draft_posts,\n        total_users: stats.total_users,\n    })\n}\n```\n\n### GROUP BY\n\nPosts per user:\n\n```rust\n#[derive(Debug, Serialize)]\nstruct UserPostStats {\n    user_id: i32,\n    username: String,\n    post_count: i64,\n    published_count: i64,\n}\n\nasync fn posts_per_user(pool: &PgPool) -> Result<Vec<UserPostStats>, sqlx::Error> {\n    let stats = sqlx::query_as!(\n        UserPostStats,\n        r#\"\n        SELECT\n            u.id as user_id,\n            u.username,\n            COUNT(p.id) as \"post_count!\",\n            COUNT(p.id) FILTER (WHERE p.published = true) as \"published_count!\"\n        FROM users u\n        LEFT JOIN posts p ON u.id = p.user_id\n        GROUP BY u.id, u.username\n        ORDER BY post_count DESC\n        \"#\n    )\n    .fetch_all(pool)\n    .await?;\n\n    Ok(stats)\n}\n```\n\n## Subqueries\n\nGet users who have published posts:\n\n```rust\nasync fn users_with_published_posts(pool: &PgPool) -> Result<Vec<User>, sqlx::Error> {\n    let users = sqlx::query_as!(\n        User,\n        r#\"\n        SELECT id, username, email, created_at\n        FROM users\n        WHERE id IN (\n            SELECT DISTINCT user_id\n            FROM posts\n            WHERE published = true\n        )\n        ORDER BY username\n        \"#\n    )\n    .fetch_all(pool)\n    .await?;\n\n    Ok(users)\n}\n```\n\n## Full-Text Search\n\nPostgreSQL has powerful full-text search capabilities:\n\n### Setup\n\n```sql\n-- Add migration\nALTER TABLE posts ADD COLUMN search_vector tsvector;\n\nCREATE INDEX idx_posts_search ON posts USING GIN(search_vector);\n\n-- Update function to maintain search vector\nCREATE FUNCTION posts_search_trigger() RETURNS trigger AS $$\nBEGIN\n    NEW.search_vector :=\n        setweight(to_tsvector('english', COALESCE(NEW.title, '')), 'A') ||\n        setweight(to_tsvector('english', COALESCE(NEW.content, '')), 'B');\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER posts_search_update\n    BEFORE INSERT OR UPDATE ON posts\n    FOR EACH ROW EXECUTE FUNCTION posts_search_trigger();\n\n-- Update existing rows\nUPDATE posts SET search_vector =\n    setweight(to_tsvector('english', COALESCE(title, '')), 'A') ||\n    setweight(to_tsvector('english', COALESCE(content, '')), 'B');\n```\n\n### Search Query\n\n```rust\nasync fn search_posts(\n    pool: &PgPool,\n    query: &str,\n) -> Result<Vec<Post>, sqlx::Error> {\n    let posts = sqlx::query_as!(\n        Post,\n        r#\"\n        SELECT *\n        FROM posts\n        WHERE search_vector @@ plainto_tsquery('english', $1)\n        ORDER BY ts_rank(search_vector, plainto_tsquery('english', $1)) DESC\n        \"#,\n        query\n    )\n    .fetch_all(pool)\n    .await?;\n\n    Ok(posts)\n}\n```\n\n## Many-to-Many Relationships\n\n### Example: Posts and Tags\n\nMigration:\n\n```sql\nCREATE TABLE tags (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL\n);\n\nCREATE TABLE post_tags (\n    post_id INTEGER REFERENCES posts(id) ON DELETE CASCADE,\n    tag_id INTEGER REFERENCES tags(id) ON DELETE CASCADE,\n    PRIMARY KEY (post_id, tag_id)\n);\n\nCREATE INDEX idx_post_tags_post_id ON post_tags(post_id);\nCREATE INDEX idx_post_tags_tag_id ON post_tags(tag_id);\n```\n\n### Get Post with Tags\n\n```rust\n#[derive(Debug, Serialize)]\nstruct PostWithTags {\n    #[serde(flatten)]\n    post: Post,\n    tags: Vec<String>,\n}\n\nasync fn get_post_with_tags(\n    pool: &PgPool,\n    post_id: i32,\n) -> Result<Option<PostWithTags>, sqlx::Error> {\n    // Get post\n    let post = sqlx::query_as!(\n        Post,\n        \"SELECT * FROM posts WHERE id = $1\",\n        post_id\n    )\n    .fetch_optional(pool)\n    .await?;\n\n    if let Some(post) = post {\n        // Get tags for post\n        let tags = sqlx::query!(\n            r#\"\n            SELECT t.name\n            FROM tags t\n            INNER JOIN post_tags pt ON t.id = pt.tag_id\n            WHERE pt.post_id = $1\n            \"#,\n            post_id\n        )\n        .fetch_all(pool)\n        .await?\n        .into_iter()\n        .map(|r| r.name)\n        .collect();\n\n        Ok(Some(PostWithTags { post, tags }))\n    } else {\n        Ok(None)\n    }\n}\n```\n\n### Add Tag to Post\n\n```rust\nasync fn add_tag_to_post(\n    pool: &PgPool,\n    post_id: i32,\n    tag_name: &str,\n) -> Result<(), sqlx::Error> {\n    // Get or create tag\n    let tag = sqlx::query!(\n        \"INSERT INTO tags (name) VALUES ($1) ON CONFLICT (name) DO UPDATE SET name = $1 RETURNING id\",\n        tag_name\n    )\n    .fetch_one(pool)\n    .await?;\n\n    // Link tag to post\n    sqlx::query!(\n        \"INSERT INTO post_tags (post_id, tag_id) VALUES ($1, $2) ON CONFLICT DO NOTHING\",\n        post_id,\n        tag.id\n    )\n    .execute(pool)\n    .await?;\n\n    Ok(())\n}\n```\n\n### Get Posts by Tag\n\n```rust\nasync fn get_posts_by_tag(\n    pool: &PgPool,\n    tag_name: &str,\n) -> Result<Vec<Post>, sqlx::Error> {\n    let posts = sqlx::query_as!(\n        Post,\n        r#\"\n        SELECT p.*\n        FROM posts p\n        INNER JOIN post_tags pt ON p.id = pt.post_id\n        INNER JOIN tags t ON pt.tag_id = t.id\n        WHERE t.name = $1\n        ORDER BY p.created_at DESC\n        \"#,\n        tag_name\n    )\n    .fetch_all(pool)\n    .await?;\n\n    Ok(posts)\n}\n```\n\n## Transactions for Complex Operations\n\n### Transfer Post Ownership with History\n\n```rust\nasync fn transfer_post_with_history(\n    pool: &PgPool,\n    post_id: i32,\n    new_owner_id: i32,\n    transferred_by: i32,\n) -> Result<(), sqlx::Error> {\n    let mut tx = pool.begin().await?;\n\n    // Verify new owner exists\n    sqlx::query!(\"SELECT id FROM users WHERE id = $1\", new_owner_id)\n        .fetch_one(&mut *tx)\n        .await?;\n\n    // Get current owner\n    let current = sqlx::query!(\"SELECT user_id FROM posts WHERE id = $1\", post_id)\n        .fetch_one(&mut *tx)\n        .await?;\n\n    // Update post ownership\n    sqlx::query!(\n        \"UPDATE posts SET user_id = $1, updated_at = NOW() WHERE id = $2\",\n        new_owner_id,\n        post_id\n    )\n    .execute(&mut *tx)\n    .await?;\n\n    // Record transfer in history\n    sqlx::query!(\n        r#\"\n        INSERT INTO ownership_history (post_id, from_user_id, to_user_id, transferred_by)\n        VALUES ($1, $2, $3, $4)\n        \"#,\n        post_id,\n        current.user_id,\n        new_owner_id,\n        transferred_by\n    )\n    .execute(&mut *tx)\n    .await?;\n\n    tx.commit().await?;\n\n    Ok(())\n}\n```\n\n## Optimistic Locking\n\nPrevent lost updates with version numbers:\n\n```sql\nALTER TABLE posts ADD COLUMN version INTEGER DEFAULT 1 NOT NULL;\n```\n\n```rust\n#[derive(Deserialize)]\nstruct UpdatePostWithVersion {\n    title: Option<String>,\n    content: Option<String>,\n    version: i32,\n}\n\nasync fn update_post_optimistic(\n    pool: &PgPool,\n    post_id: i32,\n    update: UpdatePostWithVersion,\n) -> Result<Post, ApiError> {\n    let result = sqlx::query_as!(\n        Post,\n        r#\"\n        UPDATE posts\n        SET\n            title = COALESCE($1, title),\n            content = COALESCE($2, content),\n            version = version + 1,\n            updated_at = NOW()\n        WHERE id = $3 AND version = $4\n        RETURNING *\n        \"#,\n        update.title,\n        update.content,\n        post_id,\n        update.version\n    )\n    .fetch_optional(pool)\n    .await?;\n\n    result.ok_or(ApiError::Conflict(\"Post was modified by another user\".to_string()))\n}\n```\n\n## Pagination with Total Count\n\n```rust\n#[derive(Serialize)]\nstruct PaginatedResponse<T> {\n    items: Vec<T>,\n    total: i64,\n    page: i64,\n    limit: i64,\n    total_pages: i64,\n}\n\nasync fn get_posts_paginated(\n    pool: &PgPool,\n    page: i64,\n    limit: i64,\n) -> Result<PaginatedResponse<Post>, sqlx::Error> {\n    let offset = page * limit;\n\n    // Get total count\n    let total = sqlx::query!(\"SELECT COUNT(*) as count FROM posts\")\n        .fetch_one(pool)\n        .await?\n        .count\n        .unwrap_or(0);\n\n    // Get page of posts\n    let posts = sqlx::query_as!(\n        Post,\n        \"SELECT * FROM posts ORDER BY created_at DESC LIMIT $1 OFFSET $2\",\n        limit,\n        offset\n    )\n    .fetch_all(pool)\n    .await?;\n\n    let total_pages = (total as f64 / limit as f64).ceil() as i64;\n\n    Ok(PaginatedResponse {\n        items: posts,\n        total,\n        page,\n        limit,\n        total_pages,\n    })\n}\n```\n\n## Database Indexes for Performance\n\n```sql\n-- Index for filtering\nCREATE INDEX idx_posts_published ON posts(published);\n\n-- Composite index for common queries\nCREATE INDEX idx_posts_user_published ON posts(user_id, published);\n\n-- Index for sorting\nCREATE INDEX idx_posts_created_at ON posts(created_at DESC);\n\n-- Partial index (only index published posts)\nCREATE INDEX idx_published_posts ON posts(created_at DESC) WHERE published = true;\n\n-- Unique composite index\nCREATE UNIQUE INDEX idx_unique_user_post_title ON posts(user_id, title);\n```\n\n## Soft Deletes\n\nInstead of deleting, mark as deleted:\n\n```sql\nALTER TABLE posts ADD COLUMN deleted_at TIMESTAMP NULL;\n\nCREATE INDEX idx_posts_not_deleted ON posts(deleted_at) WHERE deleted_at IS NULL;\n```\n\n```rust\nasync fn soft_delete_post(\n    pool: &PgPool,\n    post_id: i32,\n) -> Result<(), sqlx::Error> {\n    sqlx::query!(\n        \"UPDATE posts SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL\",\n        post_id\n    )\n    .execute(pool)\n    .await?;\n\n    Ok(())\n}\n\nasync fn list_active_posts(pool: &PgPool) -> Result<Vec<Post>, sqlx::Error> {\n    let posts = sqlx::query_as!(\n        Post,\n        \"SELECT * FROM posts WHERE deleted_at IS NULL ORDER BY created_at DESC\"\n    )\n    .fetch_all(pool)\n    .await?;\n\n    Ok(posts)\n}\n```\n\n## Practice Exercises\n\n### Exercise 1: Popular Posts\n\nCreate a query that returns the top 10 posts by comment count.\n\n<details>\n<summary>Solution</summary>\n\n```rust\n#[derive(Serialize)]\nstruct PopularPost {\n    id: i32,\n    title: String,\n    author: String,\n    comment_count: i64,\n}\n\nasync fn get_popular_posts(pool: &PgPool) -> Result<Vec<PopularPost>, sqlx::Error> {\n    let posts = sqlx::query_as!(\n        PopularPost,\n        r#\"\n        SELECT\n            p.id,\n            p.title,\n            u.username as author,\n            COUNT(c.id) as \"comment_count!\"\n        FROM posts p\n        JOIN users u ON p.user_id = u.id\n        LEFT JOIN comments c ON p.id = c.post_id\n        WHERE p.published = true\n        GROUP BY p.id, p.title, u.username\n        ORDER BY comment_count DESC\n        LIMIT 10\n        \"#\n    )\n    .fetch_all(pool)\n    .await?;\n\n    Ok(posts)\n}\n```\n</details>\n\n### Exercise 2: User Activity\n\nGet users ordered by total activity (posts + comments).\n\n<details>\n<summary>Solution</summary>\n\n```rust\n#[derive(Serialize)]\nstruct UserActivity {\n    user_id: i32,\n    username: String,\n    post_count: i64,\n    comment_count: i64,\n    total_activity: i64,\n}\n\nasync fn get_user_activity(pool: &PgPool) -> Result<Vec<UserActivity>, sqlx::Error> {\n    let activity = sqlx::query_as!(\n        UserActivity,\n        r#\"\n        SELECT\n            u.id as user_id,\n            u.username,\n            COUNT(DISTINCT p.id) as \"post_count!\",\n            COUNT(DISTINCT c.id) as \"comment_count!\",\n            COUNT(DISTINCT p.id) + COUNT(DISTINCT c.id) as \"total_activity!\"\n        FROM users u\n        LEFT JOIN posts p ON u.id = p.user_id\n        LEFT JOIN comments c ON u.id = c.user_id\n        GROUP BY u.id, u.username\n        ORDER BY total_activity DESC\n        \"#\n    )\n    .fetch_all(pool)\n    .await?;\n\n    Ok(activity)\n}\n```\n</details>\n\n### Exercise 3: Related Posts\n\nFind posts with similar tags:\n\n<details>\n<summary>Hint</summary>\n\n```sql\nSELECT p2.*, COUNT(pt2.tag_id) as matching_tags\nFROM posts p1\nJOIN post_tags pt1 ON p1.id = pt1.post_id\nJOIN post_tags pt2 ON pt1.tag_id = pt2.tag_id\nJOIN posts p2 ON pt2.post_id = p2.id\nWHERE p1.id = $1 AND p2.id != $1\nGROUP BY p2.id\nORDER BY matching_tags DESC\nLIMIT 5\n```\n</details>\n\n## Key Takeaways\n\n- âœ… Joins combine related data from multiple tables\n- âœ… Aggregations (COUNT, SUM, AVG) provide statistics\n- âœ… Full-text search enables powerful searching\n- âœ… Many-to-many relationships use junction tables\n- âœ… Transactions ensure data consistency\n- âœ… Indexes dramatically improve query performance\n- âœ… Soft deletes preserve data while hiding it\n- âœ… Optimistic locking prevents lost updates\n\n**Next**: Complete database-backed blog API practice project!\n\n---\n\n**Progress**: Module 13, Lesson 4 complete (66/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-13-05",
          "title": "Module 13: Database Integration",
          "type": "project",
          "estimatedMinutes": 11,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 13: Database Integration\n\n# Lesson 5: Practice Project â€” Full-Stack Blog with Database\n\n## Project Overview\n\nBuild a complete blog platform with:\n- Users, Posts, Comments, Tags\n- Full CRUD operations\n- Relationships and joins\n- Search functionality\n- Statistics dashboard\n- All backed by PostgreSQL!\n\nThis integrates everything from Modules 12 and 13.\n\n## Project Setup\n\n```bash\ncargo new fullstack_blog\ncd fullstack_blog\n```\n\n### Dependencies\n\n```toml\n[package]\nname = \"fullstack_blog\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\naxum = \"0.8.x\"\ntokio = { version = \"1.x\", features = [\"full\"] }\nsqlx = { version = \"0.8.x\", features = [\"runtime-tokio\", \"postgres\", \"chrono\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nchrono = { version = \"0.4\", features = [\"serde\"] }\ndotenvy = \"0.15\"\n```\n\n### Environment Setup\n\nCreate `.env`:\n\n```env\nDATABASE_URL=postgresql://postgres:password@localhost:5432/fullstack_blog\n```\n\n## Database Schema\n\n### Create Database\n\n```bash\nsqlx database create\n```\n\n### Migration 1: Core Tables\n\n```bash\nsqlx migrate add create_core_tables\n```\n\nEdit `migrations/TIMESTAMP_create_core_tables.sql`:\n\n```sql\n-- Users table\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    bio TEXT,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Posts table\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    slug VARCHAR(255) UNIQUE NOT NULL,\n    content TEXT NOT NULL,\n    excerpt VARCHAR(500),\n    published BOOLEAN DEFAULT FALSE,\n    view_count INTEGER DEFAULT 0,\n    created_at TIMESTAMP DEFAULT NOW(),\n    updated_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Comments table\nCREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    post_id INTEGER NOT NULL REFERENCES posts(id) ON DELETE CASCADE,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    content TEXT NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Tags table\nCREATE TABLE tags (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL,\n    slug VARCHAR(50) UNIQUE NOT NULL\n);\n\n-- Post-Tag junction table\nCREATE TABLE post_tags (\n    post_id INTEGER REFERENCES posts(id) ON DELETE CASCADE,\n    tag_id INTEGER REFERENCES tags(id) ON DELETE CASCADE,\n    PRIMARY KEY (post_id, tag_id)\n);\n\n-- Indexes\nCREATE INDEX idx_posts_user_id ON posts(user_id);\nCREATE INDEX idx_posts_published ON posts(published);\nCREATE INDEX idx_posts_slug ON posts(slug);\nCREATE INDEX idx_comments_post_id ON comments(post_id);\nCREATE INDEX idx_comments_user_id ON comments(user_id);\nCREATE INDEX idx_post_tags_post_id ON post_tags(post_id);\nCREATE INDEX idx_post_tags_tag_id ON post_tags(tag_id);\n\n-- Full-text search\nALTER TABLE posts ADD COLUMN search_vector tsvector;\nCREATE INDEX idx_posts_search ON posts USING GIN(search_vector);\n\nCREATE FUNCTION posts_search_trigger() RETURNS trigger AS $$\nBEGIN\n    NEW.search_vector :=\n        setweight(to_tsvector('english', COALESCE(NEW.title, '')), 'A') ||\n        setweight(to_tsvector('english', COALESCE(NEW.content, '')), 'B');\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER posts_search_update\n    BEFORE INSERT OR UPDATE ON posts\n    FOR EACH ROW EXECUTE FUNCTION posts_search_trigger();\n```\n\n### Migration 2: Sample Data\n\n```bash\nsqlx migrate add seed_data\n```\n\nEdit `migrations/TIMESTAMP_seed_data.sql`:\n\n```sql\n-- Insert users\nINSERT INTO users (username, email, bio) VALUES\n    ('alice', 'alice@example.com', 'Rust enthusiast and blogger'),\n    ('bob', 'bob@example.com', 'Full-stack developer'),\n    ('charlie', 'charlie@example.com', 'Systems programmer');\n\n-- Insert tags\nINSERT INTO tags (name, slug) VALUES\n    ('Rust', 'rust'),\n    ('Web Development', 'web-development'),\n    ('Tutorial', 'tutorial'),\n    ('Backend', 'backend'),\n    ('Axum', 'axum');\n\n-- Insert posts\nINSERT INTO posts (user_id, title, slug, content, excerpt, published) VALUES\n    (1, 'Getting Started with Rust', 'getting-started-rust',\n     'Rust is a systems programming language focused on safety, speed, and concurrency...',\n     'An introduction to Rust programming',\n     true),\n    (1, 'Building Web APIs with Axum', 'building-web-apis-axum',\n     'Axum is a modern web framework built on Tokio, Tower, and Hyper...',\n     'Learn how to build REST APIs with Axum',\n     true),\n    (2, 'Database Integration with SQLx', 'database-integration-sqlx',\n     'SQLx provides async, type-safe database access for Rust...',\n     'Complete guide to using SQLx',\n     true),\n    (3, 'Draft Post', 'draft-post',\n     'This is a draft post...',\n     'A work in progress',\n     false);\n\n-- Link posts to tags\nINSERT INTO post_tags (post_id, tag_id) VALUES\n    (1, 1), (1, 3),  -- Getting Started with Rust: Rust, Tutorial\n    (2, 1), (2, 2), (2, 4), (2, 5),  -- Building Web APIs: Rust, Web Dev, Backend, Axum\n    (3, 1), (3, 2), (3, 4);  -- Database Integration: Rust, Web Dev, Backend\n\n-- Insert comments\nINSERT INTO comments (post_id, user_id, content) VALUES\n    (1, 2, 'Great introduction! Very helpful.'),\n    (1, 3, 'Looking forward to more Rust content!'),\n    (2, 3, 'Axum is amazing. Thanks for this guide!');\n```\n\nRun migrations:\n\n```bash\nsqlx migrate run\n```\n\n## Project Structure\n\n```\nsrc/\nâ”œâ”€â”€ main.rs\nâ”œâ”€â”€ models.rs\nâ”œâ”€â”€ errors.rs\nâ”œâ”€â”€ handlers/\nâ”‚   â”œâ”€â”€ mod.rs\nâ”‚   â”œâ”€â”€ users.rs\nâ”‚   â”œâ”€â”€ posts.rs\nâ”‚   â”œâ”€â”€ comments.rs\nâ”‚   â”œâ”€â”€ tags.rs\nâ”‚   â””â”€â”€ stats.rs\n```\n\n## Implementation\n\n### src/models.rs\n\n```rust\nuse serde::{Deserialize, Serialize};\nuse chrono::NaiveDateTime;\n\n#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]\npub struct User {\n    pub id: i32,\n    pub username: String,\n    pub email: String,\n    pub bio: Option<String>,\n    pub created_at: NaiveDateTime,\n}\n\n#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]\npub struct Post {\n    pub id: i32,\n    pub user_id: i32,\n    pub title: String,\n    pub slug: String,\n    pub content: String,\n    pub excerpt: Option<String>,\n    pub published: bool,\n    pub view_count: i32,\n    pub created_at: NaiveDateTime,\n    pub updated_at: NaiveDateTime,\n}\n\n#[derive(Debug, Serialize)]\npub struct PostWithAuthor {\n    #[serde(flatten)]\n    pub post: Post,\n    pub author: String,\n    pub tags: Vec<String>,\n    pub comment_count: i64,\n}\n\n#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]\npub struct Comment {\n    pub id: i32,\n    pub post_id: i32,\n    pub user_id: i32,\n    pub content: String,\n    pub created_at: NaiveDateTime,\n}\n\n#[derive(Debug, Serialize)]\npub struct CommentWithAuthor {\n    #[serde(flatten)]\n    pub comment: Comment,\n    pub author: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]\npub struct Tag {\n    pub id: i32,\n    pub name: String,\n    pub slug: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct CreatePost {\n    pub title: String,\n    pub content: String,\n    pub excerpt: Option<String>,\n    pub published: bool,\n    pub tags: Vec<String>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct UpdatePost {\n    pub title: Option<String>,\n    pub content: Option<String>,\n    pub excerpt: Option<String>,\n    pub published: Option<bool>,\n    pub tags: Option<Vec<String>>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct CreateComment {\n    pub content: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct Stats {\n    pub total_users: i64,\n    pub total_posts: i64,\n    pub published_posts: i64,\n    pub draft_posts: i64,\n    pub total_comments: i64,\n    pub total_tags: i64,\n}\n```\n\n### src/errors.rs\n\n```rust\nuse axum::{\n    response::{IntoResponse, Response},\n    http::StatusCode,\n    Json,\n};\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct ErrorResponse {\n    error: String,\n}\n\npub enum ApiError {\n    NotFound(String),\n    BadRequest(String),\n    InternalError(String),\n}\n\nimpl IntoResponse for ApiError {\n    fn into_response(self) -> Response {\n        let (status, message) = match self {\n            ApiError::NotFound(msg) => (StatusCode::NOT_FOUND, msg),\n            ApiError::BadRequest(msg) => (StatusCode::BAD_REQUEST, msg),\n            ApiError::InternalError(msg) => (StatusCode::INTERNAL_SERVER_ERROR, msg),\n        };\n\n        (status, Json(ErrorResponse { error: message })).into_response()\n    }\n}\n\nimpl From<sqlx::Error> for ApiError {\n    fn from(err: sqlx::Error) -> Self {\n        match err {\n            sqlx::Error::RowNotFound => ApiError::NotFound(\"Resource not found\".to_string()),\n            _ => ApiError::InternalError(err.to_string()),\n        }\n    }\n}\n```\n\n### src/handlers/posts.rs\n\n```rust\nuse axum::{\n    extract::{Path, Query, State},\n    http::StatusCode,\n    Json,\n};\nuse serde::Deserialize;\nuse sqlx::PgPool;\n\nuse crate::{\n    models::{Post, PostWithAuthor, CreatePost, UpdatePost},\n    errors::ApiError,\n};\n\n#[derive(Deserialize)]\npub struct ListQuery {\n    pub tag: Option<String>,\n    pub published: Option<bool>,\n    #[serde(default)]\n    pub page: i64,\n    #[serde(default = \"default_limit\")]\n    pub limit: i64,\n}\n\nfn default_limit() -> i64 { 10 }\n\npub async fn list_posts(\n    State(pool): State<PgPool>,\n    Query(query): Query<ListQuery>,\n) -> Result<Json<Vec<PostWithAuthor>>, ApiError> {\n    let offset = query.page * query.limit;\n\n    let posts = if let Some(tag_slug) = query.tag {\n        sqlx::query_as!(\n            PostWithAuthor,\n            r#\"\n            SELECT\n                p.id, p.user_id, p.title, p.slug, p.content, p.excerpt,\n                p.published, p.view_count, p.created_at, p.updated_at,\n                u.username as author,\n                ARRAY_AGG(t.name) FILTER (WHERE t.name IS NOT NULL) as \"tags!: Vec<String>\",\n                COUNT(DISTINCT c.id) as \"comment_count!\"\n            FROM posts p\n            JOIN users u ON p.user_id = u.id\n            LEFT JOIN post_tags pt ON p.id = pt.post_id\n            LEFT JOIN tags t ON pt.tag_id = t.id\n            LEFT JOIN comments c ON p.id = c.post_id\n            WHERE p.published = COALESCE($1, p.published)\n              AND EXISTS (\n                  SELECT 1 FROM post_tags pt2\n                  JOIN tags t2 ON pt2.tag_id = t2.id\n                  WHERE pt2.post_id = p.id AND t2.slug = $2\n              )\n            GROUP BY p.id, p.user_id, p.title, p.slug, p.content, p.excerpt,\n                     p.published, p.view_count, p.created_at, p.updated_at, u.username\n            ORDER BY p.created_at DESC\n            LIMIT $3 OFFSET $4\n            \"#,\n            query.published,\n            tag_slug,\n            query.limit,\n            offset\n        )\n        .fetch_all(&pool)\n        .await?\n    } else {\n        sqlx::query_as!(\n            PostWithAuthor,\n            r#\"\n            SELECT\n                p.id, p.user_id, p.title, p.slug, p.content, p.excerpt,\n                p.published, p.view_count, p.created_at, p.updated_at,\n                u.username as author,\n                COALESCE(ARRAY_AGG(t.name) FILTER (WHERE t.name IS NOT NULL), '{}') as \"tags!: Vec<String>\",\n                COUNT(DISTINCT c.id) as \"comment_count!\"\n            FROM posts p\n            JOIN users u ON p.user_id = u.id\n            LEFT JOIN post_tags pt ON p.id = pt.post_id\n            LEFT JOIN tags t ON pt.tag_id = t.id\n            LEFT JOIN comments c ON p.id = c.post_id\n            WHERE p.published = COALESCE($1, p.published)\n            GROUP BY p.id, u.username\n            ORDER BY p.created_at DESC\n            LIMIT $2 OFFSET $3\n            \"#,\n            query.published,\n            query.limit,\n            offset\n        )\n        .fetch_all(&pool)\n        .await?\n    };\n\n    Ok(Json(posts))\n}\n\npub async fn get_post(\n    State(pool): State<PgPool>,\n    Path(slug): Path<String>,\n) -> Result<Json<PostWithAuthor>, ApiError> {\n    // Increment view count\n    sqlx::query!(\"UPDATE posts SET view_count = view_count + 1 WHERE slug = $1\", slug)\n        .execute(&pool)\n        .await?;\n\n    let post = sqlx::query_as!(\n        PostWithAuthor,\n        r#\"\n        SELECT\n            p.id, p.user_id, p.title, p.slug, p.content, p.excerpt,\n            p.published, p.view_count, p.created_at, p.updated_at,\n            u.username as author,\n            COALESCE(ARRAY_AGG(t.name) FILTER (WHERE t.name IS NOT NULL), '{}') as \"tags!: Vec<String>\",\n            COUNT(DISTINCT c.id) as \"comment_count!\"\n        FROM posts p\n        JOIN users u ON p.user_id = u.id\n        LEFT JOIN post_tags pt ON p.id = pt.post_id\n        LEFT JOIN tags t ON pt.tag_id = t.id\n        LEFT JOIN comments c ON p.id = c.post_id\n        WHERE p.slug = $1\n        GROUP BY p.id, u.username\n        \"#,\n        slug\n    )\n    .fetch_one(&pool)\n    .await?;\n\n    Ok(Json(post))\n}\n\npub async fn search_posts(\n    State(pool): State<PgPool>,\n    Query(query): Query<SearchQuery>,\n) -> Result<Json<Vec<PostWithAuthor>>, ApiError> {\n    let posts = sqlx::query_as!(\n        PostWithAuthor,\n        r#\"\n        SELECT\n            p.id, p.user_id, p.title, p.slug, p.content, p.excerpt,\n            p.published, p.view_count, p.created_at, p.updated_at,\n            u.username as author,\n            COALESCE(ARRAY_AGG(t.name) FILTER (WHERE t.name IS NOT NULL), '{}') as \"tags!: Vec<String>\",\n            COUNT(DISTINCT c.id) as \"comment_count!\"\n        FROM posts p\n        JOIN users u ON p.user_id = u.id\n        LEFT JOIN post_tags pt ON p.id = pt.post_id\n        LEFT JOIN tags t ON pt.tag_id = t.id\n        LEFT JOIN comments c ON p.id = c.post_id\n        WHERE p.search_vector @@ plainto_tsquery('english', $1)\n          AND p.published = true\n        GROUP BY p.id, u.username\n        ORDER BY ts_rank(p.search_vector, plainto_tsquery('english', $1)) DESC\n        LIMIT 20\n        \"#,\n        query.q\n    )\n    .fetch_all(&pool)\n    .await?;\n\n    Ok(Json(posts))\n}\n\n#[derive(Deserialize)]\npub struct SearchQuery {\n    pub q: String,\n}\n\nfn slugify(s: &str) -> String {\n    s.to_lowercase()\n        .chars()\n        .map(|c| if c.is_alphanumeric() { c } else { '-' })\n        .collect::<String>()\n        .split('-')\n        .filter(|s| !s.is_empty())\n        .collect::<Vec<&str>>()\n        .join(\"-\")\n}\n\npub async fn create_post(\n    State(pool): State<PgPool>,\n    Path(user_id): Path<i32>,\n    Json(create): Json<CreatePost>,\n) -> Result<(StatusCode, Json<Post>), ApiError> {\n    let slug = slugify(&create.title);\n\n    let mut tx = pool.begin().await?;\n\n    // Create post\n    let post = sqlx::query_as!(\n        Post,\n        r#\"\n        INSERT INTO posts (user_id, title, slug, content, excerpt, published)\n        VALUES ($1, $2, $3, $4, $5, $6)\n        RETURNING *\n        \"#,\n        user_id,\n        create.title,\n        slug,\n        create.content,\n        create.excerpt,\n        create.published\n    )\n    .fetch_one(&mut *tx)\n    .await?;\n\n    // Add tags\n    for tag_name in create.tags {\n        let tag_slug = slugify(&tag_name);\n        let tag = sqlx::query!(\n            \"INSERT INTO tags (name, slug) VALUES ($1, $2) ON CONFLICT (slug) DO UPDATE SET name = $1 RETURNING id\",\n            tag_name,\n            tag_slug\n        )\n        .fetch_one(&mut *tx)\n        .await?;\n\n        sqlx::query!(\n            \"INSERT INTO post_tags (post_id, tag_id) VALUES ($1, $2)\",\n            post.id,\n            tag.id\n        )\n        .execute(&mut *tx)\n        .await?;\n    }\n\n    tx.commit().await?;\n\n    Ok((StatusCode::CREATED, Json(post)))\n}\n```\n\n### src/handlers/stats.rs\n\n```rust\nuse axum::{extract::State, Json};\nuse sqlx::PgPool;\n\nuse crate::{models::Stats, errors::ApiError};\n\npub async fn get_stats(State(pool): State<PgPool>) -> Result<Json<Stats>, ApiError> {\n    let stats = sqlx::query!(\n        r#\"\n        SELECT\n            (SELECT COUNT(*) FROM users) as \"total_users!\",\n            (SELECT COUNT(*) FROM posts) as \"total_posts!\",\n            (SELECT COUNT(*) FROM posts WHERE published = true) as \"published_posts!\",\n            (SELECT COUNT(*) FROM posts WHERE published = false) as \"draft_posts!\",\n            (SELECT COUNT(*) FROM comments) as \"total_comments!\",\n            (SELECT COUNT(*) FROM tags) as \"total_tags!\"\n        \"#\n    )\n    .fetch_one(&pool)\n    .await?;\n\n    Ok(Json(Stats {\n        total_users: stats.total_users,\n        total_posts: stats.total_posts,\n        published_posts: stats.published_posts,\n        draft_posts: stats.draft_posts,\n        total_comments: stats.total_comments,\n        total_tags: stats.total_tags,\n    }))\n}\n```\n\n### src/main.rs\n\n```rust\nmod models;\nmod errors;\nmod handlers;\n\nuse axum::{\n    routing::{get, post},\n    Router,\n};\nuse sqlx::postgres::PgPoolOptions;\nuse std::env;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    dotenvy::dotenv().ok();\n\n    let database_url = env::var(\"DATABASE_URL\")?;\n\n    let pool = PgPoolOptions::new()\n        .max_connections(5)\n        .connect(&database_url)\n        .await?;\n\n    println!(\"âœ… Connected to database\");\n\n    let app = Router::new()\n        .route(\"/\", get(|| async { \"Full-Stack Blog API\" }))\n        .route(\"/posts\", get(handlers::posts::list_posts))\n        .route(\"/posts/search\", get(handlers::posts::search_posts))\n        .route(\"/posts/{slug}\", get(handlers::posts::get_post))\n        .route(\"/users/{user_id}/posts\", post(handlers::posts::create_post))\n        .route(\"/stats\", get(handlers::stats::get_stats))\n        .with_state(pool);\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await?;\n\n    println!(\"ðŸš€ Server running on http://localhost:3000\");\n    println!(\"\\nðŸ“š Endpoints:\");\n    println!(\"  GET  /posts\");\n    println!(\"  GET  /posts?tag=rust&published=true\");\n    println!(\"  GET  /posts/{{slug}}\");\n    println!(\"  GET  /posts/search?q=rust\");\n    println!(\"  POST /users/{{user_id}}/posts\");\n    println!(\"  GET  /stats\");\n\n    axum::serve(listener, app).await?;\n\n    Ok(())\n}\n```\n\n## Testing\n\n```bash\n# List all published posts\ncurl \"http://localhost:3000/posts?published=true\"\n\n# Filter by tag\ncurl \"http://localhost:3000/posts?tag=rust\"\n\n# Get single post\ncurl http://localhost:3000/posts/getting-started-rust\n\n# Search\ncurl \"http://localhost:3000/posts/search?q=axum\"\n\n# Get stats\ncurl http://localhost:3000/stats\n\n# Create post\ncurl -X POST http://localhost:3000/users/1/posts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"My New Post\",\n    \"content\": \"This is the full content...\",\n    \"excerpt\": \"A brief summary\",\n    \"published\": true,\n    \"tags\": [\"Rust\", \"Tutorial\"]\n  }'\n```\n\n## Challenge Extensions\n\nAdd these features yourself:\n\n1. **User endpoints** - List users, get user profile\n2. **Comment endpoints** - Add, list, delete comments\n3. **Update/delete posts** - PUT and DELETE for posts\n4. **Popular posts** - Endpoint for most viewed posts\n5. **Trending tags** - Tags ordered by post count\n6. **Related posts** - Posts with similar tags\n\n## Key Takeaways\n\n- âœ… Complete full-stack application with database\n- âœ… Complex queries with joins and aggregations\n- âœ… Many-to-many relationships (posts and tags)\n- âœ… Full-text search\n- âœ… View counting and statistics\n- âœ… Proper error handling\n- âœ… Transaction management\n- âœ… Production-ready patterns\n\n**Next Module**: Authentication & Security!\n\n---\n\n**Progress**: Module 13 complete! (67/90+ lessons total)\n"
          }
        }
      ]
    },
    {
      "id": "module-14",
      "title": "MODULE 14",
      "description": "Module 14",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-14-01",
          "title": "Module 14: Authentication & Security",
          "type": "exercise",
          "estimatedMinutes": 7,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 14: Authentication & Security\n\n# Lesson 1: Password Hashing & User Authentication\n\n## Why Authentication Matters\n\n**Authentication** verifies **who** a user is. Without it:\n- Anyone can access private data\n- No personalization\n- No accountability\n- No protected actions\n\n## Never Store Plain Passwords!\n\nâŒ **NEVER DO THIS:**\n```sql\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50),\n    password VARCHAR(255)  -- NEVER store plain text!\n);\n\nINSERT INTO users (username, password) VALUES ('alice', 'password123');  -- TERRIBLE!\n```\n\n**Why it's dangerous:**\n- Database breach = all passwords exposed\n- Admins can see passwords\n- Users often reuse passwords across sites\n\n## Password Hashing\n\n**Hashing** transforms passwords into irreversible strings:\n\n```\n\"password123\" â†’ hash â†’ \"$argon2id$v=19$m=19456,t=2,p=1$...\"\n```\n\n**Properties:**\n- **One-way**: Can't reverse hash to get password\n- **Deterministic**: Same password = same hash\n- **Unique**: Different passwords = different hashes\n- **Slow**: Makes brute-force attacks impractical\n\n## Using `argon2` for Password Hashing\n\n### Setup\n\n```toml\n[dependencies]\nargon2 = \"0.5\"\nrand = \"0.8\"\n```\n\n### Hash a Password\n\n```rust\nuse argon2::{\n    password_hash::{\n        rand_core::OsRng,\n        PasswordHash, PasswordHasher, PasswordVerifier, SaltString\n    },\n    Argon2\n};\n\nfn hash_password(password: &str) -> Result<String, argon2::password_hash::Error> {\n    let salt = SaltString::generate(&mut OsRng);\n    let argon2 = Argon2::default();\n\n    let password_hash = argon2\n        .hash_password(password.as_bytes(), &salt)?\n        .to_string();\n\n    Ok(password_hash)\n}\n\n#[tokio::main]\nasync fn main() {\n    let password = \"my_secure_password\";\n    let hash = hash_password(password).unwrap();\n\n    println!(\"Password: {}\", password);\n    println!(\"Hash: {}\", hash);\n    // Output: $argon2id$v=19$m=19456,t=2,p=1$...\n}\n```\n\n### Verify a Password\n\n```rust\nfn verify_password(password: &str, hash: &str) -> Result<bool, argon2::password_hash::Error> {\n    let parsed_hash = PasswordHash::new(hash)?;\n    let argon2 = Argon2::default();\n\n    match argon2.verify_password(password.as_bytes(), &parsed_hash) {\n        Ok(()) => Ok(true),\n        Err(argon2::password_hash::Error::Password) => Ok(false),\n        Err(e) => Err(e),\n    }\n}\n\nfn main() {\n    let password = \"my_secure_password\";\n    let hash = hash_password(password).unwrap();\n\n    // Correct password\n    assert!(verify_password(password, &hash).unwrap());\n\n    // Wrong password\n    assert!(!verify_password(\"wrong_password\", &hash).unwrap());\n}\n```\n\n## User Registration\n\n### Database Schema\n\n```sql\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n```\n\n**Notice:** We store `password_hash`, not `password`!\n\n### Registration Handler\n\n```rust\nuse axum::{\n    extract::State,\n    http::StatusCode,\n    Json,\n};\nuse serde::{Deserialize, Serialize};\nuse sqlx::PgPool;\n\n#[derive(Deserialize)]\nstruct RegisterRequest {\n    username: String,\n    email: String,\n    password: String,\n}\n\n#[derive(Serialize)]\nstruct User {\n    id: i32,\n    username: String,\n    email: String,\n}\n\nasync fn register(\n    State(pool): State<PgPool>,\n    Json(req): Json<RegisterRequest>,\n) -> Result<(StatusCode, Json<User>), ApiError> {\n    // Validate password strength\n    if req.password.len() < 8 {\n        return Err(ApiError::BadRequest(\"Password must be at least 8 characters\".into()));\n    }\n\n    // Hash password\n    let password_hash = hash_password(&req.password)\n        .map_err(|_| ApiError::InternalError(\"Failed to hash password\".into()))?;\n\n    // Insert user\n    let user = sqlx::query_as!(\n        User,\n        r#\"\n        INSERT INTO users (username, email, password_hash)\n        VALUES ($1, $2, $3)\n        RETURNING id, username, email\n        \"#,\n        req.username,\n        req.email,\n        password_hash\n    )\n    .fetch_one(&pool)\n    .await\n    .map_err(|e| match e {\n        sqlx::Error::Database(db_err) if db_err.is_unique_violation() => {\n            ApiError::BadRequest(\"Username or email already exists\".into())\n        }\n        _ => ApiError::from(e),\n    })?;\n\n    Ok((StatusCode::CREATED, Json(user)))\n}\n```\n\n## User Login\n\n### Login Handler\n\n```rust\n#[derive(Deserialize)]\nstruct LoginRequest {\n    username: String,\n    password: String,\n}\n\n#[derive(Serialize)]\nstruct LoginResponse {\n    user: User,\n    message: String,\n}\n\nasync fn login(\n    State(pool): State<PgPool>,\n    Json(req): Json<LoginRequest>,\n) -> Result<Json<LoginResponse>, ApiError> {\n    // Get user from database\n    let user_record = sqlx::query!(\n        \"SELECT id, username, email, password_hash FROM users WHERE username = $1\",\n        req.username\n    )\n    .fetch_optional(&pool)\n    .await?\n    .ok_or_else(|| ApiError::Unauthorized(\"Invalid credentials\".into()))?;\n\n    // Verify password\n    let is_valid = verify_password(&req.password, &user_record.password_hash)\n        .map_err(|_| ApiError::InternalError(\"Password verification failed\".into()))?;\n\n    if !is_valid {\n        return Err(ApiError::Unauthorized(\"Invalid credentials\".into()));\n    }\n\n    // Success!\n    Ok(Json(LoginResponse {\n        user: User {\n            id: user_record.id,\n            username: user_record.username,\n            email: user_record.email,\n        },\n        message: \"Login successful\".into(),\n    }))\n}\n```\n\n## Security Best Practices\n\n### Password Requirements\n\n```rust\nfn validate_password(password: &str) -> Result<(), String> {\n    if password.len() < 8 {\n        return Err(\"Password must be at least 8 characters\".into());\n    }\n\n    let has_uppercase = password.chars().any(|c| c.is_uppercase());\n    let has_lowercase = password.chars().any(|c| c.is_lowercase());\n    let has_digit = password.chars().any(|c| c.is_numeric());\n\n    if !has_uppercase || !has_lowercase || !has_digit {\n        return Err(\"Password must contain uppercase, lowercase, and digit\".into());\n    }\n\n    Ok(())\n}\n```\n\n### Rate Limiting (Basic)\n\nPrevent brute-force attacks:\n\n```rust\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\n#[derive(Clone)]\nstruct RateLimiter {\n    attempts: Arc<Mutex<HashMap<String, Vec<u64>>>>,\n}\n\nimpl RateLimiter {\n    fn new() -> Self {\n        Self {\n            attempts: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    async fn check_rate_limit(&self, username: &str) -> Result<(), String> {\n        let mut attempts = self.attempts.lock().await;\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_secs();\n\n        let user_attempts = attempts.entry(username.to_string()).or_insert_with(Vec::new);\n\n        // Remove attempts older than 15 minutes\n        user_attempts.retain(|&time| now - time < 900);\n\n        // Check if too many attempts\n        if user_attempts.len() >= 5 {\n            return Err(\"Too many login attempts. Try again later.\".into());\n        }\n\n        // Record this attempt\n        user_attempts.push(now);\n\n        Ok(())\n    }\n}\n\nasync fn login_with_rate_limit(\n    State(pool): State<PgPool>,\n    State(rate_limiter): State<RateLimiter>,\n    Json(req): Json<LoginRequest>,\n) -> Result<Json<LoginResponse>, ApiError> {\n    // Check rate limit\n    rate_limiter\n        .check_rate_limit(&req.username)\n        .await\n        .map_err(|e| ApiError::TooManyRequests(e))?;\n\n    // Continue with login...\n    login(State(pool), Json(req)).await\n}\n```\n\n### Email Validation\n\n```rust\nfn validate_email(email: &str) -> bool {\n    email.contains('@') && email.contains('.') && email.len() >= 5\n}\n```\n\n### Username Sanitization\n\n```rust\nfn validate_username(username: &str) -> Result<(), String> {\n    if username.len() < 3 || username.len() > 30 {\n        return Err(\"Username must be 3-30 characters\".into());\n    }\n\n    if !username.chars().all(|c| c.is_alphanumeric() || c == '_' || c == '-') {\n        return Err(\"Username can only contain letters, numbers, _ and -\".into());\n    }\n\n    Ok(())\n}\n```\n\n## Complete Registration/Login Example\n\n```rust\nuse axum::{\n    routing::post,\n    Router,\n    extract::State,\n    http::StatusCode,\n    Json,\n};\nuse sqlx::postgres::PgPoolOptions;\nuse serde::{Deserialize, Serialize};\n\nmod auth {\n    use argon2::{\n        password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},\n        Argon2,\n    };\n\n    pub fn hash_password(password: &str) -> Result<String, argon2::password_hash::Error> {\n        let salt = SaltString::generate(&mut OsRng);\n        let argon2 = Argon2::default();\n        let password_hash = argon2.hash_password(password.as_bytes(), &salt)?.to_string();\n        Ok(password_hash)\n    }\n\n    pub fn verify_password(password: &str, hash: &str) -> Result<bool, argon2::password_hash::Error> {\n        let parsed_hash = PasswordHash::new(hash)?;\n        let argon2 = Argon2::default();\n        match argon2.verify_password(password.as_bytes(), &parsed_hash) {\n            Ok(()) => Ok(true),\n            Err(argon2::password_hash::Error::Password) => Ok(false),\n            Err(e) => Err(e),\n        }\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    dotenvy::dotenv().ok();\n    let database_url = std::env::var(\"DATABASE_URL\")?;\n\n    let pool = PgPoolOptions::new()\n        .max_connections(5)\n        .connect(&database_url)\n        .await?;\n\n    let app = Router::new()\n        .route(\"/register\", post(register))\n        .route(\"/login\", post(login))\n        .with_state(pool);\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await?;\n    println!(\"ðŸš€ Auth server running on http://localhost:3000\");\n\n    axum::serve(listener, app).await?;\n\n    Ok(())\n}\n```\n\n## Practice Exercises\n\n### Exercise 1: Password Strength Meter\n\nCreate a function that returns password strength (weak/medium/strong):\n\n```rust\nenum PasswordStrength {\n    Weak,\n    Medium,\n    Strong,\n}\n\nfn check_password_strength(password: &str) -> PasswordStrength {\n    // Your implementation here\n}\n```\n\n<details>\n<summary>Solution</summary>\n\n```rust\nfn check_password_strength(password: &str) -> PasswordStrength {\n    let mut score = 0;\n\n    if password.len() >= 8 { score += 1; }\n    if password.len() >= 12 { score += 1; }\n    if password.chars().any(|c| c.is_uppercase()) { score += 1; }\n    if password.chars().any(|c| c.is_lowercase()) { score += 1; }\n    if password.chars().any(|c| c.is_numeric()) { score += 1; }\n    if password.chars().any(|c| !c.is_alphanumeric()) { score += 1; }\n\n    match score {\n        0..=2 => PasswordStrength::Weak,\n        3..=4 => PasswordStrength::Medium,\n        _ => PasswordStrength::Strong,\n    }\n}\n```\n</details>\n\n### Exercise 2: Change Password Endpoint\n\nCreate a POST /change-password endpoint that:\n- Verifies old password\n- Validates new password\n- Updates password_hash in database\n\n<details>\n<summary>Hint</summary>\n\n```rust\n#[derive(Deserialize)]\nstruct ChangePasswordRequest {\n    user_id: i32,\n    old_password: String,\n    new_password: String,\n}\n\nasync fn change_password(\n    State(pool): State<PgPool>,\n    Json(req): Json<ChangePasswordRequest>,\n) -> Result<StatusCode, ApiError> {\n    // 1. Get current password_hash from database\n    // 2. Verify old_password matches\n    // 3. Validate new_password\n    // 4. Hash new_password\n    // 5. Update database\n    // 6. Return StatusCode::OK\n}\n```\n</details>\n\n### Exercise 3: Account Lockout\n\nImplement account lockout after 5 failed login attempts:\n\n<details>\n<summary>Hint</summary>\n\nAdd `failed_attempts` and `locked_until` columns to users table:\n\n```sql\nALTER TABLE users ADD COLUMN failed_attempts INTEGER DEFAULT 0;\nALTER TABLE users ADD COLUMN locked_until TIMESTAMP NULL;\n```\n\nIn login handler:\n1. Check if `locked_until` is in the future\n2. On failed login, increment `failed_attempts`\n3. If >= 5, set `locked_until` to 15 minutes from now\n4. On successful login, reset `failed_attempts` to 0\n</details>\n\n## Key Takeaways\n\n- âœ… NEVER store passwords in plain text\n- âœ… Use argon2 for password hashing (slow, secure)\n- âœ… Hash passwords before storing\n- âœ… Verify passwords by comparing hashes\n- âœ… Validate password strength (length, complexity)\n- âœ… Implement rate limiting to prevent brute-force\n- âœ… Return generic error messages (\"Invalid credentials\")\n- âœ… Hash passwords on registration, verify on login\n\n**Next**: JWT tokens for stateless authentication!\n\n---\n\n**Progress**: Module 14, Lesson 1 complete (68/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-14-02",
          "title": "Module 14: Authentication & Security",
          "type": "exercise",
          "estimatedMinutes": 8,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 14: Authentication & Security\n\n# Lesson 2: JWT Tokens for Stateless Authentication\n\n## What are JWTs?\n\n**JWT (JSON Web Token)** is a compact, URL-safe token format for authentication.\n\n**Structure:**\n```\nheader.payload.signature\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n```\n\n**Three parts:**\n1. **Header** - Algorithm and token type\n2. **Payload** - Claims (user data)\n3. **Signature** - Verifies token hasn't been tampered with\n\n## JWT vs Sessions\n\n### Sessions (Stateful)\n- Server stores session data in database/memory\n- Client receives session ID cookie\n- Server looks up session on each request\n- âŒ Doesn't scale well (requires shared state)\n- âœ… Easy to invalidate\n\n### JWT (Stateless)\n- Server creates signed token with user data\n- Client stores token (localStorage/cookie)\n- Client sends token with each request\n- Server verifies signature (no database lookup)\n- âœ… Scales horizontally (no shared state needed)\n- âŒ Hard to invalidate before expiration\n\n## Setup\n\n```toml\n[dependencies]\njsonwebtoken = \"9\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nchrono = \"0.4\"\n```\n\n## Creating JWTs\n\n```rust\nuse jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey};\nuse serde::{Deserialize, Serialize};\nuse chrono::{Utc, Duration};\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Claims {\n    sub: String,      // Subject (user ID)\n    exp: usize,       // Expiration time\n    iat: usize,       // Issued at\n    user_id: i32,\n    username: String,\n}\n\nfn create_jwt(user_id: i32, username: String, secret: &str) -> Result<String, jsonwebtoken::errors::Error> {\n    let now = Utc::now();\n    let expiration = now + Duration::hours(24);\n\n    let claims = Claims {\n        sub: user_id.to_string(),\n        exp: expiration.timestamp() as usize,\n        iat: now.timestamp() as usize,\n        user_id,\n        username,\n    };\n\n    encode(\n        &Header::default(),\n        &claims,\n        &EncodingKey::from_secret(secret.as_bytes())\n    )\n}\n\nfn main() {\n    let secret = \"my-secret-key-keep-this-safe\";\n    let token = create_jwt(1, \"alice\".to_string(), secret).unwrap();\n\n    println!(\"JWT Token: {}\", token);\n}\n```\n\n## Verifying JWTs\n\n```rust\nfn verify_jwt(token: &str, secret: &str) -> Result<Claims, jsonwebtoken::errors::Error> {\n    let token_data = decode::<Claims>(\n        token,\n        &DecodingKey::from_secret(secret.as_bytes()),\n        &Validation::default()\n    )?;\n\n    Ok(token_data.claims)\n}\n\nfn main() {\n    let secret = \"my-secret-key\";\n    let token = create_jwt(1, \"alice\".to_string(), secret).unwrap();\n\n    match verify_jwt(&token, secret) {\n        Ok(claims) => {\n            println!(\"Valid token!\");\n            println!(\"User ID: {}\", claims.user_id);\n            println!(\"Username: {}\", claims.username);\n        }\n        Err(e) => println!(\"Invalid token: {}\", e),\n    }\n}\n```\n\n## Login with JWT\n\n```rust\nuse axum::{\n    extract::State,\n    http::StatusCode,\n    Json,\n};\nuse serde::{Deserialize, Serialize};\nuse sqlx::PgPool;\n\n#[derive(Deserialize)]\nstruct LoginRequest {\n    username: String,\n    password: String,\n}\n\n#[derive(Serialize)]\nstruct LoginResponse {\n    token: String,\n    user: UserResponse,\n}\n\n#[derive(Serialize)]\nstruct UserResponse {\n    id: i32,\n    username: String,\n    email: String,\n}\n\nasync fn login(\n    State(pool): State<PgPool>,\n    State(jwt_secret): State<String>,\n    Json(req): Json<LoginRequest>,\n) -> Result<Json<LoginResponse>, ApiError> {\n    // Get user from database\n    let user = sqlx::query!(\n        \"SELECT id, username, email, password_hash FROM users WHERE username = $1\",\n        req.username\n    )\n    .fetch_optional(&pool)\n    .await?\n    .ok_or_else(|| ApiError::Unauthorized(\"Invalid credentials\".into()))?;\n\n    // Verify password\n    let is_valid = verify_password(&req.password, &user.password_hash)\n        .map_err(|_| ApiError::InternalError(\"Password verification failed\".into()))?;\n\n    if !is_valid {\n        return Err(ApiError::Unauthorized(\"Invalid credentials\".into()));\n    }\n\n    // Create JWT\n    let token = create_jwt(user.id, user.username.clone(), &jwt_secret)\n        .map_err(|_| ApiError::InternalError(\"Failed to create token\".into()))?;\n\n    Ok(Json(LoginResponse {\n        token,\n        user: UserResponse {\n            id: user.id,\n            username: user.username,\n            email: user.email,\n        },\n    }))\n}\n```\n\n## Protected Routes with Middleware\n\n### Create Auth Middleware\n\n```rust\nuse axum::{\n    extract::{Request, State},\n    middleware::Next,\n    response::Response,\n    http::{StatusCode, header},\n};\n\n#[derive(Clone)]\npub struct AuthState {\n    pub jwt_secret: String,\n}\n\n#[derive(Clone)]\npub struct CurrentUser {\n    pub user_id: i32,\n    pub username: String,\n}\n\nasync fn auth_middleware(\n    State(auth_state): State<AuthState>,\n    mut req: Request,\n    next: Next,\n) -> Result<Response, StatusCode> {\n    // Extract token from Authorization header\n    let token = req\n        .headers()\n        .get(header::AUTHORIZATION)\n        .and_then(|h| h.to_str().ok())\n        .and_then(|h| h.strip_prefix(\"Bearer \"))\n        .ok_or(StatusCode::UNAUTHORIZED)?;\n\n    // Verify token\n    let claims = verify_jwt(token, &auth_state.jwt_secret)\n        .map_err(|_| StatusCode::UNAUTHORIZED)?;\n\n    // Add user to request extensions\n    req.extensions_mut().insert(CurrentUser {\n        user_id: claims.user_id,\n        username: claims.username,\n    });\n\n    Ok(next.run(req).await)\n}\n```\n\n### Using the Middleware\n\n```rust\nuse axum::{\n    Router,\n    routing::get,\n    middleware,\n    extract::Extension,\n};\n\nasync fn protected_route(\n    Extension(user): Extension<CurrentUser>,\n) -> String {\n    format!(\"Hello, {}! Your user ID is {}\", user.username, user.user_id)\n}\n\nfn create_router(auth_state: AuthState, pool: PgPool) -> Router {\n    // Public routes\n    let public_routes = Router::new()\n        .route(\"/login\", post(login))\n        .route(\"/register\", post(register));\n\n    // Protected routes (require authentication)\n    let protected_routes = Router::new()\n        .route(\"/profile\", get(get_profile))\n        .route(\"/posts\", post(create_post))\n        .layer(middleware::from_fn_with_state(auth_state.clone(), auth_middleware));\n\n    Router::new()\n        .merge(public_routes)\n        .merge(protected_routes)\n        .with_state((auth_state, pool))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let jwt_secret = std::env::var(\"JWT_SECRET\")\n        .unwrap_or_else(|_| \"your-secret-key\".to_string());\n\n    let auth_state = AuthState { jwt_secret };\n\n    let pool = /* create pool */;\n\n    let app = create_router(auth_state, pool);\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await?;\n    axum::serve(listener, app).await?;\n\n    Ok(())\n}\n```\n\n## Extracting Current User\n\nCreate a custom extractor:\n\n```rust\nuse axum::{\n    async_trait,\n    extract::FromRequestParts,\n    http::{request::Parts, StatusCode},\n};\n\n#[async_trait]\nimpl<S> FromRequestParts<S> for CurrentUser\nwhere\n    S: Send + Sync,\n{\n    type Rejection = StatusCode;\n\n    async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {\n        parts\n            .extensions\n            .get::<CurrentUser>()\n            .cloned()\n            .ok_or(StatusCode::UNAUTHORIZED)\n    }\n}\n\n// Now use it in handlers:\nasync fn get_profile(\n    State(pool): State<PgPool>,\n    user: CurrentUser,  // Automatically extracted!\n) -> Result<Json<UserProfile>, ApiError> {\n    let profile = sqlx::query_as!(\n        UserProfile,\n        \"SELECT id, username, email, bio FROM users WHERE id = $1\",\n        user.user_id\n    )\n    .fetch_one(&pool)\n    .await?;\n\n    Ok(Json(profile))\n}\n```\n\n## Refresh Tokens\n\nLong-lived tokens for getting new access tokens:\n\n```rust\nuse uuid::Uuid;\n\n#[derive(Serialize)]\nstruct TokenPair {\n    access_token: String,\n    refresh_token: String,\n}\n\nasync fn create_token_pair(\n    user_id: i32,\n    username: String,\n    jwt_secret: &str,\n    pool: &PgPool,\n) -> Result<TokenPair, sqlx::Error> {\n    // Short-lived access token (1 hour)\n    let access_token = create_jwt_with_expiry(user_id, username.clone(), jwt_secret, 1)?;\n\n    // Long-lived refresh token (30 days)\n    let refresh_token = Uuid::new_v4().to_string();\n    let expires_at = Utc::now() + Duration::days(30);\n\n    // Store refresh token in database\n    sqlx::query!(\n        r#\"\n        INSERT INTO refresh_tokens (user_id, token, expires_at)\n        VALUES ($1, $2, $3)\n        \"#,\n        user_id,\n        refresh_token,\n        expires_at.naive_utc()\n    )\n    .execute(pool)\n    .await?;\n\n    Ok(TokenPair {\n        access_token,\n        refresh_token,\n    })\n}\n\nasync fn refresh_access_token(\n    State(pool): State<PgPool>,\n    State(jwt_secret): State<String>,\n    Json(req): Json<RefreshRequest>,\n) -> Result<Json<TokenResponse>, ApiError> {\n    // Verify refresh token exists and is valid\n    let token_record = sqlx::query!(\n        r#\"\n        SELECT user_id, expires_at FROM refresh_tokens\n        WHERE token = $1 AND expires_at > NOW()\n        \"#,\n        req.refresh_token\n    )\n    .fetch_optional(&pool)\n    .await?\n    .ok_or_else(|| ApiError::Unauthorized(\"Invalid refresh token\".into()))?;\n\n    // Get user\n    let user = sqlx::query!(\n        \"SELECT username FROM users WHERE id = $1\",\n        token_record.user_id\n    )\n    .fetch_one(&pool)\n    .await?;\n\n    // Create new access token\n    let access_token = create_jwt(token_record.user_id, user.username, &jwt_secret)\n        .map_err(|_| ApiError::InternalError(\"Failed to create token\".into()))?;\n\n    Ok(Json(TokenResponse { access_token }))\n}\n```\n\n## Environment Variables for Secrets\n\n**.env:**\n```env\nDATABASE_URL=postgresql://postgres:password@localhost:5432/blog_dev\nJWT_SECRET=your-super-secret-jwt-key-change-this-in-production\n```\n\n**Load in code:**\n```rust\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    dotenvy::dotenv().ok();\n\n    let jwt_secret = std::env::var(\"JWT_SECRET\")\n        .expect(\"JWT_SECRET must be set\");\n\n    // Use jwt_secret...\n}\n```\n\n## Security Best Practices\n\n### 1. Keep Secrets Secret\n\nâŒ **Never:**\n```rust\nlet secret = \"hardcoded-secret\";  // DON'T!\n```\n\nâœ… **Always:**\n```rust\nlet secret = std::env::var(\"JWT_SECRET\").expect(\"JWT_SECRET not set\");\n```\n\n### 2. Use Strong Secrets\n\n```bash\n# Generate a strong secret\nopenssl rand -base64 32\n```\n\n### 3. Short Expiration Times\n\n```rust\n// Access token: 1 hour\nlet expiration = now + Duration::hours(1);\n\n// Refresh token: 30 days\nlet expiration = now + Duration::days(30);\n```\n\n### 4. HTTPS Only in Production\n\nNever send tokens over HTTP in production!\n\n### 5. Token Revocation\n\nStore token IDs in database for revocation:\n\n```rust\n#[derive(Serialize, Deserialize)]\nstruct Claims {\n    sub: String,\n    exp: usize,\n    iat: usize,\n    jti: String,  // JWT ID for revocation\n    user_id: i32,\n}\n\nasync fn verify_token_not_revoked(jti: &str, pool: &PgPool) -> Result<bool, sqlx::Error> {\n    let exists = sqlx::query!(\n        \"SELECT 1 FROM revoked_tokens WHERE jti = $1\",\n        jti\n    )\n    .fetch_optional(pool)\n    .await?\n    .is_some();\n\n    Ok(!exists)\n}\n```\n\n## Complete Example\n\n```rust\nuse axum::{\n    Router,\n    routing::{get, post},\n    middleware,\n    extract::{State, Extension},\n    http::StatusCode,\n    Json,\n};\nuse sqlx::PgPool;\nuse serde::{Deserialize, Serialize};\n\nmod auth;  // Your auth module with JWT functions\n\n#[derive(Clone)]\nstruct AppState {\n    pool: PgPool,\n    jwt_secret: String,\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    dotenvy::dotenv().ok();\n\n    let database_url = std::env::var(\"DATABASE_URL\")?;\n    let jwt_secret = std::env::var(\"JWT_SECRET\")?;\n\n    let pool = PgPoolOptions::new()\n        .max_connections(5)\n        .connect(&database_url)\n        .await?;\n\n    let state = AppState { pool, jwt_secret };\n\n    let app = Router::new()\n        // Public routes\n        .route(\"/register\", post(register))\n        .route(\"/login\", post(login))\n        // Protected routes\n        .route(\"/profile\", get(get_profile))\n        .route(\"/posts\", post(create_post))\n        .layer(middleware::from_fn_with_state(state.clone(), auth_middleware))\n        .with_state(state);\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await?;\n    println!(\"ðŸš€ Server with JWT auth running!\");\n\n    axum::serve(listener, app).await?;\n\n    Ok(())\n}\n```\n\n## Testing with curl\n\n```bash\n# Register\ncurl -X POST http://localhost:3000/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"username\":\"alice\",\"email\":\"alice@example.com\",\"password\":\"SecurePass123\"}'\n\n# Login (get token)\nTOKEN=$(curl -X POST http://localhost:3000/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"username\":\"alice\",\"password\":\"SecurePass123\"}' \\\n  | jq -r '.token')\n\n# Use token for protected route\ncurl http://localhost:3000/profile \\\n  -H \"Authorization: Bearer $TOKEN\"\n```\n\n## Key Takeaways\n\n- âœ… JWTs enable stateless authentication\n- âœ… Tokens contain signed user data (claims)\n- âœ… Server verifies signature without database lookup\n- âœ… Use short expiration times (1 hour for access tokens)\n- âœ… Refresh tokens for long-lived sessions\n- âœ… Store JWT secret in environment variables\n- âœ… Use middleware to protect routes\n- âœ… Extract current user in handlers automatically\n- âœ… Consider token revocation for critical applications\n\n**Next**: Authorization and role-based access control!\n\n---\n\n**Progress**: Module 14, Lesson 2 complete (69/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-14-03",
          "title": "Module 14: Authentication & Security",
          "type": "exercise",
          "estimatedMinutes": 8,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 14: Authentication & Security\n\n# Lesson 3: Authorization & Role-Based Access Control\n\n## Authentication vs Authorization\n\n- **Authentication** = Who are you? (Login)\n- **Authorization** = What can you do? (Permissions)\n\n## Role-Based Access Control (RBAC)\n\nUsers have **roles**, roles have **permissions**.\n\n**Example:**\n- **Admin**: Can do everything\n- **Editor**: Can create/edit/delete posts\n- **User**: Can create/edit own posts, comment\n- **Guest**: Can only view published posts\n\n## Database Schema\n\n```sql\n-- Roles table\nCREATE TABLE roles (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL\n);\n\n-- User roles junction table\nCREATE TABLE user_roles (\n    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,\n    role_id INTEGER REFERENCES roles(id) ON DELETE CASCADE,\n    PRIMARY KEY (user_id, role_id)\n);\n\n-- Insert default roles\nINSERT INTO roles (name) VALUES ('admin'), ('editor'), ('user');\n\n-- Give alice admin role\nINSERT INTO user_roles (user_id, role_id)\nSELECT 1, id FROM roles WHERE name = 'admin';\n```\n\n## Adding Roles to JWT Claims\n\n```rust\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Claims {\n    sub: String,\n    exp: usize,\n    iat: usize,\n    user_id: i32,\n    username: String,\n    roles: Vec<String>,  // Add roles!\n}\n\nasync fn create_jwt_with_roles(\n    user_id: i32,\n    username: String,\n    pool: &PgPool,\n    jwt_secret: &str,\n) -> Result<String, Box<dyn std::error::Error>> {\n    // Get user's roles\n    let roles = sqlx::query!(\n        r#\"\n        SELECT r.name\n        FROM roles r\n        JOIN user_roles ur ON r.id = ur.role_id\n        WHERE ur.user_id = $1\n        \"#,\n        user_id\n    )\n    .fetch_all(pool)\n    .await?\n    .into_iter()\n    .map(|r| r.name)\n    .collect();\n\n    let now = Utc::now();\n    let expiration = now + Duration::hours(1);\n\n    let claims = Claims {\n        sub: user_id.to_string(),\n        exp: expiration.timestamp() as usize,\n        iat: now.timestamp() as usize,\n        user_id,\n        username,\n        roles,\n    };\n\n    let token = encode(\n        &Header::default(),\n        &claims,\n        &EncodingKey::from_secret(jwt_secret.as_bytes())\n    )?;\n\n    Ok(token)\n}\n```\n\n## CurrentUser with Roles\n\n```rust\n#[derive(Clone, Debug)]\npub struct CurrentUser {\n    pub user_id: i32,\n    pub username: String,\n    pub roles: Vec<String>,\n}\n\nimpl CurrentUser {\n    pub fn has_role(&self, role: &str) -> bool {\n        self.roles.iter().any(|r| r == role)\n    }\n\n    pub fn is_admin(&self) -> bool {\n        self.has_role(\"admin\")\n    }\n\n    pub fn is_editor(&self) -> bool {\n        self.has_role(\"editor\") || self.is_admin()\n    }\n}\n```\n\n## Role-Based Middleware\n\n### Require Specific Role\n\n```rust\nuse axum::{\n    extract::Request,\n    middleware::Next,\n    response::Response,\n    http::StatusCode,\n};\n\nasync fn require_admin(\n    Extension(user): Extension<CurrentUser>,\n    req: Request,\n    next: Next,\n) -> Result<Response, StatusCode> {\n    if user.is_admin() {\n        Ok(next.run(req).await)\n    } else {\n        Err(StatusCode::FORBIDDEN)\n    }\n}\n\nasync fn require_editor(\n    Extension(user): Extension<CurrentUser>,\n    req: Request,\n    next: Next,\n) -> Result<Response, StatusCode> {\n    if user.is_editor() {\n        Ok(next.run(req).await)\n    } else {\n        Err(StatusCode::FORBIDDEN)\n    }\n}\n```\n\n### Using Role Middleware\n\n```rust\nuse axum::{\n    Router,\n    routing::{get, post, delete},\n    middleware,\n};\n\nfn create_router(state: AppState) -> Router {\n    // Public routes\n    let public = Router::new()\n        .route(\"/login\", post(login))\n        .route(\"/posts\", get(list_posts));\n\n    // User routes (any authenticated user)\n    let user_routes = Router::new()\n        .route(\"/profile\", get(get_profile))\n        .layer(middleware::from_fn_with_state(state.clone(), auth_middleware));\n\n    // Editor routes\n    let editor_routes = Router::new()\n        .route(\"/posts\", post(create_post))\n        .route(\"/posts/{id}\", delete(delete_post))\n        .layer(middleware::from_fn(require_editor))\n        .layer(middleware::from_fn_with_state(state.clone(), auth_middleware));\n\n    // Admin routes\n    let admin_routes = Router::new()\n        .route(\"/users\", get(list_all_users))\n        .route(\"/users/{id}/roles\", post(assign_role))\n        .layer(middleware::from_fn(require_admin))\n        .layer(middleware::from_fn_with_state(state.clone(), auth_middleware));\n\n    Router::new()\n        .merge(public)\n        .merge(user_routes)\n        .nest(\"/admin\", admin_routes)\n        .nest(\"/editor\", editor_routes)\n        .with_state(state)\n}\n```\n\n## Resource-Based Authorization\n\nCheck if user owns a resource:\n\n```rust\nasync fn update_post(\n    State(pool): State<PgPool>,\n    user: CurrentUser,\n    Path(post_id): Path<i32>,\n    Json(update): Json<UpdatePost>,\n) -> Result<Json<Post>, ApiError> {\n    // Get post\n    let post = sqlx::query!(\"SELECT user_id FROM posts WHERE id = $1\", post_id)\n        .fetch_optional(&pool)\n        .await?\n        .ok_or_else(|| ApiError::NotFound(\"Post not found\".into()))?;\n\n    // Check authorization\n    if post.user_id != user.user_id && !user.is_admin() {\n        return Err(ApiError::Forbidden(\"You don't own this post\".into()));\n    }\n\n    // Proceed with update...\n    let updated_post = sqlx::query_as!(\n        Post,\n        \"UPDATE posts SET title = COALESCE($1, title), content = COALESCE($2, content) WHERE id = $3 RETURNING *\",\n        update.title,\n        update.content,\n        post_id\n    )\n    .fetch_one(&pool)\n    .await?;\n\n    Ok(Json(updated_post))\n}\n```\n\n## Permission-Based System\n\nMore granular than roles:\n\n```sql\n-- Permissions table\nCREATE TABLE permissions (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) UNIQUE NOT NULL,\n    description TEXT\n);\n\n-- Role permissions junction\nCREATE TABLE role_permissions (\n    role_id INTEGER REFERENCES roles(id) ON DELETE CASCADE,\n    permission_id INTEGER REFERENCES permissions(id) ON DELETE CASCADE,\n    PRIMARY KEY (role_id, permission_id)\n);\n\n-- Insert permissions\nINSERT INTO permissions (name, description) VALUES\n    ('posts.create', 'Create new posts'),\n    ('posts.edit.own', 'Edit own posts'),\n    ('posts.edit.any', 'Edit any posts'),\n    ('posts.delete.own', 'Delete own posts'),\n    ('posts.delete.any', 'Delete any posts'),\n    ('users.manage', 'Manage users'),\n    ('roles.assign', 'Assign roles to users');\n\n-- Assign permissions to admin role\nINSERT INTO role_permissions (role_id, permission_id)\nSELECT r.id, p.id\nFROM roles r, permissions p\nWHERE r.name = 'admin';\n\n-- Assign some permissions to editor role\nINSERT INTO role_permissions (role_id, permission_id)\nSELECT r.id, p.id\nFROM roles r, permissions p\nWHERE r.name = 'editor'\n  AND p.name IN ('posts.create', 'posts.edit.any', 'posts.delete.own');\n```\n\n### Load Permissions in JWT\n\n```rust\n#[derive(Debug, Serialize, Deserialize)]\nstruct Claims {\n    sub: String,\n    exp: usize,\n    iat: usize,\n    user_id: i32,\n    username: String,\n    permissions: Vec<String>,\n}\n\nasync fn get_user_permissions(user_id: i32, pool: &PgPool) -> Result<Vec<String>, sqlx::Error> {\n    let permissions = sqlx::query!(\n        r#\"\n        SELECT DISTINCT p.name\n        FROM permissions p\n        JOIN role_permissions rp ON p.id = rp.permission_id\n        JOIN user_roles ur ON rp.role_id = ur.role_id\n        WHERE ur.user_id = $1\n        \"#,\n        user_id\n    )\n    .fetch_all(pool)\n    .await?\n    .into_iter()\n    .map(|r| r.name)\n    .collect();\n\n    Ok(permissions)\n}\n```\n\n### Check Permissions\n\n```rust\nimpl CurrentUser {\n    pub fn can(&self, permission: &str) -> bool {\n        self.permissions.iter().any(|p| p == permission)\n    }\n}\n\nasync fn delete_post(\n    State(pool): State<PgPool>,\n    user: CurrentUser,\n    Path(post_id): Path<i32>,\n) -> Result<StatusCode, ApiError> {\n    let post = sqlx::query!(\"SELECT user_id FROM posts WHERE id = $1\", post_id)\n        .fetch_one(&pool)\n        .await?;\n\n    // Check permissions\n    let can_delete = if post.user_id == user.user_id {\n        user.can(\"posts.delete.own\")\n    } else {\n        user.can(\"posts.delete.any\")\n    };\n\n    if !can_delete {\n        return Err(ApiError::Forbidden(\"Insufficient permissions\".into()));\n    }\n\n    sqlx::query!(\"DELETE FROM posts WHERE id = $1\", post_id)\n        .execute(&pool)\n        .await?;\n\n    Ok(StatusCode::NO_CONTENT)\n}\n```\n\n## Role Management Endpoints\n\n### Assign Role to User\n\n```rust\n#[derive(Deserialize)]\nstruct AssignRoleRequest {\n    role_name: String,\n}\n\nasync fn assign_role(\n    State(pool): State<PgPool>,\n    user: CurrentUser,\n    Path(target_user_id): Path<i32>,\n    Json(req): Json<AssignRoleRequest>,\n) -> Result<StatusCode, ApiError> {\n    // Only admins can assign roles\n    if !user.is_admin() {\n        return Err(ApiError::Forbidden(\"Admin access required\".into()));\n    }\n\n    // Get role ID\n    let role = sqlx::query!(\"SELECT id FROM roles WHERE name = $1\", req.role_name)\n        .fetch_optional(&pool)\n        .await?\n        .ok_or_else(|| ApiError::NotFound(\"Role not found\".into()))?;\n\n    // Assign role\n    sqlx::query!(\n        \"INSERT INTO user_roles (user_id, role_id) VALUES ($1, $2) ON CONFLICT DO NOTHING\",\n        target_user_id,\n        role.id\n    )\n    .execute(&pool)\n    .await?;\n\n    Ok(StatusCode::OK)\n}\n\nasync fn remove_role(\n    State(pool): State<PgPool>,\n    user: CurrentUser,\n    Path((target_user_id, role_name)): Path<(i32, String)>,\n) -> Result<StatusCode, ApiError> {\n    if !user.is_admin() {\n        return Err(ApiError::Forbidden(\"Admin access required\".into()));\n    }\n\n    sqlx::query!(\n        r#\"\n        DELETE FROM user_roles\n        WHERE user_id = $1\n          AND role_id = (SELECT id FROM roles WHERE name = $2)\n        \"#,\n        target_user_id,\n        role_name\n    )\n    .execute(&pool)\n    .await?;\n\n    Ok(StatusCode::NO_CONTENT)\n}\n```\n\n## Audit Logging\n\nTrack who does what:\n\n```sql\nCREATE TABLE audit_log (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER REFERENCES users(id),\n    action VARCHAR(100) NOT NULL,\n    resource_type VARCHAR(50),\n    resource_id INTEGER,\n    details JSONB,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE INDEX idx_audit_log_user_id ON audit_log(user_id);\nCREATE INDEX idx_audit_log_created_at ON audit_log(created_at);\n```\n\n```rust\nasync fn log_action(\n    pool: &PgPool,\n    user_id: i32,\n    action: &str,\n    resource_type: Option<&str>,\n    resource_id: Option<i32>,\n    details: Option<serde_json::Value>,\n) -> Result<(), sqlx::Error> {\n    sqlx::query!(\n        r#\"\n        INSERT INTO audit_log (user_id, action, resource_type, resource_id, details)\n        VALUES ($1, $2, $3, $4, $5)\n        \"#,\n        user_id,\n        action,\n        resource_type,\n        resource_id,\n        details\n    )\n    .execute(pool)\n    .await?;\n\n    Ok(())\n}\n\nasync fn delete_post_with_audit(\n    State(pool): State<PgPool>,\n    user: CurrentUser,\n    Path(post_id): Path<i32>,\n) -> Result<StatusCode, ApiError> {\n    // Check permissions and delete...\n\n    // Log the action\n    log_action(\n        &pool,\n        user.user_id,\n        \"delete_post\",\n        Some(\"post\"),\n        Some(post_id),\n        None,\n    )\n    .await?;\n\n    Ok(StatusCode::NO_CONTENT)\n}\n```\n\n## Complete Example\n\n```rust\nmod auth;\nmod models;\n\nuse axum::{\n    Router,\n    routing::{get, post, put, delete},\n    middleware,\n    extract::{State, Path, Extension},\n    http::StatusCode,\n    Json,\n};\n\n#[derive(Clone)]\nstruct AppState {\n    pool: PgPool,\n    jwt_secret: String,\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    dotenvy::dotenv().ok();\n\n    let state = AppState {\n        pool: /* create pool */,\n        jwt_secret: std::env::var(\"JWT_SECRET\")?,\n    };\n\n    let app = Router::new()\n        // Public\n        .route(\"/login\", post(login))\n        .route(\"/register\", post(register))\n        // Authenticated users\n        .route(\"/posts\", get(list_posts))\n        .route(\"/profile\", get(get_profile))\n        .layer(middleware::from_fn_with_state(state.clone(), auth_middleware))\n        // Editor routes\n        .nest(\"/editor\", Router::new()\n            .route(\"/posts\", post(create_post))\n            .route(\"/posts/{id}\", put(update_post).delete(delete_post))\n            .layer(middleware::from_fn(require_editor))\n        )\n        // Admin routes\n        .nest(\"/admin\", Router::new()\n            .route(\"/users\", get(list_all_users))\n            .route(\"/users/{id}/roles\", post(assign_role))\n            .route(\"/users/{id}/roles/{role}\", delete(remove_role))\n            .layer(middleware::from_fn(require_admin))\n        )\n        .with_state(state);\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await?;\n    println!(\"ðŸš€ Server with RBAC running!\");\n\n    axum::serve(listener, app).await?;\n\n    Ok(())\n}\n```\n\n## Testing\n\n```bash\n# Login as admin\nADMIN_TOKEN=$(curl -X POST http://localhost:3000/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"username\":\"admin\",\"password\":\"admin123\"}' \\\n  | jq -r '.token')\n\n# Assign editor role to user 5\ncurl -X POST http://localhost:3000/admin/users/5/roles \\\n  -H \"Authorization: Bearer $ADMIN_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"role_name\":\"editor\"}'\n\n# Try to access admin route as regular user (should fail with 403)\ncurl http://localhost:3000/admin/users \\\n  -H \"Authorization: Bearer $USER_TOKEN\"\n```\n\n## Key Takeaways\n\n- âœ… **Authentication** = Who you are\n- âœ… **Authorization** = What you can do\n- âœ… RBAC = Roles contain permissions\n- âœ… Include roles/permissions in JWT claims\n- âœ… Check permissions in handlers\n- âœ… Use middleware for route-level authorization\n- âœ… Resource-based checks (e.g., owns post)\n- âœ… Audit log for security and compliance\n- âœ… Return 403 Forbidden for unauthorized actions\n\n**Next**: Security best practices and common vulnerabilities!\n\n---\n\n**Progress**: Module 14, Lesson 3 complete (70/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-14-04",
          "title": "Module 14: Authentication & Security",
          "type": "project",
          "estimatedMinutes": 8,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 14: Authentication & Security\n\n# Lesson 4: Security Best Practices & Common Vulnerabilities\n\n## OWASP Top 10 for Web Applications\n\nThe **OWASP Top 10** lists the most critical security risks.\n\n### 1. Broken Access Control\n\n**Problem:** Users can access resources they shouldn't.\n\nâŒ **Vulnerable:**\n```rust\nasync fn delete_post(\n    Path(post_id): Path<i32>,\n) -> StatusCode {\n    // Anyone can delete any post!\n    sqlx::query!(\"DELETE FROM posts WHERE id = $1\", post_id)\n        .execute(&pool)\n        .await?;\n    StatusCode::NO_CONTENT\n}\n```\n\nâœ… **Secure:**\n```rust\nasync fn delete_post(\n    State(pool): State<PgPool>,\n    user: CurrentUser,\n    Path(post_id): Path<i32>,\n) -> Result<StatusCode, ApiError> {\n    // Get post ownership\n    let post = sqlx::query!(\"SELECT user_id FROM posts WHERE id = $1\", post_id)\n        .fetch_one(&pool)\n        .await?;\n\n    // Check authorization\n    if post.user_id != user.user_id && !user.is_admin() {\n        return Err(ApiError::Forbidden(\"Not authorized\".into()));\n    }\n\n    sqlx::query!(\"DELETE FROM posts WHERE id = $1\", post_id)\n        .execute(&pool)\n        .await?;\n\n    Ok(StatusCode::NO_CONTENT)\n}\n```\n\n### 2. SQL Injection\n\n**Problem:** User input executed as SQL code.\n\nâŒ **Vulnerable:**\n```rust\nasync fn search_users(query: String) -> Vec<User> {\n    // NEVER DO THIS!\n    let sql = format!(\"SELECT * FROM users WHERE name = '{}'\", query);\n    sqlx::query(&sql).fetch_all(&pool).await.unwrap()\n}\n\n// Attacker sends: \"'; DROP TABLE users; --\"\n// Executes: SELECT * FROM users WHERE name = ''; DROP TABLE users; --'\n```\n\nâœ… **Secure:**\n```rust\nasync fn search_users(query: String) -> Vec<User> {\n    // Use parameterized queries\n    sqlx::query_as!(\n        User,\n        \"SELECT * FROM users WHERE name LIKE $1\",\n        format!(\"%{}%\", query)\n    )\n    .fetch_all(&pool)\n    .await\n    .unwrap()\n}\n```\n\n**Rust's type system helps!** `query!` and `query_as!` macros prevent SQL injection.\n\n### 3. Cryptographic Failures\n\n**Problem:** Weak encryption, storing sensitive data unencrypted.\n\nâœ… **Best Practices:**\n- Use `argon2` for passwords (never MD5 or SHA1)\n- Use HTTPS in production\n- Store secrets in environment variables\n- Use strong JWT secrets (32+ characters)\n\n```rust\n// Generate strong secret:\n// openssl rand -base64 32\n\nlet jwt_secret = std::env::var(\"JWT_SECRET\")\n    .expect(\"JWT_SECRET must be set\");\n```\n\n### 4. Insecure Design\n\n**Problem:** Flawed architecture from the start.\n\nâœ… **Secure by Design:**\n- Default deny (require explicit authorization)\n- Principle of least privilege\n- Defense in depth (multiple security layers)\n- Fail securely (errors don't reveal info)\n\n### 5. Security Misconfiguration\n\n**Problem:** Leaving default settings, exposing debug info.\n\nâŒ **Vulnerable:**\n```rust\n// Exposing internal error details\nreturn Err(format!(\"Database error: {}\", err));  // Shows SQL error to user!\n```\n\nâœ… **Secure:**\n```rust\n// Generic error message to user\nreturn Err(ApiError::InternalError(\"An error occurred\".into()));\n\n// Log detailed error server-side\neprintln!(\"Database error: {}\", err);\n```\n\n**Production checklist:**\n- [ ] Change default passwords\n- [ ] Disable debug mode\n- [ ] Remove development endpoints\n- [ ] Set up proper CORS\n- [ ] Use environment variables for config\n\n### 6. Vulnerable and Outdated Components\n\n**Problem:** Using libraries with known vulnerabilities.\n\nâœ… **Prevention:**\n```bash\n# Check for vulnerabilities\ncargo audit\n\n# Update dependencies\ncargo update\n```\n\n### 7. Identification and Authentication Failures\n\n**Problem:** Weak authentication mechanisms.\n\nâœ… **Best Practices:**\n- Enforce strong passwords\n- Implement rate limiting\n- Use multi-factor authentication (MFA)\n- Secure session management\n- Prevent brute-force attacks\n\n```rust\n// Password requirements\nfn validate_password(password: &str) -> Result<(), String> {\n    if password.len() < 12 {\n        return Err(\"Password must be at least 12 characters\".into());\n    }\n    if !password.chars().any(|c| c.is_uppercase()) {\n        return Err(\"Password must contain uppercase letter\".into());\n    }\n    if !password.chars().any(|c| c.is_lowercase()) {\n        return Err(\"Password must contain lowercase letter\".into());\n    }\n    if !password.chars().any(|c| c.is_numeric()) {\n        return Err(\"Password must contain number\".into());\n    }\n    if !password.chars().any(|c| \"!@#$%^&*\".contains(c)) {\n        return Err(\"Password must contain special character\".into());\n    }\n    Ok(())\n}\n```\n\n### 8. Software and Data Integrity Failures\n\n**Problem:** Accepting untrusted data without validation.\n\nâœ… **Input Validation:**\n```rust\n#[derive(Deserialize)]\nstruct CreatePost {\n    #[serde(deserialize_with = \"validate_title\")]\n    title: String,\n    content: String,\n}\n\nfn validate_title<'de, D>(deserializer: D) -> Result<String, D::Error>\nwhere\n    D: serde::Deserializer<'de>,\n{\n    let title = String::deserialize(deserializer)?;\n\n    if title.trim().is_empty() {\n        return Err(serde::de::Error::custom(\"Title cannot be empty\"));\n    }\n\n    if title.len() > 255 {\n        return Err(serde::de::Error::custom(\"Title too long\"));\n    }\n\n    // Sanitize HTML/script tags\n    if title.contains('<') || title.contains('>') {\n        return Err(serde::de::Error::custom(\"Title cannot contain HTML\"));\n    }\n\n    Ok(title)\n}\n```\n\n### 9. Security Logging and Monitoring Failures\n\n**Problem:** Not logging security events.\n\nâœ… **Audit Logging:**\n```rust\nasync fn log_security_event(\n    pool: &PgPool,\n    event_type: &str,\n    user_id: Option<i32>,\n    ip_address: &str,\n    details: Option<serde_json::Value>,\n) -> Result<(), sqlx::Error> {\n    sqlx::query!(\n        r#\"\n        INSERT INTO security_log (event_type, user_id, ip_address, details)\n        VALUES ($1, $2, $3, $4)\n        \"#,\n        event_type,\n        user_id,\n        ip_address,\n        details\n    )\n    .execute(pool)\n    .await?;\n\n    Ok(())\n}\n\n// Log failed login attempts\nasync fn login(req: LoginRequest) -> Result<LoginResponse, ApiError> {\n    match authenticate(&req.username, &req.password).await {\n        Ok(user) => {\n            log_security_event(\n                &pool,\n                \"login_success\",\n                Some(user.id),\n                &ip_address,\n                None,\n            ).await?;\n            Ok(user)\n        }\n        Err(e) => {\n            log_security_event(\n                &pool,\n                \"login_failed\",\n                None,\n                &ip_address,\n                Some(json!({\"username\": req.username})),\n            ).await?;\n            Err(e)\n        }\n    }\n}\n```\n\n### 10. Server-Side Request Forgery (SSRF)\n\n**Problem:** Making requests to internal services based on user input.\n\nâŒ **Vulnerable:**\n```rust\nasync fn fetch_url(url: String) -> String {\n    // User could access internal services!\n    // url = \"http://localhost:8080/admin/delete-everything\"\n    reqwest::get(&url).await.unwrap().text().await.unwrap()\n}\n```\n\nâœ… **Secure:**\n```rust\nasync fn fetch_url(url: String) -> Result<String, ApiError> {\n    // Validate URL\n    let parsed = url::Url::parse(&url)\n        .map_err(|_| ApiError::BadRequest(\"Invalid URL\".into()))?;\n\n    // Whitelist allowed hosts\n    let allowed_hosts = [\"api.example.com\", \"cdn.example.com\"];\n    if !allowed_hosts.contains(&parsed.host_str().unwrap_or(\"\")) {\n        return Err(ApiError::BadRequest(\"Host not allowed\".into()));\n    }\n\n    // Blacklist private IPs\n    if parsed.host_str().unwrap_or(\"\").starts_with(\"192.168.\")\n        || parsed.host_str().unwrap_or(\"\").starts_with(\"10.\")\n        || parsed.host_str().unwrap_or(\"\") == \"localhost\"\n    {\n        return Err(ApiError::BadRequest(\"Cannot access private networks\".into()));\n    }\n\n    let response = reqwest::get(url).await?.text().await?;\n    Ok(response)\n}\n```\n\n## Cross-Site Scripting (XSS)\n\n**Problem:** Injecting malicious scripts.\n\nâœ… **Prevention:**\n- Sanitize user input\n- Escape output\n- Use Content Security Policy headers\n\n```rust\nuse ammonia::clean;\n\nfn sanitize_html(input: &str) -> String {\n    // Strip all HTML tags\n    clean(input)\n}\n\nasync fn create_post(Json(req): Json<CreatePost>) -> Result<Json<Post>, ApiError> {\n    let sanitized_content = sanitize_html(&req.content);\n\n    let post = sqlx::query_as!(\n        Post,\n        \"INSERT INTO posts (title, content) VALUES ($1, $2) RETURNING *\",\n        req.title,\n        sanitized_content\n    )\n    .fetch_one(&pool)\n    .await?;\n\n    Ok(Json(post))\n}\n```\n\n## Cross-Site Request Forgery (CSRF)\n\n**Problem:** Forcing users to execute unwanted actions.\n\nâœ… **Prevention with SameSite cookies:**\n```rust\nuse axum::http::header::{SET_COOKIE, HeaderValue};\n\n// Set cookie with SameSite=Strict\nlet cookie = format!(\n    \"session={}; HttpOnly; Secure; SameSite=Strict; Max-Age=3600\",\n    session_id\n);\n\nlet mut headers = HeaderMap::new();\nheaders.insert(SET_COOKIE, HeaderValue::from_str(&cookie)?);\n```\n\n## CORS (Cross-Origin Resource Sharing)\n\nControl which domains can access your API:\n\n```toml\n[dependencies]\ntower-http = { version = \"0.5\", features = [\"cors\"] }\n```\n\n```rust\nuse tower_http::cors::{CorsLayer, Any};\nuse axum::http::Method;\n\nlet cors = CorsLayer::new()\n    .allow_origin(\"https://yourdomain.com\".parse::<HeaderValue>()?)\n    .allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE])\n    .allow_headers(Any)\n    .allow_credentials(true);\n\nlet app = Router::new()\n    .route(\"/api/posts\", get(list_posts))\n    .layer(cors);\n```\n\n## Rate Limiting\n\nPrevent abuse and DDoS:\n\n```toml\n[dependencies]\ntower-governor = \"0.3\"\n```\n\n```rust\nuse tower_governor::{\n    governor::GovernorConfigBuilder,\n    GovernorLayer,\n};\n\n// Allow 100 requests per minute\nlet governor_conf = Box::new(\n    GovernorConfigBuilder::default()\n        .per_second(2)\n        .burst_size(5)\n        .finish()\n        .unwrap(),\n);\n\nlet app = Router::new()\n    .route(\"/api/posts\", get(list_posts))\n    .layer(GovernorLayer {\n        config: Box::leak(governor_conf),\n    });\n```\n\n## Environment Variables Best Practices\n\n```rust\nuse dotenvy::dotenv;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Load .env only in development\n    #[cfg(debug_assertions)]\n    dotenv().ok();\n\n    // Fail fast if required vars missing\n    let database_url = std::env::var(\"DATABASE_URL\")\n        .expect(\"DATABASE_URL must be set\");\n\n    let jwt_secret = std::env::var(\"JWT_SECRET\")\n        .expect(\"JWT_SECRET must be set\");\n\n    // Validate secret strength\n    if jwt_secret.len() < 32 {\n        panic!(\"JWT_SECRET must be at least 32 characters\");\n    }\n\n    // ...\n}\n```\n\n**.env.example** (commit this):\n```env\nDATABASE_URL=postgresql://user:password@localhost:5432/dbname\nJWT_SECRET=your-secret-key-change-in-production\nRUST_LOG=info\n```\n\n**.env** (never commit this):\n```env\nDATABASE_URL=postgresql://prod_user:actual_password@db.example.com:5432/prod_db\nJWT_SECRET=8f3d7e9a2c1b4d6f8e7a9c2b1d4f6e8a7c9b2d1f4e6a8c7b9d2e1f4a6c8e7b9d\nRUST_LOG=warn\n```\n\n## Production Security Checklist\n\n### Before Deployment\n\n- [ ] All secrets in environment variables\n- [ ] Strong password requirements enforced\n- [ ] Rate limiting enabled\n- [ ] CORS configured properly\n- [ ] HTTPS enforced (no HTTP)\n- [ ] SQL injection prevented (use `query!`)\n- [ ] Input validation on all endpoints\n- [ ] Error messages don't leak information\n- [ ] Audit logging enabled\n- [ ] Dependencies updated (`cargo audit`)\n- [ ] No debug/test endpoints in production\n- [ ] JWT secrets are strong (32+ chars)\n- [ ] Password hashing with argon2\n- [ ] CSRF protection enabled\n- [ ] XSS prevention (sanitize HTML)\n- [ ] Role-based access control implemented\n\n### Monitoring\n\n- [ ] Log all authentication events\n- [ ] Monitor for failed login attempts\n- [ ] Alert on suspicious activity\n- [ ] Track API usage patterns\n- [ ] Database query performance monitoring\n\n### Incident Response\n\n- [ ] Backup and recovery procedures\n- [ ] Rollback plan\n- [ ] Security incident response plan\n- [ ] Contact information for security team\n\n## Key Takeaways\n\n- âœ… Follow OWASP Top 10 guidelines\n- âœ… **Never trust user input** - always validate and sanitize\n- âœ… Use parameterized queries (prevents SQL injection)\n- âœ… Hash passwords with argon2\n- âœ… Implement proper authorization checks\n- âœ… Use HTTPS in production\n- âœ… Store secrets in environment variables\n- âœ… Enable rate limiting\n- âœ… Configure CORS properly\n- âœ… Log security events\n- âœ… Keep dependencies updated\n- âœ… Sanitize HTML to prevent XSS\n- âœ… Generic error messages (don't leak info)\n\n**Next**: Complete authentication system practice project!\n\n---\n\n**Progress**: Module 14, Lesson 4 complete (71/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-14-05",
          "title": "Module 14: Authentication & Security",
          "type": "project",
          "estimatedMinutes": 10,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 14: Authentication & Security\n\n# Lesson 5: Practice Project â€” Complete Authentication System\n\n## Project Overview\n\nBuild a production-ready authentication system with:\n- User registration with email verification\n- Login with JWT tokens\n- Role-based access control (RBAC)\n- Password reset functionality\n- Refresh tokens\n- Rate limiting\n- Audit logging\n- Complete blog API with authorization\n\nThis integrates everything from Module 14!\n\n## Project Setup\n\n```bash\ncargo new secure_blog_api\ncd secure_blog_api\n```\n\n### Dependencies\n\n```toml\n[package]\nname = \"secure_blog_api\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\naxum = \"0.8.x\"\ntokio = { version = \"1.x\", features = [\"full\"] }\nsqlx = { version = \"0.8.x\", features = [\"runtime-tokio\", \"postgres\", \"chrono\", \"uuid\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nchrono = { version = \"0.4\", features = [\"serde\"] }\ndotenvy = \"0.15\"\nargon2 = \"0.5\"\njsonwebtoken = \"9\"\nuuid = { version = \"1.0\", features = [\"v4\", \"serde\"] }\ntower-http = { version = \"0.5\", features = [\"cors\", \"trace\"] }\nrand = \"0.8\"\n```\n\n### Database Schema\n\nCreate migration:\n\n```bash\nsqlx database create\nsqlx migrate add complete_auth_system\n```\n\nEdit migration file:\n\n```sql\n-- Users table\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    email_verified BOOLEAN DEFAULT FALSE,\n    failed_login_attempts INTEGER DEFAULT 0,\n    locked_until TIMESTAMP,\n    created_at TIMESTAMP DEFAULT NOW(),\n    updated_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Roles\nCREATE TABLE roles (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL\n);\n\n-- User roles junction\nCREATE TABLE user_roles (\n    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,\n    role_id INTEGER REFERENCES roles(id) ON DELETE CASCADE,\n    PRIMARY KEY (user_id, role_id)\n);\n\n-- Posts\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    title VARCHAR(255) NOT NULL,\n    slug VARCHAR(255) UNIQUE NOT NULL,\n    content TEXT NOT NULL,\n    published BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT NOW(),\n    updated_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Refresh tokens\nCREATE TABLE refresh_tokens (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    token VARCHAR(255) UNIQUE NOT NULL,\n    expires_at TIMESTAMP NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Email verification tokens\nCREATE TABLE email_verification_tokens (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    token VARCHAR(255) UNIQUE NOT NULL,\n    expires_at TIMESTAMP NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Password reset tokens\nCREATE TABLE password_reset_tokens (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    token VARCHAR(255) UNIQUE NOT NULL,\n    expires_at TIMESTAMP NOT NULL,\n    used BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Audit log\nCREATE TABLE audit_log (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER REFERENCES users(id),\n    action VARCHAR(100) NOT NULL,\n    resource_type VARCHAR(50),\n    resource_id INTEGER,\n    ip_address VARCHAR(45),\n    details JSONB,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Indexes\nCREATE INDEX idx_users_email ON users(email);\nCREATE INDEX idx_users_username ON users(username);\nCREATE INDEX idx_posts_user_id ON posts(user_id);\nCREATE INDEX idx_posts_slug ON posts(slug);\nCREATE INDEX idx_posts_published ON posts(published);\nCREATE INDEX idx_refresh_tokens_token ON refresh_tokens(token);\nCREATE INDEX idx_refresh_tokens_user_id ON refresh_tokens(user_id);\nCREATE INDEX idx_audit_log_user_id ON audit_log(user_id);\nCREATE INDEX idx_audit_log_created_at ON audit_log(created_at);\n\n-- Insert default roles\nINSERT INTO roles (name) VALUES ('admin'), ('editor'), ('user');\n\n-- Insert test admin user (password: Admin123!)\nINSERT INTO users (username, email, password_hash, email_verified)\nVALUES (\n    'admin',\n    'admin@example.com',\n    '$argon2id$v=19$m=19456,t=2,p=1$...',  -- Hash of 'Admin123!'\n    true\n);\n\nINSERT INTO user_roles (user_id, role_id)\nSELECT 1, id FROM roles WHERE name = 'admin';\n```\n\nRun migration:\n\n```bash\nsqlx migrate run\n```\n\n## Project Structure\n\n```\nsrc/\nâ”œâ”€â”€ main.rs\nâ”œâ”€â”€ config.rs\nâ”œâ”€â”€ models/\nâ”‚   â”œâ”€â”€ mod.rs\nâ”‚   â”œâ”€â”€ user.rs\nâ”‚   â”œâ”€â”€ post.rs\nâ”‚   â””â”€â”€ claims.rs\nâ”œâ”€â”€ handlers/\nâ”‚   â”œâ”€â”€ mod.rs\nâ”‚   â”œâ”€â”€ auth.rs\nâ”‚   â”œâ”€â”€ posts.rs\nâ”‚   â””â”€â”€ admin.rs\nâ”œâ”€â”€ middleware/\nâ”‚   â”œâ”€â”€ mod.rs\nâ”‚   â”œâ”€â”€ auth.rs\nâ”‚   â””â”€â”€ rate_limit.rs\nâ”œâ”€â”€ utils/\nâ”‚   â”œâ”€â”€ mod.rs\nâ”‚   â”œâ”€â”€ password.rs\nâ”‚   â”œâ”€â”€ jwt.rs\nâ”‚   â”œâ”€â”€ audit.rs\nâ”‚   â””â”€â”€ email.rs\nâ””â”€â”€ errors.rs\n```\n\n## Key Components\n\n### src/config.rs\n\n```rust\nuse serde::Deserialize;\n\n#[derive(Clone, Debug)]\npub struct Config {\n    pub database_url: String,\n    pub jwt_secret: String,\n    pub jwt_expiration_hours: i64,\n    pub refresh_token_days: i64,\n    pub server_host: String,\n    pub server_port: u16,\n}\n\nimpl Config {\n    pub fn from_env() -> Result<Self, Box<dyn std::error::Error>> {\n        dotenvy::dotenv().ok();\n\n        let jwt_secret = std::env::var(\"JWT_SECRET\")?;\n        if jwt_secret.len() < 32 {\n            return Err(\"JWT_SECRET must be at least 32 characters\".into());\n        }\n\n        Ok(Self {\n            database_url: std::env::var(\"DATABASE_URL\")?,\n            jwt_secret,\n            jwt_expiration_hours: std::env::var(\"JWT_EXPIRATION_HOURS\")\n                .unwrap_or_else(|_| \"1\".to_string())\n                .parse()?,\n            refresh_token_days: std::env::var(\"REFRESH_TOKEN_DAYS\")\n                .unwrap_or_else(|_| \"30\".to_string())\n                .parse()?,\n            server_host: std::env::var(\"SERVER_HOST\")\n                .unwrap_or_else(|_| \"0.0.0.0\".to_string()),\n            server_port: std::env::var(\"SERVER_PORT\")\n                .unwrap_or_else(|_| \"3000\".to_string())\n                .parse()?,\n        })\n    }\n}\n```\n\n### src/utils/password.rs\n\n```rust\nuse argon2::{\n    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},\n    Argon2,\n};\n\npub fn hash_password(password: &str) -> Result<String, argon2::password_hash::Error> {\n    let salt = SaltString::generate(&mut OsRng);\n    let argon2 = Argon2::default();\n    let password_hash = argon2.hash_password(password.as_bytes(), &salt)?.to_string();\n    Ok(password_hash)\n}\n\npub fn verify_password(password: &str, hash: &str) -> Result<bool, argon2::password_hash::Error> {\n    let parsed_hash = PasswordHash::new(hash)?;\n    let argon2 = Argon2::default();\n    match argon2.verify_password(password.as_bytes(), &parsed_hash) {\n        Ok(()) => Ok(true),\n        Err(argon2::password_hash::Error::Password) => Ok(false),\n        Err(e) => Err(e),\n    }\n}\n\npub fn validate_password(password: &str) -> Result<(), String> {\n    if password.len() < 8 {\n        return Err(\"Password must be at least 8 characters\".into());\n    }\n    if !password.chars().any(|c| c.is_uppercase()) {\n        return Err(\"Password must contain uppercase letter\".into());\n    }\n    if !password.chars().any(|c| c.is_lowercase()) {\n        return Err(\"Password must contain lowercase letter\".into());\n    }\n    if !password.chars().any(|c| c.is_numeric()) {\n        return Err(\"Password must contain number\".into());\n    }\n    Ok(())\n}\n```\n\n### src/utils/jwt.rs\n\n```rust\nuse chrono::{Duration, Utc};\nuse jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Claims {\n    pub sub: String,\n    pub exp: usize,\n    pub iat: usize,\n    pub user_id: i32,\n    pub username: String,\n    pub roles: Vec<String>,\n}\n\npub fn create_jwt(\n    user_id: i32,\n    username: String,\n    roles: Vec<String>,\n    secret: &str,\n    expiration_hours: i64,\n) -> Result<String, jsonwebtoken::errors::Error> {\n    let now = Utc::now();\n    let expiration = now + Duration::hours(expiration_hours);\n\n    let claims = Claims {\n        sub: user_id.to_string(),\n        exp: expiration.timestamp() as usize,\n        iat: now.timestamp() as usize,\n        user_id,\n        username,\n        roles,\n    };\n\n    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_bytes()))\n}\n\npub fn verify_jwt(token: &str, secret: &str) -> Result<Claims, jsonwebtoken::errors::Error> {\n    let token_data = decode::<Claims>(\n        token,\n        &DecodingKey::from_secret(secret.as_bytes()),\n        &Validation::default(),\n    )?;\n\n    Ok(token_data.claims)\n}\n```\n\n### src/handlers/auth.rs (Complete)\n\n```rust\nuse axum::{extract::State, http::StatusCode, Json};\nuse chrono::{Duration, Utc};\nuse serde::{Deserialize, Serialize};\nuse sqlx::PgPool;\nuse uuid::Uuid;\n\nuse crate::{\n    config::Config,\n    errors::ApiError,\n    models::user::User,\n    utils::{audit, jwt, password},\n};\n\n#[derive(Deserialize)]\npub struct RegisterRequest {\n    pub username: String,\n    pub email: String,\n    pub password: String,\n}\n\n#[derive(Serialize)]\npub struct RegisterResponse {\n    pub user: UserResponse,\n    pub message: String,\n}\n\n#[derive(Serialize)]\npub struct UserResponse {\n    pub id: i32,\n    pub username: String,\n    pub email: String,\n    pub email_verified: bool,\n}\n\npub async fn register(\n    State(pool): State<PgPool>,\n    Json(req): Json<RegisterRequest>,\n) -> Result<(StatusCode, Json<RegisterResponse>), ApiError> {\n    // Validate password\n    password::validate_password(&req.password)\n        .map_err(|e| ApiError::BadRequest(e))?;\n\n    // Hash password\n    let password_hash = password::hash_password(&req.password)\n        .map_err(|_| ApiError::InternalError(\"Failed to hash password\".into()))?;\n\n    // Insert user\n    let user = sqlx::query_as!(\n        User,\n        r#\"\n        INSERT INTO users (username, email, password_hash)\n        VALUES ($1, $2, $3)\n        RETURNING id, username, email, password_hash, email_verified,\n                  failed_login_attempts, locked_until, created_at, updated_at\n        \"#,\n        req.username,\n        req.email,\n        password_hash\n    )\n    .fetch_one(&pool)\n    .await\n    .map_err(|e| match e {\n        sqlx::Error::Database(db_err) if db_err.is_unique_violation() => {\n            ApiError::BadRequest(\"Username or email already exists\".into())\n        }\n        _ => ApiError::from(e),\n    })?;\n\n    // Assign default 'user' role\n    sqlx::query!(\n        \"INSERT INTO user_roles (user_id, role_id) SELECT $1, id FROM roles WHERE name = 'user'\",\n        user.id\n    )\n    .execute(&pool)\n    .await?;\n\n    // Create email verification token\n    let verification_token = Uuid::new_v4().to_string();\n    let expires_at = Utc::now() + Duration::hours(24);\n\n    sqlx::query!(\n        \"INSERT INTO email_verification_tokens (user_id, token, expires_at) VALUES ($1, $2, $3)\",\n        user.id,\n        verification_token,\n        expires_at.naive_utc()\n    )\n    .execute(&pool)\n    .await?;\n\n    // In production: Send email with verification link\n    // send_verification_email(&user.email, &verification_token).await?;\n\n    Ok((\n        StatusCode::CREATED,\n        Json(RegisterResponse {\n            user: UserResponse {\n                id: user.id,\n                username: user.username,\n                email: user.email,\n                email_verified: user.email_verified,\n            },\n            message: \"Registration successful. Please verify your email.\".to_string(),\n        }),\n    ))\n}\n\n#[derive(Deserialize)]\npub struct LoginRequest {\n    pub username: String,\n    pub password: String,\n}\n\n#[derive(Serialize)]\npub struct LoginResponse {\n    pub access_token: String,\n    pub refresh_token: String,\n    pub user: UserResponse,\n}\n\npub async fn login(\n    State(pool): State<PgPool>,\n    State(config): State<Config>,\n    Json(req): Json<LoginRequest>,\n) -> Result<Json<LoginResponse>, ApiError> {\n    // Get user\n    let user = sqlx::query_as!(\n        User,\n        \"SELECT * FROM users WHERE username = $1\",\n        req.username\n    )\n    .fetch_optional(&pool)\n    .await?\n    .ok_or_else(|| ApiError::Unauthorized(\"Invalid credentials\".into()))?;\n\n    // Check if account is locked\n    if let Some(locked_until) = user.locked_until {\n        if locked_until.and_utc() > Utc::now() {\n            return Err(ApiError::Forbidden(\"Account is locked\".into()));\n        }\n    }\n\n    // Verify password\n    let is_valid = password::verify_password(&req.password, &user.password_hash)\n        .map_err(|_| ApiError::InternalError(\"Password verification failed\".into()))?;\n\n    if !is_valid {\n        // Increment failed attempts\n        let new_attempts = user.failed_login_attempts + 1;\n        let locked_until = if new_attempts >= 5 {\n            Some(Utc::now() + Duration::minutes(15))\n        } else {\n            None\n        };\n\n        sqlx::query!(\n            \"UPDATE users SET failed_login_attempts = $1, locked_until = $2 WHERE id = $3\",\n            new_attempts,\n            locked_until.map(|dt| dt.naive_utc()),\n            user.id\n        )\n        .execute(&pool)\n        .await?;\n\n        return Err(ApiError::Unauthorized(\"Invalid credentials\".into()));\n    }\n\n    // Reset failed attempts on successful login\n    sqlx::query!(\n        \"UPDATE users SET failed_login_attempts = 0, locked_until = NULL WHERE id = $1\",\n        user.id\n    )\n    .execute(&pool)\n    .await?;\n\n    // Get user roles\n    let roles = sqlx::query!(\n        r#\"\n        SELECT r.name FROM roles r\n        JOIN user_roles ur ON r.id = ur.role_id\n        WHERE ur.user_id = $1\n        \"#,\n        user.id\n    )\n    .fetch_all(&pool)\n    .await?\n    .into_iter()\n    .map(|r| r.name)\n    .collect();\n\n    // Create JWT\n    let access_token = jwt::create_jwt(\n        user.id,\n        user.username.clone(),\n        roles,\n        &config.jwt_secret,\n        config.jwt_expiration_hours,\n    )\n    .map_err(|_| ApiError::InternalError(\"Failed to create token\".into()))?;\n\n    // Create refresh token\n    let refresh_token = Uuid::new_v4().to_string();\n    let expires_at = Utc::now() + Duration::days(config.refresh_token_days);\n\n    sqlx::query!(\n        \"INSERT INTO refresh_tokens (user_id, token, expires_at) VALUES ($1, $2, $3)\",\n        user.id,\n        refresh_token,\n        expires_at.naive_utc()\n    )\n    .execute(&pool)\n    .await?;\n\n    Ok(Json(LoginResponse {\n        access_token,\n        refresh_token,\n        user: UserResponse {\n            id: user.id,\n            username: user.username,\n            email: user.email,\n            email_verified: user.email_verified,\n        },\n    }))\n}\n```\n\n### src/middleware/auth.rs\n\n```rust\nuse axum::{\n    extract::{Request, State},\n    http::{header, StatusCode},\n    middleware::Next,\n    response::Response,\n};\n\nuse crate::{config::Config, models::user::CurrentUser, utils::jwt};\n\npub async fn auth_middleware(\n    State(config): State<Config>,\n    mut req: Request,\n    next: Next,\n) -> Result<Response, StatusCode> {\n    let token = req\n        .headers()\n        .get(header::AUTHORIZATION)\n        .and_then(|h| h.to_str().ok())\n        .and_then(|h| h.strip_prefix(\"Bearer \"))\n        .ok_or(StatusCode::UNAUTHORIZED)?;\n\n    let claims = jwt::verify_jwt(token, &config.jwt_secret).map_err(|_| StatusCode::UNAUTHORIZED)?;\n\n    req.extensions_mut().insert(CurrentUser {\n        user_id: claims.user_id,\n        username: claims.username,\n        roles: claims.roles,\n    });\n\n    Ok(next.run(req).await)\n}\n\npub async fn require_role(\n    role: String,\n    Extension(user): Extension<CurrentUser>,\n    req: Request,\n    next: Next,\n) -> Result<Response, StatusCode> {\n    if user.has_role(&role) {\n        Ok(next.run(req).await)\n    } else {\n        Err(StatusCode::FORBIDDEN)\n    }\n}\n```\n\n## Testing the Complete System\n\n```bash\n# 1. Register\ncurl -X POST http://localhost:3000/auth/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"username\": \"testuser\",\n    \"email\": \"test@example.com\",\n    \"password\": \"SecurePass123\"\n  }'\n\n# 2. Login\nLOGIN_RESPONSE=$(curl -X POST http://localhost:3000/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"username\": \"testuser\",\n    \"password\": \"SecurePass123\"\n  }')\n\nTOKEN=$(echo $LOGIN_RESPONSE | jq -r '.access_token')\nREFRESH=$(echo $LOGIN_RESPONSE | jq -r '.refresh_token')\n\n# 3. Access protected route\ncurl http://localhost:3000/posts \\\n  -H \"Authorization: Bearer $TOKEN\"\n\n# 4. Create post (requires authentication)\ncurl -X POST http://localhost:3000/posts \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"My First Post\",\n    \"content\": \"This is the content\"\n  }'\n\n# 5. Refresh access token\ncurl -X POST http://localhost:3000/auth/refresh \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\\\"refresh_token\\\": \\\"$REFRESH\\\"}\"\n\n# 6. Admin endpoint (will fail for non-admin)\ncurl http://localhost:3000/admin/users \\\n  -H \"Authorization: Bearer $TOKEN\"\n```\n\n## Key Features Implemented\n\nâœ… User registration with validation\nâœ… Secure password hashing (Argon2)\nâœ… Email verification tokens\nâœ… Login with JWT\nâœ… Refresh tokens (30-day expiry)\nâœ… Role-based access control\nâœ… Account lockout after failed attempts\nâœ… Password reset functionality\nâœ… Audit logging\nâœ… Rate limiting\nâœ… CORS configuration\nâœ… Input validation\nâœ… SQL injection prevention\nâœ… Authorization checks\n\n## Challenge Extensions\n\nAdd these features:\n\n1. **Email service integration** - Actually send verification emails\n2. **Two-factor authentication (2FA)** - TOTP codes\n3. **OAuth integration** - Login with Google/GitHub\n4. **Session management** - View active sessions, logout all devices\n5. **API key authentication** - For programmatic access\n6. **Webhook notifications** - Security events\n\n## Key Takeaways\n\n- âœ… Complete production-ready auth system\n- âœ… Multiple layers of security\n- âœ… Proper password handling\n- âœ… JWT with refresh tokens\n- âœ… Role-based authorization\n- âœ… Account protection (lockout, rate limiting)\n- âœ… Audit logging for security\n- âœ… Environment-based configuration\n- âœ… Database-backed everything (persistent)\n\n**Module 14 Complete!** You now have a solid understanding of authentication and security in Rust web applications.\n\n---\n\n**Progress**: Module 14 complete! (72/90+ lessons total)\n"
          }
        }
      ]
    },
    {
      "id": "module-15",
      "title": "MODULE 15",
      "description": "Module 15",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-15-01",
          "title": "Module 15: Advanced API Development",
          "type": "reading",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 15: Advanced API Development\n\n# Lesson 1: Middleware & Request/Response Processing\n\n## What is Middleware?\n\n**Middleware** processes requests before they reach handlers and responses before they reach clients.\n\n### Tower Layer System\n\nAxum uses **Tower** for middleware. Middleware can:\n- Log requests\n- Add headers\n- Authenticate users\n- Transform requests/responses\n- Handle errors\n\n## Built-in Middleware\n\n### Logging\n\n```toml\n[dependencies]\ntower-http = { version = \"0.5\", features = [\"trace\"] }\ntracing = \"0.1\"\ntracing-subscriber = \"0.3\"\n```\n\n```rust\nuse tower_http::trace::TraceLayer;\nuse tracing_subscriber;\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::fmt::init();\n\n    let app = Router::new()\n        .route(\"/\", get(handler))\n        .layer(TraceLayer::new_for_http());\n\n    // Logs every request!\n}\n```\n\n### CORS\n\n```rust\nuse tower_http::cors::{CorsLayer, Any};\n\nlet cors = CorsLayer::new()\n    .allow_origin(Any)\n    .allow_methods(Any)\n    .allow_headers(Any);\n\nlet app = Router::new()\n    .route(\"/api/data\", get(get_data))\n    .layer(cors);\n```\n\n### Compression\n\n```rust\nuse tower_http::compression::CompressionLayer;\n\nlet app = Router::new()\n    .route(\"/api/data\", get(get_large_data))\n    .layer(CompressionLayer::new());  // Gzip compression\n```\n\n## Custom Middleware\n\n### Request ID Middleware\n\n```rust\nuse axum::{\n    extract::Request,\n    middleware::Next,\n    response::Response,\n    http::header,\n};\nuse uuid::Uuid;\n\nasync fn request_id_middleware(\n    mut req: Request,\n    next: Next,\n) -> Response {\n    let request_id = Uuid::new_v4().to_string();\n\n    // Add to request\n    req.extensions_mut().insert(request_id.clone());\n\n    // Process request\n    let mut response = next.run(req).await;\n\n    // Add to response headers\n    response.headers_mut().insert(\n        \"X-Request-ID\",\n        request_id.parse().unwrap(),\n    );\n\n    response\n}\n\n// Use it\nlet app = Router::new()\n    .route(\"/\", get(handler))\n    .layer(middleware::from_fn(request_id_middleware));\n```\n\n### Timing Middleware\n\n```rust\nuse std::time::Instant;\n\nasync fn timing_middleware(req: Request, next: Next) -> Response {\n    let start = Instant::now();\n    let path = req.uri().path().to_owned();\n\n    let response = next.run(req).await;\n\n    let duration = start.elapsed();\n    println!(\"{} took {:?}\", path, duration);\n\n    response\n}\n```\n\n## State in Middleware\n\n```rust\n#[derive(Clone)]\nstruct AppState {\n    db: PgPool,\n    config: Config,\n}\n\nasync fn db_middleware(\n    State(state): State<AppState>,\n    req: Request,\n    next: Next,\n) -> Response {\n    // Use state.db in middleware\n    next.run(req).await\n}\n\nlet app = Router::new()\n    .route(\"/\", get(handler))\n    .layer(middleware::from_fn_with_state(state.clone(), db_middleware))\n    .with_state(state);\n```\n\n## Response Interceptors\n\n```rust\nasync fn add_server_header(\n    req: Request,\n    next: Next,\n) -> Response {\n    let mut response = next.run(req).await;\n\n    response.headers_mut().insert(\n        \"Server\",\n        \"MyAPI/1.0\".parse().unwrap(),\n    );\n\n    response\n}\n```\n\n## Error Handling Middleware\n\n```rust\nasync fn error_handler(\n    req: Request,\n    next: Next,\n) -> Result<Response, StatusCode> {\n    match next.run(req).await.status() {\n        status if status.is_server_error() => {\n            println!(\"Server error occurred\");\n            Err(StatusCode::INTERNAL_SERVER_ERROR)\n        }\n        _ => Ok(next.run(req).await),\n    }\n}\n```\n\n## Layer Ordering\n\nLayers wrap in reverse order:\n\n```rust\nlet app = Router::new()\n    .route(\"/\", get(handler))\n    .layer(layer3)  // Runs third (outermost)\n    .layer(layer2)  // Runs second\n    .layer(layer1); // Runs first (innermost)\n\n// Request flow: layer3 â†’ layer2 â†’ layer1 â†’ handler â†’ layer1 â†’ layer2 â†’ layer3\n```\n\n## Key Takeaways\n\n- âœ… Middleware processes requests/responses\n- âœ… Tower provides composable layers\n- âœ… Built-in: logging, CORS, compression\n- âœ… Custom middleware with `from_fn`\n- âœ… Access state in middleware\n- âœ… Layer ordering matters!\n\n**Next**: API versioning and documentation!\n\n---\n\n**Progress**: Module 15, Lesson 1 complete (73/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-15-02",
          "title": "Module 15: Advanced API Development",
          "type": "reading",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 15: Advanced API Development\n\n# Lesson 2: API Versioning & Documentation\n\n## API Versioning\n\nHandle breaking changes gracefully.\n\n### URL Path Versioning\n\n```rust\nlet v1_routes = Router::new()\n    .route(\"/users\", get(v1::list_users));\n\nlet v2_routes = Router::new()\n    .route(\"/users\", get(v2::list_users));\n\nlet app = Router::new()\n    .nest(\"/api/v1\", v1_routes)\n    .nest(\"/api/v2\", v2_routes);\n```\n\n### Header Versioning\n\n```rust\nasync fn version_middleware(req: Request, next: Next) -> Result<Response, StatusCode> {\n    let version = req\n        .headers()\n        .get(\"API-Version\")\n        .and_then(|v| v.to_str().ok())\n        .unwrap_or(\"v1\");\n\n    req.extensions_mut().insert(version.to_string());\n    Ok(next.run(req).await)\n}\n```\n\n## OpenAPI Documentation\n\n```toml\n[dependencies]\nutoipa = { version = \"4\", features = [\"axum_extras\"] }\nutoipa-swagger-ui = { version = \"6\", features = [\"axum\"] }\n```\n\n```rust\nuse utoipa::{OpenApi, ToSchema};\nuse utoipa_swagger_ui::SwaggerUi;\n\n#[derive(ToSchema, Serialize)]\nstruct User {\n    id: i32,\n    username: String,\n}\n\n#[utoipa::path(\n    get,\n    path = \"/users\",\n    responses(\n        (status = 200, description = \"List all users\", body = Vec<User>)\n    )\n)]\nasync fn list_users() -> Json<Vec<User>> {\n    // ...\n}\n\n#[derive(OpenApi)]\n#[openapi(\n    paths(list_users),\n    components(schemas(User))\n)]\nstruct ApiDoc;\n\nlet app = Router::new()\n    .merge(SwaggerUi::new(\"/swagger-ui\")\n        .url(\"/api-docs/openapi.json\", ApiDoc::openapi()));\n```\n\nVisit `http://localhost:3000/swagger-ui` for interactive docs!\n\n## Key Takeaways\n\n- âœ… Version APIs to handle breaking changes\n- âœ… Use URL paths or headers for versions\n- âœ… Auto-generate OpenAPI docs\n- âœ… Swagger UI for interactive testing\n\n**Next**: WebSockets and real-time features!\n\n---\n\n**Progress**: Module 15, Lesson 2 complete (74/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-15-03",
          "title": "Module 15: Advanced API Development",
          "type": "reading",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 15: Advanced API Development\n\n# Lesson 3: WebSockets & Real-Time Communication\n\n## What are WebSockets?\n\nBi-directional, persistent connections for real-time data.\n\n### Setup\n\n```toml\n[dependencies]\naxum = { version = \"0.8\", features = [\"ws\"] }\n```\n\n### Basic WebSocket Handler\n\n```rust\nuse axum::{\n    extract::ws::{WebSocket, WebSocketUpgrade},\n    response::Response,\n};\n\nasync fn ws_handler(ws: WebSocketUpgrade) -> Response {\n    ws.on_upgrade(handle_socket)\n}\n\nasync fn handle_socket(mut socket: WebSocket) {\n    while let Some(msg) = socket.recv().await {\n        if let Ok(msg) = msg {\n            // Echo back\n            if socket.send(msg).await.is_err() {\n                break;\n            }\n        }\n    }\n}\n\nlet app = Router::new()\n    .route(\"/ws\", get(ws_handler));\n```\n\n### Chat Room Example\n\n```rust\nuse std::sync::Arc;\nuse tokio::sync::broadcast;\n\ntype Tx = broadcast::Sender<String>;\n\nasync fn chat_handler(\n    ws: WebSocketUpgrade,\n    State(tx): State<Arc<Tx>>,\n) -> Response {\n    ws.on_upgrade(|socket| handle_chat(socket, tx))\n}\n\nasync fn handle_chat(socket: WebSocket, tx: Arc<Tx>) {\n    let (mut sender, mut receiver) = socket.split();\n    let mut rx = tx.subscribe();\n\n    // Send messages from broadcast to client\n    let mut send_task = tokio::spawn(async move {\n        while let Ok(msg) = rx.recv().await {\n            if sender.send(Message::Text(msg)).await.is_err() {\n                break;\n            }\n        }\n    });\n\n    // Receive from client and broadcast\n    let tx2 = tx.clone();\n    let mut recv_task = tokio::spawn(async move {\n        while let Some(Ok(Message::Text(text))) = receiver.next().await {\n            let _ = tx2.send(text);\n        }\n    });\n\n    // Wait for either task to finish\n    tokio::select! {\n        _ = (&mut send_task) => recv_task.abort(),\n        _ = (&mut recv_task) => send_task.abort(),\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let (tx, _rx) = broadcast::channel(100);\n    let app_state = Arc::new(tx);\n\n    let app = Router::new()\n        .route(\"/ws\", get(chat_handler))\n        .with_state(app_state);\n\n    // ...\n}\n```\n\n### Client Example (JavaScript)\n\n```javascript\nconst ws = new WebSocket('ws://localhost:3000/ws');\n\nws.onmessage = (event) => {\n    console.log('Received:', event.data);\n};\n\nws.send('Hello from client!');\n```\n\n## Server-Sent Events (SSE)\n\nOne-way streaming from server to client:\n\n```rust\nuse axum::{\n    response::sse::{Event, Sse},\n    response::IntoResponse,\n};\nuse tokio_stream::StreamExt as _;\nuse std::convert::Infallible;\n\nasync fn sse_handler() -> Sse<impl Stream<Item = Result<Event, Infallible>>> {\n    let stream = tokio_stream::iter(0..)\n        .throttle(Duration::from_secs(1))\n        .map(|i| Ok(Event::default().data(format!(\"Event {}\", i))));\n\n    Sse::new(stream)\n}\n```\n\n## Key Takeaways\n\n- âœ… WebSockets for bi-directional real-time\n- âœ… SSE for server-to-client streaming\n- âœ… Broadcast channels for chat/notifications\n- âœ… Use tokio for async handling\n\n**Module 15 Complete!**\n\n---\n\n**Progress**: Module 15 complete! (75/90+ lessons total)\n"
          }
        }
      ]
    },
    {
      "id": "module-16",
      "title": "MODULE 16",
      "description": "Module 16",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-16-01",
          "title": "Module 16: Testing & Quality",
          "type": "reading",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 16: Testing & Quality\n\n# Lesson 1: Unit & Integration Testing\n\n## Unit Tests\n\nTest individual functions:\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 2), 4);\n    }\n\n    #[test]\n    fn test_user_validation() {\n        assert!(validate_email(\"test@example.com\"));\n        assert!(!validate_email(\"invalid\"));\n    }\n}\n```\n\n## Testing Database Code\n\n```toml\n[dev-dependencies]\nsqlx = { version = \"0.8.x\", features = [\"runtime-tokio\", \"postgres\"] }\n```\n\n```rust\n#[sqlx::test]\nasync fn test_create_user(pool: PgPool) -> sqlx::Result<()> {\n    let user = create_user(&pool, \"testuser\", \"test@example.com\").await?;\n    assert_eq!(user.username, \"testuser\");\n    Ok(())\n}\n```\n\n## Testing API Endpoints\n\n```toml\n[dev-dependencies]\naxum-test = \"14\"\n```\n\n```rust\nuse axum_test::TestServer;\n\n#[tokio::test]\nasync fn test_list_posts() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.get(\"/posts\").await;\n    response.assert_status_ok();\n    response.assert_json(&vec![/* expected posts */]);\n}\n\n#[tokio::test]\nasync fn test_auth_required() {\n    let app = create_app();\n    let server = TestServer::new(app).unwrap();\n\n    let response = server.post(\"/posts\")\n        .json(&json!({\"title\": \"Test\"}))\n        .await;\n\n    response.assert_status(StatusCode::UNAUTHORIZED);\n}\n```\n\n## Key Takeaways\n\n- âœ… Unit tests for functions\n- âœ… `#[sqlx::test]` for database tests\n- âœ… axum-test for API testing\n- âœ… Test authentication and authorization\n\n**Next**: API documentation and code quality!\n\n---\n\n**Progress**: Module 16, Lesson 1 complete (76/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-16-02",
          "title": "Module 16: Testing & Quality",
          "type": "reading",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 16: Testing & Quality\n\n# Lesson 2: Documentation & Code Quality\n\n## Doc Comments\n\n```rust\n/// Creates a new user in the database.\n///\n/// # Arguments\n///\n/// * `username` - The user's username\n/// * `email` - The user's email address\n///\n/// # Example\n///\n/// ```\n/// let user = create_user(\"alice\", \"alice@example.com\").await?;\n/// ```\n///\n/// # Errors\n///\n/// Returns an error if the username or email already exists.\npub async fn create_user(username: &str, email: &str) -> Result<User, ApiError> {\n    // ...\n}\n```\n\nGenerate docs:\n\n```bash\ncargo doc --open\n```\n\n## Clippy (Linter)\n\n```bash\ncargo clippy\n\n# Fix automatically\ncargo clippy --fix\n```\n\n## Formatting\n\n```bash\ncargo fmt\n\n# Check formatting\ncargo fmt -- --check\n```\n\n## Pre-commit Hooks\n\nCreate `.git/hooks/pre-commit`:\n\n```bash\n#!/bin/sh\ncargo fmt -- --check\ncargo clippy -- -D warnings\ncargo test\n```\n\n## Key Takeaways\n\n- âœ… Document public APIs\n- âœ… Run `cargo doc` for HTML docs\n- âœ… Use clippy for linting\n- âœ… Format with `cargo fmt`\n- âœ… Set up pre-commit hooks\n\n**Next**: Benchmarking and performance!\n\n---\n\n**Progress**: Module 16, Lesson 2 complete (77/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-16-03",
          "title": "Module 16: Testing & Quality",
          "type": "reading",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 16: Testing & Quality\n\n# Lesson 3: Performance & Benchmarking\n\n## Benchmarking with Criterion\n\n```toml\n[dev-dependencies]\ncriterion = \"0.5\"\n\n[[bench]]\nname = \"my_benchmark\"\nharness = false\n```\n\n`benches/my_benchmark.rs`:\n\n```rust\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nfn fibonacci(n: u64) -> u64 {\n    match n {\n        0 => 1,\n        1 => 1,\n        n => fibonacci(n-1) + fibonacci(n-2),\n    }\n}\n\nfn criterion_benchmark(c: &mut Criterion) {\n    c.bench_function(\"fib 20\", |b| b.iter(|| fibonacci(black_box(20))));\n}\n\ncriterion_group!(benches, criterion_benchmark);\ncriterion_main!(benches);\n```\n\nRun:\n\n```bash\ncargo bench\n```\n\n## Database Connection Pooling\n\n```rust\nlet pool = PgPoolOptions::new()\n    .max_connections(20)       // Increase for high traffic\n    .min_connections(5)        // Keep some connections warm\n    .acquire_timeout(Duration::from_secs(3))\n    .connect(&database_url)\n    .await?;\n```\n\n## Caching\n\n```rust\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse std::collections::HashMap;\n\n#[derive(Clone)]\nstruct Cache {\n    data: Arc<RwLock<HashMap<String, String>>>,\n}\n\nimpl Cache {\n    async fn get(&self, key: &str) -> Option<String> {\n        self.data.read().await.get(key).cloned()\n    }\n\n    async fn set(&self, key: String, value: String) {\n        self.data.write().await.insert(key, value);\n    }\n}\n```\n\n## Profiling\n\n```bash\n# Install flamegraph\ncargo install flamegraph\n\n# Generate flamegraph\ncargo flamegraph --bin my_api\n```\n\n## Key Takeaways\n\n- âœ… Benchmark with criterion\n- âœ… Optimize database connection pools\n- âœ… Use caching for expensive operations\n- âœ… Profile with flamegraph\n\n**Module 16 Complete!**\n\n---\n\n**Progress**: Module 16 complete! (78/90+ lessons total)\n"
          }
        }
      ]
    },
    {
      "id": "module-17",
      "title": "MODULE 17",
      "description": "Module 17",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-17-01",
          "title": "Module 17: Production Deployment",
          "type": "reading",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 17: Production Deployment\n\n# Lesson 1: Docker & Containerization\n\n## Dockerfile for Rust\n\n```dockerfile\n# Build stage\nFROM rust:1.75 as builder\n\nWORKDIR /app\nCOPY . .\n\n# Build release binary\nRUN cargo build --release\n\n# Runtime stage\nFROM debian:bookworm-slim\n\nRUN apt-get update && apt-get install -y \\\n    ca-certificates \\\n    && rm -rf /var/lib/apt/lists/*\n\nWORKDIR /app\n\nCOPY --from=builder /app/target/release/my_api /app/my_api\n\nEXPOSE 3000\n\nCMD [\"./my_api\"]\n```\n\n## Docker Compose\n\n```yaml\nversion: '3.8'\n\nservices:\n  api:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - DATABASE_URL=postgresql://user:pass@db:5432/mydb\n      - JWT_SECRET=${JWT_SECRET}\n    depends_on:\n      - db\n\n  db:\n    image: postgres:15\n    environment:\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=pass\n      - POSTGRES_DB=mydb\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\nvolumes:\n  postgres_data:\n```\n\nBuild and run:\n\n```bash\ndocker-compose up --build\n```\n\n## Multi-stage Optimization\n\n```dockerfile\n# Use Alpine for smaller image\nFROM rust:1.75-alpine as builder\n\nRUN apk add --no-cache musl-dev\n\nWORKDIR /app\nCOPY Cargo.* ./\nCOPY src ./src\n\nRUN cargo build --release --target x86_64-unknown-linux-musl\n\nFROM alpine:latest\n\nCOPY --from=builder /app/target/x86_64-unknown-linux-musl/release/my_api /app/my_api\n\nEXPOSE 3000\nCMD [\"/app/my_api\"]\n```\n\n## Key Takeaways\n\n- âœ… Multi-stage builds reduce image size\n- âœ… Docker Compose for local development\n- âœ… Use Alpine for minimal images\n- âœ… Separate build and runtime stages\n\n**Next**: Deployment to cloud platforms!\n\n---\n\n**Progress**: Module 17, Lesson 1 complete (79/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-17-02",
          "title": "Module 17: Production Deployment",
          "type": "reading",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 17: Production Deployment\n\n# Lesson 2: Cloud Deployment\n\n## Deploying to Fly.io\n\n```bash\n# Install flyctl\ncurl -L https://fly.io/install.sh | sh\n\n# Login\nflyctl auth login\n\n# Initialize\nflyctl launch\n\n# Deploy\nflyctl deploy\n```\n\n`fly.toml`:\n\n```toml\napp = \"my-rust-api\"\n\n[build]\n  builder = \"paketobuildpacks/builder:base\"\n\n[env]\n  PORT = \"8080\"\n\n[[services]]\n  internal_port = 8080\n  protocol = \"tcp\"\n\n  [[services.ports]]\n    handlers = [\"http\"]\n    port = 80\n\n  [[services.ports]]\n    handlers = [\"tls\", \"http\"]\n    port = 443\n```\n\n## Railway\n\n```bash\nrailway login\nrailway init\nrailway up\n```\n\n## AWS ECS / Fargate\n\nDeploy Docker container to AWS:\n\n```bash\n# Build and push to ECR\naws ecr get-login-password | docker login --username AWS --password-stdin ECR_URL\ndocker build -t my-api .\ndocker tag my-api:latest ECR_URL/my-api:latest\ndocker push ECR_URL/my-api:latest\n\n# Deploy to ECS\naws ecs update-service --cluster my-cluster --service my-service --force-new-deployment\n```\n\n## Environment Variables\n\nUse secrets manager:\n\n```bash\n# Set secrets on Fly.io\nflyctl secrets set JWT_SECRET=your-secret DATABASE_URL=postgres://...\n```\n\n## Health Checks\n\n```rust\nasync fn health_check() -> &'static str {\n    \"OK\"\n}\n\nlet app = Router::new()\n    .route(\"/health\", get(health_check))\n    // ...\n```\n\n## Key Takeaways\n\n- âœ… Fly.io for easy deployment\n- âœ… Railway for quick deploys\n- âœ… AWS ECS for production scale\n- âœ… Use secret managers for credentials\n- âœ… Implement health checks\n\n**Next**: Monitoring and observability!\n\n---\n\n**Progress**: Module 17, Lesson 2 complete (80/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-17-03",
          "title": "Module 17: Production Deployment",
          "type": "reading",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 17: Production Deployment\n\n# Lesson 3: Monitoring & Observability\n\n## Logging with Tracing\n\n```toml\n[dependencies]\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\n```\n\n```rust\nuse tracing::{info, warn, error};\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::fmt()\n        .with_env_filter(\"info,my_api=debug\")\n        .init();\n\n    info!(\"Starting server\");\n\n    // ...\n}\n\nasync fn create_user(username: &str) -> Result<User, Error> {\n    info!(username = %username, \"Creating user\");\n\n    match create_user_in_db(username).await {\n        Ok(user) => {\n            info!(user_id = user.id, \"User created successfully\");\n            Ok(user)\n        }\n        Err(e) => {\n            error!(error = %e, \"Failed to create user\");\n            Err(e)\n        }\n    }\n}\n```\n\n## Metrics with Prometheus\n\n```toml\n[dependencies]\naxum-prometheus = \"0.6\"\n```\n\n```rust\nuse axum_prometheus::PrometheusMetricLayer;\n\nlet (prometheus_layer, metric_handle) = PrometheusMetricLayer::pair();\n\nlet app = Router::new()\n    .route(\"/\", get(handler))\n    .route(\"/metrics\", get(|| async move { metric_handle.render() }))\n    .layer(prometheus_layer);\n```\n\n## Error Tracking (Sentry)\n\n```toml\n[dependencies]\nsentry = \"0.32\"\n```\n\n```rust\nlet _guard = sentry::init((\"YOUR_SENTRY_DSN\", sentry::ClientOptions {\n    release: sentry::release_name!(),\n    ..Default::default()\n}));\n\n// Errors automatically tracked\nsentry::capture_error(&error);\n```\n\n## Key Takeaways\n\n- âœ… Use tracing for structured logging\n- âœ… Expose Prometheus metrics\n- âœ… Integrate error tracking (Sentry)\n- âœ… Monitor in production\n\n**Module 17 Complete!**\n\n---\n\n**Progress**: Module 17 complete! (81/90+ lessons total)\n"
          }
        }
      ]
    },
    {
      "id": "module-18",
      "title": "MODULE 18",
      "description": "Module 18",
      "difficulty": "advanced",
      "estimatedHours": 1,
      "lessons": [
        {
          "id": "lesson-18-01",
          "title": "Module 18: Full-Stack Capstone Project",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 18: Full-Stack Capstone Project\n\n# Lesson 1: Project Overview - Social Platform API\n\n## What We're Building\n\nA complete **social platform API** with:\n- User authentication (JWT)\n- User profiles\n- Posts with likes and comments\n- Follow/following system\n- Feed algorithm\n- Real-time notifications (WebSockets)\n- File uploads (profile pictures)\n- Full-text search\n- Rate limiting\n- Comprehensive tests\n- Docker deployment\n\n## Tech Stack\n\n**Backend:**\n- Rust + Axum 0.8\n- PostgreSQL + SQLx 0.8\n- JWT authentication\n- WebSockets for real-time\n- Redis for caching\n\n**Features:**\n- RESTful API\n- Role-based access control\n- Database migrations\n- API documentation (Swagger)\n- Monitoring and logging\n\n## Database Schema\n\n```sql\n-- Users\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    bio TEXT,\n    avatar_url VARCHAR(500),\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Posts\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER REFERENCES users(id),\n    content TEXT NOT NULL,\n    image_url VARCHAR(500),\n    likes_count INTEGER DEFAULT 0,\n    comments_count INTEGER DEFAULT 0,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Comments\nCREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    post_id INTEGER REFERENCES posts(id) ON DELETE CASCADE,\n    user_id INTEGER REFERENCES users(id),\n    content TEXT NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Likes\nCREATE TABLE post_likes (\n    user_id INTEGER REFERENCES users(id),\n    post_id INTEGER REFERENCES posts(id) ON DELETE CASCADE,\n    created_at TIMESTAMP DEFAULT NOW(),\n    PRIMARY KEY (user_id, post_id)\n);\n\n-- Follows\nCREATE TABLE follows (\n    follower_id INTEGER REFERENCES users(id),\n    following_id INTEGER REFERENCES users(id),\n    created_at TIMESTAMP DEFAULT NOW(),\n    PRIMARY KEY (follower_id, following_id),\n    CHECK (follower_id != following_id)\n);\n```\n\n## API Endpoints\n\n```\nPOST   /auth/register\nPOST   /auth/login\nPOST   /auth/logout\n\nGET    /users/{username}\nPUT    /users/me\nGET    /users/{username}/followers\nGET    /users/{username}/following\nPOST   /users/{username}/follow\nDELETE /users/{username}/follow\n\nGET    /posts\nGET    /posts/feed\nGET    /posts/{id}\nPOST   /posts\nPUT    /posts/{id}\nDELETE /posts/{id}\nPOST   /posts/{id}/like\nDELETE /posts/{id}/like\n\nGET    /posts/{id}/comments\nPOST   /posts/{id}/comments\nDELETE /comments/{id}\n\nGET    /search?q=...\n\nWS     /ws/notifications\n```\n\n## Project Structure\n\n```\nsocial_api/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ main.rs\nâ”‚   â”œâ”€â”€ config.rs\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”œâ”€â”€ handlers/\nâ”‚   â”œâ”€â”€ middleware/\nâ”‚   â”œâ”€â”€ services/\nâ”‚   â””â”€â”€ utils/\nâ”œâ”€â”€ migrations/\nâ”œâ”€â”€ tests/\nâ”œâ”€â”€ Dockerfile\nâ”œâ”€â”€ docker-compose.yml\nâ””â”€â”€ README.md\n```\n\n## Next Steps\n\n1. Set up project structure\n2. Implement authentication\n3. Build core features (posts, comments, likes)\n4. Add social features (follows, feed)\n5. Implement real-time notifications\n6. Add file uploads\n7. Write tests\n8. Deploy to production\n\n**Next**: Implementing the authentication system!\n\n---\n\n**Progress**: Module 18, Lesson 1 complete (82/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-18-02",
          "title": "Module 18: Full-Stack Capstone Project",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 18: Full-Stack Capstone Project\n\n# Lesson 2: Implementing Core Features\n\nThis lesson provides a complete implementation guide. Refer to previous modules for detailed explanations.\n\n## Posts Handler\n\n```rust\n// src/handlers/posts.rs\nuse axum::{extract::{State, Path}, Json};\nuse sqlx::PgPool;\n\npub async fn create_post(\n    State(pool): State<PgPool>,\n    user: CurrentUser,\n    Json(req): Json<CreatePostRequest>,\n) -> Result<Json<Post>, ApiError> {\n    let post = sqlx::query_as!(\n        Post,\n        r#\"\n        INSERT INTO posts (user_id, content, image_url)\n        VALUES ($1, $2, $3)\n        RETURNING *\n        \"#,\n        user.user_id,\n        req.content,\n        req.image_url\n    )\n    .fetch_one(&pool)\n    .await?;\n\n    Ok(Json(post))\n}\n\npub async fn like_post(\n    State(pool): State<PgPool>,\n    user: CurrentUser,\n    Path(post_id): Path<i32>,\n) -> Result<StatusCode, ApiError> {\n    // Insert like\n    sqlx::query!(\n        \"INSERT INTO post_likes (user_id, post_id) VALUES ($1, $2) ON CONFLICT DO NOTHING\",\n        user.user_id,\n        post_id\n    )\n    .execute(&pool)\n    .await?;\n\n    // Increment count\n    sqlx::query!(\"UPDATE posts SET likes_count = likes_count + 1 WHERE id = $1\", post_id)\n        .execute(&pool)\n        .await?;\n\n    Ok(StatusCode::OK)\n}\n```\n\n## Follow System\n\n```rust\npub async fn follow_user(\n    State(pool): State<PgPool>,\n    user: CurrentUser,\n    Path(username): Path<String>,\n) -> Result<StatusCode, ApiError> {\n    let target_user = get_user_by_username(&pool, &username).await?;\n\n    sqlx::query!(\n        \"INSERT INTO follows (follower_id, following_id) VALUES ($1, $2)\",\n        user.user_id,\n        target_user.id\n    )\n    .execute(&pool)\n    .await?;\n\n    Ok(StatusCode::OK)\n}\n```\n\n## Feed Algorithm\n\n```rust\npub async fn get_feed(\n    State(pool): State<PgPool>,\n    user: CurrentUser,\n) -> Result<Json<Vec<PostWithAuthor>>, ApiError> {\n    let posts = sqlx::query_as!(\n        PostWithAuthor,\n        r#\"\n        SELECT p.*, u.username, u.avatar_url\n        FROM posts p\n        JOIN users u ON p.user_id = u.id\n        WHERE p.user_id IN (\n            SELECT following_id FROM follows WHERE follower_id = $1\n        ) OR p.user_id = $1\n        ORDER BY p.created_at DESC\n        LIMIT 50\n        \"#,\n        user.user_id\n    )\n    .fetch_all(&pool)\n    .await?;\n\n    Ok(Json(posts))\n}\n```\n\n**Key Takeaways:**\n- âœ… Implement CRUD for posts\n- âœ… Like/unlike functionality\n- âœ… Follow system\n- âœ… Personalized feed\n\n**Next**: Real-time features and deployment!\n\n---\n\n**Progress**: Module 18, Lesson 2 complete (83/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-18-03",
          "title": "Module 18: Full-Stack Capstone Project",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 18: Full-Stack Capstone Project\n\n# Lesson 3: Real-Time Features & File Uploads\n\n## WebSocket Notifications\n\n```rust\nuse axum::extract::ws::{WebSocket, WebSocketUpgrade};\nuse tokio::sync::broadcast;\n\ntype NotificationChannel = broadcast::Sender<Notification>;\n\nasync fn ws_notifications(\n    ws: WebSocketUpgrade,\n    State(tx): State<Arc<NotificationChannel>>,\n    user: CurrentUser,\n) -> Response {\n    ws.on_upgrade(|socket| handle_notifications(socket, tx, user))\n}\n\nasync fn handle_notifications(\n    socket: WebSocket,\n    tx: Arc<NotificationChannel>,\n    user: CurrentUser,\n) {\n    let (mut sender, _) = socket.split();\n    let mut rx = tx.subscribe();\n\n    while let Ok(notification) = rx.recv().await {\n        if notification.user_id == user.user_id {\n            let msg = serde_json::to_string(&notification).unwrap();\n            if sender.send(Message::Text(msg)).await.is_err() {\n                break;\n            }\n        }\n    }\n}\n```\n\n## File Uploads\n\n```toml\n[dependencies]\ntower-http = { version = \"0.5\", features = [\"fs\"] }\nmulter = \"3.0\"\n```\n\n```rust\nuse axum::extract::Multipart;\n\nasync fn upload_avatar(\n    user: CurrentUser,\n    mut multipart: Multipart,\n) -> Result<Json<UploadResponse>, ApiError> {\n    while let Some(field) = multipart.next_field().await? {\n        if field.name() == Some(\"file\") {\n            let data = field.bytes().await?;\n            let filename = format!(\"avatars/{}.jpg\", user.user_id);\n\n            tokio::fs::write(&filename, data).await?;\n\n            return Ok(Json(UploadResponse {\n                url: format!(\"/uploads/{}\", filename),\n            }));\n        }\n    }\n\n    Err(ApiError::BadRequest(\"No file uploaded\".into()))\n}\n```\n\n**Key Takeaways:**\n- âœ… WebSocket notifications\n- âœ… File upload handling\n- âœ… Broadcast to connected clients\n\n**Next**: Testing and deployment!\n\n---\n\n**Progress**: Module 18, Lesson 3 complete (84/90+ lessons total)\n"
          }
        },
        {
          "id": "lesson-18-04",
          "title": "Module 18: Full-Stack Capstone Project",
          "type": "project",
          "estimatedMinutes": 5,
          "difficulty": "advanced",
          "content": {
            "format": "markdown",
            "body": "# Module 18: Full-Stack Capstone Project\n\n# Lesson 4: Testing, Documentation & Deployment\n\n## Integration Tests\n\n```rust\n#[sqlx::test]\nasync fn test_create_and_like_post(pool: PgPool) -> Result<()> {\n    let user = create_test_user(&pool).await?;\n    let post = create_post(&pool, user.id, \"Test post\").await?;\n\n    like_post(&pool, user.id, post.id).await?;\n\n    let likes = get_post_likes(&pool, post.id).await?;\n    assert_eq!(likes, 1);\n\n    Ok(())\n}\n```\n\n## API Documentation\n\nGenerate with `utoipa` and serve Swagger UI at `/swagger-ui`.\n\n## Docker Deployment\n\n```dockerfile\nFROM rust:1.75 as builder\nWORKDIR /app\nCOPY . .\nRUN cargo build --release\n\nFROM debian:bookworm-slim\nCOPY --from=builder /app/target/release/social_api /app/social_api\nEXPOSE 3000\nCMD [\"/app/social_api\"]\n```\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\nservices:\n  api:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - DATABASE_URL=postgresql://user:pass@db:5432/social\n      - JWT_SECRET=${JWT_SECRET}\n    depends_on:\n      - db\n      - redis\n\n  db:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: social\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: pass\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\n  redis:\n    image: redis:7\n\nvolumes:\n  postgres_data:\n```\n\nDeploy:\n\n```bash\ndocker-compose up --build\n```\n\n## Production Checklist\n\n- âœ… All tests passing\n- âœ… Environment variables for secrets\n- âœ… HTTPS enabled\n- âœ… Rate limiting configured\n- âœ… Monitoring and logging\n- âœ… Database backups\n- âœ… CI/CD pipeline\n- âœ… Documentation complete\n\n## Congratulations!\n\nYou've built a complete full-stack social platform API with:\n- âœ… Authentication & authorization\n- âœ… Database integration\n- âœ… Real-time features\n- âœ… File uploads\n- âœ… Comprehensive tests\n- âœ… Production deployment\n\n**You're now a Rust full-stack developer!** ðŸ¦€ðŸŽ‰\n\n---\n\n**Progress**: Module 18 complete! (85/90+ lessons total)\n\n**Course 100% Complete!** ðŸš€\n"
          }
        }
      ]
    }
  ],
  "metadata": {
    "version": "1.0.0",
    "lastUpdated": "2025-11-14",
    "author": "Code Tutor"
  }
}